(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-option :smt.qi.profile true)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@ref 0)
(declare-fun null () T@ref)
(declare-fun r1 () T@ref)
(declare-fun r2 () T@ref)
(declare-fun this () T@ref)
(declare-fun %lbl%+152 () Bool)
(declare-fun %lbl%@498 () Bool)
(declare-sort |T@[ref]Int| 0)
(declare-fun |Select_[ref]$int| (|T@[ref]Int| T@ref) Int)
(declare-fun heap@16 () |T@[ref]Int|)
(declare-fun %lbl%+150 () Bool)
(declare-fun heap@14 () |T@[ref]Int|)
(declare-fun %lbl%+148 () Bool)
(declare-fun heap@15 () |T@[ref]Int|)
(declare-fun |Store_[ref]$int| (|T@[ref]Int| T@ref Int) |T@[ref]Int|)
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?x2 Int)) (= (|Select_[ref]$int| (|Store_[ref]$int| ?x0 ?x1 ?x2) ?x1)  ?x2)))
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 Int)) (=>  (not (= ?x1 ?y1)) (= (|Select_[ref]$int| (|Store_[ref]$int| ?x0 ?x1 ?x2) ?y1) (|Select_[ref]$int| ?x0 ?y1)))))
(declare-fun %lbl%+146 () Bool)
(declare-fun heap@13 () |T@[ref]Int|)
(declare-fun %lbl%+144 () Bool)
(declare-fun heap@11 () |T@[ref]Int|)
(declare-fun %lbl%+142 () Bool)
(declare-fun heap@12 () |T@[ref]Int|)
(declare-fun %lbl%+140 () Bool)
(declare-fun heap@10 () |T@[ref]Int|)
(declare-fun %lbl%+138 () Bool)
(declare-fun heap@8 () |T@[ref]Int|)
(declare-fun %lbl%+136 () Bool)
(declare-fun heap@9 () |T@[ref]Int|)
(declare-fun %lbl%+134 () Bool)
(declare-fun heap@7 () |T@[ref]Int|)
(declare-fun %lbl%+132 () Bool)
(declare-fun heap@5 () |T@[ref]Int|)
(declare-fun %lbl%+130 () Bool)
(declare-fun heap@6 () |T@[ref]Int|)
(declare-fun %lbl%+128 () Bool)
(declare-fun heap@4 () |T@[ref]Int|)
(declare-fun %lbl%+126 () Bool)
(declare-fun heap@2 () |T@[ref]Int|)
(declare-fun %lbl%+124 () Bool)
(declare-fun heap@3 () |T@[ref]Int|)
(declare-fun %lbl%+122 () Bool)
(declare-fun heap@0 () |T@[ref]Int|)
(declare-fun heap () |T@[ref]Int|)
(declare-fun heap@1 () |T@[ref]Int|)
(declare-fun %lbl%@304 () Bool)
(declare-fun %lbl%+229 () Bool)
(assert (distinct null r1 r2 this)
)
(push 1)
(set-info :boogie-vc-id m1)
(assert (not
(let ((anon15_correct  (=> (! (and %lbl%+152 true) :lblpos +152) (! (or %lbl%@498 (= (|Select_[ref]$int| heap@16 r1) 1)) :lblneg @498))))
(let ((anon20_Else_correct  (=> (! (and %lbl%+150 true) :lblpos +150) (=> (= heap@16 heap@14) anon15_correct))))
(let ((anon20_Then_correct  (=> (! (and %lbl%+148 true) :lblpos +148) (=> (and (= heap@15 (|Store_[ref]$int| heap@14 r2 5)) (= heap@16 heap@15)) anon15_correct))))
(let ((anon12_correct  (=> (! (and %lbl%+146 true) :lblpos +146) (=> (= heap@14 (|Store_[ref]$int| heap@13 this 2)) (and anon20_Then_correct anon20_Else_correct)))))
(let ((anon19_Else_correct  (=> (! (and %lbl%+144 true) :lblpos +144) (=> (= heap@13 heap@11) anon12_correct))))
(let ((anon19_Then_correct  (=> (! (and %lbl%+142 true) :lblpos +142) (=> (and (= heap@12 (|Store_[ref]$int| heap@11 r2 6)) (= heap@13 heap@12)) anon12_correct))))
(let ((anon9_correct  (=> (! (and %lbl%+140 true) :lblpos +140) (=> (= heap@11 (|Store_[ref]$int| heap@10 this 1)) (and anon19_Then_correct anon19_Else_correct)))))
(let ((anon18_Else_correct  (=> (! (and %lbl%+138 true) :lblpos +138) (=> (= heap@10 heap@8) anon9_correct))))
(let ((anon18_Then_correct  (=> (! (and %lbl%+136 true) :lblpos +136) (=> (and (= heap@9 (|Store_[ref]$int| heap@8 r2 5)) (= heap@10 heap@9)) anon9_correct))))
(let ((anon6_correct  (=> (! (and %lbl%+134 true) :lblpos +134) (=> (= heap@8 (|Store_[ref]$int| heap@7 this 0)) (and anon18_Then_correct anon18_Else_correct)))))
(let ((anon17_Else_correct  (=> (! (and %lbl%+132 true) :lblpos +132) (=> (= heap@7 heap@5) anon6_correct))))
(let ((anon17_Then_correct  (=> (! (and %lbl%+130 true) :lblpos +130) (=> (and (= heap@6 (|Store_[ref]$int| heap@5 r2 4)) (= heap@7 heap@6)) anon6_correct))))
(let ((anon3_correct  (=> (! (and %lbl%+128 true) :lblpos +128) (=> (= heap@5 (|Store_[ref]$int| heap@4 this 1)) (and anon17_Then_correct anon17_Else_correct)))))
(let ((anon16_Else_correct  (=> (! (and %lbl%+126 true) :lblpos +126) (=> (= heap@4 heap@2) anon3_correct))))
(let ((anon16_Then_correct  (=> (! (and %lbl%+124 true) :lblpos +124) (=> (and (= heap@3 (|Store_[ref]$int| heap@2 r2 3)) (= heap@4 heap@3)) anon3_correct))))
(let ((anon0_correct  (=> (! (and %lbl%+122 true) :lblpos +122) (=> (and (= heap@0 (|Store_[ref]$int| heap r1 1)) (= heap@1 (|Store_[ref]$int| heap@0 r2 2))) (and (! (or %lbl%@304 (= (|Select_[ref]$int| heap@1 r1) 1)) :lblneg @304) (=> (= (|Select_[ref]$int| heap@1 r1) 1) (=> (= heap@2 (|Store_[ref]$int| heap@1 this 0)) (and anon16_Then_correct anon16_Else_correct))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+229 true) :lblpos +229) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
