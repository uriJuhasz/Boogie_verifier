(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun %lbl%+105 () Bool)
(declare-fun %lbl%@212 () Bool)
(declare-fun x@5 () Int)
(declare-fun %lbl%+83 () Bool)
(declare-fun b2 () Bool)
(declare-fun x@4 () Int)
(declare-fun x@2 () Int)
(declare-fun %lbl%+81 () Bool)
(declare-fun x@3 () Int)
(declare-fun %lbl%+72 () Bool)
(declare-fun b1 () Bool)
(declare-fun x@1 () Int)
(declare-fun %lbl%+70 () Bool)
(declare-fun x@0 () Int)
(declare-fun %lbl%+109 () Bool)
(push 1)
(set-info :boogie-vc-id m)
(assert (not
	(let ((GeneratedUnifiedExit_correct  (> x@5 0)))
		(let ((anon7_Else_correct  (=> (not b2) (=> (and (= x@4 (+ x@2 4)) (= x@5 x@4)) GeneratedUnifiedExit_correct))))
			(let ((anon7_Then_correct  (=> b2 (=> (and (= x@3 (+ x@2 3)) (= x@5 x@3)) GeneratedUnifiedExit_correct))))
				(let ((anon6_Else_correct  (=> (not b1) (=> (and (= x@1 (+ 0 2)) (= x@2 x@1)) (and anon7_Then_correct anon7_Else_correct)))))
					(let ((anon6_Then_correct  (=> b1 (=> (and (= x@0 (+ 0 1)) (= x@2 x@0)) (and anon7_Then_correct anon7_Else_correct)))))
						(let ((anon0_correct  ((and anon6_Then_correct anon6_Else_correct))))
							anon0_correct
						)
					)
				)
			)
		)
	)
))
(check-sat)
(pop 1)
; Valid

anon0_correct

anon0_correct                 <==> (anon6_Then_correct && anon6_Else_correct)
anon6_Then_correct            <==> (b1     => (((x@0 = (+ 0 1))   && (x@2 = x@0)) => (anon7_Then_correct && anon7_Else_correct)))
anon6_Else_correct            <==> (not b1 => (((x@1 = (+ 0 2))   && (x@2 = x@1)) => (anon7_Then_correct && anon7_Else_correct)))
anon7_Then_correct            <==> (b2     => (((x@3 = (+ x@2 3)) && (x@5 = x@3)) => GeneratedUnifiedExit_correct))
anon7_Else_correct            <==> (not b2 => (((x@4 = (+ x@2 4)) && (x@5 = x@4)) => GeneratedUnifiedExit_correct))
GeneratedUnifiedExit_correct  <==> (x@5 > 0)