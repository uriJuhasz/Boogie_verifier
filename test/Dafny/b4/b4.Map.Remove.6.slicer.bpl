type Integer = int;
type Boolean = bool;
type Set T = [T]bool;
type HeapType = <alpha>[ref,Field (alpha)]alpha;
type ref;
type Seq m0;
type BoxType;
type ClassName;
type DatatypeType;
type DtCtorId;
type Field m0;
type TickType;
const $$Language$Dafny : bool;
const null : ref;
const $ModuleContextHeight : int;
const $FunctionContextHeight : int;
const $InMethodContext : bool;
const unique alloc : Field (bool);
const unique class.Map : ClassName;
const unique Map.Keys : Field (Seq (BoxType));
const unique Map.Values : Field (Seq (BoxType));
const unique Map.Repr : Field (Set (BoxType) );
const unique Map.head : Field (ref);
const unique Map.nodes : Field (Seq (BoxType));
const unique class.Node : ClassName;
const unique Node.key : Field (BoxType);
const unique Node.val : Field (BoxType);
const unique Node.next : Field (ref);
function Set#Empty <T> () : Set (T) ;
function Set#Singleton <T> (T) : Set (T) ;
function Set#UnionOne <T> (Set (T) ,T) : Set (T) ;
function Set#Union <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Intersection <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Difference <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Equal <T> (Set (T) ,Set (T) ) : bool;
function Set#Disjoint <T> (Set (T) ,Set (T) ) : bool;
function Set#Choose <T> (Set (T) ,TickType) : T;
function Seq#Length <T> (Seq (T)) : int;
function Seq#Empty <T> () : Seq (T);
function Seq#Singleton <T> (T) : Seq (T);
function Seq#Build <T> (Seq (T),int,T,int) : Seq (T);
function Seq#Append <T> (Seq (T),Seq (T)) : Seq (T);
function Seq#Index <T> (Seq (T),int) : T;
function Seq#Update <T> (Seq (T),int,T) : Seq (T);
function Seq#Contains <T> (Seq (T),T) : bool;
function Seq#Equal <T> (Seq (T),Seq (T)) : bool;
function Seq#Take <T> (Seq (T),int) : Seq (T);
function Seq#Drop <T> (Seq (T),int) : Seq (T);
function $Box <T> (T) : BoxType;
function $Unbox <T> (BoxType) : T;
function $IsCanonicalBoolBox(BoxType) : bool;
function dtype(ref) : ClassName;
function TypeTuple(ClassName,ClassName) : ClassName;
function TypeTupleCar(ClassName) : ClassName;
function TypeTupleCdr(ClassName) : ClassName;
function DtType(DatatypeType) : ClassName;
function FDim <T> (Field (T)) : int;
function IndexField(int) : Field (BoxType);
function MultiIndexField(Field (BoxType),int) : Field (BoxType);
function MultiIndexField_Inverse0 <T> (Field (T)) : Field (T);
function MultiIndexField_Inverse1 <T> (Field (T)) : int;
function DeclType <T> (Field (T)) : ClassName;
function DtAlloc(DatatypeType,HeapType) : bool;
function GenericAlloc(BoxType,HeapType) : bool;
function $IsGoodHeap(HeapType) : bool;
function $HeapSucc(HeapType,HeapType) : bool;
function array.Length(ref) : int;
function Map.Valid(HeapType,ref) : bool;
function Map.Valid#canCall(HeapType,ref) : bool;
function lambda#8(Field (Set (BoxType) ),ref,HeapType,Field (bool),ref) : <alpha>[ref,Field (alpha)]bool;
var $Heap : HeapType;
var p#20 : ref;
var prev#22 : ref;
var $rhs#0 : ref;
var $rhs#2 : ref;
var $_Frame_$_0 : <beta>[ref,Field (beta)]bool;
var call4formal_$_p#24 : ref;
var call6formal_$_prev#26 : ref;
var $Heap_$_0 : HeapType;
var call4formal_$_p#24_$_0 : ref;
var call6formal_$_prev#26_$_0 : ref;
var call5formal_$_n#25_$_0 : int;
var $Heap_$_6 : HeapType;
var $rhs#3_$_0 : Seq (BoxType);
var $Heap_$_1 : HeapType;
var $rhs#4_$_0 : Seq (BoxType);
var $Heap_$_2 : HeapType;
var $rhs#5_$_0 : Seq (BoxType);
var $Heap_$_3 : HeapType;
var $rhs#7_$_0 : ref;
var $Heap_$_5 : HeapType;
var $rhs#6_$_0 : ref;
var $Heap_$_4 : HeapType;
var $_Frame : <beta>[ref,Field (beta)]bool;
var n#21 : int;
var $rhs#1 : int;
var key#36 : BoxType;
var $rhs#3 : Seq (BoxType);
var $rhs#4 : Seq (BoxType);
var $rhs#5 : Seq (BoxType);
var $rhs#6 : ref;
var $rhs#7 : ref;
var $Tick_$_0 : TickType;
procedure Map.Remove (this : ref,key#16 : BoxType)
{
	var p#20 : ref;
	var prev#22 : ref;
	var $rhs#0 : ref;
	var $rhs#2 : ref;
	var $_Frame_$_0 : <beta>[ref,Field (beta)]bool;
	var $Heap_$_0 : HeapType;
	var call4formal_$_p#24_$_0 : ref;
	var call5formal_$_n#25_$_0 : int;
	var call6formal_$_prev#26_$_0 : ref;
	var $rhs#3_$_0 : Seq (BoxType);
	var $Heap_$_1 : HeapType;
	var $rhs#4_$_0 : Seq (BoxType);
	var $Heap_$_2 : HeapType;
	var $rhs#5_$_0 : Seq (BoxType);
	var $Heap_$_3 : HeapType;
	var $rhs#6_$_0 : ref;
	var $Heap_$_4 : HeapType;
	var $rhs#7_$_0 : ref;
	var $Heap_$_5 : HeapType;
	var $Heap_$_6 : HeapType;
	var $_$_condition : bool;
	var $_$_condition_$0 : bool;
$start:
	assume $$Language$Dafny;
	assume (forall  o_$10 : BoxType :: {(Set#Empty() : Set (BoxType) )[o_$10]} ( !(Set#Empty() : Set (BoxType) )[o_$10] ));
	assume (forall  r_$1_$0 : BoxType :: {Set#Singleton(r_$1_$0)} ( Set#Singleton(r_$1_$0)[r_$1_$0] ));
	assume (forall  r_$2_$0 : BoxType, o_$0_$0 : BoxType :: {Set#Singleton(r_$2_$0)[o_$0_$0]} ( Set#Singleton(r_$2_$0)[o_$0_$0] <==> (r_$2_$0 == o_$0_$0) ));
	assume (forall  a_$22 : Set (BoxType) , x_$14 : BoxType, o_$1_$0 : BoxType :: {Set#UnionOne(a_$22,x_$14)[o_$1_$0]} ( Set#UnionOne(a_$22,x_$14)[o_$1_$0] <==> ((o_$1_$0 == x_$14) || a_$22[o_$1_$0]) ));
	assume (forall  a_$0_$0 : Set (BoxType) , x_$0_$0 : BoxType :: {Set#UnionOne(a_$0_$0,x_$0_$0)} ( Set#UnionOne(a_$0_$0,x_$0_$0)[x_$0_$0] ));
	assume (forall  a_$1_$0 : Set (BoxType) , x_$1_$0 : BoxType, y_$6 : BoxType :: {Set#UnionOne(a_$1_$0,x_$1_$0),a_$1_$0[y_$6]} ( a_$1_$0[y_$6] ==> Set#UnionOne(a_$1_$0,x_$1_$0)[y_$6] ));
	assume (forall  a_$2_$0 : Set (BoxType) , b_$29 : Set (BoxType) , o_$2_$0 : BoxType :: {Set#Union(a_$2_$0,b_$29)[o_$2_$0]} ( Set#Union(a_$2_$0,b_$29)[o_$2_$0] <==> (a_$2_$0[o_$2_$0] || b_$29[o_$2_$0]) ));
	assume (forall  a_$3_$0 : Set (BoxType) , b_$0_$0 : Set (BoxType) , y_$0_$0 : BoxType :: {Set#Union(a_$3_$0,b_$0_$0),a_$3_$0[y_$0_$0]} ( a_$3_$0[y_$0_$0] ==> Set#Union(a_$3_$0,b_$0_$0)[y_$0_$0] ));
	assume (forall  a_$4_$0 : Set (BoxType) , b_$1_$0 : Set (BoxType) , y_$1_$0 : BoxType :: {Set#Union(a_$4_$0,b_$1_$0),b_$1_$0[y_$1_$0]} ( b_$1_$0[y_$1_$0] ==> Set#Union(a_$4_$0,b_$1_$0)[y_$1_$0] ));
	assume (forall  a_$5_$0 : Set (BoxType) , b_$2_$0 : Set (BoxType)  :: {Set#Union(a_$5_$0,b_$2_$0)} ( Set#Disjoint(a_$5_$0,b_$2_$0) ==> ((Set#Difference(Set#Union(a_$5_$0,b_$2_$0),a_$5_$0) == b_$2_$0) && (Set#Difference(Set#Union(a_$5_$0,b_$2_$0),b_$2_$0) == a_$5_$0)) ));
	assume (forall  a_$6_$0 : Set (BoxType) , b_$3_$0 : Set (BoxType) , o_$3_$0 : BoxType :: {Set#Intersection(a_$6_$0,b_$3_$0)[o_$3_$0]} ( Set#Intersection(a_$6_$0,b_$3_$0)[o_$3_$0] <==> (a_$6_$0[o_$3_$0] && b_$3_$0[o_$3_$0]) ));
	assume (forall  a_$7_$0 : Set (BoxType) , b_$4_$0 : Set (BoxType)  :: {Set#Union(Set#Union(a_$7_$0,b_$4_$0),b_$4_$0)} ( Set#Union(Set#Union(a_$7_$0,b_$4_$0),b_$4_$0) == Set#Union(a_$7_$0,b_$4_$0) ));
	assume (forall  a_$8_$0 : Set (BoxType) , b_$5_$0 : Set (BoxType)  :: {Set#Union(a_$8_$0,Set#Union(a_$8_$0,b_$5_$0))} ( Set#Union(a_$8_$0,Set#Union(a_$8_$0,b_$5_$0)) == Set#Union(a_$8_$0,b_$5_$0) ));
	assume (forall  a_$9_$0 : Set (BoxType) , b_$6_$0 : Set (BoxType)  :: {Set#Intersection(Set#Intersection(a_$9_$0,b_$6_$0),b_$6_$0)} ( Set#Intersection(Set#Intersection(a_$9_$0,b_$6_$0),b_$6_$0) == Set#Intersection(a_$9_$0,b_$6_$0) ));
	assume (forall  a_$10_$0 : Set (BoxType) , b_$7_$0 : Set (BoxType)  :: {Set#Intersection(a_$10_$0,Set#Intersection(a_$10_$0,b_$7_$0))} ( Set#Intersection(a_$10_$0,Set#Intersection(a_$10_$0,b_$7_$0)) == Set#Intersection(a_$10_$0,b_$7_$0) ));
	assume (forall  a_$11_$0 : Set (BoxType) , b_$8_$0 : Set (BoxType) , o_$4_$0 : BoxType :: {Set#Difference(a_$11_$0,b_$8_$0)[o_$4_$0]} ( Set#Difference(a_$11_$0,b_$8_$0)[o_$4_$0] <==> (a_$11_$0[o_$4_$0] && (!b_$8_$0[o_$4_$0])) ));
	assume (forall  a_$12_$0 : Set (BoxType) , b_$9_$0 : Set (BoxType) , y_$2_$0 : BoxType :: {Set#Difference(a_$12_$0,b_$9_$0),b_$9_$0[y_$2_$0]} ( b_$9_$0[y_$2_$0] ==> (!Set#Difference(a_$12_$0,b_$9_$0)[y_$2_$0]) ));
	assume (forall  a_$14_$0 : Set (BoxType) , b_$11_$0 : Set (BoxType)  :: {Set#Equal(a_$14_$0,b_$11_$0)} ( Set#Equal(a_$14_$0,b_$11_$0) <==> ((forall  o_$6_$1 : BoxType :: {a_$14_$0[o_$6_$1]} {b_$11_$0[o_$6_$1]} ( a_$14_$0[o_$6_$1] <==> b_$11_$0[o_$6_$1] ))) ));
	assume (forall  a_$15_$0 : Set (BoxType) , b_$12_$0 : Set (BoxType)  :: {Set#Equal(a_$15_$0,b_$12_$0)} ( Set#Equal(a_$15_$0,b_$12_$0) ==> (a_$15_$0 == b_$12_$0) ));
	assume (forall  a_$16_$0 : Set (BoxType) , b_$13_$0 : Set (BoxType)  :: {Set#Disjoint(a_$16_$0,b_$13_$0)} ( Set#Disjoint(a_$16_$0,b_$13_$0) <==> ((forall  o_$7_$1 : BoxType :: {a_$16_$0[o_$7_$1]} {b_$13_$0[o_$7_$1]} ( (!a_$16_$0[o_$7_$1]) || (!b_$13_$0[o_$7_$1]) ))) ));
	assume (forall  a_$17_$0 : Set (BoxType) , tick_$0 : TickType :: {Set#Choose(a_$17_$0,tick_$0)} ( (!(a_$17_$0 == (Set#Empty() : Set (BoxType) ))) ==> a_$17_$0[Set#Choose(a_$17_$0,tick_$0)] ));
	assume ((forall  s_$14 : Seq (ref)  :: {Seq#Length(s_$14)} ( 0 <= Seq#Length(s_$14) ))) && ((forall  s_$15 : Seq (BoxType)  :: {Seq#Length(s_$15)} ( 0 <= Seq#Length(s_$15) )));
	assume (Seq#Length((Seq#Empty() : Seq (ref) )) == 0) && (Seq#Length((Seq#Empty() : Seq (BoxType) )) == 0);
	assume ((forall  s_$0_$0 : Seq (ref)  :: {Seq#Length(s_$0_$0)} ( (Seq#Length(s_$0_$0) == 0) ==> (s_$0_$0 == (Seq#Empty() : Seq (ref) )) ))) && ((forall  s_$0_$1 : Seq (BoxType)  :: {Seq#Length(s_$0_$1)} ( (Seq#Length(s_$0_$1) == 0) ==> (s_$0_$1 == (Seq#Empty() : Seq (BoxType) )) )));
	assume ((forall  t_$3 : ref :: {Seq#Length(Seq#Singleton(t_$3))} ( Seq#Length(Seq#Singleton(t_$3)) == 1 ))) && ((forall  t_$4 : BoxType :: {Seq#Length(Seq#Singleton(t_$4))} ( Seq#Length(Seq#Singleton(t_$4)) == 1 )));
	assume ((forall  s_$1_$0 : Seq (ref) , i_$12 : Integer, v_$0_$0 : ref, len_$2 : Integer :: {Seq#Length(Seq#Build(s_$1_$0,i_$12,v_$0_$0,len_$2))} ( (0 <= len_$2) ==> (Seq#Length(Seq#Build(s_$1_$0,i_$12,v_$0_$0,len_$2)) == len_$2) ))) && ((forall  s_$1_$1 : Seq (BoxType) , i_$13 : Integer, v_$0_$1 : BoxType, len_$3 : Integer :: {Seq#Length(Seq#Build(s_$1_$1,i_$13,v_$0_$1,len_$3))} ( (0 <= len_$3) ==> (Seq#Length(Seq#Build(s_$1_$1,i_$13,v_$0_$1,len_$3)) == len_$3) )));
	assume ((forall  s0_$4 : Seq (ref) , s1_$4 : Seq (ref)  :: {Seq#Length(Seq#Append(s0_$4,s1_$4))} ( Seq#Length(Seq#Append(s0_$4,s1_$4)) == (Seq#Length(s0_$4) + Seq#Length(s1_$4)) ))) && ((forall  s0_$5 : Seq (BoxType) , s1_$5 : Seq (BoxType)  :: {Seq#Length(Seq#Append(s0_$5,s1_$5))} ( Seq#Length(Seq#Append(s0_$5,s1_$5)) == (Seq#Length(s0_$5) + Seq#Length(s1_$5)) )));
	assume ((forall  t_$0_$0 : ref :: {Seq#Index(Seq#Singleton(t_$0_$0),0)} ( Seq#Index(Seq#Singleton(t_$0_$0),0) == t_$0_$0 ))) && ((forall  t_$0_$1 : BoxType :: {Seq#Index(Seq#Singleton(t_$0_$1),0)} ( Seq#Index(Seq#Singleton(t_$0_$1),0) == t_$0_$1 )));
	assume ((forall  s0_$0_$0 : Seq (ref) , s1_$0_$0 : Seq (ref) , n_$9 : Integer :: {Seq#Index(Seq#Append(s0_$0_$0,s1_$0_$0),n_$9)} ( ((n_$9 < Seq#Length(s0_$0_$0)) ==> (Seq#Index(Seq#Append(s0_$0_$0,s1_$0_$0),n_$9) == Seq#Index(s0_$0_$0,n_$9))) && ((Seq#Length(s0_$0_$0) <= n_$9) ==> (Seq#Index(Seq#Append(s0_$0_$0,s1_$0_$0),n_$9) == Seq#Index(s1_$0_$0,n_$9 - Seq#Length(s0_$0_$0)))) ))) && ((forall  s0_$0_$1 : Seq (BoxType) , s1_$0_$1 : Seq (BoxType) , n_$10 : Integer :: {Seq#Index(Seq#Append(s0_$0_$1,s1_$0_$1),n_$10)} ( ((n_$10 < Seq#Length(s0_$0_$1)) ==> (Seq#Index(Seq#Append(s0_$0_$1,s1_$0_$1),n_$10) == Seq#Index(s0_$0_$1,n_$10))) && ((Seq#Length(s0_$0_$1) <= n_$10) ==> (Seq#Index(Seq#Append(s0_$0_$1,s1_$0_$1),n_$10) == Seq#Index(s1_$0_$1,n_$10 - Seq#Length(s0_$0_$1)))) )));
	assume ((forall  s_$2_$0 : Seq (ref) , i_$0_$0 : Integer, v_$1_$0 : ref, len_$0_$0 : Integer, n_$0_$0 : Integer :: {Seq#Index(Seq#Build(s_$2_$0,i_$0_$0,v_$1_$0,len_$0_$0),n_$0_$0)} ( ((0 <= n_$0_$0) && (n_$0_$0 < len_$0_$0)) ==> (((i_$0_$0 == n_$0_$0) ==> (Seq#Index(Seq#Build(s_$2_$0,i_$0_$0,v_$1_$0,len_$0_$0),n_$0_$0) == v_$1_$0)) && ((!(i_$0_$0 == n_$0_$0)) ==> (Seq#Index(Seq#Build(s_$2_$0,i_$0_$0,v_$1_$0,len_$0_$0),n_$0_$0) == Seq#Index(s_$2_$0,n_$0_$0)))) ))) && ((forall  s_$2_$1 : Seq (BoxType) , i_$0_$1 : Integer, v_$1_$1 : BoxType, len_$0_$1 : Integer, n_$0_$1 : Integer :: {Seq#Index(Seq#Build(s_$2_$1,i_$0_$1,v_$1_$1,len_$0_$1),n_$0_$1)} ( ((0 <= n_$0_$1) && (n_$0_$1 < len_$0_$1)) ==> (((i_$0_$1 == n_$0_$1) ==> (Seq#Index(Seq#Build(s_$2_$1,i_$0_$1,v_$1_$1,len_$0_$1),n_$0_$1) == v_$1_$1)) && ((!(i_$0_$1 == n_$0_$1)) ==> (Seq#Index(Seq#Build(s_$2_$1,i_$0_$1,v_$1_$1,len_$0_$1),n_$0_$1) == Seq#Index(s_$2_$1,n_$0_$1)))) )));
	assume ((forall  s_$3_$0 : Seq (ref) , i_$1_$0 : Integer, v_$2_$0 : ref :: {Seq#Length(Seq#Update(s_$3_$0,i_$1_$0,v_$2_$0))} ( ((0 <= i_$1_$0) && (i_$1_$0 < Seq#Length(s_$3_$0))) ==> (Seq#Length(Seq#Update(s_$3_$0,i_$1_$0,v_$2_$0)) == Seq#Length(s_$3_$0)) ))) && ((forall  s_$3_$1 : Seq (BoxType) , i_$1_$1 : Integer, v_$2_$1 : BoxType :: {Seq#Length(Seq#Update(s_$3_$1,i_$1_$1,v_$2_$1))} ( ((0 <= i_$1_$1) && (i_$1_$1 < Seq#Length(s_$3_$1))) ==> (Seq#Length(Seq#Update(s_$3_$1,i_$1_$1,v_$2_$1)) == Seq#Length(s_$3_$1)) )));
	assume ((forall  s_$4_$0 : Seq (ref) , i_$2_$0 : Integer, v_$3_$0 : ref, n_$1_$0 : Integer :: {Seq#Index(Seq#Update(s_$4_$0,i_$2_$0,v_$3_$0),n_$1_$0)} ( ((0 <= n_$1_$0) && (n_$1_$0 < Seq#Length(s_$4_$0))) ==> (((i_$2_$0 == n_$1_$0) ==> (Seq#Index(Seq#Update(s_$4_$0,i_$2_$0,v_$3_$0),n_$1_$0) == v_$3_$0)) && ((!(i_$2_$0 == n_$1_$0)) ==> (Seq#Index(Seq#Update(s_$4_$0,i_$2_$0,v_$3_$0),n_$1_$0) == Seq#Index(s_$4_$0,n_$1_$0)))) ))) && ((forall  s_$4_$1 : Seq (BoxType) , i_$2_$1 : Integer, v_$3_$1 : BoxType, n_$1_$1 : Integer :: {Seq#Index(Seq#Update(s_$4_$1,i_$2_$1,v_$3_$1),n_$1_$1)} ( ((0 <= n_$1_$1) && (n_$1_$1 < Seq#Length(s_$4_$1))) ==> (((i_$2_$1 == n_$1_$1) ==> (Seq#Index(Seq#Update(s_$4_$1,i_$2_$1,v_$3_$1),n_$1_$1) == v_$3_$1)) && ((!(i_$2_$1 == n_$1_$1)) ==> (Seq#Index(Seq#Update(s_$4_$1,i_$2_$1,v_$3_$1),n_$1_$1) == Seq#Index(s_$4_$1,n_$1_$1)))) )));
	assume ((forall  s_$5_$0 : Seq (ref) , x_$2_$0 : ref :: {Seq#Contains(s_$5_$0,x_$2_$0)} ( Seq#Contains(s_$5_$0,x_$2_$0) <==> ((exists  i_$3_$1 : Integer :: {Seq#Index(s_$5_$0,i_$3_$1)} ( ((0 <= i_$3_$1) && (i_$3_$1 < Seq#Length(s_$5_$0))) && (Seq#Index(s_$5_$0,i_$3_$1) == x_$2_$0) ))) ))) && ((forall  s_$5_$1 : Seq (BoxType) , x_$2_$1 : BoxType :: {Seq#Contains(s_$5_$1,x_$2_$1)} ( Seq#Contains(s_$5_$1,x_$2_$1) <==> ((exists  i_$3_$3 : Integer :: {Seq#Index(s_$5_$1,i_$3_$3)} ( ((0 <= i_$3_$3) && (i_$3_$3 < Seq#Length(s_$5_$1))) && (Seq#Index(s_$5_$1,i_$3_$3) == x_$2_$1) ))) )));
	assume (forall  x_$3 : ref :: {Seq#Contains((Seq#Empty() : Seq (ref) ),x_$3)} ( !Seq#Contains((Seq#Empty() : Seq (ref) ),x_$3) ));
	assume ((forall  s0_$1_$0 : Seq (ref) , s1_$1_$0 : Seq (ref) , x_$4_$0 : ref :: {Seq#Contains(Seq#Append(s0_$1_$0,s1_$1_$0),x_$4_$0)} ( Seq#Contains(Seq#Append(s0_$1_$0,s1_$1_$0),x_$4_$0) <==> (Seq#Contains(s0_$1_$0,x_$4_$0) || Seq#Contains(s1_$1_$0,x_$4_$0)) ))) && ((forall  s0_$1_$1 : Seq (BoxType) , s1_$1_$1 : Seq (BoxType) , x_$4_$1 : BoxType :: {Seq#Contains(Seq#Append(s0_$1_$1,s1_$1_$1),x_$4_$1)} ( Seq#Contains(Seq#Append(s0_$1_$1,s1_$1_$1),x_$4_$1) <==> (Seq#Contains(s0_$1_$1,x_$4_$1) || Seq#Contains(s1_$1_$1,x_$4_$1)) )));
	assume ((forall  s_$6_$0 : Seq (ref) , i_$4_$0 : Integer, v_$4_$0 : ref, len_$1_$0 : Integer, x_$5_$0 : ref :: {Seq#Contains(Seq#Build(s_$6_$0,i_$4_$0,v_$4_$0,len_$1_$0),x_$5_$0)} ( Seq#Contains(Seq#Build(s_$6_$0,i_$4_$0,v_$4_$0,len_$1_$0),x_$5_$0) <==> ((((0 <= i_$4_$0) && (i_$4_$0 < len_$1_$0)) && (x_$5_$0 == v_$4_$0)) || ((exists  j_$5 : Integer :: {Seq#Index(s_$6_$0,j_$5)} ( ((((0 <= j_$5) && (j_$5 < Seq#Length(s_$6_$0))) && (j_$5 < len_$1_$0)) && (!(j_$5 == i_$4_$0))) && (Seq#Index(s_$6_$0,j_$5) == x_$5_$0) )))) ))) && ((forall  s_$6_$1 : Seq (BoxType) , i_$4_$1 : Integer, v_$4_$1 : BoxType, len_$1_$1 : Integer, x_$5_$1 : BoxType :: {Seq#Contains(Seq#Build(s_$6_$1,i_$4_$1,v_$4_$1,len_$1_$1),x_$5_$1)} ( Seq#Contains(Seq#Build(s_$6_$1,i_$4_$1,v_$4_$1,len_$1_$1),x_$5_$1) <==> ((((0 <= i_$4_$1) && (i_$4_$1 < len_$1_$1)) && (x_$5_$1 == v_$4_$1)) || ((exists  j_$7 : Integer :: {Seq#Index(s_$6_$1,j_$7)} ( ((((0 <= j_$7) && (j_$7 < Seq#Length(s_$6_$1))) && (j_$7 < len_$1_$1)) && (!(j_$7 == i_$4_$1))) && (Seq#Index(s_$6_$1,j_$7) == x_$5_$1) )))) )));
	assume ((forall  s_$7_$0 : Seq (ref) , n_$2_$0 : Integer, x_$6_$0 : ref :: {Seq#Contains(Seq#Take(s_$7_$0,n_$2_$0),x_$6_$0)} ( Seq#Contains(Seq#Take(s_$7_$0,n_$2_$0),x_$6_$0) <==> ((exists  i_$5_$1 : Integer :: {Seq#Index(s_$7_$0,i_$5_$1)} ( (((0 <= i_$5_$1) && (i_$5_$1 < n_$2_$0)) && (i_$5_$1 < Seq#Length(s_$7_$0))) && (Seq#Index(s_$7_$0,i_$5_$1) == x_$6_$0) ))) ))) && ((forall  s_$7_$1 : Seq (BoxType) , n_$2_$1 : Integer, x_$6_$1 : BoxType :: {Seq#Contains(Seq#Take(s_$7_$1,n_$2_$1),x_$6_$1)} ( Seq#Contains(Seq#Take(s_$7_$1,n_$2_$1),x_$6_$1) <==> ((exists  i_$5_$3 : Integer :: {Seq#Index(s_$7_$1,i_$5_$3)} ( (((0 <= i_$5_$3) && (i_$5_$3 < n_$2_$1)) && (i_$5_$3 < Seq#Length(s_$7_$1))) && (Seq#Index(s_$7_$1,i_$5_$3) == x_$6_$1) ))) )));
	assume ((forall  s_$8_$0 : Seq (ref) , n_$3_$0 : Integer, x_$7_$0 : ref :: {Seq#Contains(Seq#Drop(s_$8_$0,n_$3_$0),x_$7_$0)} ( Seq#Contains(Seq#Drop(s_$8_$0,n_$3_$0),x_$7_$0) <==> ((exists  i_$6_$1 : Integer :: {Seq#Index(s_$8_$0,i_$6_$1)} ( (((0 <= n_$3_$0) && (n_$3_$0 <= i_$6_$1)) && (i_$6_$1 < Seq#Length(s_$8_$0))) && (Seq#Index(s_$8_$0,i_$6_$1) == x_$7_$0) ))) ))) && ((forall  s_$8_$1 : Seq (BoxType) , n_$3_$1 : Integer, x_$7_$1 : BoxType :: {Seq#Contains(Seq#Drop(s_$8_$1,n_$3_$1),x_$7_$1)} ( Seq#Contains(Seq#Drop(s_$8_$1,n_$3_$1),x_$7_$1) <==> ((exists  i_$6_$3 : Integer :: {Seq#Index(s_$8_$1,i_$6_$3)} ( (((0 <= n_$3_$1) && (n_$3_$1 <= i_$6_$3)) && (i_$6_$3 < Seq#Length(s_$8_$1))) && (Seq#Index(s_$8_$1,i_$6_$3) == x_$7_$1) ))) )));
	assume ((forall  s0_$2_$0 : Seq (ref) , s1_$2_$0 : Seq (ref)  :: {Seq#Equal(s0_$2_$0,s1_$2_$0)} ( Seq#Equal(s0_$2_$0,s1_$2_$0) <==> ((Seq#Length(s0_$2_$0) == Seq#Length(s1_$2_$0)) && ((forall  j_$0_$1 : Integer :: {Seq#Index(s0_$2_$0,j_$0_$1)} {Seq#Index(s1_$2_$0,j_$0_$1)} ( ((0 <= j_$0_$1) && (j_$0_$1 < Seq#Length(s0_$2_$0))) ==> (Seq#Index(s0_$2_$0,j_$0_$1) == Seq#Index(s1_$2_$0,j_$0_$1)) )))) ))) && ((forall  s0_$2_$1 : Seq (BoxType) , s1_$2_$1 : Seq (BoxType)  :: {Seq#Equal(s0_$2_$1,s1_$2_$1)} ( Seq#Equal(s0_$2_$1,s1_$2_$1) <==> ((Seq#Length(s0_$2_$1) == Seq#Length(s1_$2_$1)) && ((forall  j_$0_$3 : Integer :: {Seq#Index(s0_$2_$1,j_$0_$3)} {Seq#Index(s1_$2_$1,j_$0_$3)} ( ((0 <= j_$0_$3) && (j_$0_$3 < Seq#Length(s0_$2_$1))) ==> (Seq#Index(s0_$2_$1,j_$0_$3) == Seq#Index(s1_$2_$1,j_$0_$3)) )))) )));
	assume ((forall  a_$18_$0 : Seq (ref) , b_$14_$0 : Seq (ref)  :: {Seq#Equal(a_$18_$0,b_$14_$0)} ( Seq#Equal(a_$18_$0,b_$14_$0) ==> (a_$18_$0 == b_$14_$0) ))) && ((forall  a_$18_$1 : Seq (BoxType) , b_$14_$1 : Seq (BoxType)  :: {Seq#Equal(a_$18_$1,b_$14_$1)} ( Seq#Equal(a_$18_$1,b_$14_$1) ==> (a_$18_$1 == b_$14_$1) )));
	assume ((forall  s_$9_$0 : Seq (ref) , n_$5_$0 : Integer :: {Seq#Length(Seq#Take(s_$9_$0,n_$5_$0))} ( (0 <= n_$5_$0) ==> (((n_$5_$0 <= Seq#Length(s_$9_$0)) ==> (Seq#Length(Seq#Take(s_$9_$0,n_$5_$0)) == n_$5_$0)) && ((Seq#Length(s_$9_$0) < n_$5_$0) ==> (Seq#Length(Seq#Take(s_$9_$0,n_$5_$0)) == Seq#Length(s_$9_$0)))) ))) && ((forall  s_$9_$1 : Seq (BoxType) , n_$5_$1 : Integer :: {Seq#Length(Seq#Take(s_$9_$1,n_$5_$1))} ( (0 <= n_$5_$1) ==> (((n_$5_$1 <= Seq#Length(s_$9_$1)) ==> (Seq#Length(Seq#Take(s_$9_$1,n_$5_$1)) == n_$5_$1)) && ((Seq#Length(s_$9_$1) < n_$5_$1) ==> (Seq#Length(Seq#Take(s_$9_$1,n_$5_$1)) == Seq#Length(s_$9_$1)))) )));
	assume ((forall  s_$10_$0 : Seq (ref) , n_$6_$0 : Integer, j_$2_$0 : Integer :: {Seq#Index(Seq#Take(s_$10_$0,n_$6_$0),j_$2_$0)} {:weight  25}( (((0 <= j_$2_$0) && (j_$2_$0 < n_$6_$0)) && (j_$2_$0 < Seq#Length(s_$10_$0))) ==> (Seq#Index(Seq#Take(s_$10_$0,n_$6_$0),j_$2_$0) == Seq#Index(s_$10_$0,j_$2_$0)) ))) && ((forall  s_$10_$1 : Seq (BoxType) , n_$6_$1 : Integer, j_$2_$1 : Integer :: {Seq#Index(Seq#Take(s_$10_$1,n_$6_$1),j_$2_$1)} {:weight  25}( (((0 <= j_$2_$1) && (j_$2_$1 < n_$6_$1)) && (j_$2_$1 < Seq#Length(s_$10_$1))) ==> (Seq#Index(Seq#Take(s_$10_$1,n_$6_$1),j_$2_$1) == Seq#Index(s_$10_$1,j_$2_$1)) )));
	assume ((forall  s_$11_$0 : Seq (ref) , n_$7_$0 : Integer :: {Seq#Length(Seq#Drop(s_$11_$0,n_$7_$0))} ( (0 <= n_$7_$0) ==> (((n_$7_$0 <= Seq#Length(s_$11_$0)) ==> (Seq#Length(Seq#Drop(s_$11_$0,n_$7_$0)) == (Seq#Length(s_$11_$0) - n_$7_$0))) && ((Seq#Length(s_$11_$0) < n_$7_$0) ==> (Seq#Length(Seq#Drop(s_$11_$0,n_$7_$0)) == 0))) ))) && ((forall  s_$11_$1 : Seq (BoxType) , n_$7_$1 : Integer :: {Seq#Length(Seq#Drop(s_$11_$1,n_$7_$1))} ( (0 <= n_$7_$1) ==> (((n_$7_$1 <= Seq#Length(s_$11_$1)) ==> (Seq#Length(Seq#Drop(s_$11_$1,n_$7_$1)) == (Seq#Length(s_$11_$1) - n_$7_$1))) && ((Seq#Length(s_$11_$1) < n_$7_$1) ==> (Seq#Length(Seq#Drop(s_$11_$1,n_$7_$1)) == 0))) )));
	assume ((forall  s_$12_$0 : Seq (ref) , n_$8_$0 : Integer, j_$3_$0 : Integer :: {Seq#Index(Seq#Drop(s_$12_$0,n_$8_$0),j_$3_$0)} {:weight  25}( (((0 <= n_$8_$0) && (0 <= j_$3_$0)) && (j_$3_$0 < (Seq#Length(s_$12_$0) - n_$8_$0))) ==> (Seq#Index(Seq#Drop(s_$12_$0,n_$8_$0),j_$3_$0) == Seq#Index(s_$12_$0,j_$3_$0 + n_$8_$0)) ))) && ((forall  s_$12_$1 : Seq (BoxType) , n_$8_$1 : Integer, j_$3_$1 : Integer :: {Seq#Index(Seq#Drop(s_$12_$1,n_$8_$1),j_$3_$1)} {:weight  25}( (((0 <= n_$8_$1) && (0 <= j_$3_$1)) && (j_$3_$1 < (Seq#Length(s_$12_$1) - n_$8_$1))) ==> (Seq#Index(Seq#Drop(s_$12_$1,n_$8_$1),j_$3_$1) == Seq#Index(s_$12_$1,j_$3_$1 + n_$8_$1)) )));
	assume ((forall  s_$13_$0 : Seq (ref) , t_$1_$0 : Seq (ref)  :: {Seq#Append(s_$13_$0,t_$1_$0)} ( (Seq#Take(Seq#Append(s_$13_$0,t_$1_$0),Seq#Length(s_$13_$0)) == s_$13_$0) && (Seq#Drop(Seq#Append(s_$13_$0,t_$1_$0),Seq#Length(s_$13_$0)) == t_$1_$0) ))) && ((forall  s_$13_$1 : Seq (BoxType) , t_$1_$1 : Seq (BoxType)  :: {Seq#Append(s_$13_$1,t_$1_$1)} ( (Seq#Take(Seq#Append(s_$13_$1,t_$1_$1),Seq#Length(s_$13_$1)) == s_$13_$1) && (Seq#Drop(Seq#Append(s_$13_$1,t_$1_$1),Seq#Length(s_$13_$1)) == t_$1_$1) )));
	assume (((((((((((((((((forall  x_$8_$0 : Boolean :: {$Box(x_$8_$0)} ( ($Unbox($Box(x_$8_$0)) : Boolean) == x_$8_$0 ))) && ((forall  x_$8_$1 : TickType :: {$Box(x_$8_$1)} ( ($Unbox($Box(x_$8_$1)) : TickType) == x_$8_$1 )))) && ((forall  x_$8_$2 : Integer :: {$Box(x_$8_$2)} ( ($Unbox($Box(x_$8_$2)) : Integer) == x_$8_$2 )))) && ((forall  x_$8_$3 : Seq (ref)  :: {$Box(x_$8_$3)} ( ($Unbox($Box(x_$8_$3)) : Seq (ref) ) == x_$8_$3 )))) && ((forall  x_$8_$4 : ref :: {$Box(x_$8_$4)} ( ($Unbox($Box(x_$8_$4)) : ref) == x_$8_$4 )))) && ((forall  x_$8_$5 : BoxType :: {$Box(x_$8_$5)} ( ($Unbox($Box(x_$8_$5)) : BoxType) == x_$8_$5 )))) && ((forall  x_$8_$6 : [BoxType]Boolean :: {$Box(x_$8_$6)} ( ($Unbox($Box(x_$8_$6)) : [BoxType]Boolean) == x_$8_$6 )))) && ((forall  x_$8_$7 : Seq (BoxType)  :: {$Box(x_$8_$7)} ( ($Unbox($Box(x_$8_$7)) : Seq (BoxType) ) == x_$8_$7 )))) && ((forall  x_$8_$8 : DatatypeType :: {$Box(x_$8_$8)} ( ($Unbox($Box(x_$8_$8)) : DatatypeType) == x_$8_$8 )))) && ((forall  x_$8_$9 : ClassName :: {$Box(x_$8_$9)} ( ($Unbox($Box(x_$8_$9)) : ClassName) == x_$8_$9 )))) && ((forall  x_$8_$10 : Field (BoxType)  :: {$Box(x_$8_$10)} ( ($Unbox($Box(x_$8_$10)) : Field (BoxType) ) == x_$8_$10 )))) && ((forall  x_$8_$11 : Field (Boolean)  :: {$Box(x_$8_$11)} ( ($Unbox($Box(x_$8_$11)) : Field (Boolean) ) == x_$8_$11 )))) && ((forall  x_$8_$12 : HeapType :: {$Box(x_$8_$12)} ( ($Unbox($Box(x_$8_$12)) : HeapType) == x_$8_$12 )))) && ((forall  x_$8_$13 : Field (Seq (BoxType) )  :: {$Box(x_$8_$13)} ( ($Unbox($Box(x_$8_$13)) : Field (Seq (BoxType) ) ) == x_$8_$13 )))) && ((forall  x_$8_$14 : Field (Set (BoxType) )  :: {$Box(x_$8_$14)} ( ($Unbox($Box(x_$8_$14)) : Field (Set (BoxType) ) ) == x_$8_$14 )))) && ((forall  x_$8_$15 : Field (ref)  :: {$Box(x_$8_$15)} ( ($Unbox($Box(x_$8_$15)) : Field (ref) ) == x_$8_$15 )))) && ((forall  x_$8_$16 : <v0>[ref,Field (v0) ]Boolean :: {$Box(x_$8_$16)} ( ($Unbox($Box(x_$8_$16)) : <v0>[ref,Field (v0) ]Boolean) == x_$8_$16 )));
	assume (forall  b_$15 : BoxType :: {($Unbox(b_$15) : Integer)} ( $Box(($Unbox(b_$15) : Integer)) == b_$15 ));
	assume (forall  b_$16 : BoxType :: {($Unbox(b_$16) : ref)} ( $Box(($Unbox(b_$16) : ref)) == b_$16 ));
	assume (forall  b_$17 : BoxType :: {($Unbox(b_$17) : [BoxType]Boolean)} ( $Box(($Unbox(b_$17) : [BoxType]Boolean)) == b_$17 ));
	assume (forall  b_$18 : BoxType :: {($Unbox(b_$18) : Seq (BoxType) )} ( $Box(($Unbox(b_$18) : Seq (BoxType) )) == b_$18 ));
	assume (forall  b_$19 : BoxType :: {($Unbox(b_$19) : DatatypeType)} ( $Box(($Unbox(b_$19) : DatatypeType)) == b_$19 ));
	assume $IsCanonicalBoolBox($Box(false)) && $IsCanonicalBoolBox($Box(true));
	assume (forall  b_$20 : BoxType :: {($Unbox(b_$20) : Boolean)} ( $IsCanonicalBoolBox(b_$20) ==> ($Box(($Unbox(b_$20) : Boolean)) == b_$20) ));
	assume (forall  a_$19 : ClassName, b_$21 : ClassName :: {TypeTuple(a_$19,b_$21)} ( (TypeTupleCar(TypeTuple(a_$19,b_$21)) == a_$19) && (TypeTupleCdr(TypeTuple(a_$19,b_$21)) == b_$21) ));
	assume (forall  i_$7 : Integer :: {IndexField(i_$7)} ( FDim(IndexField(i_$7)) == 1 ));
	assume (forall  f_$1 : Field (BoxType) , i_$9 : Integer :: {MultiIndexField(f_$1,i_$9)} ( FDim(MultiIndexField(f_$1,i_$9)) == (FDim(f_$1) + 1) ));
	assume (forall  f_$2 : Field (BoxType) , i_$10 : Integer :: {MultiIndexField(f_$2,i_$10)} ( (MultiIndexField_Inverse0(MultiIndexField(f_$2,i_$10)) == f_$2) && (MultiIndexField_Inverse1(MultiIndexField(f_$2,i_$10)) == i_$10) ));
	assume FDim(alloc) == 0;
	assume (forall  h : HeapType, k : HeapType, d : DatatypeType :: {$HeapSucc(h,k),DtAlloc(d,h)} {$HeapSucc(h,k),DtAlloc(d,k)} ( $HeapSucc(h,k) ==> (DtAlloc(d,h) ==> DtAlloc(d,k)) ));
	assume (forall  h_$0 : HeapType, k_$0 : HeapType, d_$0 : BoxType :: {$HeapSucc(h_$0,k_$0),GenericAlloc(d_$0,h_$0)} {$HeapSucc(h_$0,k_$0),GenericAlloc(d_$0,k_$0)} ( $HeapSucc(h_$0,k_$0) ==> (GenericAlloc(d_$0,h_$0) ==> GenericAlloc(d_$0,k_$0)) ));
	assume (forall  b_$22 : BoxType, h_$1 : HeapType :: {GenericAlloc(b_$22,h_$1),h_$1[($Unbox(b_$22) : ref),alloc]} ( GenericAlloc(b_$22,h_$1) ==> ((($Unbox(b_$22) : ref) == null) || h_$1[($Unbox(b_$22) : ref),alloc]) ));
	assume (forall  b_$23 : BoxType, h_$2 : HeapType, i_$11 : Integer :: {GenericAlloc(b_$23,h_$2),Seq#Index(($Unbox(b_$23) : Seq (BoxType) ),i_$11)} ( ((GenericAlloc(b_$23,h_$2) && (0 <= i_$11)) && (i_$11 < Seq#Length(($Unbox(b_$23) : Seq (BoxType) )))) ==> GenericAlloc(Seq#Index(($Unbox(b_$23) : Seq (BoxType) ),i_$11),h_$2) ));
	assume (forall  b_$24 : BoxType, h_$3 : HeapType, t_$2 : BoxType :: {GenericAlloc(b_$24,h_$3),($Unbox(b_$24) : [BoxType]Boolean)[t_$2]} ( (GenericAlloc(b_$24,h_$3) && ($Unbox(b_$24) : [BoxType]Boolean)[t_$2]) ==> GenericAlloc(t_$2,h_$3) ));
	assume (forall  b_$25 : BoxType, h_$4 : HeapType :: {GenericAlloc(b_$25,h_$4),DtType(($Unbox(b_$25) : DatatypeType))} ( GenericAlloc(b_$25,h_$4) ==> DtAlloc(($Unbox(b_$25) : DatatypeType),h_$4) ));
	assume (forall  b_$26 : Boolean, h_$5 : HeapType :: ( $IsGoodHeap(h_$5) ==> GenericAlloc($Box(b_$26),h_$5) ));
	assume (forall  x_$9 : Integer, h_$6 : HeapType :: ( $IsGoodHeap(h_$6) ==> GenericAlloc($Box(x_$9),h_$6) ));
	assume (forall  r_$3 : ref, h_$7 : HeapType :: {GenericAlloc($Box(r_$3),h_$7)} ( ($IsGoodHeap(h_$7) && ((r_$3 == null) || h_$7[r_$3,alloc])) ==> GenericAlloc($Box(r_$3),h_$7) ));
	assume (((((forall  f_$4 : Field (Boolean) , r_$5 : ref, H_$1 : HeapType :: ( H_$1[r_$5,f_$4] == H_$1[r_$5,f_$4] ))) && ((forall  f_$5 : Field (ref) , r_$6 : ref, H_$2 : HeapType :: ( H_$2[r_$6,f_$5] == H_$2[r_$6,f_$5] )))) && ((forall  f_$6 : Field (BoxType) , r_$7 : ref, H_$3 : HeapType :: ( H_$3[r_$7,f_$6] == H_$3[r_$7,f_$6] )))) && ((forall  f_$7 : Field ([BoxType]Boolean) , r_$8 : ref, H_$4 : HeapType :: ( H_$4[r_$8,f_$7] == H_$4[r_$8,f_$7] )))) && ((forall  f_$8 : Field (Seq (BoxType) ) , r_$9 : ref, H_$5 : HeapType :: ( H_$5[r_$9,f_$8] == H_$5[r_$9,f_$8] )));
	assume (((((forall  v_$5 : Boolean, f_$0_$0 : Field (Boolean) , r_$0_$0 : ref, H_$0_$0 : HeapType :: ( H_$0_$0[r_$0_$0,f_$0_$0 := v_$5] == H_$0_$0[r_$0_$0,f_$0_$0 := v_$5] ))) && ((forall  v_$6 : ref, f_$0_$1 : Field (ref) , r_$0_$1 : ref, H_$0_$1 : HeapType :: ( H_$0_$1[r_$0_$1,f_$0_$1 := v_$6] == H_$0_$1[r_$0_$1,f_$0_$1 := v_$6] )))) && ((forall  v_$7 : BoxType, f_$0_$2 : Field (BoxType) , r_$0_$2 : ref, H_$0_$2 : HeapType :: ( H_$0_$2[r_$0_$2,f_$0_$2 := v_$7] == H_$0_$2[r_$0_$2,f_$0_$2 := v_$7] )))) && ((forall  v_$8 : [BoxType]Boolean, f_$0_$3 : Field ([BoxType]Boolean) , r_$0_$3 : ref, H_$0_$3 : HeapType :: ( H_$0_$3[r_$0_$3,f_$0_$3 := v_$8] == H_$0_$3[r_$0_$3,f_$0_$3 := v_$8] )))) && ((forall  v_$9 : Seq (BoxType) , f_$0_$4 : Field (Seq (BoxType) ) , r_$0_$4 : ref, H_$0_$4 : HeapType :: ( H_$0_$4[r_$0_$4,f_$0_$4 := v_$9] == H_$0_$4[r_$0_$4,f_$0_$4 := v_$9] )));
	assume (((((forall  h_$8_$0 : HeapType, r_$4_$0 : ref, f_$3_$0 : Field (Boolean) , x_$10_$0 : Boolean :: {h_$8_$0[r_$4_$0,f_$3_$0 := x_$10_$0]} ( $HeapSucc(h_$8_$0,h_$8_$0[r_$4_$0,f_$3_$0 := x_$10_$0]) ))) && ((forall  h_$8_$1 : HeapType, r_$4_$1 : ref, f_$3_$1 : Field (ref) , x_$10_$1 : ref :: {h_$8_$1[r_$4_$1,f_$3_$1 := x_$10_$1]} ( $HeapSucc(h_$8_$1,h_$8_$1[r_$4_$1,f_$3_$1 := x_$10_$1]) )))) && ((forall  h_$8_$2 : HeapType, r_$4_$2 : ref, f_$3_$2 : Field (BoxType) , x_$10_$2 : BoxType :: {h_$8_$2[r_$4_$2,f_$3_$2 := x_$10_$2]} ( $HeapSucc(h_$8_$2,h_$8_$2[r_$4_$2,f_$3_$2 := x_$10_$2]) )))) && ((forall  h_$8_$3 : HeapType, r_$4_$3 : ref, f_$3_$3 : Field ([BoxType]Boolean) , x_$10_$3 : [BoxType]Boolean :: {h_$8_$3[r_$4_$3,f_$3_$3 := x_$10_$3]} ( $HeapSucc(h_$8_$3,h_$8_$3[r_$4_$3,f_$3_$3 := x_$10_$3]) )))) && ((forall  h_$8_$4 : HeapType, r_$4_$4 : ref, f_$3_$4 : Field (Seq (BoxType) ) , x_$10_$4 : Seq (BoxType)  :: {h_$8_$4[r_$4_$4,f_$3_$4 := x_$10_$4]} ( $HeapSucc(h_$8_$4,h_$8_$4[r_$4_$4,f_$3_$4 := x_$10_$4]) )));
	assume (forall  a_$20 : HeapType, b_$27 : HeapType, c : HeapType :: {$HeapSucc(a_$20,b_$27),$HeapSucc(b_$27,c)} ( ($HeapSucc(a_$20,b_$27) && $HeapSucc(b_$27,c)) ==> $HeapSucc(a_$20,c) ));
	assume (forall  h_$9 : HeapType, k_$1 : HeapType :: {$HeapSucc(h_$9,k_$1)} ( $HeapSucc(h_$9,k_$1) ==> ((forall  o_$8 : ref :: {k_$1[o_$8,alloc]} ( h_$9[o_$8,alloc] ==> k_$1[o_$8,alloc] ))) ));
	assume (forall  x_$11 : Integer, y_$3 : Integer :: {x_$11 mod y_$3} {x_$11 div y_$3} ( (x_$11 mod y_$3) == (x_$11 - ((x_$11 div y_$3) * y_$3)) ));
	assume (forall  x_$12 : Integer, y_$4 : Integer :: {x_$12 mod y_$4} ( (0 < y_$4) ==> ((0 <= (x_$12 mod y_$4)) && ((x_$12 mod y_$4) < y_$4)) ));
	assume (forall  x_$13 : Integer, y_$5 : Integer :: {x_$13 mod y_$5} ( (y_$5 < 0) ==> ((y_$5 < (x_$13 mod y_$5)) && ((x_$13 mod y_$5) <= 0)) ));
	assume (forall  a_$21 : Integer, b_$28 : Integer, d_$1 : Integer :: {a_$21 mod d_$1,b_$28 mod d_$1} ( (((2 <= d_$1) && ((a_$21 mod d_$1) == (b_$28 mod d_$1))) && (a_$21 < b_$28)) ==> ((a_$21 + d_$1) <= b_$28) ));
	assume (forall  o_$9 : ref :: ( 0 <= array.Length(o_$9) ));
	assume (FDim(Map.Keys) == 0) && (DeclType(Map.Keys) == class.Map);
	assume (forall  $h : HeapType, $o : ref :: {$h[$o,Map.Keys]} ( (($IsGoodHeap($h) && (!($o == null))) && $h[$o,alloc]) ==> ((forall  $i#0 : Integer :: {Seq#Index($h[$o,Map.Keys],$i#0)} ( ((0 <= $i#0) && ($i#0 < Seq#Length($h[$o,Map.Keys]))) ==> GenericAlloc(Seq#Index($h[$o,Map.Keys],$i#0),$h) ))) ));
	assume (FDim(Map.Values) == 0) && (DeclType(Map.Values) == class.Map);
	assume (forall  $h_$0 : HeapType, $o_$0 : ref :: {$h_$0[$o_$0,Map.Values]} ( (($IsGoodHeap($h_$0) && (!($o_$0 == null))) && $h_$0[$o_$0,alloc]) ==> ((forall  $i#1 : Integer :: {Seq#Index($h_$0[$o_$0,Map.Values],$i#1)} ( ((0 <= $i#1) && ($i#1 < Seq#Length($h_$0[$o_$0,Map.Values]))) ==> GenericAlloc(Seq#Index($h_$0[$o_$0,Map.Values],$i#1),$h_$0) ))) ));
	assume (FDim(Map.Repr) == 0) && (DeclType(Map.Repr) == class.Map);
	assume (forall  $h_$1 : HeapType, $o_$1 : ref :: {$h_$1[$o_$1,Map.Repr]} ( (($IsGoodHeap($h_$1) && (!($o_$1 == null))) && $h_$1[$o_$1,alloc]) ==> ((forall  $t#2 : BoxType :: {$h_$1[$o_$1,Map.Repr][$t#2]} ( $h_$1[$o_$1,Map.Repr][$t#2] ==> ((($Unbox($t#2) : ref) == null) || $h_$1[($Unbox($t#2) : ref),alloc]) ))) ));
	assume (FDim(Map.head) == 0) && (DeclType(Map.head) == class.Map);
	assume (forall  $h_$2 : HeapType, $o_$2 : ref :: {$h_$2[$o_$2,Map.head]} ( (($IsGoodHeap($h_$2) && (!($o_$2 == null))) && $h_$2[$o_$2,alloc]) ==> (($h_$2[$o_$2,Map.head] == null) || ($h_$2[$h_$2[$o_$2,Map.head],alloc] && (dtype($h_$2[$o_$2,Map.head]) == class.Node))) ));
	assume (FDim(Map.nodes) == 0) && (DeclType(Map.nodes) == class.Map);
	assume (forall  $h_$3 : HeapType, $o_$3 : ref :: {$h_$3[$o_$3,Map.nodes]} ( (($IsGoodHeap($h_$3) && (!($o_$3 == null))) && $h_$3[$o_$3,alloc]) ==> ((forall  $i#3 : Integer :: {Seq#Index($h_$3[$o_$3,Map.nodes],$i#3)} ( ((0 <= $i#3) && ($i#3 < Seq#Length($h_$3[$o_$3,Map.nodes]))) ==> ((($Unbox(Seq#Index($h_$3[$o_$3,Map.nodes],$i#3)) : ref) == null) || ($h_$3[($Unbox(Seq#Index($h_$3[$o_$3,Map.nodes],$i#3)) : ref),alloc] && (dtype(($Unbox(Seq#Index($h_$3[$o_$3,Map.nodes],$i#3)) : ref)) == class.Node))) ))) ));
	assume (FDim(Node.key) == 0) && (DeclType(Node.key) == class.Node);
	assume (FDim(Node.val) == 0) && (DeclType(Node.val) == class.Node);
	assume (FDim(Node.next) == 0) && (DeclType(Node.next) == class.Node);
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((4 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$0 : HeapType, this_$0 : ref :: {Map.Valid($Heap_$0,this_$0)} ( (Map.Valid#canCall($Heap_$0,this_$0) || (((((((!(0 == $ModuleContextHeight)) || (!(4 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$0)) && (!(this_$0 == null))) && $Heap_$0[this_$0,alloc]) && (dtype(this_$0) == class.Map))) ==> (((((($Heap_$0[this_$0,Map.Repr][$Box(this_$0)] ==> true) && (($Heap_$0[this_$0,Map.Repr][$Box(this_$0)] && (Seq#Length($Heap_$0[this_$0,Map.Keys]) == Seq#Length($Heap_$0[this_$0,Map.Values]))) ==> true)) && ((($Heap_$0[this_$0,Map.Repr][$Box(this_$0)] && (Seq#Length($Heap_$0[this_$0,Map.Keys]) == Seq#Length($Heap_$0[this_$0,Map.Values]))) && (Seq#Length($Heap_$0[this_$0,Map.nodes]) == (Seq#Length($Heap_$0[this_$0,Map.Keys]) + 1))) ==> true)) && (((($Heap_$0[this_$0,Map.Repr][$Box(this_$0)] && (Seq#Length($Heap_$0[this_$0,Map.Keys]) == Seq#Length($Heap_$0[this_$0,Map.Values]))) && (Seq#Length($Heap_$0[this_$0,Map.nodes]) == (Seq#Length($Heap_$0[this_$0,Map.Keys]) + 1))) && ($Heap_$0[this_$0,Map.head] == ($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],0)) : ref))) ==> ((forall  i#0 : Integer :: ( true ==> (((0 <= i#0) ==> true) && (((0 <= i#0) && (i#0 < Seq#Length($Heap_$0[this_$0,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref) == null)) ==> true) && (((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref) == null)) && $Heap_$0[this_$0,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref))]) ==> true)) && ((((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref) == null)) && $Heap_$0[this_$0,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref))]) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref),Node.key] == Seq#Index($Heap_$0[this_$0,Map.Keys],i#0))) ==> true)) && (((((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref) == null)) && $Heap_$0[this_$0,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref))]) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref),Node.key] == Seq#Index($Heap_$0[this_$0,Map.Keys],i#0))) && (!Seq#Contains(Seq#Drop($Heap_$0[this_$0,Map.Keys],i#0 + 1),$Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref),Node.key]))) ==> true)) && ((((((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref) == null)) && $Heap_$0[this_$0,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref))]) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref),Node.key] == Seq#Index($Heap_$0[this_$0,Map.Keys],i#0))) && (!Seq#Contains(Seq#Drop($Heap_$0[this_$0,Map.Keys],i#0 + 1),$Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref),Node.key]))) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0)) : ref),Node.val] == Seq#Index($Heap_$0[this_$0,Map.Values],i#0))) ==> true)))) ))))) && ((((($Heap_$0[this_$0,Map.Repr][$Box(this_$0)] && (Seq#Length($Heap_$0[this_$0,Map.Keys]) == Seq#Length($Heap_$0[this_$0,Map.Values]))) && (Seq#Length($Heap_$0[this_$0,Map.nodes]) == (Seq#Length($Heap_$0[this_$0,Map.Keys]) + 1))) && ($Heap_$0[this_$0,Map.head] == ($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],0)) : ref))) && ((forall  i#0_$0 : Integer :: ( true ==> (((0 <= i#0_$0) && (i#0_$0 < Seq#Length($Heap_$0[this_$0,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0)) : ref) == null)) && $Heap_$0[this_$0,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0)) : ref))]) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0)) : ref),Node.key] == Seq#Index($Heap_$0[this_$0,Map.Keys],i#0_$0))) && (!Seq#Contains(Seq#Drop($Heap_$0[this_$0,Map.Keys],i#0_$0 + 1),$Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0)) : ref),Node.key]))) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0)) : ref),Node.val] == Seq#Index($Heap_$0[this_$0,Map.Values],i#0_$0))) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0)) : ref),Node.next] == ($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$0 + 1)) : ref)))) )))) ==> true)) && (Map.Valid($Heap_$0,this_$0) <==> ((((($Heap_$0[this_$0,Map.Repr][$Box(this_$0)] && (Seq#Length($Heap_$0[this_$0,Map.Keys]) == Seq#Length($Heap_$0[this_$0,Map.Values]))) && (Seq#Length($Heap_$0[this_$0,Map.nodes]) == (Seq#Length($Heap_$0[this_$0,Map.Keys]) + 1))) && ($Heap_$0[this_$0,Map.head] == ($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],0)) : ref))) && ((forall  i#0_$1 : Integer :: ( true ==> (((0 <= i#0_$1) && (i#0_$1 < Seq#Length($Heap_$0[this_$0,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1)) : ref) == null)) && $Heap_$0[this_$0,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1)) : ref))]) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1)) : ref),Node.key] == Seq#Index($Heap_$0[this_$0,Map.Keys],i#0_$1))) && (!Seq#Contains(Seq#Drop($Heap_$0[this_$0,Map.Keys],i#0_$1 + 1),$Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1)) : ref),Node.key]))) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1)) : ref),Node.val] == Seq#Index($Heap_$0[this_$0,Map.Values],i#0_$1))) && ($Heap_$0[($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1)) : ref),Node.next] == ($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],i#0_$1 + 1)) : ref)))) )))) && (($Unbox(Seq#Index($Heap_$0[this_$0,Map.nodes],Seq#Length($Heap_$0[this_$0,Map.nodes]) - 1)) : ref) == null)))) )));
	assume (forall  $h0 : HeapType, $h1 : HeapType, this_$1 : ref :: {$HeapSucc($h0,$h1),Map.Valid($h1,this_$1)} ( ((((((($IsGoodHeap($h0) && $IsGoodHeap($h1)) && (!(this_$1 == null))) && $h0[this_$1,alloc]) && (dtype(this_$1) == class.Map)) && $h1[this_$1,alloc]) && (dtype(this_$1) == class.Map)) && $HeapSucc($h0,$h1)) ==> (((((((forall  $o_$4_$0 : ref, $f_$13 : Field (Boolean)  :: ( ((((!($o_$4_$0 == null)) && $h0[$o_$4_$0,alloc]) && $h1[$o_$4_$0,alloc]) && (($o_$4_$0 == this_$1) || $h0[this_$1,Map.Repr][$Box($o_$4_$0)])) ==> ($h0[$o_$4_$0,$f_$13] == $h1[$o_$4_$0,$f_$13]) ))) && ((forall  $o_$4_$1 : ref, $f_$14 : Field (ref)  :: ( ((((!($o_$4_$1 == null)) && $h0[$o_$4_$1,alloc]) && $h1[$o_$4_$1,alloc]) && (($o_$4_$1 == this_$1) || $h0[this_$1,Map.Repr][$Box($o_$4_$1)])) ==> ($h0[$o_$4_$1,$f_$14] == $h1[$o_$4_$1,$f_$14]) )))) && ((forall  $o_$4_$2 : ref, $f_$15 : Field (BoxType)  :: ( ((((!($o_$4_$2 == null)) && $h0[$o_$4_$2,alloc]) && $h1[$o_$4_$2,alloc]) && (($o_$4_$2 == this_$1) || $h0[this_$1,Map.Repr][$Box($o_$4_$2)])) ==> ($h0[$o_$4_$2,$f_$15] == $h1[$o_$4_$2,$f_$15]) )))) && ((forall  $o_$4_$3 : ref, $f_$16 : Field ([BoxType]Boolean)  :: ( ((((!($o_$4_$3 == null)) && $h0[$o_$4_$3,alloc]) && $h1[$o_$4_$3,alloc]) && (($o_$4_$3 == this_$1) || $h0[this_$1,Map.Repr][$Box($o_$4_$3)])) ==> ($h0[$o_$4_$3,$f_$16] == $h1[$o_$4_$3,$f_$16]) )))) && ((forall  $o_$4_$4 : ref, $f_$17 : Field (Seq (BoxType) )  :: ( ((((!($o_$4_$4 == null)) && $h0[$o_$4_$4,alloc]) && $h1[$o_$4_$4,alloc]) && (($o_$4_$4 == this_$1) || $h0[this_$1,Map.Repr][$Box($o_$4_$4)])) ==> ($h0[$o_$4_$4,$f_$17] == $h1[$o_$4_$4,$f_$17]) )))) ==> (Map.Valid($h0,this_$1) <==> Map.Valid($h1,this_$1))) ));
	assume (forall  $h_$4 : HeapType, $o_$5 : ref :: {$h_$4[$o_$5,Node.key]} ( (($IsGoodHeap($h_$4) && (!($o_$5 == null))) && $h_$4[$o_$5,alloc]) ==> GenericAlloc($h_$4[$o_$5,Node.key],$h_$4) ));
	assume (forall  $h_$5 : HeapType, $o_$6 : ref :: {$h_$5[$o_$6,Node.val]} ( (($IsGoodHeap($h_$5) && (!($o_$6 == null))) && $h_$5[$o_$6,alloc]) ==> GenericAlloc($h_$5[$o_$6,Node.val],$h_$5) ));
	assume (forall  $h_$6 : HeapType, $o_$7 : ref :: {$h_$6[$o_$7,Node.next]} ( (($IsGoodHeap($h_$6) && (!($o_$7 == null))) && $h_$6[$o_$7,alloc]) ==> (($h_$6[$o_$7,Node.next] == null) || ($h_$6[$h_$6[$o_$7,Node.next],alloc] && (dtype($h_$6[$o_$7,Node.next]) == class.Node))) ));
	assume (((((forall  $o_$16_$0 : ref, $f_$8_$0 : Field (Boolean) , Map.Repr_$4_$0 : Field (Set (BoxType) ) , null_$8_$0 : ref, $Heap_$9_$0 : HeapType, alloc_$8_$0 : Field (Boolean) , this_$8_$0 : ref :: {lambda#8(Map.Repr_$4_$0,null_$8_$0,$Heap_$9_$0,alloc_$8_$0,this_$8_$0)[$o_$16_$0,$f_$8_$0]} ( lambda#8(Map.Repr_$4_$0,null_$8_$0,$Heap_$9_$0,alloc_$8_$0,this_$8_$0)[$o_$16_$0,$f_$8_$0] <==> (((!($o_$16_$0 == null_$8_$0)) && $Heap_$9_$0[$o_$16_$0,alloc_$8_$0]) ==> $Heap_$9_$0[this_$8_$0,Map.Repr_$4_$0][$Box($o_$16_$0)]) ))) && ((forall  $o_$16_$1 : ref, $f_$8_$1 : Field (ref) , Map.Repr_$4_$1 : Field (Set (BoxType) ) , null_$8_$1 : ref, $Heap_$9_$1 : HeapType, alloc_$8_$1 : Field (Boolean) , this_$8_$1 : ref :: {lambda#8(Map.Repr_$4_$1,null_$8_$1,$Heap_$9_$1,alloc_$8_$1,this_$8_$1)[$o_$16_$1,$f_$8_$1]} ( lambda#8(Map.Repr_$4_$1,null_$8_$1,$Heap_$9_$1,alloc_$8_$1,this_$8_$1)[$o_$16_$1,$f_$8_$1] <==> (((!($o_$16_$1 == null_$8_$1)) && $Heap_$9_$1[$o_$16_$1,alloc_$8_$1]) ==> $Heap_$9_$1[this_$8_$1,Map.Repr_$4_$1][$Box($o_$16_$1)]) )))) && ((forall  $o_$16_$2 : ref, $f_$8_$2 : Field (BoxType) , Map.Repr_$4_$2 : Field (Set (BoxType) ) , null_$8_$2 : ref, $Heap_$9_$2 : HeapType, alloc_$8_$2 : Field (Boolean) , this_$8_$2 : ref :: {lambda#8(Map.Repr_$4_$2,null_$8_$2,$Heap_$9_$2,alloc_$8_$2,this_$8_$2)[$o_$16_$2,$f_$8_$2]} ( lambda#8(Map.Repr_$4_$2,null_$8_$2,$Heap_$9_$2,alloc_$8_$2,this_$8_$2)[$o_$16_$2,$f_$8_$2] <==> (((!($o_$16_$2 == null_$8_$2)) && $Heap_$9_$2[$o_$16_$2,alloc_$8_$2]) ==> $Heap_$9_$2[this_$8_$2,Map.Repr_$4_$2][$Box($o_$16_$2)]) )))) && ((forall  $o_$16_$3 : ref, $f_$8_$3 : Field ([BoxType]Boolean) , Map.Repr_$4_$3 : Field (Set (BoxType) ) , null_$8_$3 : ref, $Heap_$9_$3 : HeapType, alloc_$8_$3 : Field (Boolean) , this_$8_$3 : ref :: {lambda#8(Map.Repr_$4_$3,null_$8_$3,$Heap_$9_$3,alloc_$8_$3,this_$8_$3)[$o_$16_$3,$f_$8_$3]} ( lambda#8(Map.Repr_$4_$3,null_$8_$3,$Heap_$9_$3,alloc_$8_$3,this_$8_$3)[$o_$16_$3,$f_$8_$3] <==> (((!($o_$16_$3 == null_$8_$3)) && $Heap_$9_$3[$o_$16_$3,alloc_$8_$3]) ==> $Heap_$9_$3[this_$8_$3,Map.Repr_$4_$3][$Box($o_$16_$3)]) )))) && ((forall  $o_$16_$4 : ref, $f_$8_$4 : Field (Seq (BoxType) ) , Map.Repr_$4_$4 : Field (Set (BoxType) ) , null_$8_$4 : ref, $Heap_$9_$4 : HeapType, alloc_$8_$4 : Field (Boolean) , this_$8_$4 : ref :: {lambda#8(Map.Repr_$4_$4,null_$8_$4,$Heap_$9_$4,alloc_$8_$4,this_$8_$4)[$o_$16_$4,$f_$8_$4]} ( lambda#8(Map.Repr_$4_$4,null_$8_$4,$Heap_$9_$4,alloc_$8_$4,this_$8_$4)[$o_$16_$4,$f_$8_$4] <==> (((!($o_$16_$4 == null_$8_$4)) && $Heap_$9_$4[$o_$16_$4,alloc_$8_$4]) ==> $Heap_$9_$4[this_$8_$4,Map.Repr_$4_$4][$Box($o_$16_$4)]) )));
	goto PreconditionGeneratedEntry;
$exit:
	assume false;
PreconditionGeneratedEntry:
	assume $IsGoodHeap($Heap);
	assume ((!(this == null)) && $Heap[this,alloc]) && (dtype(this) == class.Map);
	assume GenericAlloc(key#16,$Heap);
	assume (p#20 == null) || ($Heap[p#20,alloc] && (dtype(p#20) == class.Node));
	assume (prev#22 == null) || ($Heap[prev#22,alloc] && (dtype(prev#22) == class.Node));
	assume ($rhs#0 == null) || ($Heap[$rhs#0,alloc] && (dtype($rhs#0) == class.Node));
	assume ($rhs#2 == null) || ($Heap[$rhs#2,alloc] && (dtype($rhs#2) == class.Node));
	assume (0 == $ModuleContextHeight) && $InMethodContext;
	assume ((((((Map.Valid#canCall($Heap,this) && Map.Valid($Heap,this)) && $Heap[this,Map.Repr][$Box(this)]) && (Seq#Length($Heap[this,Map.Keys]) == Seq#Length($Heap[this,Map.Values]))) && (Seq#Length($Heap[this,Map.nodes]) == (Seq#Length($Heap[this,Map.Keys]) + 1))) && ($Heap[this,Map.head] == ($Unbox(Seq#Index($Heap[this,Map.nodes],0)) : ref))) && ((forall  i#0_$2 : Integer :: ( true ==> (((0 <= i#0_$2) && (i#0_$2 < Seq#Length($Heap[this,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2)) : ref) == null)) && $Heap[this,Map.Repr][$Box(($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2)) : ref))]) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2)) : ref),Node.key] == Seq#Index($Heap[this,Map.Keys],i#0_$2))) && (!Seq#Contains(Seq#Drop($Heap[this,Map.Keys],i#0_$2 + 1),$Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2)) : ref),Node.key]))) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2)) : ref),Node.val] == Seq#Index($Heap[this,Map.Values],i#0_$2))) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2)) : ref),Node.next] == ($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$2 + 1)) : ref)))) )))) && (($Unbox(Seq#Index($Heap[this,Map.nodes],Seq#Length($Heap[this,Map.nodes]) - 1)) : ref) == null);
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || $Heap[this,Map.Repr][$Box(this)]);
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length($Heap[this,Map.Keys]) == Seq#Length($Heap[this,Map.Values])));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length($Heap[this,Map.nodes]) == (Seq#Length($Heap[this,Map.Keys]) + 1)));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || ($Heap[this,Map.head] == ($Unbox(Seq#Index($Heap[this,Map.nodes],0)) : ref)));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || ((forall  i#0_$3 : Integer :: ( true ==> (((0 <= i#0_$3) && (i#0_$3 < Seq#Length($Heap[this,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3)) : ref) == null)) && $Heap[this,Map.Repr][$Box(($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3)) : ref))]) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3)) : ref),Node.key] == Seq#Index($Heap[this,Map.Keys],i#0_$3))) && (!Seq#Contains(Seq#Drop($Heap[this,Map.Keys],i#0_$3 + 1),$Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3)) : ref),Node.key]))) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3)) : ref),Node.val] == Seq#Index($Heap[this,Map.Values],i#0_$3))) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3)) : ref),Node.next] == ($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$3 + 1)) : ref)))) ))));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (($Unbox(Seq#Index($Heap[this,Map.nodes],Seq#Length($Heap[this,Map.nodes]) - 1)) : ref) == null));
	goto anon0;
anon0:
	assume $_Frame_$_0 == lambda#8(Map.Repr,null,$Heap,alloc,this);
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (((((forall  $o_$19_$0 : ref, $f_$11_$0 : Field (Boolean)  :: ( false ==> $_Frame_$_0[$o_$19_$0,$f_$11_$0] ))) && ((forall  $o_$19_$1 : ref, $f_$11_$1 : Field (ref)  :: ( false ==> $_Frame_$_0[$o_$19_$1,$f_$11_$1] )))) && ((forall  $o_$19_$2 : ref, $f_$11_$2 : Field (BoxType)  :: ( false ==> $_Frame_$_0[$o_$19_$2,$f_$11_$2] )))) && ((forall  $o_$19_$3 : ref, $f_$11_$3 : Field ([BoxType]Boolean)  :: ( false ==> $_Frame_$_0[$o_$19_$3,$f_$11_$3] )))) && ((forall  $o_$19_$4 : ref, $f_$11_$4 : Field (Seq (BoxType) )  :: ( false ==> $_Frame_$_0[$o_$19_$4,$f_$11_$4] )));
	assume (call4formal_$_p#24 == null) || ($Heap[call4formal_$_p#24,alloc] && (dtype(call4formal_$_p#24) == class.Node));
	assume (call6formal_$_prev#26 == null) || ($Heap[call6formal_$_prev#26,alloc] && (dtype(call6formal_$_prev#26) == class.Node));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || $Heap[this,Map.Repr][$Box(this)]);
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length($Heap[this,Map.Keys]) == Seq#Length($Heap[this,Map.Values])));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length($Heap[this,Map.nodes]) == (Seq#Length($Heap[this,Map.Keys]) + 1)));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || ($Heap[this,Map.head] == ($Unbox(Seq#Index($Heap[this,Map.nodes],0)) : ref)));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || ((forall  i#0_$4 : Integer :: ( true ==> (((0 <= i#0_$4) && (i#0_$4 < Seq#Length($Heap[this,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4)) : ref) == null)) && $Heap[this,Map.Repr][$Box(($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4)) : ref))]) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4)) : ref),Node.key] == Seq#Index($Heap[this,Map.Keys],i#0_$4))) && (!Seq#Contains(Seq#Drop($Heap[this,Map.Keys],i#0_$4 + 1),$Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4)) : ref),Node.key]))) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4)) : ref),Node.val] == Seq#Index($Heap[this,Map.Values],i#0_$4))) && ($Heap[($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4)) : ref),Node.next] == ($Unbox(Seq#Index($Heap[this,Map.nodes],i#0_$4 + 1)) : ref)))) ))));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (($Unbox(Seq#Index($Heap[this,Map.nodes],Seq#Length($Heap[this,Map.nodes]) - 1)) : ref) == null));
	assume $IsGoodHeap($Heap_$_0);
	assume (call4formal_$_p#24_$_0 == null) || ($Heap_$_0[call4formal_$_p#24_$_0,alloc] && (dtype(call4formal_$_p#24_$_0) == class.Node));
	assume (call6formal_$_prev#26_$_0 == null) || ($Heap_$_0[call6formal_$_prev#26_$_0,alloc] && (dtype(call6formal_$_prev#26_$_0) == class.Node));
	assume (call4formal_$_p#24_$_0 == null) ==> (!Seq#Contains($Heap_$_0[this,Map.Keys],key#16));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (0 <= call5formal_$_n#25_$_0);
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (call5formal_$_n#25_$_0 < Seq#Length($Heap_$_0[this,Map.Keys]));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (Seq#Index($Heap_$_0[this,Map.Keys],call5formal_$_n#25_$_0) == key#16);
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (!Seq#Contains(Seq#Take($Heap_$_0[this,Map.Keys],call5formal_$_n#25_$_0),key#16));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (!Seq#Contains(Seq#Drop($Heap_$_0[this,Map.Keys],call5formal_$_n#25_$_0 + 1),key#16));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (call4formal_$_p#24_$_0 == ($Unbox(Seq#Index($Heap_$_0[this,Map.nodes],call5formal_$_n#25_$_0)) : ref));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (((call5formal_$_n#25_$_0 == 0) && (call6formal_$_prev#26_$_0 == null)) || ((0 < call5formal_$_n#25_$_0) && (call6formal_$_prev#26_$_0 == ($Unbox(Seq#Index($Heap_$_0[this,Map.nodes],call5formal_$_n#25_$_0 - 1)) : ref))));
	assume (((((forall  $o_$20_$0 : ref, $f_$12_$0 : Field (Boolean)  :: {$Heap_$_0[$o_$20_$0,$f_$12_$0]} ( ((!($o_$20_$0 == null)) && $Heap[$o_$20_$0,alloc]) ==> ($Heap_$_0[$o_$20_$0,$f_$12_$0] == $Heap[$o_$20_$0,$f_$12_$0]) ))) && ((forall  $o_$20_$1 : ref, $f_$12_$1 : Field (ref)  :: {$Heap_$_0[$o_$20_$1,$f_$12_$1]} ( ((!($o_$20_$1 == null)) && $Heap[$o_$20_$1,alloc]) ==> ($Heap_$_0[$o_$20_$1,$f_$12_$1] == $Heap[$o_$20_$1,$f_$12_$1]) )))) && ((forall  $o_$20_$2 : ref, $f_$12_$2 : Field (BoxType)  :: {$Heap_$_0[$o_$20_$2,$f_$12_$2]} ( ((!($o_$20_$2 == null)) && $Heap[$o_$20_$2,alloc]) ==> ($Heap_$_0[$o_$20_$2,$f_$12_$2] == $Heap[$o_$20_$2,$f_$12_$2]) )))) && ((forall  $o_$20_$3 : ref, $f_$12_$3 : Field ([BoxType]Boolean)  :: {$Heap_$_0[$o_$20_$3,$f_$12_$3]} ( ((!($o_$20_$3 == null)) && $Heap[$o_$20_$3,alloc]) ==> ($Heap_$_0[$o_$20_$3,$f_$12_$3] == $Heap[$o_$20_$3,$f_$12_$3]) )))) && ((forall  $o_$20_$4 : ref, $f_$12_$4 : Field (Seq (BoxType) )  :: {$Heap_$_0[$o_$20_$4,$f_$12_$4]} ( ((!($o_$20_$4 == null)) && $Heap[$o_$20_$4,alloc]) ==> ($Heap_$_0[$o_$20_$4,$f_$12_$4] == $Heap[$o_$20_$4,$f_$12_$4]) )));
	assume $HeapSucc($Heap,$Heap_$_0);
	assume true;
	assume true;
	if ($_$_condition) { goto anon5_Then; } else { goto anon5_Else; }
anon5_Then:
	assume $_$_condition;
	assume $_$_condition <==> (!(call4formal_$_p#24_$_0 == null));
	assume !(call4formal_$_p#24_$_0 == null);
	assume true;
	assert  $_Frame_$_0[this,Map.Keys];
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length($Heap_$_0[this,Map.Keys]));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length($Heap_$_0[this,Map.Keys]));
	assume true;
	assume $rhs#3_$_0 == Seq#Append(Seq#Take($Heap_$_0[this,Map.Keys],call5formal_$_n#25_$_0),Seq#Drop($Heap_$_0[this,Map.Keys],call5formal_$_n#25_$_0 + 1));
	assume $Heap_$_1 == $Heap_$_0[this,Map.Keys := $rhs#3_$_0];
	assume $IsGoodHeap($Heap_$_1);
	assume true;
	assert  $_Frame_$_0[this,Map.Values];
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length($Heap_$_1[this,Map.Values]));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length($Heap_$_1[this,Map.Values]));
	assume true;
	assume $rhs#4_$_0 == Seq#Append(Seq#Take($Heap_$_1[this,Map.Values],call5formal_$_n#25_$_0),Seq#Drop($Heap_$_1[this,Map.Values],call5formal_$_n#25_$_0 + 1));
	assume $Heap_$_2 == $Heap_$_1[this,Map.Values := $rhs#4_$_0];
	assume $IsGoodHeap($Heap_$_2);
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length($Heap_$_2[this,Map.Keys]));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length($Heap[this,Map.Keys]));
	assume true;
	assert  Seq#Equal(Seq#Drop($Heap_$_2[this,Map.Keys],call5formal_$_n#25_$_0),Seq#Drop($Heap[this,Map.Keys],call5formal_$_n#25_$_0 + 1));
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length($Heap_$_2[this,Map.Values]));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length($Heap[this,Map.Values]));
	assume true;
	assert  Seq#Equal(Seq#Drop($Heap_$_2[this,Map.Values],call5formal_$_n#25_$_0),Seq#Drop($Heap[this,Map.Values],call5formal_$_n#25_$_0 + 1));
	assume true;
	assert  $_Frame_$_0[this,Map.nodes];
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length($Heap_$_2[this,Map.nodes]));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length($Heap_$_2[this,Map.nodes]));
	assume true;
	assume $rhs#5_$_0 == Seq#Append(Seq#Take($Heap_$_2[this,Map.nodes],call5formal_$_n#25_$_0),Seq#Drop($Heap_$_2[this,Map.nodes],call5formal_$_n#25_$_0 + 1));
	assume $Heap_$_3 == $Heap_$_2[this,Map.nodes := $rhs#5_$_0];
	assume $IsGoodHeap($Heap_$_3);
	assume true;
	if ($_$_condition_$0) { goto anon6_Then; } else { goto anon6_Else; }
anon5_Else:
	assume !$_$_condition;
	assume $_$_condition <==> (!(call4formal_$_p#24_$_0 == null));
	assume call4formal_$_p#24_$_0 == null;
	assume $Heap_$_6 == $Heap_$_0;
	goto GeneratedUnifiedExit;
anon6_Then:
	assume $_$_condition_$0;
	assume $_$_condition_$0 <==> (call6formal_$_prev#26_$_0 == null);
	assume call6formal_$_prev#26_$_0 == null;
	assume true;
	assert  $_Frame_$_0[this,Map.head];
	assert  !($Heap_$_3[this,Map.head] == null);
	assume true;
	assume $rhs#6_$_0 == $Heap_$_3[$Heap_$_3[this,Map.head],Node.next];
	assume $Heap_$_4 == $Heap_$_3[this,Map.head := $rhs#6_$_0];
	assume $IsGoodHeap($Heap_$_4);
	assume $Heap_$_6 == $Heap_$_4;
	goto GeneratedUnifiedExit;
anon6_Else:
	assume !$_$_condition_$0;
	assume $_$_condition_$0 <==> (call6formal_$_prev#26_$_0 == null);
	assume !(call6formal_$_prev#26_$_0 == null);
	assert  !(call6formal_$_prev#26_$_0 == null);
	assume true;
	assert  $_Frame_$_0[call6formal_$_prev#26_$_0,Node.next];
	assert  !(call4formal_$_p#24_$_0 == null);
	assume true;
	assume $rhs#7_$_0 == $Heap_$_3[call4formal_$_p#24_$_0,Node.next];
	assume $Heap_$_5 == $Heap_$_3[call6formal_$_prev#26_$_0,Node.next := $rhs#7_$_0];
	assume $IsGoodHeap($Heap_$_5);
	assume $Heap_$_6 == $Heap_$_5;
	goto GeneratedUnifiedExit;
GeneratedUnifiedExit:
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || $Heap_$_6[this,Map.Repr][$Box(this)]);
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (Seq#Length($Heap_$_6[this,Map.Keys]) == Seq#Length($Heap_$_6[this,Map.Values])));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (Seq#Length($Heap_$_6[this,Map.nodes]) == (Seq#Length($Heap_$_6[this,Map.Keys]) + 1)));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || ($Heap_$_6[this,Map.head] == ($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],0)) : ref)));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || ((forall  i#0_$5 : Integer :: ( true ==> (((0 <= i#0_$5) && (i#0_$5 < Seq#Length($Heap_$_6[this,Map.Keys]))) ==> ((((((!(($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5)) : ref) == null)) && $Heap_$_6[this,Map.Repr][$Box(($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5)) : ref))]) && ($Heap_$_6[($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5)) : ref),Node.key] == Seq#Index($Heap_$_6[this,Map.Keys],i#0_$5))) && (!Seq#Contains(Seq#Drop($Heap_$_6[this,Map.Keys],i#0_$5 + 1),$Heap_$_6[($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5)) : ref),Node.key]))) && ($Heap_$_6[($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5)) : ref),Node.val] == Seq#Index($Heap_$_6[this,Map.Values],i#0_$5))) && ($Heap_$_6[($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5)) : ref),Node.next] == ($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],i#0_$5 + 1)) : ref)))) ))));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (($Unbox(Seq#Index($Heap_$_6[this,Map.nodes],Seq#Length($Heap_$_6[this,Map.nodes]) - 1)) : ref) == null));
	assert  (forall  $o_$21 : ref :: ( (((!($o_$21 == null)) && $Heap_$_6[this,Map.Repr][$Box($o_$21)]) && (!$Heap[this,Map.Repr][$Box($o_$21)])) ==> (!$Heap[$o_$21,alloc]) ));
	assert  (forall  k#17 : BoxType :: ( GenericAlloc(k#17,$Heap_$_6) ==> (Seq#Contains($Heap_$_6[this,Map.Keys],k#17) ==> Seq#Contains($Heap[this,Map.Keys],k#17)) ));
	assert  (forall  k#18 : BoxType :: ( GenericAlloc(k#18,$Heap_$_6) ==> (Seq#Contains($Heap[this,Map.Keys],k#18) ==> (Seq#Contains($Heap_$_6[this,Map.Keys],k#18) || (k#18 == key#16))) ));
	assert  (!Seq#Contains($Heap[this,Map.Keys],key#16)) ==> Seq#Equal($Heap_$_6[this,Map.Keys],$Heap[this,Map.Keys]);
	assert  (!Seq#Contains($Heap[this,Map.Keys],key#16)) ==> Seq#Equal($Heap_$_6[this,Map.Values],$Heap[this,Map.Values]);
	assert  Seq#Contains($Heap[this,Map.Keys],key#16) ==> (Seq#Length($Heap_$_6[this,Map.Keys]) == (Seq#Length($Heap[this,Map.Keys]) - 1));
	assert  Seq#Contains($Heap[this,Map.Keys],key#16) ==> (!Seq#Contains($Heap_$_6[this,Map.Keys],key#16));
	assert  Seq#Contains($Heap[this,Map.Keys],key#16) ==> ((exists  h#19 : Integer :: ( (((((0 <= h#19) && (h#19 < Seq#Length($Heap[this,Map.Keys]))) && Seq#Equal(Seq#Take($Heap_$_6[this,Map.Keys],h#19),Seq#Take($Heap[this,Map.Keys],h#19))) && Seq#Equal(Seq#Take($Heap_$_6[this,Map.Values],h#19),Seq#Take($Heap[this,Map.Values],h#19))) && Seq#Equal(Seq#Drop($Heap_$_6[this,Map.Keys],h#19),Seq#Drop($Heap[this,Map.Keys],h#19 + 1))) && Seq#Equal(Seq#Drop($Heap_$_6[this,Map.Values],h#19),Seq#Drop($Heap[this,Map.Values],h#19 + 1)) )));
	goto $exit;
}
