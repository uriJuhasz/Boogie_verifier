type Integer = int;
type Boolean = bool;
type Set T = [T]bool;
type MultiSet T = [T]int;
type HeapType = <alpha>[ref,Field (alpha)]alpha;
type ref;
type Seq m0;
type BoxType;
type ClassName;
type DatatypeType;
type DtCtorId;
type Field m0;
type TickType;
const $$Language$Dafny : bool;
const null : ref;
const unique class.int : ClassName;
const unique class.bool : ClassName;
const unique class.set : ClassName;
const unique class.seq : ClassName;
const unique class.multiset : ClassName;
const $ModuleContextHeight : int;
const $FunctionContextHeight : int;
const $InMethodContext : bool;
const unique alloc : Field (bool);
const unique class.object : ClassName;
const unique class.array : ClassName;
const unique class.BreadthFirstSearch : ClassName;
const unique class.Map : ClassName;
const unique ##Map.Empty : DtCtorId;
const unique ##Map.Maplet : DtCtorId;
const unique class.List : ClassName;
const unique ##List.Nil : DtCtorId;
const unique ##List.Cons : DtCtorId;
const unique class.Nat : ClassName;
const unique ##Nat.Zero : DtCtorId;
const unique ##Nat.Suc : DtCtorId;
const unique class._default : ClassName;
const $old_$Heap : HeapType;
const $old_$Tick : TickType;
function Set#Empty <T> () : Set (T) ;
function Set#Singleton <T> (T) : Set (T) ;
function Set#UnionOne <T> (Set (T) ,T) : Set (T) ;
function Set#Union <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Intersection <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Difference <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Subset <T> (Set (T) ,Set (T) ) : bool;
function Set#Equal <T> (Set (T) ,Set (T) ) : bool;
function Set#Disjoint <T> (Set (T) ,Set (T) ) : bool;
function Set#Choose <T> (Set (T) ,TickType) : T;
function Math#min(int,int) : int;
function Math#clip(int) : int;
function $IsGoodMultiSet <T> (MultiSet (T) ) : bool;
function MultiSet#Empty <T> () : MultiSet (T) ;
function MultiSet#Singleton <T> (T) : MultiSet (T) ;
function MultiSet#UnionOne <T> (MultiSet (T) ,T) : MultiSet (T) ;
function MultiSet#Union <T> (MultiSet (T) ,MultiSet (T) ) : MultiSet (T) ;
function MultiSet#Intersection <T> (MultiSet (T) ,MultiSet (T) ) : MultiSet (T) ;
function MultiSet#Difference <T> (MultiSet (T) ,MultiSet (T) ) : MultiSet (T) ;
function MultiSet#Subset <T> (MultiSet (T) ,MultiSet (T) ) : bool;
function MultiSet#Equal <T> (MultiSet (T) ,MultiSet (T) ) : bool;
function MultiSet#Disjoint <T> (MultiSet (T) ,MultiSet (T) ) : bool;
function MultiSet#FromSet <T> (Set (T) ) : MultiSet (T) ;
function MultiSet#FromSeq <T> (Seq (T)) : MultiSet (T) ;
function Seq#Length <T> (Seq (T)) : int;
function Seq#Empty <T> () : Seq (T);
function Seq#Singleton <T> (T) : Seq (T);
function Seq#Build <T> (Seq (T),T) : Seq (T);
function Seq#Append <T> (Seq (T),Seq (T)) : Seq (T);
function Seq#Index <T> (Seq (T),int) : T;
function Seq#Update <T> (Seq (T),int,T) : Seq (T);
function Seq#Contains <T> (Seq (T),T) : bool;
function Seq#Equal <T> (Seq (T),Seq (T)) : bool;
function Seq#SameUntil <T> (Seq (T),Seq (T),int) : bool;
function Seq#Take <T> (Seq (T),int) : Seq (T);
function Seq#Drop <T> (Seq (T),int) : Seq (T);
function Seq#FromArray(HeapType,ref) : Seq (BoxType);
function $Box <T> (T) : BoxType;
function $Unbox <T> (BoxType) : T;
function $IsCanonicalBoolBox(BoxType) : bool;
function dtype(ref) : ClassName;
function TypeParams(ref,int) : ClassName;
function TypeTuple(ClassName,ClassName) : ClassName;
function TypeTupleCar(ClassName) : ClassName;
function TypeTupleCdr(ClassName) : ClassName;
function DtType(DatatypeType) : ClassName;
function DtTypeParams(DatatypeType,int) : ClassName;
function DatatypeCtorId(DatatypeType) : DtCtorId;
function DtRank(DatatypeType) : int;
function FDim <T> (Field (T)) : int;
function IndexField(int) : Field (BoxType);
function IndexField_Inverse <T> (Field (T)) : int;
function MultiIndexField(Field (BoxType),int) : Field (BoxType);
function MultiIndexField_Inverse0 <T> (Field (T)) : Field (T);
function MultiIndexField_Inverse1 <T> (Field (T)) : int;
function DeclType <T> (Field (T)) : ClassName;
function DtAlloc(DatatypeType,HeapType) : bool;
function GenericAlloc(BoxType,HeapType) : bool;
function array.Length(ref) : int;
function {:inline  true} read <alpha> (H:HeapType,r:ref,f:Field (alpha)) : alpha {H[r,f]}
function {:inline  true} update <alpha> (H_$0:HeapType,r_$0:ref,f_$0:Field (alpha),v:alpha) : HeapType {H_$0[r_$0,f_$0 := v]}
function $IsGoodHeap(HeapType) : bool;
function $HeapSucc(HeapType,HeapType) : bool;
function BreadthFirstSearch.Succ(HeapType,ref,BoxType) : Set (BoxType) ;
function BreadthFirstSearch.Succ#canCall(HeapType,ref,BoxType) : bool;
function BreadthFirstSearch.IsPath(HeapType,ref,BoxType,BoxType,Seq (BoxType)) : bool;
function BreadthFirstSearch.IsPath#limited(HeapType,ref,BoxType,BoxType,Seq (BoxType)) : bool;
function BreadthFirstSearch.IsPath#2(HeapType,ref,BoxType,BoxType,Seq (BoxType)) : bool;
function BreadthFirstSearch.IsPath#canCall(HeapType,ref,BoxType,BoxType,Seq (BoxType)) : bool;
function BreadthFirstSearch.IsClosed(HeapType,ref,Set (BoxType) ) : bool;
function BreadthFirstSearch.IsClosed#canCall(HeapType,ref,Set (BoxType) ) : bool;
function BreadthFirstSearch.Value(HeapType,ref,DatatypeType) : int;
function BreadthFirstSearch.Value#limited(HeapType,ref,DatatypeType) : int;
function BreadthFirstSearch.Value#2(HeapType,ref,DatatypeType) : int;
function BreadthFirstSearch.Value#canCall(HeapType,ref,DatatypeType) : bool;
function BreadthFirstSearch.ToNat(HeapType,ref,int) : DatatypeType;
function BreadthFirstSearch.ToNat#limited(HeapType,ref,int) : DatatypeType;
function BreadthFirstSearch.ToNat#2(HeapType,ref,int) : DatatypeType;
function BreadthFirstSearch.ToNat#canCall(HeapType,ref,int) : bool;
function BreadthFirstSearch.R(HeapType,ref,BoxType,DatatypeType,Set (BoxType) ) : Set (BoxType) ;
function BreadthFirstSearch.R#limited(HeapType,ref,BoxType,DatatypeType,Set (BoxType) ) : Set (BoxType) ;
function BreadthFirstSearch.R#2(HeapType,ref,BoxType,DatatypeType,Set (BoxType) ) : Set (BoxType) ;
function BreadthFirstSearch.R#canCall(HeapType,ref,BoxType,DatatypeType,Set (BoxType) ) : bool;
function BreadthFirstSearch.Successors(HeapType,ref,Set (BoxType) ,Set (BoxType) ) : Set (BoxType) ;
function BreadthFirstSearch.Successors#canCall(HeapType,ref,Set (BoxType) ,Set (BoxType) ) : bool;
function BreadthFirstSearch.Domain(HeapType,ref,DatatypeType) : Set (BoxType) ;
function BreadthFirstSearch.Domain#canCall(HeapType,ref,DatatypeType) : bool;
function BreadthFirstSearch.ValidMap(HeapType,ref,BoxType,DatatypeType) : bool;
function BreadthFirstSearch.ValidMap#limited(HeapType,ref,BoxType,DatatypeType) : bool;
function BreadthFirstSearch.ValidMap#2(HeapType,ref,BoxType,DatatypeType) : bool;
function BreadthFirstSearch.ValidMap#canCall(HeapType,ref,BoxType,DatatypeType) : bool;
function BreadthFirstSearch.Find(HeapType,ref,BoxType,BoxType,DatatypeType) : Seq (BoxType);
function BreadthFirstSearch.Find#limited(HeapType,ref,BoxType,BoxType,DatatypeType) : Seq (BoxType);
function BreadthFirstSearch.Find#2(HeapType,ref,BoxType,BoxType,DatatypeType) : Seq (BoxType);
function BreadthFirstSearch.Find#canCall(HeapType,ref,BoxType,BoxType,DatatypeType) : bool;
function #Map.Empty() : DatatypeType;
function Map.Empty?(DatatypeType) : bool;
function #Map.Maplet(Set (BoxType) ,BoxType,Seq (BoxType),DatatypeType) : DatatypeType;
function Map.Maplet?(DatatypeType) : bool;
function Map.dom(DatatypeType) : Set (BoxType) ;
function ##Map.Maplet#1(DatatypeType) : BoxType;
function ##Map.Maplet#2(DatatypeType) : Seq (BoxType);
function Map.next(DatatypeType) : DatatypeType;
function #List.Nil() : DatatypeType;
function List.Nil?(DatatypeType) : bool;
function #List.Cons(BoxType,DatatypeType) : DatatypeType;
function List.Cons?(DatatypeType) : bool;
function ##List.Cons#0(DatatypeType) : BoxType;
function ##List.Cons#1(DatatypeType) : DatatypeType;
function #Nat.Zero() : DatatypeType;
function Nat.Zero?(DatatypeType) : bool;
function #Nat.Suc(DatatypeType) : DatatypeType;
function Nat.Suc?(DatatypeType) : bool;
function Nat.predecessor(DatatypeType) : DatatypeType;
function lambda#0(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#1(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#2(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#3(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#4(Set (BoxType) ,HeapType,ref,BoxType) : [BoxType]bool;
function lambda#5(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#6(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#7(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#8(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#9(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#10(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#11(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#12(Set (BoxType) ,HeapType,Set (BoxType) ,ref) : [BoxType]bool;
function lambda#13(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#14(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#15(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#16(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#17(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#18(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#19(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#20(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#21(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#22(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#23(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#24(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
var $Heap : HeapType;
var $Tick : TickType;
var V#13 : Set (BoxType) ;
var C#14 : Set (BoxType) ;
var N#15 : Set (BoxType) ;
var Processed#16 : Set (BoxType) ;
var paths#17 : DatatypeType;
var dd#18 : DatatypeType;
var v#21 : BoxType;
var pathToV#22 : Seq (BoxType);
var newlyEncountered#24 : Set (BoxType) ;
var $rhs#30 : DatatypeType;
var $_Frame_$_0 : <beta>[ref,Field (beta)]bool;
var $rhs#13_$_0 : Set (BoxType) ;
var $rhs#14_$_0 : Set (BoxType) ;
var $rhs#15_$_0 : Set (BoxType) ;
var $rhs#17_$_0 : Set (BoxType) ;
var $rhs#18_$_0 : DatatypeType;
var dd#18_$_0 : DatatypeType;
var $decr0$init$0_$_0 : Set (BoxType) ;
var $w0_$_0 : bool;
var C#14_$_0 : Set (BoxType) ;
var $Heap_$_0 : HeapType;
var N#15_$_0 : Set (BoxType) ;
var dd#18_$_1 : DatatypeType;
var newlyEncountered#24_$_0 : Set (BoxType) ;
var V#13_$_0 : Set (BoxType) ;
var $rhs#30_$_0 : DatatypeType;
var paths#17_$_0 : DatatypeType;
var v#21_$_0 : BoxType;
var Processed#16_$_0 : Set (BoxType) ;
var pathToV#22_$_0 : Seq (BoxType);
var d#9_$_0 : int;
var $decr0$0_$_1 : Set (BoxType) ;
var v#21_$_1 : BoxType;
var $Tick_$_0 : TickType;
var $rhs#19_$_1 : Set (BoxType) ;
var $rhs#20_$_1 : Set (BoxType) ;
var pathToV#22_$_1 : Seq (BoxType);
var w#156_$_1 : BoxType;
var newlyEncountered#24_$_1 : Set (BoxType) ;
var $rhs#28_$_1 : Set (BoxType) ;
var $rhs#29_$_1 : Set (BoxType) ;
var call8formal_$_newPaths#78 : DatatypeType;
var $Heap_$_1 : HeapType;
var call8formal_$_newPaths#78_$_0 : DatatypeType;
var C#14_$_1 : Set (BoxType) ;
var N#15_$_1 : Set (BoxType) ;
var d#9_$_1 : int;
var dd#18_$_2 : DatatypeType;
var d#9_$_3 : int;
var $Heap_$_9 : HeapType;
var path#10_$_0 : Seq (BoxType);
var $rhs#32_$_1 : Set (BoxType) ;
var $rhs#33_$_1 : int;
var $rhs#34_$_1 : DatatypeType;
var p#23_$_0 : Seq (BoxType);
var $Heap_$_2 : HeapType;
var p#152a : Seq (BoxType);
var n#146_$_0 : int;
var $Heap_$_3 : HeapType;
var n#149_$_0 : int;
var mm#148_$_0 : DatatypeType;
var nn#150_$_0 : DatatypeType;
var $Heap_$_4 : HeapType;
var d#9_$_2 : int;
var p#27_$_0 : Seq (BoxType);
var $Heap_$_5 : HeapType;
var p#184a : Seq (BoxType);
var nn#26_$_0 : DatatypeType;
var $Heap_$_7 : HeapType;
var $Heap_$_8 : HeapType;
var $Heap_$_6 : HeapType;
var x#113_$_0 : BoxType;
var x#117_$_0 : BoxType;
var nn#125_$_0 : DatatypeType;
var $_Frame : <beta>[ref,Field (beta)]bool;
var $rhs#13 : Set (BoxType) ;
var $rhs#14 : Set (BoxType) ;
var $rhs#15 : Set (BoxType) ;
var $rhs#17 : Set (BoxType) ;
var $rhs#18 : DatatypeType;
var $PreLoopHeap0 : HeapType;
var $decr0$init$0 : Set (BoxType) ;
var $w0 : bool;
var source#110 : BoxType;
var m#111 : DatatypeType;
var m#112 : DatatypeType;
var x#113 : BoxType;
var source#114 : BoxType;
var x#115 : BoxType;
var m#116 : DatatypeType;
var x#117 : BoxType;
var source#118 : BoxType;
var x#119 : BoxType;
var m#120 : DatatypeType;
var source#121 : BoxType;
var nn#122 : DatatypeType;
var AllVertices#123 : Set (BoxType) ;
var source#124 : BoxType;
var nn#125 : DatatypeType;
var AllVertices#126 : Set (BoxType) ;
var source#127 : BoxType;
var nn#128 : DatatypeType;
var AllVertices#129 : Set (BoxType) ;
var S#130 : Set (BoxType) ;
var AllVertices#131 : Set (BoxType) ;
var source#132 : BoxType;
var nn#133 : DatatypeType;
var AllVertices#134 : Set (BoxType) ;
var nn#135 : DatatypeType;
var $decr0$0 : Set (BoxType) ;
var $rhs#19 : Set (BoxType) ;
var $rhs#20 : Set (BoxType) ;
var source#136 : BoxType;
var x#137 : BoxType;
var m#138 : DatatypeType;
var p#23 : Seq (BoxType);
var source#139 : BoxType;
var dest#140 : BoxType;
var p#141 : Seq (BoxType);
var source#142 : BoxType;
var x#143 : BoxType;
var p#144 : Seq (BoxType);
var AllVertices#145 : Set (BoxType) ;
var n#146 : int;
var source#147 : BoxType;
var mm#148 : DatatypeType;
var n#149 : int;
var nn#150 : DatatypeType;
var AllVertices#151 : Set (BoxType) ;
var source#153 : BoxType;
var dest#154 : BoxType;
var p#155 : Seq (BoxType);
var $rhs#24 : int;
var $rhs#25 : Seq (BoxType);
var w#156 : BoxType;
var x#157 : BoxType;
var $rhs#28 : Set (BoxType) ;
var $rhs#29 : Set (BoxType) ;
var vSuccs#158 : Set (BoxType) ;
var source#159 : BoxType;
var paths#160 : DatatypeType;
var v#161 : BoxType;
var pathToV#162 : Seq (BoxType);
var $rhs#31 : Set (BoxType) ;
var $rhs#32 : Set (BoxType) ;
var $rhs#33 : int;
var $rhs#34 : DatatypeType;
var nn#26 : DatatypeType;
var nn#163 : DatatypeType;
var nn#164 : DatatypeType;
var source#165 : BoxType;
var mm#166 : DatatypeType;
var nn#167 : DatatypeType;
var AllVertices#168 : Set (BoxType) ;
var source#169 : BoxType;
var mm#170 : DatatypeType;
var nn#171 : DatatypeType;
var AllVertices#172 : Set (BoxType) ;
var source#173 : BoxType;
var nn#174 : DatatypeType;
var AllVertices#175 : Set (BoxType) ;
var p#27 : Seq (BoxType);
var source#177 : BoxType;
var dest#178 : BoxType;
var p#179 : Seq (BoxType);
var source#180 : BoxType;
var x#181 : BoxType;
var p#182 : Seq (BoxType);
var AllVertices#183 : Set (BoxType) ;
var source#185 : BoxType;
var dest#186 : BoxType;
var p#187 : Seq (BoxType);
var $rhs#31_$_0 : Set (BoxType) ;
var $rhs#32_$_0 : Set (BoxType) ;
var $rhs#33_$_0 : int;
var $rhs#34_$_0 : DatatypeType;
var $rhs#28_$_0 : Set (BoxType) ;
var $rhs#29_$_0 : Set (BoxType) ;
var vSuccs#158_$_0 : Set (BoxType) ;
var source#159_$_0 : BoxType;
var paths#160_$_0 : DatatypeType;
var v#161_$_0 : BoxType;
var pathToV#162_$_0 : Seq (BoxType);
var w#156_$_0 : BoxType;
var x#157_$_0 : BoxType;
var $decr0$0_$_0 : Set (BoxType) ;
var $rhs#19_$_0 : Set (BoxType) ;
var $rhs#20_$_0 : Set (BoxType) ;
var source#136_$_0 : BoxType;
var x#137_$_0 : BoxType;
var m#138_$_0 : DatatypeType;
var $Tick_$_1 : TickType;
var $Tick_$_2 : TickType;
var $Tick_$_3 : TickType;
var $Tick_$_4 : TickType;
var $Tick_$_5 : TickType;
var $Tick_$_6 : TickType;
var $Tick_$_7 : TickType;
var $Tick_$_8 : TickType;
procedure BreadthFirstSearch.BFS (this : ref,source#6 : BoxType,dest#7 : BoxType,AllVertices#8 : Set (BoxType) ) returns (d#9 : int,path#10 : Seq (BoxType))
{
	var $_Frame : <beta>[ref,Field (beta)]bool;
	var V#13 : Set (BoxType) ;
	var C#14 : Set (BoxType) ;
	var N#15 : Set (BoxType) ;
	var $rhs#13 : Set (BoxType) ;
	var $rhs#14 : Set (BoxType) ;
	var $rhs#15 : Set (BoxType) ;
	var Processed#16 : Set (BoxType) ;
	var paths#17 : DatatypeType;
	var $rhs#17 : Set (BoxType) ;
	var $rhs#18 : DatatypeType;
	var dd#18 : DatatypeType;
	var $PreLoopHeap0 : HeapType;
	var $decr0$init$0 : Set (BoxType) ;
	var $w0 : bool;
	var source#110 : BoxType;
	var m#111 : DatatypeType;
	var m#112 : DatatypeType;
	var x#113 : BoxType;
	var source#114 : BoxType;
	var x#115 : BoxType;
	var m#116 : DatatypeType;
	var x#117 : BoxType;
	var source#118 : BoxType;
	var x#119 : BoxType;
	var m#120 : DatatypeType;
	var source#121 : BoxType;
	var nn#122 : DatatypeType;
	var AllVertices#123 : Set (BoxType) ;
	var source#124 : BoxType;
	var nn#125 : DatatypeType;
	var AllVertices#126 : Set (BoxType) ;
	var source#127 : BoxType;
	var nn#128 : DatatypeType;
	var AllVertices#129 : Set (BoxType) ;
	var S#130 : Set (BoxType) ;
	var AllVertices#131 : Set (BoxType) ;
	var source#132 : BoxType;
	var nn#133 : DatatypeType;
	var AllVertices#134 : Set (BoxType) ;
	var nn#135 : DatatypeType;
	var $decr0$0 : Set (BoxType) ;
	var v#21 : BoxType;
	var $rhs#19 : Set (BoxType) ;
	var $rhs#20 : Set (BoxType) ;
	var pathToV#22 : Seq (BoxType);
	var source#136 : BoxType;
	var x#137 : BoxType;
	var m#138 : DatatypeType;
	var p#23 : Seq (BoxType);
	var source#139 : BoxType;
	var dest#140 : BoxType;
	var p#141 : Seq (BoxType);
	var source#142 : BoxType;
	var x#143 : BoxType;
	var p#144 : Seq (BoxType);
	var AllVertices#145 : Set (BoxType) ;
	var n#146 : int;
	var source#147 : BoxType;
	var mm#148 : DatatypeType;
	var n#149 : int;
	var nn#150 : DatatypeType;
	var AllVertices#151 : Set (BoxType) ;
	var source#153 : BoxType;
	var dest#154 : BoxType;
	var p#155 : Seq (BoxType);
	var p#152a : Seq (BoxType);
	var $rhs#24 : int;
	var $rhs#25 : Seq (BoxType);
	var newlyEncountered#24 : Set (BoxType) ;
	var w#156 : BoxType;
	var x#157 : BoxType;
	var $rhs#28 : Set (BoxType) ;
	var $rhs#29 : Set (BoxType) ;
	var $rhs#30 : DatatypeType;
	var vSuccs#158 : Set (BoxType) ;
	var source#159 : BoxType;
	var paths#160 : DatatypeType;
	var v#161 : BoxType;
	var pathToV#162 : Seq (BoxType);
	var $rhs#31 : Set (BoxType) ;
	var $rhs#32 : Set (BoxType) ;
	var $rhs#33 : int;
	var $rhs#34 : DatatypeType;
	var nn#26 : DatatypeType;
	var nn#163 : DatatypeType;
	var nn#164 : DatatypeType;
	var source#165 : BoxType;
	var mm#166 : DatatypeType;
	var nn#167 : DatatypeType;
	var AllVertices#168 : Set (BoxType) ;
	var source#169 : BoxType;
	var mm#170 : DatatypeType;
	var nn#171 : DatatypeType;
	var AllVertices#172 : Set (BoxType) ;
	var source#173 : BoxType;
	var nn#174 : DatatypeType;
	var AllVertices#175 : Set (BoxType) ;
	var p#27 : Seq (BoxType);
	var source#177 : BoxType;
	var dest#178 : BoxType;
	var p#179 : Seq (BoxType);
	var source#180 : BoxType;
	var x#181 : BoxType;
	var p#182 : Seq (BoxType);
	var AllVertices#183 : Set (BoxType) ;
	var source#185 : BoxType;
	var dest#186 : BoxType;
	var p#187 : Seq (BoxType);
	var p#184a : Seq (BoxType);
	var $_Frame_$_0 : <beta>[ref,Field (beta)]bool;
	var $rhs#13_$_0 : Set (BoxType) ;
	var $rhs#14_$_0 : Set (BoxType) ;
	var $rhs#15_$_0 : Set (BoxType) ;
	var $rhs#17_$_0 : Set (BoxType) ;
	var $rhs#18_$_0 : DatatypeType;
	var dd#18_$_0 : DatatypeType;
	var $decr0$init$0_$_0 : Set (BoxType) ;
	var $w0_$_0 : bool;
	var $rhs#31_$_0 : Set (BoxType) ;
	var $rhs#32_$_0 : Set (BoxType) ;
	var $rhs#33_$_0 : int;
	var $rhs#34_$_0 : DatatypeType;
	var C#14_$_0 : Set (BoxType) ;
	var N#15_$_0 : Set (BoxType) ;
	var d#9_$_0 : int;
	var dd#18_$_1 : DatatypeType;
	var newlyEncountered#24_$_0 : Set (BoxType) ;
	var $rhs#28_$_0 : Set (BoxType) ;
	var $rhs#29_$_0 : Set (BoxType) ;
	var V#13_$_0 : Set (BoxType) ;
	var vSuccs#158_$_0 : Set (BoxType) ;
	var source#159_$_0 : BoxType;
	var paths#160_$_0 : DatatypeType;
	var v#161_$_0 : BoxType;
	var pathToV#162_$_0 : Seq (BoxType);
	var $rhs#30_$_0 : DatatypeType;
	var $Heap_$_0 : HeapType;
	var $Tick_$_0 : TickType;
	var paths#17_$_0 : DatatypeType;
	var w#156_$_0 : BoxType;
	var x#157_$_0 : BoxType;
	var $decr0$0_$_0 : Set (BoxType) ;
	var v#21_$_0 : BoxType;
	var $rhs#19_$_0 : Set (BoxType) ;
	var $rhs#20_$_0 : Set (BoxType) ;
	var Processed#16_$_0 : Set (BoxType) ;
	var source#136_$_0 : BoxType;
	var x#137_$_0 : BoxType;
	var m#138_$_0 : DatatypeType;
	var pathToV#22_$_0 : Seq (BoxType);
	var $decr0$0_$_1 : Set (BoxType) ;
	var v#21_$_1 : BoxType;
	var $Tick_$_1 : TickType;
	var $rhs#19_$_1 : Set (BoxType) ;
	var $rhs#20_$_1 : Set (BoxType) ;
	var pathToV#22_$_1 : Seq (BoxType);
	var w#156_$_1 : BoxType;
	var newlyEncountered#24_$_1 : Set (BoxType) ;
	var $rhs#28_$_1 : Set (BoxType) ;
	var $rhs#29_$_1 : Set (BoxType) ;
	var $Heap_$_1 : HeapType;
	var $Tick_$_2 : TickType;
	var call8formal_$_newPaths#78_$_0 : DatatypeType;
	var $rhs#32_$_1 : Set (BoxType) ;
	var $rhs#33_$_1 : int;
	var $rhs#34_$_1 : DatatypeType;
	var C#14_$_1 : Set (BoxType) ;
	var N#15_$_1 : Set (BoxType) ;
	var d#9_$_1 : int;
	var dd#18_$_2 : DatatypeType;
	var p#23_$_0 : Seq (BoxType);
	var $Heap_$_2 : HeapType;
	var $Tick_$_3 : TickType;
	var n#146_$_0 : int;
	var $Heap_$_3 : HeapType;
	var $Tick_$_4 : TickType;
	var n#149_$_0 : int;
	var mm#148_$_0 : DatatypeType;
	var nn#150_$_0 : DatatypeType;
	var $Heap_$_4 : HeapType;
	var $Tick_$_5 : TickType;
	var nn#26_$_0 : DatatypeType;
	var p#27_$_0 : Seq (BoxType);
	var $Heap_$_5 : HeapType;
	var $Tick_$_6 : TickType;
	var d#9_$_2 : int;
	var $Heap_$_6 : HeapType;
	var $Tick_$_7 : TickType;
	var $Heap_$_7 : HeapType;
	var $Tick_$_8 : TickType;
	var $Heap_$_8 : HeapType;
	var x#113_$_0 : BoxType;
	var x#117_$_0 : BoxType;
	var nn#125_$_0 : DatatypeType;
	var d#9_$_3 : int;
	var $Heap_$_9 : HeapType;
	var path#10_$_0 : Seq (BoxType);
	var $_$_condition : bool;
	var $_$_condition_$0 : bool;
	var $_$_condition_$1 : bool;
	var $_$_condition_$2 : bool;
	var $_$_condition_$3 : bool;
	var $_$_condition_$4 : bool;
	var $_$_condition_$5 : bool;
	var $_$_condition_$6 : bool;
	var $_$_condition_$7 : bool;
	var $_$_condition_$8 : bool;
	var $_$_condition_$9 : bool;
	var $_$_condition_$10 : bool;
	var $_$_condition_$11 : bool;
	var $_$_condition_$12 : bool;
	var $_$_condition_$13 : bool;
	var $_$_condition_$14 : bool;
	var $_$_condition_$15 : bool;
	var $_$_condition_$16 : bool;
	var $_$_condition_$17 : bool;
	var $_$_condition_$18 : bool;
	var $_$_condition_$19 : bool;
	var $_$_condition_$20 : bool;
	var $_$_condition_$21 : bool;
	var $_$_condition_$22 : bool;
$start:
	assume $$Language$Dafny;
	assume (forall<T> o : T :: {(Set#Empty() : Set (T) )[o]} ( !(Set#Empty() : Set (T) )[o] ));
	assume (forall<T> r_$1 : T :: {Set#Singleton(r_$1)} ( Set#Singleton(r_$1)[r_$1] ));
	assume (forall<T> r_$2 : T, o_$0 : T :: {Set#Singleton(r_$2)[o_$0]} ( Set#Singleton(r_$2)[o_$0] <==> (r_$2 == o_$0) ));
	assume (forall<T> a : Set (T) , x : T, o_$1 : T :: {Set#UnionOne(a,x)[o_$1]} ( Set#UnionOne(a,x)[o_$1] <==> ((o_$1 == x) || a[o_$1]) ));
	assume (forall<T> a_$0 : Set (T) , x_$0 : T :: {Set#UnionOne(a_$0,x_$0)} ( Set#UnionOne(a_$0,x_$0)[x_$0] ));
	assume (forall<T> a_$1 : Set (T) , x_$1 : T, y : T :: {Set#UnionOne(a_$1,x_$1),a_$1[y]} ( a_$1[y] ==> Set#UnionOne(a_$1,x_$1)[y] ));
	assume (forall<T> a_$2 : Set (T) , b : Set (T) , o_$2 : T :: {Set#Union(a_$2,b)[o_$2]} ( Set#Union(a_$2,b)[o_$2] <==> (a_$2[o_$2] || b[o_$2]) ));
	assume (forall<T> a_$3 : Set (T) , b_$0 : Set (T) , y_$0 : T :: {Set#Union(a_$3,b_$0),a_$3[y_$0]} ( a_$3[y_$0] ==> Set#Union(a_$3,b_$0)[y_$0] ));
	assume (forall<T> a_$4 : Set (T) , b_$1 : Set (T) , y_$1 : T :: {Set#Union(a_$4,b_$1),b_$1[y_$1]} ( b_$1[y_$1] ==> Set#Union(a_$4,b_$1)[y_$1] ));
	assume (forall<T> a_$5 : Set (T) , b_$2 : Set (T)  :: {Set#Union(a_$5,b_$2)} ( Set#Disjoint(a_$5,b_$2) ==> ((Set#Difference(Set#Union(a_$5,b_$2),a_$5) == b_$2) && (Set#Difference(Set#Union(a_$5,b_$2),b_$2) == a_$5)) ));
	assume (forall<T> a_$6 : Set (T) , b_$3 : Set (T) , o_$3 : T :: {Set#Intersection(a_$6,b_$3)[o_$3]} ( Set#Intersection(a_$6,b_$3)[o_$3] <==> (a_$6[o_$3] && b_$3[o_$3]) ));
	assume (forall<T> a_$7 : Set (T) , b_$4 : Set (T)  :: {Set#Union(Set#Union(a_$7,b_$4),b_$4)} ( Set#Union(Set#Union(a_$7,b_$4),b_$4) == Set#Union(a_$7,b_$4) ));
	assume (forall<T> a_$8 : Set (T) , b_$5 : Set (T)  :: {Set#Union(a_$8,Set#Union(a_$8,b_$5))} ( Set#Union(a_$8,Set#Union(a_$8,b_$5)) == Set#Union(a_$8,b_$5) ));
	assume (forall<T> a_$9 : Set (T) , b_$6 : Set (T)  :: {Set#Intersection(Set#Intersection(a_$9,b_$6),b_$6)} ( Set#Intersection(Set#Intersection(a_$9,b_$6),b_$6) == Set#Intersection(a_$9,b_$6) ));
	assume (forall<T> a_$10 : Set (T) , b_$7 : Set (T)  :: {Set#Intersection(a_$10,Set#Intersection(a_$10,b_$7))} ( Set#Intersection(a_$10,Set#Intersection(a_$10,b_$7)) == Set#Intersection(a_$10,b_$7) ));
	assume (forall<T> a_$11 : Set (T) , b_$8 : Set (T) , o_$4 : T :: {Set#Difference(a_$11,b_$8)[o_$4]} ( Set#Difference(a_$11,b_$8)[o_$4] <==> (a_$11[o_$4] && (!b_$8[o_$4])) ));
	assume (forall<T> a_$12 : Set (T) , b_$9 : Set (T) , y_$2 : T :: {Set#Difference(a_$12,b_$9),b_$9[y_$2]} ( b_$9[y_$2] ==> (!Set#Difference(a_$12,b_$9)[y_$2]) ));
	assume (forall<T> a_$13 : Set (T) , b_$10 : Set (T)  :: {Set#Subset(a_$13,b_$10)} ( Set#Subset(a_$13,b_$10) <==> ((forall  o_$5 : T :: {a_$13[o_$5]} {b_$10[o_$5]} ( a_$13[o_$5] ==> b_$10[o_$5] ))) ));
	assume (forall<T> a_$14 : Set (T) , b_$11 : Set (T)  :: {Set#Equal(a_$14,b_$11)} ( Set#Equal(a_$14,b_$11) <==> ((forall  o_$6 : T :: {a_$14[o_$6]} {b_$11[o_$6]} ( a_$14[o_$6] <==> b_$11[o_$6] ))) ));
	assume (forall<T> a_$15 : Set (T) , b_$12 : Set (T)  :: {Set#Equal(a_$15,b_$12)} ( Set#Equal(a_$15,b_$12) ==> (a_$15 == b_$12) ));
	assume (forall<T> a_$16 : Set (T) , b_$13 : Set (T)  :: {Set#Disjoint(a_$16,b_$13)} ( Set#Disjoint(a_$16,b_$13) <==> ((forall  o_$7 : T :: {a_$16[o_$7]} {b_$13[o_$7]} ( (!a_$16[o_$7]) || (!b_$13[o_$7]) ))) ));
	assume (forall<T> a_$17 : Set (T) , tick : TickType :: {Set#Choose(a_$17,tick)} ( (!(a_$17 == (Set#Empty() : Set (T) ))) ==> a_$17[Set#Choose(a_$17,tick)] ));
	assume (forall  a_$18 : Integer, b_$14 : Integer :: {Math#min(a_$18,b_$14)} ( (a_$18 <= b_$14) <==> (Math#min(a_$18,b_$14) == a_$18) ));
	assume (forall  a_$19 : Integer, b_$15 : Integer :: {Math#min(a_$19,b_$15)} ( (b_$15 <= a_$19) <==> (Math#min(a_$19,b_$15) == b_$15) ));
	assume (forall  a_$20 : Integer, b_$16 : Integer :: {Math#min(a_$20,b_$16)} ( (Math#min(a_$20,b_$16) == a_$20) || (Math#min(a_$20,b_$16) == b_$16) ));
	assume (forall  a_$21 : Integer :: {Math#clip(a_$21)} ( (0 <= a_$21) ==> (Math#clip(a_$21) == a_$21) ));
	assume (forall  a_$22 : Integer :: {Math#clip(a_$22)} ( (a_$22 < 0) ==> (Math#clip(a_$22) == 0) ));
	assume (forall<T> ms : MultiSet (T)  :: {$IsGoodMultiSet(ms)} ( $IsGoodMultiSet(ms) <==> ((forall  o_$8 : T :: {ms[o_$8]} ( 0 <= ms[o_$8] ))) ));
	assume (forall<T> o_$9 : T :: {(MultiSet#Empty() : MultiSet (T) )[o_$9]} ( (MultiSet#Empty() : MultiSet (T) )[o_$9] == 0 ));
	assume (forall<T> r_$3 : T, o_$10 : T :: {MultiSet#Singleton(r_$3)[o_$10]} ( ((MultiSet#Singleton(r_$3)[o_$10] == 1) <==> (r_$3 == o_$10)) && ((MultiSet#Singleton(r_$3)[o_$10] == 0) <==> (!(r_$3 == o_$10))) ));
	assume (forall<T> r_$4 : T :: {MultiSet#Singleton(r_$4)} ( MultiSet#Singleton(r_$4) == MultiSet#UnionOne((MultiSet#Empty() : MultiSet (T) ),r_$4) ));
	assume (forall<T> a_$23 : MultiSet (T) , x_$2 : T, o_$11 : T :: {MultiSet#UnionOne(a_$23,x_$2)[o_$11]} ( (0 < MultiSet#UnionOne(a_$23,x_$2)[o_$11]) <==> ((o_$11 == x_$2) || (0 < a_$23[o_$11])) ));
	assume (forall<T> a_$24 : MultiSet (T) , x_$3 : T :: {MultiSet#UnionOne(a_$24,x_$3)} ( MultiSet#UnionOne(a_$24,x_$3)[x_$3] == (a_$24[x_$3] + 1) ));
	assume (forall<T> a_$25 : MultiSet (T) , x_$4 : T, y_$3 : T :: {MultiSet#UnionOne(a_$25,x_$4),a_$25[y_$3]} ( (0 < a_$25[y_$3]) ==> (0 < MultiSet#UnionOne(a_$25,x_$4)[y_$3]) ));
	assume (forall<T> a_$26 : MultiSet (T) , x_$5 : T, y_$4 : T :: {MultiSet#UnionOne(a_$26,x_$5),a_$26[y_$4]} ( (!(x_$5 == y_$4)) ==> (a_$26[y_$4] == MultiSet#UnionOne(a_$26,x_$5)[y_$4]) ));
	assume (forall<T> a_$27 : MultiSet (T) , b_$17 : MultiSet (T) , o_$12 : T :: {MultiSet#Union(a_$27,b_$17)[o_$12]} ( MultiSet#Union(a_$27,b_$17)[o_$12] == (a_$27[o_$12] + b_$17[o_$12]) ));
	assume (forall<T> a_$28 : MultiSet (T) , b_$18 : MultiSet (T) , y_$5 : T :: {MultiSet#Union(a_$28,b_$18),a_$28[y_$5]} ( (0 < a_$28[y_$5]) ==> (0 < MultiSet#Union(a_$28,b_$18)[y_$5]) ));
	assume (forall<T> a_$29 : MultiSet (T) , b_$19 : MultiSet (T) , y_$6 : T :: {MultiSet#Union(a_$29,b_$19),b_$19[y_$6]} ( (0 < b_$19[y_$6]) ==> (0 < MultiSet#Union(a_$29,b_$19)[y_$6]) ));
	assume (forall<T> a_$30 : MultiSet (T) , b_$20 : MultiSet (T)  :: {MultiSet#Union(a_$30,b_$20)} ( (MultiSet#Difference(MultiSet#Union(a_$30,b_$20),a_$30) == b_$20) && (MultiSet#Difference(MultiSet#Union(a_$30,b_$20),b_$20) == a_$30) ));
	assume (forall<T> a_$31 : MultiSet (T) , b_$21 : MultiSet (T) , o_$13 : T :: {MultiSet#Intersection(a_$31,b_$21)[o_$13]} ( MultiSet#Intersection(a_$31,b_$21)[o_$13] == Math#min(a_$31[o_$13],b_$21[o_$13]) ));
	assume (forall<T> a_$32 : MultiSet (T) , b_$22 : MultiSet (T)  :: {MultiSet#Intersection(MultiSet#Intersection(a_$32,b_$22),b_$22)} ( MultiSet#Intersection(MultiSet#Intersection(a_$32,b_$22),b_$22) == MultiSet#Intersection(a_$32,b_$22) ));
	assume (forall<T> a_$33 : MultiSet (T) , b_$23 : MultiSet (T)  :: {MultiSet#Intersection(a_$33,MultiSet#Intersection(a_$33,b_$23))} ( MultiSet#Intersection(a_$33,MultiSet#Intersection(a_$33,b_$23)) == MultiSet#Intersection(a_$33,b_$23) ));
	assume (forall<T> a_$34 : MultiSet (T) , b_$24 : MultiSet (T) , o_$14 : T :: {MultiSet#Difference(a_$34,b_$24)[o_$14]} ( MultiSet#Difference(a_$34,b_$24)[o_$14] == Math#clip(a_$34[o_$14] - b_$24[o_$14]) ));
	assume (forall<T> a_$35 : MultiSet (T) , b_$25 : MultiSet (T) , y_$7 : T :: {MultiSet#Difference(a_$35,b_$25),b_$25[y_$7],a_$35[y_$7]} ( (a_$35[y_$7] <= b_$25[y_$7]) ==> (MultiSet#Difference(a_$35,b_$25)[y_$7] == 0) ));
	assume (forall<T> a_$36 : MultiSet (T) , b_$26 : MultiSet (T)  :: {MultiSet#Subset(a_$36,b_$26)} ( MultiSet#Subset(a_$36,b_$26) <==> ((forall  o_$15 : T :: {a_$36[o_$15]} {b_$26[o_$15]} ( a_$36[o_$15] <= b_$26[o_$15] ))) ));
	assume (forall<T> a_$37 : MultiSet (T) , b_$27 : MultiSet (T)  :: {MultiSet#Equal(a_$37,b_$27)} ( MultiSet#Equal(a_$37,b_$27) <==> ((forall  o_$16 : T :: {a_$37[o_$16]} {b_$27[o_$16]} ( a_$37[o_$16] == b_$27[o_$16] ))) ));
	assume (forall<T> a_$38 : MultiSet (T) , b_$28 : MultiSet (T)  :: {MultiSet#Equal(a_$38,b_$28)} ( MultiSet#Equal(a_$38,b_$28) ==> (a_$38 == b_$28) ));
	assume (forall<T> a_$39 : MultiSet (T) , b_$29 : MultiSet (T)  :: {MultiSet#Disjoint(a_$39,b_$29)} ( MultiSet#Disjoint(a_$39,b_$29) <==> ((forall  o_$17 : T :: {a_$39[o_$17]} {b_$29[o_$17]} ( (a_$39[o_$17] == 0) || (b_$29[o_$17] == 0) ))) ));
	assume (forall<T> s : Set (T) , a_$40 : T :: {MultiSet#FromSet(s)[a_$40]} ( ((MultiSet#FromSet(s)[a_$40] == 0) <==> (!s[a_$40])) && ((MultiSet#FromSet(s)[a_$40] == 1) <==> s[a_$40]) ));
	assume (forall<T> s_$0 : Seq (T)  :: {MultiSet#FromSeq(s_$0)} ( $IsGoodMultiSet(MultiSet#FromSeq(s_$0)) ));
	assume (forall<T> s_$1 : Seq (T) , v_$0 : T :: {MultiSet#FromSeq(Seq#Build(s_$1,v_$0))} ( MultiSet#FromSeq(Seq#Build(s_$1,v_$0)) == MultiSet#UnionOne(MultiSet#FromSeq(s_$1),v_$0) ));
	assume (forall<T> :: MultiSet#FromSeq((Seq#Empty() : Seq (T) )) == (MultiSet#Empty() : MultiSet (T) ));
	assume (forall<T> a_$41 : Seq (T) , b_$30 : Seq (T)  :: {MultiSet#FromSeq(Seq#Append(a_$41,b_$30))} ( MultiSet#FromSeq(Seq#Append(a_$41,b_$30)) == MultiSet#Union(MultiSet#FromSeq(a_$41),MultiSet#FromSeq(b_$30)) ));
	assume (forall<T> s_$2 : Seq (T) , i : Integer, v_$1 : T, x_$6 : T :: {MultiSet#FromSeq(Seq#Update(s_$2,i,v_$1))[x_$6]} ( ((0 <= i) && (i < Seq#Length(s_$2))) ==> (MultiSet#FromSeq(Seq#Update(s_$2,i,v_$1))[x_$6] == MultiSet#Union(MultiSet#Difference(MultiSet#FromSeq(s_$2),MultiSet#Singleton(Seq#Index(s_$2,i))),MultiSet#Singleton(v_$1))[x_$6]) ));
	assume (forall<T> s_$3 : Seq (T) , x_$7 : T :: {MultiSet#FromSeq(s_$3)[x_$7]} ( ((exists  i_$0 : Integer :: {Seq#Index(s_$3,i_$0)} ( ((0 <= i_$0) && (i_$0 < Seq#Length(s_$3))) && (x_$7 == Seq#Index(s_$3,i_$0)) ))) <==> (0 < MultiSet#FromSeq(s_$3)[x_$7]) ));
	assume (forall<T> s_$4 : Seq (T)  :: {Seq#Length(s_$4)} ( 0 <= Seq#Length(s_$4) ));
	assume (forall<T> :: Seq#Length((Seq#Empty() : Seq (T) )) == 0);
	assume (forall<T> s_$5 : Seq (T)  :: {Seq#Length(s_$5)} ( (Seq#Length(s_$5) == 0) ==> (s_$5 == (Seq#Empty() : Seq (T) )) ));
	assume (forall<T> t : T :: {Seq#Length(Seq#Singleton(t))} ( Seq#Length(Seq#Singleton(t)) == 1 ));
	assume (forall<T> s_$6 : Seq (T) , v_$2 : T :: {Seq#Length(Seq#Build(s_$6,v_$2))} ( Seq#Length(Seq#Build(s_$6,v_$2)) == (1 + Seq#Length(s_$6)) ));
	assume (forall<T> s_$7 : Seq (T) , i_$1 : Integer, v_$3 : T :: {Seq#Index(Seq#Build(s_$7,v_$3),i_$1)} ( ((i_$1 == Seq#Length(s_$7)) ==> (Seq#Index(Seq#Build(s_$7,v_$3),i_$1) == v_$3)) && ((!(i_$1 == Seq#Length(s_$7))) ==> (Seq#Index(Seq#Build(s_$7,v_$3),i_$1) == Seq#Index(s_$7,i_$1))) ));
	assume (forall<T> s0 : Seq (T) , s1 : Seq (T)  :: {Seq#Length(Seq#Append(s0,s1))} ( Seq#Length(Seq#Append(s0,s1)) == (Seq#Length(s0) + Seq#Length(s1)) ));
	assume (forall<T> t_$0 : T :: {Seq#Index(Seq#Singleton(t_$0),0)} ( Seq#Index(Seq#Singleton(t_$0),0) == t_$0 ));
	assume (forall<T> s0_$0 : Seq (T) , s1_$0 : Seq (T) , n : Integer :: {Seq#Index(Seq#Append(s0_$0,s1_$0),n)} ( ((n < Seq#Length(s0_$0)) ==> (Seq#Index(Seq#Append(s0_$0,s1_$0),n) == Seq#Index(s0_$0,n))) && ((Seq#Length(s0_$0) <= n) ==> (Seq#Index(Seq#Append(s0_$0,s1_$0),n) == Seq#Index(s1_$0,n - Seq#Length(s0_$0)))) ));
	assume (forall<T> s_$8 : Seq (T) , i_$2 : Integer, v_$4 : T :: {Seq#Length(Seq#Update(s_$8,i_$2,v_$4))} ( ((0 <= i_$2) && (i_$2 < Seq#Length(s_$8))) ==> (Seq#Length(Seq#Update(s_$8,i_$2,v_$4)) == Seq#Length(s_$8)) ));
	assume (forall<T> s_$9 : Seq (T) , i_$3 : Integer, v_$5 : T, n_$0 : Integer :: {Seq#Index(Seq#Update(s_$9,i_$3,v_$5),n_$0)} ( ((0 <= n_$0) && (n_$0 < Seq#Length(s_$9))) ==> (((i_$3 == n_$0) ==> (Seq#Index(Seq#Update(s_$9,i_$3,v_$5),n_$0) == v_$5)) && ((!(i_$3 == n_$0)) ==> (Seq#Index(Seq#Update(s_$9,i_$3,v_$5),n_$0) == Seq#Index(s_$9,n_$0)))) ));
	assume (forall<T> s_$10 : Seq (T) , x_$8 : T :: {Seq#Contains(s_$10,x_$8)} ( Seq#Contains(s_$10,x_$8) <==> ((exists  i_$4 : Integer :: {Seq#Index(s_$10,i_$4)} ( ((0 <= i_$4) && (i_$4 < Seq#Length(s_$10))) && (Seq#Index(s_$10,i_$4) == x_$8) ))) ));
	assume (forall  x_$9 : ref :: {Seq#Contains((Seq#Empty() : Seq (ref) ),x_$9)} ( !Seq#Contains((Seq#Empty() : Seq (ref) ),x_$9) ));
	assume (forall<T> s0_$1 : Seq (T) , s1_$1 : Seq (T) , x_$10 : T :: {Seq#Contains(Seq#Append(s0_$1,s1_$1),x_$10)} ( Seq#Contains(Seq#Append(s0_$1,s1_$1),x_$10) <==> (Seq#Contains(s0_$1,x_$10) || Seq#Contains(s1_$1,x_$10)) ));
	assume (forall<T> s_$11 : Seq (T) , v_$6 : T, x_$11 : T :: {Seq#Contains(Seq#Build(s_$11,v_$6),x_$11)} ( Seq#Contains(Seq#Build(s_$11,v_$6),x_$11) <==> ((v_$6 == x_$11) || Seq#Contains(s_$11,x_$11)) ));
	assume (forall<T> s_$12 : Seq (T) , n_$1 : Integer, x_$12 : T :: {Seq#Contains(Seq#Take(s_$12,n_$1),x_$12)} ( Seq#Contains(Seq#Take(s_$12,n_$1),x_$12) <==> ((exists  i_$5 : Integer :: {Seq#Index(s_$12,i_$5)} ( (((0 <= i_$5) && (i_$5 < n_$1)) && (i_$5 < Seq#Length(s_$12))) && (Seq#Index(s_$12,i_$5) == x_$12) ))) ));
	assume (forall<T> s_$13 : Seq (T) , n_$2 : Integer, x_$13 : T :: {Seq#Contains(Seq#Drop(s_$13,n_$2),x_$13)} ( Seq#Contains(Seq#Drop(s_$13,n_$2),x_$13) <==> ((exists  i_$6 : Integer :: {Seq#Index(s_$13,i_$6)} ( (((0 <= n_$2) && (n_$2 <= i_$6)) && (i_$6 < Seq#Length(s_$13))) && (Seq#Index(s_$13,i_$6) == x_$13) ))) ));
	assume (forall<T> s0_$2 : Seq (T) , s1_$2 : Seq (T)  :: {Seq#Equal(s0_$2,s1_$2)} ( Seq#Equal(s0_$2,s1_$2) <==> ((Seq#Length(s0_$2) == Seq#Length(s1_$2)) && ((forall  j : Integer :: {Seq#Index(s0_$2,j)} {Seq#Index(s1_$2,j)} ( ((0 <= j) && (j < Seq#Length(s0_$2))) ==> (Seq#Index(s0_$2,j) == Seq#Index(s1_$2,j)) )))) ));
	assume (forall<T> a_$42 : Seq (T) , b_$31 : Seq (T)  :: {Seq#Equal(a_$42,b_$31)} ( Seq#Equal(a_$42,b_$31) ==> (a_$42 == b_$31) ));
	assume (forall<T> s0_$3 : Seq (T) , s1_$3 : Seq (T) , n_$3 : Integer :: {Seq#SameUntil(s0_$3,s1_$3,n_$3)} ( Seq#SameUntil(s0_$3,s1_$3,n_$3) <==> ((forall  j_$0 : Integer :: {Seq#Index(s0_$3,j_$0)} {Seq#Index(s1_$3,j_$0)} ( ((0 <= j_$0) && (j_$0 < n_$3)) ==> (Seq#Index(s0_$3,j_$0) == Seq#Index(s1_$3,j_$0)) ))) ));
	assume (forall<T> s_$14 : Seq (T) , n_$4 : Integer :: {Seq#Length(Seq#Take(s_$14,n_$4))} ( (0 <= n_$4) ==> (((n_$4 <= Seq#Length(s_$14)) ==> (Seq#Length(Seq#Take(s_$14,n_$4)) == n_$4)) && ((Seq#Length(s_$14) < n_$4) ==> (Seq#Length(Seq#Take(s_$14,n_$4)) == Seq#Length(s_$14)))) ));
	assume (forall<T> s_$15 : Seq (T) , n_$5 : Integer, j_$1 : Integer :: {Seq#Index(Seq#Take(s_$15,n_$5),j_$1)} {:weight  25}( (((0 <= j_$1) && (j_$1 < n_$5)) && (j_$1 < Seq#Length(s_$15))) ==> (Seq#Index(Seq#Take(s_$15,n_$5),j_$1) == Seq#Index(s_$15,j_$1)) ));
	assume (forall<T> s_$16 : Seq (T) , n_$6 : Integer :: {Seq#Length(Seq#Drop(s_$16,n_$6))} ( (0 <= n_$6) ==> (((n_$6 <= Seq#Length(s_$16)) ==> (Seq#Length(Seq#Drop(s_$16,n_$6)) == (Seq#Length(s_$16) - n_$6))) && ((Seq#Length(s_$16) < n_$6) ==> (Seq#Length(Seq#Drop(s_$16,n_$6)) == 0))) ));
	assume (forall<T> s_$17 : Seq (T) , n_$7 : Integer, j_$2 : Integer :: {Seq#Index(Seq#Drop(s_$17,n_$7),j_$2)} {:weight  25}( (((0 <= n_$7) && (0 <= j_$2)) && (j_$2 < (Seq#Length(s_$17) - n_$7))) ==> (Seq#Index(Seq#Drop(s_$17,n_$7),j_$2) == Seq#Index(s_$17,j_$2 + n_$7)) ));
	assume (forall<T> s_$18 : Seq (T) , t_$1 : Seq (T)  :: {Seq#Append(s_$18,t_$1)} ( (Seq#Take(Seq#Append(s_$18,t_$1),Seq#Length(s_$18)) == s_$18) && (Seq#Drop(Seq#Append(s_$18,t_$1),Seq#Length(s_$18)) == t_$1) ));
	assume (forall  h : HeapType, a_$43 : ref :: {Seq#Length(Seq#FromArray(h,a_$43))} ( Seq#Length(Seq#FromArray(h,a_$43)) == array.Length(a_$43) ));
	assume (forall  h_$0 : HeapType, a_$44 : ref, i_$7 : Integer :: ( ((0 <= i_$7) && (i_$7 < Seq#Length(Seq#FromArray(h_$0,a_$44)))) ==> (Seq#Index(Seq#FromArray(h_$0,a_$44),i_$7) == read(h_$0,a_$44,IndexField(i_$7))) ));
	assume (forall<alpha> h_$1 : HeapType, o_$18 : ref, f_$1 : Field (alpha) , v_$7 : alpha, a_$45 : ref :: {Seq#FromArray(update(h_$1,o_$18,f_$1,v_$7),a_$45)} ( (!(o_$18 == a_$45)) ==> (Seq#FromArray(update(h_$1,o_$18,f_$1,v_$7),a_$45) == Seq#FromArray(h_$1,a_$45)) ));
	assume (forall  h_$2 : HeapType, i_$8 : Integer, v_$8 : BoxType, a_$46 : ref :: {Seq#FromArray(update(h_$2,a_$46,IndexField(i_$8),v_$8),a_$46)} ( ((0 <= i_$8) && (i_$8 < array.Length(a_$46))) ==> (Seq#FromArray(update(h_$2,a_$46,IndexField(i_$8),v_$8),a_$46) == Seq#Update(Seq#FromArray(h_$2,a_$46),i_$8,v_$8)) ));
	assume (forall<T> s_$19 : Seq (T) , i_$9 : Integer, v_$9 : T, n_$8 : Integer :: {Seq#Take(Seq#Update(s_$19,i_$9,v_$9),n_$8)} ( (((0 <= i_$9) && (i_$9 < n_$8)) && (n_$8 <= Seq#Length(s_$19))) ==> (Seq#Take(Seq#Update(s_$19,i_$9,v_$9),n_$8) == Seq#Update(Seq#Take(s_$19,n_$8),i_$9,v_$9)) ));
	assume (forall<T> s_$20 : Seq (T) , i_$10 : Integer, v_$10 : T, n_$9 : Integer :: {Seq#Take(Seq#Update(s_$20,i_$10,v_$10),n_$9)} ( ((n_$9 <= i_$10) && (i_$10 < Seq#Length(s_$20))) ==> (Seq#Take(Seq#Update(s_$20,i_$10,v_$10),n_$9) == Seq#Take(s_$20,n_$9)) ));
	assume (forall<T> s_$21 : Seq (T) , i_$11 : Integer, v_$11 : T, n_$10 : Integer :: {Seq#Drop(Seq#Update(s_$21,i_$11,v_$11),n_$10)} ( (((0 <= n_$10) && (n_$10 <= i_$11)) && (i_$11 < Seq#Length(s_$21))) ==> (Seq#Drop(Seq#Update(s_$21,i_$11,v_$11),n_$10) == Seq#Update(Seq#Drop(s_$21,n_$10),i_$11 - n_$10,v_$11)) ));
	assume (forall<T> s_$22 : Seq (T) , i_$12 : Integer, v_$12 : T, n_$11 : Integer :: {Seq#Drop(Seq#Update(s_$22,i_$12,v_$12),n_$11)} ( (((0 <= i_$12) && (i_$12 < n_$11)) && (n_$11 < Seq#Length(s_$22))) ==> (Seq#Drop(Seq#Update(s_$22,i_$12,v_$12),n_$11) == Seq#Drop(s_$22,n_$11)) ));
	assume (forall  h_$3 : HeapType, a_$47 : ref, n0 : Integer, n1 : Integer :: {Seq#Take(Seq#FromArray(h_$3,a_$47),n0),Seq#Take(Seq#FromArray(h_$3,a_$47),n1)} ( ((((n0 + 1) == n1) && (0 <= n0)) && (n1 <= array.Length(a_$47))) ==> (Seq#Take(Seq#FromArray(h_$3,a_$47),n1) == Seq#Build(Seq#Take(Seq#FromArray(h_$3,a_$47),n0),read(h_$3,a_$47,IndexField(n0)))) ));
	assume (forall<T> s_$23 : Seq (T) , v_$13 : T, n_$12 : Integer :: {Seq#Drop(Seq#Build(s_$23,v_$13),n_$12)} ( ((0 <= n_$12) && (n_$12 <= Seq#Length(s_$23))) ==> (Seq#Drop(Seq#Build(s_$23,v_$13),n_$12) == Seq#Build(Seq#Drop(s_$23,n_$12),v_$13)) ));
	assume (forall<T> x_$14 : T :: {$Box(x_$14)} ( ($Unbox($Box(x_$14)) : T) == x_$14 ));
	assume (forall  b_$32 : BoxType :: {($Unbox(b_$32) : Integer)} ( $Box(($Unbox(b_$32) : Integer)) == b_$32 ));
	assume (forall  b_$33 : BoxType :: {($Unbox(b_$33) : ref)} ( $Box(($Unbox(b_$33) : ref)) == b_$33 ));
	assume (forall  b_$34 : BoxType :: {($Unbox(b_$34) : [BoxType]Boolean)} ( $Box(($Unbox(b_$34) : [BoxType]Boolean)) == b_$34 ));
	assume (forall  b_$35 : BoxType :: {($Unbox(b_$35) : Seq (BoxType) )} ( $Box(($Unbox(b_$35) : Seq (BoxType) )) == b_$35 ));
	assume (forall  b_$36 : BoxType :: {($Unbox(b_$36) : DatatypeType)} ( $Box(($Unbox(b_$36) : DatatypeType)) == b_$36 ));
	assume $IsCanonicalBoolBox($Box(false)) && $IsCanonicalBoolBox($Box(true));
	assume (forall  b_$37 : BoxType :: {($Unbox(b_$37) : Boolean)} ( $IsCanonicalBoolBox(b_$37) ==> ($Box(($Unbox(b_$37) : Boolean)) == b_$37) ));
	assume (forall  a_$48 : ClassName, b_$38 : ClassName :: {TypeTuple(a_$48,b_$38)} ( (TypeTupleCar(TypeTuple(a_$48,b_$38)) == a_$48) && (TypeTupleCdr(TypeTuple(a_$48,b_$38)) == b_$38) ));
	assume (forall  i_$13 : Integer :: {IndexField(i_$13)} ( FDim(IndexField(i_$13)) == 1 ));
	assume (forall  i_$14 : Integer :: {IndexField(i_$14)} ( IndexField_Inverse(IndexField(i_$14)) == i_$14 ));
	assume (forall  f_$2 : Field (BoxType) , i_$15 : Integer :: {MultiIndexField(f_$2,i_$15)} ( FDim(MultiIndexField(f_$2,i_$15)) == (FDim(f_$2) + 1) ));
	assume (forall  f_$3 : Field (BoxType) , i_$16 : Integer :: {MultiIndexField(f_$3,i_$16)} ( (MultiIndexField_Inverse0(MultiIndexField(f_$3,i_$16)) == f_$3) && (MultiIndexField_Inverse1(MultiIndexField(f_$3,i_$16)) == i_$16) ));
	assume FDim(alloc) == 0;
	assume (forall  h_$4 : HeapType, k : HeapType, d : DatatypeType :: {$HeapSucc(h_$4,k),DtAlloc(d,h_$4)} {$HeapSucc(h_$4,k),DtAlloc(d,k)} ( $HeapSucc(h_$4,k) ==> (DtAlloc(d,h_$4) ==> DtAlloc(d,k)) ));
	assume (forall  h_$5 : HeapType, k_$0 : HeapType, d_$0 : BoxType :: {$HeapSucc(h_$5,k_$0),GenericAlloc(d_$0,h_$5)} {$HeapSucc(h_$5,k_$0),GenericAlloc(d_$0,k_$0)} ( $HeapSucc(h_$5,k_$0) ==> (GenericAlloc(d_$0,h_$5) ==> GenericAlloc(d_$0,k_$0)) ));
	assume (forall  b_$39 : BoxType, h_$6 : HeapType :: {GenericAlloc(b_$39,h_$6),h_$6[($Unbox(b_$39) : ref),alloc]} ( GenericAlloc(b_$39,h_$6) ==> ((($Unbox(b_$39) : ref) == null) || h_$6[($Unbox(b_$39) : ref),alloc]) ));
	assume (forall  b_$40 : BoxType, h_$7 : HeapType, i_$17 : Integer :: {GenericAlloc(b_$40,h_$7),Seq#Index(($Unbox(b_$40) : Seq (BoxType) ),i_$17)} ( ((GenericAlloc(b_$40,h_$7) && (0 <= i_$17)) && (i_$17 < Seq#Length(($Unbox(b_$40) : Seq (BoxType) )))) ==> GenericAlloc(Seq#Index(($Unbox(b_$40) : Seq (BoxType) ),i_$17),h_$7) ));
	assume (forall  b_$41 : BoxType, h_$8 : HeapType, t_$2 : BoxType :: {GenericAlloc(b_$41,h_$8),($Unbox(b_$41) : [BoxType]Boolean)[t_$2]} ( (GenericAlloc(b_$41,h_$8) && ($Unbox(b_$41) : [BoxType]Boolean)[t_$2]) ==> GenericAlloc(t_$2,h_$8) ));
	assume (forall  b_$42 : BoxType, h_$9 : HeapType :: {GenericAlloc(b_$42,h_$9),DtType(($Unbox(b_$42) : DatatypeType))} ( GenericAlloc(b_$42,h_$9) ==> DtAlloc(($Unbox(b_$42) : DatatypeType),h_$9) ));
	assume (forall  b_$43 : Boolean, h_$10 : HeapType :: ( $IsGoodHeap(h_$10) ==> GenericAlloc($Box(b_$43),h_$10) ));
	assume (forall  x_$15 : Integer, h_$11 : HeapType :: ( $IsGoodHeap(h_$11) ==> GenericAlloc($Box(x_$15),h_$11) ));
	assume (forall  r_$5 : ref, h_$12 : HeapType :: {GenericAlloc($Box(r_$5),h_$12)} ( ($IsGoodHeap(h_$12) && ((r_$5 == null) || h_$12[r_$5,alloc])) ==> GenericAlloc($Box(r_$5),h_$12) ));
	assume (forall  o_$19 : ref :: ( 0 <= array.Length(o_$19) ));
	assume (forall<alpha> f : Field (alpha) , r : ref, H : HeapType :: ( read(H,r,f) == H[r,f] ));
	assume (forall<alpha> v : alpha, f_$0 : Field (alpha) , r_$0 : ref, H_$0 : HeapType :: ( update(H_$0,r_$0,f_$0,v) == H_$0[r_$0,f_$0 := v] ));
	assume (forall<alpha> h_$13 : HeapType, r_$6 : ref, f_$4 : Field (alpha) , x_$16 : alpha :: {update(h_$13,r_$6,f_$4,x_$16)} ( $IsGoodHeap(update(h_$13,r_$6,f_$4,x_$16)) ==> $HeapSucc(h_$13,update(h_$13,r_$6,f_$4,x_$16)) ));
	assume (forall  h_$14 : HeapType, k_$1 : HeapType :: {$HeapSucc(h_$14,k_$1)} ( $HeapSucc(h_$14,k_$1) ==> ((forall  o_$20 : ref :: {read(k_$1,o_$20,alloc)} ( read(h_$14,o_$20,alloc) ==> read(k_$1,o_$20,alloc) ))) ));
	assume (forall  x_$17 : Integer, y_$8 : Integer :: {x_$17 mod y_$8} {x_$17 div y_$8} ( (x_$17 mod y_$8) == (x_$17 - ((x_$17 div y_$8) * y_$8)) ));
	assume (forall  x_$18 : Integer, y_$9 : Integer :: {x_$18 mod y_$9} ( (0 < y_$9) ==> ((0 <= (x_$18 mod y_$9)) && ((x_$18 mod y_$9) < y_$9)) ));
	assume (forall  x_$19 : Integer, y_$10 : Integer :: {x_$19 mod y_$10} ( (y_$10 < 0) ==> ((0 <= (x_$19 mod y_$10)) && ((x_$19 mod y_$10) < (0 - y_$10))) ));
	assume (forall  a_$49 : Integer, b_$44 : Integer, d_$1 : Integer :: {a_$49 mod d_$1,b_$44 mod d_$1} ( (((2 <= d_$1) && ((a_$49 mod d_$1) == (b_$44 mod d_$1))) && (a_$49 < b_$44)) ==> ((a_$49 + d_$1) <= b_$44) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((0 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$0 : HeapType, this_$0 : ref, x#0 : BoxType :: {BreadthFirstSearch.Succ($Heap_$0,this_$0,x#0)} ( (BreadthFirstSearch.Succ#canCall($Heap_$0,this_$0,x#0) || ((((((((!(0 == $ModuleContextHeight)) || (!(0 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$0)) && (!(this_$0 == null))) && read($Heap_$0,this_$0,alloc)) && (dtype(this_$0) == class.BreadthFirstSearch)) && GenericAlloc(x#0,$Heap_$0))) ==> ((forall  $t#0 : BoxType :: {BreadthFirstSearch.Succ($Heap_$0,this_$0,x#0)[$t#0]} ( BreadthFirstSearch.Succ($Heap_$0,this_$0,x#0)[$t#0] ==> GenericAlloc($t#0,$Heap_$0) ))) )));
	assume (forall  $h0 : HeapType, $h1 : HeapType, this_$1 : ref, x#0_$0 : BoxType :: {$HeapSucc($h0,$h1),BreadthFirstSearch.Succ($h1,this_$1,x#0_$0)} ( ((((((((($IsGoodHeap($h0) && $IsGoodHeap($h1)) && (!(this_$1 == null))) && read($h0,this_$1,alloc)) && (dtype(this_$1) == class.BreadthFirstSearch)) && read($h1,this_$1,alloc)) && (dtype(this_$1) == class.BreadthFirstSearch)) && GenericAlloc(x#0_$0,$h0)) && GenericAlloc(x#0_$0,$h1)) && $HeapSucc($h0,$h1)) ==> (((forall<alpha> $o : ref, $f : Field (alpha)  :: ( false ==> (read($h0,$o,$f) == read($h1,$o,$f)) ))) ==> (BreadthFirstSearch.Succ($h0,this_$1,x#0_$0) == BreadthFirstSearch.Succ($h1,this_$1,x#0_$0))) ));
	assume (forall  $Heap_$1 : HeapType, this_$2 : ref, source#1 : BoxType, dest#2 : BoxType, p#3 : Seq (BoxType)  :: {BreadthFirstSearch.IsPath#2($Heap_$1,this_$2,source#1,dest#2,p#3)} ( BreadthFirstSearch.IsPath#2($Heap_$1,this_$2,source#1,dest#2,p#3) <==> BreadthFirstSearch.IsPath($Heap_$1,this_$2,source#1,dest#2,p#3) ));
	assume (forall  $Heap_$2 : HeapType, this_$3 : ref, source#1_$0 : BoxType, dest#2_$0 : BoxType, p#3_$0 : Seq (BoxType)  :: {BreadthFirstSearch.IsPath($Heap_$2,this_$3,source#1_$0,dest#2_$0,p#3_$0)} ( BreadthFirstSearch.IsPath($Heap_$2,this_$3,source#1_$0,dest#2_$0,p#3_$0) <==> BreadthFirstSearch.IsPath#limited($Heap_$2,this_$3,source#1_$0,dest#2_$0,p#3_$0) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((1 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$3 : HeapType, this_$4 : ref, source#1_$1 : BoxType, dest#2_$1 : BoxType, p#3_$1 : Seq (BoxType)  :: {BreadthFirstSearch.IsPath($Heap_$3,this_$4,source#1_$1,dest#2_$1,p#3_$1)} ( (BreadthFirstSearch.IsPath#canCall($Heap_$3,this_$4,source#1_$1,dest#2_$1,p#3_$1) || ((((((((((!(0 == $ModuleContextHeight)) || (!(1 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$3)) && (!(this_$4 == null))) && read($Heap_$3,this_$4,alloc)) && (dtype(this_$4) == class.BreadthFirstSearch)) && GenericAlloc(source#1_$1,$Heap_$3)) && GenericAlloc(dest#2_$1,$Heap_$3)) && ((forall  $i#1 : Integer :: {Seq#Index(p#3_$1,$i#1)} ( ((0 <= $i#1) && ($i#1 < Seq#Length(p#3_$1))) ==> GenericAlloc(Seq#Index(p#3_$1,$i#1),$Heap_$3) ))))) ==> ((((source#1_$1 == dest#2_$1) ==> true) && ((!(source#1_$1 == dest#2_$1)) ==> (((!Seq#Equal(p#3_$1,(Seq#Empty() : Seq (BoxType) ))) ==> BreadthFirstSearch.Succ#canCall($Heap_$3,this_$4,Seq#Index(p#3_$1,Seq#Length(p#3_$1) - 1))) && (((!Seq#Equal(p#3_$1,(Seq#Empty() : Seq (BoxType) ))) && BreadthFirstSearch.Succ($Heap_$3,this_$4,Seq#Index(p#3_$1,Seq#Length(p#3_$1) - 1))[dest#2_$1]) ==> BreadthFirstSearch.IsPath#canCall($Heap_$3,this_$4,source#1_$1,Seq#Index(p#3_$1,Seq#Length(p#3_$1) - 1),Seq#Take(p#3_$1,Seq#Length(p#3_$1) - 1)))))) && (BreadthFirstSearch.IsPath($Heap_$3,this_$4,source#1_$1,dest#2_$1,p#3_$1) <==> (if (source#1_$1 == dest#2_$1) then Seq#Equal(p#3_$1,(Seq#Empty() : Seq (BoxType) )) else (((!Seq#Equal(p#3_$1,(Seq#Empty() : Seq (BoxType) ))) && BreadthFirstSearch.Succ($Heap_$3,this_$4,Seq#Index(p#3_$1,Seq#Length(p#3_$1) - 1))[dest#2_$1]) && BreadthFirstSearch.IsPath#limited($Heap_$3,this_$4,source#1_$1,Seq#Index(p#3_$1,Seq#Length(p#3_$1) - 1),Seq#Take(p#3_$1,Seq#Length(p#3_$1) - 1)))))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((1 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$4 : HeapType, this_$5 : ref, source#1_$2 : BoxType, dest#2_$2 : BoxType, p#3_$2 : Seq (BoxType)  :: {BreadthFirstSearch.IsPath#2($Heap_$4,this_$5,source#1_$2,dest#2_$2,p#3_$2)} ( (BreadthFirstSearch.IsPath#canCall($Heap_$4,this_$5,source#1_$2,dest#2_$2,p#3_$2) || ((((((((((!(0 == $ModuleContextHeight)) || (!(1 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$4)) && (!(this_$5 == null))) && read($Heap_$4,this_$5,alloc)) && (dtype(this_$5) == class.BreadthFirstSearch)) && GenericAlloc(source#1_$2,$Heap_$4)) && GenericAlloc(dest#2_$2,$Heap_$4)) && ((forall  $i#2 : Integer :: {Seq#Index(p#3_$2,$i#2)} ( ((0 <= $i#2) && ($i#2 < Seq#Length(p#3_$2))) ==> GenericAlloc(Seq#Index(p#3_$2,$i#2),$Heap_$4) ))))) ==> (BreadthFirstSearch.IsPath#2($Heap_$4,this_$5,source#1_$2,dest#2_$2,p#3_$2) <==> (if (source#1_$2 == dest#2_$2) then Seq#Equal(p#3_$2,(Seq#Empty() : Seq (BoxType) )) else (((!Seq#Equal(p#3_$2,(Seq#Empty() : Seq (BoxType) ))) && BreadthFirstSearch.Succ($Heap_$4,this_$5,Seq#Index(p#3_$2,Seq#Length(p#3_$2) - 1))[dest#2_$2]) && BreadthFirstSearch.IsPath($Heap_$4,this_$5,source#1_$2,Seq#Index(p#3_$2,Seq#Length(p#3_$2) - 1),Seq#Take(p#3_$2,Seq#Length(p#3_$2) - 1))))) )));
	assume (forall  $h0_$0 : HeapType, $h1_$0 : HeapType, this_$6 : ref, source#1_$3 : BoxType, dest#2_$3 : BoxType, p#3_$3 : Seq (BoxType)  :: {$HeapSucc($h0_$0,$h1_$0),BreadthFirstSearch.IsPath($h1_$0,this_$6,source#1_$3,dest#2_$3,p#3_$3)} ( ((((((((((((($IsGoodHeap($h0_$0) && $IsGoodHeap($h1_$0)) && (!(this_$6 == null))) && read($h0_$0,this_$6,alloc)) && (dtype(this_$6) == class.BreadthFirstSearch)) && read($h1_$0,this_$6,alloc)) && (dtype(this_$6) == class.BreadthFirstSearch)) && GenericAlloc(source#1_$3,$h0_$0)) && GenericAlloc(source#1_$3,$h1_$0)) && GenericAlloc(dest#2_$3,$h0_$0)) && GenericAlloc(dest#2_$3,$h1_$0)) && ((forall  $i#3 : Integer :: {Seq#Index(p#3_$3,$i#3)} ( ((0 <= $i#3) && ($i#3 < Seq#Length(p#3_$3))) ==> GenericAlloc(Seq#Index(p#3_$3,$i#3),$h0_$0) )))) && ((forall  $i#4 : Integer :: {Seq#Index(p#3_$3,$i#4)} ( ((0 <= $i#4) && ($i#4 < Seq#Length(p#3_$3))) ==> GenericAlloc(Seq#Index(p#3_$3,$i#4),$h1_$0) )))) && $HeapSucc($h0_$0,$h1_$0)) ==> (((forall<alpha> $o_$0 : ref, $f_$0 : Field (alpha)  :: ( false ==> (read($h0_$0,$o_$0,$f_$0) == read($h1_$0,$o_$0,$f_$0)) ))) ==> (BreadthFirstSearch.IsPath($h0_$0,this_$6,source#1_$3,dest#2_$3,p#3_$3) <==> BreadthFirstSearch.IsPath($h1_$0,this_$6,source#1_$3,dest#2_$3,p#3_$3))) ));
	assume (forall  $h0_$1 : HeapType, $h1_$1 : HeapType, this_$7 : ref, source#1_$4 : BoxType, dest#2_$4 : BoxType, p#3_$4 : Seq (BoxType)  :: {$HeapSucc($h0_$1,$h1_$1),BreadthFirstSearch.IsPath#limited($h1_$1,this_$7,source#1_$4,dest#2_$4,p#3_$4)} ( ((((((((((((($IsGoodHeap($h0_$1) && $IsGoodHeap($h1_$1)) && (!(this_$7 == null))) && read($h0_$1,this_$7,alloc)) && (dtype(this_$7) == class.BreadthFirstSearch)) && read($h1_$1,this_$7,alloc)) && (dtype(this_$7) == class.BreadthFirstSearch)) && GenericAlloc(source#1_$4,$h0_$1)) && GenericAlloc(source#1_$4,$h1_$1)) && GenericAlloc(dest#2_$4,$h0_$1)) && GenericAlloc(dest#2_$4,$h1_$1)) && ((forall  $i#3_$0 : Integer :: {Seq#Index(p#3_$4,$i#3_$0)} ( ((0 <= $i#3_$0) && ($i#3_$0 < Seq#Length(p#3_$4))) ==> GenericAlloc(Seq#Index(p#3_$4,$i#3_$0),$h0_$1) )))) && ((forall  $i#4_$0 : Integer :: {Seq#Index(p#3_$4,$i#4_$0)} ( ((0 <= $i#4_$0) && ($i#4_$0 < Seq#Length(p#3_$4))) ==> GenericAlloc(Seq#Index(p#3_$4,$i#4_$0),$h1_$1) )))) && $HeapSucc($h0_$1,$h1_$1)) ==> (((forall<alpha> $o_$1 : ref, $f_$1 : Field (alpha)  :: ( false ==> (read($h0_$1,$o_$1,$f_$1) == read($h1_$1,$o_$1,$f_$1)) ))) ==> (BreadthFirstSearch.IsPath#limited($h0_$1,this_$7,source#1_$4,dest#2_$4,p#3_$4) <==> BreadthFirstSearch.IsPath#limited($h1_$1,this_$7,source#1_$4,dest#2_$4,p#3_$4))) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((2 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$5 : HeapType, this_$8 : ref, S#4 : Set (BoxType)  :: {BreadthFirstSearch.IsClosed($Heap_$5,this_$8,S#4)} ( (BreadthFirstSearch.IsClosed#canCall($Heap_$5,this_$8,S#4) || ((((((((!(0 == $ModuleContextHeight)) || (!(2 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$5)) && (!(this_$8 == null))) && read($Heap_$5,this_$8,alloc)) && (dtype(this_$8) == class.BreadthFirstSearch)) && ((forall  $t#6 : BoxType :: {S#4[$t#6]} ( S#4[$t#6] ==> GenericAlloc($t#6,$Heap_$5) ))))) ==> (((forall  v#5 : BoxType :: ( GenericAlloc(v#5,$Heap_$5) ==> (S#4[v#5] ==> BreadthFirstSearch.Succ#canCall($Heap_$5,this_$8,v#5)) ))) && (BreadthFirstSearch.IsClosed($Heap_$5,this_$8,S#4) <==> ((forall  v#5_$0 : BoxType :: ( GenericAlloc(v#5_$0,$Heap_$5) ==> (S#4[v#5_$0] ==> Set#Subset(BreadthFirstSearch.Succ($Heap_$5,this_$8,v#5_$0),S#4)) ))))) )));
	assume (forall  $h0_$2 : HeapType, $h1_$2 : HeapType, this_$9 : ref, S#4_$0 : Set (BoxType)  :: {$HeapSucc($h0_$2,$h1_$2),BreadthFirstSearch.IsClosed($h1_$2,this_$9,S#4_$0)} ( ((((((((($IsGoodHeap($h0_$2) && $IsGoodHeap($h1_$2)) && (!(this_$9 == null))) && read($h0_$2,this_$9,alloc)) && (dtype(this_$9) == class.BreadthFirstSearch)) && read($h1_$2,this_$9,alloc)) && (dtype(this_$9) == class.BreadthFirstSearch)) && ((forall  $t#7 : BoxType :: {S#4_$0[$t#7]} ( S#4_$0[$t#7] ==> GenericAlloc($t#7,$h0_$2) )))) && ((forall  $t#8 : BoxType :: {S#4_$0[$t#8]} ( S#4_$0[$t#8] ==> GenericAlloc($t#8,$h1_$2) )))) && $HeapSucc($h0_$2,$h1_$2)) ==> (((forall<alpha> $o_$2 : ref, $f_$2 : Field (alpha)  :: ( false ==> (read($h0_$2,$o_$2,$f_$2) == read($h1_$2,$o_$2,$f_$2)) ))) ==> (BreadthFirstSearch.IsClosed($h0_$2,this_$9,S#4_$0) <==> BreadthFirstSearch.IsClosed($h1_$2,this_$9,S#4_$0))) ));
	assume (forall  $Heap_$6 : HeapType, this_$10 : ref, nn#34 : DatatypeType :: {BreadthFirstSearch.Value#2($Heap_$6,this_$10,nn#34)} ( BreadthFirstSearch.Value#2($Heap_$6,this_$10,nn#34) == BreadthFirstSearch.Value($Heap_$6,this_$10,nn#34) ));
	assume (forall  $Heap_$7 : HeapType, this_$11 : ref, nn#34_$0 : DatatypeType :: {BreadthFirstSearch.Value($Heap_$7,this_$11,nn#34_$0)} ( BreadthFirstSearch.Value($Heap_$7,this_$11,nn#34_$0) == BreadthFirstSearch.Value#limited($Heap_$7,this_$11,nn#34_$0) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((11 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$8 : HeapType, this_$12 : ref :: {BreadthFirstSearch.Value($Heap_$8,this_$12,#Nat.Zero())} ( (BreadthFirstSearch.Value#canCall($Heap_$8,this_$12,#Nat.Zero()) || (((((((!(0 == $ModuleContextHeight)) || (!(11 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$8)) && (!(this_$12 == null))) && read($Heap_$8,this_$12,alloc)) && (dtype(this_$12) == class.BreadthFirstSearch))) ==> ((BreadthFirstSearch.Value($Heap_$8,this_$12,#Nat.Zero()) == 0) && (0 <= BreadthFirstSearch.Value($Heap_$8,this_$12,#Nat.Zero()))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((11 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$9 : HeapType, this_$13 : ref, mm#35 : DatatypeType :: {BreadthFirstSearch.Value($Heap_$9,this_$13,#Nat.Suc(mm#35))} ( (BreadthFirstSearch.Value#canCall($Heap_$9,this_$13,#Nat.Suc(mm#35)) || (((((((((!(0 == $ModuleContextHeight)) || (!(11 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$9)) && (!(this_$13 == null))) && read($Heap_$9,this_$13,alloc)) && (dtype(this_$13) == class.BreadthFirstSearch)) && DtAlloc(mm#35,$Heap_$9)) && (DtType(mm#35) == class.Nat))) ==> ((BreadthFirstSearch.Value#canCall($Heap_$9,this_$13,mm#35) && (BreadthFirstSearch.Value($Heap_$9,this_$13,#Nat.Suc(mm#35)) == (BreadthFirstSearch.Value#limited($Heap_$9,this_$13,mm#35) + 1))) && (0 <= BreadthFirstSearch.Value($Heap_$9,this_$13,#Nat.Suc(mm#35)))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((11 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$10 : HeapType, this_$14 : ref, nn#34_$1 : DatatypeType :: {BreadthFirstSearch.Value($Heap_$10,this_$14,nn#34_$1)} ( (BreadthFirstSearch.Value#canCall($Heap_$10,this_$14,nn#34_$1) || (((((((((!(0 == $ModuleContextHeight)) || (!(11 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$10)) && (!(this_$14 == null))) && read($Heap_$10,this_$14,alloc)) && (dtype(this_$14) == class.BreadthFirstSearch)) && DtAlloc(nn#34_$1,$Heap_$10)) && (DtType(nn#34_$1) == class.Nat))) ==> ((BreadthFirstSearch.ToNat($Heap_$10,this_$14,BreadthFirstSearch.Value#limited($Heap_$10,this_$14,nn#34_$1)) == nn#34_$1) && (0 <= BreadthFirstSearch.Value($Heap_$10,this_$14,nn#34_$1))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((11 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$11 : HeapType, this_$15 : ref :: {BreadthFirstSearch.Value#2($Heap_$11,this_$15,#Nat.Zero())} ( (BreadthFirstSearch.Value#canCall($Heap_$11,this_$15,#Nat.Zero()) || (((((((!(0 == $ModuleContextHeight)) || (!(11 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$11)) && (!(this_$15 == null))) && read($Heap_$11,this_$15,alloc)) && (dtype(this_$15) == class.BreadthFirstSearch))) ==> (BreadthFirstSearch.Value#2($Heap_$11,this_$15,#Nat.Zero()) == 0) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((11 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$12 : HeapType, this_$16 : ref, mm#35_$0 : DatatypeType :: {BreadthFirstSearch.Value#2($Heap_$12,this_$16,#Nat.Suc(mm#35_$0))} ( (BreadthFirstSearch.Value#canCall($Heap_$12,this_$16,#Nat.Suc(mm#35_$0)) || (((((((((!(0 == $ModuleContextHeight)) || (!(11 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$12)) && (!(this_$16 == null))) && read($Heap_$12,this_$16,alloc)) && (dtype(this_$16) == class.BreadthFirstSearch)) && DtAlloc(mm#35_$0,$Heap_$12)) && (DtType(mm#35_$0) == class.Nat))) ==> (BreadthFirstSearch.Value#2($Heap_$12,this_$16,#Nat.Suc(mm#35_$0)) == (BreadthFirstSearch.Value($Heap_$12,this_$16,mm#35_$0) + 1)) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((11 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$13 : HeapType, this_$17 : ref, nn#34_$2 : DatatypeType :: {BreadthFirstSearch.Value#2($Heap_$13,this_$17,nn#34_$2)} ( (BreadthFirstSearch.Value#canCall($Heap_$13,this_$17,nn#34_$2) || (((((((((!(0 == $ModuleContextHeight)) || (!(11 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$13)) && (!(this_$17 == null))) && read($Heap_$13,this_$17,alloc)) && (dtype(this_$17) == class.BreadthFirstSearch)) && DtAlloc(nn#34_$2,$Heap_$13)) && (DtType(nn#34_$2) == class.Nat))) ==> true )));
	assume (forall  $h0_$3 : HeapType, $h1_$3 : HeapType, this_$18 : ref, nn#34_$3 : DatatypeType :: {$HeapSucc($h0_$3,$h1_$3),BreadthFirstSearch.Value($h1_$3,this_$18,nn#34_$3)} ( ((((((((((($IsGoodHeap($h0_$3) && $IsGoodHeap($h1_$3)) && (!(this_$18 == null))) && read($h0_$3,this_$18,alloc)) && (dtype(this_$18) == class.BreadthFirstSearch)) && read($h1_$3,this_$18,alloc)) && (dtype(this_$18) == class.BreadthFirstSearch)) && DtAlloc(nn#34_$3,$h0_$3)) && (DtType(nn#34_$3) == class.Nat)) && DtAlloc(nn#34_$3,$h1_$3)) && (DtType(nn#34_$3) == class.Nat)) && $HeapSucc($h0_$3,$h1_$3)) ==> (((forall<alpha> $o_$3 : ref, $f_$3 : Field (alpha)  :: ( false ==> (read($h0_$3,$o_$3,$f_$3) == read($h1_$3,$o_$3,$f_$3)) ))) ==> (BreadthFirstSearch.Value($h0_$3,this_$18,nn#34_$3) == BreadthFirstSearch.Value($h1_$3,this_$18,nn#34_$3))) ));
	assume (forall  $h0_$4 : HeapType, $h1_$4 : HeapType, this_$19 : ref, nn#34_$4 : DatatypeType :: {$HeapSucc($h0_$4,$h1_$4),BreadthFirstSearch.Value#limited($h1_$4,this_$19,nn#34_$4)} ( ((((((((((($IsGoodHeap($h0_$4) && $IsGoodHeap($h1_$4)) && (!(this_$19 == null))) && read($h0_$4,this_$19,alloc)) && (dtype(this_$19) == class.BreadthFirstSearch)) && read($h1_$4,this_$19,alloc)) && (dtype(this_$19) == class.BreadthFirstSearch)) && DtAlloc(nn#34_$4,$h0_$4)) && (DtType(nn#34_$4) == class.Nat)) && DtAlloc(nn#34_$4,$h1_$4)) && (DtType(nn#34_$4) == class.Nat)) && $HeapSucc($h0_$4,$h1_$4)) ==> (((forall<alpha> $o_$4 : ref, $f_$4 : Field (alpha)  :: ( false ==> (read($h0_$4,$o_$4,$f_$4) == read($h1_$4,$o_$4,$f_$4)) ))) ==> (BreadthFirstSearch.Value#limited($h0_$4,this_$19,nn#34_$4) == BreadthFirstSearch.Value#limited($h1_$4,this_$19,nn#34_$4))) ));
	assume (forall  $Heap_$14 : HeapType, this_$20 : ref, n#36 : Integer :: {BreadthFirstSearch.ToNat#2($Heap_$14,this_$20,n#36)} ( BreadthFirstSearch.ToNat#2($Heap_$14,this_$20,n#36) == BreadthFirstSearch.ToNat($Heap_$14,this_$20,n#36) ));
	assume (forall  $Heap_$15 : HeapType, this_$21 : ref, n#36_$0 : Integer :: {BreadthFirstSearch.ToNat($Heap_$15,this_$21,n#36_$0)} ( BreadthFirstSearch.ToNat($Heap_$15,this_$21,n#36_$0) == BreadthFirstSearch.ToNat#limited($Heap_$15,this_$21,n#36_$0) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((10 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$16 : HeapType, this_$22 : ref, n#36_$1 : Integer :: {BreadthFirstSearch.ToNat($Heap_$16,this_$22,n#36_$1)} ( (BreadthFirstSearch.ToNat#canCall($Heap_$16,this_$22,n#36_$1) || ((((((((!(0 == $ModuleContextHeight)) || (!(10 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$16)) && (!(this_$22 == null))) && read($Heap_$16,this_$22,alloc)) && (dtype(this_$22) == class.BreadthFirstSearch)) && (0 <= n#36_$1))) ==> ((((((n#36_$1 == 0) ==> true) && ((!(n#36_$1 == 0)) ==> BreadthFirstSearch.ToNat#canCall($Heap_$16,this_$22,n#36_$1 - 1))) && (BreadthFirstSearch.ToNat($Heap_$16,this_$22,n#36_$1) == (if (n#36_$1 == 0) then #Nat.Zero() else #Nat.Suc(BreadthFirstSearch.ToNat#limited($Heap_$16,this_$22,n#36_$1 - 1))))) && DtAlloc(BreadthFirstSearch.ToNat($Heap_$16,this_$22,n#36_$1),$Heap_$16)) && (DtType(BreadthFirstSearch.ToNat($Heap_$16,this_$22,n#36_$1)) == class.Nat)) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((10 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$17 : HeapType, this_$23 : ref, n#36_$2 : Integer :: {BreadthFirstSearch.ToNat#2($Heap_$17,this_$23,n#36_$2)} ( (BreadthFirstSearch.ToNat#canCall($Heap_$17,this_$23,n#36_$2) || ((((((((!(0 == $ModuleContextHeight)) || (!(10 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$17)) && (!(this_$23 == null))) && read($Heap_$17,this_$23,alloc)) && (dtype(this_$23) == class.BreadthFirstSearch)) && (0 <= n#36_$2))) ==> (BreadthFirstSearch.ToNat#2($Heap_$17,this_$23,n#36_$2) == (if (n#36_$2 == 0) then #Nat.Zero() else #Nat.Suc(BreadthFirstSearch.ToNat($Heap_$17,this_$23,n#36_$2 - 1)))) )));
	assume (forall  $h0_$5 : HeapType, $h1_$5 : HeapType, this_$24 : ref, n#36_$3 : Integer :: {$HeapSucc($h0_$5,$h1_$5),BreadthFirstSearch.ToNat($h1_$5,this_$24,n#36_$3)} ( ((((((((($IsGoodHeap($h0_$5) && $IsGoodHeap($h1_$5)) && (!(this_$24 == null))) && read($h0_$5,this_$24,alloc)) && (dtype(this_$24) == class.BreadthFirstSearch)) && read($h1_$5,this_$24,alloc)) && (dtype(this_$24) == class.BreadthFirstSearch)) && (0 <= n#36_$3)) && (0 <= n#36_$3)) && $HeapSucc($h0_$5,$h1_$5)) ==> (((forall<alpha> $o_$5 : ref, $f_$5 : Field (alpha)  :: ( false ==> (read($h0_$5,$o_$5,$f_$5) == read($h1_$5,$o_$5,$f_$5)) ))) ==> (BreadthFirstSearch.ToNat($h0_$5,this_$24,n#36_$3) == BreadthFirstSearch.ToNat($h1_$5,this_$24,n#36_$3))) ));
	assume (forall  $h0_$6 : HeapType, $h1_$6 : HeapType, this_$25 : ref, n#36_$4 : Integer :: {$HeapSucc($h0_$6,$h1_$6),BreadthFirstSearch.ToNat#limited($h1_$6,this_$25,n#36_$4)} ( ((((((((($IsGoodHeap($h0_$6) && $IsGoodHeap($h1_$6)) && (!(this_$25 == null))) && read($h0_$6,this_$25,alloc)) && (dtype(this_$25) == class.BreadthFirstSearch)) && read($h1_$6,this_$25,alloc)) && (dtype(this_$25) == class.BreadthFirstSearch)) && (0 <= n#36_$4)) && (0 <= n#36_$4)) && $HeapSucc($h0_$6,$h1_$6)) ==> (((forall<alpha> $o_$6 : ref, $f_$6 : Field (alpha)  :: ( false ==> (read($h0_$6,$o_$6,$f_$6) == read($h1_$6,$o_$6,$f_$6)) ))) ==> (BreadthFirstSearch.ToNat#limited($h0_$6,this_$25,n#36_$4) == BreadthFirstSearch.ToNat#limited($h1_$6,this_$25,n#36_$4))) ));
	assume (forall  $Heap_$18 : HeapType, this_$26 : ref, source#38 : BoxType, nn#39 : DatatypeType, AllVertices#40 : Set (BoxType)  :: {BreadthFirstSearch.R#2($Heap_$18,this_$26,source#38,nn#39,AllVertices#40)} ( BreadthFirstSearch.R#2($Heap_$18,this_$26,source#38,nn#39,AllVertices#40) == BreadthFirstSearch.R($Heap_$18,this_$26,source#38,nn#39,AllVertices#40) ));
	assume (forall  $Heap_$19 : HeapType, this_$27 : ref, source#38_$0 : BoxType, nn#39_$0 : DatatypeType, AllVertices#40_$0 : Set (BoxType)  :: {BreadthFirstSearch.R($Heap_$19,this_$27,source#38_$0,nn#39_$0,AllVertices#40_$0)} ( BreadthFirstSearch.R($Heap_$19,this_$27,source#38_$0,nn#39_$0,AllVertices#40_$0) == BreadthFirstSearch.R#limited($Heap_$19,this_$27,source#38_$0,nn#39_$0,AllVertices#40_$0) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((13 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$20 : HeapType, this_$28 : ref, source#38_$1 : BoxType, AllVertices#40_$1 : Set (BoxType)  :: {BreadthFirstSearch.R($Heap_$20,this_$28,source#38_$1,#Nat.Zero(),AllVertices#40_$1)} ( (BreadthFirstSearch.R#canCall($Heap_$20,this_$28,source#38_$1,#Nat.Zero(),AllVertices#40_$1) || (((((((((!(0 == $ModuleContextHeight)) || (!(13 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$20)) && (!(this_$28 == null))) && read($Heap_$20,this_$28,alloc)) && (dtype(this_$28) == class.BreadthFirstSearch)) && GenericAlloc(source#38_$1,$Heap_$20)) && ((forall  $t#0_$0 : BoxType :: {AllVertices#40_$1[$t#0_$0]} ( AllVertices#40_$1[$t#0_$0] ==> GenericAlloc($t#0_$0,$Heap_$20) ))))) ==> ((BreadthFirstSearch.R($Heap_$20,this_$28,source#38_$1,#Nat.Zero(),AllVertices#40_$1) == Set#UnionOne((Set#Empty() : Set (BoxType) ),source#38_$1)) && ((forall  $t#1 : BoxType :: {BreadthFirstSearch.R($Heap_$20,this_$28,source#38_$1,#Nat.Zero(),AllVertices#40_$1)[$t#1]} ( BreadthFirstSearch.R($Heap_$20,this_$28,source#38_$1,#Nat.Zero(),AllVertices#40_$1)[$t#1] ==> GenericAlloc($t#1,$Heap_$20) )))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((13 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$21 : HeapType, this_$29 : ref, mm#41 : DatatypeType, source#38_$2 : BoxType, AllVertices#40_$2 : Set (BoxType)  :: {BreadthFirstSearch.R($Heap_$21,this_$29,source#38_$2,#Nat.Suc(mm#41),AllVertices#40_$2)} ( (BreadthFirstSearch.R#canCall($Heap_$21,this_$29,source#38_$2,#Nat.Suc(mm#41),AllVertices#40_$2) || (((((((((((!(0 == $ModuleContextHeight)) || (!(13 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$21)) && (!(this_$29 == null))) && read($Heap_$21,this_$29,alloc)) && (dtype(this_$29) == class.BreadthFirstSearch)) && DtAlloc(mm#41,$Heap_$21)) && (DtType(mm#41) == class.Nat)) && GenericAlloc(source#38_$2,$Heap_$21)) && ((forall  $t#2 : BoxType :: {AllVertices#40_$2[$t#2]} ( AllVertices#40_$2[$t#2] ==> GenericAlloc($t#2,$Heap_$21) ))))) ==> ((((BreadthFirstSearch.R#canCall($Heap_$21,this_$29,source#38_$2,mm#41,AllVertices#40_$2) && BreadthFirstSearch.R#canCall($Heap_$21,this_$29,source#38_$2,mm#41,AllVertices#40_$2)) && BreadthFirstSearch.Successors#canCall($Heap_$21,this_$29,BreadthFirstSearch.R($Heap_$21,this_$29,source#38_$2,mm#41,AllVertices#40_$2),AllVertices#40_$2)) && (BreadthFirstSearch.R($Heap_$21,this_$29,source#38_$2,#Nat.Suc(mm#41),AllVertices#40_$2) == Set#Union(BreadthFirstSearch.R#limited($Heap_$21,this_$29,source#38_$2,mm#41,AllVertices#40_$2),BreadthFirstSearch.Successors($Heap_$21,this_$29,BreadthFirstSearch.R#limited($Heap_$21,this_$29,source#38_$2,mm#41,AllVertices#40_$2),AllVertices#40_$2)))) && ((forall  $t#3 : BoxType :: {BreadthFirstSearch.R($Heap_$21,this_$29,source#38_$2,#Nat.Suc(mm#41),AllVertices#40_$2)[$t#3]} ( BreadthFirstSearch.R($Heap_$21,this_$29,source#38_$2,#Nat.Suc(mm#41),AllVertices#40_$2)[$t#3] ==> GenericAlloc($t#3,$Heap_$21) )))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((13 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$22 : HeapType, this_$30 : ref, source#38_$3 : BoxType, nn#39_$1 : DatatypeType, AllVertices#40_$3 : Set (BoxType)  :: {BreadthFirstSearch.R($Heap_$22,this_$30,source#38_$3,nn#39_$1,AllVertices#40_$3)} ( (BreadthFirstSearch.R#canCall($Heap_$22,this_$30,source#38_$3,nn#39_$1,AllVertices#40_$3) || (((((((((((!(0 == $ModuleContextHeight)) || (!(13 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$22)) && (!(this_$30 == null))) && read($Heap_$22,this_$30,alloc)) && (dtype(this_$30) == class.BreadthFirstSearch)) && GenericAlloc(source#38_$3,$Heap_$22)) && DtAlloc(nn#39_$1,$Heap_$22)) && (DtType(nn#39_$1) == class.Nat)) && ((forall  $t#4 : BoxType :: {AllVertices#40_$3[$t#4]} ( AllVertices#40_$3[$t#4] ==> GenericAlloc($t#4,$Heap_$22) ))))) ==> ((forall  $t#5 : BoxType :: {BreadthFirstSearch.R($Heap_$22,this_$30,source#38_$3,nn#39_$1,AllVertices#40_$3)[$t#5]} ( BreadthFirstSearch.R($Heap_$22,this_$30,source#38_$3,nn#39_$1,AllVertices#40_$3)[$t#5] ==> GenericAlloc($t#5,$Heap_$22) ))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((13 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$23 : HeapType, this_$31 : ref, source#38_$4 : BoxType, AllVertices#40_$4 : Set (BoxType)  :: {BreadthFirstSearch.R#2($Heap_$23,this_$31,source#38_$4,#Nat.Zero(),AllVertices#40_$4)} ( (BreadthFirstSearch.R#canCall($Heap_$23,this_$31,source#38_$4,#Nat.Zero(),AllVertices#40_$4) || (((((((((!(0 == $ModuleContextHeight)) || (!(13 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$23)) && (!(this_$31 == null))) && read($Heap_$23,this_$31,alloc)) && (dtype(this_$31) == class.BreadthFirstSearch)) && GenericAlloc(source#38_$4,$Heap_$23)) && ((forall  $t#6_$0 : BoxType :: {AllVertices#40_$4[$t#6_$0]} ( AllVertices#40_$4[$t#6_$0] ==> GenericAlloc($t#6_$0,$Heap_$23) ))))) ==> (BreadthFirstSearch.R#2($Heap_$23,this_$31,source#38_$4,#Nat.Zero(),AllVertices#40_$4) == Set#UnionOne((Set#Empty() : Set (BoxType) ),source#38_$4)) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((13 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$24 : HeapType, this_$32 : ref, mm#41_$0 : DatatypeType, source#38_$5 : BoxType, AllVertices#40_$5 : Set (BoxType)  :: {BreadthFirstSearch.R#2($Heap_$24,this_$32,source#38_$5,#Nat.Suc(mm#41_$0),AllVertices#40_$5)} ( (BreadthFirstSearch.R#canCall($Heap_$24,this_$32,source#38_$5,#Nat.Suc(mm#41_$0),AllVertices#40_$5) || (((((((((((!(0 == $ModuleContextHeight)) || (!(13 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$24)) && (!(this_$32 == null))) && read($Heap_$24,this_$32,alloc)) && (dtype(this_$32) == class.BreadthFirstSearch)) && DtAlloc(mm#41_$0,$Heap_$24)) && (DtType(mm#41_$0) == class.Nat)) && GenericAlloc(source#38_$5,$Heap_$24)) && ((forall  $t#7_$0 : BoxType :: {AllVertices#40_$5[$t#7_$0]} ( AllVertices#40_$5[$t#7_$0] ==> GenericAlloc($t#7_$0,$Heap_$24) ))))) ==> (BreadthFirstSearch.R#2($Heap_$24,this_$32,source#38_$5,#Nat.Suc(mm#41_$0),AllVertices#40_$5) == Set#Union(BreadthFirstSearch.R($Heap_$24,this_$32,source#38_$5,mm#41_$0,AllVertices#40_$5),BreadthFirstSearch.Successors($Heap_$24,this_$32,BreadthFirstSearch.R($Heap_$24,this_$32,source#38_$5,mm#41_$0,AllVertices#40_$5),AllVertices#40_$5))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((13 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$25 : HeapType, this_$33 : ref, source#38_$6 : BoxType, nn#39_$2 : DatatypeType, AllVertices#40_$6 : Set (BoxType)  :: {BreadthFirstSearch.R#2($Heap_$25,this_$33,source#38_$6,nn#39_$2,AllVertices#40_$6)} ( (BreadthFirstSearch.R#canCall($Heap_$25,this_$33,source#38_$6,nn#39_$2,AllVertices#40_$6) || (((((((((((!(0 == $ModuleContextHeight)) || (!(13 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$25)) && (!(this_$33 == null))) && read($Heap_$25,this_$33,alloc)) && (dtype(this_$33) == class.BreadthFirstSearch)) && GenericAlloc(source#38_$6,$Heap_$25)) && DtAlloc(nn#39_$2,$Heap_$25)) && (DtType(nn#39_$2) == class.Nat)) && ((forall  $t#8_$0 : BoxType :: {AllVertices#40_$6[$t#8_$0]} ( AllVertices#40_$6[$t#8_$0] ==> GenericAlloc($t#8_$0,$Heap_$25) ))))) ==> true )));
	assume (forall  $h0_$7 : HeapType, $h1_$7 : HeapType, this_$34 : ref, source#38_$7 : BoxType, nn#39_$3 : DatatypeType, AllVertices#40_$7 : Set (BoxType)  :: {$HeapSucc($h0_$7,$h1_$7),BreadthFirstSearch.R($h1_$7,this_$34,source#38_$7,nn#39_$3,AllVertices#40_$7)} ( ((((((((((((((($IsGoodHeap($h0_$7) && $IsGoodHeap($h1_$7)) && (!(this_$34 == null))) && read($h0_$7,this_$34,alloc)) && (dtype(this_$34) == class.BreadthFirstSearch)) && read($h1_$7,this_$34,alloc)) && (dtype(this_$34) == class.BreadthFirstSearch)) && GenericAlloc(source#38_$7,$h0_$7)) && GenericAlloc(source#38_$7,$h1_$7)) && DtAlloc(nn#39_$3,$h0_$7)) && (DtType(nn#39_$3) == class.Nat)) && DtAlloc(nn#39_$3,$h1_$7)) && (DtType(nn#39_$3) == class.Nat)) && ((forall  $t#9 : BoxType :: {AllVertices#40_$7[$t#9]} ( AllVertices#40_$7[$t#9] ==> GenericAlloc($t#9,$h0_$7) )))) && ((forall  $t#10 : BoxType :: {AllVertices#40_$7[$t#10]} ( AllVertices#40_$7[$t#10] ==> GenericAlloc($t#10,$h1_$7) )))) && $HeapSucc($h0_$7,$h1_$7)) ==> (((forall<alpha> $o_$7 : ref, $f_$7 : Field (alpha)  :: ( false ==> (read($h0_$7,$o_$7,$f_$7) == read($h1_$7,$o_$7,$f_$7)) ))) ==> (BreadthFirstSearch.R($h0_$7,this_$34,source#38_$7,nn#39_$3,AllVertices#40_$7) == BreadthFirstSearch.R($h1_$7,this_$34,source#38_$7,nn#39_$3,AllVertices#40_$7))) ));
	assume (forall  $h0_$8 : HeapType, $h1_$8 : HeapType, this_$35 : ref, source#38_$8 : BoxType, nn#39_$4 : DatatypeType, AllVertices#40_$8 : Set (BoxType)  :: {$HeapSucc($h0_$8,$h1_$8),BreadthFirstSearch.R#limited($h1_$8,this_$35,source#38_$8,nn#39_$4,AllVertices#40_$8)} ( ((((((((((((((($IsGoodHeap($h0_$8) && $IsGoodHeap($h1_$8)) && (!(this_$35 == null))) && read($h0_$8,this_$35,alloc)) && (dtype(this_$35) == class.BreadthFirstSearch)) && read($h1_$8,this_$35,alloc)) && (dtype(this_$35) == class.BreadthFirstSearch)) && GenericAlloc(source#38_$8,$h0_$8)) && GenericAlloc(source#38_$8,$h1_$8)) && DtAlloc(nn#39_$4,$h0_$8)) && (DtType(nn#39_$4) == class.Nat)) && DtAlloc(nn#39_$4,$h1_$8)) && (DtType(nn#39_$4) == class.Nat)) && ((forall  $t#9_$0 : BoxType :: {AllVertices#40_$8[$t#9_$0]} ( AllVertices#40_$8[$t#9_$0] ==> GenericAlloc($t#9_$0,$h0_$8) )))) && ((forall  $t#10_$0 : BoxType :: {AllVertices#40_$8[$t#10_$0]} ( AllVertices#40_$8[$t#10_$0] ==> GenericAlloc($t#10_$0,$h1_$8) )))) && $HeapSucc($h0_$8,$h1_$8)) ==> (((forall<alpha> $o_$8 : ref, $f_$8 : Field (alpha)  :: ( false ==> (read($h0_$8,$o_$8,$f_$8) == read($h1_$8,$o_$8,$f_$8)) ))) ==> (BreadthFirstSearch.R#limited($h0_$8,this_$35,source#38_$8,nn#39_$4,AllVertices#40_$8) == BreadthFirstSearch.R#limited($h1_$8,this_$35,source#38_$8,nn#39_$4,AllVertices#40_$8))) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((12 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$26 : HeapType, this_$36 : ref, S#42 : Set (BoxType) , AllVertices#43 : Set (BoxType)  :: {BreadthFirstSearch.Successors($Heap_$26,this_$36,S#42,AllVertices#43)} ( (BreadthFirstSearch.Successors#canCall($Heap_$26,this_$36,S#42,AllVertices#43) || (((((((((!(0 == $ModuleContextHeight)) || (!(12 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$26)) && (!(this_$36 == null))) && read($Heap_$26,this_$36,alloc)) && (dtype(this_$36) == class.BreadthFirstSearch)) && ((forall  $t#12 : BoxType :: {S#42[$t#12]} ( S#42[$t#12] ==> GenericAlloc($t#12,$Heap_$26) )))) && ((forall  $t#13 : BoxType :: {AllVertices#43[$t#13]} ( AllVertices#43[$t#13] ==> GenericAlloc($t#13,$Heap_$26) ))))) ==> ((((forall  w#44 : BoxType :: ( GenericAlloc(w#44,$Heap_$26) ==> (AllVertices#43[w#44] ==> ((forall  x#45 : BoxType :: ( GenericAlloc(x#45,$Heap_$26) ==> (S#42[x#45] ==> BreadthFirstSearch.Succ#canCall($Heap_$26,this_$36,x#45)) )))) ))) && (BreadthFirstSearch.Successors($Heap_$26,this_$36,S#42,AllVertices#43) == lambda#12(S#42,$Heap_$26,AllVertices#43,this_$36))) && ((forall  $t#15 : BoxType :: {BreadthFirstSearch.Successors($Heap_$26,this_$36,S#42,AllVertices#43)[$t#15]} ( BreadthFirstSearch.Successors($Heap_$26,this_$36,S#42,AllVertices#43)[$t#15] ==> GenericAlloc($t#15,$Heap_$26) )))) )));
	assume (forall  $h0_$9 : HeapType, $h1_$9 : HeapType, this_$37 : ref, S#42_$0 : Set (BoxType) , AllVertices#43_$0 : Set (BoxType)  :: {$HeapSucc($h0_$9,$h1_$9),BreadthFirstSearch.Successors($h1_$9,this_$37,S#42_$0,AllVertices#43_$0)} ( ((((((((((($IsGoodHeap($h0_$9) && $IsGoodHeap($h1_$9)) && (!(this_$37 == null))) && read($h0_$9,this_$37,alloc)) && (dtype(this_$37) == class.BreadthFirstSearch)) && read($h1_$9,this_$37,alloc)) && (dtype(this_$37) == class.BreadthFirstSearch)) && ((forall  $t#16 : BoxType :: {S#42_$0[$t#16]} ( S#42_$0[$t#16] ==> GenericAlloc($t#16,$h0_$9) )))) && ((forall  $t#17 : BoxType :: {S#42_$0[$t#17]} ( S#42_$0[$t#17] ==> GenericAlloc($t#17,$h1_$9) )))) && ((forall  $t#18 : BoxType :: {AllVertices#43_$0[$t#18]} ( AllVertices#43_$0[$t#18] ==> GenericAlloc($t#18,$h0_$9) )))) && ((forall  $t#19 : BoxType :: {AllVertices#43_$0[$t#19]} ( AllVertices#43_$0[$t#19] ==> GenericAlloc($t#19,$h1_$9) )))) && $HeapSucc($h0_$9,$h1_$9)) ==> (((forall<alpha> $o_$9 : ref, $f_$9 : Field (alpha)  :: ( false ==> (read($h0_$9,$o_$9,$f_$9) == read($h1_$9,$o_$9,$f_$9)) ))) ==> (BreadthFirstSearch.Successors($h0_$9,this_$37,S#42_$0,AllVertices#43_$0) == BreadthFirstSearch.Successors($h1_$9,this_$37,S#42_$0,AllVertices#43_$0))) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((14 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$27 : HeapType, this_$38 : ref, m#59 : DatatypeType :: {BreadthFirstSearch.Domain($Heap_$27,this_$38,m#59)} ( (BreadthFirstSearch.Domain#canCall($Heap_$27,this_$38,m#59) || (((((((((!(0 == $ModuleContextHeight)) || (!(14 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$27)) && (!(this_$38 == null))) && read($Heap_$27,this_$38,alloc)) && (dtype(this_$38) == class.BreadthFirstSearch)) && DtAlloc(m#59,$Heap_$27)) && (DtType(m#59) == class.Map))) ==> (((((m#59 == #Map.Empty()) ==> true) && ((!(m#59 == #Map.Empty())) ==> true)) && (BreadthFirstSearch.Domain($Heap_$27,this_$38,m#59) == (if (m#59 == #Map.Empty()) then (Set#Empty() : Set (BoxType) ) else Map.dom(m#59)))) && ((forall  $t#0_$1 : BoxType :: {BreadthFirstSearch.Domain($Heap_$27,this_$38,m#59)[$t#0_$1]} ( BreadthFirstSearch.Domain($Heap_$27,this_$38,m#59)[$t#0_$1] ==> GenericAlloc($t#0_$1,$Heap_$27) )))) )));
	assume (forall  $h0_$10 : HeapType, $h1_$10 : HeapType, this_$39 : ref, m#59_$0 : DatatypeType :: {$HeapSucc($h0_$10,$h1_$10),BreadthFirstSearch.Domain($h1_$10,this_$39,m#59_$0)} ( ((((((((((($IsGoodHeap($h0_$10) && $IsGoodHeap($h1_$10)) && (!(this_$39 == null))) && read($h0_$10,this_$39,alloc)) && (dtype(this_$39) == class.BreadthFirstSearch)) && read($h1_$10,this_$39,alloc)) && (dtype(this_$39) == class.BreadthFirstSearch)) && DtAlloc(m#59_$0,$h0_$10)) && (DtType(m#59_$0) == class.Map)) && DtAlloc(m#59_$0,$h1_$10)) && (DtType(m#59_$0) == class.Map)) && $HeapSucc($h0_$10,$h1_$10)) ==> (((forall<alpha> $o_$10 : ref, $f_$10 : Field (alpha)  :: ( false ==> (read($h0_$10,$o_$10,$f_$10) == read($h1_$10,$o_$10,$f_$10)) ))) ==> (BreadthFirstSearch.Domain($h0_$10,this_$39,m#59_$0) == BreadthFirstSearch.Domain($h1_$10,this_$39,m#59_$0))) ));
	assume (forall  $Heap_$28 : HeapType, this_$40 : ref, source#60 : BoxType, m#61 : DatatypeType :: {BreadthFirstSearch.ValidMap#2($Heap_$28,this_$40,source#60,m#61)} ( BreadthFirstSearch.ValidMap#2($Heap_$28,this_$40,source#60,m#61) <==> BreadthFirstSearch.ValidMap($Heap_$28,this_$40,source#60,m#61) ));
	assume (forall  $Heap_$29 : HeapType, this_$41 : ref, source#60_$0 : BoxType, m#61_$0 : DatatypeType :: {BreadthFirstSearch.ValidMap($Heap_$29,this_$41,source#60_$0,m#61_$0)} ( BreadthFirstSearch.ValidMap($Heap_$29,this_$41,source#60_$0,m#61_$0) <==> BreadthFirstSearch.ValidMap#limited($Heap_$29,this_$41,source#60_$0,m#61_$0) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((15 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$30 : HeapType, this_$42 : ref, source#60_$1 : BoxType :: {BreadthFirstSearch.ValidMap($Heap_$30,this_$42,source#60_$1,#Map.Empty())} ( (BreadthFirstSearch.ValidMap#canCall($Heap_$30,this_$42,source#60_$1,#Map.Empty()) || ((((((((!(0 == $ModuleContextHeight)) || (!(15 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$30)) && (!(this_$42 == null))) && read($Heap_$30,this_$42,alloc)) && (dtype(this_$42) == class.BreadthFirstSearch)) && GenericAlloc(source#60_$1,$Heap_$30))) ==> (BreadthFirstSearch.ValidMap($Heap_$30,this_$42,source#60_$1,#Map.Empty()) <==> true) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((15 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$31 : HeapType, this_$43 : ref, dom#62 : Set (BoxType) , v#63 : BoxType, path#64 : Seq (BoxType) , next#65 : DatatypeType, source#60_$2 : BoxType :: {BreadthFirstSearch.ValidMap($Heap_$31,this_$43,source#60_$2,#Map.Maplet(dom#62,v#63,path#64,next#65))} ( (BreadthFirstSearch.ValidMap#canCall($Heap_$31,this_$43,source#60_$2,#Map.Maplet(dom#62,v#63,path#64,next#65)) || (((((((((((((!(0 == $ModuleContextHeight)) || (!(15 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$31)) && (!(this_$43 == null))) && read($Heap_$31,this_$43,alloc)) && (dtype(this_$43) == class.BreadthFirstSearch)) && ((forall  $t#1_$0 : BoxType :: {dom#62[$t#1_$0]} ( dom#62[$t#1_$0] ==> GenericAlloc($t#1_$0,$Heap_$31) )))) && GenericAlloc(v#63,$Heap_$31)) && ((forall  $i#2_$0 : Integer :: {Seq#Index(path#64,$i#2_$0)} ( ((0 <= $i#2_$0) && ($i#2_$0 < Seq#Length(path#64))) ==> GenericAlloc(Seq#Index(path#64,$i#2_$0),$Heap_$31) )))) && DtAlloc(next#65,$Heap_$31)) && (DtType(next#65) == class.Map)) && GenericAlloc(source#60_$2,$Heap_$31))) ==> ((((dom#62[v#63] ==> BreadthFirstSearch.Domain#canCall($Heap_$31,this_$43,next#65)) && ((dom#62[v#63] && Set#Equal(dom#62,Set#Union(BreadthFirstSearch.Domain($Heap_$31,this_$43,next#65),Set#UnionOne((Set#Empty() : Set (BoxType) ),v#63)))) ==> BreadthFirstSearch.IsPath#canCall($Heap_$31,this_$43,source#60_$2,v#63,path#64))) && (((dom#62[v#63] && Set#Equal(dom#62,Set#Union(BreadthFirstSearch.Domain($Heap_$31,this_$43,next#65),Set#UnionOne((Set#Empty() : Set (BoxType) ),v#63)))) && BreadthFirstSearch.IsPath($Heap_$31,this_$43,source#60_$2,v#63,path#64)) ==> BreadthFirstSearch.ValidMap#canCall($Heap_$31,this_$43,source#60_$2,next#65))) && (BreadthFirstSearch.ValidMap($Heap_$31,this_$43,source#60_$2,#Map.Maplet(dom#62,v#63,path#64,next#65)) <==> (((dom#62[v#63] && Set#Equal(dom#62,Set#Union(BreadthFirstSearch.Domain($Heap_$31,this_$43,next#65),Set#UnionOne((Set#Empty() : Set (BoxType) ),v#63)))) && BreadthFirstSearch.IsPath($Heap_$31,this_$43,source#60_$2,v#63,path#64)) && BreadthFirstSearch.ValidMap#limited($Heap_$31,this_$43,source#60_$2,next#65)))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((15 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$32 : HeapType, this_$44 : ref, source#60_$3 : BoxType, m#61_$1 : DatatypeType :: {BreadthFirstSearch.ValidMap($Heap_$32,this_$44,source#60_$3,m#61_$1)} ( (BreadthFirstSearch.ValidMap#canCall($Heap_$32,this_$44,source#60_$3,m#61_$1) || ((((((((((!(0 == $ModuleContextHeight)) || (!(15 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$32)) && (!(this_$44 == null))) && read($Heap_$32,this_$44,alloc)) && (dtype(this_$44) == class.BreadthFirstSearch)) && GenericAlloc(source#60_$3,$Heap_$32)) && DtAlloc(m#61_$1,$Heap_$32)) && (DtType(m#61_$1) == class.Map))) ==> true )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((15 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$33 : HeapType, this_$45 : ref, source#60_$4 : BoxType :: {BreadthFirstSearch.ValidMap#2($Heap_$33,this_$45,source#60_$4,#Map.Empty())} ( (BreadthFirstSearch.ValidMap#canCall($Heap_$33,this_$45,source#60_$4,#Map.Empty()) || ((((((((!(0 == $ModuleContextHeight)) || (!(15 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$33)) && (!(this_$45 == null))) && read($Heap_$33,this_$45,alloc)) && (dtype(this_$45) == class.BreadthFirstSearch)) && GenericAlloc(source#60_$4,$Heap_$33))) ==> (BreadthFirstSearch.ValidMap#2($Heap_$33,this_$45,source#60_$4,#Map.Empty()) <==> true) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((15 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$34 : HeapType, this_$46 : ref, dom#62_$0 : Set (BoxType) , v#63_$0 : BoxType, path#64_$0 : Seq (BoxType) , next#65_$0 : DatatypeType, source#60_$5 : BoxType :: {BreadthFirstSearch.ValidMap#2($Heap_$34,this_$46,source#60_$5,#Map.Maplet(dom#62_$0,v#63_$0,path#64_$0,next#65_$0))} ( (BreadthFirstSearch.ValidMap#canCall($Heap_$34,this_$46,source#60_$5,#Map.Maplet(dom#62_$0,v#63_$0,path#64_$0,next#65_$0)) || (((((((((((((!(0 == $ModuleContextHeight)) || (!(15 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$34)) && (!(this_$46 == null))) && read($Heap_$34,this_$46,alloc)) && (dtype(this_$46) == class.BreadthFirstSearch)) && ((forall  $t#3_$0 : BoxType :: {dom#62_$0[$t#3_$0]} ( dom#62_$0[$t#3_$0] ==> GenericAlloc($t#3_$0,$Heap_$34) )))) && GenericAlloc(v#63_$0,$Heap_$34)) && ((forall  $i#4_$1 : Integer :: {Seq#Index(path#64_$0,$i#4_$1)} ( ((0 <= $i#4_$1) && ($i#4_$1 < Seq#Length(path#64_$0))) ==> GenericAlloc(Seq#Index(path#64_$0,$i#4_$1),$Heap_$34) )))) && DtAlloc(next#65_$0,$Heap_$34)) && (DtType(next#65_$0) == class.Map)) && GenericAlloc(source#60_$5,$Heap_$34))) ==> (BreadthFirstSearch.ValidMap#2($Heap_$34,this_$46,source#60_$5,#Map.Maplet(dom#62_$0,v#63_$0,path#64_$0,next#65_$0)) <==> (((dom#62_$0[v#63_$0] && Set#Equal(dom#62_$0,Set#Union(BreadthFirstSearch.Domain($Heap_$34,this_$46,next#65_$0),Set#UnionOne((Set#Empty() : Set (BoxType) ),v#63_$0)))) && BreadthFirstSearch.IsPath($Heap_$34,this_$46,source#60_$5,v#63_$0,path#64_$0)) && BreadthFirstSearch.ValidMap($Heap_$34,this_$46,source#60_$5,next#65_$0))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((15 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$35 : HeapType, this_$47 : ref, source#60_$6 : BoxType, m#61_$2 : DatatypeType :: {BreadthFirstSearch.ValidMap#2($Heap_$35,this_$47,source#60_$6,m#61_$2)} ( (BreadthFirstSearch.ValidMap#canCall($Heap_$35,this_$47,source#60_$6,m#61_$2) || ((((((((((!(0 == $ModuleContextHeight)) || (!(15 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$35)) && (!(this_$47 == null))) && read($Heap_$35,this_$47,alloc)) && (dtype(this_$47) == class.BreadthFirstSearch)) && GenericAlloc(source#60_$6,$Heap_$35)) && DtAlloc(m#61_$2,$Heap_$35)) && (DtType(m#61_$2) == class.Map))) ==> true )));
	assume (forall  $h0_$11 : HeapType, $h1_$11 : HeapType, this_$48 : ref, source#60_$7 : BoxType, m#61_$3 : DatatypeType :: {$HeapSucc($h0_$11,$h1_$11),BreadthFirstSearch.ValidMap($h1_$11,this_$48,source#60_$7,m#61_$3)} ( ((((((((((((($IsGoodHeap($h0_$11) && $IsGoodHeap($h1_$11)) && (!(this_$48 == null))) && read($h0_$11,this_$48,alloc)) && (dtype(this_$48) == class.BreadthFirstSearch)) && read($h1_$11,this_$48,alloc)) && (dtype(this_$48) == class.BreadthFirstSearch)) && GenericAlloc(source#60_$7,$h0_$11)) && GenericAlloc(source#60_$7,$h1_$11)) && DtAlloc(m#61_$3,$h0_$11)) && (DtType(m#61_$3) == class.Map)) && DtAlloc(m#61_$3,$h1_$11)) && (DtType(m#61_$3) == class.Map)) && $HeapSucc($h0_$11,$h1_$11)) ==> (((forall<alpha> $o_$11 : ref, $f_$11 : Field (alpha)  :: ( false ==> (read($h0_$11,$o_$11,$f_$11) == read($h1_$11,$o_$11,$f_$11)) ))) ==> (BreadthFirstSearch.ValidMap($h0_$11,this_$48,source#60_$7,m#61_$3) <==> BreadthFirstSearch.ValidMap($h1_$11,this_$48,source#60_$7,m#61_$3))) ));
	assume (forall  $h0_$12 : HeapType, $h1_$12 : HeapType, this_$49 : ref, source#60_$8 : BoxType, m#61_$4 : DatatypeType :: {$HeapSucc($h0_$12,$h1_$12),BreadthFirstSearch.ValidMap#limited($h1_$12,this_$49,source#60_$8,m#61_$4)} ( ((((((((((((($IsGoodHeap($h0_$12) && $IsGoodHeap($h1_$12)) && (!(this_$49 == null))) && read($h0_$12,this_$49,alloc)) && (dtype(this_$49) == class.BreadthFirstSearch)) && read($h1_$12,this_$49,alloc)) && (dtype(this_$49) == class.BreadthFirstSearch)) && GenericAlloc(source#60_$8,$h0_$12)) && GenericAlloc(source#60_$8,$h1_$12)) && DtAlloc(m#61_$4,$h0_$12)) && (DtType(m#61_$4) == class.Map)) && DtAlloc(m#61_$4,$h1_$12)) && (DtType(m#61_$4) == class.Map)) && $HeapSucc($h0_$12,$h1_$12)) ==> (((forall<alpha> $o_$12 : ref, $f_$12 : Field (alpha)  :: ( false ==> (read($h0_$12,$o_$12,$f_$12) == read($h1_$12,$o_$12,$f_$12)) ))) ==> (BreadthFirstSearch.ValidMap#limited($h0_$12,this_$49,source#60_$8,m#61_$4) <==> BreadthFirstSearch.ValidMap#limited($h1_$12,this_$49,source#60_$8,m#61_$4))) ));
	assume (forall  $Heap_$36 : HeapType, this_$50 : ref, source#66 : BoxType, x#67 : BoxType, m#68 : DatatypeType :: {BreadthFirstSearch.Find#2($Heap_$36,this_$50,source#66,x#67,m#68)} ( BreadthFirstSearch.Find#2($Heap_$36,this_$50,source#66,x#67,m#68) == BreadthFirstSearch.Find($Heap_$36,this_$50,source#66,x#67,m#68) ));
	assume (forall  $Heap_$37 : HeapType, this_$51 : ref, source#66_$0 : BoxType, x#67_$0 : BoxType, m#68_$0 : DatatypeType :: {BreadthFirstSearch.Find($Heap_$37,this_$51,source#66_$0,x#67_$0,m#68_$0)} ( BreadthFirstSearch.Find($Heap_$37,this_$51,source#66_$0,x#67_$0,m#68_$0) == BreadthFirstSearch.Find#limited($Heap_$37,this_$51,source#66_$0,x#67_$0,m#68_$0) ));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((16 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$38 : HeapType, this_$52 : ref, dom#69 : Set (BoxType) , v#70 : BoxType, path#71 : Seq (BoxType) , next#72 : DatatypeType, source#66_$1 : BoxType, x#67_$1 : BoxType :: {BreadthFirstSearch.Find($Heap_$38,this_$52,source#66_$1,x#67_$1,#Map.Maplet(dom#69,v#70,path#71,next#72))} ( (BreadthFirstSearch.Find#canCall($Heap_$38,this_$52,source#66_$1,x#67_$1,#Map.Maplet(dom#69,v#70,path#71,next#72)) || ((((((((((((((((!(0 == $ModuleContextHeight)) || (!(16 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$38)) && (!(this_$52 == null))) && read($Heap_$38,this_$52,alloc)) && (dtype(this_$52) == class.BreadthFirstSearch)) && ((forall  $t#7_$1 : BoxType :: {dom#69[$t#7_$1]} ( dom#69[$t#7_$1] ==> GenericAlloc($t#7_$1,$Heap_$38) )))) && GenericAlloc(v#70,$Heap_$38)) && ((forall  $i#8 : Integer :: {Seq#Index(path#71,$i#8)} ( ((0 <= $i#8) && ($i#8 < Seq#Length(path#71))) ==> GenericAlloc(Seq#Index(path#71,$i#8),$Heap_$38) )))) && DtAlloc(next#72,$Heap_$38)) && (DtType(next#72) == class.Map)) && GenericAlloc(source#66_$1,$Heap_$38)) && GenericAlloc(x#67_$1,$Heap_$38)) && BreadthFirstSearch.ValidMap($Heap_$38,this_$52,source#66_$1,#Map.Maplet(dom#69,v#70,path#71,next#72))) && BreadthFirstSearch.Domain($Heap_$38,this_$52,#Map.Maplet(dom#69,v#70,path#71,next#72))[x#67_$1])) ==> (((((x#67_$1 == v#70) ==> true) && ((!(x#67_$1 == v#70)) ==> BreadthFirstSearch.Find#canCall($Heap_$38,this_$52,source#66_$1,x#67_$1,next#72))) && (BreadthFirstSearch.Find($Heap_$38,this_$52,source#66_$1,x#67_$1,#Map.Maplet(dom#69,v#70,path#71,next#72)) == (if (x#67_$1 == v#70) then path#71 else BreadthFirstSearch.Find#limited($Heap_$38,this_$52,source#66_$1,x#67_$1,next#72)))) && ((forall  $i#9 : Integer :: {Seq#Index(BreadthFirstSearch.Find($Heap_$38,this_$52,source#66_$1,x#67_$1,#Map.Maplet(dom#69,v#70,path#71,next#72)),$i#9)} ( ((0 <= $i#9) && ($i#9 < Seq#Length(BreadthFirstSearch.Find($Heap_$38,this_$52,source#66_$1,x#67_$1,#Map.Maplet(dom#69,v#70,path#71,next#72))))) ==> GenericAlloc(Seq#Index(BreadthFirstSearch.Find($Heap_$38,this_$52,source#66_$1,x#67_$1,#Map.Maplet(dom#69,v#70,path#71,next#72)),$i#9),$Heap_$38) )))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((16 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$39 : HeapType, this_$53 : ref, source#66_$2 : BoxType, x#67_$2 : BoxType, m#68_$1 : DatatypeType :: {BreadthFirstSearch.Find($Heap_$39,this_$53,source#66_$2,x#67_$2,m#68_$1)} ( (BreadthFirstSearch.Find#canCall($Heap_$39,this_$53,source#66_$2,x#67_$2,m#68_$1) || (((((((((((((!(0 == $ModuleContextHeight)) || (!(16 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$39)) && (!(this_$53 == null))) && read($Heap_$39,this_$53,alloc)) && (dtype(this_$53) == class.BreadthFirstSearch)) && GenericAlloc(source#66_$2,$Heap_$39)) && GenericAlloc(x#67_$2,$Heap_$39)) && DtAlloc(m#68_$1,$Heap_$39)) && (DtType(m#68_$1) == class.Map)) && BreadthFirstSearch.ValidMap($Heap_$39,this_$53,source#66_$2,m#68_$1)) && BreadthFirstSearch.Domain($Heap_$39,this_$53,m#68_$1)[x#67_$2])) ==> (BreadthFirstSearch.IsPath($Heap_$39,this_$53,source#66_$2,x#67_$2,BreadthFirstSearch.Find#limited($Heap_$39,this_$53,source#66_$2,x#67_$2,m#68_$1)) && ((forall  $i#10 : Integer :: {Seq#Index(BreadthFirstSearch.Find($Heap_$39,this_$53,source#66_$2,x#67_$2,m#68_$1),$i#10)} ( ((0 <= $i#10) && ($i#10 < Seq#Length(BreadthFirstSearch.Find($Heap_$39,this_$53,source#66_$2,x#67_$2,m#68_$1)))) ==> GenericAlloc(Seq#Index(BreadthFirstSearch.Find($Heap_$39,this_$53,source#66_$2,x#67_$2,m#68_$1),$i#10),$Heap_$39) )))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((16 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$40 : HeapType, this_$54 : ref, dom#69_$0 : Set (BoxType) , v#70_$0 : BoxType, path#71_$0 : Seq (BoxType) , next#72_$0 : DatatypeType, source#66_$3 : BoxType, x#67_$3 : BoxType :: {BreadthFirstSearch.Find#2($Heap_$40,this_$54,source#66_$3,x#67_$3,#Map.Maplet(dom#69_$0,v#70_$0,path#71_$0,next#72_$0))} ( (BreadthFirstSearch.Find#canCall($Heap_$40,this_$54,source#66_$3,x#67_$3,#Map.Maplet(dom#69_$0,v#70_$0,path#71_$0,next#72_$0)) || ((((((((((((((((!(0 == $ModuleContextHeight)) || (!(16 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$40)) && (!(this_$54 == null))) && read($Heap_$40,this_$54,alloc)) && (dtype(this_$54) == class.BreadthFirstSearch)) && ((forall  $t#11 : BoxType :: {dom#69_$0[$t#11]} ( dom#69_$0[$t#11] ==> GenericAlloc($t#11,$Heap_$40) )))) && GenericAlloc(v#70_$0,$Heap_$40)) && ((forall  $i#12 : Integer :: {Seq#Index(path#71_$0,$i#12)} ( ((0 <= $i#12) && ($i#12 < Seq#Length(path#71_$0))) ==> GenericAlloc(Seq#Index(path#71_$0,$i#12),$Heap_$40) )))) && DtAlloc(next#72_$0,$Heap_$40)) && (DtType(next#72_$0) == class.Map)) && GenericAlloc(source#66_$3,$Heap_$40)) && GenericAlloc(x#67_$3,$Heap_$40)) && BreadthFirstSearch.ValidMap($Heap_$40,this_$54,source#66_$3,#Map.Maplet(dom#69_$0,v#70_$0,path#71_$0,next#72_$0))) && BreadthFirstSearch.Domain($Heap_$40,this_$54,#Map.Maplet(dom#69_$0,v#70_$0,path#71_$0,next#72_$0))[x#67_$3])) ==> (BreadthFirstSearch.Find#2($Heap_$40,this_$54,source#66_$3,x#67_$3,#Map.Maplet(dom#69_$0,v#70_$0,path#71_$0,next#72_$0)) == (if (x#67_$3 == v#70_$0) then path#71_$0 else BreadthFirstSearch.Find($Heap_$40,this_$54,source#66_$3,x#67_$3,next#72_$0))) )));
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((16 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$41 : HeapType, this_$55 : ref, source#66_$4 : BoxType, x#67_$4 : BoxType, m#68_$2 : DatatypeType :: {BreadthFirstSearch.Find#2($Heap_$41,this_$55,source#66_$4,x#67_$4,m#68_$2)} ( (BreadthFirstSearch.Find#canCall($Heap_$41,this_$55,source#66_$4,x#67_$4,m#68_$2) || (((((((((((((!(0 == $ModuleContextHeight)) || (!(16 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$41)) && (!(this_$55 == null))) && read($Heap_$41,this_$55,alloc)) && (dtype(this_$55) == class.BreadthFirstSearch)) && GenericAlloc(source#66_$4,$Heap_$41)) && GenericAlloc(x#67_$4,$Heap_$41)) && DtAlloc(m#68_$2,$Heap_$41)) && (DtType(m#68_$2) == class.Map)) && BreadthFirstSearch.ValidMap($Heap_$41,this_$55,source#66_$4,m#68_$2)) && BreadthFirstSearch.Domain($Heap_$41,this_$55,m#68_$2)[x#67_$4])) ==> true )));
	assume (forall  $h0_$13 : HeapType, $h1_$13 : HeapType, this_$56 : ref, source#66_$5 : BoxType, x#67_$5 : BoxType, m#68_$3 : DatatypeType :: {$HeapSucc($h0_$13,$h1_$13),BreadthFirstSearch.Find($h1_$13,this_$56,source#66_$5,x#67_$5,m#68_$3)} ( ((((((((((((((($IsGoodHeap($h0_$13) && $IsGoodHeap($h1_$13)) && (!(this_$56 == null))) && read($h0_$13,this_$56,alloc)) && (dtype(this_$56) == class.BreadthFirstSearch)) && read($h1_$13,this_$56,alloc)) && (dtype(this_$56) == class.BreadthFirstSearch)) && GenericAlloc(source#66_$5,$h0_$13)) && GenericAlloc(source#66_$5,$h1_$13)) && GenericAlloc(x#67_$5,$h0_$13)) && GenericAlloc(x#67_$5,$h1_$13)) && DtAlloc(m#68_$3,$h0_$13)) && (DtType(m#68_$3) == class.Map)) && DtAlloc(m#68_$3,$h1_$13)) && (DtType(m#68_$3) == class.Map)) && $HeapSucc($h0_$13,$h1_$13)) ==> (((forall<alpha> $o_$13 : ref, $f_$13 : Field (alpha)  :: ( false ==> (read($h0_$13,$o_$13,$f_$13) == read($h1_$13,$o_$13,$f_$13)) ))) ==> (BreadthFirstSearch.Find($h0_$13,this_$56,source#66_$5,x#67_$5,m#68_$3) == BreadthFirstSearch.Find($h1_$13,this_$56,source#66_$5,x#67_$5,m#68_$3))) ));
	assume (forall  $h0_$14 : HeapType, $h1_$14 : HeapType, this_$57 : ref, source#66_$6 : BoxType, x#67_$6 : BoxType, m#68_$4 : DatatypeType :: {$HeapSucc($h0_$14,$h1_$14),BreadthFirstSearch.Find#limited($h1_$14,this_$57,source#66_$6,x#67_$6,m#68_$4)} ( ((((((((((((((($IsGoodHeap($h0_$14) && $IsGoodHeap($h1_$14)) && (!(this_$57 == null))) && read($h0_$14,this_$57,alloc)) && (dtype(this_$57) == class.BreadthFirstSearch)) && read($h1_$14,this_$57,alloc)) && (dtype(this_$57) == class.BreadthFirstSearch)) && GenericAlloc(source#66_$6,$h0_$14)) && GenericAlloc(source#66_$6,$h1_$14)) && GenericAlloc(x#67_$6,$h0_$14)) && GenericAlloc(x#67_$6,$h1_$14)) && DtAlloc(m#68_$4,$h0_$14)) && (DtType(m#68_$4) == class.Map)) && DtAlloc(m#68_$4,$h1_$14)) && (DtType(m#68_$4) == class.Map)) && $HeapSucc($h0_$14,$h1_$14)) ==> (((forall<alpha> $o_$14 : ref, $f_$14 : Field (alpha)  :: ( false ==> (read($h0_$14,$o_$14,$f_$14) == read($h1_$14,$o_$14,$f_$14)) ))) ==> (BreadthFirstSearch.Find#limited($h0_$14,this_$57,source#66_$6,x#67_$6,m#68_$4) == BreadthFirstSearch.Find#limited($h1_$14,this_$57,source#66_$6,x#67_$6,m#68_$4))) ));
	assume DtType(#Map.Empty()) == class.Map;
	assume DatatypeCtorId(#Map.Empty()) == ##Map.Empty;
	assume (forall  d_$2 : DatatypeType :: ( Map.Empty?(d_$2) ==> (d_$2 == #Map.Empty()) ));
	assume (forall  this_$58 : DatatypeType :: {Map.Empty?(this_$58)} ( Map.Empty?(this_$58) <==> (DatatypeCtorId(this_$58) == ##Map.Empty) ));
	assume (forall  $h : HeapType :: {DtAlloc(#Map.Empty(),$h)} ( $IsGoodHeap($h) ==> (DtAlloc(#Map.Empty(),$h) <==> true) ));
	assume (forall  a0#0 : Set (BoxType) , a1#1 : BoxType, a2#2 : Seq (BoxType) , a3#3 : DatatypeType :: ( DtType(#Map.Maplet(a0#0,a1#1,a2#2,a3#3)) == class.Map ));
	assume (forall  a0#4 : Set (BoxType) , a1#5 : BoxType, a2#6 : Seq (BoxType) , a3#7 : DatatypeType :: ( DatatypeCtorId(#Map.Maplet(a0#4,a1#5,a2#6,a3#7)) == ##Map.Maplet ));
	assume (forall  d_$3 : DatatypeType :: ( Map.Maplet?(d_$3) ==> ((exists  a0#8 : Set (BoxType) , a1#9 : BoxType, a2#10 : Seq (BoxType) , a3#11 : DatatypeType :: ( d_$3 == #Map.Maplet(a0#8,a1#9,a2#10,a3#11) ))) ));
	assume (forall  this_$59 : DatatypeType :: {Map.Maplet?(this_$59)} ( Map.Maplet?(this_$59) <==> (DatatypeCtorId(this_$59) == ##Map.Maplet) ));
	assume (forall  a0#12 : Set (BoxType) , a1#13 : BoxType, a2#14 : Seq (BoxType) , a3#15 : DatatypeType, $h_$0 : HeapType :: {DtAlloc(#Map.Maplet(a0#12,a1#13,a2#14,a3#15),$h_$0)} ( $IsGoodHeap($h_$0) ==> (DtAlloc(#Map.Maplet(a0#12,a1#13,a2#14,a3#15),$h_$0) <==> ((((((forall  $t#16_$0 : BoxType :: {a0#12[$t#16_$0]} ( a0#12[$t#16_$0] ==> GenericAlloc($t#16_$0,$h_$0) ))) && GenericAlloc(a1#13,$h_$0)) && ((forall  $i#17 : Integer :: {Seq#Index(a2#14,$i#17)} ( ((0 <= $i#17) && ($i#17 < Seq#Length(a2#14))) ==> GenericAlloc(Seq#Index(a2#14,$i#17),$h_$0) )))) && DtAlloc(a3#15,$h_$0)) && (DtType(a3#15) == class.Map))) ));
	assume (forall  a0#18 : Set (BoxType) , a1#19 : BoxType, a2#20 : Seq (BoxType) , a3#21 : DatatypeType :: ( Map.dom(#Map.Maplet(a0#18,a1#19,a2#20,a3#21)) == a0#18 ));
	assume (forall  a0#22 : Set (BoxType) , a1#23 : BoxType, a2#24 : Seq (BoxType) , a3#25 : DatatypeType, d_$4 : DatatypeType :: ( a0#22[$Box(d_$4)] ==> (DtRank(d_$4) < DtRank(#Map.Maplet(a0#22,a1#23,a2#24,a3#25))) ));
	assume (forall  a0#26 : Set (BoxType) , a1#27 : BoxType, a2#28 : Seq (BoxType) , a3#29 : DatatypeType :: ( ##Map.Maplet#1(#Map.Maplet(a0#26,a1#27,a2#28,a3#29)) == a1#27 ));
	assume (forall  a0#30 : Set (BoxType) , a1#31 : BoxType, a2#32 : Seq (BoxType) , a3#33 : DatatypeType :: ( DtRank(($Unbox(a1#31) : DatatypeType)) < DtRank(#Map.Maplet(a0#30,a1#31,a2#32,a3#33)) ));
	assume (forall  a0#34 : Set (BoxType) , a1#35 : BoxType, a2#36 : Seq (BoxType) , a3#37 : DatatypeType :: ( ##Map.Maplet#2(#Map.Maplet(a0#34,a1#35,a2#36,a3#37)) == a2#36 ));
	assume (forall  a0#38 : Set (BoxType) , a1#39 : BoxType, a2#40 : Seq (BoxType) , a3#41 : DatatypeType, i_$18 : Integer :: ( ((0 <= i_$18) && (i_$18 < Seq#Length(a2#40))) ==> (DtRank(($Unbox(Seq#Index(a2#40,i_$18)) : DatatypeType)) < DtRank(#Map.Maplet(a0#38,a1#39,a2#40,a3#41))) ));
	assume (forall  a0#42 : Set (BoxType) , a1#43 : BoxType, a2#44 : Seq (BoxType) , a3#45 : DatatypeType :: ( Map.next(#Map.Maplet(a0#42,a1#43,a2#44,a3#45)) == a3#45 ));
	assume (forall  a0#46 : Set (BoxType) , a1#47 : BoxType, a2#48 : Seq (BoxType) , a3#49 : DatatypeType :: ( DtRank(a3#49) < DtRank(#Map.Maplet(a0#46,a1#47,a2#48,a3#49)) ));
	assume DtType(#List.Nil()) == class.List;
	assume DatatypeCtorId(#List.Nil()) == ##List.Nil;
	assume (forall  d_$5 : DatatypeType :: ( List.Nil?(d_$5) ==> (d_$5 == #List.Nil()) ));
	assume (forall  this_$60 : DatatypeType :: {List.Nil?(this_$60)} ( List.Nil?(this_$60) <==> (DatatypeCtorId(this_$60) == ##List.Nil) ));
	assume (forall  $h_$1 : HeapType :: {DtAlloc(#List.Nil(),$h_$1)} ( $IsGoodHeap($h_$1) ==> (DtAlloc(#List.Nil(),$h_$1) <==> true) ));
	assume (forall  a0#50 : BoxType, a1#51 : DatatypeType :: ( DtType(#List.Cons(a0#50,a1#51)) == class.List ));
	assume (forall  a0#52 : BoxType, a1#53 : DatatypeType :: ( DatatypeCtorId(#List.Cons(a0#52,a1#53)) == ##List.Cons ));
	assume (forall  d_$6 : DatatypeType :: ( List.Cons?(d_$6) ==> ((exists  a0#54 : BoxType, a1#55 : DatatypeType :: ( d_$6 == #List.Cons(a0#54,a1#55) ))) ));
	assume (forall  this_$61 : DatatypeType :: {List.Cons?(this_$61)} ( List.Cons?(this_$61) <==> (DatatypeCtorId(this_$61) == ##List.Cons) ));
	assume (forall  a0#56 : BoxType, a1#57 : DatatypeType, $h_$2 : HeapType :: {DtAlloc(#List.Cons(a0#56,a1#57),$h_$2)} ( $IsGoodHeap($h_$2) ==> (DtAlloc(#List.Cons(a0#56,a1#57),$h_$2) <==> ((GenericAlloc(a0#56,$h_$2) && DtAlloc(a1#57,$h_$2)) && (DtType(a1#57) == class.List))) ));
	assume (forall  a0#58 : BoxType, a1#59 : DatatypeType :: ( ##List.Cons#0(#List.Cons(a0#58,a1#59)) == a0#58 ));
	assume (forall  a0#60 : BoxType, a1#61 : DatatypeType :: ( DtRank(($Unbox(a0#60) : DatatypeType)) < DtRank(#List.Cons(a0#60,a1#61)) ));
	assume (forall  a0#62 : BoxType, a1#63 : DatatypeType :: ( ##List.Cons#1(#List.Cons(a0#62,a1#63)) == a1#63 ));
	assume (forall  a0#64 : BoxType, a1#65 : DatatypeType :: ( DtRank(a1#65) < DtRank(#List.Cons(a0#64,a1#65)) ));
	assume DtType(#Nat.Zero()) == class.Nat;
	assume DatatypeCtorId(#Nat.Zero()) == ##Nat.Zero;
	assume (forall  d_$7 : DatatypeType :: ( Nat.Zero?(d_$7) ==> (d_$7 == #Nat.Zero()) ));
	assume (forall  this_$62 : DatatypeType :: {Nat.Zero?(this_$62)} ( Nat.Zero?(this_$62) <==> (DatatypeCtorId(this_$62) == ##Nat.Zero) ));
	assume (forall  $h_$3 : HeapType :: {DtAlloc(#Nat.Zero(),$h_$3)} ( $IsGoodHeap($h_$3) ==> (DtAlloc(#Nat.Zero(),$h_$3) <==> true) ));
	assume (forall  a0#66 : DatatypeType :: ( DtType(#Nat.Suc(a0#66)) == class.Nat ));
	assume (forall  a0#67 : DatatypeType :: ( DatatypeCtorId(#Nat.Suc(a0#67)) == ##Nat.Suc ));
	assume (forall  d_$8 : DatatypeType :: ( Nat.Suc?(d_$8) ==> ((exists  a0#68 : DatatypeType :: ( d_$8 == #Nat.Suc(a0#68) ))) ));
	assume (forall  this_$63 : DatatypeType :: {Nat.Suc?(this_$63)} ( Nat.Suc?(this_$63) <==> (DatatypeCtorId(this_$63) == ##Nat.Suc) ));
	assume (forall  a0#69 : DatatypeType, $h_$4 : HeapType :: {DtAlloc(#Nat.Suc(a0#69),$h_$4)} ( $IsGoodHeap($h_$4) ==> (DtAlloc(#Nat.Suc(a0#69),$h_$4) <==> (DtAlloc(a0#69,$h_$4) && (DtType(a0#69) == class.Nat))) ));
	assume (forall  a0#70 : DatatypeType :: ( Nat.predecessor(#Nat.Suc(a0#70)) == a0#70 ));
	assume (forall  a0#71 : DatatypeType :: ( DtRank(a0#71) < DtRank(#Nat.Suc(a0#71)) ));
	assume (forall<alpha> $o_$15 : ref, $f_$15 : Field (alpha) , alloc_$0 : Field (Boolean) , null_$0 : ref, $Heap_$42 : HeapType :: {lambda#0(alloc_$0,null_$0,$Heap_$42)[$o_$15,$f_$15]} ( lambda#0(alloc_$0,null_$0,$Heap_$42)[$o_$15,$f_$15] <==> (((!($o_$15 == null_$0)) && read($Heap_$42,$o_$15,alloc_$0)) ==> false) ));
	assume (forall<alpha> $o_$16 : ref, $f_$16 : Field (alpha) , alloc_$1 : Field (Boolean) , null_$1 : ref, $Heap_$43 : HeapType :: {lambda#1(alloc_$1,null_$1,$Heap_$43)[$o_$16,$f_$16]} ( lambda#1(alloc_$1,null_$1,$Heap_$43)[$o_$16,$f_$16] <==> (((!($o_$16 == null_$1)) && read($Heap_$43,$o_$16,alloc_$1)) ==> false) ));
	assume (forall<alpha> $o_$17 : ref, $f_$17 : Field (alpha) , alloc_$2 : Field (Boolean) , null_$2 : ref, $Heap_$44 : HeapType :: {lambda#2(alloc_$2,null_$2,$Heap_$44)[$o_$17,$f_$17]} ( lambda#2(alloc_$2,null_$2,$Heap_$44)[$o_$17,$f_$17] <==> (((!($o_$17 == null_$2)) && read($Heap_$44,$o_$17,alloc_$2)) ==> false) ));
	assume (forall<alpha> $o_$18 : ref, $f_$18 : Field (alpha) , alloc_$3 : Field (Boolean) , null_$3 : ref, $Heap_$45 : HeapType :: {lambda#3(alloc_$3,null_$3,$Heap_$45)[$o_$18,$f_$18]} ( lambda#3(alloc_$3,null_$3,$Heap_$45)[$o_$18,$f_$18] <==> (((!($o_$18 == null_$3)) && read($Heap_$45,$o_$18,alloc_$3)) ==> false) ));
	assume (forall  $y#27 : BoxType, V#13_$0 : Set (BoxType) , $Heap_$46 : HeapType, this_$64 : ref, v#21_$0 : BoxType :: {lambda#4(V#13_$0,$Heap_$46,this_$64,v#21_$0)[$y#27]} ( lambda#4(V#13_$0,$Heap_$46,this_$64,v#21_$0)[$y#27] <==> ((exists  w#25 : BoxType :: ( ((GenericAlloc(w#25,$Heap_$46) && BreadthFirstSearch.Succ($Heap_$46,this_$64,v#21_$0)[w#25]) && (!V#13_$0[w#25])) && ($y#27 == w#25) ))) ));
	assume (forall<alpha> $o_$19 : ref, $f_$19 : Field (alpha) , alloc_$4 : Field (Boolean) , null_$4 : ref, $Heap_$47 : HeapType :: {lambda#5(alloc_$4,null_$4,$Heap_$47)[$o_$19,$f_$19]} ( lambda#5(alloc_$4,null_$4,$Heap_$47)[$o_$19,$f_$19] <==> (((!($o_$19 == null_$4)) && read($Heap_$47,$o_$19,alloc_$4)) ==> false) ));
	assume (forall<alpha> $o_$20 : ref, $f_$20 : Field (alpha) , alloc_$5 : Field (Boolean) , null_$5 : ref, $Heap_$48 : HeapType :: {lambda#6(alloc_$5,null_$5,$Heap_$48)[$o_$20,$f_$20]} ( lambda#6(alloc_$5,null_$5,$Heap_$48)[$o_$20,$f_$20] <==> (((!($o_$20 == null_$5)) && read($Heap_$48,$o_$20,alloc_$5)) ==> false) ));
	assume (forall<alpha> $o_$21 : ref, $f_$21 : Field (alpha) , alloc_$6 : Field (Boolean) , null_$6 : ref, $Heap_$49 : HeapType :: {lambda#7(alloc_$6,null_$6,$Heap_$49)[$o_$21,$f_$21]} ( lambda#7(alloc_$6,null_$6,$Heap_$49)[$o_$21,$f_$21] <==> (((!($o_$21 == null_$6)) && read($Heap_$49,$o_$21,alloc_$6)) ==> false) ));
	assume (forall<alpha> $o_$22 : ref, $f_$22 : Field (alpha) , alloc_$7 : Field (Boolean) , null_$7 : ref, $Heap_$50 : HeapType :: {lambda#8(alloc_$7,null_$7,$Heap_$50)[$o_$22,$f_$22]} ( lambda#8(alloc_$7,null_$7,$Heap_$50)[$o_$22,$f_$22] <==> (((!($o_$22 == null_$7)) && read($Heap_$50,$o_$22,alloc_$7)) ==> false) ));
	assume (forall<alpha> $o_$23 : ref, $f_$23 : Field (alpha) , alloc_$8 : Field (Boolean) , null_$8 : ref, $Heap_$51 : HeapType :: {lambda#9(alloc_$8,null_$8,$Heap_$51)[$o_$23,$f_$23]} ( lambda#9(alloc_$8,null_$8,$Heap_$51)[$o_$23,$f_$23] <==> (((!($o_$23 == null_$8)) && read($Heap_$51,$o_$23,alloc_$8)) ==> false) ));
	assume (forall<alpha> $o_$24 : ref, $f_$24 : Field (alpha) , alloc_$9 : Field (Boolean) , null_$9 : ref, $Heap_$52 : HeapType :: {lambda#10(alloc_$9,null_$9,$Heap_$52)[$o_$24,$f_$24]} ( lambda#10(alloc_$9,null_$9,$Heap_$52)[$o_$24,$f_$24] <==> (((!($o_$24 == null_$9)) && read($Heap_$52,$o_$24,alloc_$9)) ==> false) ));
	assume (forall<alpha> $o_$25 : ref, $f_$25 : Field (alpha) , alloc_$10 : Field (Boolean) , null_$10 : ref, $Heap_$53 : HeapType :: {lambda#11(alloc_$10,null_$10,$Heap_$53)[$o_$25,$f_$25]} ( lambda#11(alloc_$10,null_$10,$Heap_$53)[$o_$25,$f_$25] <==> (((!($o_$25 == null_$10)) && read($Heap_$53,$o_$25,alloc_$10)) ==> false) ));
	assume (forall  $y#14 : BoxType, S#42_$1 : Set (BoxType) , $Heap_$54 : HeapType, AllVertices#43_$1 : Set (BoxType) , this_$65 : ref :: {lambda#12(S#42_$1,$Heap_$54,AllVertices#43_$1,this_$65)[$y#14]} ( lambda#12(S#42_$1,$Heap_$54,AllVertices#43_$1,this_$65)[$y#14] <==> ((exists  w#44_$0 : BoxType :: ( ((GenericAlloc(w#44_$0,$Heap_$54) && AllVertices#43_$1[w#44_$0]) && ((exists  x#45_$0 : BoxType :: ( (GenericAlloc(x#45_$0,$Heap_$54) && S#42_$1[x#45_$0]) && BreadthFirstSearch.Succ($Heap_$54,this_$65,x#45_$0)[w#44_$0] )))) && ($y#14 == w#44_$0) ))) ));
	assume (forall<alpha> $o_$26 : ref, $f_$26 : Field (alpha) , alloc_$11 : Field (Boolean) , null_$11 : ref, $Heap_$55 : HeapType :: {lambda#13(alloc_$11,null_$11,$Heap_$55)[$o_$26,$f_$26]} ( lambda#13(alloc_$11,null_$11,$Heap_$55)[$o_$26,$f_$26] <==> (((!($o_$26 == null_$11)) && read($Heap_$55,$o_$26,alloc_$11)) ==> false) ));
	assume (forall<alpha> $o_$27 : ref, $f_$27 : Field (alpha) , alloc_$12 : Field (Boolean) , null_$12 : ref, $Heap_$56 : HeapType :: {lambda#14(alloc_$12,null_$12,$Heap_$56)[$o_$27,$f_$27]} ( lambda#14(alloc_$12,null_$12,$Heap_$56)[$o_$27,$f_$27] <==> (((!($o_$27 == null_$12)) && read($Heap_$56,$o_$27,alloc_$12)) ==> false) ));
	assume (forall<alpha> $o_$28 : ref, $f_$28 : Field (alpha) , alloc_$13 : Field (Boolean) , null_$13 : ref, $Heap_$57 : HeapType :: {lambda#15(alloc_$13,null_$13,$Heap_$57)[$o_$28,$f_$28]} ( lambda#15(alloc_$13,null_$13,$Heap_$57)[$o_$28,$f_$28] <==> (((!($o_$28 == null_$13)) && read($Heap_$57,$o_$28,alloc_$13)) ==> false) ));
	assume (forall<alpha> $o_$29 : ref, $f_$29 : Field (alpha) , alloc_$14 : Field (Boolean) , null_$14 : ref, $Heap_$58 : HeapType :: {lambda#16(alloc_$14,null_$14,$Heap_$58)[$o_$29,$f_$29]} ( lambda#16(alloc_$14,null_$14,$Heap_$58)[$o_$29,$f_$29] <==> (((!($o_$29 == null_$14)) && read($Heap_$58,$o_$29,alloc_$14)) ==> false) ));
	assume (forall<alpha> $o_$30 : ref, $f_$30 : Field (alpha) , alloc_$15 : Field (Boolean) , null_$15 : ref, $Heap_$59 : HeapType :: {lambda#17(alloc_$15,null_$15,$Heap_$59)[$o_$30,$f_$30]} ( lambda#17(alloc_$15,null_$15,$Heap_$59)[$o_$30,$f_$30] <==> (((!($o_$30 == null_$15)) && read($Heap_$59,$o_$30,alloc_$15)) ==> false) ));
	assume (forall<alpha> $o_$31 : ref, $f_$31 : Field (alpha) , alloc_$16 : Field (Boolean) , null_$16 : ref, $Heap_$60 : HeapType :: {lambda#18(alloc_$16,null_$16,$Heap_$60)[$o_$31,$f_$31]} ( lambda#18(alloc_$16,null_$16,$Heap_$60)[$o_$31,$f_$31] <==> (((!($o_$31 == null_$16)) && read($Heap_$60,$o_$31,alloc_$16)) ==> false) ));
	assume (forall<alpha> $o_$32 : ref, $f_$32 : Field (alpha) , alloc_$17 : Field (Boolean) , null_$17 : ref, $Heap_$61 : HeapType :: {lambda#19(alloc_$17,null_$17,$Heap_$61)[$o_$32,$f_$32]} ( lambda#19(alloc_$17,null_$17,$Heap_$61)[$o_$32,$f_$32] <==> (((!($o_$32 == null_$17)) && read($Heap_$61,$o_$32,alloc_$17)) ==> false) ));
	assume (forall<alpha> $o_$33 : ref, $f_$33 : Field (alpha) , alloc_$18 : Field (Boolean) , null_$18 : ref, $Heap_$62 : HeapType :: {lambda#20(alloc_$18,null_$18,$Heap_$62)[$o_$33,$f_$33]} ( lambda#20(alloc_$18,null_$18,$Heap_$62)[$o_$33,$f_$33] <==> (((!($o_$33 == null_$18)) && read($Heap_$62,$o_$33,alloc_$18)) ==> false) ));
	assume (forall<alpha> $o_$34 : ref, $f_$34 : Field (alpha) , alloc_$19 : Field (Boolean) , null_$19 : ref, $Heap_$63 : HeapType :: {lambda#21(alloc_$19,null_$19,$Heap_$63)[$o_$34,$f_$34]} ( lambda#21(alloc_$19,null_$19,$Heap_$63)[$o_$34,$f_$34] <==> (((!($o_$34 == null_$19)) && read($Heap_$63,$o_$34,alloc_$19)) ==> false) ));
	assume (forall<alpha> $o_$35 : ref, $f_$35 : Field (alpha) , alloc_$20 : Field (Boolean) , null_$20 : ref, $Heap_$64 : HeapType :: {lambda#22(alloc_$20,null_$20,$Heap_$64)[$o_$35,$f_$35]} ( lambda#22(alloc_$20,null_$20,$Heap_$64)[$o_$35,$f_$35] <==> (((!($o_$35 == null_$20)) && read($Heap_$64,$o_$35,alloc_$20)) ==> false) ));
	assume (forall<alpha> $o_$36 : ref, $f_$36 : Field (alpha) , alloc_$21 : Field (Boolean) , null_$21 : ref, $Heap_$65 : HeapType :: {lambda#23(alloc_$21,null_$21,$Heap_$65)[$o_$36,$f_$36]} ( lambda#23(alloc_$21,null_$21,$Heap_$65)[$o_$36,$f_$36] <==> (((!($o_$36 == null_$21)) && read($Heap_$65,$o_$36,alloc_$21)) ==> false) ));
	assume (forall<alpha> $o_$37 : ref, $f_$37 : Field (alpha) , alloc_$22 : Field (Boolean) , null_$22 : ref, $Heap_$66 : HeapType :: {lambda#24(alloc_$22,null_$22,$Heap_$66)[$o_$37,$f_$37]} ( lambda#24(alloc_$22,null_$22,$Heap_$66)[$o_$37,$f_$37] <==> (((!($o_$37 == null_$22)) && read($Heap_$66,$o_$37,alloc_$22)) ==> false) ));
	goto PreconditionGeneratedEntry;
$exit:
	assume false;
PreconditionGeneratedEntry:
	assume $IsGoodHeap($Heap);
	assume ((!(this == null)) && read($Heap,this,alloc)) && (dtype(this) == class.BreadthFirstSearch);
	assume GenericAlloc(source#6,$Heap);
	assume GenericAlloc(dest#7,$Heap);
	assume (forall  $t#0_$2 : BoxType :: {AllVertices#8[$t#0_$2]} ( AllVertices#8[$t#0_$2] ==> GenericAlloc($t#0_$2,$Heap) ));
	assume (forall  $i#1_$0 : Integer :: {Seq#Index(path#10,$i#1_$0)} ( ((0 <= $i#1_$0) && ($i#1_$0 < Seq#Length(path#10))) ==> GenericAlloc(Seq#Index(path#10,$i#1_$0),$Heap) ));
	assume (forall  $t#10_$1 : BoxType :: {V#13[$t#10_$1]} ( V#13[$t#10_$1] ==> GenericAlloc($t#10_$1,$Heap) ));
	assume (forall  $t#11_$0 : BoxType :: {C#14[$t#11_$0]} ( C#14[$t#11_$0] ==> GenericAlloc($t#11_$0,$Heap) ));
	assume (forall  $t#12_$0 : BoxType :: {N#15[$t#12_$0]} ( N#15[$t#12_$0] ==> GenericAlloc($t#12_$0,$Heap) ));
	assume (forall  $t#16_$1 : BoxType :: {Processed#16[$t#16_$1]} ( Processed#16[$t#16_$1] ==> GenericAlloc($t#16_$1,$Heap) ));
	assume DtAlloc(paths#17,$Heap) && (DtType(paths#17) == class.Map);
	assume DtAlloc(dd#18,$Heap) && (DtType(dd#18) == class.Nat);
	assume GenericAlloc(v#21,$Heap);
	assume (forall  $i#21 : Integer :: {Seq#Index(pathToV#22,$i#21)} ( ((0 <= $i#21) && ($i#21 < Seq#Length(pathToV#22))) ==> GenericAlloc(Seq#Index(pathToV#22,$i#21),$Heap) ));
	assume (forall  $t#26 : BoxType :: {newlyEncountered#24[$t#26]} ( newlyEncountered#24[$t#26] ==> GenericAlloc($t#26,$Heap) ));
	assume DtAlloc($rhs#30,$Heap) && (DtType($rhs#30) == class.Map);
	assume (0 == $ModuleContextHeight) && $InMethodContext;
	assume AllVertices#8[source#6];
	assume AllVertices#8[dest#7];
	assume (BreadthFirstSearch.IsClosed#canCall($Heap,this,AllVertices#8) && BreadthFirstSearch.IsClosed($Heap,this,AllVertices#8)) && ((forall  v#5_$1 : BoxType :: ( GenericAlloc(v#5_$1,$Heap) ==> (AllVertices#8[v#5_$1] ==> Set#Subset(BreadthFirstSearch.Succ($Heap,this,v#5_$1),AllVertices#8)) )));
	assume BreadthFirstSearch.IsClosed#canCall($Heap,this,AllVertices#8) ==> (BreadthFirstSearch.IsClosed($Heap,this,AllVertices#8) || ((forall  v#5_$2 : BoxType :: ( GenericAlloc(v#5_$2,$Heap) ==> (AllVertices#8[v#5_$2] ==> Set#Subset(BreadthFirstSearch.Succ($Heap,this,v#5_$2),AllVertices#8)) ))));
	goto anon0;
anon0:
	assume $_Frame_$_0 == lambda#3(alloc,null,$Heap);
	assume true;
	assume true;
	assume true;
	assume true;
	assume $rhs#13_$_0 == Set#UnionOne((Set#Empty() : Set (BoxType) ),source#6);
	assume true;
	assume $rhs#14_$_0 == Set#UnionOne((Set#Empty() : Set (BoxType) ),source#6);
	assume true;
	assume $rhs#15_$_0 == (Set#Empty() : Set (BoxType) );
	assume true;
	assume true;
	assume true;
	assume true;
	assume $rhs#17_$_0 == (Set#Empty() : Set (BoxType) );
	assume true;
	assume $rhs#18_$_0 == #Map.Maplet(Set#UnionOne((Set#Empty() : Set (BoxType) ),source#6),source#6,(Seq#Empty() : Seq (BoxType) ),#Map.Empty());
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume dd#18_$_0 == #Nat.Zero();
	assume true;
	assume $decr0$init$0_$_0 == Set#Difference(AllVertices#8,$rhs#17_$_0);
	assert  $w0_$_0 ==> Set#Subset($rhs#13_$_0,AllVertices#8);
	assert  $w0_$_0 ==> Set#Subset($rhs#17_$_0,AllVertices#8);
	assert  $w0_$_0 ==> Set#Subset($rhs#14_$_0,AllVertices#8);
	assert  $w0_$_0 ==> Set#Subset($rhs#15_$_0,AllVertices#8);
	assert  $w0_$_0 ==> $rhs#13_$_0[source#6];
	assert  $w0_$_0 ==> Set#Equal($rhs#13_$_0,Set#Union(Set#Union($rhs#17_$_0,$rhs#14_$_0),$rhs#15_$_0));
	assert  $w0_$_0 ==> Set#Disjoint($rhs#17_$_0,$rhs#14_$_0);
	assert  $w0_$_0 ==> Set#Disjoint(Set#Union($rhs#17_$_0,$rhs#14_$_0),$rhs#15_$_0);
	assert  $w0_$_0 ==> BreadthFirstSearch.ValidMap#2($Heap,this,source#6,$rhs#18_$_0);
	assert  $w0_$_0 ==> Set#Equal($rhs#13_$_0,BreadthFirstSearch.Domain($Heap,this,$rhs#18_$_0));
	assert  $w0_$_0 ==> ((forall  x#19 : BoxType :: ( GenericAlloc(x#19,$Heap) ==> ($rhs#14_$_0[x#19] ==> (Seq#Length(BreadthFirstSearch.Find#2($Heap,this,source#6,x#19,$rhs#18_$_0)) == 0)) )));
	assert  $w0_$_0 ==> ((forall  x#20 : BoxType :: ( GenericAlloc(x#20,$Heap) ==> ($rhs#15_$_0[x#20] ==> (Seq#Length(BreadthFirstSearch.Find#2($Heap,this,source#6,x#20,$rhs#18_$_0)) == (0 + 1))) )));
	assert  $w0_$_0 ==> (BreadthFirstSearch.R($Heap,this,source#6,dd#18_$_0,AllVertices#8)[dest#7] ==> $rhs#14_$_0[dest#7]);
	assert  $w0_$_0 ==> ((!(0 == 0)) ==> (!BreadthFirstSearch.R#2($Heap,this,source#6,Nat.predecessor(dd#18_$_0),AllVertices#8)[dest#7]));
	assert  $w0_$_0 ==> Set#Equal(Set#Union($rhs#17_$_0,$rhs#14_$_0),BreadthFirstSearch.R#2($Heap,this,source#6,dd#18_$_0,AllVertices#8));
	assert  $w0_$_0 ==> Set#Equal($rhs#15_$_0,Set#Difference(BreadthFirstSearch.Successors($Heap,this,$rhs#17_$_0,AllVertices#8),BreadthFirstSearch.R#2($Heap,this,source#6,dd#18_$_0,AllVertices#8)));
	assert  $w0_$_0 ==> (Set#Equal($rhs#14_$_0,(Set#Empty() : Set (BoxType) )) ==> Set#Equal($rhs#15_$_0,(Set#Empty() : Set (BoxType) )));
	assert  $w0_$_0 ==> (BreadthFirstSearch.Value#2($Heap,this,dd#18_$_0) == 0);
	goto anon50_LoopHead;
anon50_LoopHead:
	assume (forall  $t#11_$1 : BoxType :: {C#14_$_0[$t#11_$1]} ( C#14_$_0[$t#11_$1] ==> GenericAlloc($t#11_$1,$Heap_$_0) ));
	assume (forall  $t#12_$1 : BoxType :: {N#15_$_0[$t#12_$1]} ( N#15_$_0[$t#12_$1] ==> GenericAlloc($t#12_$1,$Heap_$_0) ));
	assume DtAlloc(dd#18_$_1,$Heap_$_0) && (DtType(dd#18_$_1) == class.Nat);
	assume (forall  $t#26_$0 : BoxType :: {newlyEncountered#24_$_0[$t#26_$0]} ( newlyEncountered#24_$_0[$t#26_$0] ==> GenericAlloc($t#26_$0,$Heap_$_0) ));
	assume (forall  $t#10_$2 : BoxType :: {V#13_$_0[$t#10_$2]} ( V#13_$_0[$t#10_$2] ==> GenericAlloc($t#10_$2,$Heap_$_0) ));
	assume DtAlloc($rhs#30_$_0,$Heap_$_0) && (DtType($rhs#30_$_0) == class.Map);
	assume $IsGoodHeap($Heap_$_0);
	assume DtAlloc(paths#17_$_0,$Heap_$_0) && (DtType(paths#17_$_0) == class.Map);
	assume GenericAlloc(v#21_$_0,$Heap_$_0);
	assume (forall  $t#16_$2 : BoxType :: {Processed#16_$_0[$t#16_$2]} ( Processed#16_$_0[$t#16_$2] ==> GenericAlloc($t#16_$2,$Heap_$_0) ));
	assume (forall  $i#21_$0 : Integer :: {Seq#Index(pathToV#22_$_0,$i#21_$0)} ( ((0 <= $i#21_$0) && ($i#21_$0 < Seq#Length(pathToV#22_$_0))) ==> GenericAlloc(Seq#Index(pathToV#22_$_0,$i#21_$0),$Heap_$_0) ));
	assume 0 <= d#9_$_0;
	assume $w0_$_0 ==> (((Set#Subset(V#13_$_0,AllVertices#8) ==> true) && ((Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) ==> true)) && (((Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) && Set#Subset(C#14_$_0,AllVertices#8)) ==> true));
	assume $w0_$_0 ==> Set#Subset(V#13_$_0,AllVertices#8);
	assume $w0_$_0 ==> Set#Subset(Processed#16_$_0,AllVertices#8);
	assume $w0_$_0 ==> Set#Subset(C#14_$_0,AllVertices#8);
	assume $w0_$_0 ==> Set#Subset(N#15_$_0,AllVertices#8);
	assume $w0_$_0 ==> true;
	assume $w0_$_0 ==> V#13_$_0[source#6];
	assume $w0_$_0 ==> true;
	assume $w0_$_0 ==> Set#Equal(V#13_$_0,Set#Union(Set#Union(Processed#16_$_0,C#14_$_0),N#15_$_0));
	assume $w0_$_0 ==> (Set#Disjoint(Processed#16_$_0,C#14_$_0) ==> true);
	assume $w0_$_0 ==> Set#Disjoint(Processed#16_$_0,C#14_$_0);
	assume $w0_$_0 ==> Set#Disjoint(Set#Union(Processed#16_$_0,C#14_$_0),N#15_$_0);
	assume $w0_$_0 ==> BreadthFirstSearch.ValidMap#canCall($Heap_$_0,this,source#6,paths#17_$_0);
	assume $w0_$_0 ==> BreadthFirstSearch.ValidMap#2($Heap_$_0,this,source#6,paths#17_$_0);
	assume $w0_$_0 ==> BreadthFirstSearch.Domain#canCall($Heap_$_0,this,paths#17_$_0);
	assume $w0_$_0 ==> Set#Equal(V#13_$_0,BreadthFirstSearch.Domain($Heap_$_0,this,paths#17_$_0));
	assume $w0_$_0 ==> ((forall  x#19_$0 : BoxType :: ( GenericAlloc(x#19_$0,$Heap_$_0) ==> (C#14_$_0[x#19_$0] ==> BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,x#19_$0,paths#17_$_0)) )));
	assume $w0_$_0 ==> ((forall  x#19_$1 : BoxType :: ( GenericAlloc(x#19_$1,$Heap_$_0) ==> (C#14_$_0[x#19_$1] ==> (Seq#Length(BreadthFirstSearch.Find#2($Heap_$_0,this,source#6,x#19_$1,paths#17_$_0)) == d#9_$_0)) )));
	assume $w0_$_0 ==> ((forall  x#20_$0 : BoxType :: ( GenericAlloc(x#20_$0,$Heap_$_0) ==> (N#15_$_0[x#20_$0] ==> BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,x#20_$0,paths#17_$_0)) )));
	assume $w0_$_0 ==> ((forall  x#20_$1 : BoxType :: ( GenericAlloc(x#20_$1,$Heap_$_0) ==> (N#15_$_0[x#20_$1] ==> (Seq#Length(BreadthFirstSearch.Find#2($Heap_$_0,this,source#6,x#20_$1,paths#17_$_0)) == (d#9_$_0 + 1))) )));
	assume $w0_$_0 ==> (BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8) && (BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)[dest#7] ==> true));
	assume $w0_$_0 ==> (BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)[dest#7] ==> C#14_$_0[dest#7]);
	assume $w0_$_0 ==> ((!(d#9_$_0 == 0)) ==> BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,Nat.predecessor(dd#18_$_1),AllVertices#8));
	assume $w0_$_0 ==> ((!(d#9_$_0 == 0)) ==> (!BreadthFirstSearch.R#2($Heap_$_0,this,source#6,Nat.predecessor(dd#18_$_1),AllVertices#8)[dest#7]));
	assume $w0_$_0 ==> BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8);
	assume $w0_$_0 ==> Set#Equal(Set#Union(Processed#16_$_0,C#14_$_0),BreadthFirstSearch.R#2($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8));
	assume $w0_$_0 ==> (BreadthFirstSearch.Successors#canCall($Heap_$_0,this,Processed#16_$_0,AllVertices#8) && BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8));
	assume $w0_$_0 ==> Set#Equal(N#15_$_0,Set#Difference(BreadthFirstSearch.Successors($Heap_$_0,this,Processed#16_$_0,AllVertices#8),BreadthFirstSearch.R#2($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)));
	assume $w0_$_0 ==> (Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) )) ==> true);
	assume $w0_$_0 ==> (Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) )) ==> Set#Equal(N#15_$_0,(Set#Empty() : Set (BoxType) )));
	assume $w0_$_0 ==> BreadthFirstSearch.Value#canCall($Heap_$_0,this,dd#18_$_1);
	assume $w0_$_0 ==> (BreadthFirstSearch.Value#2($Heap_$_0,this,dd#18_$_1) == d#9_$_0);
	assume (forall<alpha> $o_$38 : ref, $f_$38 : Field (alpha)  :: {read($Heap_$_0,$o_$38,$f_$38)} ( ((!($o_$38 == null)) && read($Heap,$o_$38,alloc)) ==> (read($Heap_$_0,$o_$38,$f_$38) == read($Heap,$o_$38,$f_$38)) ));
	assume $HeapSucc($Heap,$Heap_$_0);
	assume (forall<alpha> $o_$39 : ref, $f_$39 : Field (alpha)  :: {read($Heap_$_0,$o_$39,$f_$39)} ( ((!($o_$39 == null)) && read($Heap,$o_$39,alloc)) ==> ((read($Heap_$_0,$o_$39,$f_$39) == read($Heap,$o_$39,$f_$39)) || $_Frame_$_0[$o_$39,$f_$39]) ));
	assume Set#Subset(Set#Difference(AllVertices#8,Processed#16_$_0),$decr0$init$0_$_0) && (Set#Equal(Set#Difference(AllVertices#8,Processed#16_$_0),$decr0$init$0_$_0) ==> true);
	if ($_$_condition) { goto anon50_LoopDone; } else { goto anon50_LoopBody; }
anon50_LoopDone:
	assume !true;
	goto anon40;
anon50_LoopBody:
	assume true;
	if ($_$_condition_$0) { goto anon51_Then; } else { goto anon51_Else; }
anon40:
	assume true;
	if ($_$_condition_$8) { goto anon68_Then; } else { goto anon68_Else; }
anon51_Then:
	assume !$w0_$_0;
	if ($_$_condition_$1) { goto anon52_Then; } else { goto anon52_Else; }
anon51_Else:
	assume $w0_$_0;
	assume true;
	if ($_$_condition_$2) { goto anon61_Then; } else { goto anon61_Else; }
anon52_Then:
	assume Set#Subset(V#13_$_0,AllVertices#8);
	if ($_$_condition_$3) { goto anon53_Then; } else { goto anon53_Else; }
anon52_Else:
	assume !Set#Subset(V#13_$_0,AllVertices#8);
	if ($_$_condition_$4) { goto anon53_Then; } else { goto anon53_Else; }
anon61_Then:
	assume Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) ));
	goto anon40;
anon61_Else:
	assume !Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) ));
	assume true;
	assume $decr0$0_$_1 == Set#Difference(AllVertices#8,Processed#16_$_0);
	assume true;
	assert  !(C#14_$_0 == (Set#Empty() : Set (BoxType) ));
	assume true;
	assume v#21_$_1 == Set#Choose(C#14_$_0,$Tick_$_0);
	assume true;
	assume true;
	assume true;
	assume true;
	assume $rhs#19_$_1 == Set#Difference(C#14_$_0,Set#UnionOne((Set#Empty() : Set (BoxType) ),v#21_$_1));
	assume true;
	assume $rhs#20_$_1 == Set#Union(Processed#16_$_0,Set#UnionOne((Set#Empty() : Set (BoxType) ),v#21_$_1));
	assume true;
	assume true;
	assert  BreadthFirstSearch.ValidMap($Heap_$_0,this,source#6,paths#17_$_0) && BreadthFirstSearch.Domain($Heap_$_0,this,paths#17_$_0)[v#21_$_1];
	assume BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,v#21_$_1,paths#17_$_0);
	assume BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,v#21_$_1,paths#17_$_0);
	assume pathToV#22_$_1 == BreadthFirstSearch.Find($Heap_$_0,this,source#6,v#21_$_1,paths#17_$_0);
	assume true;
	assume true;
	if ($_$_condition_$5) { goto anon62_Then; } else { goto anon62_Else; }
anon53_Then:
	assume Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8);
	if ($_$_condition_$6) { goto anon54_Then; } else { goto anon54_Else; }
anon53_Else:
	assume !(Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8));
	if ($_$_condition_$7) { goto anon54_Then; } else { goto anon54_Else; }
anon62_Then:
	assume v#21_$_1 == dest#7;
	if ($_$_condition_$9) { goto anon63_Then; } else { goto anon63_Else; }
anon62_Else:
	assume !(v#21_$_1 == dest#7);
	assume true;
	assume GenericAlloc(w#156_$_1,$Heap_$_0);
	assume BreadthFirstSearch.Succ#canCall($Heap_$_0,this,v#21_$_1);
	if ($_$_condition_$10) { goto anon65_Then; } else { goto anon65_Else; }
anon54_Then:
	assume (Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) && Set#Subset(C#14_$_0,AllVertices#8);
	goto anon8;
anon54_Else:
	assume !((Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) && Set#Subset(C#14_$_0,AllVertices#8));
	goto anon8;
anon68_Then:
	assume DtAlloc(nn#26_$_0,$Heap_$_0) && (DtType(nn#26_$_0) == class.Nat);
	assume true;
	assume true;
	assume BreadthFirstSearch.Value#canCall($Heap_$_0,this,nn#26_$_0);
	assume BreadthFirstSearch.Value#canCall($Heap_$_0,this,dd#18_$_1);
	assume BreadthFirstSearch.Value#canCall($Heap_$_0,this,nn#26_$_0) && BreadthFirstSearch.Value#canCall($Heap_$_0,this,dd#18_$_1);
	if ($_$_condition_$11) { goto anon69_Then; } else { goto anon69_Else; }
anon68_Else:
	assume (forall  nn#176 : DatatypeType :: ( ((DtAlloc(nn#176,$Heap_$_0) && (DtType(nn#176) == class.Nat)) && true) ==> (!BreadthFirstSearch.R($Heap_$_0,this,source#6,nn#176,AllVertices#8)[dest#7]) ));
	assume true;
	if ($_$_condition_$12) { goto anon70_Then; } else { goto anon70_Else; }
anon63_Then:
	assume (forall  $i#22 : Integer :: {Seq#Index(p#23_$_0,$i#22)} ( ((0 <= $i#22) && ($i#22 < Seq#Length(p#23_$_0))) ==> GenericAlloc(Seq#Index(p#23_$_0,$i#22),$Heap_$_0) ));
	assume BreadthFirstSearch.IsPath#canCall($Heap_$_0,this,source#6,dest#7,p#23_$_0);
	assume BreadthFirstSearch.IsPath#canCall($Heap_$_0,this,source#6,dest#7,p#23_$_0);
	assume BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,dest#7,p#23_$_0);
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (forall<alpha> $o_$40 : ref, $f_$40 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$40,$f_$40] ));
	assert  BreadthFirstSearch.IsPath#canCall($Heap_$_0,this,source#6,dest#7,p#23_$_0) ==> (BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,dest#7,p#23_$_0) || (if (source#6 == dest#7) then Seq#Equal(p#23_$_0,(Seq#Empty() : Seq (BoxType) )) else (((!Seq#Equal(p#23_$_0,(Seq#Empty() : Seq (BoxType) ))) && BreadthFirstSearch.Succ($Heap_$_0,this,Seq#Index(p#23_$_0,Seq#Length(p#23_$_0) - 1))[dest#7]) && BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,Seq#Index(p#23_$_0,Seq#Length(p#23_$_0) - 1),Seq#Take(p#23_$_0,Seq#Length(p#23_$_0) - 1)))));
	assert  AllVertices#8[source#6];
	assert  BreadthFirstSearch.IsClosed#canCall($Heap_$_0,this,AllVertices#8) ==> (BreadthFirstSearch.IsClosed($Heap_$_0,this,AllVertices#8) || ((forall  v#5_$3 : BoxType :: ( GenericAlloc(v#5_$3,$Heap_$_0) ==> (AllVertices#8[v#5_$3] ==> Set#Subset(BreadthFirstSearch.Succ($Heap_$_0,this,v#5_$3),AllVertices#8)) ))));
	assume $IsGoodHeap($Heap_$_2);
	assume BreadthFirstSearch.R#2($Heap_$_2,this,source#6,BreadthFirstSearch.ToNat#2($Heap_$_2,this,Seq#Length(p#23_$_0)),AllVertices#8)[dest#7];
	assume (forall<alpha> $o_$41 : ref, $f_$41 : Field (alpha)  :: {read($Heap_$_2,$o_$41,$f_$41)} ( ((!($o_$41 == null)) && read($Heap_$_0,$o_$41,alloc)) ==> (read($Heap_$_2,$o_$41,$f_$41) == read($Heap_$_0,$o_$41,$f_$41)) ));
	assume $HeapSucc($Heap_$_0,$Heap_$_2);
	assume true;
	assume true;
	if ($_$_condition_$13) { goto anon64_Then; } else { goto anon64_Else; }
anon63_Else:
	assume (forall  p#152 : Seq (BoxType)  :: ( (((forall  $i#23 : Integer :: {Seq#Index(p#152,$i#23)} ( ((0 <= $i#23) && ($i#23 < Seq#Length(p#152))) ==> GenericAlloc(Seq#Index(p#152,$i#23),$Heap_$_0) ))) && BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,dest#7,p#152)) ==> (Seq#Length(pathToV#22_$_1) <= Seq#Length(p#152)) ));
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume d#9_$_3 == d#9_$_0;
	assume $Heap_$_9 == $Heap_$_0;
	assume path#10_$_0 == pathToV#22_$_1;
	goto GeneratedUnifiedExit;
anon65_Then:
	assume BreadthFirstSearch.Succ($Heap_$_0,this,v#21_$_1)[w#156_$_1];
	if ($_$_condition_$14) { goto anon66_Then; } else { goto anon66_Else; }
anon65_Else:
	assume !BreadthFirstSearch.Succ($Heap_$_0,this,v#21_$_1)[w#156_$_1];
	if ($_$_condition_$15) { goto anon66_Then; } else { goto anon66_Else; }
anon8:
	assume ((Set#Subset(V#13_$_0,AllVertices#8) ==> true) && ((Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) ==> true)) && (((Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) && Set#Subset(C#14_$_0,AllVertices#8)) ==> true);
	assume ((Set#Subset(V#13_$_0,AllVertices#8) && Set#Subset(Processed#16_$_0,AllVertices#8)) && Set#Subset(C#14_$_0,AllVertices#8)) && Set#Subset(N#15_$_0,AllVertices#8);
	assume true;
	assume V#13_$_0[source#6];
	assume true;
	assume Set#Equal(V#13_$_0,Set#Union(Set#Union(Processed#16_$_0,C#14_$_0),N#15_$_0));
	if ($_$_condition_$16) { goto anon55_Then; } else { goto anon55_Else; }
anon69_Then:
	assume BreadthFirstSearch.Value($Heap_$_0,this,nn#26_$_0) < BreadthFirstSearch.Value($Heap_$_0,this,dd#18_$_1);
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (forall<alpha> $o_$42 : ref, $f_$42 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$42,$f_$42] ));
	assert  BreadthFirstSearch.Value#2($Heap_$_0,this,nn#26_$_0) <= BreadthFirstSearch.Value#2($Heap_$_0,this,dd#18_$_1);
	assume $IsGoodHeap($Heap_$_6);
	assume Set#Subset(BreadthFirstSearch.R#2($Heap_$_6,this,source#6,nn#26_$_0,AllVertices#8),BreadthFirstSearch.R#2($Heap_$_6,this,source#6,dd#18_$_1,AllVertices#8));
	assume (forall<alpha> $o_$43 : ref, $f_$43 : Field (alpha)  :: {read($Heap_$_6,$o_$43,$f_$43)} ( ((!($o_$43 == null)) && read($Heap_$_0,$o_$43,alloc)) ==> (read($Heap_$_6,$o_$43,$f_$43) == read($Heap_$_0,$o_$43,$f_$43)) ));
	assume $HeapSucc($Heap_$_0,$Heap_$_6);
	assume true;
	assume $Heap_$_8 == $Heap_$_6;
	goto anon44;
anon69_Else:
	assume BreadthFirstSearch.Value($Heap_$_0,this,dd#18_$_1) <= BreadthFirstSearch.Value($Heap_$_0,this,nn#26_$_0);
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (forall<alpha> $o_$44 : ref, $f_$44 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$44,$f_$44] ));
	assert  Set#Equal(BreadthFirstSearch.R#2($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8),BreadthFirstSearch.R#2($Heap_$_0,this,source#6,#Nat.Suc(dd#18_$_1),AllVertices#8));
	assert  BreadthFirstSearch.Value#2($Heap_$_0,this,dd#18_$_1) <= BreadthFirstSearch.Value#2($Heap_$_0,this,nn#26_$_0);
	assume $IsGoodHeap($Heap_$_7);
	assume Set#Equal(BreadthFirstSearch.R#2($Heap_$_7,this,source#6,dd#18_$_1,AllVertices#8),BreadthFirstSearch.R#2($Heap_$_7,this,source#6,nn#26_$_0,AllVertices#8));
	assume (forall<alpha> $o_$45 : ref, $f_$45 : Field (alpha)  :: {read($Heap_$_7,$o_$45,$f_$45)} ( ((!($o_$45 == null)) && read($Heap_$_0,$o_$45,alloc)) ==> (read($Heap_$_7,$o_$45,$f_$45) == read($Heap_$_0,$o_$45,$f_$45)) ));
	assume $HeapSucc($Heap_$_0,$Heap_$_7);
	assume true;
	assume $Heap_$_8 == $Heap_$_7;
	goto anon44;
anon70_Then:
	assume (forall  $i#35 : Integer :: {Seq#Index(p#27_$_0,$i#35)} ( ((0 <= $i#35) && ($i#35 < Seq#Length(p#27_$_0))) ==> GenericAlloc(Seq#Index(p#27_$_0,$i#35),$Heap_$_0) ));
	assume BreadthFirstSearch.IsPath#canCall($Heap_$_0,this,source#6,dest#7,p#27_$_0);
	assume BreadthFirstSearch.IsPath#canCall($Heap_$_0,this,source#6,dest#7,p#27_$_0);
	assume BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,dest#7,p#27_$_0);
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (forall<alpha> $o_$46 : ref, $f_$46 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$46,$f_$46] ));
	assert  BreadthFirstSearch.IsPath#canCall($Heap_$_0,this,source#6,dest#7,p#27_$_0) ==> (BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,dest#7,p#27_$_0) || (if (source#6 == dest#7) then Seq#Equal(p#27_$_0,(Seq#Empty() : Seq (BoxType) )) else (((!Seq#Equal(p#27_$_0,(Seq#Empty() : Seq (BoxType) ))) && BreadthFirstSearch.Succ($Heap_$_0,this,Seq#Index(p#27_$_0,Seq#Length(p#27_$_0) - 1))[dest#7]) && BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,Seq#Index(p#27_$_0,Seq#Length(p#27_$_0) - 1),Seq#Take(p#27_$_0,Seq#Length(p#27_$_0) - 1)))));
	assert  AllVertices#8[source#6];
	assert  BreadthFirstSearch.IsClosed#canCall($Heap_$_0,this,AllVertices#8) ==> (BreadthFirstSearch.IsClosed($Heap_$_0,this,AllVertices#8) || ((forall  v#5_$4 : BoxType :: ( GenericAlloc(v#5_$4,$Heap_$_0) ==> (AllVertices#8[v#5_$4] ==> Set#Subset(BreadthFirstSearch.Succ($Heap_$_0,this,v#5_$4),AllVertices#8)) ))));
	assume $IsGoodHeap($Heap_$_5);
	assume BreadthFirstSearch.R#2($Heap_$_5,this,source#6,BreadthFirstSearch.ToNat#2($Heap_$_5,this,Seq#Length(p#27_$_0)),AllVertices#8)[dest#7];
	assume (forall<alpha> $o_$47 : ref, $f_$47 : Field (alpha)  :: {read($Heap_$_5,$o_$47,$f_$47)} ( ((!($o_$47 == null)) && read($Heap_$_0,$o_$47,alloc)) ==> (read($Heap_$_5,$o_$47,$f_$47) == read($Heap_$_0,$o_$47,$f_$47)) ));
	assume $HeapSucc($Heap_$_0,$Heap_$_5);
	assume true;
	assume true;
	assert  false;
	assume false;
	assume BreadthFirstSearch.IsPath#canCall($Heap_$_5,this,source#6,dest#7,p#184a);
	assume BreadthFirstSearch.IsPath#canCall($Heap_$_5,this,source#6,dest#7,p#184a);
	assume d#9_$_3 == d#9_$_0;
	assume $Heap_$_9 == $Heap_$_5;
	assume path#10_$_0 == path#10;
	goto $exit;
anon70_Else:
	assume (forall  p#184 : Seq (BoxType)  :: ( (((forall  $i#36 : Integer :: {Seq#Index(p#184,$i#36)} ( ((0 <= $i#36) && ($i#36 < Seq#Length(p#184))) ==> GenericAlloc(Seq#Index(p#184,$i#36),$Heap_$_0) ))) && BreadthFirstSearch.IsPath($Heap_$_0,this,source#6,dest#7,p#184)) ==> false ));
	assume true;
	assume true;
	assume true;
	assume d#9_$_2 == (0 - 1);
	assume true;
	assume d#9_$_3 == d#9_$_2;
	assume $Heap_$_9 == $Heap_$_0;
	assume path#10_$_0 == path#10;
	goto GeneratedUnifiedExit;
anon64_Then:
	assume Seq#Length(p#23_$_0) < Seq#Length(pathToV#22_$_1);
	assume true;
	assert  0 <= Seq#Length(p#23_$_0);
	assume n#146_$_0 == Seq#Length(p#23_$_0);
	assert  (forall<alpha> $o_$48 : ref, $f_$48 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$48,$f_$48] ));
	assume $IsGoodHeap($Heap_$_3);
	assume BreadthFirstSearch.Value#2($Heap_$_3,this,BreadthFirstSearch.ToNat#2($Heap_$_3,this,n#146_$_0)) == n#146_$_0;
	assume (forall<alpha> $o_$49 : ref, $f_$49 : Field (alpha)  :: {read($Heap_$_3,$o_$49,$f_$49)} ( ((!($o_$49 == null)) && read($Heap_$_2,$o_$49,alloc)) ==> (read($Heap_$_3,$o_$49,$f_$49) == read($Heap_$_2,$o_$49,$f_$49)) ));
	assume $HeapSucc($Heap_$_2,$Heap_$_3);
	assume true;
	assume true;
	assert  0 <= Seq#Length(p#23_$_0);
	assume n#149_$_0 == Seq#Length(p#23_$_0);
	assume BreadthFirstSearch.ToNat#canCall($Heap_$_3,this,Seq#Length(p#23_$_0));
	assume BreadthFirstSearch.ToNat#canCall($Heap_$_3,this,Seq#Length(p#23_$_0));
	assume mm#148_$_0 == BreadthFirstSearch.ToNat($Heap_$_3,this,Seq#Length(p#23_$_0));
	assume true;
	assume nn#150_$_0 == Nat.predecessor(dd#18_$_1);
	assume true;
	assert  (forall<alpha> $o_$50 : ref, $f_$50 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$50,$f_$50] ));
	assert  BreadthFirstSearch.Value#2($Heap_$_3,this,mm#148_$_0) <= BreadthFirstSearch.Value#2($Heap_$_3,this,nn#150_$_0);
	assume $IsGoodHeap($Heap_$_4);
	assume Set#Subset(BreadthFirstSearch.R#2($Heap_$_4,this,source#6,mm#148_$_0,AllVertices#8),BreadthFirstSearch.R#2($Heap_$_4,this,source#6,nn#150_$_0,AllVertices#8));
	assume (forall<alpha> $o_$51 : ref, $f_$51 : Field (alpha)  :: {read($Heap_$_4,$o_$51,$f_$51)} ( ((!($o_$51 == null)) && read($Heap_$_3,$o_$51,alloc)) ==> (read($Heap_$_4,$o_$51,$f_$51) == read($Heap_$_3,$o_$51,$f_$51)) ));
	assume $HeapSucc($Heap_$_3,$Heap_$_4);
	assume true;
	goto anon28;
anon64_Else:
	assume Seq#Length(pathToV#22_$_1) <= Seq#Length(p#23_$_0);
	goto anon28;
GeneratedUnifiedExit:
	assert  (0 <= d#9_$_3) ==> (BreadthFirstSearch.IsPath#canCall($Heap_$_9,this,source#6,dest#7,path#10_$_0) ==> (BreadthFirstSearch.IsPath($Heap_$_9,this,source#6,dest#7,path#10_$_0) || (if (source#6 == dest#7) then Seq#Equal(path#10_$_0,(Seq#Empty() : Seq (BoxType) )) else (((!Seq#Equal(path#10_$_0,(Seq#Empty() : Seq (BoxType) ))) && BreadthFirstSearch.Succ($Heap_$_9,this,Seq#Index(path#10_$_0,Seq#Length(path#10_$_0) - 1))[dest#7]) && BreadthFirstSearch.IsPath($Heap_$_9,this,source#6,Seq#Index(path#10_$_0,Seq#Length(path#10_$_0) - 1),Seq#Take(path#10_$_0,Seq#Length(path#10_$_0) - 1))))));
	assert  (0 <= d#9_$_3) ==> (Seq#Length(path#10_$_0) == d#9_$_3);
	assert  (0 <= d#9_$_3) ==> ((forall  p#11 : Seq (BoxType)  :: ( ((((forall  $i#4_$2 : Integer :: {Seq#Index(p#11,$i#4_$2)} ( ((0 <= $i#4_$2) && ($i#4_$2 < Seq#Length(p#11))) ==> GenericAlloc(Seq#Index(p#11,$i#4_$2),$Heap_$_9) ))) && ((forall  p$ih#2#108 : Seq (BoxType)  :: ( ((forall  $i#3_$1 : Integer :: {Seq#Index(p$ih#2#108,$i#3_$1)} ( ((0 <= $i#3_$1) && ($i#3_$1 < Seq#Length(p$ih#2#108))) ==> GenericAlloc(Seq#Index(p$ih#2#108,$i#3_$1),$Heap_$_9) ))) ==> ((Seq#Length(p$ih#2#108) < Seq#Length(p#11)) ==> (BreadthFirstSearch.IsPath($Heap_$_9,this,source#6,dest#7,p$ih#2#108) ==> (Seq#Length(path#10_$_0) <= Seq#Length(p$ih#2#108)))) )))) && true) ==> (BreadthFirstSearch.IsPath#2($Heap_$_9,this,source#6,dest#7,p#11) ==> (Seq#Length(path#10_$_0) <= Seq#Length(p#11))) )));
	assert  (d#9_$_3 < 0) ==> (!((exists  p#12 : Seq (BoxType)  :: ( ((((forall  $i#8_$0 : Integer :: {Seq#Index(p#12,$i#8_$0)} ( ((0 <= $i#8_$0) && ($i#8_$0 < Seq#Length(p#12))) ==> GenericAlloc(Seq#Index(p#12,$i#8_$0),$Heap_$_9) ))) && ((forall  p$ih#6#109 : Seq (BoxType)  :: ( ((forall  $i#7 : Integer :: {Seq#Index(p$ih#6#109,$i#7)} ( ((0 <= $i#7) && ($i#7 < Seq#Length(p$ih#6#109))) ==> GenericAlloc(Seq#Index(p$ih#6#109,$i#7),$Heap_$_9) ))) ==> ((Seq#Length(p$ih#6#109) < Seq#Length(p#12)) ==> (!BreadthFirstSearch.IsPath($Heap_$_9,this,source#6,dest#7,p$ih#6#109))) )))) && true) && BreadthFirstSearch.IsPath#2($Heap_$_9,this,source#6,dest#7,p#12) ))));
	goto $exit;
anon66_Then:
	assume BreadthFirstSearch.Succ($Heap_$_0,this,v#21_$_1)[w#156_$_1] && (!V#13_$_0[w#156_$_1]);
	goto anon36;
anon66_Else:
	assume !(BreadthFirstSearch.Succ($Heap_$_0,this,v#21_$_1)[w#156_$_1] && (!V#13_$_0[w#156_$_1]));
	goto anon36;
anon55_Then:
	assume Set#Disjoint(Processed#16_$_0,C#14_$_0);
	goto anon10;
anon55_Else:
	assume !Set#Disjoint(Processed#16_$_0,C#14_$_0);
	goto anon10;
anon44:
	assume BreadthFirstSearch.R#canCall($Heap_$_8,this,source#6,nn#26_$_0,AllVertices#8);
	assume BreadthFirstSearch.R#canCall($Heap_$_8,this,source#6,nn#26_$_0,AllVertices#8);
	assert  !BreadthFirstSearch.R#2($Heap_$_8,this,source#6,nn#26_$_0,AllVertices#8)[dest#7];
	assume false;
	assume true;
	assume d#9_$_3 == d#9_$_0;
	assume $Heap_$_9 == $Heap_$_8;
	assume path#10_$_0 == path#10;
	goto $exit;
anon28:
	assume true;
	assert  Seq#Length(pathToV#22_$_1) <= Seq#Length(p#23_$_0);
	assume false;
	assume BreadthFirstSearch.IsPath#canCall($Heap,this,source#6,dest#7,p#152a);
	assume BreadthFirstSearch.IsPath#canCall($Heap,this,source#6,dest#7,p#152a);
	assume d#9_$_3 == d#9_$_0;
	assume $Heap_$_9 == $Heap;
	assume path#10_$_0 == path#10;
	goto $exit;
anon36:
	assume (forall  w#25_$0 : BoxType :: ( GenericAlloc(w#25_$0,$Heap_$_0) ==> (BreadthFirstSearch.Succ#canCall($Heap_$_0,this,v#21_$_1) && (BreadthFirstSearch.Succ($Heap_$_0,this,v#21_$_1)[w#25_$0] ==> true)) ));
	assume newlyEncountered#24_$_1 == lambda#4(V#13_$_0,$Heap_$_0,this,v#21_$_1);
	assume true;
	assume true;
	assume true;
	assume true;
	assume $rhs#28_$_1 == Set#Union(V#13_$_0,newlyEncountered#24_$_1);
	assume true;
	assume $rhs#29_$_1 == Set#Union(N#15_$_0,newlyEncountered#24_$_1);
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (forall<alpha> $o_$52 : ref, $f_$52 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$52,$f_$52] ));
	assume DtAlloc(call8formal_$_newPaths#78,$Heap) && (DtType(call8formal_$_newPaths#78) == class.Map);
	assert  BreadthFirstSearch.ValidMap#2($Heap_$_0,this,source#6,paths#17_$_0);
	assert  Set#Disjoint(newlyEncountered#24_$_1,BreadthFirstSearch.Domain($Heap_$_0,this,paths#17_$_0));
	assert  (forall  succ#79 : BoxType :: ( GenericAlloc(succ#79,$Heap_$_0) ==> (newlyEncountered#24_$_1[succ#79] ==> BreadthFirstSearch.IsPath#2($Heap_$_0,this,source#6,succ#79,Seq#Append(pathToV#22_$_1,Seq#Build((Seq#Empty() : Seq (BoxType) ),v#21_$_1)))) ));
	assume $IsGoodHeap($Heap_$_1);
	assume DtAlloc(call8formal_$_newPaths#78_$_0,$Heap_$_1) && (DtType(call8formal_$_newPaths#78_$_0) == class.Map);
	assume BreadthFirstSearch.ValidMap#2($Heap_$_1,this,source#6,call8formal_$_newPaths#78_$_0);
	assume Set#Equal(BreadthFirstSearch.Domain($Heap_$_1,this,call8formal_$_newPaths#78_$_0),Set#Union(BreadthFirstSearch.Domain($Heap_$_1,this,paths#17_$_0),newlyEncountered#24_$_1));
	assume (forall  x#80 : BoxType :: ( GenericAlloc(x#80,$Heap_$_1) ==> (BreadthFirstSearch.Domain($Heap_$_1,this,paths#17_$_0)[x#80] ==> Seq#Equal(BreadthFirstSearch.Find#2($Heap_$_1,this,source#6,x#80,paths#17_$_0),BreadthFirstSearch.Find#2($Heap_$_1,this,source#6,x#80,call8formal_$_newPaths#78_$_0))) ));
	assume (forall  x#81 : BoxType :: ( GenericAlloc(x#81,$Heap_$_1) ==> (newlyEncountered#24_$_1[x#81] ==> Seq#Equal(BreadthFirstSearch.Find#2($Heap_$_1,this,source#6,x#81,call8formal_$_newPaths#78_$_0),Seq#Append(pathToV#22_$_1,Seq#Build((Seq#Empty() : Seq (BoxType) ),v#21_$_1)))) ));
	assume (forall<alpha> $o_$53 : ref, $f_$53 : Field (alpha)  :: {read($Heap_$_1,$o_$53,$f_$53)} ( ((!($o_$53 == null)) && read($Heap_$_0,$o_$53,alloc)) ==> (read($Heap_$_1,$o_$53,$f_$53) == read($Heap_$_0,$o_$53,$f_$53)) ));
	assume $HeapSucc($Heap_$_0,$Heap_$_1);
	assume true;
	assume true;
	if ($_$_condition_$17) { goto anon67_Then; } else { goto anon67_Else; }
anon10:
	assume Set#Disjoint(Processed#16_$_0,C#14_$_0) ==> true;
	assume Set#Disjoint(Processed#16_$_0,C#14_$_0) && Set#Disjoint(Set#Union(Processed#16_$_0,C#14_$_0),N#15_$_0);
	assume BreadthFirstSearch.ValidMap#canCall($Heap_$_0,this,source#6,paths#17_$_0);
	assume BreadthFirstSearch.ValidMap#canCall($Heap_$_0,this,source#6,paths#17_$_0);
	assume BreadthFirstSearch.ValidMap($Heap_$_0,this,source#6,paths#17_$_0);
	assume BreadthFirstSearch.Domain#canCall($Heap_$_0,this,paths#17_$_0);
	assume BreadthFirstSearch.Domain#canCall($Heap_$_0,this,paths#17_$_0);
	assume Set#Equal(V#13_$_0,BreadthFirstSearch.Domain($Heap_$_0,this,paths#17_$_0));
	assume GenericAlloc(x#113_$_0,$Heap_$_0);
	if ($_$_condition_$18) { goto anon56_Then; } else { goto anon56_Else; }
anon67_Then:
	assume Set#Equal($rhs#19_$_1,(Set#Empty() : Set (BoxType) ));
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume true;
	assume $rhs#32_$_1 == (Set#Empty() : Set (BoxType) );
	assume true;
	assume $rhs#33_$_1 == (d#9_$_0 + 1);
	assume true;
	assume $rhs#34_$_1 == #Nat.Suc(dd#18_$_1);
	assume true;
	assume C#14_$_1 == $rhs#29_$_1;
	assume N#15_$_1 == $rhs#32_$_1;
	assume d#9_$_1 == $rhs#33_$_1;
	assume dd#18_$_2 == $rhs#34_$_1;
	goto anon39;
anon67_Else:
	assume !Set#Equal($rhs#19_$_1,(Set#Empty() : Set (BoxType) ));
	assume C#14_$_1 == $rhs#19_$_1;
	assume N#15_$_1 == $rhs#29_$_1;
	assume d#9_$_1 == d#9_$_0;
	assume dd#18_$_2 == dd#18_$_1;
	goto anon39;
anon56_Then:
	assume C#14_$_0[x#113_$_0];
	assert  BreadthFirstSearch.ValidMap($Heap_$_0,this,source#6,paths#17_$_0) && BreadthFirstSearch.Domain($Heap_$_0,this,paths#17_$_0)[x#113_$_0];
	assume BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,x#113_$_0,paths#17_$_0);
	goto anon12;
anon56_Else:
	assume !C#14_$_0[x#113_$_0];
	goto anon12;
anon39:
	assert  Set#Subset(Set#Difference(AllVertices#8,$rhs#20_$_1),$decr0$0_$_1) && (!Set#Subset($decr0$0_$_1,Set#Difference(AllVertices#8,$rhs#20_$_1)));
	assume ((Set#Subset($rhs#28_$_1,AllVertices#8) ==> true) && ((Set#Subset($rhs#28_$_1,AllVertices#8) && Set#Subset($rhs#20_$_1,AllVertices#8)) ==> true)) && (((Set#Subset($rhs#28_$_1,AllVertices#8) && Set#Subset($rhs#20_$_1,AllVertices#8)) && Set#Subset(C#14_$_1,AllVertices#8)) ==> true);
	assume true;
	assume true;
	assume Set#Disjoint($rhs#20_$_1,C#14_$_1) ==> true;
	assume BreadthFirstSearch.ValidMap#canCall($Heap_$_1,this,source#6,call8formal_$_newPaths#78_$_0);
	assume BreadthFirstSearch.Domain#canCall($Heap_$_1,this,call8formal_$_newPaths#78_$_0);
	assume (forall  x#19_$2 : BoxType :: ( GenericAlloc(x#19_$2,$Heap_$_1) ==> (C#14_$_1[x#19_$2] ==> BreadthFirstSearch.Find#canCall($Heap_$_1,this,source#6,x#19_$2,call8formal_$_newPaths#78_$_0)) ));
	assume (forall  x#20_$2 : BoxType :: ( GenericAlloc(x#20_$2,$Heap_$_1) ==> (N#15_$_1[x#20_$2] ==> BreadthFirstSearch.Find#canCall($Heap_$_1,this,source#6,x#20_$2,call8formal_$_newPaths#78_$_0)) ));
	assume BreadthFirstSearch.R#canCall($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8) && (BreadthFirstSearch.R($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8)[dest#7] ==> true);
	assume (!(d#9_$_1 == 0)) ==> BreadthFirstSearch.R#canCall($Heap_$_1,this,source#6,Nat.predecessor(dd#18_$_2),AllVertices#8);
	assume BreadthFirstSearch.R#canCall($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8);
	assume BreadthFirstSearch.Successors#canCall($Heap_$_1,this,$rhs#20_$_1,AllVertices#8) && BreadthFirstSearch.R#canCall($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8);
	assume Set#Equal(C#14_$_1,(Set#Empty() : Set (BoxType) )) ==> true;
	assume BreadthFirstSearch.Value#canCall($Heap_$_1,this,dd#18_$_2);
	assert  $w0_$_0 ==> Set#Subset($rhs#28_$_1,AllVertices#8);
	assert  $w0_$_0 ==> Set#Subset($rhs#20_$_1,AllVertices#8);
	assert  $w0_$_0 ==> Set#Subset(C#14_$_1,AllVertices#8);
	assert  $w0_$_0 ==> Set#Subset(N#15_$_1,AllVertices#8);
	assert  $w0_$_0 ==> $rhs#28_$_1[source#6];
	assert  $w0_$_0 ==> Set#Equal($rhs#28_$_1,Set#Union(Set#Union($rhs#20_$_1,C#14_$_1),N#15_$_1));
	assert  $w0_$_0 ==> Set#Disjoint($rhs#20_$_1,C#14_$_1);
	assert  $w0_$_0 ==> Set#Disjoint(Set#Union($rhs#20_$_1,C#14_$_1),N#15_$_1);
	assert  $w0_$_0 ==> BreadthFirstSearch.ValidMap#2($Heap_$_1,this,source#6,call8formal_$_newPaths#78_$_0);
	assert  $w0_$_0 ==> Set#Equal($rhs#28_$_1,BreadthFirstSearch.Domain($Heap_$_1,this,call8formal_$_newPaths#78_$_0));
	assert  $w0_$_0 ==> ((forall  x#19_$3 : BoxType :: ( GenericAlloc(x#19_$3,$Heap_$_1) ==> (C#14_$_1[x#19_$3] ==> (Seq#Length(BreadthFirstSearch.Find#2($Heap_$_1,this,source#6,x#19_$3,call8formal_$_newPaths#78_$_0)) == d#9_$_1)) )));
	assert  $w0_$_0 ==> ((forall  x#20_$3 : BoxType :: ( GenericAlloc(x#20_$3,$Heap_$_1) ==> (N#15_$_1[x#20_$3] ==> (Seq#Length(BreadthFirstSearch.Find#2($Heap_$_1,this,source#6,x#20_$3,call8formal_$_newPaths#78_$_0)) == (d#9_$_1 + 1))) )));
	assert  $w0_$_0 ==> (BreadthFirstSearch.R($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8)[dest#7] ==> C#14_$_1[dest#7]);
	assert  $w0_$_0 ==> ((!(d#9_$_1 == 0)) ==> (!BreadthFirstSearch.R#2($Heap_$_1,this,source#6,Nat.predecessor(dd#18_$_2),AllVertices#8)[dest#7]));
	assert  $w0_$_0 ==> Set#Equal(Set#Union($rhs#20_$_1,C#14_$_1),BreadthFirstSearch.R#2($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8));
	assert  $w0_$_0 ==> Set#Equal(N#15_$_1,Set#Difference(BreadthFirstSearch.Successors($Heap_$_1,this,$rhs#20_$_1,AllVertices#8),BreadthFirstSearch.R#2($Heap_$_1,this,source#6,dd#18_$_2,AllVertices#8)));
	assert  $w0_$_0 ==> (Set#Equal(C#14_$_1,(Set#Empty() : Set (BoxType) )) ==> Set#Equal(N#15_$_1,(Set#Empty() : Set (BoxType) )));
	assert  $w0_$_0 ==> (BreadthFirstSearch.Value#2($Heap_$_1,this,dd#18_$_2) == d#9_$_1);
	assume false;
	assume d#9_$_3 == d#9_$_1;
	assume $Heap_$_9 == $Heap_$_1;
	assume path#10_$_0 == path#10;
	goto $exit;
anon12:
	assume (forall  x#19_$4 : BoxType :: ( GenericAlloc(x#19_$4,$Heap_$_0) ==> (C#14_$_0[x#19_$4] ==> BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,x#19_$4,paths#17_$_0)) ));
	assume (forall  x#19_$5 : BoxType :: ( GenericAlloc(x#19_$5,$Heap_$_0) ==> (C#14_$_0[x#19_$5] ==> (Seq#Length(BreadthFirstSearch.Find($Heap_$_0,this,source#6,x#19_$5,paths#17_$_0)) == d#9_$_0)) ));
	assume GenericAlloc(x#117_$_0,$Heap_$_0);
	if ($_$_condition_$19) { goto anon57_Then; } else { goto anon57_Else; }
anon57_Then:
	assume N#15_$_0[x#117_$_0];
	assert  BreadthFirstSearch.ValidMap($Heap_$_0,this,source#6,paths#17_$_0) && BreadthFirstSearch.Domain($Heap_$_0,this,paths#17_$_0)[x#117_$_0];
	assume BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,x#117_$_0,paths#17_$_0);
	goto anon14;
anon57_Else:
	assume !N#15_$_0[x#117_$_0];
	goto anon14;
anon14:
	assume (forall  x#20_$4 : BoxType :: ( GenericAlloc(x#20_$4,$Heap_$_0) ==> (N#15_$_0[x#20_$4] ==> BreadthFirstSearch.Find#canCall($Heap_$_0,this,source#6,x#20_$4,paths#17_$_0)) ));
	assume (forall  x#20_$5 : BoxType :: ( GenericAlloc(x#20_$5,$Heap_$_0) ==> (N#15_$_0[x#20_$5] ==> (Seq#Length(BreadthFirstSearch.Find($Heap_$_0,this,source#6,x#20_$5,paths#17_$_0)) == (d#9_$_0 + 1))) ));
	assume BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8);
	if ($_$_condition_$20) { goto anon58_Then; } else { goto anon58_Else; }
anon58_Then:
	assume BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)[dest#7];
	goto anon16;
anon58_Else:
	assume !BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)[dest#7];
	goto anon16;
anon16:
	assume BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8) && (BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)[dest#7] ==> true);
	assume BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)[dest#7] ==> C#14_$_0[dest#7];
	if ($_$_condition_$21) { goto anon59_Then; } else { goto anon59_Else; }
anon59_Then:
	assume !(d#9_$_0 == 0);
	assume nn#125_$_0 == Nat.predecessor(dd#18_$_1);
	assume BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,Nat.predecessor(dd#18_$_1),AllVertices#8);
	goto anon18;
anon59_Else:
	assume d#9_$_0 == 0;
	goto anon18;
anon18:
	assume (!(d#9_$_0 == 0)) ==> BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,Nat.predecessor(dd#18_$_1),AllVertices#8);
	assume (!(d#9_$_0 == 0)) ==> (!BreadthFirstSearch.R($Heap_$_0,this,source#6,Nat.predecessor(dd#18_$_1),AllVertices#8)[dest#7]);
	assume BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8);
	assume BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8);
	assume Set#Equal(Set#Union(Processed#16_$_0,C#14_$_0),BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8));
	assume BreadthFirstSearch.Successors#canCall($Heap_$_0,this,Processed#16_$_0,AllVertices#8);
	assume BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8);
	assume BreadthFirstSearch.Successors#canCall($Heap_$_0,this,Processed#16_$_0,AllVertices#8) && BreadthFirstSearch.R#canCall($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8);
	assume Set#Equal(N#15_$_0,Set#Difference(BreadthFirstSearch.Successors($Heap_$_0,this,Processed#16_$_0,AllVertices#8),BreadthFirstSearch.R($Heap_$_0,this,source#6,dd#18_$_1,AllVertices#8)));
	if ($_$_condition_$22) { goto anon60_Then; } else { goto anon60_Else; }
anon60_Then:
	assume Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) ));
	goto anon20;
anon60_Else:
	assume !Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) ));
	goto anon20;
anon20:
	assume Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) )) ==> true;
	assume Set#Equal(C#14_$_0,(Set#Empty() : Set (BoxType) )) ==> Set#Equal(N#15_$_0,(Set#Empty() : Set (BoxType) ));
	assume BreadthFirstSearch.Value#canCall($Heap_$_0,this,dd#18_$_1);
	assume BreadthFirstSearch.Value#canCall($Heap_$_0,this,dd#18_$_1);
	assume BreadthFirstSearch.Value($Heap_$_0,this,dd#18_$_1) == d#9_$_0;
	assume true;
	assume false;
	assume d#9_$_3 == d#9_$_0;
	assume $Heap_$_9 == $Heap_$_0;
	assume path#10_$_0 == path#10;
	goto $exit;
}
