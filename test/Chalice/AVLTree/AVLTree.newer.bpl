
// Copyright (c) 2008, Microsoft

type Field a;
type HeapType = <a>[ref,Field a]a;
type MaskType = <a>[ref,Field a][PermissionComponent]real;
type PMaskType = <a>[ref,Field a]bool;
type RefSet = [ref]bool;
type CreditsType = [ref]int;
type ref;
const null: ref;

var Heap: HeapType;

type PermissionComponent;
const unique perm$R: PermissionComponent;
const unique perm$N: PermissionComponent;
var Mask: MaskType where IsGoodMask(Mask);
var SecMask: MaskType where IsGoodMask(SecMask);
const Permission$denominator: real;
axiom Permission$denominator == 1.0;
const Permission$FullFraction: real;
const Permission$Zero: [PermissionComponent]real;
axiom Permission$Zero[perm$R] == 0.0 && Permission$Zero[perm$N] == 0.0;
const Permission$Full: [PermissionComponent]real;
axiom Permission$Full[perm$R] == Permission$FullFraction && Permission$Full[perm$N] == 0.0;
const ZeroMask: MaskType;
axiom (forall<T> o: ref, f: Field T, pc: PermissionComponent :: ZeroMask[o,f][pc] == 0.0);
const ZeroPMask: PMaskType;
axiom (forall<T> o: ref, f: Field T :: ZeroPMask[o,f] == false);
axiom IsGoodMask(ZeroMask);
const ZeroRefSet: RefSet;
axiom (forall o:ref :: {ZeroRefSet[o]} ZeroRefSet[o] == false);
const unique joinable: Field int;
axiom NonPredicateField(joinable);
const unique token#t: TypeName;
const unique forkK: Field real;
axiom NonPredicateField(forkK);
const channelK: real;
const monitorK: real;
const predicateK: real;

axiom Permission$FullFraction  == 1.0;
axiom 0.0 < channelK && 1000.0*channelK < 0.01;
axiom 0.0 < monitorK && 1000.0*monitorK < 0.01;
axiom 0.0 < predicateK && 1000.0*predicateK < 0.01;
axiom predicateK == channelK && channelK == monitorK;

function NonEmptyMask(m: MaskType) returns (bool);

// this is currently more restrictive than needed, but we need to be sure that an amount has been left behind that is not infinitely subtractable (e.g., a rd* permission) for soundness.
// See also the version below in PercentageFunctionPL
axiom (forall m: MaskType :: {NonEmptyMask(m)} (forall<T> m1: MaskType, o: ref, f: Field T :: {NonPredicateField(f), m1[o, f]} NonPredicateField(f) && m[o, f][perm$R]>=0.01 ==> NonEmptyMask(m)));


var Credits: CreditsType;

function combine(PartialHeapType, PartialHeapType) returns (PartialHeapType);
function heapFragment<T>(T) returns (PartialHeapType);
type PartialHeapType;
const emptyPartialHeap: PartialHeapType;

type ModuleName;
const CurrentModule: ModuleName;
type TypeName;
function dtype(ref) returns (TypeName);
const CanAssumeFunctionDefs: bool;
const FunctionContextHeight: int;

type Mu;
const unique mu: Field Mu;
axiom NonPredicateField(mu);
function MuBelow(Mu, Mu) returns (bool);  // strict partial order
axiom (forall m: Mu, n: Mu ::
  { MuBelow(m,n), MuBelow(n,m) }
  !(MuBelow(m,n) && MuBelow(n,m)));
axiom (forall m: Mu, n: Mu, o: Mu ::
  { MuBelow(m,n), MuBelow(n,o) }
  MuBelow(m,n) && MuBelow(n,o) ==> MuBelow(m,o));
const $LockBottom: Mu;
axiom (forall m, n: Mu :: MuBelow(m, n) ==> n != $LockBottom);

const unique held: Field int;
function Acquire$Heap(int) returns (HeapType);
function Acquire$Mask(int) returns (MaskType);
function Acquire$SecMask(int) returns (MaskType);
function Acquire$Credits(int) returns (CreditsType);
axiom NonPredicateField(held);

function LastSeen$Heap(Mu, int) returns (HeapType);
function LastSeen$Mask(Mu, int) returns (MaskType);
function LastSeen$SecMask(Mu, int) returns (MaskType);
function LastSeen$Credits(Mu, int) returns (CreditsType);

const unique rdheld: Field bool;
axiom NonPredicateField(rdheld);
function wf(h: HeapType, m: MaskType, sm: MaskType) returns (bool);

function IsGoodInhaleState(ih: HeapType, h: HeapType,
                           m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { ih[o, f] }  CanRead(m, o, f) ==> ih[o, f] == h[o, f]) &&
  (forall o: ref :: { ih[o, held] }  (0<ih[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { ih[o, rdheld] }  ih[o, rdheld] == h[o, rdheld]) &&
  (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> ih[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, rdheld] }  h[o, rdheld] ==> ih[o, mu] == h[o, mu])
}
function IsGoodExhalePredicateState(eh: HeapType, h: HeapType, pm: PMaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { eh[o, f] }  pm[o, f] ==> eh[o, f] == h[o, f])
}
function predicateMaskField<T>(f: Field T): Field PMaskType;
function IsGoodExhaleState(eh: HeapType, h: HeapType,
                           m: MaskType, holdsExhaled: RefSet) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { eh[o, f] }  CanRead(m, o, f) ==> eh[o, f] == h[o, f]) &&
  (forall o: ref :: { eh[o, held] }  (0<eh[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { eh[o, rdheld] }  eh[o, rdheld] == h[o, rdheld]) &&
  (holdsExhaled!=ZeroRefSet ==> (forall o: ref :: { h[o, held] }  (!holdsExhaled[o] && 0<h[o, held]) ==> eh[o, mu] == h[o, mu]) &&
              (forall o: ref :: { h[o, rdheld] }  (!holdsExhaled[o] && h[o, rdheld]) ==> eh[o, mu] == h[o, mu])  ) &&
  (holdsExhaled==ZeroRefSet ==> (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> eh[o, mu] == h[o, mu]) &&
              (forall o: ref :: { h[o, rdheld] }  (h[o, rdheld]) ==> eh[o, mu] == h[o, mu])  ) &&
  (forall o: ref :: { h[o, forkK] } { eh[o, forkK] } h[o, forkK] == eh[o, forkK]) &&
  (forall o: ref :: { h[o, held] } { eh[o, held] } h[o, held] == eh[o, held]) &&
  (forall o: ref, f: Field int :: { eh[o, f], PredicateField(f) } PredicateField(f) ==> h[o, f] <= eh[o, f]) &&
  (forall o: ref, f: Field int :: { h[o, predicateMaskField(f)], PredicateField(f) } { eh[o, predicateMaskField(f)], PredicateField(f) } { m[o, predicateMaskField(f)], PredicateField(f) } { #AVLTreeNode.valid#trigger(o), PredicateField(f) } { #AVLTree.valid#trigger(o), PredicateField(f) } PredicateField(f) && CanRead(m, o, f) ==>
      (forall<T> o2: ref, f2: Field T :: { h[o2, f2] } { eh[o2, f2] } { m[o2, f2] }  h[o, predicateMaskField(f)][o2, f2] ==> eh[o2, f2] == h[o2, f2])) &&
  (forall o: ref, f: Field int :: { PredicateField(f), eh[o, predicateMaskField(f)] } PredicateField(f) && CanRead(m, o, f) ==> eh[o, predicateMaskField(f)] == h[o, predicateMaskField(f)])
}
      

// ---------------------------------------------------------------
// -- Permissions ------------------------------------------------
// ---------------------------------------------------------------

function {:expand false} CanRead<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  0.0 < m[obj,f][perm$R] || 0.0 < m[obj,f][perm$N]
}
function {:expand false} CanReadForSure<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  0.0 < m[obj,f][perm$R] || 0.0 < m[obj,f][perm$N]
}
function {:expand false} CanWrite<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  m[obj,f][perm$R] == Permission$FullFraction && m[obj,f][perm$N] == 0.0
}
function {:expand true} IsGoodMask(m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T ::
      0.0 <= m[o,f][perm$R] && 
      (NonPredicateField(f) ==> 
        (m[o,f][perm$R]<=Permission$FullFraction &&
        (0.0 < m[o,f][perm$N] ==> m[o,f][perm$R] < Permission$FullFraction))) &&
      (m[o,f][perm$N] < 0.0 ==> 0.0 < m[o,f][perm$R]))
}

axiom (forall h: HeapType, m, sm: MaskType, o: ref, q: ref :: {wf(h, m, sm), h[o, mu], h[q, mu]} wf(h, m, sm) && o!=q && (0 < h[o, held] || h[o, rdheld]) && (0 < h[q, held] || h[q, rdheld]) ==> h[o, mu] != h[q, mu]);

function DecPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: real) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: real, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$R]}
      DecPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] - howMuch, m[q, g][perm$R])
);

function DecEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: real) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: real, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$N]}
         DecEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] - howMuch, m[q, g][perm$N])
);

function IncPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: real) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: real, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$R]}
         IncPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] + howMuch, m[q, g][perm$R])
);

function IncEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: real) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: real, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$N]}
         IncEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] + howMuch, m[q, g][perm$N])
);

function Havocing<T,U>(h: HeapType, o: ref, f: Field T, newValue: U) returns (HeapType);

axiom (forall<T,U> h: HeapType, o: ref, f: Field T, newValue: U, q: ref, g: Field U :: {Havocing(h, o, f, newValue)[q, g]}
         Havocing(h, o, f, newValue)[q, g] == ite(o==q && f ==g, newValue, h[q, g])
);

function Call$Heap(int) returns (HeapType);
function Call$Mask(int) returns (MaskType);
function Call$SecMask(int) returns (MaskType);
function Call$Credits(int) returns (CreditsType);
function Call$Args(int) returns (ArgSeq);
type ArgSeq = <T>[int]T;


const ZeroCredits: CreditsType;
axiom (forall o: ref :: ZeroCredits[o] == 0);
function EmptyCredits(c: CreditsType) returns (bool);
axiom (forall c: CreditsType :: {EmptyCredits(c)} EmptyCredits(c) <==> (forall o: ref :: o != null ==> c[o] == 0));

function NonPredicateField<T>(f: Field T) returns (bool);
function PredicateField<T>(f: Field T) returns (bool);
axiom (forall<T> f: Field T :: NonPredicateField(f) ==> ! PredicateField(f));
axiom (forall<T> f: Field T :: PredicateField(f) ==> ! NonPredicateField(f));

// function for recording enclosure of one predicate instance in another
function #predicateInside#(x:ref, p: Field (int), v:int, y:ref, q:Field (int), w : int) returns (bool);

// transitivity for #predicateInside#
axiom (forall x:ref, p: Field (int), v:int, y:ref, q:Field (int), w : int, z:ref, r:Field(int),u:int :: {#predicateInside#(x,p,v,y,q,w), #predicateInside#(y,q,w,z,r,u)} #predicateInside#(x,p,v,y,q,w) && #predicateInside#(y,q,w,z,r,u) ==> #predicateInside#(x,p,v,z,r,u));

// knowledge that two identical instances of the same predicate cannot be inside each other
axiom (forall x:ref, p: Field (int), v:int, y:ref, w:int :: {#predicateInside#(x,p,v,y,p,w)} #predicateInside#(x,p,v,y,p,w) ==> x!=y);


function submask(m1: MaskType, m2: MaskType) returns (bool);

axiom (forall m1: MaskType, m2: MaskType :: {submask(m1, m2)}
  submask(m1, m2) <==> (forall<T> o: ref, f: Field T :: (m1[o, f][perm$R] < m2[o, f][perm$R]) || (m1[o, f][perm$R] == m2[o, f][perm$R] && m1[o, f][perm$N] <= m2[o, f][perm$N]))
);

// ---------------------------------------------------------------
// -- If thn else -----------------------------------------------
// ---------------------------------------------------------------

function ite<T>(bool, T, T) returns (T);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} con ==> ite(con, a, b) == a);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} ! con ==> ite(con, a, b) == b);

// ---------------------------------------------------------------
// -- Strings ----------------------------------------------------
// ---------------------------------------------------------------

type string = int;

// ---------------------------------------------------------------
// -- Axiomatization of sequences --------------------------------
// ---------------------------------------------------------------

type Seq T;

function Seq#Length<T>(Seq T) returns (int);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } 0 <= Seq#Length(s));

function Seq#Empty<T>() returns (Seq T);
axiom (forall<T> :: Seq#Length(Seq#Empty(): Seq T) == 0);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } Seq#Length(s) == 0 ==> s == Seq#Empty());

function Seq#Singleton<T>(T) returns (Seq T);
axiom (forall<T> t: T :: { Seq#Length(Seq#Singleton(t)) } Seq#Length(Seq#Singleton(t)) == 1);

function Seq#Build<T>(s: Seq T, index: int, val: T, newLength: int) returns (Seq T);
axiom (forall<T> s: Seq T, i: int, v: T, len: int :: { Seq#Length(Seq#Build(s,i,v,len)) }
  0 <= len ==> Seq#Length(Seq#Build(s,i,v,len)) == len);

function Seq#Append<T>(Seq T, Seq T) returns (Seq T);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Length(Seq#Append(s0,s1)) }
  Seq#Length(Seq#Append(s0,s1)) == Seq#Length(s0) + Seq#Length(s1));

function Seq#Index<T>(Seq T, int) returns (T);
axiom (forall<T> t: T :: { Seq#Index(Seq#Singleton(t), 0) } Seq#Index(Seq#Singleton(t), 0) == t);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#Index(Seq#Append(s0,s1), n) }
  (n < Seq#Length(s0) ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s0, n)) &&
  (Seq#Length(s0) <= n ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s1, n - Seq#Length(s0))));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, n: int :: { Seq#Index(Seq#Build(s,i,v,len),n) }
  0 <= n && n < len ==>
    (i == n ==> Seq#Index(Seq#Build(s,i,v,len),n) == v) &&
    (i != n ==> Seq#Index(Seq#Build(s,i,v,len),n) == Seq#Index(s,n)));

function Seq#Contains<T>(Seq T, T) returns (bool);
axiom (forall<T> s: Seq T, x: T :: { Seq#Contains(s,x) }
  Seq#Contains(s,x) <==>
    (exists i: int :: { Seq#Index(s,i) } 0 <= i && i < Seq#Length(s) && Seq#Index(s,i) == x));
axiom (forall x: ref ::
  { Seq#Contains(Seq#Empty(), x) }
  !Seq#Contains(Seq#Empty(), x));
axiom (forall<T> s0: Seq T, s1: Seq T, x: T ::
  { Seq#Contains(Seq#Append(s0, s1), x) }
  Seq#Contains(Seq#Append(s0, s1), x) <==>
    Seq#Contains(s0, x) || Seq#Contains(s1, x));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, x: T ::
  { Seq#Contains(Seq#Build(s, i, v, len), x) }
  Seq#Contains(Seq#Build(s, i, v, len), x) <==>
    (0 <= i && i < len && x == v)  ||  
    (exists j: int :: { Seq#Index(s,j) } 0 <= j && j < Seq#Length(s) && j < len && j!=i && Seq#Index(s,j) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Take(s, n), x) }
  Seq#Contains(Seq#Take(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= i && i < n && i < Seq#Length(s) && Seq#Index(s, i) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Drop(s, n), x) }
  Seq#Contains(Seq#Drop(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= n && n <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

function Seq#Equal<T>(Seq T, Seq T) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Equal(s0,s1) }
  Seq#Equal(s0,s1) <==>
    Seq#Length(s0) == Seq#Length(s1) &&
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < Seq#Length(s0) ==> Seq#Index(s0,j) == Seq#Index(s1,j)));
axiom(forall<T> a: Seq T, b: Seq T :: { Seq#Equal(a,b) }  // extensionality axiom for sequences
  Seq#Equal(a,b) ==> a == b);

function Seq#SameUntil<T>(Seq T, Seq T, int) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#SameUntil(s0,s1,n) }
  Seq#SameUntil(s0,s1,n) <==>
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < n ==> Seq#Index(s0,j) == Seq#Index(s1,j)));

function Seq#Take<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Take(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Take(s,n)) == n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Take(s,n)) == Seq#Length(s)));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Take(s,n), j) } {:weight 25}
  0 <= j && j < n && j < Seq#Length(s) ==>
    Seq#Index(Seq#Take(s,n), j) == Seq#Index(s, j));

function Seq#Drop<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Drop(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Drop(s,n)) == Seq#Length(s) - n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Drop(s,n)) == 0));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Drop(s,n), j) } {:weight 25}
  0 <= n && 0 <= j && j < Seq#Length(s)-n ==>
    Seq#Index(Seq#Drop(s,n), j) == Seq#Index(s, j+n));

axiom (forall<T> s, t: Seq T ::
  { Seq#Append(s, t) }
  Seq#Take(Seq#Append(s, t), Seq#Length(s)) == s &&
  Seq#Drop(Seq#Append(s, t), Seq#Length(s)) == t);

function Seq#Range(min: int, max: int) returns (Seq int);

axiom (forall min: int, max: int :: { Seq#Length(Seq#Range(min, max)) } (min < max ==> Seq#Length(Seq#Range(min, max)) == max-min) && (max <= min ==> Seq#Length(Seq#Range(min, max)) == 0));
axiom (forall min: int, max: int, j: int :: { Seq#Index(Seq#Range(min, max), j) } 0<=j && j<max-min ==> Seq#Index(Seq#Range(min, max), j) == min + j);

axiom (forall<T> x, y: T ::
  { Seq#Contains(Seq#Singleton(x),y) }
    Seq#Contains(Seq#Singleton(x),y) <==> x==y);

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

const unique AVLTree#t: TypeName;
const unique module#default: ModuleName;
procedure AVLTree$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_9: real;
  var h0#_0: HeapType;
  var m0#_1: MaskType;
  var sm0#_2: MaskType;
  var c0#_3: CreditsType;
  var h1#_4: HeapType;
  var m1#_5: MaskType;
  var sm1#_6: MaskType;
  var c1#_7: CreditsType;
  var lk#_8: ref;
  assume (0.0 < methodK#_9) && ((1000.0 * methodK#_9) < (real(1) * 0.01));
  assume wf(h0#_0, m0#_1, sm0#_2);
  assume wf(h1#_4, m1#_5, sm1#_6);
  m1#_5 := ZeroMask;
  sm1#_6 := ZeroMask;
  c1#_7 := ZeroCredits;
  havoc h1#_4;
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  3.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the field AVLTree.root
// -------------------------------------------
const unique AVLTree.root: Field (ref);
axiom NonPredicateField(AVLTree.root);


// -------------------------------------------
// Translation of the field AVLTree.keys
// -------------------------------------------
const unique AVLTree.keys: Field (Seq (int));
axiom NonPredicateField(AVLTree.keys);


// -------------------------------------------
// Translation of the predicate AVLTree.valid
// -------------------------------------------

// basic definitions
const unique AVLTree.valid: Field (int);
const unique AVLTree.valid#m: Field (PMaskType);
axiom PredicateField(AVLTree.valid);
axiom predicateMaskField(AVLTree.valid) == AVLTree.valid#m;

// trigger function
function #AVLTree.valid#trigger(this: ref) returns ($myresult: bool);

// definedness check
procedure AVLTree.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var predicateK#_10: real;
  assume (0.0 < predicateK#_10) && ((1000.0 * predicateK#_10) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  12.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  12.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  12.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  12.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  12.22: Receiver might be null."} Heap[this, AVLTree.root] != null;
    assert {:msg "  12.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  12.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  13.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  13.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  13.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  13.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  14.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  14.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  14.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  14.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  15.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  15.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  15.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  15.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  16.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  16.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  16.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  16.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
    assert {:msg "  16.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  16.30: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  16.30: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
    assert {:msg "  16.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTree.root], AVLTreeNode.keys);
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  assert {:msg "  17.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  17.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  17.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  17.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}


// -------------------------------------------
// Translation of the method AVLTree.init
// -------------------------------------------

// definedness check for method AVLTree.init
procedure AVLTree.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_12: real;
  assume (0.0 < methodK#_12) && ((1000.0 * methodK#_12) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_15: Field (PMaskType) :: 
    (forall ref#_14: ref :: 
      Heap[ref#_14, pmask#_15] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  25.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  27.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  27.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTree.init
procedure AVLTree.init(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_12: real;
  var foldK#_23: real;
  var predRec#_20: ref;
  var predVer#_21: int;
  var predFlag#_22: bool;
  var newPredicateMask#_36: PMaskType;
  var exhaleMask#_38: MaskType;
  var exhaleHeap#_37: HeapType;
  var exhaledHolds#_39: RefSet;
  assume (0.0 < methodK#_12) && ((1000.0 * methodK#_12) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_19: Field (PMaskType) :: 
    (forall ref#_18: ref :: 
      Heap[ref#_18, pmask#_19] == ZeroPMask
    )
  );
  // update field root
  assert {:msg "  29.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
  Heap[this, AVLTree.root] := null;
  assume wf(Heap, Mask, SecMask);
  // update field keys
  assert {:msg "  30.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
  Heap[this, AVLTree.keys] := Seq#Empty();
  assume wf(Heap, Mask, SecMask);
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0.0 < foldK#_23) && ((1000.0 * foldK#_23) < (real(1) * 0.01)) && ((1000.0 * foldK#_23) < methodK#_12);
  assert {:msg "  31.3: The target of the fold statement might be null."} this != null;
  predRec#_20 := this;
  predVer#_21 := Heap[this, AVLTree.valid];
  predFlag#_22 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} ((real(100) * 0.01) <= Mask[this, AVLTree.root][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.root][perm$R]) ==> (0.0 <= Mask[this, AVLTree.root][perm$N]));
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} ((real(50) * 0.01) <= Mask[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTree.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTree.keys][perm$N]));
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_20, AVLTree.valid, predVer#_21, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTree.valid#m][this, AVLTree.root] := true;
  Heap[this, AVLTree.valid#m][this, AVLTree.keys] := true;
  if (!(Heap[this, AVLTree.root] == null)) {
    havoc newPredicateMask#_36;
    assume (forall ref#_34: ref :: 
      (forall<T#_0> f#_35: Field (T#_0) :: 
        (Heap[this, AVLTree.valid#m][ref#_34, f#_35] || Heap[Heap[this, AVLTree.root], AVLTreeNode.valid#m][ref#_34, f#_35]) ==> newPredicateMask#_36[ref#_34, f#_35]
      )
    );
    Heap[this, AVLTree.valid#m] := newPredicateMask#_36;
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_38 := Mask;
  havoc exhaleHeap#_37;
  exhaledHolds#_39 := ZeroRefSet;
  assert {:msg "  21.2: The postcondition at 27.11 might not hold. The expression at 27.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  assert {:msg "  21.2: The postcondition at 25.11 might not hold. The permission at 25.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  21.2: The postcondition at 25.11 might not hold. Insufficient fraction at 25.11 for AVLTree.valid."} ((real(100) * 0.01) <= exhaleMask#_38[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_38[this, AVLTree.valid][perm$R]) ==> (0.0 <= exhaleMask#_38[this, AVLTree.valid][perm$N]));
  exhaleMask#_38[this, AVLTree.valid] := exhaleMask#_38[this, AVLTree.valid][perm$R := exhaleMask#_38[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_38, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_37[this, AVLTree.valid];
  }
  assume wf(Heap, exhaleMask#_38, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  21.2: The postcondition at 26.11 might not hold. The permission at 26.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  21.2: The postcondition at 26.11 might not hold. Insufficient fraction at 26.11 for AVLTree.keys."} ((real(50) * 0.01) <= exhaleMask#_38[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_38[this, AVLTree.keys][perm$R]) ==> (0.0 <= exhaleMask#_38[this, AVLTree.keys][perm$N]));
  exhaleMask#_38[this, AVLTree.keys] := exhaleMask#_38[this, AVLTree.keys][perm$R := exhaleMask#_38[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_38, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_38;
  assume IsGoodExhaleState(exhaleHeap#_37, Heap, Mask, exhaledHolds#_39);
  Heap := exhaleHeap#_37;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  21.2: Method might lock/unlock more than allowed."} (forall lk#_42: ref :: 
    { Heap[lk#_42, held] }
    { Heap[lk#_42, rdheld] }
    (((0 < Heap[lk#_42, held]) == (0 < old(Heap)[lk#_42, held])) && (Heap[lk#_42, rdheld] == old(Heap)[lk#_42, rdheld])) || false
  );
  assert {:msg "  21.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTree.insert
// -------------------------------------------

// definedness check for method AVLTree.insert
procedure AVLTree.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_43: real;
  var j#73#115: int where true;
  var j#74#117: int where true;
  assume (0.0 < methodK#_43) && ((1000.0 * methodK#_43) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  36.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_46: Field (PMaskType) :: 
    (forall ref#_45: ref :: 
      Heap[ref#_45, pmask#_46] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  39.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  42.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  42.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume Seq#Contains(Heap[this, AVLTree.keys], k#0);
  assert {:msg "  43.11: Receiver might be null."} true && (0 <= j#73#115) ==> (this != null);
  assert {:msg "  43.11: Location might not be readable."} true && (0 <= j#73#115) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  43.11: Receiver might be null."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  43.11: Location might not be readable."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  43.36: Sequence index might be negative."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (0 <= j#73#115);
  assert {:msg "  43.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assert {:msg "  43.41: Receiver might be null."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  43.41: Location might not be readable."} true && (0 <= j#73#115) && (j#73#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assume (forall j#73#114: int :: 
    (0 <= j#73#114) && (j#73#114 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#73#114))
  );
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#74#117) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#74#117) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  44.33: Sequence index might be negative."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (0 <= j#74#117);
  assert {:msg "  44.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (j#74#117 < Seq#Length(Heap[this, AVLTree.keys]));
  assert {:msg "  44.42: Receiver might be null."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  44.42: Location might not be readable."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  44.33: Sequence index might be negative."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> (0 <= j#74#117);
  assert {:msg "  44.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#74#117) && (j#74#117 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#117))) ==> (j#74#117 < Seq#Length(Heap[this, AVLTree.keys]));
  assume (forall j#74#116: int :: 
    (0 <= j#74#116) && (j#74#116 < Seq#Length(Heap[this, AVLTree.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#116)) || (Seq#Index(Heap[this, AVLTree.keys], j#74#116) == k#0))
  );
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTree.insert
procedure AVLTree.insert(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_43: real;
  var predRec#_52: ref;
  var predVer#_53: int;
  var unfoldK#_51: real;
  var oldVers#_58: int;
  var newVers#_59: int;
  var cond#_61: bool;
  var n#2: ref where (n#2 == null) || (dtype(n#2) == AVLTreeNode#t);
  var nw#_62: ref;
  var methodCallK#_67: real;
  var this#118: ref where (this#118 == null) || (dtype(this#118) == AVLTreeNode#t);
  var k#119: int where true;
  var callHeap#_63: HeapType;
  var callMask#_64: MaskType;
  var callSecMask#_65: MaskType;
  var callCredits#_66: CreditsType;
  var exhaleMask#_69: MaskType;
  var exhaleHeap#_68: HeapType;
  var exhaledHolds#_70: RefSet;
  var isHeld#_77: int;
  var isRdHeld#_78: bool;
  var methodCallK#_84: real;
  var this#120: ref where (this#120 == null) || (dtype(this#120) == AVLTreeNode#t);
  var k#121: int where true;
  var r#122: ref where (r#122 == null) || (dtype(r#122) == AVLTreeNode#t);
  var callHeap#_80: HeapType;
  var callMask#_81: MaskType;
  var callSecMask#_82: MaskType;
  var callCredits#_83: CreditsType;
  var exhaleMask#_86: MaskType;
  var exhaleHeap#_85: HeapType;
  var exhaledHolds#_87: RefSet;
  var isHeld#_92: int;
  var isRdHeld#_93: bool;
  var r#75: ref where (r#75 == null) || (dtype(r#75) == AVLTreeNode#t);
  var foldK#_98: real;
  var predRec#_95: ref;
  var predVer#_96: int;
  var predFlag#_97: bool;
  var newPredicateMask#_111: PMaskType;
  var exhaleMask#_113: MaskType;
  var exhaleHeap#_112: HeapType;
  var exhaledHolds#_114: RefSet;
  assume (0.0 < methodK#_43) && ((1000.0 * methodK#_43) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_50: Field (PMaskType) :: 
    (forall ref#_49: ref :: 
      Heap[ref#_49, pmask#_50] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTree.valid#trigger(this);
  predRec#_52 := this;
  predVer#_53 := Heap[this, AVLTree.valid];
  assume (0.0 < unfoldK#_51) && (unfoldK#_51 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_51) < methodK#_43);
  assert {:msg "  46.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  46.3: unfold might fail because the predicate AVLTree.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  46.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} ((real(100) * 0.01) <= Mask[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTree.valid][perm$N]));
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTree.valid)) {
    oldVers#_58 := Heap[this, AVLTree.valid];
    havoc newVers#_59;
    Heap[this, AVLTree.valid] := newVers#_59;
    assume oldVers#_58 < Heap[this, AVLTree.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_52, AVLTree.valid, predVer#_53, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_61 := Heap[this, AVLTree.root] == null;
  assert {:msg "  47.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  47.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (cond#_61) {
    // local var n
    // assigment to n
    // new
    havoc nw#_62;
    assume (nw#_62 != null) && (dtype(nw#_62) == AVLTreeNode#t);
    assume (forall<T#_1> f: Field (T#_1) :: 
      (Mask[nw#_62, f][perm$R] == 0.0) && (Mask[nw#_62, f][perm$N] == 0.0)
    );
    assume Heap[nw#_62, mu] == $LockBottom;
    assume Heap[nw#_62, held] <= 0;
    assume Heap[nw#_62, rdheld] == false;
    Mask[nw#_62, AVLTreeNode.key] := Mask[nw#_62, AVLTreeNode.key][perm$R := Mask[nw#_62, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    Mask[nw#_62, AVLTreeNode.height] := Mask[nw#_62, AVLTreeNode.height][perm$R := Mask[nw#_62, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
    Mask[nw#_62, AVLTreeNode.left] := Mask[nw#_62, AVLTreeNode.left][perm$R := Mask[nw#_62, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    Mask[nw#_62, AVLTreeNode.right] := Mask[nw#_62, AVLTreeNode.right][perm$R := Mask[nw#_62, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    Mask[nw#_62, AVLTreeNode.keys] := Mask[nw#_62, AVLTreeNode.keys][perm$R := Mask[nw#_62, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
    Mask[nw#_62, AVLTreeNode.balanceFactor] := Mask[nw#_62, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_62, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
    Mask[nw#_62, mu] := Mask[nw#_62, mu][perm$R := Mask[nw#_62, mu][perm$R] + (real(100) * 0.01)];
    n#2 := nw#_62;
    assume (0.0 < methodCallK#_67) && ((1000.0 * methodCallK#_67) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_67) < methodK#_43);
    // call init
    callHeap#_63 := Heap;
    callMask#_64 := Mask;
    callSecMask#_65 := SecMask;
    callCredits#_66 := Credits;
    assume wf(callHeap#_63, callMask#_64, callSecMask#_65);
    assert {:msg "  49.4: The target of the method call might be null."} n#2 != null;
    this#118 := n#2;
    k#119 := k#0;
    // begin exhale (precondition)
    exhaleMask#_69 := Mask;
    havoc exhaleHeap#_68;
    exhaledHolds#_70 := ZeroRefSet;
    assert {:msg "  49.4: The precondition at 155.12 might not hold. The permission at 155.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  49.4: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_69[this#118, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_69[this#118, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_69[this#118, AVLTreeNode.key][perm$N]));
    exhaleMask#_69[this#118, AVLTreeNode.key] := exhaleMask#_69[this#118, AVLTreeNode.key][perm$R := exhaleMask#_69[this#118, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_69, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 156.12 might not hold. The permission at 156.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  49.4: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_69[this#118, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_69[this#118, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_69[this#118, AVLTreeNode.height][perm$N]));
    exhaleMask#_69[this#118, AVLTreeNode.height] := exhaleMask#_69[this#118, AVLTreeNode.height][perm$R := exhaleMask#_69[this#118, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_69, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 157.12 might not hold. The permission at 157.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  49.4: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_69[this#118, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_69[this#118, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_69[this#118, AVLTreeNode.left][perm$N]));
    exhaleMask#_69[this#118, AVLTreeNode.left] := exhaleMask#_69[this#118, AVLTreeNode.left][perm$R := exhaleMask#_69[this#118, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_69, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 158.12 might not hold. The permission at 158.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  49.4: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_69[this#118, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_69[this#118, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_69[this#118, AVLTreeNode.right][perm$N]));
    exhaleMask#_69[this#118, AVLTreeNode.right] := exhaleMask#_69[this#118, AVLTreeNode.right][perm$R := exhaleMask#_69[this#118, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_69, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 160.12 might not hold. The permission at 160.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  49.4: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_69[this#118, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_69[this#118, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_69[this#118, AVLTreeNode.keys][perm$N]));
    exhaleMask#_69[this#118, AVLTreeNode.keys] := exhaleMask#_69[this#118, AVLTreeNode.keys][perm$R := exhaleMask#_69[this#118, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_69, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  49.4: The precondition at 161.12 might not hold. The permission at 161.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  49.4: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_69[this#118, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_69[this#118, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_69[this#118, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_69[this#118, AVLTreeNode.balanceFactor] := exhaleMask#_69[this#118, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_69[this#118, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_69, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_69;
    assume IsGoodExhaleState(exhaleHeap#_68, Heap, Mask, exhaledHolds#_70);
    Heap := exhaleHeap#_68;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[this#118, AVLTreeNode.valid] := Mask[this#118, AVLTreeNode.valid][perm$R := Mask[this#118, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#118, AVLTreeNode.keys] := Mask[this#118, AVLTreeNode.keys][perm$R := Mask[this#118, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#118, AVLTreeNode.height] := Mask[this#118, AVLTreeNode.height][perm$R := Mask[this#118, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#118 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#118, AVLTreeNode.balanceFactor] := Mask[this#118, AVLTreeNode.balanceFactor][perm$R := Mask[this#118, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[this#118, AVLTreeNode.height] == 1;
    assume Seq#Equal(Heap[this#118, AVLTreeNode.keys], Seq#Singleton(k#119));
    assume Heap[this#118, AVLTreeNode.balanceFactor] == 0;
    assume Seq#Contains(Heap[this#118, AVLTreeNode.keys], k#119);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    // update field root
    assert {:msg "  50.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := n#2;
    assume wf(Heap, Mask, SecMask);
  } else {
    assume (0.0 < methodCallK#_84) && ((1000.0 * methodCallK#_84) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_84) < methodK#_43);
    // call insert
    callHeap#_80 := Heap;
    callMask#_81 := Mask;
    callSecMask#_82 := SecMask;
    callCredits#_83 := Credits;
    assume wf(callHeap#_80, callMask#_81, callSecMask#_82);
    assert {:msg "  52.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  52.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  52.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#120 := Heap[this, AVLTree.root];
    k#121 := k#0;
    // begin exhale (precondition)
    exhaleMask#_86 := Mask;
    havoc exhaleHeap#_85;
    exhaledHolds#_87 := ZeroRefSet;
    assert {:msg "  52.4: The precondition at 185.12 might not hold. The permission at 185.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  52.4: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_86[this#120, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_86[this#120, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_86[this#120, AVLTreeNode.valid][perm$N]));
    exhaleMask#_86[this#120, AVLTreeNode.valid] := exhaleMask#_86[this#120, AVLTreeNode.valid][perm$R := exhaleMask#_86[this#120, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_86, this#120, AVLTreeNode.valid)) {
      assume Heap[this#120, AVLTreeNode.valid] < exhaleHeap#_85[this#120, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_86, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  52.4: The precondition at 186.12 might not hold. The permission at 186.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  52.4: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_86[this#120, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_86[this#120, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_86[this#120, AVLTreeNode.keys][perm$N]));
    exhaleMask#_86[this#120, AVLTreeNode.keys] := exhaleMask#_86[this#120, AVLTreeNode.keys][perm$R := exhaleMask#_86[this#120, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_86, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  52.4: The precondition at 187.12 might not hold. The permission at 187.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  52.4: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_86[this#120, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_86[this#120, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_86[this#120, AVLTreeNode.height][perm$N]));
    exhaleMask#_86[this#120, AVLTreeNode.height] := exhaleMask#_86[this#120, AVLTreeNode.height][perm$R := exhaleMask#_86[this#120, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_86, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  52.4: The precondition at 188.12 might not hold. The permission at 188.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  52.4: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_86[this#120, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_86[this#120, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_86[this#120, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_86[this#120, AVLTreeNode.balanceFactor] := exhaleMask#_86[this#120, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_86[this#120, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_86, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_86;
    assume IsGoodExhaleState(exhaleHeap#_85, Heap, Mask, exhaledHolds#_87);
    Heap := exhaleHeap#_85;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#122;
    // inhale (postcondition)
    assume !(r#122 == null);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#122, AVLTreeNode.valid] := Mask[r#122, AVLTreeNode.valid][perm$R := Mask[r#122, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#122, AVLTreeNode.keys] := Mask[r#122, AVLTreeNode.keys][perm$R := Mask[r#122, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#122, AVLTreeNode.height] := Mask[r#122, AVLTreeNode.height][perm$R := Mask[r#122, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#122 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#122, AVLTreeNode.balanceFactor] := Mask[r#122, AVLTreeNode.balanceFactor][perm$R := Mask[r#122, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Contains(Heap[r#122, AVLTreeNode.keys], k#121);
    assume (forall i#82#123: int :: 
      (0 <= i#82#123) && (i#82#123 < Seq#Length(callHeap#_80[this#120, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#122, AVLTreeNode.keys], Seq#Index(callHeap#_80[this#120, AVLTreeNode.keys], i#82#123))
    );
    assume (forall i#83#124: int :: 
      (0 <= i#83#124) && (i#83#124 < Seq#Length(Heap[r#122, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_80[this#120, AVLTreeNode.keys], Seq#Index(Heap[r#122, AVLTreeNode.keys], i#83#124)) || (Seq#Index(Heap[r#122, AVLTreeNode.keys], i#83#124) == k#121))
    );
    if (Seq#Contains(callHeap#_80[this#120, AVLTreeNode.keys], k#121)) {
      assume Seq#Equal(Heap[r#122, AVLTreeNode.keys], callHeap#_80[this#120, AVLTreeNode.keys]);
    }
    if (!Seq#Contains(callHeap#_80[this#120, AVLTreeNode.keys], k#121)) {
      assume Seq#Length(Heap[r#122, AVLTreeNode.keys]) == (Seq#Length(callHeap#_80[this#120, AVLTreeNode.keys]) + 1);
    }
    assume (Heap[r#122, AVLTreeNode.height] == callHeap#_80[this#120, AVLTreeNode.height]) || (Heap[r#122, AVLTreeNode.height] == (callHeap#_80[this#120, AVLTreeNode.height] + 1));
    if (Seq#Contains(callHeap#_80[this#120, AVLTreeNode.keys], k#121)) {
      assume Heap[r#122, AVLTreeNode.height] == callHeap#_80[this#120, AVLTreeNode.height];
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#75 := r#122;
    // update field root
    assert {:msg "  53.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#75;
    assume wf(Heap, Mask, SecMask);
  }
  // update field keys
  assert {:msg "  55.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
  assert {:msg "  55.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  55.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  assert {:msg "  55.11: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
  assert {:msg "  55.11: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTree.root], AVLTreeNode.keys);
  Heap[this, AVLTree.keys] := Heap[Heap[this, AVLTree.root], AVLTreeNode.keys];
  assume wf(Heap, Mask, SecMask);
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0.0 < foldK#_98) && ((1000.0 * foldK#_98) < (real(1) * 0.01)) && ((1000.0 * foldK#_98) < methodK#_43);
  assert {:msg "  56.3: The target of the fold statement might be null."} this != null;
  predRec#_95 := this;
  predVer#_96 := Heap[this, AVLTree.valid];
  predFlag#_97 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} ((real(100) * 0.01) <= Mask[this, AVLTree.root][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.root][perm$R]) ==> (0.0 <= Mask[this, AVLTree.root][perm$N]));
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} ((real(50) * 0.01) <= Mask[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTree.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTree.keys][perm$N]));
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_95, AVLTree.valid, predVer#_96, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTree.valid#m][this, AVLTree.root] := true;
  Heap[this, AVLTree.valid#m][this, AVLTree.keys] := true;
  if (!(Heap[this, AVLTree.root] == null)) {
    havoc newPredicateMask#_111;
    assume (forall ref#_109: ref :: 
      (forall<T#_2> f#_110: Field (T#_2) :: 
        (Heap[this, AVLTree.valid#m][ref#_109, f#_110] || Heap[Heap[this, AVLTree.root], AVLTreeNode.valid#m][ref#_109, f#_110]) ==> newPredicateMask#_111[ref#_109, f#_110]
      )
    );
    Heap[this, AVLTree.valid#m] := newPredicateMask#_111;
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_113 := Mask;
  havoc exhaleHeap#_112;
  exhaledHolds#_114 := ZeroRefSet;
  assert {:msg "  35.2: The postcondition at 42.11 might not hold. The expression at 42.11 might not evaluate to true."} Seq#Contains(Heap[this, AVLTree.keys], k#0);
  assert {:msg "  35.2: The postcondition at 43.11 might not hold. The expression at 43.11 might not evaluate to true."} (forall j#73#125: int :: 
    (0 <= j#73#125) && (j#73#125 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#73#125))
  );
  assert {:msg "  35.2: The postcondition at 44.11 might not hold. The expression at 44.11 might not evaluate to true."} (forall j#74#126: int :: 
    (0 <= j#74#126) && (j#74#126 < Seq#Length(Heap[this, AVLTree.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#74#126)) || (Seq#Index(Heap[this, AVLTree.keys], j#74#126) == k#0))
  );
  assert {:msg "  35.2: The postcondition at 39.11 might not hold. The permission at 39.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  35.2: The postcondition at 39.11 might not hold. Insufficient fraction at 39.11 for AVLTree.valid."} ((real(100) * 0.01) <= exhaleMask#_113[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_113[this, AVLTree.valid][perm$R]) ==> (0.0 <= exhaleMask#_113[this, AVLTree.valid][perm$N]));
  exhaleMask#_113[this, AVLTree.valid] := exhaleMask#_113[this, AVLTree.valid][perm$R := exhaleMask#_113[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_113, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_112[this, AVLTree.valid];
  }
  assume wf(Heap, exhaleMask#_113, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  35.2: The postcondition at 40.11 might not hold. The permission at 40.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  35.2: The postcondition at 40.11 might not hold. Insufficient fraction at 40.11 for AVLTree.keys."} ((real(50) * 0.01) <= exhaleMask#_113[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_113[this, AVLTree.keys][perm$R]) ==> (0.0 <= exhaleMask#_113[this, AVLTree.keys][perm$N]));
  exhaleMask#_113[this, AVLTree.keys] := exhaleMask#_113[this, AVLTree.keys][perm$R := exhaleMask#_113[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_113, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_113;
  assume IsGoodExhaleState(exhaleHeap#_112, Heap, Mask, exhaledHolds#_114);
  Heap := exhaleHeap#_112;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  35.2: Method might lock/unlock more than allowed."} (forall lk#_117: ref :: 
    { Heap[lk#_117, held] }
    { Heap[lk#_117, rdheld] }
    (((0 < Heap[lk#_117, held]) == (0 < old(Heap)[lk#_117, held])) && (Heap[lk#_117, rdheld] == old(Heap)[lk#_117, rdheld])) || false
  );
  assert {:msg "  35.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTree.remove
// -------------------------------------------

// definedness check for method AVLTree.remove
procedure AVLTree.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_118: real;
  var j#76#130: int where true;
  var j#77#132: int where true;
  assume (0.0 < methodK#_118) && ((1000.0 * methodK#_118) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  61.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_121: Field (PMaskType) :: 
    (forall ref#_120: ref :: 
      Heap[ref#_120, pmask#_121] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  64.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  67.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  67.18: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume !Seq#Contains(Heap[this, AVLTree.keys], k#3);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#76#130) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#76#130) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  68.36: Sequence index might be negative."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (0 <= j#76#130);
  assert {:msg "  68.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assert {:msg "  68.41: Receiver might be null."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  68.41: Location might not be readable."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  68.36: Sequence index might be negative."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> (0 <= j#76#130);
  assert {:msg "  68.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#76#130) && (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#130))) ==> (j#76#130 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assume (forall j#76#129: int :: 
    (0 <= j#76#129) && (j#76#129 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#129)) || (Seq#Index(old(Heap)[this, AVLTree.keys], j#76#129) == k#3))
  );
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#77#132) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#77#132) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  69.33: Sequence index might be negative."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (0 <= j#77#132);
  assert {:msg "  69.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (j#77#132 < Seq#Length(Heap[this, AVLTree.keys]));
  assert {:msg "  69.42: Receiver might be null."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  69.42: Location might not be readable."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  69.33: Sequence index might be negative."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> (0 <= j#77#132);
  assert {:msg "  69.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#77#132) && (j#77#132 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#132)) ==> (j#77#132 < Seq#Length(Heap[this, AVLTree.keys]));
  assume (forall j#77#131: int :: 
    (0 <= j#77#131) && (j#77#131 < Seq#Length(Heap[this, AVLTree.keys])) ==> Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#131)) && (!(Seq#Index(Heap[this, AVLTree.keys], j#77#131) == k#3))
  );
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTree.remove
procedure AVLTree.remove(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_118: real;
  var predRec#_127: ref;
  var predVer#_128: int;
  var unfoldK#_126: real;
  var oldVers#_133: int;
  var newVers#_134: int;
  var cond#_136: bool;
  var methodCallK#_141: real;
  var this#133: ref where (this#133 == null) || (dtype(this#133) == AVLTreeNode#t);
  var k#134: int where true;
  var r#135: ref where (r#135 == null) || (dtype(r#135) == AVLTreeNode#t);
  var callHeap#_137: HeapType;
  var callMask#_138: MaskType;
  var callSecMask#_139: MaskType;
  var callCredits#_140: CreditsType;
  var exhaleMask#_143: MaskType;
  var exhaleHeap#_142: HeapType;
  var exhaledHolds#_144: RefSet;
  var isHeld#_149: int;
  var isRdHeld#_150: bool;
  var r#78: ref where (r#78 == null) || (dtype(r#78) == AVLTreeNode#t);
  var foldK#_155: real;
  var predRec#_152: ref;
  var predVer#_153: int;
  var predFlag#_154: bool;
  var newPredicateMask#_168: PMaskType;
  var exhaleMask#_170: MaskType;
  var exhaleHeap#_169: HeapType;
  var exhaledHolds#_171: RefSet;
  assume (0.0 < methodK#_118) && ((1000.0 * methodK#_118) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_125: Field (PMaskType) :: 
    (forall ref#_124: ref :: 
      Heap[ref#_124, pmask#_125] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTree.valid#trigger(this);
  predRec#_127 := this;
  predVer#_128 := Heap[this, AVLTree.valid];
  assume (0.0 < unfoldK#_126) && (unfoldK#_126 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_126) < methodK#_118);
  assert {:msg "  71.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  71.3: unfold might fail because the predicate AVLTree.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  71.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} ((real(100) * 0.01) <= Mask[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTree.valid][perm$N]));
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTree.valid)) {
    oldVers#_133 := Heap[this, AVLTree.valid];
    havoc newVers#_134;
    Heap[this, AVLTree.valid] := newVers#_134;
    assume oldVers#_133 < Heap[this, AVLTree.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_127, AVLTree.valid, predVer#_128, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_136 := Heap[this, AVLTree.root] == null;
  assert {:msg "  72.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  72.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (cond#_136) {
  } else {
    assume (0.0 < methodCallK#_141) && ((1000.0 * methodCallK#_141) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_141) < methodK#_118);
    // call remove
    callHeap#_137 := Heap;
    callMask#_138 := Mask;
    callSecMask#_139 := SecMask;
    callCredits#_140 := Credits;
    assume wf(callHeap#_137, callMask#_138, callSecMask#_139);
    assert {:msg "  74.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  74.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  74.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#133 := Heap[this, AVLTree.root];
    k#134 := k#3;
    // begin exhale (precondition)
    exhaleMask#_143 := Mask;
    havoc exhaleHeap#_142;
    exhaledHolds#_144 := ZeroRefSet;
    assert {:msg "  74.4: The precondition at 254.12 might not hold. The permission at 254.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  74.4: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_143[this#133, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_143[this#133, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_143[this#133, AVLTreeNode.valid][perm$N]));
    exhaleMask#_143[this#133, AVLTreeNode.valid] := exhaleMask#_143[this#133, AVLTreeNode.valid][perm$R := exhaleMask#_143[this#133, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_143, this#133, AVLTreeNode.valid)) {
      assume Heap[this#133, AVLTreeNode.valid] < exhaleHeap#_142[this#133, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_143, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  74.4: The precondition at 255.12 might not hold. The permission at 255.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  74.4: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_143[this#133, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_143[this#133, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_143[this#133, AVLTreeNode.keys][perm$N]));
    exhaleMask#_143[this#133, AVLTreeNode.keys] := exhaleMask#_143[this#133, AVLTreeNode.keys][perm$R := exhaleMask#_143[this#133, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_143, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  74.4: The precondition at 256.12 might not hold. The permission at 256.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  74.4: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_143[this#133, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_143[this#133, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_143[this#133, AVLTreeNode.height][perm$N]));
    exhaleMask#_143[this#133, AVLTreeNode.height] := exhaleMask#_143[this#133, AVLTreeNode.height][perm$R := exhaleMask#_143[this#133, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_143, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  74.4: The precondition at 257.12 might not hold. The permission at 257.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  74.4: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_143[this#133, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_143[this#133, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_143[this#133, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_143[this#133, AVLTreeNode.balanceFactor] := exhaleMask#_143[this#133, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_143[this#133, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_143, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_143;
    assume IsGoodExhaleState(exhaleHeap#_142, Heap, Mask, exhaledHolds#_144);
    Heap := exhaleHeap#_142;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#135;
    // inhale (postcondition)
    if (Seq#Equal(callHeap#_137[this#133, AVLTreeNode.keys], Seq#Singleton(k#134))) {
      assume r#135 == null;
    }
    if (!Seq#Equal(callHeap#_137[this#133, AVLTreeNode.keys], Seq#Singleton(k#134))) {
      assume !(r#135 == null);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#135, AVLTreeNode.valid] := Mask[r#135, AVLTreeNode.valid][perm$R := Mask[r#135, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#135, AVLTreeNode.keys] := Mask[r#135, AVLTreeNode.keys][perm$R := Mask[r#135, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#135, AVLTreeNode.height] := Mask[r#135, AVLTreeNode.height][perm$R := Mask[r#135, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume r#135 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#135, AVLTreeNode.balanceFactor] := Mask[r#135, AVLTreeNode.balanceFactor][perm$R := Mask[r#135, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#135 == null)) {
      assume !Seq#Contains(Heap[r#135, AVLTreeNode.keys], k#134);
    }
    if (!(r#135 == null)) {
      assume (forall i#84#136: int :: 
        (0 <= i#84#136) && (i#84#136 < Seq#Length(callHeap#_137[this#133, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#135, AVLTreeNode.keys], Seq#Index(callHeap#_137[this#133, AVLTreeNode.keys], i#84#136)) || (Seq#Index(callHeap#_137[this#133, AVLTreeNode.keys], i#84#136) == k#134))
      );
    }
    if (!(r#135 == null)) {
      assume (forall i#85#137: int :: 
        (0 <= i#85#137) && (i#85#137 < Seq#Length(Heap[r#135, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_137[this#133, AVLTreeNode.keys], Seq#Index(Heap[r#135, AVLTreeNode.keys], i#85#137)) && (!(Seq#Index(Heap[r#135, AVLTreeNode.keys], i#85#137) == k#134))
      );
    }
    if (!Seq#Contains(callHeap#_137[this#133, AVLTreeNode.keys], k#134)) {
      assume !(r#135 == null);
    }
    if (!Seq#Contains(callHeap#_137[this#133, AVLTreeNode.keys], k#134)) {
      assume Seq#Equal(Heap[r#135, AVLTreeNode.keys], callHeap#_137[this#133, AVLTreeNode.keys]);
    }
    if (!(r#135 == null)) {
      if (Seq#Contains(callHeap#_137[this#133, AVLTreeNode.keys], k#134)) {
        assume Seq#Length(Heap[r#135, AVLTreeNode.keys]) == (Seq#Length(callHeap#_137[this#133, AVLTreeNode.keys]) - 1);
      }
    }
    if (callHeap#_137[this#133, AVLTreeNode.height] > 1) {
      assume !(r#135 == null);
    }
    if (!(r#135 == null)) {
      assume (Heap[r#135, AVLTreeNode.height] == callHeap#_137[this#133, AVLTreeNode.height]) || ((Heap[r#135, AVLTreeNode.height] + 1) == callHeap#_137[this#133, AVLTreeNode.height]);
    }
    if (!Seq#Contains(callHeap#_137[this#133, AVLTreeNode.keys], k#134)) {
      assume Heap[r#135, AVLTreeNode.height] == callHeap#_137[this#133, AVLTreeNode.height];
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#78 := r#135;
    // update field root
    assert {:msg "  75.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#78;
    assume wf(Heap, Mask, SecMask);
    // update field keys
    assert {:msg "  76.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
    assert {:msg "  76.13: Receiver might be null."} true ==> (this != null);
    assert {:msg "  76.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    if (Heap[this, AVLTree.root] == null) {
    } else {
      assert {:msg "  76.33: Receiver might be null."} true ==> (this != null);
      assert {:msg "  76.33: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
      assert {:msg "  76.33: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
      assert {:msg "  76.33: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTree.root], AVLTreeNode.keys);
    }
    Heap[this, AVLTree.keys] := ite(Heap[this, AVLTree.root] == null, Seq#Empty(), Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask, SecMask);
  }
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0.0 < foldK#_155) && ((1000.0 * foldK#_155) < (real(1) * 0.01)) && ((1000.0 * foldK#_155) < methodK#_118);
  assert {:msg "  78.3: The target of the fold statement might be null."} this != null;
  predRec#_152 := this;
  predVer#_153 := Heap[this, AVLTree.valid];
  predFlag#_154 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} ((real(100) * 0.01) <= Mask[this, AVLTree.root][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.root][perm$R]) ==> (0.0 <= Mask[this, AVLTree.root][perm$N]));
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} ((real(50) * 0.01) <= Mask[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTree.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTree.keys][perm$N]));
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_152, AVLTree.valid, predVer#_153, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTree.valid#m][this, AVLTree.root] := true;
  Heap[this, AVLTree.valid#m][this, AVLTree.keys] := true;
  if (!(Heap[this, AVLTree.root] == null)) {
    havoc newPredicateMask#_168;
    assume (forall ref#_166: ref :: 
      (forall<T#_3> f#_167: Field (T#_3) :: 
        (Heap[this, AVLTree.valid#m][ref#_166, f#_167] || Heap[Heap[this, AVLTree.root], AVLTreeNode.valid#m][ref#_166, f#_167]) ==> newPredicateMask#_168[ref#_166, f#_167]
      )
    );
    Heap[this, AVLTree.valid#m] := newPredicateMask#_168;
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_170 := Mask;
  havoc exhaleHeap#_169;
  exhaledHolds#_171 := ZeroRefSet;
  assert {:msg "  60.2: The postcondition at 67.11 might not hold. The expression at 67.11 might not evaluate to true."} !Seq#Contains(Heap[this, AVLTree.keys], k#3);
  assert {:msg "  60.2: The postcondition at 68.11 might not hold. The expression at 68.11 might not evaluate to true."} (forall j#76#138: int :: 
    (0 <= j#76#138) && (j#76#138 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#76#138)) || (Seq#Index(old(Heap)[this, AVLTree.keys], j#76#138) == k#3))
  );
  assert {:msg "  60.2: The postcondition at 69.11 might not hold. The expression at 69.11 might not evaluate to true."} (forall j#77#139: int :: 
    (0 <= j#77#139) && (j#77#139 < Seq#Length(Heap[this, AVLTree.keys])) ==> Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#77#139)) && (!(Seq#Index(Heap[this, AVLTree.keys], j#77#139) == k#3))
  );
  assert {:msg "  60.2: The postcondition at 64.11 might not hold. The permission at 64.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  60.2: The postcondition at 64.11 might not hold. Insufficient fraction at 64.11 for AVLTree.valid."} ((real(100) * 0.01) <= exhaleMask#_170[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_170[this, AVLTree.valid][perm$R]) ==> (0.0 <= exhaleMask#_170[this, AVLTree.valid][perm$N]));
  exhaleMask#_170[this, AVLTree.valid] := exhaleMask#_170[this, AVLTree.valid][perm$R := exhaleMask#_170[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_170, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_169[this, AVLTree.valid];
  }
  assume wf(Heap, exhaleMask#_170, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  60.2: The postcondition at 65.11 might not hold. The permission at 65.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  60.2: The postcondition at 65.11 might not hold. Insufficient fraction at 65.11 for AVLTree.keys."} ((real(50) * 0.01) <= exhaleMask#_170[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_170[this, AVLTree.keys][perm$R]) ==> (0.0 <= exhaleMask#_170[this, AVLTree.keys][perm$N]));
  exhaleMask#_170[this, AVLTree.keys] := exhaleMask#_170[this, AVLTree.keys][perm$R := exhaleMask#_170[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_170, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_170;
  assume IsGoodExhaleState(exhaleHeap#_169, Heap, Mask, exhaledHolds#_171);
  Heap := exhaleHeap#_169;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  60.2: Method might lock/unlock more than allowed."} (forall lk#_174: ref :: 
    { Heap[lk#_174, held] }
    { Heap[lk#_174, rdheld] }
    (((0 < Heap[lk#_174, held]) == (0 < old(Heap)[lk#_174, held])) && (Heap[lk#_174, rdheld] == old(Heap)[lk#_174, rdheld])) || false
  );
  assert {:msg "  60.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTree.has
// -------------------------------------------

// definedness check for method AVLTree.has
procedure AVLTree.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_175: real;
  assume (0.0 < methodK#_175) && ((1000.0 * methodK#_175) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  83.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_175 > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + methodK#_175];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_178: Field (PMaskType) :: 
    (forall ref#_177: ref :: 
      Heap[ref#_177, pmask#_178] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  86.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_175 > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + methodK#_175];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  88.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  88.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume b#5 == Seq#Contains(Heap[this, AVLTree.keys], k#4);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTree.has
procedure AVLTree.has(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_175: real;
  var predRec#_184: ref;
  var predVer#_185: int;
  var unfoldK#_183: real;
  var oldVers#_190: int;
  var newVers#_191: int;
  var cond#_193: bool;
  var bb#7: bool where true;
  var methodCallK#_198: real;
  var this#142: ref where (this#142 == null) || (dtype(this#142) == AVLTreeNode#t);
  var k#143: int where true;
  var b#144: bool where true;
  var callHeap#_194: HeapType;
  var callMask#_195: MaskType;
  var callSecMask#_196: MaskType;
  var callCredits#_197: CreditsType;
  var exhaleMask#_200: MaskType;
  var exhaleHeap#_199: HeapType;
  var exhaledHolds#_201: RefSet;
  var isHeld#_204: int;
  var isRdHeld#_205: bool;
  var foldK#_210: real;
  var predRec#_207: ref;
  var predVer#_208: int;
  var predFlag#_209: bool;
  var newPredicateMask#_223: PMaskType;
  var exhaleMask#_225: MaskType;
  var exhaleHeap#_224: HeapType;
  var exhaledHolds#_226: RefSet;
  assume (0.0 < methodK#_175) && ((1000.0 * methodK#_175) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_175 > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + methodK#_175];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_182: Field (PMaskType) :: 
    (forall ref#_181: ref :: 
      Heap[ref#_181, pmask#_182] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTree.valid#trigger(this);
  predRec#_184 := this;
  predVer#_185 := Heap[this, AVLTree.valid];
  assume (0.0 < unfoldK#_183) && (unfoldK#_183 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_183) < methodK#_175);
  assert {:msg "  90.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  90.3: unfold might fail because the predicate AVLTree.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  90.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} ((real(100) * 0.01) <= Mask[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTree.valid][perm$N]));
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTree.valid)) {
    oldVers#_190 := Heap[this, AVLTree.valid];
    havoc newVers#_191;
    Heap[this, AVLTree.valid] := newVers#_191;
    assume oldVers#_190 < Heap[this, AVLTree.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_184, AVLTree.valid, predVer#_185, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_193 := Heap[this, AVLTree.root] == null;
  assert {:msg "  91.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  91.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (cond#_193) {
    // assigment to b
    b#5 := false;
  } else {
    // local var bb
    assume (0.0 < methodCallK#_198) && ((1000.0 * methodCallK#_198) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_198) < methodK#_175);
    // call has
    callHeap#_194 := Heap;
    callMask#_195 := Mask;
    callSecMask#_196 := SecMask;
    callCredits#_197 := Credits;
    assume wf(callHeap#_194, callMask#_195, callSecMask#_196);
    assert {:msg "  95.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  95.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  95.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#142 := Heap[this, AVLTree.root];
    k#143 := k#4;
    // begin exhale (precondition)
    exhaleMask#_200 := Mask;
    havoc exhaleHeap#_199;
    exhaledHolds#_201 := ZeroRefSet;
    assert {:msg "  95.4: The precondition at 458.12 might not hold. The permission at 458.12 might not be positive."} methodCallK#_198 > 0.0;
    assert {:msg "  95.4: The precondition at 458.12 might not hold. Insufficient fraction at 458.12 for AVLTreeNode.keys."} exhaleMask#_200[this#142, AVLTreeNode.keys][perm$R] > 0.0;
    assume methodCallK#_198 < exhaleMask#_200[this#142, AVLTreeNode.keys][perm$R];
    exhaleMask#_200[this#142, AVLTreeNode.keys] := exhaleMask#_200[this#142, AVLTreeNode.keys][perm$R := exhaleMask#_200[this#142, AVLTreeNode.keys][perm$R] - methodCallK#_198];
    assume wf(Heap, exhaleMask#_200, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  95.4: The precondition at 457.12 might not hold. The permission at 457.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  95.4: The precondition at 457.12 might not hold. Insufficient fraction at 457.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_200[this#142, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_200[this#142, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_200[this#142, AVLTreeNode.valid][perm$N]));
    exhaleMask#_200[this#142, AVLTreeNode.valid] := exhaleMask#_200[this#142, AVLTreeNode.valid][perm$R := exhaleMask#_200[this#142, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_200, this#142, AVLTreeNode.valid)) {
      assume Heap[this#142, AVLTreeNode.valid] < exhaleHeap#_199[this#142, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_200, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_200;
    assume IsGoodExhaleState(exhaleHeap#_199, Heap, Mask, exhaledHolds#_201);
    Heap := exhaleHeap#_199;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc b#144;
    // inhale (postcondition)
    assume this#142 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[this#142, AVLTreeNode.valid] := Mask[this#142, AVLTreeNode.valid][perm$R := Mask[this#142, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#142 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodCallK#_198 > 0.0;
    Mask[this#142, AVLTreeNode.keys] := Mask[this#142, AVLTreeNode.keys][perm$R := Mask[this#142, AVLTreeNode.keys][perm$R] + methodCallK#_198];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume b#144 == Seq#Contains(Heap[this#142, AVLTreeNode.keys], k#143);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    bb#7 := b#144;
    // assigment to b
    b#5 := bb#7;
  }
  // fold
  assume #AVLTree.valid#trigger(this);
  assume (0.0 < foldK#_210) && ((1000.0 * foldK#_210) < (real(1) * 0.01)) && ((1000.0 * foldK#_210) < methodK#_175);
  assert {:msg "  98.3: The target of the fold statement might be null."} this != null;
  predRec#_207 := this;
  predVer#_208 := Heap[this, AVLTree.valid];
  predFlag#_209 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  }
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 10.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} ((real(100) * 0.01) <= Mask[this, AVLTree.root][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTree.root][perm$R]) ==> (0.0 <= Mask[this, AVLTree.root][perm$N]));
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 11.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} ((real(50) * 0.01) <= Mask[this, AVLTree.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTree.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTree.keys][perm$N]));
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 12.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_207, AVLTree.valid, predVer#_208, Heap[this, AVLTree.root], AVLTreeNode.valid, Heap[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 13.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 14.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The permission at 15.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTree.valid#m][this, AVLTree.root] := true;
  Heap[this, AVLTree.valid#m][this, AVLTree.keys] := true;
  if (!(Heap[this, AVLTree.root] == null)) {
    havoc newPredicateMask#_223;
    assume (forall ref#_221: ref :: 
      (forall<T#_4> f#_222: Field (T#_4) :: 
        (Heap[this, AVLTree.valid#m][ref#_221, f#_222] || Heap[Heap[this, AVLTree.root], AVLTreeNode.valid#m][ref#_221, f#_222]) ==> newPredicateMask#_223[ref#_221, f#_222]
      )
    );
    Heap[this, AVLTree.valid#m] := newPredicateMask#_223;
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    Heap[this, AVLTree.valid#m][Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_225 := Mask;
  havoc exhaleHeap#_224;
  exhaledHolds#_226 := ZeroRefSet;
  assert {:msg "  82.2: The postcondition at 88.11 might not hold. The expression at 88.11 might not evaluate to true."} b#5 == Seq#Contains(Heap[this, AVLTree.keys], k#4);
  assert {:msg "  82.2: The postcondition at 86.11 might not hold. The permission at 86.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  82.2: The postcondition at 86.11 might not hold. Insufficient fraction at 86.11 for AVLTree.valid."} ((real(100) * 0.01) <= exhaleMask#_225[this, AVLTree.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_225[this, AVLTree.valid][perm$R]) ==> (0.0 <= exhaleMask#_225[this, AVLTree.valid][perm$N]));
  exhaleMask#_225[this, AVLTree.valid] := exhaleMask#_225[this, AVLTree.valid][perm$R := exhaleMask#_225[this, AVLTree.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_225, this, AVLTree.valid)) {
    assume Heap[this, AVLTree.valid] < exhaleHeap#_224[this, AVLTree.valid];
  }
  assume wf(Heap, exhaleMask#_225, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  82.2: The postcondition at 87.11 might not hold. The permission at 87.11 might not be positive."} methodK#_175 > 0.0;
  assert {:msg "  82.2: The postcondition at 87.11 might not hold. Insufficient fraction at 87.11 for AVLTree.keys."} (methodK#_175 <= exhaleMask#_225[this, AVLTree.keys][perm$R]) && ((methodK#_175 == exhaleMask#_225[this, AVLTree.keys][perm$R]) ==> (0.0 <= exhaleMask#_225[this, AVLTree.keys][perm$N]));
  exhaleMask#_225[this, AVLTree.keys] := exhaleMask#_225[this, AVLTree.keys][perm$R := exhaleMask#_225[this, AVLTree.keys][perm$R] - methodK#_175];
  assume wf(Heap, exhaleMask#_225, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_225;
  assume IsGoodExhaleState(exhaleHeap#_224, Heap, Mask, exhaledHolds#_226);
  Heap := exhaleHeap#_224;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  82.2: Method might lock/unlock more than allowed."} (forall lk#_229: ref :: 
    { Heap[lk#_229, held] }
    { Heap[lk#_229, rdheld] }
    (((0 < Heap[lk#_229, held]) == (0 < old(Heap)[lk#_229, held])) && (Heap[lk#_229, rdheld] == old(Heap)[lk#_229, rdheld])) || false
  );
  assert {:msg "  82.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}
const unique AVLTreeNode#t: TypeName;
procedure AVLTreeNode$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_239: real;
  var h0#_230: HeapType;
  var m0#_231: MaskType;
  var sm0#_232: MaskType;
  var c0#_233: CreditsType;
  var h1#_234: HeapType;
  var m1#_235: MaskType;
  var sm1#_236: MaskType;
  var c1#_237: CreditsType;
  var lk#_238: ref;
  assume (0.0 < methodK#_239) && ((1000.0 * methodK#_239) < (real(1) * 0.01));
  assume wf(h0#_230, m0#_231, sm0#_232);
  assume wf(h1#_234, m1#_235, sm1#_236);
  m1#_235 := ZeroMask;
  sm1#_236 := ZeroMask;
  c1#_237 := ZeroCredits;
  havoc h1#_234;
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  104.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the field AVLTreeNode.key
// -------------------------------------------
const unique AVLTreeNode.key: Field (int);
axiom NonPredicateField(AVLTreeNode.key);


// -------------------------------------------
// Translation of the field AVLTreeNode.height
// -------------------------------------------
const unique AVLTreeNode.height: Field (int);
axiom NonPredicateField(AVLTreeNode.height);


// -------------------------------------------
// Translation of the field AVLTreeNode.left
// -------------------------------------------
const unique AVLTreeNode.left: Field (ref);
axiom NonPredicateField(AVLTreeNode.left);


// -------------------------------------------
// Translation of the field AVLTreeNode.right
// -------------------------------------------
const unique AVLTreeNode.right: Field (ref);
axiom NonPredicateField(AVLTreeNode.right);


// -------------------------------------------
// Translation of the field AVLTreeNode.keys
// -------------------------------------------
const unique AVLTreeNode.keys: Field (Seq (int));
axiom NonPredicateField(AVLTreeNode.keys);


// -------------------------------------------
// Translation of the field AVLTreeNode.balanceFactor
// -------------------------------------------
const unique AVLTreeNode.balanceFactor: Field (int);
axiom NonPredicateField(AVLTreeNode.balanceFactor);


// -------------------------------------------
// Translation of the predicate AVLTreeNode.valid
// -------------------------------------------

// basic definitions
const unique AVLTreeNode.valid: Field (int);
const unique AVLTreeNode.valid#m: Field (PMaskType);
axiom PredicateField(AVLTreeNode.valid);
axiom predicateMaskField(AVLTreeNode.valid) == AVLTreeNode.valid#m;

// trigger function
function #AVLTreeNode.valid#trigger(this: ref) returns ($myresult: bool);

// definedness check
procedure AVLTreeNode.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var predicateK#_240: real;
  var lk#79#147: int where true;
  var rk#80#148: int where true;
  var kk#149: int where true;
  assume (0.0 < predicateK#_240) && ((1000.0 * predicateK#_240) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  125.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  125.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  125.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  125.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  125.22: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  125.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  125.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  126.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  126.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  126.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  126.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  127.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  127.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  127.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  127.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  128.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  128.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  128.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  128.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  129.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  129.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  129.48: Sequence index might be negative."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= lk#79#147);
    assert {:msg "  129.48: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  129.53: Receiver might be null."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  129.53: Location might not be readable."} true && (0 <= lk#79#147) && (lk#79#147 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall lk#79#145: int :: 
      (0 <= lk#79#145) && (lk#79#145 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#145) < Heap[this, AVLTreeNode.key])
    );
  }
  assert {:msg "  130.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  130.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  130.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  130.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  130.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  130.22: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  assert {:msg "  132.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  132.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  132.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  132.23: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  132.23: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  132.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  132.23: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  133.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  133.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  133.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  133.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  134.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  134.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  134.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  134.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  135.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  135.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  135.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  135.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  136.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  136.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  136.51: Receiver might be null."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  136.51: Location might not be readable."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  136.57: Sequence index might be negative."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= rk#80#148);
    assert {:msg "  136.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= rk#80#148) && (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (rk#80#148 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall rk#80#146: int :: 
      (0 <= rk#80#146) && (rk#80#146 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#146))
    );
  }
  assert {:msg "  137.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  137.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  137.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  137.23: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  137.23: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  137.23: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  139.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assert {:msg "  139.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  139.49: Receiver might be null."} true ==> (this != null);
    assert {:msg "  139.49: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  139.49: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  139.49: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  139.65: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.65: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  139.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.75: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  139.100: Receiver might be null."} true ==> (this != null);
    assert {:msg "  139.100: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  139.100: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  139.100: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  140.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  140.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  140.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  140.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  142.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  142.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assert {:msg "  144.9: Receiver might be null."} true ==> (this != null);
  assert {:msg "  144.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  144.30: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
  assert {:msg "  144.30: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  144.30: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  144.30: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  144.48: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) ==> (this != null);
  assert {:msg "  144.48: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  144.69: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> (this != null);
  assert {:msg "  144.69: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  144.69: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  144.69: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  144.91: Receiver might be null."} true && (!(((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#149)))) ==> (this != null);
  assert {:msg "  144.91: Location might not be readable."} true && (!(((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#149)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#149)))) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assert {:msg "  146.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assert {:msg "  146.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  146.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  146.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  146.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  146.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.53: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  146.67: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.67: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  146.67: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  146.67: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  146.84: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.84: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    if (Heap[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  146.97: Receiver might be null."} true ==> (this != null);
      assert {:msg "  146.97: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      assert {:msg "  146.97: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
      assert {:msg "  146.97: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  146.115: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.115: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    if (Heap[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  146.129: Receiver might be null."} true ==> (this != null);
      assert {:msg "  146.129: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      assert {:msg "  146.129: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
      assert {:msg "  146.129: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  147.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  147.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.24: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  147.37: Receiver might be null."} true ==> (this != null);
    assert {:msg "  147.37: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  147.37: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  147.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  147.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.53: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  147.67: Receiver might be null."} true ==> (this != null);
    assert {:msg "  147.67: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  147.67: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  147.67: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  148.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  148.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  149.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  149.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  150.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  150.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}


// -------------------------------------------
// Translation of the method AVLTreeNode.init
// -------------------------------------------

// definedness check for method AVLTreeNode.init
procedure AVLTreeNode.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_242: real;
  assume (0.0 < methodK#_242) && ((1000.0 * methodK#_242) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_245: Field (PMaskType) :: 
    (forall ref#_244: ref :: 
      Heap[ref#_244, pmask#_245] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  163.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  168.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  168.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assume Heap[this, AVLTreeNode.height] == 1;
  assert {:msg "  169.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  169.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Singleton(k#8));
  assert {:msg "  170.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  170.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] == 0;
  assert {:msg "  172.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  172.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], k#8);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.init
procedure AVLTreeNode.init(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_242: real;
  var assertHeap#_250: HeapType;
  var assertMask#_251: MaskType;
  var assertSecMask#_252: MaskType;
  var assertCredits#_253: CreditsType;
  var exhaleMask#_255: MaskType;
  var exhaleHeap#_254: HeapType;
  var exhaledHolds#_256: RefSet;
  var methodCallK#_261: real;
  var this#150: ref where (this#150 == null) || (dtype(this#150) == AVLTreeNode#t);
  var callHeap#_257: HeapType;
  var callMask#_258: MaskType;
  var callSecMask#_259: MaskType;
  var callCredits#_260: CreditsType;
  var exhaleMask#_263: MaskType;
  var exhaleHeap#_262: HeapType;
  var exhaledHolds#_264: RefSet;
  var isHeld#_279: int;
  var isRdHeld#_280: bool;
  var exhaleMask#_283: MaskType;
  var exhaleHeap#_282: HeapType;
  var exhaledHolds#_284: RefSet;
  assume (0.0 < methodK#_242) && ((1000.0 * methodK#_242) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_249: Field (PMaskType) :: 
    (forall ref#_248: ref :: 
      Heap[ref#_248, pmask#_249] == ZeroPMask
    )
  );
  // update field left
  assert {:msg "  174.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  Heap[this, AVLTreeNode.left] := null;
  assume wf(Heap, Mask, SecMask);
  // update field right
  assert {:msg "  175.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  Heap[this, AVLTreeNode.right] := null;
  assume wf(Heap, Mask, SecMask);
  // update field key
  assert {:msg "  176.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.key);
  Heap[this, AVLTreeNode.key] := k#8;
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_250 := Heap;
  assertMask#_251 := Mask;
  assertSecMask#_252 := SecMask;
  assertCredits#_253 := Credits;
  assume wf(assertHeap#_250, assertMask#_251, assertSecMask#_252);
  // begin exhale (assert)
  exhaleMask#_255 := assertMask#_251;
  havoc exhaleHeap#_254;
  exhaledHolds#_256 := ZeroRefSet;
  assert {:msg "  178.10: Sequence index might be negative."} true ==> (0 <= 0);
  assert {:msg "  178.10: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(k#8)));
  assert {:msg "  178.3: Assertion might not hold. The expression at 178.10 might not evaluate to true."} Seq#Index(Seq#Singleton(k#8), 0) == k#8;
  assertMask#_251 := exhaleMask#_255;
  assume IsGoodExhaleState(exhaleHeap#_254, assertHeap#_250, assertMask#_251, exhaledHolds#_256);
  assertHeap#_250 := exhaleHeap#_254;
  assume IsGoodMask(assertMask#_251);
  assume wf(assertHeap#_250, assertMask#_251, assertSecMask#_252);
  // end exhale
  assume (0.0 < methodCallK#_261) && ((1000.0 * methodCallK#_261) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_261) < methodK#_242);
  // call close
  callHeap#_257 := Heap;
  callMask#_258 := Mask;
  callSecMask#_259 := SecMask;
  callCredits#_260 := Credits;
  assume wf(callHeap#_257, callMask#_258, callSecMask#_259);
  assert {:msg "  179.3: The target of the method call might be null."} this != null;
  this#150 := this;
  // begin exhale (precondition)
  exhaleMask#_263 := Mask;
  havoc exhaleHeap#_262;
  exhaledHolds#_264 := ZeroRefSet;
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#151: int :: 
      (0 <= k#92#151) && (k#92#151 < Seq#Length(Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys], k#92#151) < Heap[this#150, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#152: int :: 
      (0 <= k#93#152) && (k#93#152 < Seq#Length(Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#150, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys], k#93#152))
    );
  }
  assert {:msg "  179.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#150, AVLTreeNode.left] == null, 0, Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#150, AVLTreeNode.right] == null, 0, Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  179.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#150, AVLTreeNode.left] == null, 0, Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#150, AVLTreeNode.right] == null, 0, Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  179.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  179.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_263[this#150, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[this#150, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_263[this#150, AVLTreeNode.key][perm$N]));
  exhaleMask#_263[this#150, AVLTreeNode.key] := exhaleMask#_263[this#150, AVLTreeNode.key][perm$R := exhaleMask#_263[this#150, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  179.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_263[this#150, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[this#150, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_263[this#150, AVLTreeNode.height][perm$N]));
  exhaleMask#_263[this#150, AVLTreeNode.height] := exhaleMask#_263[this#150, AVLTreeNode.height][perm$R := exhaleMask#_263[this#150, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  179.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_263[this#150, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[this#150, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_263[this#150, AVLTreeNode.left][perm$N]));
  exhaleMask#_263[this#150, AVLTreeNode.left] := exhaleMask#_263[this#150, AVLTreeNode.left][perm$R := exhaleMask#_263[this#150, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  179.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_263[this#150, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[this#150, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_263[this#150, AVLTreeNode.right][perm$N]));
  exhaleMask#_263[this#150, AVLTreeNode.right] := exhaleMask#_263[this#150, AVLTreeNode.right][perm$R := exhaleMask#_263[this#150, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  179.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_263[this#150, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[this#150, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_263[this#150, AVLTreeNode.keys][perm$N]));
  exhaleMask#_263[this#150, AVLTreeNode.keys] := exhaleMask#_263[this#150, AVLTreeNode.keys][perm$R := exhaleMask#_263[this#150, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  179.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  179.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_263[this#150, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[this#150, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_263[this#150, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_263[this#150, AVLTreeNode.balanceFactor] := exhaleMask#_263[this#150, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_263[this#150, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_263, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_263, Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_262[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_263, Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_262[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#150, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  179.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_263[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_263;
  assume IsGoodExhaleState(exhaleHeap#_262, Heap, Mask, exhaledHolds#_264);
  Heap := exhaleHeap#_262;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#150, AVLTreeNode.valid] := Mask[this#150, AVLTreeNode.valid][perm$R := Mask[this#150, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#150, AVLTreeNode.height] := Mask[this#150, AVLTreeNode.height][perm$R := Mask[this#150, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#150, AVLTreeNode.keys] := Mask[this#150, AVLTreeNode.keys][perm$R := Mask[this#150, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#150 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#150, AVLTreeNode.balanceFactor] := Mask[this#150, AVLTreeNode.balanceFactor][perm$R := Mask[this#150, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#150, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_257[this#150, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_257[callHeap#_257[this#150, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_257[this#150, AVLTreeNode.key])), ite(callHeap#_257[this#150, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_257[callHeap#_257[this#150, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#150, AVLTreeNode.height] == ite(ite(callHeap#_257[this#150, AVLTreeNode.left] == null, 0, callHeap#_257[callHeap#_257[this#150, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_257[this#150, AVLTreeNode.right] == null, 0, callHeap#_257[callHeap#_257[this#150, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_257[this#150, AVLTreeNode.left] == null, 0, callHeap#_257[callHeap#_257[this#150, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_257[this#150, AVLTreeNode.right] == null, 0, callHeap#_257[callHeap#_257[this#150, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#150, AVLTreeNode.balanceFactor] == (ite(callHeap#_257[this#150, AVLTreeNode.left] == null, 0, callHeap#_257[callHeap#_257[this#150, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_257[this#150, AVLTreeNode.right] == null, 0, callHeap#_257[callHeap#_257[this#150, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_283 := Mask;
  havoc exhaleHeap#_282;
  exhaledHolds#_284 := ZeroRefSet;
  assert {:msg "  154.2: The postcondition at 168.11 might not hold. The expression at 168.11 might not evaluate to true."} Heap[this, AVLTreeNode.height] == 1;
  assert {:msg "  154.2: The postcondition at 169.11 might not hold. The expression at 169.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Singleton(k#8));
  assert {:msg "  154.2: The postcondition at 170.11 might not hold. The expression at 170.11 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == 0;
  assert {:msg "  154.2: The postcondition at 172.11 might not hold. The expression at 172.11 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], k#8);
  assert {:msg "  154.2: The postcondition at 163.11 might not hold. The permission at 163.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  154.2: The postcondition at 163.11 might not hold. Insufficient fraction at 163.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_283[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_283[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_283[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_283[this, AVLTreeNode.valid] := exhaleMask#_283[this, AVLTreeNode.valid][perm$R := exhaleMask#_283[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_283, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_282[this, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_283, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  154.2: The postcondition at 164.11 might not hold. The permission at 164.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  154.2: The postcondition at 164.11 might not hold. Insufficient fraction at 164.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_283[this, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_283[this, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_283[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_283[this, AVLTreeNode.keys] := exhaleMask#_283[this, AVLTreeNode.keys][perm$R := exhaleMask#_283[this, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_283, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  154.2: The postcondition at 165.11 might not hold. The permission at 165.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  154.2: The postcondition at 165.11 might not hold. Insufficient fraction at 165.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_283[this, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_283[this, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_283[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_283[this, AVLTreeNode.height] := exhaleMask#_283[this, AVLTreeNode.height][perm$R := exhaleMask#_283[this, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_283, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  154.2: The postcondition at 166.11 might not hold. The permission at 166.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  154.2: The postcondition at 166.11 might not hold. Insufficient fraction at 166.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_283[this, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_283[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_283[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_283[this, AVLTreeNode.balanceFactor] := exhaleMask#_283[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_283[this, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_283, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_283;
  assume IsGoodExhaleState(exhaleHeap#_282, Heap, Mask, exhaledHolds#_284);
  Heap := exhaleHeap#_282;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  154.2: Method might lock/unlock more than allowed."} (forall lk#_289: ref :: 
    { Heap[lk#_289, held] }
    { Heap[lk#_289, rdheld] }
    (((0 < Heap[lk#_289, held]) == (0 < old(Heap)[lk#_289, held])) && (Heap[lk#_289, rdheld] == old(Heap)[lk#_289, rdheld])) || false
  );
  assert {:msg "  154.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.insert
// -------------------------------------------

// definedness check for method AVLTreeNode.insert
procedure AVLTreeNode.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_290: real;
  var i#82#156: int where true;
  var i#83#158: int where true;
  assume (0.0 < methodK#_290) && ((1000.0 * methodK#_290) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  185.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_293: Field (PMaskType) :: 
    (forall ref#_292: ref :: 
      Heap[ref#_292, pmask#_293] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#10 == null);
  assert {:msg "  191.11: Receiver might be null."} r#10 != null;
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#10, AVLTreeNode.valid] := Mask[r#10, AVLTreeNode.valid][perm$R := Mask[r#10, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#10, AVLTreeNode.keys] := Mask[r#10, AVLTreeNode.keys][perm$R := Mask[r#10, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#10, AVLTreeNode.height] := Mask[r#10, AVLTreeNode.height][perm$R := Mask[r#10, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#10 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#10, AVLTreeNode.balanceFactor] := Mask[r#10, AVLTreeNode.balanceFactor][perm$R := Mask[r#10, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  196.16: Receiver might be null."} true ==> (r#10 != null);
  assert {:msg "  196.16: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assume Seq#Contains(Heap[r#10, AVLTreeNode.keys], k#9);
  assert {:msg "  197.11: Receiver might be null."} true && (0 <= i#82#156) ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true && (0 <= i#82#156) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assert {:msg "  197.11: Receiver might be null."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assert {:msg "  197.36: Sequence index might be negative."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (0 <= i#82#156);
  assert {:msg "  197.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
  assert {:msg "  197.41: Receiver might be null."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (r#10 != null);
  assert {:msg "  197.41: Location might not be readable."} true && (0 <= i#82#156) && (i#82#156 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assume (forall i#82#155: int :: 
    (0 <= i#82#155) && (i#82#155 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#10, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#82#155))
  );
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#83#158) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#83#158) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.35: Sequence index might be negative."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (0 <= i#83#158);
  assert {:msg "  198.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys]));
  assert {:msg "  198.44: Receiver might be null."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  198.44: Location might not be readable."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.35: Sequence index might be negative."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> (0 <= i#83#158);
  assert {:msg "  198.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#83#158) && (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#158))) ==> (i#83#158 < Seq#Length(Heap[r#10, AVLTreeNode.keys]));
  assume (forall i#83#157: int :: 
    (0 <= i#83#157) && (i#83#157 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#157)) || (Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#157) == k#9))
  );
  assert {:msg "  199.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  199.20: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  199.30: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  199.30: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.keys);
    assert {:msg "  199.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  199.42: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume Seq#Equal(Heap[r#10, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  assert {:msg "  200.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  200.22: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  200.34: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  200.34: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.keys);
    assert {:msg "  200.50: Receiver might be null."} true ==> (this != null);
    assert {:msg "  200.50: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume Seq#Length(Heap[r#10, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) + 1);
  }
  assert {:msg "  202.13: Receiver might be null."} true ==> (r#10 != null);
  assert {:msg "  202.13: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.height);
  assert {:msg "  202.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  202.29: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  assert {:msg "  202.44: Receiver might be null."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#10 != null);
  assert {:msg "  202.44: Location might not be readable."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#10, AVLTreeNode.height);
  assert {:msg "  202.60: Receiver might be null."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  202.60: Location might not be readable."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
  assume (Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#10, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] + 1));
  assert {:msg "  203.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  203.20: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  203.30: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  203.30: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.height);
    assert {:msg "  203.44: Receiver might be null."} true ==> (this != null);
    assert {:msg "  203.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.insert
procedure AVLTreeNode.insert(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_290: real;
  var predRec#_299: ref;
  var predVer#_300: int;
  var unfoldK#_298: real;
  var oldVers#_305: int;
  var newVers#_306: int;
  var cond#_308: bool;
  var assertHeap#_309: HeapType;
  var assertMask#_310: MaskType;
  var assertSecMask#_311: MaskType;
  var assertCredits#_312: CreditsType;
  var exhaleMask#_314: MaskType;
  var exhaleHeap#_313: HeapType;
  var exhaledHolds#_315: RefSet;
  var methodCallK#_320: real;
  var this#161: ref where (this#161 == null) || (dtype(this#161) == AVLTreeNode#t);
  var callHeap#_316: HeapType;
  var callMask#_317: MaskType;
  var callSecMask#_318: MaskType;
  var callCredits#_319: CreditsType;
  var exhaleMask#_322: MaskType;
  var exhaleHeap#_321: HeapType;
  var exhaledHolds#_323: RefSet;
  var isHeld#_338: int;
  var isRdHeld#_339: bool;
  var cond#_341: bool;
  var nl#12: ref where (nl#12 == null) || (dtype(nl#12) == AVLTreeNode#t);
  var cond#_342: bool;
  var nw#_343: ref;
  var methodCallK#_348: real;
  var this#166: ref where (this#166 == null) || (dtype(this#166) == AVLTreeNode#t);
  var k#167: int where true;
  var callHeap#_344: HeapType;
  var callMask#_345: MaskType;
  var callSecMask#_346: MaskType;
  var callCredits#_347: CreditsType;
  var exhaleMask#_350: MaskType;
  var exhaleHeap#_349: HeapType;
  var exhaledHolds#_351: RefSet;
  var isHeld#_358: int;
  var isRdHeld#_359: bool;
  var methodCallK#_365: real;
  var this#168: ref where (this#168 == null) || (dtype(this#168) == AVLTreeNode#t);
  var k#169: int where true;
  var r#170: ref where (r#170 == null) || (dtype(r#170) == AVLTreeNode#t);
  var callHeap#_361: HeapType;
  var callMask#_362: MaskType;
  var callSecMask#_363: MaskType;
  var callCredits#_364: CreditsType;
  var exhaleMask#_367: MaskType;
  var exhaleHeap#_366: HeapType;
  var exhaledHolds#_368: RefSet;
  var isHeld#_373: int;
  var isRdHeld#_374: bool;
  var bf#14: int where true;
  var methodCallK#_380: real;
  var this#173: ref where (this#173 == null) || (dtype(this#173) == AVLTreeNode#t);
  var bf#174: int where true;
  var callHeap#_376: HeapType;
  var callMask#_377: MaskType;
  var callSecMask#_378: MaskType;
  var callCredits#_379: CreditsType;
  var exhaleMask#_382: MaskType;
  var exhaleHeap#_381: HeapType;
  var exhaledHolds#_383: RefSet;
  var isHeld#_390: int;
  var isRdHeld#_391: bool;
  var cond#_393: bool;
  var methodCallK#_398: real;
  var this#175: ref where (this#175 == null) || (dtype(this#175) == AVLTreeNode#t);
  var r#176: ref where (r#176 == null) || (dtype(r#176) == AVLTreeNode#t);
  var callHeap#_394: HeapType;
  var callMask#_395: MaskType;
  var callSecMask#_396: MaskType;
  var callCredits#_397: CreditsType;
  var exhaleMask#_400: MaskType;
  var exhaleHeap#_399: HeapType;
  var exhaledHolds#_401: RefSet;
  var isHeld#_416: int;
  var isRdHeld#_417: bool;
  var methodCallK#_423: real;
  var this#181: ref where (this#181 == null) || (dtype(this#181) == AVLTreeNode#t);
  var callHeap#_419: HeapType;
  var callMask#_420: MaskType;
  var callSecMask#_421: MaskType;
  var callCredits#_422: CreditsType;
  var exhaleMask#_425: MaskType;
  var exhaleHeap#_424: HeapType;
  var exhaledHolds#_426: RefSet;
  var isHeld#_441: int;
  var isRdHeld#_442: bool;
  var nr#16: ref where (nr#16 == null) || (dtype(nr#16) == AVLTreeNode#t);
  var cond#_444: bool;
  var nw#_445: ref;
  var methodCallK#_450: real;
  var this#186: ref where (this#186 == null) || (dtype(this#186) == AVLTreeNode#t);
  var k#187: int where true;
  var callHeap#_446: HeapType;
  var callMask#_447: MaskType;
  var callSecMask#_448: MaskType;
  var callCredits#_449: CreditsType;
  var exhaleMask#_452: MaskType;
  var exhaleHeap#_451: HeapType;
  var exhaledHolds#_453: RefSet;
  var isHeld#_460: int;
  var isRdHeld#_461: bool;
  var methodCallK#_467: real;
  var this#188: ref where (this#188 == null) || (dtype(this#188) == AVLTreeNode#t);
  var k#189: int where true;
  var r#190: ref where (r#190 == null) || (dtype(r#190) == AVLTreeNode#t);
  var callHeap#_463: HeapType;
  var callMask#_464: MaskType;
  var callSecMask#_465: MaskType;
  var callCredits#_466: CreditsType;
  var exhaleMask#_469: MaskType;
  var exhaleHeap#_468: HeapType;
  var exhaledHolds#_470: RefSet;
  var isHeld#_475: int;
  var isRdHeld#_476: bool;
  var bf#18: int where true;
  var methodCallK#_482: real;
  var this#193: ref where (this#193 == null) || (dtype(this#193) == AVLTreeNode#t);
  var bf#194: int where true;
  var callHeap#_478: HeapType;
  var callMask#_479: MaskType;
  var callSecMask#_480: MaskType;
  var callCredits#_481: CreditsType;
  var exhaleMask#_484: MaskType;
  var exhaleHeap#_483: HeapType;
  var exhaledHolds#_485: RefSet;
  var isHeld#_492: int;
  var isRdHeld#_493: bool;
  var cond#_495: bool;
  var methodCallK#_500: real;
  var this#195: ref where (this#195 == null) || (dtype(this#195) == AVLTreeNode#t);
  var r#196: ref where (r#196 == null) || (dtype(r#196) == AVLTreeNode#t);
  var callHeap#_496: HeapType;
  var callMask#_497: MaskType;
  var callSecMask#_498: MaskType;
  var callCredits#_499: CreditsType;
  var exhaleMask#_502: MaskType;
  var exhaleHeap#_501: HeapType;
  var exhaledHolds#_503: RefSet;
  var isHeld#_518: int;
  var isRdHeld#_519: bool;
  var methodCallK#_525: real;
  var this#201: ref where (this#201 == null) || (dtype(this#201) == AVLTreeNode#t);
  var callHeap#_521: HeapType;
  var callMask#_522: MaskType;
  var callSecMask#_523: MaskType;
  var callCredits#_524: CreditsType;
  var exhaleMask#_527: MaskType;
  var exhaleHeap#_526: HeapType;
  var exhaledHolds#_528: RefSet;
  var isHeld#_543: int;
  var isRdHeld#_544: bool;
  var exhaleMask#_547: MaskType;
  var exhaleHeap#_546: HeapType;
  var exhaledHolds#_548: RefSet;
  assume (0.0 < methodK#_290) && ((1000.0 * methodK#_290) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_297: Field (PMaskType) :: 
    (forall ref#_296: ref :: 
      Heap[ref#_296, pmask#_297] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  predRec#_299 := this;
  predVer#_300 := Heap[this, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_298) && (unfoldK#_298 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_298) < methodK#_290);
  assert {:msg "  205.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  205.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  205.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTreeNode.valid)) {
    oldVers#_305 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_306;
    Heap[this, AVLTreeNode.valid] := newVers#_306;
    assume oldVers#_305 < Heap[this, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_299, AVLTreeNode.valid, predVer#_300, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#159: int :: 
      (0 <= lk#79#159) && (lk#79#159 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#159) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_299, AVLTreeNode.valid, predVer#_300, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#160: int :: 
      (0 <= rk#80#160) && (rk#80#160 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#160))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_308 := Heap[this, AVLTreeNode.key] == k#9;
  assert {:msg "  206.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  206.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (cond#_308) {
    // assigment to r
    r#10 := this;
    // assert
    assertHeap#_309 := Heap;
    assertMask#_310 := Mask;
    assertSecMask#_311 := SecMask;
    assertCredits#_312 := Credits;
    assume wf(assertHeap#_309, assertMask#_310, assertSecMask#_311);
    // begin exhale (assert)
    exhaleMask#_314 := assertMask#_310;
    havoc exhaleHeap#_313;
    exhaledHolds#_315 := ZeroRefSet;
    assert {:msg "  208.15: Receiver might be null."} true ==> (this != null);
    assert {:msg "  208.15: Location might not be readable."} true ==> CanRead(assertMask#_310, this, AVLTreeNode.key);
    assert {:msg "  208.14: Sequence index might be negative."} true ==> (0 <= 0);
    assert {:msg "  208.14: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(assertHeap#_309[this, AVLTreeNode.key])));
    assert {:msg "  208.4: Assertion might not hold. The expression at 208.11 might not evaluate to true."} k#9 == Seq#Index(Seq#Singleton(assertHeap#_309[this, AVLTreeNode.key]), 0);
    assertMask#_310 := exhaleMask#_314;
    assume IsGoodExhaleState(exhaleHeap#_313, assertHeap#_309, assertMask#_310, exhaledHolds#_315);
    assertHeap#_309 := exhaleHeap#_313;
    assume IsGoodMask(assertMask#_310);
    assume wf(assertHeap#_309, assertMask#_310, assertSecMask#_311);
    // end exhale
    assume (0.0 < methodCallK#_320) && ((1000.0 * methodCallK#_320) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_320) < methodK#_290);
    // call close
    callHeap#_316 := Heap;
    callMask#_317 := Mask;
    callSecMask#_318 := SecMask;
    callCredits#_319 := Credits;
    assume wf(callHeap#_316, callMask#_317, callSecMask#_318);
    assert {:msg "  209.4: The target of the method call might be null."} r#10 != null;
    this#161 := r#10;
    // begin exhale (precondition)
    exhaleMask#_322 := Mask;
    havoc exhaleHeap#_321;
    exhaledHolds#_323 := ZeroRefSet;
    if (!(Heap[this#161, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#162: int :: 
        (0 <= k#92#162) && (k#92#162 < Seq#Length(Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys], k#92#162) < Heap[this#161, AVLTreeNode.key])
      );
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#163: int :: 
        (0 <= k#93#163) && (k#93#163 < Seq#Length(Heap[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#161, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys], k#93#163))
      );
    }
    assert {:msg "  209.4: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#161, AVLTreeNode.left] == null, 0, Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#161, AVLTreeNode.right] == null, 0, Heap[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  209.4: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#161, AVLTreeNode.left] == null, 0, Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#161, AVLTreeNode.right] == null, 0, Heap[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    assert {:msg "  209.4: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  209.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_322[this#161, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[this#161, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_322[this#161, AVLTreeNode.key][perm$N]));
    exhaleMask#_322[this#161, AVLTreeNode.key] := exhaleMask#_322[this#161, AVLTreeNode.key][perm$R := exhaleMask#_322[this#161, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_322, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  209.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_322[this#161, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[this#161, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_322[this#161, AVLTreeNode.height][perm$N]));
    exhaleMask#_322[this#161, AVLTreeNode.height] := exhaleMask#_322[this#161, AVLTreeNode.height][perm$R := exhaleMask#_322[this#161, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_322, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  209.4: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_322[this#161, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[this#161, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_322[this#161, AVLTreeNode.left][perm$N]));
    exhaleMask#_322[this#161, AVLTreeNode.left] := exhaleMask#_322[this#161, AVLTreeNode.left][perm$R := exhaleMask#_322[this#161, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_322, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  209.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_322[this#161, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[this#161, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_322[this#161, AVLTreeNode.right][perm$N]));
    exhaleMask#_322[this#161, AVLTreeNode.right] := exhaleMask#_322[this#161, AVLTreeNode.right][perm$R := exhaleMask#_322[this#161, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_322, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  209.4: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_322[this#161, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[this#161, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_322[this#161, AVLTreeNode.keys][perm$N]));
    exhaleMask#_322[this#161, AVLTreeNode.keys] := exhaleMask#_322[this#161, AVLTreeNode.keys][perm$R := exhaleMask#_322[this#161, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_322, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  209.4: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  209.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_322[this#161, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[this#161, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_322[this#161, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_322[this#161, AVLTreeNode.balanceFactor] := exhaleMask#_322[this#161, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_322[this#161, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_322, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#161, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_322, Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_321[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_322, Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_321[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  209.4: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_322[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_322, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_322;
    assume IsGoodExhaleState(exhaleHeap#_321, Heap, Mask, exhaledHolds#_323);
    Heap := exhaleHeap#_321;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#161 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[this#161, AVLTreeNode.valid] := Mask[this#161, AVLTreeNode.valid][perm$R := Mask[this#161, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#161 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#161, AVLTreeNode.height] := Mask[this#161, AVLTreeNode.height][perm$R := Mask[this#161, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#161 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#161, AVLTreeNode.keys] := Mask[this#161, AVLTreeNode.keys][perm$R := Mask[this#161, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#161 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#161, AVLTreeNode.balanceFactor] := Mask[this#161, AVLTreeNode.balanceFactor][perm$R := Mask[this#161, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Equal(Heap[this#161, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_316[this#161, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_316[callHeap#_316[this#161, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_316[this#161, AVLTreeNode.key])), ite(callHeap#_316[this#161, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_316[callHeap#_316[this#161, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Heap[this#161, AVLTreeNode.height] == ite(ite(callHeap#_316[this#161, AVLTreeNode.left] == null, 0, callHeap#_316[callHeap#_316[this#161, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_316[this#161, AVLTreeNode.right] == null, 0, callHeap#_316[callHeap#_316[this#161, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_316[this#161, AVLTreeNode.left] == null, 0, callHeap#_316[callHeap#_316[this#161, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_316[this#161, AVLTreeNode.right] == null, 0, callHeap#_316[callHeap#_316[this#161, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#161, AVLTreeNode.balanceFactor] == (ite(callHeap#_316[this#161, AVLTreeNode.left] == null, 0, callHeap#_316[callHeap#_316[this#161, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_316[this#161, AVLTreeNode.right] == null, 0, callHeap#_316[callHeap#_316[this#161, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
  } else {
    // if
    cond#_341 := k#9 < Heap[this, AVLTreeNode.key];
    assert {:msg "  211.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  211.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (cond#_341) {
      // local var nl
      // if
      cond#_342 := Heap[this, AVLTreeNode.left] == null;
      assert {:msg "  213.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  213.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (cond#_342) {
        // assigment to nl
        // new
        havoc nw#_343;
        assume (nw#_343 != null) && (dtype(nw#_343) == AVLTreeNode#t);
        assume (forall<T#_5> f: Field (T#_5) :: 
          (Mask[nw#_343, f][perm$R] == 0.0) && (Mask[nw#_343, f][perm$N] == 0.0)
        );
        assume Heap[nw#_343, mu] == $LockBottom;
        assume Heap[nw#_343, held] <= 0;
        assume Heap[nw#_343, rdheld] == false;
        Mask[nw#_343, AVLTreeNode.key] := Mask[nw#_343, AVLTreeNode.key][perm$R := Mask[nw#_343, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
        Mask[nw#_343, AVLTreeNode.height] := Mask[nw#_343, AVLTreeNode.height][perm$R := Mask[nw#_343, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
        Mask[nw#_343, AVLTreeNode.left] := Mask[nw#_343, AVLTreeNode.left][perm$R := Mask[nw#_343, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
        Mask[nw#_343, AVLTreeNode.right] := Mask[nw#_343, AVLTreeNode.right][perm$R := Mask[nw#_343, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
        Mask[nw#_343, AVLTreeNode.keys] := Mask[nw#_343, AVLTreeNode.keys][perm$R := Mask[nw#_343, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
        Mask[nw#_343, AVLTreeNode.balanceFactor] := Mask[nw#_343, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_343, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
        Mask[nw#_343, mu] := Mask[nw#_343, mu][perm$R := Mask[nw#_343, mu][perm$R] + (real(100) * 0.01)];
        nl#12 := nw#_343;
        assume (0.0 < methodCallK#_348) && ((1000.0 * methodCallK#_348) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_348) < methodK#_290);
        // call init
        callHeap#_344 := Heap;
        callMask#_345 := Mask;
        callSecMask#_346 := SecMask;
        callCredits#_347 := Credits;
        assume wf(callHeap#_344, callMask#_345, callSecMask#_346);
        assert {:msg "  215.6: The target of the method call might be null."} nl#12 != null;
        this#166 := nl#12;
        k#167 := k#9;
        // begin exhale (precondition)
        exhaleMask#_350 := Mask;
        havoc exhaleHeap#_349;
        exhaledHolds#_351 := ZeroRefSet;
        assert {:msg "  215.6: The precondition at 155.12 might not hold. The permission at 155.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  215.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_350[this#166, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_350[this#166, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_350[this#166, AVLTreeNode.key][perm$N]));
        exhaleMask#_350[this#166, AVLTreeNode.key] := exhaleMask#_350[this#166, AVLTreeNode.key][perm$R := exhaleMask#_350[this#166, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_350, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 156.12 might not hold. The permission at 156.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  215.6: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_350[this#166, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_350[this#166, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_350[this#166, AVLTreeNode.height][perm$N]));
        exhaleMask#_350[this#166, AVLTreeNode.height] := exhaleMask#_350[this#166, AVLTreeNode.height][perm$R := exhaleMask#_350[this#166, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_350, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 157.12 might not hold. The permission at 157.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  215.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_350[this#166, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_350[this#166, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_350[this#166, AVLTreeNode.left][perm$N]));
        exhaleMask#_350[this#166, AVLTreeNode.left] := exhaleMask#_350[this#166, AVLTreeNode.left][perm$R := exhaleMask#_350[this#166, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_350, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 158.12 might not hold. The permission at 158.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  215.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_350[this#166, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_350[this#166, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_350[this#166, AVLTreeNode.right][perm$N]));
        exhaleMask#_350[this#166, AVLTreeNode.right] := exhaleMask#_350[this#166, AVLTreeNode.right][perm$R := exhaleMask#_350[this#166, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_350, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 160.12 might not hold. The permission at 160.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  215.6: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_350[this#166, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_350[this#166, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_350[this#166, AVLTreeNode.keys][perm$N]));
        exhaleMask#_350[this#166, AVLTreeNode.keys] := exhaleMask#_350[this#166, AVLTreeNode.keys][perm$R := exhaleMask#_350[this#166, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_350, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  215.6: The precondition at 161.12 might not hold. The permission at 161.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  215.6: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_350[this#166, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_350[this#166, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_350[this#166, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_350[this#166, AVLTreeNode.balanceFactor] := exhaleMask#_350[this#166, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_350[this#166, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_350, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_350;
        assume IsGoodExhaleState(exhaleHeap#_349, Heap, Mask, exhaledHolds#_351);
        Heap := exhaleHeap#_349;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#166 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#166, AVLTreeNode.valid] := Mask[this#166, AVLTreeNode.valid][perm$R := Mask[this#166, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#166 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#166, AVLTreeNode.keys] := Mask[this#166, AVLTreeNode.keys][perm$R := Mask[this#166, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#166 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#166, AVLTreeNode.height] := Mask[this#166, AVLTreeNode.height][perm$R := Mask[this#166, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#166 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#166, AVLTreeNode.balanceFactor] := Mask[this#166, AVLTreeNode.balanceFactor][perm$R := Mask[this#166, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[this#166, AVLTreeNode.height] == 1;
        assume Seq#Equal(Heap[this#166, AVLTreeNode.keys], Seq#Singleton(k#167));
        assume Heap[this#166, AVLTreeNode.balanceFactor] == 0;
        assume Seq#Contains(Heap[this#166, AVLTreeNode.keys], k#167);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      } else {
        assume (0.0 < methodCallK#_365) && ((1000.0 * methodCallK#_365) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_365) < methodK#_290);
        // call insert
        callHeap#_361 := Heap;
        callMask#_362 := Mask;
        callSecMask#_363 := SecMask;
        callCredits#_364 := Credits;
        assume wf(callHeap#_361, callMask#_362, callSecMask#_363);
        assert {:msg "  217.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  217.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  217.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#168 := Heap[this, AVLTreeNode.left];
        k#169 := k#9;
        // begin exhale (precondition)
        exhaleMask#_367 := Mask;
        havoc exhaleHeap#_366;
        exhaledHolds#_368 := ZeroRefSet;
        assert {:msg "  217.6: The precondition at 185.12 might not hold. The permission at 185.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  217.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_367[this#168, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_367[this#168, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_367[this#168, AVLTreeNode.valid][perm$N]));
        exhaleMask#_367[this#168, AVLTreeNode.valid] := exhaleMask#_367[this#168, AVLTreeNode.valid][perm$R := exhaleMask#_367[this#168, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_367, this#168, AVLTreeNode.valid)) {
          assume Heap[this#168, AVLTreeNode.valid] < exhaleHeap#_366[this#168, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  217.6: The precondition at 186.12 might not hold. The permission at 186.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  217.6: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_367[this#168, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_367[this#168, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_367[this#168, AVLTreeNode.keys][perm$N]));
        exhaleMask#_367[this#168, AVLTreeNode.keys] := exhaleMask#_367[this#168, AVLTreeNode.keys][perm$R := exhaleMask#_367[this#168, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  217.6: The precondition at 187.12 might not hold. The permission at 187.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  217.6: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_367[this#168, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_367[this#168, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_367[this#168, AVLTreeNode.height][perm$N]));
        exhaleMask#_367[this#168, AVLTreeNode.height] := exhaleMask#_367[this#168, AVLTreeNode.height][perm$R := exhaleMask#_367[this#168, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  217.6: The precondition at 188.12 might not hold. The permission at 188.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  217.6: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_367[this#168, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_367[this#168, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_367[this#168, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_367[this#168, AVLTreeNode.balanceFactor] := exhaleMask#_367[this#168, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_367[this#168, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_367, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_367;
        assume IsGoodExhaleState(exhaleHeap#_366, Heap, Mask, exhaledHolds#_368);
        Heap := exhaleHeap#_366;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#170;
        // inhale (postcondition)
        assume !(r#170 == null);
        assume r#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[r#170, AVLTreeNode.valid] := Mask[r#170, AVLTreeNode.valid][perm$R := Mask[r#170, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#170, AVLTreeNode.keys] := Mask[r#170, AVLTreeNode.keys][perm$R := Mask[r#170, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#170, AVLTreeNode.height] := Mask[r#170, AVLTreeNode.height][perm$R := Mask[r#170, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#170 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#170, AVLTreeNode.balanceFactor] := Mask[r#170, AVLTreeNode.balanceFactor][perm$R := Mask[r#170, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Contains(Heap[r#170, AVLTreeNode.keys], k#169);
        assume (forall i#82#171: int :: 
          (0 <= i#82#171) && (i#82#171 < Seq#Length(callHeap#_361[this#168, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#170, AVLTreeNode.keys], Seq#Index(callHeap#_361[this#168, AVLTreeNode.keys], i#82#171))
        );
        assume (forall i#83#172: int :: 
          (0 <= i#83#172) && (i#83#172 < Seq#Length(Heap[r#170, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_361[this#168, AVLTreeNode.keys], Seq#Index(Heap[r#170, AVLTreeNode.keys], i#83#172)) || (Seq#Index(Heap[r#170, AVLTreeNode.keys], i#83#172) == k#169))
        );
        if (Seq#Contains(callHeap#_361[this#168, AVLTreeNode.keys], k#169)) {
          assume Seq#Equal(Heap[r#170, AVLTreeNode.keys], callHeap#_361[this#168, AVLTreeNode.keys]);
        }
        if (!Seq#Contains(callHeap#_361[this#168, AVLTreeNode.keys], k#169)) {
          assume Seq#Length(Heap[r#170, AVLTreeNode.keys]) == (Seq#Length(callHeap#_361[this#168, AVLTreeNode.keys]) + 1);
        }
        assume (Heap[r#170, AVLTreeNode.height] == callHeap#_361[this#168, AVLTreeNode.height]) || (Heap[r#170, AVLTreeNode.height] == (callHeap#_361[this#168, AVLTreeNode.height] + 1));
        if (Seq#Contains(callHeap#_361[this#168, AVLTreeNode.keys], k#169)) {
          assume Heap[r#170, AVLTreeNode.height] == callHeap#_361[this#168, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nl#12 := r#170;
      }
      // update field left
      assert {:msg "  219.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
      Heap[this, AVLTreeNode.left] := nl#12;
      assume wf(Heap, Mask, SecMask);
      // local var bf
      assume (0.0 < methodCallK#_380) && ((1000.0 * methodCallK#_380) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_380) < methodK#_290);
      // call getBalanceFactorI
      callHeap#_376 := Heap;
      callMask#_377 := Mask;
      callSecMask#_378 := SecMask;
      callCredits#_379 := Credits;
      assume wf(callHeap#_376, callMask#_377, callSecMask#_378);
      assert {:msg "  221.5: The target of the method call might be null."} this != null;
      this#173 := this;
      // begin exhale (precondition)
      exhaleMask#_382 := Mask;
      havoc exhaleHeap#_381;
      exhaledHolds#_383 := ZeroRefSet;
      assert {:msg "  221.5: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_380 > 0.0;
      assert {:msg "  221.5: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_382[this#173, AVLTreeNode.left][perm$R] > 0.0;
      assume methodCallK#_380 < exhaleMask#_382[this#173, AVLTreeNode.left][perm$R];
      exhaleMask#_382[this#173, AVLTreeNode.left] := exhaleMask#_382[this#173, AVLTreeNode.left][perm$R := exhaleMask#_382[this#173, AVLTreeNode.left][perm$R] - methodCallK#_380];
      assume wf(Heap, exhaleMask#_382, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#173, AVLTreeNode.left] == null)) {
        assert {:msg "  221.5: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_380 > 0.0;
        assert {:msg "  221.5: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
        assume methodCallK#_380 < exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height][perm$R];
        exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_380];
        assume wf(Heap, exhaleMask#_382, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  221.5: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_380 > 0.0;
      assert {:msg "  221.5: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_382[this#173, AVLTreeNode.right][perm$R] > 0.0;
      assume methodCallK#_380 < exhaleMask#_382[this#173, AVLTreeNode.right][perm$R];
      exhaleMask#_382[this#173, AVLTreeNode.right] := exhaleMask#_382[this#173, AVLTreeNode.right][perm$R := exhaleMask#_382[this#173, AVLTreeNode.right][perm$R] - methodCallK#_380];
      assume wf(Heap, exhaleMask#_382, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#173, AVLTreeNode.right] == null)) {
        assert {:msg "  221.5: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_380 > 0.0;
        assert {:msg "  221.5: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
        assume methodCallK#_380 < exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height][perm$R];
        exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_380];
        assume wf(Heap, exhaleMask#_382, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#173, AVLTreeNode.left] == null)) {
        assert {:msg "  221.5: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  221.5: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_382[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_382, Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_381[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_382, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#173, AVLTreeNode.right] == null)) {
        assert {:msg "  221.5: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  221.5: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_382[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_382, Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_381[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_382, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_382;
      assume IsGoodExhaleState(exhaleHeap#_381, Heap, Mask, exhaledHolds#_383);
      Heap := exhaleHeap#_381;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc bf#174;
      // inhale (postcondition)
      assume this#173 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#173, AVLTreeNode.left] == null) || (dtype(Heap[this#173, AVLTreeNode.left]) == AVLTreeNode#t);
      assume methodCallK#_380 > 0.0;
      Mask[this#173, AVLTreeNode.left] := Mask[this#173, AVLTreeNode.left][perm$R := Mask[this#173, AVLTreeNode.left][perm$R] + methodCallK#_380];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#173, AVLTreeNode.left] == null)) {
        assume Heap[this#173, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#173, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#173, AVLTreeNode.left] == null)) {
        assume Heap[this#173, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_380 > 0.0;
        Mask[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_380];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume this#173 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#173, AVLTreeNode.right] == null) || (dtype(Heap[this#173, AVLTreeNode.right]) == AVLTreeNode#t);
      assume methodCallK#_380 > 0.0;
      Mask[this#173, AVLTreeNode.right] := Mask[this#173, AVLTreeNode.right][perm$R := Mask[this#173, AVLTreeNode.right][perm$R] + methodCallK#_380];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#173, AVLTreeNode.right] == null)) {
        assume Heap[this#173, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#173, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#173, AVLTreeNode.right] == null)) {
        assume Heap[this#173, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_380 > 0.0;
        Mask[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_380];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume bf#174 == (ite(Heap[this#173, AVLTreeNode.left] == null, 0, Heap[Heap[this#173, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#173, AVLTreeNode.right] == null, 0, Heap[Heap[this#173, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#174 > 0) {
        assume !(Heap[this#173, AVLTreeNode.left] == null);
      }
      if (bf#174 < 0) {
        assume !(Heap[this#173, AVLTreeNode.right] == null);
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      bf#14 := bf#174;
      // if
      cond#_393 := bf#14 == 2;
      if (cond#_393) {
        assume (0.0 < methodCallK#_398) && ((1000.0 * methodCallK#_398) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_398) < methodK#_290);
        // call rebalanceLeft
        callHeap#_394 := Heap;
        callMask#_395 := Mask;
        callSecMask#_396 := SecMask;
        callCredits#_397 := Credits;
        assume wf(callHeap#_394, callMask#_395, callSecMask#_396);
        assert {:msg "  224.6: The target of the method call might be null."} this != null;
        this#175 := this;
        // begin exhale (precondition)
        exhaleMask#_400 := Mask;
        havoc exhaleHeap#_399;
        exhaledHolds#_401 := ZeroRefSet;
        assert {:msg "  224.6: The precondition at 608.12 might not hold. The expression at 608.12 might not evaluate to true."} !(Heap[this#175, AVLTreeNode.left] == null);
        assert {:msg "  224.6: The precondition at 613.12 might not hold. The expression at 613.12 might not evaluate to true."} (forall k#94#177: int :: 
          (0 <= k#94#177) && (k#94#177 < Seq#Length(Heap[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys], k#94#177) < Heap[this#175, AVLTreeNode.key])
        );
        if (!(Heap[this#175, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 619.12 might not hold. The expression at 619.28 might not evaluate to true."} (forall k#95#178: int :: 
            (0 <= k#95#178) && (k#95#178 < Seq#Length(Heap[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#175, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys], k#95#178))
          );
        }
        assert {:msg "  224.6: The precondition at 621.12 might not hold. The expression at 621.12 might not evaluate to true."} (Heap[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#175, AVLTreeNode.right] == null, 0, Heap[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height])) == 2;
        assert {:msg "  224.6: The precondition at 600.12 might not hold. The permission at 600.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_400[this#175, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[this#175, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_400[this#175, AVLTreeNode.key][perm$N]));
        exhaleMask#_400[this#175, AVLTreeNode.key] := exhaleMask#_400[this#175, AVLTreeNode.key][perm$R := exhaleMask#_400[this#175, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 601.12 might not hold. The permission at 601.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_400[this#175, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[this#175, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_400[this#175, AVLTreeNode.height][perm$N]));
        exhaleMask#_400[this#175, AVLTreeNode.height] := exhaleMask#_400[this#175, AVLTreeNode.height][perm$R := exhaleMask#_400[this#175, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 602.12 might not hold. The permission at 602.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 602.12 might not hold. Insufficient fraction at 602.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_400[this#175, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[this#175, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_400[this#175, AVLTreeNode.left][perm$N]));
        exhaleMask#_400[this#175, AVLTreeNode.left] := exhaleMask#_400[this#175, AVLTreeNode.left][perm$R := exhaleMask#_400[this#175, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 603.12 might not hold. The permission at 603.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_400[this#175, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[this#175, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_400[this#175, AVLTreeNode.right][perm$N]));
        exhaleMask#_400[this#175, AVLTreeNode.right] := exhaleMask#_400[this#175, AVLTreeNode.right][perm$R := exhaleMask#_400[this#175, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 605.12 might not hold. The permission at 605.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 605.12 might not hold. Insufficient fraction at 605.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_400[this#175, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[this#175, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_400[this#175, AVLTreeNode.keys][perm$N]));
        exhaleMask#_400[this#175, AVLTreeNode.keys] := exhaleMask#_400[this#175, AVLTreeNode.keys][perm$R := exhaleMask#_400[this#175, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 606.12 might not hold. The permission at 606.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 606.12 might not hold. Insufficient fraction at 606.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_400[this#175, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[this#175, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_400[this#175, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_400[this#175, AVLTreeNode.balanceFactor] := exhaleMask#_400[this#175, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_400[this#175, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 609.12 might not hold. The permission at 609.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_400, Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_399[Heap[this#175, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 610.12 might not hold. The permission at 610.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 611.12 might not hold. The permission at 611.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 611.12 might not hold. Insufficient fraction at 611.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  224.6: The precondition at 612.12 might not hold. The permission at 612.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  224.6: The precondition at 612.12 might not hold. Insufficient fraction at 612.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_400, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#175, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 615.12 might not hold. The permission at 615.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  224.6: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_400, Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_399[Heap[this#175, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_400, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#175, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 616.12 might not hold. The permission at 616.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  224.6: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_400, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#175, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 617.12 might not hold. The permission at 617.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  224.6: The precondition at 617.12 might not hold. Insufficient fraction at 617.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_400, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#175, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 618.12 might not hold. The permission at 618.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  224.6: The precondition at 618.12 might not hold. Insufficient fraction at 618.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_400[Heap[this#175, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_400, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_400;
        assume IsGoodExhaleState(exhaleHeap#_399, Heap, Mask, exhaledHolds#_401);
        Heap := exhaleHeap#_399;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#176;
        // inhale (postcondition)
        assume !(r#176 == null);
        assume r#176 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[r#176, AVLTreeNode.valid] := Mask[r#176, AVLTreeNode.valid][perm$R := Mask[r#176, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#176 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#176, AVLTreeNode.height] := Mask[r#176, AVLTreeNode.height][perm$R := Mask[r#176, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#176 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#176, AVLTreeNode.keys] := Mask[r#176, AVLTreeNode.keys][perm$R := Mask[r#176, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#176 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#176, AVLTreeNode.balanceFactor] := Mask[r#176, AVLTreeNode.balanceFactor][perm$R := Mask[r#176, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume (Heap[r#176, AVLTreeNode.height] == callHeap#_394[callHeap#_394[this#175, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#176, AVLTreeNode.height] == (callHeap#_394[callHeap#_394[this#175, AVLTreeNode.left], AVLTreeNode.height] + 1));
        assume Seq#Equal(Heap[r#176, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_394[callHeap#_394[this#175, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_394[this#175, AVLTreeNode.key])), ite(callHeap#_394[this#175, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_394[callHeap#_394[this#175, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        r#10 := r#176;
      } else {
        // assigment to r
        r#10 := this;
        assume (0.0 < methodCallK#_423) && ((1000.0 * methodCallK#_423) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_423) < methodK#_290);
        // call close
        callHeap#_419 := Heap;
        callMask#_420 := Mask;
        callSecMask#_421 := SecMask;
        callCredits#_422 := Credits;
        assume wf(callHeap#_419, callMask#_420, callSecMask#_421);
        assert {:msg "  227.6: The target of the method call might be null."} r#10 != null;
        this#181 := r#10;
        // begin exhale (precondition)
        exhaleMask#_425 := Mask;
        havoc exhaleHeap#_424;
        exhaledHolds#_426 := ZeroRefSet;
        if (!(Heap[this#181, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#182: int :: 
            (0 <= k#92#182) && (k#92#182 < Seq#Length(Heap[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys], k#92#182) < Heap[this#181, AVLTreeNode.key])
          );
        }
        if (!(Heap[this#181, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#183: int :: 
            (0 <= k#93#183) && (k#93#183 < Seq#Length(Heap[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#181, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys], k#93#183))
          );
        }
        assert {:msg "  227.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#181, AVLTreeNode.left] == null, 0, Heap[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#181, AVLTreeNode.right] == null, 0, Heap[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  227.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#181, AVLTreeNode.left] == null, 0, Heap[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#181, AVLTreeNode.right] == null, 0, Heap[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  227.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  227.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_425[this#181, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[this#181, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_425[this#181, AVLTreeNode.key][perm$N]));
        exhaleMask#_425[this#181, AVLTreeNode.key] := exhaleMask#_425[this#181, AVLTreeNode.key][perm$R := exhaleMask#_425[this#181, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_425, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  227.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_425[this#181, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[this#181, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_425[this#181, AVLTreeNode.height][perm$N]));
        exhaleMask#_425[this#181, AVLTreeNode.height] := exhaleMask#_425[this#181, AVLTreeNode.height][perm$R := exhaleMask#_425[this#181, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_425, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  227.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_425[this#181, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[this#181, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_425[this#181, AVLTreeNode.left][perm$N]));
        exhaleMask#_425[this#181, AVLTreeNode.left] := exhaleMask#_425[this#181, AVLTreeNode.left][perm$R := exhaleMask#_425[this#181, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_425, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  227.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_425[this#181, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[this#181, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_425[this#181, AVLTreeNode.right][perm$N]));
        exhaleMask#_425[this#181, AVLTreeNode.right] := exhaleMask#_425[this#181, AVLTreeNode.right][perm$R := exhaleMask#_425[this#181, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_425, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  227.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_425[this#181, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[this#181, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_425[this#181, AVLTreeNode.keys][perm$N]));
        exhaleMask#_425[this#181, AVLTreeNode.keys] := exhaleMask#_425[this#181, AVLTreeNode.keys][perm$R := exhaleMask#_425[this#181, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_425, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  227.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  227.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_425[this#181, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[this#181, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_425[this#181, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_425[this#181, AVLTreeNode.balanceFactor] := exhaleMask#_425[this#181, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_425[this#181, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_425, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#181, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_425, Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_424[Heap[this#181, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_425, Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_424[Heap[this#181, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#181, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  227.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_425[Heap[this#181, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_425, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_425;
        assume IsGoodExhaleState(exhaleHeap#_424, Heap, Mask, exhaledHolds#_426);
        Heap := exhaleHeap#_424;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#181 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#181, AVLTreeNode.valid] := Mask[this#181, AVLTreeNode.valid][perm$R := Mask[this#181, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#181 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#181, AVLTreeNode.height] := Mask[this#181, AVLTreeNode.height][perm$R := Mask[this#181, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#181 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#181, AVLTreeNode.keys] := Mask[this#181, AVLTreeNode.keys][perm$R := Mask[this#181, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#181 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#181, AVLTreeNode.balanceFactor] := Mask[this#181, AVLTreeNode.balanceFactor][perm$R := Mask[this#181, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#181, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_419[this#181, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_419[callHeap#_419[this#181, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_419[this#181, AVLTreeNode.key])), ite(callHeap#_419[this#181, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_419[callHeap#_419[this#181, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#181, AVLTreeNode.height] == ite(ite(callHeap#_419[this#181, AVLTreeNode.left] == null, 0, callHeap#_419[callHeap#_419[this#181, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_419[this#181, AVLTreeNode.right] == null, 0, callHeap#_419[callHeap#_419[this#181, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_419[this#181, AVLTreeNode.left] == null, 0, callHeap#_419[callHeap#_419[this#181, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_419[this#181, AVLTreeNode.right] == null, 0, callHeap#_419[callHeap#_419[this#181, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#181, AVLTreeNode.balanceFactor] == (ite(callHeap#_419[this#181, AVLTreeNode.left] == null, 0, callHeap#_419[callHeap#_419[this#181, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_419[this#181, AVLTreeNode.right] == null, 0, callHeap#_419[callHeap#_419[this#181, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    } else {
      // local var nr
      // if
      cond#_444 := Heap[this, AVLTreeNode.right] == null;
      assert {:msg "  231.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  231.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (cond#_444) {
        // assigment to nr
        // new
        havoc nw#_445;
        assume (nw#_445 != null) && (dtype(nw#_445) == AVLTreeNode#t);
        assume (forall<T#_6> f: Field (T#_6) :: 
          (Mask[nw#_445, f][perm$R] == 0.0) && (Mask[nw#_445, f][perm$N] == 0.0)
        );
        assume Heap[nw#_445, mu] == $LockBottom;
        assume Heap[nw#_445, held] <= 0;
        assume Heap[nw#_445, rdheld] == false;
        Mask[nw#_445, AVLTreeNode.key] := Mask[nw#_445, AVLTreeNode.key][perm$R := Mask[nw#_445, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
        Mask[nw#_445, AVLTreeNode.height] := Mask[nw#_445, AVLTreeNode.height][perm$R := Mask[nw#_445, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
        Mask[nw#_445, AVLTreeNode.left] := Mask[nw#_445, AVLTreeNode.left][perm$R := Mask[nw#_445, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
        Mask[nw#_445, AVLTreeNode.right] := Mask[nw#_445, AVLTreeNode.right][perm$R := Mask[nw#_445, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
        Mask[nw#_445, AVLTreeNode.keys] := Mask[nw#_445, AVLTreeNode.keys][perm$R := Mask[nw#_445, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
        Mask[nw#_445, AVLTreeNode.balanceFactor] := Mask[nw#_445, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_445, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
        Mask[nw#_445, mu] := Mask[nw#_445, mu][perm$R := Mask[nw#_445, mu][perm$R] + (real(100) * 0.01)];
        nr#16 := nw#_445;
        assume (0.0 < methodCallK#_450) && ((1000.0 * methodCallK#_450) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_450) < methodK#_290);
        // call init
        callHeap#_446 := Heap;
        callMask#_447 := Mask;
        callSecMask#_448 := SecMask;
        callCredits#_449 := Credits;
        assume wf(callHeap#_446, callMask#_447, callSecMask#_448);
        assert {:msg "  233.6: The target of the method call might be null."} nr#16 != null;
        this#186 := nr#16;
        k#187 := k#9;
        // begin exhale (precondition)
        exhaleMask#_452 := Mask;
        havoc exhaleHeap#_451;
        exhaledHolds#_453 := ZeroRefSet;
        assert {:msg "  233.6: The precondition at 155.12 might not hold. The permission at 155.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  233.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_452[this#186, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_452[this#186, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_452[this#186, AVLTreeNode.key][perm$N]));
        exhaleMask#_452[this#186, AVLTreeNode.key] := exhaleMask#_452[this#186, AVLTreeNode.key][perm$R := exhaleMask#_452[this#186, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_452, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 156.12 might not hold. The permission at 156.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  233.6: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_452[this#186, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_452[this#186, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_452[this#186, AVLTreeNode.height][perm$N]));
        exhaleMask#_452[this#186, AVLTreeNode.height] := exhaleMask#_452[this#186, AVLTreeNode.height][perm$R := exhaleMask#_452[this#186, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_452, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 157.12 might not hold. The permission at 157.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  233.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_452[this#186, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_452[this#186, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_452[this#186, AVLTreeNode.left][perm$N]));
        exhaleMask#_452[this#186, AVLTreeNode.left] := exhaleMask#_452[this#186, AVLTreeNode.left][perm$R := exhaleMask#_452[this#186, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_452, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 158.12 might not hold. The permission at 158.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  233.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_452[this#186, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_452[this#186, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_452[this#186, AVLTreeNode.right][perm$N]));
        exhaleMask#_452[this#186, AVLTreeNode.right] := exhaleMask#_452[this#186, AVLTreeNode.right][perm$R := exhaleMask#_452[this#186, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_452, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 160.12 might not hold. The permission at 160.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  233.6: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_452[this#186, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_452[this#186, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_452[this#186, AVLTreeNode.keys][perm$N]));
        exhaleMask#_452[this#186, AVLTreeNode.keys] := exhaleMask#_452[this#186, AVLTreeNode.keys][perm$R := exhaleMask#_452[this#186, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_452, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  233.6: The precondition at 161.12 might not hold. The permission at 161.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  233.6: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_452[this#186, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_452[this#186, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_452[this#186, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_452[this#186, AVLTreeNode.balanceFactor] := exhaleMask#_452[this#186, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_452[this#186, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_452, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_452;
        assume IsGoodExhaleState(exhaleHeap#_451, Heap, Mask, exhaledHolds#_453);
        Heap := exhaleHeap#_451;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#186 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#186, AVLTreeNode.valid] := Mask[this#186, AVLTreeNode.valid][perm$R := Mask[this#186, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#186 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#186, AVLTreeNode.keys] := Mask[this#186, AVLTreeNode.keys][perm$R := Mask[this#186, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#186 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#186, AVLTreeNode.height] := Mask[this#186, AVLTreeNode.height][perm$R := Mask[this#186, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#186 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#186, AVLTreeNode.balanceFactor] := Mask[this#186, AVLTreeNode.balanceFactor][perm$R := Mask[this#186, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[this#186, AVLTreeNode.height] == 1;
        assume Seq#Equal(Heap[this#186, AVLTreeNode.keys], Seq#Singleton(k#187));
        assume Heap[this#186, AVLTreeNode.balanceFactor] == 0;
        assume Seq#Contains(Heap[this#186, AVLTreeNode.keys], k#187);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      } else {
        assume (0.0 < methodCallK#_467) && ((1000.0 * methodCallK#_467) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_467) < methodK#_290);
        // call insert
        callHeap#_463 := Heap;
        callMask#_464 := Mask;
        callSecMask#_465 := SecMask;
        callCredits#_466 := Credits;
        assume wf(callHeap#_463, callMask#_464, callSecMask#_465);
        assert {:msg "  235.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  235.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  235.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#188 := Heap[this, AVLTreeNode.right];
        k#189 := k#9;
        // begin exhale (precondition)
        exhaleMask#_469 := Mask;
        havoc exhaleHeap#_468;
        exhaledHolds#_470 := ZeroRefSet;
        assert {:msg "  235.6: The precondition at 185.12 might not hold. The permission at 185.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  235.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_469[this#188, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_469[this#188, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_469[this#188, AVLTreeNode.valid][perm$N]));
        exhaleMask#_469[this#188, AVLTreeNode.valid] := exhaleMask#_469[this#188, AVLTreeNode.valid][perm$R := exhaleMask#_469[this#188, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_469, this#188, AVLTreeNode.valid)) {
          assume Heap[this#188, AVLTreeNode.valid] < exhaleHeap#_468[this#188, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_469, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  235.6: The precondition at 186.12 might not hold. The permission at 186.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  235.6: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_469[this#188, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_469[this#188, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_469[this#188, AVLTreeNode.keys][perm$N]));
        exhaleMask#_469[this#188, AVLTreeNode.keys] := exhaleMask#_469[this#188, AVLTreeNode.keys][perm$R := exhaleMask#_469[this#188, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_469, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  235.6: The precondition at 187.12 might not hold. The permission at 187.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  235.6: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_469[this#188, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_469[this#188, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_469[this#188, AVLTreeNode.height][perm$N]));
        exhaleMask#_469[this#188, AVLTreeNode.height] := exhaleMask#_469[this#188, AVLTreeNode.height][perm$R := exhaleMask#_469[this#188, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_469, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  235.6: The precondition at 188.12 might not hold. The permission at 188.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  235.6: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_469[this#188, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_469[this#188, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_469[this#188, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_469[this#188, AVLTreeNode.balanceFactor] := exhaleMask#_469[this#188, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_469[this#188, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_469, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_469;
        assume IsGoodExhaleState(exhaleHeap#_468, Heap, Mask, exhaledHolds#_470);
        Heap := exhaleHeap#_468;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#190;
        // inhale (postcondition)
        assume !(r#190 == null);
        assume r#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[r#190, AVLTreeNode.valid] := Mask[r#190, AVLTreeNode.valid][perm$R := Mask[r#190, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#190, AVLTreeNode.keys] := Mask[r#190, AVLTreeNode.keys][perm$R := Mask[r#190, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#190, AVLTreeNode.height] := Mask[r#190, AVLTreeNode.height][perm$R := Mask[r#190, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#190 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#190, AVLTreeNode.balanceFactor] := Mask[r#190, AVLTreeNode.balanceFactor][perm$R := Mask[r#190, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Contains(Heap[r#190, AVLTreeNode.keys], k#189);
        assume (forall i#82#191: int :: 
          (0 <= i#82#191) && (i#82#191 < Seq#Length(callHeap#_463[this#188, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#190, AVLTreeNode.keys], Seq#Index(callHeap#_463[this#188, AVLTreeNode.keys], i#82#191))
        );
        assume (forall i#83#192: int :: 
          (0 <= i#83#192) && (i#83#192 < Seq#Length(Heap[r#190, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_463[this#188, AVLTreeNode.keys], Seq#Index(Heap[r#190, AVLTreeNode.keys], i#83#192)) || (Seq#Index(Heap[r#190, AVLTreeNode.keys], i#83#192) == k#189))
        );
        if (Seq#Contains(callHeap#_463[this#188, AVLTreeNode.keys], k#189)) {
          assume Seq#Equal(Heap[r#190, AVLTreeNode.keys], callHeap#_463[this#188, AVLTreeNode.keys]);
        }
        if (!Seq#Contains(callHeap#_463[this#188, AVLTreeNode.keys], k#189)) {
          assume Seq#Length(Heap[r#190, AVLTreeNode.keys]) == (Seq#Length(callHeap#_463[this#188, AVLTreeNode.keys]) + 1);
        }
        assume (Heap[r#190, AVLTreeNode.height] == callHeap#_463[this#188, AVLTreeNode.height]) || (Heap[r#190, AVLTreeNode.height] == (callHeap#_463[this#188, AVLTreeNode.height] + 1));
        if (Seq#Contains(callHeap#_463[this#188, AVLTreeNode.keys], k#189)) {
          assume Heap[r#190, AVLTreeNode.height] == callHeap#_463[this#188, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nr#16 := r#190;
      }
      // update field right
      assert {:msg "  237.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
      Heap[this, AVLTreeNode.right] := nr#16;
      assume wf(Heap, Mask, SecMask);
      // local var bf
      assume (0.0 < methodCallK#_482) && ((1000.0 * methodCallK#_482) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_482) < methodK#_290);
      // call getBalanceFactorI
      callHeap#_478 := Heap;
      callMask#_479 := Mask;
      callSecMask#_480 := SecMask;
      callCredits#_481 := Credits;
      assume wf(callHeap#_478, callMask#_479, callSecMask#_480);
      assert {:msg "  240.5: The target of the method call might be null."} this != null;
      this#193 := this;
      // begin exhale (precondition)
      exhaleMask#_484 := Mask;
      havoc exhaleHeap#_483;
      exhaledHolds#_485 := ZeroRefSet;
      assert {:msg "  240.5: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_482 > 0.0;
      assert {:msg "  240.5: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_484[this#193, AVLTreeNode.left][perm$R] > 0.0;
      assume methodCallK#_482 < exhaleMask#_484[this#193, AVLTreeNode.left][perm$R];
      exhaleMask#_484[this#193, AVLTreeNode.left] := exhaleMask#_484[this#193, AVLTreeNode.left][perm$R := exhaleMask#_484[this#193, AVLTreeNode.left][perm$R] - methodCallK#_482];
      assume wf(Heap, exhaleMask#_484, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#193, AVLTreeNode.left] == null)) {
        assert {:msg "  240.5: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_482 > 0.0;
        assert {:msg "  240.5: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
        assume methodCallK#_482 < exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height][perm$R];
        exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_482];
        assume wf(Heap, exhaleMask#_484, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  240.5: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_482 > 0.0;
      assert {:msg "  240.5: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_484[this#193, AVLTreeNode.right][perm$R] > 0.0;
      assume methodCallK#_482 < exhaleMask#_484[this#193, AVLTreeNode.right][perm$R];
      exhaleMask#_484[this#193, AVLTreeNode.right] := exhaleMask#_484[this#193, AVLTreeNode.right][perm$R := exhaleMask#_484[this#193, AVLTreeNode.right][perm$R] - methodCallK#_482];
      assume wf(Heap, exhaleMask#_484, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#193, AVLTreeNode.right] == null)) {
        assert {:msg "  240.5: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_482 > 0.0;
        assert {:msg "  240.5: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
        assume methodCallK#_482 < exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height][perm$R];
        exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_482];
        assume wf(Heap, exhaleMask#_484, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#193, AVLTreeNode.left] == null)) {
        assert {:msg "  240.5: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  240.5: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_484[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_484, Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_483[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_484, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#193, AVLTreeNode.right] == null)) {
        assert {:msg "  240.5: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  240.5: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_484[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_484, Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_483[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_484, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_484;
      assume IsGoodExhaleState(exhaleHeap#_483, Heap, Mask, exhaledHolds#_485);
      Heap := exhaleHeap#_483;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc bf#194;
      // inhale (postcondition)
      assume this#193 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#193, AVLTreeNode.left] == null) || (dtype(Heap[this#193, AVLTreeNode.left]) == AVLTreeNode#t);
      assume methodCallK#_482 > 0.0;
      Mask[this#193, AVLTreeNode.left] := Mask[this#193, AVLTreeNode.left][perm$R := Mask[this#193, AVLTreeNode.left][perm$R] + methodCallK#_482];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#193, AVLTreeNode.left] == null)) {
        assume Heap[this#193, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#193, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#193, AVLTreeNode.left] == null)) {
        assume Heap[this#193, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_482 > 0.0;
        Mask[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_482];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume this#193 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#193, AVLTreeNode.right] == null) || (dtype(Heap[this#193, AVLTreeNode.right]) == AVLTreeNode#t);
      assume methodCallK#_482 > 0.0;
      Mask[this#193, AVLTreeNode.right] := Mask[this#193, AVLTreeNode.right][perm$R := Mask[this#193, AVLTreeNode.right][perm$R] + methodCallK#_482];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#193, AVLTreeNode.right] == null)) {
        assume Heap[this#193, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#193, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#193, AVLTreeNode.right] == null)) {
        assume Heap[this#193, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_482 > 0.0;
        Mask[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_482];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume bf#194 == (ite(Heap[this#193, AVLTreeNode.left] == null, 0, Heap[Heap[this#193, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#193, AVLTreeNode.right] == null, 0, Heap[Heap[this#193, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#194 > 0) {
        assume !(Heap[this#193, AVLTreeNode.left] == null);
      }
      if (bf#194 < 0) {
        assume !(Heap[this#193, AVLTreeNode.right] == null);
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      bf#18 := bf#194;
      // if
      cond#_495 := bf#18 == (0 - 2);
      if (cond#_495) {
        assume (0.0 < methodCallK#_500) && ((1000.0 * methodCallK#_500) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_500) < methodK#_290);
        // call rebalanceRight
        callHeap#_496 := Heap;
        callMask#_497 := Mask;
        callSecMask#_498 := SecMask;
        callCredits#_499 := Credits;
        assume wf(callHeap#_496, callMask#_497, callSecMask#_498);
        assert {:msg "  242.6: The target of the method call might be null."} this != null;
        this#195 := this;
        // begin exhale (precondition)
        exhaleMask#_502 := Mask;
        havoc exhaleHeap#_501;
        exhaledHolds#_503 := ZeroRefSet;
        if (!(Heap[this#195, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 758.12 might not hold. The expression at 758.25 might not evaluate to true."} (forall k#104#197: int :: 
            (0 <= k#104#197) && (k#104#197 < Seq#Length(Heap[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys], k#104#197) < Heap[this#195, AVLTreeNode.key])
          );
        }
        assert {:msg "  242.6: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} !(Heap[this#195, AVLTreeNode.right] == null);
        assert {:msg "  242.6: The precondition at 765.12 might not hold. The expression at 765.12 might not evaluate to true."} (forall k#105#198: int :: 
          (0 <= k#105#198) && (k#105#198 < Seq#Length(Heap[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#195, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys], k#105#198))
        );
        assert {:msg "  242.6: The precondition at 768.12 might not hold. The expression at 768.12 might not evaluate to true."} (ite(Heap[this#195, AVLTreeNode.left] == null, 0, Heap[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
        assert {:msg "  242.6: The precondition at 746.12 might not hold. The permission at 746.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_502[this#195, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[this#195, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_502[this#195, AVLTreeNode.key][perm$N]));
        exhaleMask#_502[this#195, AVLTreeNode.key] := exhaleMask#_502[this#195, AVLTreeNode.key][perm$R := exhaleMask#_502[this#195, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 747.12 might not hold. The permission at 747.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_502[this#195, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[this#195, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_502[this#195, AVLTreeNode.height][perm$N]));
        exhaleMask#_502[this#195, AVLTreeNode.height] := exhaleMask#_502[this#195, AVLTreeNode.height][perm$R := exhaleMask#_502[this#195, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 748.12 might not hold. The permission at 748.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 748.12 might not hold. Insufficient fraction at 748.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_502[this#195, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[this#195, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_502[this#195, AVLTreeNode.left][perm$N]));
        exhaleMask#_502[this#195, AVLTreeNode.left] := exhaleMask#_502[this#195, AVLTreeNode.left][perm$R := exhaleMask#_502[this#195, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 749.12 might not hold. The permission at 749.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 749.12 might not hold. Insufficient fraction at 749.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_502[this#195, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[this#195, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_502[this#195, AVLTreeNode.right][perm$N]));
        exhaleMask#_502[this#195, AVLTreeNode.right] := exhaleMask#_502[this#195, AVLTreeNode.right][perm$R := exhaleMask#_502[this#195, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 751.12 might not hold. The permission at 751.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 751.12 might not hold. Insufficient fraction at 751.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_502[this#195, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[this#195, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_502[this#195, AVLTreeNode.keys][perm$N]));
        exhaleMask#_502[this#195, AVLTreeNode.keys] := exhaleMask#_502[this#195, AVLTreeNode.keys][perm$R := exhaleMask#_502[this#195, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 752.12 might not hold. The permission at 752.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 752.12 might not hold. Insufficient fraction at 752.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_502[this#195, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[this#195, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_502[this#195, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_502[this#195, AVLTreeNode.balanceFactor] := exhaleMask#_502[this#195, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_502[this#195, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#195, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 754.12 might not hold. The permission at 754.25 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  242.6: The precondition at 754.12 might not hold. Insufficient fraction at 754.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_502, Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_501[Heap[this#195, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_502, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#195, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 755.12 might not hold. The permission at 755.25 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  242.6: The precondition at 755.12 might not hold. Insufficient fraction at 755.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_502, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#195, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 756.12 might not hold. The permission at 756.25 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  242.6: The precondition at 756.12 might not hold. Insufficient fraction at 756.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_502, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#195, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 757.12 might not hold. The permission at 757.25 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  242.6: The precondition at 757.12 might not hold. Insufficient fraction at 757.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_502, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assert {:msg "  242.6: The precondition at 761.12 might not hold. The permission at 761.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 761.12 might not hold. Insufficient fraction at 761.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_502, Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_501[Heap[this#195, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 762.12 might not hold. The permission at 762.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 762.12 might not hold. Insufficient fraction at 762.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 763.12 might not hold. The permission at 763.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 763.12 might not hold. Insufficient fraction at 763.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  242.6: The precondition at 764.12 might not hold. The permission at 764.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  242.6: The precondition at 764.12 might not hold. Insufficient fraction at 764.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_502[Heap[this#195, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_502, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_502;
        assume IsGoodExhaleState(exhaleHeap#_501, Heap, Mask, exhaledHolds#_503);
        Heap := exhaleHeap#_501;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#196;
        // inhale (postcondition)
        assume !(r#196 == null);
        assume r#196 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[r#196, AVLTreeNode.valid] := Mask[r#196, AVLTreeNode.valid][perm$R := Mask[r#196, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#196 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#196, AVLTreeNode.height] := Mask[r#196, AVLTreeNode.height][perm$R := Mask[r#196, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#196 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#196, AVLTreeNode.keys] := Mask[r#196, AVLTreeNode.keys][perm$R := Mask[r#196, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume r#196 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[r#196, AVLTreeNode.balanceFactor] := Mask[r#196, AVLTreeNode.balanceFactor][perm$R := Mask[r#196, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume (Heap[r#196, AVLTreeNode.height] == callHeap#_496[callHeap#_496[this#195, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#196, AVLTreeNode.height] == (callHeap#_496[callHeap#_496[this#195, AVLTreeNode.right], AVLTreeNode.height] + 1));
        assume Seq#Equal(Heap[r#196, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_496[this#195, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_496[callHeap#_496[this#195, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_496[this#195, AVLTreeNode.key])), callHeap#_496[callHeap#_496[this#195, AVLTreeNode.right], AVLTreeNode.keys]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        r#10 := r#196;
      } else {
        // assigment to r
        r#10 := this;
        assume (0.0 < methodCallK#_525) && ((1000.0 * methodCallK#_525) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_525) < methodK#_290);
        // call close
        callHeap#_521 := Heap;
        callMask#_522 := Mask;
        callSecMask#_523 := SecMask;
        callCredits#_524 := Credits;
        assume wf(callHeap#_521, callMask#_522, callSecMask#_523);
        assert {:msg "  245.6: The target of the method call might be null."} r#10 != null;
        this#201 := r#10;
        // begin exhale (precondition)
        exhaleMask#_527 := Mask;
        havoc exhaleHeap#_526;
        exhaledHolds#_528 := ZeroRefSet;
        if (!(Heap[this#201, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#202: int :: 
            (0 <= k#92#202) && (k#92#202 < Seq#Length(Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys], k#92#202) < Heap[this#201, AVLTreeNode.key])
          );
        }
        if (!(Heap[this#201, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#203: int :: 
            (0 <= k#93#203) && (k#93#203 < Seq#Length(Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#201, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys], k#93#203))
          );
        }
        assert {:msg "  245.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#201, AVLTreeNode.left] == null, 0, Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#201, AVLTreeNode.right] == null, 0, Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  245.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#201, AVLTreeNode.left] == null, 0, Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#201, AVLTreeNode.right] == null, 0, Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  245.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  245.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_527[this#201, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[this#201, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_527[this#201, AVLTreeNode.key][perm$N]));
        exhaleMask#_527[this#201, AVLTreeNode.key] := exhaleMask#_527[this#201, AVLTreeNode.key][perm$R := exhaleMask#_527[this#201, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_527, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  245.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_527[this#201, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[this#201, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_527[this#201, AVLTreeNode.height][perm$N]));
        exhaleMask#_527[this#201, AVLTreeNode.height] := exhaleMask#_527[this#201, AVLTreeNode.height][perm$R := exhaleMask#_527[this#201, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_527, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  245.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_527[this#201, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[this#201, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_527[this#201, AVLTreeNode.left][perm$N]));
        exhaleMask#_527[this#201, AVLTreeNode.left] := exhaleMask#_527[this#201, AVLTreeNode.left][perm$R := exhaleMask#_527[this#201, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_527, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  245.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_527[this#201, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[this#201, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_527[this#201, AVLTreeNode.right][perm$N]));
        exhaleMask#_527[this#201, AVLTreeNode.right] := exhaleMask#_527[this#201, AVLTreeNode.right][perm$R := exhaleMask#_527[this#201, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_527, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  245.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_527[this#201, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[this#201, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_527[this#201, AVLTreeNode.keys][perm$N]));
        exhaleMask#_527[this#201, AVLTreeNode.keys] := exhaleMask#_527[this#201, AVLTreeNode.keys][perm$R := exhaleMask#_527[this#201, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_527, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  245.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  245.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_527[this#201, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[this#201, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_527[this#201, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_527[this#201, AVLTreeNode.balanceFactor] := exhaleMask#_527[this#201, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_527[this#201, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_527, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#201, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_527, Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_526[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_527, Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_526[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#201, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  245.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_527[Heap[this#201, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_527, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_527;
        assume IsGoodExhaleState(exhaleHeap#_526, Heap, Mask, exhaledHolds#_528);
        Heap := exhaleHeap#_526;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#201 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#201, AVLTreeNode.valid] := Mask[this#201, AVLTreeNode.valid][perm$R := Mask[this#201, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#201 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#201, AVLTreeNode.height] := Mask[this#201, AVLTreeNode.height][perm$R := Mask[this#201, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#201 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#201, AVLTreeNode.keys] := Mask[this#201, AVLTreeNode.keys][perm$R := Mask[this#201, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#201 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#201, AVLTreeNode.balanceFactor] := Mask[this#201, AVLTreeNode.balanceFactor][perm$R := Mask[this#201, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#201, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_521[this#201, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_521[callHeap#_521[this#201, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_521[this#201, AVLTreeNode.key])), ite(callHeap#_521[this#201, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_521[callHeap#_521[this#201, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#201, AVLTreeNode.height] == ite(ite(callHeap#_521[this#201, AVLTreeNode.left] == null, 0, callHeap#_521[callHeap#_521[this#201, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_521[this#201, AVLTreeNode.right] == null, 0, callHeap#_521[callHeap#_521[this#201, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_521[this#201, AVLTreeNode.left] == null, 0, callHeap#_521[callHeap#_521[this#201, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_521[this#201, AVLTreeNode.right] == null, 0, callHeap#_521[callHeap#_521[this#201, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#201, AVLTreeNode.balanceFactor] == (ite(callHeap#_521[this#201, AVLTreeNode.left] == null, 0, callHeap#_521[callHeap#_521[this#201, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_521[this#201, AVLTreeNode.right] == null, 0, callHeap#_521[callHeap#_521[this#201, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_547 := Mask;
  havoc exhaleHeap#_546;
  exhaledHolds#_548 := ZeroRefSet;
  assert {:msg "  184.2: The postcondition at 190.11 might not hold. The expression at 190.11 might not evaluate to true."} !(r#10 == null);
  assert {:msg "  184.2: The postcondition at 196.11 might not hold. The expression at 196.11 might not evaluate to true."} Seq#Contains(Heap[r#10, AVLTreeNode.keys], k#9);
  assert {:msg "  184.2: The postcondition at 197.11 might not hold. The expression at 197.11 might not evaluate to true."} (forall i#82#206: int :: 
    (0 <= i#82#206) && (i#82#206 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#10, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#82#206))
  );
  assert {:msg "  184.2: The postcondition at 198.11 might not hold. The expression at 198.11 might not evaluate to true."} (forall i#83#207: int :: 
    (0 <= i#83#207) && (i#83#207 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#207)) || (Seq#Index(Heap[r#10, AVLTreeNode.keys], i#83#207) == k#9))
  );
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 199.11 might not hold. The expression at 199.30 might not evaluate to true."} Seq#Equal(Heap[r#10, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 200.11 might not hold. The expression at 200.33 might not evaluate to true."} Seq#Length(Heap[r#10, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) + 1);
  }
  assert {:msg "  184.2: The postcondition at 202.11 might not hold. The expression at 202.11 might not evaluate to true."} (Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#10, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] + 1));
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 203.11 might not hold. The expression at 203.30 might not evaluate to true."} Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  assert {:msg "  184.2: The postcondition at 191.11 might not hold. The permission at 191.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  184.2: The postcondition at 191.11 might not hold. Insufficient fraction at 191.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_547[r#10, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_547[r#10, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_547[r#10, AVLTreeNode.valid][perm$N]));
  exhaleMask#_547[r#10, AVLTreeNode.valid] := exhaleMask#_547[r#10, AVLTreeNode.valid][perm$R := exhaleMask#_547[r#10, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_547, r#10, AVLTreeNode.valid)) {
    assume Heap[r#10, AVLTreeNode.valid] < exhaleHeap#_546[r#10, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_547, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  184.2: The postcondition at 192.11 might not hold. The permission at 192.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  184.2: The postcondition at 192.11 might not hold. Insufficient fraction at 192.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_547[r#10, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_547[r#10, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_547[r#10, AVLTreeNode.keys][perm$N]));
  exhaleMask#_547[r#10, AVLTreeNode.keys] := exhaleMask#_547[r#10, AVLTreeNode.keys][perm$R := exhaleMask#_547[r#10, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_547, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  184.2: The postcondition at 193.11 might not hold. The permission at 193.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  184.2: The postcondition at 193.11 might not hold. Insufficient fraction at 193.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_547[r#10, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_547[r#10, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_547[r#10, AVLTreeNode.height][perm$N]));
  exhaleMask#_547[r#10, AVLTreeNode.height] := exhaleMask#_547[r#10, AVLTreeNode.height][perm$R := exhaleMask#_547[r#10, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_547, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  184.2: The postcondition at 194.11 might not hold. The permission at 194.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  184.2: The postcondition at 194.11 might not hold. Insufficient fraction at 194.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_547[r#10, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_547[r#10, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_547[r#10, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_547[r#10, AVLTreeNode.balanceFactor] := exhaleMask#_547[r#10, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_547[r#10, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_547, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_547;
  assume IsGoodExhaleState(exhaleHeap#_546, Heap, Mask, exhaledHolds#_548);
  Heap := exhaleHeap#_546;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  184.2: Method might lock/unlock more than allowed."} (forall lk#_553: ref :: 
    { Heap[lk#_553, held] }
    { Heap[lk#_553, rdheld] }
    (((0 < Heap[lk#_553, held]) == (0 < old(Heap)[lk#_553, held])) && (Heap[lk#_553, rdheld] == old(Heap)[lk#_553, rdheld])) || false
  );
  assert {:msg "  184.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.remove
// -------------------------------------------

// definedness check for method AVLTreeNode.remove
procedure AVLTreeNode.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_554: real;
  var i#84#211: int where true;
  var i#85#213: int where true;
  assume (0.0 < methodK#_554) && ((1000.0 * methodK#_554) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  254.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_557: Field (PMaskType) :: 
    (forall ref#_556: ref :: 
      Heap[ref#_556, pmask#_557] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  259.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  259.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assume r#20 == null;
  }
  assert {:msg "  260.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  260.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assume !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  262.25: Receiver might be null."} r#20 != null;
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#20, AVLTreeNode.valid] := Mask[r#20, AVLTreeNode.valid][perm$R := Mask[r#20, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#20, AVLTreeNode.keys] := Mask[r#20, AVLTreeNode.keys][perm$R := Mask[r#20, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#20, AVLTreeNode.height] := Mask[r#20, AVLTreeNode.height][perm$R := Mask[r#20, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#20, AVLTreeNode.balanceFactor] := Mask[r#20, AVLTreeNode.balanceFactor][perm$R := Mask[r#20, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  267.32: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  267.32: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assume !Seq#Contains(Heap[r#20, AVLTreeNode.keys], k#19);
  }
  if (!(r#20 == null)) {
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#84#211) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#84#211) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  268.52: Sequence index might be negative."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (0 <= i#84#211);
    assert {:msg "  268.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
    assert {:msg "  268.59: Receiver might be null."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (r#20 != null);
    assert {:msg "  268.59: Location might not be readable."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#211))) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#211))) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  268.52: Sequence index might be negative."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#211))) ==> (0 <= i#84#211);
    assert {:msg "  268.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#84#211) && (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#211))) ==> (i#84#211 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
    assume (forall i#84#210: int :: 
      (0 <= i#84#210) && (i#84#210 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#210)) || (Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#210) == k#19))
    );
  }
  if (!(r#20 == null)) {
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#85#213) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#85#213) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.52: Sequence index might be negative."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (0 <= i#85#213);
    assert {:msg "  269.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys]));
    assert {:msg "  269.61: Receiver might be null."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  269.61: Location might not be readable."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#213)) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#213)) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.52: Sequence index might be negative."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#213)) ==> (0 <= i#85#213);
    assert {:msg "  269.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#85#213) && (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#213)) ==> (i#85#213 < Seq#Length(Heap[r#20, AVLTreeNode.keys]));
    assume (forall i#85#212: int :: 
      (0 <= i#85#212) && (i#85#212 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#212)) && (!(Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#212) == k#19))
    );
  }
  assert {:msg "  270.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  270.22: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assume !(r#20 == null);
  }
  assert {:msg "  271.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  271.22: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  271.34: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  271.34: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  271.50: Receiver might be null."} true ==> (this != null);
    assert {:msg "  271.50: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  if (!(r#20 == null)) {
    assert {:msg "  272.34: Receiver might be null."} true ==> (this != null);
    assert {:msg "  272.34: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
      assert {:msg "  272.46: Receiver might be null."} true ==> (r#20 != null);
      assert {:msg "  272.46: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.keys);
      assert {:msg "  272.62: Receiver might be null."} true ==> (this != null);
      assert {:msg "  272.62: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
      assume Seq#Length(Heap[r#20, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) - 1);
    }
  }
  assert {:msg "  274.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  274.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  275.25: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  275.25: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.height);
    assert {:msg "  275.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  275.39: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assert {:msg "  275.50: Receiver might be null."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#20 != null);
    assert {:msg "  275.50: Location might not be readable."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#20, AVLTreeNode.height);
    assert {:msg "  275.66: Receiver might be null."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  275.66: Location might not be readable."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume (Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#20, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  assert {:msg "  276.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  276.22: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  276.33: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  276.33: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.height);
    assert {:msg "  276.47: Receiver might be null."} true ==> (this != null);
    assert {:msg "  276.47: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.remove
procedure AVLTreeNode.remove(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_554: real;
  var predRec#_563: ref;
  var predVer#_564: int;
  var unfoldK#_562: real;
  var oldVers#_569: int;
  var newVers#_570: int;
  var cond#_572: bool;
  var cond#_573: bool;
  var assertHeap#_574: HeapType;
  var assertMask#_575: MaskType;
  var assertSecMask#_576: MaskType;
  var assertCredits#_577: CreditsType;
  var exhaleMask#_579: MaskType;
  var exhaleHeap#_578: HeapType;
  var exhaledHolds#_580: RefSet;
  var unfoldingK#_589: real;
  var predFlag#_588: bool;
  var predRec#_590: ref;
  var predVer#_591: int;
  var unfoldingHeap#_584: HeapType;
  var unfoldingMask#_585: MaskType;
  var unfoldingSecMask#_586: MaskType;
  var unfoldingCredits#_587: CreditsType;
  var oldVers#_596: int;
  var newVers#_597: int;
  var newPredicateMask#_601: PMaskType;
  var newPredicateMask#_604: PMaskType;
  var assertHeap#_605: HeapType;
  var assertMask#_606: MaskType;
  var assertSecMask#_607: MaskType;
  var assertCredits#_608: CreditsType;
  var exhaleMask#_610: MaskType;
  var exhaleHeap#_609: HeapType;
  var exhaledHolds#_611: RefSet;
  var unfoldingK#_620: real;
  var predFlag#_619: bool;
  var predRec#_621: ref;
  var predVer#_622: int;
  var unfoldingHeap#_615: HeapType;
  var unfoldingMask#_616: MaskType;
  var unfoldingSecMask#_617: MaskType;
  var unfoldingCredits#_618: CreditsType;
  var oldVers#_627: int;
  var newVers#_628: int;
  var newPredicateMask#_632: PMaskType;
  var newPredicateMask#_635: PMaskType;
  var cond#_636: bool;
  var bf#22: int where true;
  var nl#24: ref where (nl#24 == null) || (dtype(nl#24) == AVLTreeNode#t);
  var nr#26: ref where (nr#26 == null) || (dtype(nr#26) == AVLTreeNode#t);
  var methodCallK#_641: real;
  var this#224: ref where (this#224 == null) || (dtype(this#224) == AVLTreeNode#t);
  var bf#225: int where true;
  var callHeap#_637: HeapType;
  var callMask#_638: MaskType;
  var callSecMask#_639: MaskType;
  var callCredits#_640: CreditsType;
  var exhaleMask#_643: MaskType;
  var exhaleHeap#_642: HeapType;
  var exhaledHolds#_644: RefSet;
  var isHeld#_651: int;
  var isRdHeld#_652: bool;
  var cond#_654: bool;
  var methodCallK#_659: real;
  var this#226: ref where (this#226 == null) || (dtype(this#226) == AVLTreeNode#t);
  var r#227: ref where (r#227 == null) || (dtype(r#227) == AVLTreeNode#t);
  var m#228: ref where (m#228 == null) || (dtype(m#228) == AVLTreeNode#t);
  var callHeap#_655: HeapType;
  var callMask#_656: MaskType;
  var callSecMask#_657: MaskType;
  var callCredits#_658: CreditsType;
  var exhaleMask#_661: MaskType;
  var exhaleHeap#_660: HeapType;
  var exhaledHolds#_662: RefSet;
  var isHeld#_667: int;
  var isRdHeld#_668: bool;
  var methodCallK#_674: real;
  var this#230: ref where (this#230 == null) || (dtype(this#230) == AVLTreeNode#t);
  var r#231: ref where (r#231 == null) || (dtype(r#231) == AVLTreeNode#t);
  var m#232: ref where (m#232 == null) || (dtype(m#232) == AVLTreeNode#t);
  var callHeap#_670: HeapType;
  var callMask#_671: MaskType;
  var callSecMask#_672: MaskType;
  var callCredits#_673: CreditsType;
  var exhaleMask#_676: MaskType;
  var exhaleHeap#_675: HeapType;
  var exhaledHolds#_677: RefSet;
  var isHeld#_682: int;
  var isRdHeld#_683: bool;
  var predRec#_686: ref;
  var predVer#_687: int;
  var unfoldK#_685: real;
  var oldVers#_692: int;
  var newVers#_693: int;
  var methodCallK#_699: real;
  var this#236: ref where (this#236 == null) || (dtype(this#236) == AVLTreeNode#t);
  var callHeap#_695: HeapType;
  var callMask#_696: MaskType;
  var callSecMask#_697: MaskType;
  var callCredits#_698: CreditsType;
  var exhaleMask#_701: MaskType;
  var exhaleHeap#_700: HeapType;
  var exhaledHolds#_702: RefSet;
  var isHeld#_717: int;
  var isRdHeld#_718: bool;
  var cond#_720: bool;
  var cond#_721: bool;
  var nl#28: ref where (nl#28 == null) || (dtype(nl#28) == AVLTreeNode#t);
  var methodCallK#_726: real;
  var this#241: ref where (this#241 == null) || (dtype(this#241) == AVLTreeNode#t);
  var k#242: int where true;
  var r#243: ref where (r#243 == null) || (dtype(r#243) == AVLTreeNode#t);
  var callHeap#_722: HeapType;
  var callMask#_723: MaskType;
  var callSecMask#_724: MaskType;
  var callCredits#_725: CreditsType;
  var exhaleMask#_728: MaskType;
  var exhaleHeap#_727: HeapType;
  var exhaledHolds#_729: RefSet;
  var isHeld#_734: int;
  var isRdHeld#_735: bool;
  var bf#30: int where true;
  var methodCallK#_741: real;
  var this#246: ref where (this#246 == null) || (dtype(this#246) == AVLTreeNode#t);
  var bf#247: int where true;
  var callHeap#_737: HeapType;
  var callMask#_738: MaskType;
  var callSecMask#_739: MaskType;
  var callCredits#_740: CreditsType;
  var exhaleMask#_743: MaskType;
  var exhaleHeap#_742: HeapType;
  var exhaledHolds#_744: RefSet;
  var isHeld#_751: int;
  var isRdHeld#_752: bool;
  var cond#_754: bool;
  var methodCallK#_759: real;
  var this#248: ref where (this#248 == null) || (dtype(this#248) == AVLTreeNode#t);
  var r#249: ref where (r#249 == null) || (dtype(r#249) == AVLTreeNode#t);
  var callHeap#_755: HeapType;
  var callMask#_756: MaskType;
  var callSecMask#_757: MaskType;
  var callCredits#_758: CreditsType;
  var exhaleMask#_761: MaskType;
  var exhaleHeap#_760: HeapType;
  var exhaledHolds#_762: RefSet;
  var isHeld#_777: int;
  var isRdHeld#_778: bool;
  var methodCallK#_784: real;
  var this#254: ref where (this#254 == null) || (dtype(this#254) == AVLTreeNode#t);
  var callHeap#_780: HeapType;
  var callMask#_781: MaskType;
  var callSecMask#_782: MaskType;
  var callCredits#_783: CreditsType;
  var exhaleMask#_786: MaskType;
  var exhaleHeap#_785: HeapType;
  var exhaledHolds#_787: RefSet;
  var isHeld#_802: int;
  var isRdHeld#_803: bool;
  var methodCallK#_809: real;
  var this#259: ref where (this#259 == null) || (dtype(this#259) == AVLTreeNode#t);
  var callHeap#_805: HeapType;
  var callMask#_806: MaskType;
  var callSecMask#_807: MaskType;
  var callCredits#_808: CreditsType;
  var exhaleMask#_811: MaskType;
  var exhaleHeap#_810: HeapType;
  var exhaledHolds#_812: RefSet;
  var isHeld#_827: int;
  var isRdHeld#_828: bool;
  var cond#_830: bool;
  var nr#32: ref where (nr#32 == null) || (dtype(nr#32) == AVLTreeNode#t);
  var methodCallK#_835: real;
  var this#264: ref where (this#264 == null) || (dtype(this#264) == AVLTreeNode#t);
  var k#265: int where true;
  var r#266: ref where (r#266 == null) || (dtype(r#266) == AVLTreeNode#t);
  var callHeap#_831: HeapType;
  var callMask#_832: MaskType;
  var callSecMask#_833: MaskType;
  var callCredits#_834: CreditsType;
  var exhaleMask#_837: MaskType;
  var exhaleHeap#_836: HeapType;
  var exhaledHolds#_838: RefSet;
  var isHeld#_843: int;
  var isRdHeld#_844: bool;
  var bf#34: int where true;
  var methodCallK#_850: real;
  var this#269: ref where (this#269 == null) || (dtype(this#269) == AVLTreeNode#t);
  var bf#270: int where true;
  var callHeap#_846: HeapType;
  var callMask#_847: MaskType;
  var callSecMask#_848: MaskType;
  var callCredits#_849: CreditsType;
  var exhaleMask#_852: MaskType;
  var exhaleHeap#_851: HeapType;
  var exhaledHolds#_853: RefSet;
  var isHeld#_860: int;
  var isRdHeld#_861: bool;
  var cond#_863: bool;
  var methodCallK#_868: real;
  var this#271: ref where (this#271 == null) || (dtype(this#271) == AVLTreeNode#t);
  var r#272: ref where (r#272 == null) || (dtype(r#272) == AVLTreeNode#t);
  var callHeap#_864: HeapType;
  var callMask#_865: MaskType;
  var callSecMask#_866: MaskType;
  var callCredits#_867: CreditsType;
  var exhaleMask#_870: MaskType;
  var exhaleHeap#_869: HeapType;
  var exhaledHolds#_871: RefSet;
  var isHeld#_886: int;
  var isRdHeld#_887: bool;
  var methodCallK#_893: real;
  var this#277: ref where (this#277 == null) || (dtype(this#277) == AVLTreeNode#t);
  var callHeap#_889: HeapType;
  var callMask#_890: MaskType;
  var callSecMask#_891: MaskType;
  var callCredits#_892: CreditsType;
  var exhaleMask#_895: MaskType;
  var exhaleHeap#_894: HeapType;
  var exhaledHolds#_896: RefSet;
  var isHeld#_911: int;
  var isRdHeld#_912: bool;
  var methodCallK#_918: real;
  var this#282: ref where (this#282 == null) || (dtype(this#282) == AVLTreeNode#t);
  var callHeap#_914: HeapType;
  var callMask#_915: MaskType;
  var callSecMask#_916: MaskType;
  var callCredits#_917: CreditsType;
  var exhaleMask#_920: MaskType;
  var exhaleHeap#_919: HeapType;
  var exhaledHolds#_921: RefSet;
  var isHeld#_936: int;
  var isRdHeld#_937: bool;
  var exhaleMask#_940: MaskType;
  var exhaleHeap#_939: HeapType;
  var exhaledHolds#_941: RefSet;
  assume (0.0 < methodK#_554) && ((1000.0 * methodK#_554) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_561: Field (PMaskType) :: 
    (forall ref#_560: ref :: 
      Heap[ref#_560, pmask#_561] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  predRec#_563 := this;
  predVer#_564 := Heap[this, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_562) && (unfoldK#_562 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_562) < methodK#_554);
  assert {:msg "  278.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  278.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  278.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTreeNode.valid)) {
    oldVers#_569 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_570;
    Heap[this, AVLTreeNode.valid] := newVers#_570;
    assume oldVers#_569 < Heap[this, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_563, AVLTreeNode.valid, predVer#_564, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#214: int :: 
      (0 <= lk#79#214) && (lk#79#214 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#214) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_563, AVLTreeNode.valid, predVer#_564, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#215: int :: 
      (0 <= rk#80#215) && (rk#80#215 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#215))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_572 := Heap[this, AVLTreeNode.key] == k#19;
  assert {:msg "  279.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  279.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (cond#_572) {
    // if
    cond#_573 := (Heap[this, AVLTreeNode.left] == null) || (Heap[this, AVLTreeNode.right] == null);
    assert {:msg "  280.8: Receiver might be null."} true ==> (this != null);
    assert {:msg "  280.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  280.22: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
    assert {:msg "  280.22: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, this, AVLTreeNode.right);
    if (cond#_573) {
      // assert
      assertHeap#_574 := Heap;
      assertMask#_575 := Mask;
      assertSecMask#_576 := SecMask;
      assertCredits#_577 := Credits;
      assume wf(assertHeap#_574, assertMask#_575, assertSecMask#_576);
      // begin exhale (assert)
      exhaleMask#_579 := assertMask#_575;
      havoc exhaleHeap#_578;
      exhaledHolds#_580 := ZeroRefSet;
      assert {:msg "  281.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  281.12: Location might not be readable."} true ==> CanRead(assertMask#_575, this, AVLTreeNode.right);
      if (!(assertHeap#_574[this, AVLTreeNode.right] == null)) {
        // unfolding
        assume (0.0 < unfoldingK#_589) && ((1000.0 * unfoldingK#_589) < (real(1) * 0.01));
        predFlag#_588 := true;
        predRec#_590 := assertHeap#_574[this, AVLTreeNode.right];
        predVer#_591 := Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid];
        assert {:msg "  281.38: Receiver might be null."} true ==> (this != null);
        assert {:msg "  281.38: Location might not be readable."} true ==> CanRead(assertMask#_575, this, AVLTreeNode.right);
        assert {:msg "  281.38: Receiver might be null."} true ==> (assertHeap#_574[this, AVLTreeNode.right] != null);
        unfoldingHeap#_584 := assertHeap#_574;
        unfoldingMask#_585 := assertMask#_575;
        unfoldingSecMask#_586 := assertSecMask#_576;
        unfoldingCredits#_587 := assertCredits#_577;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        // begin exhale (unfolding)
        assert {:msg "  281.28: Unfolding might fail. The permission at 281.38 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  281.28: Unfolding might fail. Insufficient fraction at 281.38 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(unfoldingMask#_585, unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid)) {
          oldVers#_596 := unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid];
          havoc newVers#_597;
          unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_597;
          assume oldVers#_596 < unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        // end exhale
        // inhale (unfolding)
        assume unfoldingHeap#_584[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume true;
        assume (real(100) * 0.01) > 0.0;
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume unfoldingHeap#_584[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume unfoldingHeap#_584[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume (unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
        assume (real(100) * 0.01) > 0.0;
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume unfoldingHeap#_584[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume (unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
        assume (real(100) * 0.01) > 0.0;
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume unfoldingHeap#_584[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume unfoldingHeap#_584[this, AVLTreeNode.right] != null;
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_585[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume (real(100) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume #predicateInside#(predRec#_590, AVLTreeNode.valid, predVer#_591, unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume (forall lk#79#218: int :: 
            (0 <= lk#79#218) && (lk#79#218 < Seq#Length(unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#218) < unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key])
          );
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume (real(100) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume #predicateInside#(predRec#_590, AVLTreeNode.valid, predVer#_591, unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_585[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_585);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
          assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume (forall rk#80#219: int :: 
            (0 <= rk#80#219) && (rk#80#219 < Seq#Length(unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#219))
          );
        }
        if (!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        assume Seq#Equal(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key]);
        assume (forall kk#81: int :: 
          Seq#Contains(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.key]))
        );
        assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_584[unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
        assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
        assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
        assume unfoldingHeap#_584[unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
        assume IsGoodMask(unfoldingMask#_585);
        assume wf(unfoldingHeap#_584, unfoldingMask#_585, unfoldingSecMask#_586);
        // end inhale
        Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.key] := true;
        Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
        Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.left] := true;
        Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.right] := true;
        Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
        Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          havoc newPredicateMask#_601;
          assume (forall ref#_599: ref :: 
            (forall<T#_7> f#_600: Field (T#_7) :: 
              (Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_599, f#_600] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_599, f#_600]) ==> newPredicateMask#_601[ref#_599, f#_600]
            )
          );
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_601;
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          havoc newPredicateMask#_604;
          assume (forall ref#_602: ref :: 
            (forall<T#_8> f#_603: Field (T#_8) :: 
              (Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_602, f#_603] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_602, f#_603]) ==> newPredicateMask#_604[ref#_602, f#_603]
            )
          );
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_604;
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          Heap[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
        }
        assert {:msg "  281.53: Receiver might be null."} true ==> (this != null);
        assert {:msg "  281.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_585, this, AVLTreeNode.right);
        assert {:msg "  281.53: Receiver might be null."} true ==> (unfoldingHeap#_584[this, AVLTreeNode.right] != null);
        assert {:msg "  281.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_585, unfoldingHeap#_584[this, AVLTreeNode.right], AVLTreeNode.keys);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  281.5: Assertion might not hold. The expression at 281.28 might not evaluate to true."} !Seq#Equal(assertHeap#_574[assertHeap#_574[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Empty());
      }
      assertMask#_575 := exhaleMask#_579;
      assume IsGoodExhaleState(exhaleHeap#_578, assertHeap#_574, assertMask#_575, exhaledHolds#_580);
      assertHeap#_574 := exhaleHeap#_578;
      assume IsGoodMask(assertMask#_575);
      assume wf(assertHeap#_574, assertMask#_575, assertSecMask#_576);
      // end exhale
      // assert
      assertHeap#_605 := Heap;
      assertMask#_606 := Mask;
      assertSecMask#_607 := SecMask;
      assertCredits#_608 := Credits;
      assume wf(assertHeap#_605, assertMask#_606, assertSecMask#_607);
      // begin exhale (assert)
      exhaleMask#_610 := assertMask#_606;
      havoc exhaleHeap#_609;
      exhaledHolds#_611 := ZeroRefSet;
      assert {:msg "  282.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  282.12: Location might not be readable."} true ==> CanRead(assertMask#_606, this, AVLTreeNode.left);
      if (!(assertHeap#_605[this, AVLTreeNode.left] == null)) {
        // unfolding
        assume (0.0 < unfoldingK#_620) && ((1000.0 * unfoldingK#_620) < (real(1) * 0.01));
        predFlag#_619 := true;
        predRec#_621 := assertHeap#_605[this, AVLTreeNode.left];
        predVer#_622 := Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid];
        assert {:msg "  282.38: Receiver might be null."} true ==> (this != null);
        assert {:msg "  282.38: Location might not be readable."} true ==> CanRead(assertMask#_606, this, AVLTreeNode.left);
        assert {:msg "  282.38: Receiver might be null."} true ==> (assertHeap#_605[this, AVLTreeNode.left] != null);
        unfoldingHeap#_615 := assertHeap#_605;
        unfoldingMask#_616 := assertMask#_606;
        unfoldingSecMask#_617 := assertSecMask#_607;
        unfoldingCredits#_618 := assertCredits#_608;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        // begin exhale (unfolding)
        assert {:msg "  282.28: Unfolding might fail. The permission at 282.38 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  282.28: Unfolding might fail. Insufficient fraction at 282.38 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(unfoldingMask#_616, unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid)) {
          oldVers#_627 := unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid];
          havoc newVers#_628;
          unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_628;
          assume oldVers#_627 < unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        // end exhale
        // inhale (unfolding)
        assume unfoldingHeap#_615[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume true;
        assume (real(100) * 0.01) > 0.0;
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume unfoldingHeap#_615[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume unfoldingHeap#_615[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume (unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
        assume (real(100) * 0.01) > 0.0;
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume unfoldingHeap#_615[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume (unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
        assume (real(100) * 0.01) > 0.0;
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume unfoldingHeap#_615[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume unfoldingHeap#_615[this, AVLTreeNode.left] != null;
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_616[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume (real(100) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume #predicateInside#(predRec#_621, AVLTreeNode.valid, predVer#_622, unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume (forall lk#79#222: int :: 
            (0 <= lk#79#222) && (lk#79#222 < Seq#Length(unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#222) < unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key])
          );
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume (real(100) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume #predicateInside#(predRec#_621, AVLTreeNode.valid, predVer#_622, unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_616[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(unfoldingMask#_616);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
          assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume (forall rk#80#223: int :: 
            (0 <= rk#80#223) && (rk#80#223 < Seq#Length(unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#223))
          );
        }
        if (!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
        }
        assume Seq#Equal(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key]);
        assume (forall kk#81: int :: 
          Seq#Contains(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.key]))
        );
        assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_615[unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
        assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
        assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
        assume unfoldingHeap#_615[unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
        assume IsGoodMask(unfoldingMask#_616);
        assume wf(unfoldingHeap#_615, unfoldingMask#_616, unfoldingSecMask#_617);
        // end inhale
        Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.key] := true;
        Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
        Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.left] := true;
        Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.right] := true;
        Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
        Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          havoc newPredicateMask#_632;
          assume (forall ref#_630: ref :: 
            (forall<T#_9> f#_631: Field (T#_9) :: 
              (Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_630, f#_631] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_630, f#_631]) ==> newPredicateMask#_632[ref#_630, f#_631]
            )
          );
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_632;
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          havoc newPredicateMask#_635;
          assume (forall ref#_633: ref :: 
            (forall<T#_10> f#_634: Field (T#_10) :: 
              (Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_633, f#_634] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_633, f#_634]) ==> newPredicateMask#_635[ref#_633, f#_634]
            )
          );
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_635;
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := true;
        }
        if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          Heap[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
        }
        assert {:msg "  282.53: Receiver might be null."} true ==> (this != null);
        assert {:msg "  282.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_616, this, AVLTreeNode.left);
        assert {:msg "  282.53: Receiver might be null."} true ==> (unfoldingHeap#_615[this, AVLTreeNode.left] != null);
        assert {:msg "  282.53: Location might not be readable."} true ==> CanRead(unfoldingMask#_616, unfoldingHeap#_615[this, AVLTreeNode.left], AVLTreeNode.keys);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  282.5: Assertion might not hold. The expression at 282.28 might not evaluate to true."} !Seq#Equal(assertHeap#_605[assertHeap#_605[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Empty());
      }
      assertMask#_606 := exhaleMask#_610;
      assume IsGoodExhaleState(exhaleHeap#_609, assertHeap#_605, assertMask#_606, exhaledHolds#_611);
      assertHeap#_605 := exhaleHeap#_609;
      assume IsGoodMask(assertMask#_606);
      assume wf(assertHeap#_605, assertMask#_606, assertSecMask#_607);
      // end exhale
      // if
      cond#_636 := Heap[this, AVLTreeNode.left] == null;
      assert {:msg "  283.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  283.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (cond#_636) {
        // assigment to r
        assert {:msg "  284.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  284.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        r#20 := Heap[this, AVLTreeNode.right];
      } else {
        // assigment to r
        assert {:msg "  286.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  286.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        r#20 := Heap[this, AVLTreeNode.left];
      }
    } else {
      // local var bf
      // local var nl
      // assigment to nl
      assert {:msg "  290.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  290.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      nl#24 := Heap[this, AVLTreeNode.left];
      // local var nr
      // assigment to nr
      assert {:msg "  291.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  291.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      nr#26 := Heap[this, AVLTreeNode.right];
      assume (0.0 < methodCallK#_641) && ((1000.0 * methodCallK#_641) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_641) < methodK#_554);
      // call getBalanceFactorI
      callHeap#_637 := Heap;
      callMask#_638 := Mask;
      callSecMask#_639 := SecMask;
      callCredits#_640 := Credits;
      assume wf(callHeap#_637, callMask#_638, callSecMask#_639);
      assert {:msg "  293.5: The target of the method call might be null."} this != null;
      this#224 := this;
      // begin exhale (precondition)
      exhaleMask#_643 := Mask;
      havoc exhaleHeap#_642;
      exhaledHolds#_644 := ZeroRefSet;
      assert {:msg "  293.5: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_641 > 0.0;
      assert {:msg "  293.5: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_643[this#224, AVLTreeNode.left][perm$R] > 0.0;
      assume methodCallK#_641 < exhaleMask#_643[this#224, AVLTreeNode.left][perm$R];
      exhaleMask#_643[this#224, AVLTreeNode.left] := exhaleMask#_643[this#224, AVLTreeNode.left][perm$R := exhaleMask#_643[this#224, AVLTreeNode.left][perm$R] - methodCallK#_641];
      assume wf(Heap, exhaleMask#_643, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#224, AVLTreeNode.left] == null)) {
        assert {:msg "  293.5: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_641 > 0.0;
        assert {:msg "  293.5: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
        assume methodCallK#_641 < exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height][perm$R];
        exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_641];
        assume wf(Heap, exhaleMask#_643, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  293.5: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_641 > 0.0;
      assert {:msg "  293.5: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_643[this#224, AVLTreeNode.right][perm$R] > 0.0;
      assume methodCallK#_641 < exhaleMask#_643[this#224, AVLTreeNode.right][perm$R];
      exhaleMask#_643[this#224, AVLTreeNode.right] := exhaleMask#_643[this#224, AVLTreeNode.right][perm$R := exhaleMask#_643[this#224, AVLTreeNode.right][perm$R] - methodCallK#_641];
      assume wf(Heap, exhaleMask#_643, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#224, AVLTreeNode.right] == null)) {
        assert {:msg "  293.5: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_641 > 0.0;
        assert {:msg "  293.5: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
        assume methodCallK#_641 < exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height][perm$R];
        exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_641];
        assume wf(Heap, exhaleMask#_643, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#224, AVLTreeNode.left] == null)) {
        assert {:msg "  293.5: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  293.5: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_643[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_643, Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_642[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_643, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#224, AVLTreeNode.right] == null)) {
        assert {:msg "  293.5: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  293.5: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_643[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_643, Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_642[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_643, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_643;
      assume IsGoodExhaleState(exhaleHeap#_642, Heap, Mask, exhaledHolds#_644);
      Heap := exhaleHeap#_642;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc bf#225;
      // inhale (postcondition)
      assume this#224 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#224, AVLTreeNode.left] == null) || (dtype(Heap[this#224, AVLTreeNode.left]) == AVLTreeNode#t);
      assume methodCallK#_641 > 0.0;
      Mask[this#224, AVLTreeNode.left] := Mask[this#224, AVLTreeNode.left][perm$R := Mask[this#224, AVLTreeNode.left][perm$R] + methodCallK#_641];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#224, AVLTreeNode.left] == null)) {
        assume Heap[this#224, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#224, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#224, AVLTreeNode.left] == null)) {
        assume Heap[this#224, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_641 > 0.0;
        Mask[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_641];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume this#224 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[this#224, AVLTreeNode.right] == null) || (dtype(Heap[this#224, AVLTreeNode.right]) == AVLTreeNode#t);
      assume methodCallK#_641 > 0.0;
      Mask[this#224, AVLTreeNode.right] := Mask[this#224, AVLTreeNode.right][perm$R := Mask[this#224, AVLTreeNode.right][perm$R] + methodCallK#_641];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#224, AVLTreeNode.right] == null)) {
        assume Heap[this#224, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#224, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#224, AVLTreeNode.right] == null)) {
        assume Heap[this#224, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_641 > 0.0;
        Mask[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_641];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assume bf#225 == (ite(Heap[this#224, AVLTreeNode.left] == null, 0, Heap[Heap[this#224, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#224, AVLTreeNode.right] == null, 0, Heap[Heap[this#224, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#225 > 0) {
        assume !(Heap[this#224, AVLTreeNode.left] == null);
      }
      if (bf#225 < 0) {
        assume !(Heap[this#224, AVLTreeNode.right] == null);
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      bf#22 := bf#225;
      // if
      cond#_654 := bf#22 > 0;
      if (cond#_654) {
        assume (0.0 < methodCallK#_659) && ((1000.0 * methodCallK#_659) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_659) < methodK#_554);
        // call pruneMax
        callHeap#_655 := Heap;
        callMask#_656 := Mask;
        callSecMask#_657 := SecMask;
        callCredits#_658 := Credits;
        assume wf(callHeap#_655, callMask#_656, callSecMask#_657);
        assert {:msg "  295.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  295.19: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  295.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#226 := Heap[this, AVLTreeNode.left];
        // begin exhale (precondition)
        exhaleMask#_661 := Mask;
        havoc exhaleHeap#_660;
        exhaledHolds#_662 := ZeroRefSet;
        assert {:msg "  295.6: The precondition at 349.12 might not hold. The permission at 349.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  295.6: The precondition at 349.12 might not hold. Insufficient fraction at 349.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_661[this#226, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_661[this#226, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_661[this#226, AVLTreeNode.valid][perm$N]));
        exhaleMask#_661[this#226, AVLTreeNode.valid] := exhaleMask#_661[this#226, AVLTreeNode.valid][perm$R := exhaleMask#_661[this#226, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_661, this#226, AVLTreeNode.valid)) {
          assume Heap[this#226, AVLTreeNode.valid] < exhaleHeap#_660[this#226, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_661, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  295.6: The precondition at 350.12 might not hold. The permission at 350.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  295.6: The precondition at 350.12 might not hold. Insufficient fraction at 350.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_661[this#226, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_661[this#226, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_661[this#226, AVLTreeNode.keys][perm$N]));
        exhaleMask#_661[this#226, AVLTreeNode.keys] := exhaleMask#_661[this#226, AVLTreeNode.keys][perm$R := exhaleMask#_661[this#226, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_661, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  295.6: The precondition at 351.12 might not hold. The permission at 351.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  295.6: The precondition at 351.12 might not hold. Insufficient fraction at 351.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_661[this#226, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_661[this#226, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_661[this#226, AVLTreeNode.height][perm$N]));
        exhaleMask#_661[this#226, AVLTreeNode.height] := exhaleMask#_661[this#226, AVLTreeNode.height][perm$R := exhaleMask#_661[this#226, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_661, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  295.6: The precondition at 352.12 might not hold. The permission at 352.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  295.6: The precondition at 352.12 might not hold. Insufficient fraction at 352.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_661[this#226, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_661[this#226, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_661[this#226, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_661[this#226, AVLTreeNode.balanceFactor] := exhaleMask#_661[this#226, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_661[this#226, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_661, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_661;
        assume IsGoodExhaleState(exhaleHeap#_660, Heap, Mask, exhaledHolds#_662);
        Heap := exhaleHeap#_660;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#227;
        havoc m#228;
        // inhale (postcondition)
        if (!(r#227 == null)) {
          assume r#227 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[r#227, AVLTreeNode.valid] := Mask[r#227, AVLTreeNode.valid][perm$R := Mask[r#227, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#227 == null)) {
          assume r#227 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#227, AVLTreeNode.keys] := Mask[r#227, AVLTreeNode.keys][perm$R := Mask[r#227, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#227 == null)) {
          assume r#227 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#227, AVLTreeNode.height] := Mask[r#227, AVLTreeNode.height][perm$R := Mask[r#227, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#227 == null)) {
          assume r#227 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#227, AVLTreeNode.balanceFactor] := Mask[r#227, AVLTreeNode.balanceFactor][perm$R := Mask[r#227, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#227 == null)) {
          assume (Heap[r#227, AVLTreeNode.height] == callHeap#_655[this#226, AVLTreeNode.height]) || ((Heap[r#227, AVLTreeNode.height] + 1) == callHeap#_655[this#226, AVLTreeNode.height]);
        }
        if (!(r#227 == null)) {
          assume (Seq#Length(Heap[r#227, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_655[this#226, AVLTreeNode.keys]);
        }
        if (callHeap#_655[this#226, AVLTreeNode.height] > 1) {
          assume !(r#227 == null);
        }
        if (callHeap#_655[this#226, AVLTreeNode.height] == 1) {
          assume r#227 == null;
        }
        assume (callHeap#_655[this#226, AVLTreeNode.height] == ite(r#227 == null, 0, Heap[r#227, AVLTreeNode.height])) || (callHeap#_655[this#226, AVLTreeNode.height] == (ite(r#227 == null, 0, Heap[r#227, AVLTreeNode.height]) + 1));
        assume !(m#228 == null);
        assume m#228 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[m#228, AVLTreeNode.valid] := Mask[m#228, AVLTreeNode.valid][perm$R := Mask[m#228, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#228 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[m#228, AVLTreeNode.keys] := Mask[m#228, AVLTreeNode.keys][perm$R := Mask[m#228, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#228 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[m#228, AVLTreeNode.height] := Mask[m#228, AVLTreeNode.height][perm$R := Mask[m#228, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#228 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[m#228, AVLTreeNode.balanceFactor] := Mask[m#228, AVLTreeNode.balanceFactor][perm$R := Mask[m#228, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[m#228, AVLTreeNode.height] == 1;
        assume Seq#Length(Heap[m#228, AVLTreeNode.keys]) == 1;
        assume Seq#Equal(Seq#Append(ite(r#227 == null, Seq#Empty(), Heap[r#227, AVLTreeNode.keys]), Heap[m#228, AVLTreeNode.keys]), callHeap#_655[this#226, AVLTreeNode.keys]);
        if (!(r#227 == null)) {
          assume (forall k#86#229: int :: 
            (0 <= k#86#229) && (k#86#229 < Seq#Length(Heap[r#227, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#227, AVLTreeNode.keys], k#86#229) < Seq#Index(Heap[m#228, AVLTreeNode.keys], 0))
          );
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nl#24 := r#227;
        r#20 := m#228;
      } else {
        assume (0.0 < methodCallK#_674) && ((1000.0 * methodCallK#_674) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_674) < methodK#_554);
        // call pruneMin
        callHeap#_670 := Heap;
        callMask#_671 := Mask;
        callSecMask#_672 := SecMask;
        callCredits#_673 := Credits;
        assume wf(callHeap#_670, callMask#_671, callSecMask#_672);
        assert {:msg "  297.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  297.19: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  297.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#230 := Heap[this, AVLTreeNode.right];
        // begin exhale (precondition)
        exhaleMask#_676 := Mask;
        havoc exhaleHeap#_675;
        exhaledHolds#_677 := ZeroRefSet;
        assert {:msg "  297.6: The precondition at 404.12 might not hold. The permission at 404.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  297.6: The precondition at 404.12 might not hold. Insufficient fraction at 404.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_676[this#230, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_676[this#230, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_676[this#230, AVLTreeNode.valid][perm$N]));
        exhaleMask#_676[this#230, AVLTreeNode.valid] := exhaleMask#_676[this#230, AVLTreeNode.valid][perm$R := exhaleMask#_676[this#230, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_676, this#230, AVLTreeNode.valid)) {
          assume Heap[this#230, AVLTreeNode.valid] < exhaleHeap#_675[this#230, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_676, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  297.6: The precondition at 405.12 might not hold. The permission at 405.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  297.6: The precondition at 405.12 might not hold. Insufficient fraction at 405.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_676[this#230, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_676[this#230, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_676[this#230, AVLTreeNode.keys][perm$N]));
        exhaleMask#_676[this#230, AVLTreeNode.keys] := exhaleMask#_676[this#230, AVLTreeNode.keys][perm$R := exhaleMask#_676[this#230, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_676, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  297.6: The precondition at 406.12 might not hold. The permission at 406.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  297.6: The precondition at 406.12 might not hold. Insufficient fraction at 406.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_676[this#230, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_676[this#230, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_676[this#230, AVLTreeNode.height][perm$N]));
        exhaleMask#_676[this#230, AVLTreeNode.height] := exhaleMask#_676[this#230, AVLTreeNode.height][perm$R := exhaleMask#_676[this#230, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_676, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  297.6: The precondition at 407.12 might not hold. The permission at 407.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  297.6: The precondition at 407.12 might not hold. Insufficient fraction at 407.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_676[this#230, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_676[this#230, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_676[this#230, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_676[this#230, AVLTreeNode.balanceFactor] := exhaleMask#_676[this#230, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_676[this#230, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_676, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_676;
        assume IsGoodExhaleState(exhaleHeap#_675, Heap, Mask, exhaledHolds#_677);
        Heap := exhaleHeap#_675;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#231;
        havoc m#232;
        // inhale (postcondition)
        if (!(r#231 == null)) {
          assume r#231 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[r#231, AVLTreeNode.valid] := Mask[r#231, AVLTreeNode.valid][perm$R := Mask[r#231, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#231 == null)) {
          assume r#231 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#231, AVLTreeNode.keys] := Mask[r#231, AVLTreeNode.keys][perm$R := Mask[r#231, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#231 == null)) {
          assume r#231 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#231, AVLTreeNode.height] := Mask[r#231, AVLTreeNode.height][perm$R := Mask[r#231, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#231 == null)) {
          assume r#231 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#231, AVLTreeNode.balanceFactor] := Mask[r#231, AVLTreeNode.balanceFactor][perm$R := Mask[r#231, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#231 == null)) {
          assume (Heap[r#231, AVLTreeNode.height] == callHeap#_670[this#230, AVLTreeNode.height]) || (Heap[r#231, AVLTreeNode.height] == (callHeap#_670[this#230, AVLTreeNode.height] - 1));
        }
        if (!(r#231 == null)) {
          assume (Seq#Length(Heap[r#231, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_670[this#230, AVLTreeNode.keys]);
        }
        if (callHeap#_670[this#230, AVLTreeNode.height] > 1) {
          assume !(r#231 == null);
        }
        if (callHeap#_670[this#230, AVLTreeNode.height] == 1) {
          assume r#231 == null;
        }
        assume (callHeap#_670[this#230, AVLTreeNode.height] == ite(r#231 == null, 0, Heap[r#231, AVLTreeNode.height])) || (callHeap#_670[this#230, AVLTreeNode.height] == (ite(r#231 == null, 0, Heap[r#231, AVLTreeNode.height]) + 1));
        assume !(m#232 == null);
        assume m#232 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[m#232, AVLTreeNode.valid] := Mask[m#232, AVLTreeNode.valid][perm$R := Mask[m#232, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#232 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[m#232, AVLTreeNode.keys] := Mask[m#232, AVLTreeNode.keys][perm$R := Mask[m#232, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#232 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[m#232, AVLTreeNode.height] := Mask[m#232, AVLTreeNode.height][perm$R := Mask[m#232, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume m#232 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[m#232, AVLTreeNode.balanceFactor] := Mask[m#232, AVLTreeNode.balanceFactor][perm$R := Mask[m#232, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Heap[m#232, AVLTreeNode.height] == 1;
        assume Seq#Length(Heap[m#232, AVLTreeNode.keys]) == 1;
        assume Seq#Equal(Seq#Append(Heap[m#232, AVLTreeNode.keys], ite(r#231 == null, Seq#Empty(), Heap[r#231, AVLTreeNode.keys])), callHeap#_670[this#230, AVLTreeNode.keys]);
        if (!(r#231 == null)) {
          assume (forall k#89#233: int :: 
            (0 <= k#89#233) && (k#89#233 < Seq#Length(Heap[r#231, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#232, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#231, AVLTreeNode.keys], k#89#233))
          );
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nr#26 := r#231;
        r#20 := m#232;
      }
      // unfold
      assume #AVLTreeNode.valid#trigger(r#20);
      predRec#_686 := r#20;
      predVer#_687 := Heap[r#20, AVLTreeNode.valid];
      assume (0.0 < unfoldK#_685) && (unfoldK#_685 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_685) < methodK#_554);
      assert {:msg "  299.5: The target of the fold statement might be null."} r#20 != null;
      // begin exhale (unfold)
      assert {:msg "  299.5: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  299.5: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[r#20, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[r#20, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[r#20, AVLTreeNode.valid][perm$N]));
      Mask[r#20, AVLTreeNode.valid] := Mask[r#20, AVLTreeNode.valid][perm$R := Mask[r#20, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(Mask, r#20, AVLTreeNode.valid)) {
        oldVers#_692 := Heap[r#20, AVLTreeNode.valid];
        havoc newVers#_693;
        Heap[r#20, AVLTreeNode.valid] := newVers#_693;
        assume oldVers#_692 < Heap[r#20, AVLTreeNode.valid];
      }
      assume wf(Heap, Mask, SecMask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (unfold)
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(100) * 0.01) > 0.0;
      Mask[r#20, AVLTreeNode.key] := Mask[r#20, AVLTreeNode.key][perm$R := Mask[r#20, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#20, AVLTreeNode.height] := Mask[r#20, AVLTreeNode.height][perm$R := Mask[r#20, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#20, AVLTreeNode.left] == null) || (dtype(Heap[r#20, AVLTreeNode.left]) == AVLTreeNode#t);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#20, AVLTreeNode.left] := Mask[r#20, AVLTreeNode.left][perm$R := Mask[r#20, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#20, AVLTreeNode.right] == null) || (dtype(Heap[r#20, AVLTreeNode.right]) == AVLTreeNode#t);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#20, AVLTreeNode.right] := Mask[r#20, AVLTreeNode.right][perm$R := Mask[r#20, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#20, AVLTreeNode.keys] := Mask[r#20, AVLTreeNode.keys][perm$R := Mask[r#20, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#20 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#20, AVLTreeNode.balanceFactor] := Mask[r#20, AVLTreeNode.balanceFactor][perm$R := Mask[r#20, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume #predicateInside#(predRec#_686, AVLTreeNode.valid, predVer#_687, Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid]);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume (forall lk#79#234: int :: 
          (0 <= lk#79#234) && (lk#79#234 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], lk#79#234) < Heap[r#20, AVLTreeNode.key])
        );
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] > 0;
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume #predicateInside#(predRec#_686, AVLTreeNode.valid, predVer#_687, Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid]);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume (forall rk#80#235: int :: 
          (0 <= rk#80#235) && (rk#80#235 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#20, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], rk#80#235))
        );
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] > 0;
      }
      assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#20, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#20, AVLTreeNode.key])), ite(Heap[r#20, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Seq#Contains(Heap[r#20, AVLTreeNode.keys], Heap[r#20, AVLTreeNode.key]);
      assume (forall kk#81: int :: 
        Seq#Contains(Heap[r#20, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#20, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#20, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#20, AVLTreeNode.key]))
      );
      assume Heap[r#20, AVLTreeNode.height] == ite(ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[r#20, AVLTreeNode.balanceFactor] == (ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]));
      assume Heap[r#20, AVLTreeNode.balanceFactor] <= 1;
      assume Heap[r#20, AVLTreeNode.balanceFactor] >= (0 - 1);
      assume Heap[r#20, AVLTreeNode.height] > 0;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      // update field left
      assert {:msg "  300.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.left);
      Heap[r#20, AVLTreeNode.left] := nl#24;
      assume wf(Heap, Mask, SecMask);
      // update field right
      assert {:msg "  301.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.right);
      Heap[r#20, AVLTreeNode.right] := nr#26;
      assume wf(Heap, Mask, SecMask);
      assume (0.0 < methodCallK#_699) && ((1000.0 * methodCallK#_699) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_699) < methodK#_554);
      // call close
      callHeap#_695 := Heap;
      callMask#_696 := Mask;
      callSecMask#_697 := SecMask;
      callCredits#_698 := Credits;
      assume wf(callHeap#_695, callMask#_696, callSecMask#_697);
      assert {:msg "  302.5: The target of the method call might be null."} r#20 != null;
      this#236 := r#20;
      // begin exhale (precondition)
      exhaleMask#_701 := Mask;
      havoc exhaleHeap#_700;
      exhaledHolds#_702 := ZeroRefSet;
      if (!(Heap[this#236, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#237: int :: 
          (0 <= k#92#237) && (k#92#237 < Seq#Length(Heap[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys], k#92#237) < Heap[this#236, AVLTreeNode.key])
        );
      }
      if (!(Heap[this#236, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#238: int :: 
          (0 <= k#93#238) && (k#93#238 < Seq#Length(Heap[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#236, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys], k#93#238))
        );
      }
      assert {:msg "  302.5: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#236, AVLTreeNode.left] == null, 0, Heap[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#236, AVLTreeNode.right] == null, 0, Heap[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  302.5: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#236, AVLTreeNode.left] == null, 0, Heap[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#236, AVLTreeNode.right] == null, 0, Heap[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      assert {:msg "  302.5: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  302.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_701[this#236, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[this#236, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_701[this#236, AVLTreeNode.key][perm$N]));
      exhaleMask#_701[this#236, AVLTreeNode.key] := exhaleMask#_701[this#236, AVLTreeNode.key][perm$R := exhaleMask#_701[this#236, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_701, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  302.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_701[this#236, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[this#236, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_701[this#236, AVLTreeNode.height][perm$N]));
      exhaleMask#_701[this#236, AVLTreeNode.height] := exhaleMask#_701[this#236, AVLTreeNode.height][perm$R := exhaleMask#_701[this#236, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_701, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  302.5: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_701[this#236, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[this#236, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_701[this#236, AVLTreeNode.left][perm$N]));
      exhaleMask#_701[this#236, AVLTreeNode.left] := exhaleMask#_701[this#236, AVLTreeNode.left][perm$R := exhaleMask#_701[this#236, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_701, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  302.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_701[this#236, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[this#236, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_701[this#236, AVLTreeNode.right][perm$N]));
      exhaleMask#_701[this#236, AVLTreeNode.right] := exhaleMask#_701[this#236, AVLTreeNode.right][perm$R := exhaleMask#_701[this#236, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_701, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  302.5: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_701[this#236, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[this#236, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_701[this#236, AVLTreeNode.keys][perm$N]));
      exhaleMask#_701[this#236, AVLTreeNode.keys] := exhaleMask#_701[this#236, AVLTreeNode.keys][perm$R := exhaleMask#_701[this#236, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_701, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  302.5: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  302.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_701[this#236, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[this#236, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_701[this#236, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_701[this#236, AVLTreeNode.balanceFactor] := exhaleMask#_701[this#236, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_701[this#236, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_701, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#236, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_701, Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_700[Heap[this#236, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.left] == null)) {
        assert {:msg "  302.5: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_701, Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_700[Heap[this#236, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#236, AVLTreeNode.right] == null)) {
        assert {:msg "  302.5: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  302.5: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_701[Heap[this#236, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_701, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_701;
      assume IsGoodExhaleState(exhaleHeap#_700, Heap, Mask, exhaledHolds#_702);
      Heap := exhaleHeap#_700;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (postcondition)
      assume this#236 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[this#236, AVLTreeNode.valid] := Mask[this#236, AVLTreeNode.valid][perm$R := Mask[this#236, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#236 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#236, AVLTreeNode.height] := Mask[this#236, AVLTreeNode.height][perm$R := Mask[this#236, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#236 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#236, AVLTreeNode.keys] := Mask[this#236, AVLTreeNode.keys][perm$R := Mask[this#236, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#236 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#236, AVLTreeNode.balanceFactor] := Mask[this#236, AVLTreeNode.balanceFactor][perm$R := Mask[this#236, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume Seq#Equal(Heap[this#236, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_695[this#236, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_695[callHeap#_695[this#236, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_695[this#236, AVLTreeNode.key])), ite(callHeap#_695[this#236, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_695[callHeap#_695[this#236, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Heap[this#236, AVLTreeNode.height] == ite(ite(callHeap#_695[this#236, AVLTreeNode.left] == null, 0, callHeap#_695[callHeap#_695[this#236, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_695[this#236, AVLTreeNode.right] == null, 0, callHeap#_695[callHeap#_695[this#236, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_695[this#236, AVLTreeNode.left] == null, 0, callHeap#_695[callHeap#_695[this#236, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_695[this#236, AVLTreeNode.right] == null, 0, callHeap#_695[callHeap#_695[this#236, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#236, AVLTreeNode.balanceFactor] == (ite(callHeap#_695[this#236, AVLTreeNode.left] == null, 0, callHeap#_695[callHeap#_695[this#236, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_695[this#236, AVLTreeNode.right] == null, 0, callHeap#_695[callHeap#_695[this#236, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
    }
  } else {
    // if
    cond#_720 := k#19 < Heap[this, AVLTreeNode.key];
    assert {:msg "  305.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  305.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (cond#_720) {
      // if
      cond#_721 := !(Heap[this, AVLTreeNode.left] == null);
      assert {:msg "  306.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  306.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (cond#_721) {
        // local var nl
        assume (0.0 < methodCallK#_726) && ((1000.0 * methodCallK#_726) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_726) < methodK#_554);
        // call remove
        callHeap#_722 := Heap;
        callMask#_723 := Mask;
        callSecMask#_724 := SecMask;
        callCredits#_725 := Credits;
        assume wf(callHeap#_722, callMask#_723, callSecMask#_724);
        assert {:msg "  308.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  308.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  308.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#241 := Heap[this, AVLTreeNode.left];
        k#242 := k#19;
        // begin exhale (precondition)
        exhaleMask#_728 := Mask;
        havoc exhaleHeap#_727;
        exhaledHolds#_729 := ZeroRefSet;
        assert {:msg "  308.6: The precondition at 254.12 might not hold. The permission at 254.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  308.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_728[this#241, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_728[this#241, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_728[this#241, AVLTreeNode.valid][perm$N]));
        exhaleMask#_728[this#241, AVLTreeNode.valid] := exhaleMask#_728[this#241, AVLTreeNode.valid][perm$R := exhaleMask#_728[this#241, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_728, this#241, AVLTreeNode.valid)) {
          assume Heap[this#241, AVLTreeNode.valid] < exhaleHeap#_727[this#241, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_728, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  308.6: The precondition at 255.12 might not hold. The permission at 255.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  308.6: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_728[this#241, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_728[this#241, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_728[this#241, AVLTreeNode.keys][perm$N]));
        exhaleMask#_728[this#241, AVLTreeNode.keys] := exhaleMask#_728[this#241, AVLTreeNode.keys][perm$R := exhaleMask#_728[this#241, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_728, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  308.6: The precondition at 256.12 might not hold. The permission at 256.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  308.6: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_728[this#241, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_728[this#241, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_728[this#241, AVLTreeNode.height][perm$N]));
        exhaleMask#_728[this#241, AVLTreeNode.height] := exhaleMask#_728[this#241, AVLTreeNode.height][perm$R := exhaleMask#_728[this#241, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_728, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  308.6: The precondition at 257.12 might not hold. The permission at 257.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  308.6: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_728[this#241, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_728[this#241, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_728[this#241, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_728[this#241, AVLTreeNode.balanceFactor] := exhaleMask#_728[this#241, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_728[this#241, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_728, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_728;
        assume IsGoodExhaleState(exhaleHeap#_727, Heap, Mask, exhaledHolds#_729);
        Heap := exhaleHeap#_727;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#243;
        // inhale (postcondition)
        if (Seq#Equal(callHeap#_722[this#241, AVLTreeNode.keys], Seq#Singleton(k#242))) {
          assume r#243 == null;
        }
        if (!Seq#Equal(callHeap#_722[this#241, AVLTreeNode.keys], Seq#Singleton(k#242))) {
          assume !(r#243 == null);
        }
        if (!(r#243 == null)) {
          assume r#243 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[r#243, AVLTreeNode.valid] := Mask[r#243, AVLTreeNode.valid][perm$R := Mask[r#243, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#243 == null)) {
          assume r#243 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#243, AVLTreeNode.keys] := Mask[r#243, AVLTreeNode.keys][perm$R := Mask[r#243, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#243 == null)) {
          assume r#243 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#243, AVLTreeNode.height] := Mask[r#243, AVLTreeNode.height][perm$R := Mask[r#243, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#243 == null)) {
          assume r#243 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#243, AVLTreeNode.balanceFactor] := Mask[r#243, AVLTreeNode.balanceFactor][perm$R := Mask[r#243, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#243 == null)) {
          assume !Seq#Contains(Heap[r#243, AVLTreeNode.keys], k#242);
        }
        if (!(r#243 == null)) {
          assume (forall i#84#244: int :: 
            (0 <= i#84#244) && (i#84#244 < Seq#Length(callHeap#_722[this#241, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#243, AVLTreeNode.keys], Seq#Index(callHeap#_722[this#241, AVLTreeNode.keys], i#84#244)) || (Seq#Index(callHeap#_722[this#241, AVLTreeNode.keys], i#84#244) == k#242))
          );
        }
        if (!(r#243 == null)) {
          assume (forall i#85#245: int :: 
            (0 <= i#85#245) && (i#85#245 < Seq#Length(Heap[r#243, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_722[this#241, AVLTreeNode.keys], Seq#Index(Heap[r#243, AVLTreeNode.keys], i#85#245)) && (!(Seq#Index(Heap[r#243, AVLTreeNode.keys], i#85#245) == k#242))
          );
        }
        if (!Seq#Contains(callHeap#_722[this#241, AVLTreeNode.keys], k#242)) {
          assume !(r#243 == null);
        }
        if (!Seq#Contains(callHeap#_722[this#241, AVLTreeNode.keys], k#242)) {
          assume Seq#Equal(Heap[r#243, AVLTreeNode.keys], callHeap#_722[this#241, AVLTreeNode.keys]);
        }
        if (!(r#243 == null)) {
          if (Seq#Contains(callHeap#_722[this#241, AVLTreeNode.keys], k#242)) {
            assume Seq#Length(Heap[r#243, AVLTreeNode.keys]) == (Seq#Length(callHeap#_722[this#241, AVLTreeNode.keys]) - 1);
          }
        }
        if (callHeap#_722[this#241, AVLTreeNode.height] > 1) {
          assume !(r#243 == null);
        }
        if (!(r#243 == null)) {
          assume (Heap[r#243, AVLTreeNode.height] == callHeap#_722[this#241, AVLTreeNode.height]) || ((Heap[r#243, AVLTreeNode.height] + 1) == callHeap#_722[this#241, AVLTreeNode.height]);
        }
        if (!Seq#Contains(callHeap#_722[this#241, AVLTreeNode.keys], k#242)) {
          assume Heap[r#243, AVLTreeNode.height] == callHeap#_722[this#241, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nl#28 := r#243;
        // update field left
        assert {:msg "  309.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
        Heap[this, AVLTreeNode.left] := nl#28;
        assume wf(Heap, Mask, SecMask);
        // local var bf
        assume (0.0 < methodCallK#_741) && ((1000.0 * methodCallK#_741) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_741) < methodK#_554);
        // call getBalanceFactorI
        callHeap#_737 := Heap;
        callMask#_738 := Mask;
        callSecMask#_739 := SecMask;
        callCredits#_740 := Credits;
        assume wf(callHeap#_737, callMask#_738, callSecMask#_739);
        assert {:msg "  312.6: The target of the method call might be null."} this != null;
        this#246 := this;
        // begin exhale (precondition)
        exhaleMask#_743 := Mask;
        havoc exhaleHeap#_742;
        exhaledHolds#_744 := ZeroRefSet;
        assert {:msg "  312.6: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_741 > 0.0;
        assert {:msg "  312.6: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_743[this#246, AVLTreeNode.left][perm$R] > 0.0;
        assume methodCallK#_741 < exhaleMask#_743[this#246, AVLTreeNode.left][perm$R];
        exhaleMask#_743[this#246, AVLTreeNode.left] := exhaleMask#_743[this#246, AVLTreeNode.left][perm$R := exhaleMask#_743[this#246, AVLTreeNode.left][perm$R] - methodCallK#_741];
        assume wf(Heap, exhaleMask#_743, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#246, AVLTreeNode.left] == null)) {
          assert {:msg "  312.6: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_741 > 0.0;
          assert {:msg "  312.6: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
          assume methodCallK#_741 < exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height][perm$R];
          exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_741];
          assume wf(Heap, exhaleMask#_743, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assert {:msg "  312.6: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_741 > 0.0;
        assert {:msg "  312.6: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_743[this#246, AVLTreeNode.right][perm$R] > 0.0;
        assume methodCallK#_741 < exhaleMask#_743[this#246, AVLTreeNode.right][perm$R];
        exhaleMask#_743[this#246, AVLTreeNode.right] := exhaleMask#_743[this#246, AVLTreeNode.right][perm$R := exhaleMask#_743[this#246, AVLTreeNode.right][perm$R] - methodCallK#_741];
        assume wf(Heap, exhaleMask#_743, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#246, AVLTreeNode.right] == null)) {
          assert {:msg "  312.6: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_741 > 0.0;
          assert {:msg "  312.6: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
          assume methodCallK#_741 < exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height][perm$R];
          exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_741];
          assume wf(Heap, exhaleMask#_743, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#246, AVLTreeNode.left] == null)) {
          assert {:msg "  312.6: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  312.6: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_743[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_743, Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_742[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_743, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#246, AVLTreeNode.right] == null)) {
          assert {:msg "  312.6: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  312.6: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_743[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_743, Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_742[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_743, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_743;
        assume IsGoodExhaleState(exhaleHeap#_742, Heap, Mask, exhaledHolds#_744);
        Heap := exhaleHeap#_742;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc bf#247;
        // inhale (postcondition)
        assume this#246 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#246, AVLTreeNode.left] == null) || (dtype(Heap[this#246, AVLTreeNode.left]) == AVLTreeNode#t);
        assume methodCallK#_741 > 0.0;
        Mask[this#246, AVLTreeNode.left] := Mask[this#246, AVLTreeNode.left][perm$R := Mask[this#246, AVLTreeNode.left][perm$R] + methodCallK#_741];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#246, AVLTreeNode.left] == null)) {
          assume Heap[this#246, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#246, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#246, AVLTreeNode.left] == null)) {
          assume Heap[this#246, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_741 > 0.0;
          Mask[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_741];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume this#246 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#246, AVLTreeNode.right] == null) || (dtype(Heap[this#246, AVLTreeNode.right]) == AVLTreeNode#t);
        assume methodCallK#_741 > 0.0;
        Mask[this#246, AVLTreeNode.right] := Mask[this#246, AVLTreeNode.right][perm$R := Mask[this#246, AVLTreeNode.right][perm$R] + methodCallK#_741];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#246, AVLTreeNode.right] == null)) {
          assume Heap[this#246, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#246, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#246, AVLTreeNode.right] == null)) {
          assume Heap[this#246, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_741 > 0.0;
          Mask[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_741];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume bf#247 == (ite(Heap[this#246, AVLTreeNode.left] == null, 0, Heap[Heap[this#246, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#246, AVLTreeNode.right] == null, 0, Heap[Heap[this#246, AVLTreeNode.right], AVLTreeNode.height]));
        if (bf#247 > 0) {
          assume !(Heap[this#246, AVLTreeNode.left] == null);
        }
        if (bf#247 < 0) {
          assume !(Heap[this#246, AVLTreeNode.right] == null);
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        bf#30 := bf#247;
        // if
        cond#_754 := bf#30 == (0 - 2);
        if (cond#_754) {
          assume (0.0 < methodCallK#_759) && ((1000.0 * methodCallK#_759) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_759) < methodK#_554);
          // call rebalanceRight
          callHeap#_755 := Heap;
          callMask#_756 := Mask;
          callSecMask#_757 := SecMask;
          callCredits#_758 := Credits;
          assume wf(callHeap#_755, callMask#_756, callSecMask#_757);
          assert {:msg "  315.7: The target of the method call might be null."} this != null;
          this#248 := this;
          // begin exhale (precondition)
          exhaleMask#_761 := Mask;
          havoc exhaleHeap#_760;
          exhaledHolds#_762 := ZeroRefSet;
          if (!(Heap[this#248, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 758.12 might not hold. The expression at 758.25 might not evaluate to true."} (forall k#104#250: int :: 
              (0 <= k#104#250) && (k#104#250 < Seq#Length(Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys], k#104#250) < Heap[this#248, AVLTreeNode.key])
            );
          }
          assert {:msg "  315.7: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} !(Heap[this#248, AVLTreeNode.right] == null);
          assert {:msg "  315.7: The precondition at 765.12 might not hold. The expression at 765.12 might not evaluate to true."} (forall k#105#251: int :: 
            (0 <= k#105#251) && (k#105#251 < Seq#Length(Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#248, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys], k#105#251))
          );
          assert {:msg "  315.7: The precondition at 768.12 might not hold. The expression at 768.12 might not evaluate to true."} (ite(Heap[this#248, AVLTreeNode.left] == null, 0, Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
          assert {:msg "  315.7: The precondition at 746.12 might not hold. The permission at 746.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_761[this#248, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[this#248, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_761[this#248, AVLTreeNode.key][perm$N]));
          exhaleMask#_761[this#248, AVLTreeNode.key] := exhaleMask#_761[this#248, AVLTreeNode.key][perm$R := exhaleMask#_761[this#248, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 747.12 might not hold. The permission at 747.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_761[this#248, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[this#248, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_761[this#248, AVLTreeNode.height][perm$N]));
          exhaleMask#_761[this#248, AVLTreeNode.height] := exhaleMask#_761[this#248, AVLTreeNode.height][perm$R := exhaleMask#_761[this#248, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 748.12 might not hold. The permission at 748.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 748.12 might not hold. Insufficient fraction at 748.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_761[this#248, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[this#248, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_761[this#248, AVLTreeNode.left][perm$N]));
          exhaleMask#_761[this#248, AVLTreeNode.left] := exhaleMask#_761[this#248, AVLTreeNode.left][perm$R := exhaleMask#_761[this#248, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 749.12 might not hold. The permission at 749.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 749.12 might not hold. Insufficient fraction at 749.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_761[this#248, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[this#248, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_761[this#248, AVLTreeNode.right][perm$N]));
          exhaleMask#_761[this#248, AVLTreeNode.right] := exhaleMask#_761[this#248, AVLTreeNode.right][perm$R := exhaleMask#_761[this#248, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 751.12 might not hold. The permission at 751.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 751.12 might not hold. Insufficient fraction at 751.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_761[this#248, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[this#248, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_761[this#248, AVLTreeNode.keys][perm$N]));
          exhaleMask#_761[this#248, AVLTreeNode.keys] := exhaleMask#_761[this#248, AVLTreeNode.keys][perm$R := exhaleMask#_761[this#248, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 752.12 might not hold. The permission at 752.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 752.12 might not hold. Insufficient fraction at 752.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_761[this#248, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[this#248, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_761[this#248, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_761[this#248, AVLTreeNode.balanceFactor] := exhaleMask#_761[this#248, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_761[this#248, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#248, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 754.12 might not hold. The permission at 754.25 might not be positive."} (real(100) * 0.01) > 0.0;
            assert {:msg "  315.7: The precondition at 754.12 might not hold. Insufficient fraction at 754.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
            if (!CanRead(exhaleMask#_761, Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid)) {
              assume Heap[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_760[Heap[this#248, AVLTreeNode.left], AVLTreeNode.valid];
            }
            assume wf(Heap, exhaleMask#_761, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#248, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 755.12 might not hold. The permission at 755.25 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  315.7: The precondition at 755.12 might not hold. Insufficient fraction at 755.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_761, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#248, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 756.12 might not hold. The permission at 756.25 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  315.7: The precondition at 756.12 might not hold. Insufficient fraction at 756.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_761, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#248, AVLTreeNode.left] == null)) {
            assert {:msg "  315.7: The precondition at 757.12 might not hold. The permission at 757.25 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  315.7: The precondition at 757.12 might not hold. Insufficient fraction at 757.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_761, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          assert {:msg "  315.7: The precondition at 761.12 might not hold. The permission at 761.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 761.12 might not hold. Insufficient fraction at 761.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_761, Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_760[Heap[this#248, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 762.12 might not hold. The permission at 762.12 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 762.12 might not hold. Insufficient fraction at 762.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 763.12 might not hold. The permission at 763.12 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 763.12 might not hold. Insufficient fraction at 763.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  315.7: The precondition at 764.12 might not hold. The permission at 764.12 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  315.7: The precondition at 764.12 might not hold. Insufficient fraction at 764.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_761[Heap[this#248, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_761, SecMask);
          assume wf(Heap, Mask, SecMask);
          Mask := exhaleMask#_761;
          assume IsGoodExhaleState(exhaleHeap#_760, Heap, Mask, exhaledHolds#_762);
          Heap := exhaleHeap#_760;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          havoc r#249;
          // inhale (postcondition)
          assume !(r#249 == null);
          assume r#249 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[r#249, AVLTreeNode.valid] := Mask[r#249, AVLTreeNode.valid][perm$R := Mask[r#249, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#249 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#249, AVLTreeNode.height] := Mask[r#249, AVLTreeNode.height][perm$R := Mask[r#249, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#249 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#249, AVLTreeNode.keys] := Mask[r#249, AVLTreeNode.keys][perm$R := Mask[r#249, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#249 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#249, AVLTreeNode.balanceFactor] := Mask[r#249, AVLTreeNode.balanceFactor][perm$R := Mask[r#249, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume (Heap[r#249, AVLTreeNode.height] == callHeap#_755[callHeap#_755[this#248, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#249, AVLTreeNode.height] == (callHeap#_755[callHeap#_755[this#248, AVLTreeNode.right], AVLTreeNode.height] + 1));
          assume Seq#Equal(Heap[r#249, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_755[this#248, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_755[callHeap#_755[this#248, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_755[this#248, AVLTreeNode.key])), callHeap#_755[callHeap#_755[this#248, AVLTreeNode.right], AVLTreeNode.keys]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
          r#20 := r#249;
        } else {
          assume (0.0 < methodCallK#_784) && ((1000.0 * methodCallK#_784) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_784) < methodK#_554);
          // call close
          callHeap#_780 := Heap;
          callMask#_781 := Mask;
          callSecMask#_782 := SecMask;
          callCredits#_783 := Credits;
          assume wf(callHeap#_780, callMask#_781, callSecMask#_782);
          assert {:msg "  317.7: The target of the method call might be null."} this != null;
          this#254 := this;
          // begin exhale (precondition)
          exhaleMask#_786 := Mask;
          havoc exhaleHeap#_785;
          exhaledHolds#_787 := ZeroRefSet;
          if (!(Heap[this#254, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#255: int :: 
              (0 <= k#92#255) && (k#92#255 < Seq#Length(Heap[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys], k#92#255) < Heap[this#254, AVLTreeNode.key])
            );
          }
          if (!(Heap[this#254, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#256: int :: 
              (0 <= k#93#256) && (k#93#256 < Seq#Length(Heap[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#254, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys], k#93#256))
            );
          }
          assert {:msg "  317.7: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#254, AVLTreeNode.left] == null, 0, Heap[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#254, AVLTreeNode.right] == null, 0, Heap[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
          assert {:msg "  317.7: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#254, AVLTreeNode.left] == null, 0, Heap[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#254, AVLTreeNode.right] == null, 0, Heap[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
          assert {:msg "  317.7: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  317.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_786[this#254, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[this#254, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_786[this#254, AVLTreeNode.key][perm$N]));
          exhaleMask#_786[this#254, AVLTreeNode.key] := exhaleMask#_786[this#254, AVLTreeNode.key][perm$R := exhaleMask#_786[this#254, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_786, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  317.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_786[this#254, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[this#254, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_786[this#254, AVLTreeNode.height][perm$N]));
          exhaleMask#_786[this#254, AVLTreeNode.height] := exhaleMask#_786[this#254, AVLTreeNode.height][perm$R := exhaleMask#_786[this#254, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_786, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  317.7: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_786[this#254, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[this#254, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_786[this#254, AVLTreeNode.left][perm$N]));
          exhaleMask#_786[this#254, AVLTreeNode.left] := exhaleMask#_786[this#254, AVLTreeNode.left][perm$R := exhaleMask#_786[this#254, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_786, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  317.7: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_786[this#254, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[this#254, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_786[this#254, AVLTreeNode.right][perm$N]));
          exhaleMask#_786[this#254, AVLTreeNode.right] := exhaleMask#_786[this#254, AVLTreeNode.right][perm$R := exhaleMask#_786[this#254, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_786, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  317.7: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_786[this#254, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[this#254, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_786[this#254, AVLTreeNode.keys][perm$N]));
          exhaleMask#_786[this#254, AVLTreeNode.keys] := exhaleMask#_786[this#254, AVLTreeNode.keys][perm$R := exhaleMask#_786[this#254, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_786, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  317.7: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  317.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_786[this#254, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[this#254, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_786[this#254, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_786[this#254, AVLTreeNode.balanceFactor] := exhaleMask#_786[this#254, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_786[this#254, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_786, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#254, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
            if (!CanRead(exhaleMask#_786, Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid)) {
              assume Heap[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_785[Heap[this#254, AVLTreeNode.left], AVLTreeNode.valid];
            }
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.left] == null)) {
            assert {:msg "  317.7: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
            if (!CanRead(exhaleMask#_786, Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid)) {
              assume Heap[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_785[Heap[this#254, AVLTreeNode.right], AVLTreeNode.valid];
            }
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#254, AVLTreeNode.right] == null)) {
            assert {:msg "  317.7: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  317.7: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_786[Heap[this#254, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_786, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          Mask := exhaleMask#_786;
          assume IsGoodExhaleState(exhaleHeap#_785, Heap, Mask, exhaledHolds#_787);
          Heap := exhaleHeap#_785;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          // inhale (postcondition)
          assume this#254 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[this#254, AVLTreeNode.valid] := Mask[this#254, AVLTreeNode.valid][perm$R := Mask[this#254, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#254 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[this#254, AVLTreeNode.height] := Mask[this#254, AVLTreeNode.height][perm$R := Mask[this#254, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#254 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[this#254, AVLTreeNode.keys] := Mask[this#254, AVLTreeNode.keys][perm$R := Mask[this#254, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#254 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[this#254, AVLTreeNode.balanceFactor] := Mask[this#254, AVLTreeNode.balanceFactor][perm$R := Mask[this#254, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume Seq#Equal(Heap[this#254, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_780[this#254, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_780[callHeap#_780[this#254, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_780[this#254, AVLTreeNode.key])), ite(callHeap#_780[this#254, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_780[callHeap#_780[this#254, AVLTreeNode.right], AVLTreeNode.keys])));
          assume Heap[this#254, AVLTreeNode.height] == ite(ite(callHeap#_780[this#254, AVLTreeNode.left] == null, 0, callHeap#_780[callHeap#_780[this#254, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_780[this#254, AVLTreeNode.right] == null, 0, callHeap#_780[callHeap#_780[this#254, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_780[this#254, AVLTreeNode.left] == null, 0, callHeap#_780[callHeap#_780[this#254, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_780[this#254, AVLTreeNode.right] == null, 0, callHeap#_780[callHeap#_780[this#254, AVLTreeNode.right], AVLTreeNode.height]) + 1);
          assume Heap[this#254, AVLTreeNode.balanceFactor] == (ite(callHeap#_780[this#254, AVLTreeNode.left] == null, 0, callHeap#_780[callHeap#_780[this#254, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_780[this#254, AVLTreeNode.right] == null, 0, callHeap#_780[callHeap#_780[this#254, AVLTreeNode.right], AVLTreeNode.height]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
          // assigment to r
          r#20 := this;
        }
      } else {
        // assigment to r
        r#20 := this;
        assume (0.0 < methodCallK#_809) && ((1000.0 * methodCallK#_809) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_809) < methodK#_554);
        // call close
        callHeap#_805 := Heap;
        callMask#_806 := Mask;
        callSecMask#_807 := SecMask;
        callCredits#_808 := Credits;
        assume wf(callHeap#_805, callMask#_806, callSecMask#_807);
        assert {:msg "  322.6: The target of the method call might be null."} r#20 != null;
        this#259 := r#20;
        // begin exhale (precondition)
        exhaleMask#_811 := Mask;
        havoc exhaleHeap#_810;
        exhaledHolds#_812 := ZeroRefSet;
        if (!(Heap[this#259, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#260: int :: 
            (0 <= k#92#260) && (k#92#260 < Seq#Length(Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys], k#92#260) < Heap[this#259, AVLTreeNode.key])
          );
        }
        if (!(Heap[this#259, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#261: int :: 
            (0 <= k#93#261) && (k#93#261 < Seq#Length(Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#259, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys], k#93#261))
          );
        }
        assert {:msg "  322.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#259, AVLTreeNode.left] == null, 0, Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#259, AVLTreeNode.right] == null, 0, Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  322.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#259, AVLTreeNode.left] == null, 0, Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#259, AVLTreeNode.right] == null, 0, Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  322.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  322.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_811[this#259, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[this#259, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_811[this#259, AVLTreeNode.key][perm$N]));
        exhaleMask#_811[this#259, AVLTreeNode.key] := exhaleMask#_811[this#259, AVLTreeNode.key][perm$R := exhaleMask#_811[this#259, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_811, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  322.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_811[this#259, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[this#259, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_811[this#259, AVLTreeNode.height][perm$N]));
        exhaleMask#_811[this#259, AVLTreeNode.height] := exhaleMask#_811[this#259, AVLTreeNode.height][perm$R := exhaleMask#_811[this#259, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_811, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  322.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_811[this#259, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[this#259, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_811[this#259, AVLTreeNode.left][perm$N]));
        exhaleMask#_811[this#259, AVLTreeNode.left] := exhaleMask#_811[this#259, AVLTreeNode.left][perm$R := exhaleMask#_811[this#259, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_811, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  322.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_811[this#259, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[this#259, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_811[this#259, AVLTreeNode.right][perm$N]));
        exhaleMask#_811[this#259, AVLTreeNode.right] := exhaleMask#_811[this#259, AVLTreeNode.right][perm$R := exhaleMask#_811[this#259, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_811, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  322.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_811[this#259, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[this#259, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_811[this#259, AVLTreeNode.keys][perm$N]));
        exhaleMask#_811[this#259, AVLTreeNode.keys] := exhaleMask#_811[this#259, AVLTreeNode.keys][perm$R := exhaleMask#_811[this#259, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_811, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  322.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  322.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_811[this#259, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[this#259, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_811[this#259, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_811[this#259, AVLTreeNode.balanceFactor] := exhaleMask#_811[this#259, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_811[this#259, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_811, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#259, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_811, Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_810[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.left] == null)) {
          assert {:msg "  322.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_811, Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_810[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#259, AVLTreeNode.right] == null)) {
          assert {:msg "  322.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  322.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_811[Heap[this#259, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_811, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_811;
        assume IsGoodExhaleState(exhaleHeap#_810, Heap, Mask, exhaledHolds#_812);
        Heap := exhaleHeap#_810;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#259 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#259, AVLTreeNode.valid] := Mask[this#259, AVLTreeNode.valid][perm$R := Mask[this#259, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#259 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#259, AVLTreeNode.height] := Mask[this#259, AVLTreeNode.height][perm$R := Mask[this#259, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#259 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#259, AVLTreeNode.keys] := Mask[this#259, AVLTreeNode.keys][perm$R := Mask[this#259, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#259 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#259, AVLTreeNode.balanceFactor] := Mask[this#259, AVLTreeNode.balanceFactor][perm$R := Mask[this#259, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#259, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_805[this#259, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_805[callHeap#_805[this#259, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_805[this#259, AVLTreeNode.key])), ite(callHeap#_805[this#259, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_805[callHeap#_805[this#259, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#259, AVLTreeNode.height] == ite(ite(callHeap#_805[this#259, AVLTreeNode.left] == null, 0, callHeap#_805[callHeap#_805[this#259, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_805[this#259, AVLTreeNode.right] == null, 0, callHeap#_805[callHeap#_805[this#259, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_805[this#259, AVLTreeNode.left] == null, 0, callHeap#_805[callHeap#_805[this#259, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_805[this#259, AVLTreeNode.right] == null, 0, callHeap#_805[callHeap#_805[this#259, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#259, AVLTreeNode.balanceFactor] == (ite(callHeap#_805[this#259, AVLTreeNode.left] == null, 0, callHeap#_805[callHeap#_805[this#259, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_805[this#259, AVLTreeNode.right] == null, 0, callHeap#_805[callHeap#_805[this#259, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    } else {
      // if
      cond#_830 := !(Heap[this, AVLTreeNode.right] == null);
      assert {:msg "  325.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  325.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (cond#_830) {
        // local var nr
        assume (0.0 < methodCallK#_835) && ((1000.0 * methodCallK#_835) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_835) < methodK#_554);
        // call remove
        callHeap#_831 := Heap;
        callMask#_832 := Mask;
        callSecMask#_833 := SecMask;
        callCredits#_834 := Credits;
        assume wf(callHeap#_831, callMask#_832, callSecMask#_833);
        assert {:msg "  327.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  327.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  327.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#264 := Heap[this, AVLTreeNode.right];
        k#265 := k#19;
        // begin exhale (precondition)
        exhaleMask#_837 := Mask;
        havoc exhaleHeap#_836;
        exhaledHolds#_838 := ZeroRefSet;
        assert {:msg "  327.6: The precondition at 254.12 might not hold. The permission at 254.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  327.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_837[this#264, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_837[this#264, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_837[this#264, AVLTreeNode.valid][perm$N]));
        exhaleMask#_837[this#264, AVLTreeNode.valid] := exhaleMask#_837[this#264, AVLTreeNode.valid][perm$R := exhaleMask#_837[this#264, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_837, this#264, AVLTreeNode.valid)) {
          assume Heap[this#264, AVLTreeNode.valid] < exhaleHeap#_836[this#264, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_837, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  327.6: The precondition at 255.12 might not hold. The permission at 255.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  327.6: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_837[this#264, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_837[this#264, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_837[this#264, AVLTreeNode.keys][perm$N]));
        exhaleMask#_837[this#264, AVLTreeNode.keys] := exhaleMask#_837[this#264, AVLTreeNode.keys][perm$R := exhaleMask#_837[this#264, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_837, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  327.6: The precondition at 256.12 might not hold. The permission at 256.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  327.6: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_837[this#264, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_837[this#264, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_837[this#264, AVLTreeNode.height][perm$N]));
        exhaleMask#_837[this#264, AVLTreeNode.height] := exhaleMask#_837[this#264, AVLTreeNode.height][perm$R := exhaleMask#_837[this#264, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_837, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  327.6: The precondition at 257.12 might not hold. The permission at 257.12 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  327.6: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_837[this#264, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_837[this#264, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_837[this#264, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_837[this#264, AVLTreeNode.balanceFactor] := exhaleMask#_837[this#264, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_837[this#264, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_837, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_837;
        assume IsGoodExhaleState(exhaleHeap#_836, Heap, Mask, exhaledHolds#_838);
        Heap := exhaleHeap#_836;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc r#266;
        // inhale (postcondition)
        if (Seq#Equal(callHeap#_831[this#264, AVLTreeNode.keys], Seq#Singleton(k#265))) {
          assume r#266 == null;
        }
        if (!Seq#Equal(callHeap#_831[this#264, AVLTreeNode.keys], Seq#Singleton(k#265))) {
          assume !(r#266 == null);
        }
        if (!(r#266 == null)) {
          assume r#266 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[r#266, AVLTreeNode.valid] := Mask[r#266, AVLTreeNode.valid][perm$R := Mask[r#266, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#266 == null)) {
          assume r#266 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#266, AVLTreeNode.keys] := Mask[r#266, AVLTreeNode.keys][perm$R := Mask[r#266, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#266 == null)) {
          assume r#266 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#266, AVLTreeNode.height] := Mask[r#266, AVLTreeNode.height][perm$R := Mask[r#266, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#266 == null)) {
          assume r#266 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#266, AVLTreeNode.balanceFactor] := Mask[r#266, AVLTreeNode.balanceFactor][perm$R := Mask[r#266, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(r#266 == null)) {
          assume !Seq#Contains(Heap[r#266, AVLTreeNode.keys], k#265);
        }
        if (!(r#266 == null)) {
          assume (forall i#84#267: int :: 
            (0 <= i#84#267) && (i#84#267 < Seq#Length(callHeap#_831[this#264, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#266, AVLTreeNode.keys], Seq#Index(callHeap#_831[this#264, AVLTreeNode.keys], i#84#267)) || (Seq#Index(callHeap#_831[this#264, AVLTreeNode.keys], i#84#267) == k#265))
          );
        }
        if (!(r#266 == null)) {
          assume (forall i#85#268: int :: 
            (0 <= i#85#268) && (i#85#268 < Seq#Length(Heap[r#266, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_831[this#264, AVLTreeNode.keys], Seq#Index(Heap[r#266, AVLTreeNode.keys], i#85#268)) && (!(Seq#Index(Heap[r#266, AVLTreeNode.keys], i#85#268) == k#265))
          );
        }
        if (!Seq#Contains(callHeap#_831[this#264, AVLTreeNode.keys], k#265)) {
          assume !(r#266 == null);
        }
        if (!Seq#Contains(callHeap#_831[this#264, AVLTreeNode.keys], k#265)) {
          assume Seq#Equal(Heap[r#266, AVLTreeNode.keys], callHeap#_831[this#264, AVLTreeNode.keys]);
        }
        if (!(r#266 == null)) {
          if (Seq#Contains(callHeap#_831[this#264, AVLTreeNode.keys], k#265)) {
            assume Seq#Length(Heap[r#266, AVLTreeNode.keys]) == (Seq#Length(callHeap#_831[this#264, AVLTreeNode.keys]) - 1);
          }
        }
        if (callHeap#_831[this#264, AVLTreeNode.height] > 1) {
          assume !(r#266 == null);
        }
        if (!(r#266 == null)) {
          assume (Heap[r#266, AVLTreeNode.height] == callHeap#_831[this#264, AVLTreeNode.height]) || ((Heap[r#266, AVLTreeNode.height] + 1) == callHeap#_831[this#264, AVLTreeNode.height]);
        }
        if (!Seq#Contains(callHeap#_831[this#264, AVLTreeNode.keys], k#265)) {
          assume Heap[r#266, AVLTreeNode.height] == callHeap#_831[this#264, AVLTreeNode.height];
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        nr#32 := r#266;
        // update field right
        assert {:msg "  328.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
        Heap[this, AVLTreeNode.right] := nr#32;
        assume wf(Heap, Mask, SecMask);
        // local var bf
        assume (0.0 < methodCallK#_850) && ((1000.0 * methodCallK#_850) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_850) < methodK#_554);
        // call getBalanceFactorI
        callHeap#_846 := Heap;
        callMask#_847 := Mask;
        callSecMask#_848 := SecMask;
        callCredits#_849 := Credits;
        assume wf(callHeap#_846, callMask#_847, callSecMask#_848);
        assert {:msg "  331.6: The target of the method call might be null."} this != null;
        this#269 := this;
        // begin exhale (precondition)
        exhaleMask#_852 := Mask;
        havoc exhaleHeap#_851;
        exhaledHolds#_853 := ZeroRefSet;
        assert {:msg "  331.6: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_850 > 0.0;
        assert {:msg "  331.6: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_852[this#269, AVLTreeNode.left][perm$R] > 0.0;
        assume methodCallK#_850 < exhaleMask#_852[this#269, AVLTreeNode.left][perm$R];
        exhaleMask#_852[this#269, AVLTreeNode.left] := exhaleMask#_852[this#269, AVLTreeNode.left][perm$R := exhaleMask#_852[this#269, AVLTreeNode.left][perm$R] - methodCallK#_850];
        assume wf(Heap, exhaleMask#_852, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#269, AVLTreeNode.left] == null)) {
          assert {:msg "  331.6: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_850 > 0.0;
          assert {:msg "  331.6: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
          assume methodCallK#_850 < exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height][perm$R];
          exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_850];
          assume wf(Heap, exhaleMask#_852, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assert {:msg "  331.6: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_850 > 0.0;
        assert {:msg "  331.6: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_852[this#269, AVLTreeNode.right][perm$R] > 0.0;
        assume methodCallK#_850 < exhaleMask#_852[this#269, AVLTreeNode.right][perm$R];
        exhaleMask#_852[this#269, AVLTreeNode.right] := exhaleMask#_852[this#269, AVLTreeNode.right][perm$R := exhaleMask#_852[this#269, AVLTreeNode.right][perm$R] - methodCallK#_850];
        assume wf(Heap, exhaleMask#_852, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#269, AVLTreeNode.right] == null)) {
          assert {:msg "  331.6: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_850 > 0.0;
          assert {:msg "  331.6: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
          assume methodCallK#_850 < exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height][perm$R];
          exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_850];
          assume wf(Heap, exhaleMask#_852, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#269, AVLTreeNode.left] == null)) {
          assert {:msg "  331.6: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  331.6: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_852[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_852, Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_851[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_852, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#269, AVLTreeNode.right] == null)) {
          assert {:msg "  331.6: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  331.6: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_852[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_852, Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_851[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_852, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_852;
        assume IsGoodExhaleState(exhaleHeap#_851, Heap, Mask, exhaledHolds#_853);
        Heap := exhaleHeap#_851;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc bf#270;
        // inhale (postcondition)
        assume this#269 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#269, AVLTreeNode.left] == null) || (dtype(Heap[this#269, AVLTreeNode.left]) == AVLTreeNode#t);
        assume methodCallK#_850 > 0.0;
        Mask[this#269, AVLTreeNode.left] := Mask[this#269, AVLTreeNode.left][perm$R := Mask[this#269, AVLTreeNode.left][perm$R] + methodCallK#_850];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#269, AVLTreeNode.left] == null)) {
          assume Heap[this#269, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#269, AVLTreeNode.left] == null)) {
          assume Heap[this#269, AVLTreeNode.left] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_850 > 0.0;
          Mask[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_850];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume this#269 != null;
        assume wf(Heap, Mask, SecMask);
        assume (Heap[this#269, AVLTreeNode.right] == null) || (dtype(Heap[this#269, AVLTreeNode.right]) == AVLTreeNode#t);
        assume methodCallK#_850 > 0.0;
        Mask[this#269, AVLTreeNode.right] := Mask[this#269, AVLTreeNode.right][perm$R := Mask[this#269, AVLTreeNode.right][perm$R] + methodCallK#_850];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#269, AVLTreeNode.right] == null)) {
          assume Heap[this#269, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#269, AVLTreeNode.right] == null)) {
          assume Heap[this#269, AVLTreeNode.right] != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume methodCallK#_850 > 0.0;
          Mask[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_850];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        assume bf#270 == (ite(Heap[this#269, AVLTreeNode.left] == null, 0, Heap[Heap[this#269, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#269, AVLTreeNode.right] == null, 0, Heap[Heap[this#269, AVLTreeNode.right], AVLTreeNode.height]));
        if (bf#270 > 0) {
          assume !(Heap[this#269, AVLTreeNode.left] == null);
        }
        if (bf#270 < 0) {
          assume !(Heap[this#269, AVLTreeNode.right] == null);
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        bf#34 := bf#270;
        // if
        cond#_863 := bf#34 == 2;
        if (cond#_863) {
          assume (0.0 < methodCallK#_868) && ((1000.0 * methodCallK#_868) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_868) < methodK#_554);
          // call rebalanceLeft
          callHeap#_864 := Heap;
          callMask#_865 := Mask;
          callSecMask#_866 := SecMask;
          callCredits#_867 := Credits;
          assume wf(callHeap#_864, callMask#_865, callSecMask#_866);
          assert {:msg "  333.7: The target of the method call might be null."} this != null;
          this#271 := this;
          // begin exhale (precondition)
          exhaleMask#_870 := Mask;
          havoc exhaleHeap#_869;
          exhaledHolds#_871 := ZeroRefSet;
          assert {:msg "  333.7: The precondition at 608.12 might not hold. The expression at 608.12 might not evaluate to true."} !(Heap[this#271, AVLTreeNode.left] == null);
          assert {:msg "  333.7: The precondition at 613.12 might not hold. The expression at 613.12 might not evaluate to true."} (forall k#94#273: int :: 
            (0 <= k#94#273) && (k#94#273 < Seq#Length(Heap[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys], k#94#273) < Heap[this#271, AVLTreeNode.key])
          );
          if (!(Heap[this#271, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 619.12 might not hold. The expression at 619.28 might not evaluate to true."} (forall k#95#274: int :: 
              (0 <= k#95#274) && (k#95#274 < Seq#Length(Heap[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#271, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys], k#95#274))
            );
          }
          assert {:msg "  333.7: The precondition at 621.12 might not hold. The expression at 621.12 might not evaluate to true."} (Heap[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#271, AVLTreeNode.right] == null, 0, Heap[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height])) == 2;
          assert {:msg "  333.7: The precondition at 600.12 might not hold. The permission at 600.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_870[this#271, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[this#271, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_870[this#271, AVLTreeNode.key][perm$N]));
          exhaleMask#_870[this#271, AVLTreeNode.key] := exhaleMask#_870[this#271, AVLTreeNode.key][perm$R := exhaleMask#_870[this#271, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 601.12 might not hold. The permission at 601.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_870[this#271, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[this#271, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_870[this#271, AVLTreeNode.height][perm$N]));
          exhaleMask#_870[this#271, AVLTreeNode.height] := exhaleMask#_870[this#271, AVLTreeNode.height][perm$R := exhaleMask#_870[this#271, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 602.12 might not hold. The permission at 602.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 602.12 might not hold. Insufficient fraction at 602.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_870[this#271, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[this#271, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_870[this#271, AVLTreeNode.left][perm$N]));
          exhaleMask#_870[this#271, AVLTreeNode.left] := exhaleMask#_870[this#271, AVLTreeNode.left][perm$R := exhaleMask#_870[this#271, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 603.12 might not hold. The permission at 603.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_870[this#271, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[this#271, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_870[this#271, AVLTreeNode.right][perm$N]));
          exhaleMask#_870[this#271, AVLTreeNode.right] := exhaleMask#_870[this#271, AVLTreeNode.right][perm$R := exhaleMask#_870[this#271, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 605.12 might not hold. The permission at 605.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 605.12 might not hold. Insufficient fraction at 605.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_870[this#271, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[this#271, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_870[this#271, AVLTreeNode.keys][perm$N]));
          exhaleMask#_870[this#271, AVLTreeNode.keys] := exhaleMask#_870[this#271, AVLTreeNode.keys][perm$R := exhaleMask#_870[this#271, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 606.12 might not hold. The permission at 606.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 606.12 might not hold. Insufficient fraction at 606.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_870[this#271, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[this#271, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_870[this#271, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_870[this#271, AVLTreeNode.balanceFactor] := exhaleMask#_870[this#271, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_870[this#271, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 609.12 might not hold. The permission at 609.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_870, Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_869[Heap[this#271, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 610.12 might not hold. The permission at 610.12 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 611.12 might not hold. The permission at 611.12 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 611.12 might not hold. Insufficient fraction at 611.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  333.7: The precondition at 612.12 might not hold. The permission at 612.12 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  333.7: The precondition at 612.12 might not hold. Insufficient fraction at 612.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_870, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#271, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 615.12 might not hold. The permission at 615.28 might not be positive."} (real(100) * 0.01) > 0.0;
            assert {:msg "  333.7: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
            if (!CanRead(exhaleMask#_870, Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid)) {
              assume Heap[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_869[Heap[this#271, AVLTreeNode.right], AVLTreeNode.valid];
            }
            assume wf(Heap, exhaleMask#_870, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#271, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 616.12 might not hold. The permission at 616.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  333.7: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_870, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#271, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 617.12 might not hold. The permission at 617.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  333.7: The precondition at 617.12 might not hold. Insufficient fraction at 617.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_870, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#271, AVLTreeNode.right] == null)) {
            assert {:msg "  333.7: The precondition at 618.12 might not hold. The permission at 618.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  333.7: The precondition at 618.12 might not hold. Insufficient fraction at 618.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_870[Heap[this#271, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_870, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          Mask := exhaleMask#_870;
          assume IsGoodExhaleState(exhaleHeap#_869, Heap, Mask, exhaledHolds#_871);
          Heap := exhaleHeap#_869;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          havoc r#272;
          // inhale (postcondition)
          assume !(r#272 == null);
          assume r#272 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[r#272, AVLTreeNode.valid] := Mask[r#272, AVLTreeNode.valid][perm$R := Mask[r#272, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#272 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#272, AVLTreeNode.height] := Mask[r#272, AVLTreeNode.height][perm$R := Mask[r#272, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#272 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#272, AVLTreeNode.keys] := Mask[r#272, AVLTreeNode.keys][perm$R := Mask[r#272, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume r#272 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[r#272, AVLTreeNode.balanceFactor] := Mask[r#272, AVLTreeNode.balanceFactor][perm$R := Mask[r#272, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume (Heap[r#272, AVLTreeNode.height] == callHeap#_864[callHeap#_864[this#271, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#272, AVLTreeNode.height] == (callHeap#_864[callHeap#_864[this#271, AVLTreeNode.left], AVLTreeNode.height] + 1));
          assume Seq#Equal(Heap[r#272, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_864[callHeap#_864[this#271, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_864[this#271, AVLTreeNode.key])), ite(callHeap#_864[this#271, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_864[callHeap#_864[this#271, AVLTreeNode.right], AVLTreeNode.keys])));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
          r#20 := r#272;
        } else {
          // assigment to r
          r#20 := this;
          assume (0.0 < methodCallK#_893) && ((1000.0 * methodCallK#_893) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_893) < methodK#_554);
          // call close
          callHeap#_889 := Heap;
          callMask#_890 := Mask;
          callSecMask#_891 := SecMask;
          callCredits#_892 := Credits;
          assume wf(callHeap#_889, callMask#_890, callSecMask#_891);
          assert {:msg "  336.7: The target of the method call might be null."} r#20 != null;
          this#277 := r#20;
          // begin exhale (precondition)
          exhaleMask#_895 := Mask;
          havoc exhaleHeap#_894;
          exhaledHolds#_896 := ZeroRefSet;
          if (!(Heap[this#277, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#278: int :: 
              (0 <= k#92#278) && (k#92#278 < Seq#Length(Heap[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys], k#92#278) < Heap[this#277, AVLTreeNode.key])
            );
          }
          if (!(Heap[this#277, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#279: int :: 
              (0 <= k#93#279) && (k#93#279 < Seq#Length(Heap[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#277, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys], k#93#279))
            );
          }
          assert {:msg "  336.7: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#277, AVLTreeNode.left] == null, 0, Heap[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#277, AVLTreeNode.right] == null, 0, Heap[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
          assert {:msg "  336.7: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#277, AVLTreeNode.left] == null, 0, Heap[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#277, AVLTreeNode.right] == null, 0, Heap[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
          assert {:msg "  336.7: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  336.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_895[this#277, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[this#277, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_895[this#277, AVLTreeNode.key][perm$N]));
          exhaleMask#_895[this#277, AVLTreeNode.key] := exhaleMask#_895[this#277, AVLTreeNode.key][perm$R := exhaleMask#_895[this#277, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_895, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  336.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_895[this#277, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[this#277, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_895[this#277, AVLTreeNode.height][perm$N]));
          exhaleMask#_895[this#277, AVLTreeNode.height] := exhaleMask#_895[this#277, AVLTreeNode.height][perm$R := exhaleMask#_895[this#277, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_895, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  336.7: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_895[this#277, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[this#277, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_895[this#277, AVLTreeNode.left][perm$N]));
          exhaleMask#_895[this#277, AVLTreeNode.left] := exhaleMask#_895[this#277, AVLTreeNode.left][perm$R := exhaleMask#_895[this#277, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_895, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  336.7: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_895[this#277, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[this#277, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_895[this#277, AVLTreeNode.right][perm$N]));
          exhaleMask#_895[this#277, AVLTreeNode.right] := exhaleMask#_895[this#277, AVLTreeNode.right][perm$R := exhaleMask#_895[this#277, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_895, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  336.7: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_895[this#277, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[this#277, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_895[this#277, AVLTreeNode.keys][perm$N]));
          exhaleMask#_895[this#277, AVLTreeNode.keys] := exhaleMask#_895[this#277, AVLTreeNode.keys][perm$R := exhaleMask#_895[this#277, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_895, SecMask);
          assume wf(Heap, Mask, SecMask);
          assert {:msg "  336.7: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  336.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_895[this#277, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[this#277, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_895[this#277, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_895[this#277, AVLTreeNode.balanceFactor] := exhaleMask#_895[this#277, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_895[this#277, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
          assume wf(Heap, exhaleMask#_895, SecMask);
          assume wf(Heap, Mask, SecMask);
          if (!(Heap[this#277, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
            if (!CanRead(exhaleMask#_895, Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid)) {
              assume Heap[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_894[Heap[this#277, AVLTreeNode.left], AVLTreeNode.valid];
            }
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.left] == null)) {
            assert {:msg "  336.7: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
            if (!CanRead(exhaleMask#_895, Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid)) {
              assume Heap[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_894[Heap[this#277, AVLTreeNode.right], AVLTreeNode.valid];
            }
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          if (!(Heap[this#277, AVLTreeNode.right] == null)) {
            assert {:msg "  336.7: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
            assert {:msg "  336.7: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_895[Heap[this#277, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
            assume wf(Heap, exhaleMask#_895, SecMask);
            assume wf(Heap, Mask, SecMask);
          }
          Mask := exhaleMask#_895;
          assume IsGoodExhaleState(exhaleHeap#_894, Heap, Mask, exhaledHolds#_896);
          Heap := exhaleHeap#_894;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end exhale
          // inhale (postcondition)
          assume this#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume (real(100) * 0.01) > 0.0;
          Mask[this#277, AVLTreeNode.valid] := Mask[this#277, AVLTreeNode.valid][perm$R := Mask[this#277, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[this#277, AVLTreeNode.height] := Mask[this#277, AVLTreeNode.height][perm$R := Mask[this#277, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[this#277, AVLTreeNode.keys] := Mask[this#277, AVLTreeNode.keys][perm$R := Mask[this#277, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume this#277 != null;
          assume wf(Heap, Mask, SecMask);
          assume true;
          assume (real(50) * 0.01) > 0.0;
          Mask[this#277, AVLTreeNode.balanceFactor] := Mask[this#277, AVLTreeNode.balanceFactor][perm$R := Mask[this#277, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          assume wf(Heap, Mask, SecMask);
          assume Seq#Equal(Heap[this#277, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_889[this#277, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_889[callHeap#_889[this#277, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_889[this#277, AVLTreeNode.key])), ite(callHeap#_889[this#277, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_889[callHeap#_889[this#277, AVLTreeNode.right], AVLTreeNode.keys])));
          assume Heap[this#277, AVLTreeNode.height] == ite(ite(callHeap#_889[this#277, AVLTreeNode.left] == null, 0, callHeap#_889[callHeap#_889[this#277, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_889[this#277, AVLTreeNode.right] == null, 0, callHeap#_889[callHeap#_889[this#277, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_889[this#277, AVLTreeNode.left] == null, 0, callHeap#_889[callHeap#_889[this#277, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_889[this#277, AVLTreeNode.right] == null, 0, callHeap#_889[callHeap#_889[this#277, AVLTreeNode.right], AVLTreeNode.height]) + 1);
          assume Heap[this#277, AVLTreeNode.balanceFactor] == (ite(callHeap#_889[this#277, AVLTreeNode.left] == null, 0, callHeap#_889[callHeap#_889[this#277, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_889[this#277, AVLTreeNode.right] == null, 0, callHeap#_889[callHeap#_889[this#277, AVLTreeNode.right], AVLTreeNode.height]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask, SecMask);
          // end inhale
        }
      } else {
        // assigment to r
        r#20 := this;
        assume (0.0 < methodCallK#_918) && ((1000.0 * methodCallK#_918) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_918) < methodK#_554);
        // call close
        callHeap#_914 := Heap;
        callMask#_915 := Mask;
        callSecMask#_916 := SecMask;
        callCredits#_917 := Credits;
        assume wf(callHeap#_914, callMask#_915, callSecMask#_916);
        assert {:msg "  340.6: The target of the method call might be null."} r#20 != null;
        this#282 := r#20;
        // begin exhale (precondition)
        exhaleMask#_920 := Mask;
        havoc exhaleHeap#_919;
        exhaledHolds#_921 := ZeroRefSet;
        if (!(Heap[this#282, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#283: int :: 
            (0 <= k#92#283) && (k#92#283 < Seq#Length(Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys], k#92#283) < Heap[this#282, AVLTreeNode.key])
          );
        }
        if (!(Heap[this#282, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#284: int :: 
            (0 <= k#93#284) && (k#93#284 < Seq#Length(Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#282, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys], k#93#284))
          );
        }
        assert {:msg "  340.6: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#282, AVLTreeNode.left] == null, 0, Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#282, AVLTreeNode.right] == null, 0, Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  340.6: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#282, AVLTreeNode.left] == null, 0, Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#282, AVLTreeNode.right] == null, 0, Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        assert {:msg "  340.6: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  340.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_920[this#282, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[this#282, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_920[this#282, AVLTreeNode.key][perm$N]));
        exhaleMask#_920[this#282, AVLTreeNode.key] := exhaleMask#_920[this#282, AVLTreeNode.key][perm$R := exhaleMask#_920[this#282, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_920, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  340.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_920[this#282, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[this#282, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_920[this#282, AVLTreeNode.height][perm$N]));
        exhaleMask#_920[this#282, AVLTreeNode.height] := exhaleMask#_920[this#282, AVLTreeNode.height][perm$R := exhaleMask#_920[this#282, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_920, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  340.6: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_920[this#282, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[this#282, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_920[this#282, AVLTreeNode.left][perm$N]));
        exhaleMask#_920[this#282, AVLTreeNode.left] := exhaleMask#_920[this#282, AVLTreeNode.left][perm$R := exhaleMask#_920[this#282, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_920, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  340.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_920[this#282, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[this#282, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_920[this#282, AVLTreeNode.right][perm$N]));
        exhaleMask#_920[this#282, AVLTreeNode.right] := exhaleMask#_920[this#282, AVLTreeNode.right][perm$R := exhaleMask#_920[this#282, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_920, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  340.6: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_920[this#282, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[this#282, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_920[this#282, AVLTreeNode.keys][perm$N]));
        exhaleMask#_920[this#282, AVLTreeNode.keys] := exhaleMask#_920[this#282, AVLTreeNode.keys][perm$R := exhaleMask#_920[this#282, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_920, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  340.6: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  340.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_920[this#282, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[this#282, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_920[this#282, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_920[this#282, AVLTreeNode.balanceFactor] := exhaleMask#_920[this#282, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_920[this#282, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
        assume wf(Heap, exhaleMask#_920, SecMask);
        assume wf(Heap, Mask, SecMask);
        if (!(Heap[this#282, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_920, Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid)) {
            assume Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_919[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.left] == null)) {
          assert {:msg "  340.6: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
          if (!CanRead(exhaleMask#_920, Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid)) {
            assume Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_919[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid];
          }
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        if (!(Heap[this#282, AVLTreeNode.right] == null)) {
          assert {:msg "  340.6: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
          assert {:msg "  340.6: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_920[Heap[this#282, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
          assume wf(Heap, exhaleMask#_920, SecMask);
          assume wf(Heap, Mask, SecMask);
        }
        Mask := exhaleMask#_920;
        assume IsGoodExhaleState(exhaleHeap#_919, Heap, Mask, exhaledHolds#_921);
        Heap := exhaleHeap#_919;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        // inhale (postcondition)
        assume this#282 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#282, AVLTreeNode.valid] := Mask[this#282, AVLTreeNode.valid][perm$R := Mask[this#282, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#282 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#282, AVLTreeNode.height] := Mask[this#282, AVLTreeNode.height][perm$R := Mask[this#282, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#282 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#282, AVLTreeNode.keys] := Mask[this#282, AVLTreeNode.keys][perm$R := Mask[this#282, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#282 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume (real(50) * 0.01) > 0.0;
        Mask[this#282, AVLTreeNode.balanceFactor] := Mask[this#282, AVLTreeNode.balanceFactor][perm$R := Mask[this#282, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume Seq#Equal(Heap[this#282, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_914[this#282, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_914[callHeap#_914[this#282, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_914[this#282, AVLTreeNode.key])), ite(callHeap#_914[this#282, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_914[callHeap#_914[this#282, AVLTreeNode.right], AVLTreeNode.keys])));
        assume Heap[this#282, AVLTreeNode.height] == ite(ite(callHeap#_914[this#282, AVLTreeNode.left] == null, 0, callHeap#_914[callHeap#_914[this#282, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_914[this#282, AVLTreeNode.right] == null, 0, callHeap#_914[callHeap#_914[this#282, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_914[this#282, AVLTreeNode.left] == null, 0, callHeap#_914[callHeap#_914[this#282, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_914[this#282, AVLTreeNode.right] == null, 0, callHeap#_914[callHeap#_914[this#282, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#282, AVLTreeNode.balanceFactor] == (ite(callHeap#_914[this#282, AVLTreeNode.left] == null, 0, callHeap#_914[callHeap#_914[this#282, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_914[this#282, AVLTreeNode.right] == null, 0, callHeap#_914[callHeap#_914[this#282, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_940 := Mask;
  havoc exhaleHeap#_939;
  exhaledHolds#_941 := ZeroRefSet;
  if (Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assert {:msg "  253.2: The postcondition at 259.11 might not hold. The expression at 259.30 might not evaluate to true."} r#20 == null;
  }
  if (!Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assert {:msg "  253.2: The postcondition at 260.11 might not hold. The expression at 260.30 might not evaluate to true."} !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 267.11 might not hold. The expression at 267.25 might not evaluate to true."} !Seq#Contains(Heap[r#20, AVLTreeNode.keys], k#19);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 268.11 might not hold. The expression at 268.25 might not evaluate to true."} (forall i#84#287: int :: 
      (0 <= i#84#287) && (i#84#287 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#287)) || (Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#84#287) == k#19))
    );
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 269.11 might not hold. The expression at 269.25 might not evaluate to true."} (forall i#85#288: int :: 
      (0 <= i#85#288) && (i#85#288 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#288)) && (!(Seq#Index(Heap[r#20, AVLTreeNode.keys], i#85#288) == k#19))
    );
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 270.11 might not hold. The expression at 270.34 might not evaluate to true."} !(r#20 == null);
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 271.11 might not hold. The expression at 271.34 might not evaluate to true."} Seq#Equal(Heap[r#20, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  }
  if (!(r#20 == null)) {
    if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
      assert {:msg "  253.2: The postcondition at 272.11 might not hold. The expression at 272.45 might not evaluate to true."} Seq#Length(Heap[r#20, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) - 1);
    }
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  253.2: The postcondition at 274.11 might not hold. The expression at 274.29 might not evaluate to true."} !(r#20 == null);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 275.11 might not hold. The expression at 275.25 might not evaluate to true."} (Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#20, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 276.11 might not hold. The expression at 276.33 might not evaluate to true."} Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height];
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 262.11 might not hold. The permission at 262.25 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  253.2: The postcondition at 262.11 might not hold. Insufficient fraction at 262.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_940[r#20, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_940[r#20, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_940[r#20, AVLTreeNode.valid][perm$N]));
    exhaleMask#_940[r#20, AVLTreeNode.valid] := exhaleMask#_940[r#20, AVLTreeNode.valid][perm$R := exhaleMask#_940[r#20, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_940, r#20, AVLTreeNode.valid)) {
      assume Heap[r#20, AVLTreeNode.valid] < exhaleHeap#_939[r#20, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_940, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 263.11 might not hold. The permission at 263.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  253.2: The postcondition at 263.11 might not hold. Insufficient fraction at 263.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_940[r#20, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_940[r#20, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_940[r#20, AVLTreeNode.keys][perm$N]));
    exhaleMask#_940[r#20, AVLTreeNode.keys] := exhaleMask#_940[r#20, AVLTreeNode.keys][perm$R := exhaleMask#_940[r#20, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_940, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 264.11 might not hold. The permission at 264.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  253.2: The postcondition at 264.11 might not hold. Insufficient fraction at 264.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_940[r#20, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_940[r#20, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_940[r#20, AVLTreeNode.height][perm$N]));
    exhaleMask#_940[r#20, AVLTreeNode.height] := exhaleMask#_940[r#20, AVLTreeNode.height][perm$R := exhaleMask#_940[r#20, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_940, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 265.11 might not hold. The permission at 265.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  253.2: The postcondition at 265.11 might not hold. Insufficient fraction at 265.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_940[r#20, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_940[r#20, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_940[r#20, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_940[r#20, AVLTreeNode.balanceFactor] := exhaleMask#_940[r#20, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_940[r#20, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_940, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#20 == null)) {
  }
  Mask := exhaleMask#_940;
  assume IsGoodExhaleState(exhaleHeap#_939, Heap, Mask, exhaledHolds#_941);
  Heap := exhaleHeap#_939;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  253.2: Method might lock/unlock more than allowed."} (forall lk#_946: ref :: 
    { Heap[lk#_946, held] }
    { Heap[lk#_946, rdheld] }
    (((0 < Heap[lk#_946, held]) == (0 < old(Heap)[lk#_946, held])) && (Heap[lk#_946, rdheld] == old(Heap)[lk#_946, rdheld])) || false
  );
  assert {:msg "  253.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.pruneMax
// -------------------------------------------

// definedness check for method AVLTreeNode.pruneMax
procedure AVLTreeNode.pruneMax$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_947: real;
  var k#86#292: int where true;
  assume (0.0 < methodK#_947) && ((1000.0 * methodK#_947) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  349.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_950: Field (PMaskType) :: 
    (forall ref#_949: ref :: 
      Heap[ref#_949, pmask#_950] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  if (!(r#35 == null)) {
    assert {:msg "  354.25: Receiver might be null."} r#35 != null;
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#35, AVLTreeNode.valid] := Mask[r#35, AVLTreeNode.valid][perm$R := Mask[r#35, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#35, AVLTreeNode.keys] := Mask[r#35, AVLTreeNode.keys][perm$R := Mask[r#35, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#35, AVLTreeNode.height] := Mask[r#35, AVLTreeNode.height][perm$R := Mask[r#35, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assume r#35 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#35, AVLTreeNode.balanceFactor] := Mask[r#35, AVLTreeNode.balanceFactor][perm$R := Mask[r#35, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  358.26: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  358.26: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.height);
    assert {:msg "  358.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  358.42: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assert {:msg "  358.53: Receiver might be null."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#35 != null);
    assert {:msg "  358.53: Location might not be readable."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#35, AVLTreeNode.height);
    assert {:msg "  358.71: Receiver might be null."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  358.71: Location might not be readable."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume (Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#35, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  if (!(r#35 == null)) {
    assert {:msg "  359.25: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  359.25: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.keys);
    assert {:msg "  359.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  359.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume (Seq#Length(Heap[r#35, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  assert {:msg "  360.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  360.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#35 == null);
  }
  assert {:msg "  361.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  361.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assume r#35 == null;
  }
  assert {:msg "  362.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  362.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#35 == null) {
  } else {
    assert {:msg "  362.35: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  362.35: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.height);
  }
  assert {:msg "  362.52: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> (this != null);
  assert {:msg "  362.52: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#35 == null) {
  } else {
    assert {:msg "  362.72: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> (r#35 != null);
    assert {:msg "  362.72: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> CanRead(Mask, r#35, AVLTreeNode.height);
  }
  assume (old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]) + 1));
  assume !(m#36 == null);
  assert {:msg "  365.11: Receiver might be null."} m#36 != null;
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[m#36, AVLTreeNode.valid] := Mask[m#36, AVLTreeNode.valid][perm$R := Mask[m#36, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[m#36, AVLTreeNode.keys] := Mask[m#36, AVLTreeNode.keys][perm$R := Mask[m#36, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[m#36, AVLTreeNode.height] := Mask[m#36, AVLTreeNode.height][perm$R := Mask[m#36, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#36 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[m#36, AVLTreeNode.balanceFactor] := Mask[m#36, AVLTreeNode.balanceFactor][perm$R := Mask[m#36, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  369.11: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  369.11: Location might not be readable."} true ==> CanRead(Mask, m#36, AVLTreeNode.height);
  assume Heap[m#36, AVLTreeNode.height] == 1;
  assert {:msg "  370.12: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  370.12: Location might not be readable."} true ==> CanRead(Mask, m#36, AVLTreeNode.keys);
  assume Seq#Length(Heap[m#36, AVLTreeNode.keys]) == 1;
  if (r#35 == null) {
  } else {
    assert {:msg "  372.29: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  372.29: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.keys);
  }
  assert {:msg "  372.40: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  372.40: Location might not be readable."} true ==> CanRead(Mask, m#36, AVLTreeNode.keys);
  assert {:msg "  372.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  372.54: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assume Seq#Equal(Seq#Append(ite(r#35 == null, Seq#Empty(), Heap[r#35, AVLTreeNode.keys]), Heap[m#36, AVLTreeNode.keys]), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#35 == null)) {
    assert {:msg "  373.11: Receiver might be null."} true && (0 <= k#86#292) ==> (r#35 != null);
    assert {:msg "  373.11: Location might not be readable."} true && (0 <= k#86#292) ==> CanRead(Mask, r#35, AVLTreeNode.keys);
    assert {:msg "  373.11: Receiver might be null."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
    assert {:msg "  373.11: Location might not be readable."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask, r#35, AVLTreeNode.keys);
    assert {:msg "  373.45: Sequence index might be negative."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= k#86#292);
    assert {:msg "  373.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys]));
    assert {:msg "  373.49: Receiver might be null."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
    assert {:msg "  373.49: Location might not be readable."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask, m#36, AVLTreeNode.keys);
    assert {:msg "  373.49: Sequence index might be negative."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
    assert {:msg "  373.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#86#292) && (k#86#292 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap[m#36, AVLTreeNode.keys]));
    assume (forall k#86#291: int :: 
      (0 <= k#86#291) && (k#86#291 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#35, AVLTreeNode.keys], k#86#291) < Seq#Index(Heap[m#36, AVLTreeNode.keys], 0))
    );
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.pruneMax
procedure AVLTreeNode.pruneMax(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_947: real;
  var predRec#_956: ref;
  var predVer#_957: int;
  var unfoldK#_955: real;
  var oldVers#_962: int;
  var newVers#_963: int;
  var cond#_965: bool;
  var methodCallK#_970: real;
  var this#295: ref where (this#295 == null) || (dtype(this#295) == AVLTreeNode#t);
  var callHeap#_966: HeapType;
  var callMask#_967: MaskType;
  var callSecMask#_968: MaskType;
  var callCredits#_969: CreditsType;
  var exhaleMask#_972: MaskType;
  var exhaleHeap#_971: HeapType;
  var exhaledHolds#_973: RefSet;
  var isHeld#_988: int;
  var isRdHeld#_989: bool;
  var assertHeap#_991: HeapType;
  var assertMask#_992: MaskType;
  var assertSecMask#_993: MaskType;
  var assertCredits#_994: CreditsType;
  var exhaleMask#_996: MaskType;
  var exhaleHeap#_995: HeapType;
  var exhaledHolds#_997: RefSet;
  var k#87#301: int where true;
  var nr#38: ref where (nr#38 == null) || (dtype(nr#38) == AVLTreeNode#t);
  var methodCallK#_1002: real;
  var this#303: ref where (this#303 == null) || (dtype(this#303) == AVLTreeNode#t);
  var r#304: ref where (r#304 == null) || (dtype(r#304) == AVLTreeNode#t);
  var m#305: ref where (m#305 == null) || (dtype(m#305) == AVLTreeNode#t);
  var callHeap#_998: HeapType;
  var callMask#_999: MaskType;
  var callSecMask#_1000: MaskType;
  var callCredits#_1001: CreditsType;
  var exhaleMask#_1004: MaskType;
  var exhaleHeap#_1003: HeapType;
  var exhaledHolds#_1005: RefSet;
  var isHeld#_1010: int;
  var isRdHeld#_1011: bool;
  var bf#40: int where true;
  var methodCallK#_1017: real;
  var this#307: ref where (this#307 == null) || (dtype(this#307) == AVLTreeNode#t);
  var bf#308: int where true;
  var callHeap#_1013: HeapType;
  var callMask#_1014: MaskType;
  var callSecMask#_1015: MaskType;
  var callCredits#_1016: CreditsType;
  var exhaleMask#_1019: MaskType;
  var exhaleHeap#_1018: HeapType;
  var exhaledHolds#_1020: RefSet;
  var isHeld#_1027: int;
  var isRdHeld#_1028: bool;
  var cond#_1030: bool;
  var methodCallK#_1035: real;
  var this#309: ref where (this#309 == null) || (dtype(this#309) == AVLTreeNode#t);
  var r#310: ref where (r#310 == null) || (dtype(r#310) == AVLTreeNode#t);
  var callHeap#_1031: HeapType;
  var callMask#_1032: MaskType;
  var callSecMask#_1033: MaskType;
  var callCredits#_1034: CreditsType;
  var exhaleMask#_1037: MaskType;
  var exhaleHeap#_1036: HeapType;
  var exhaledHolds#_1038: RefSet;
  var isHeld#_1053: int;
  var isRdHeld#_1054: bool;
  var methodCallK#_1060: real;
  var this#315: ref where (this#315 == null) || (dtype(this#315) == AVLTreeNode#t);
  var callHeap#_1056: HeapType;
  var callMask#_1057: MaskType;
  var callSecMask#_1058: MaskType;
  var callCredits#_1059: CreditsType;
  var exhaleMask#_1062: MaskType;
  var exhaleHeap#_1061: HeapType;
  var exhaledHolds#_1063: RefSet;
  var isHeld#_1078: int;
  var isRdHeld#_1079: bool;
  var assertHeap#_1081: HeapType;
  var assertMask#_1082: MaskType;
  var assertSecMask#_1083: MaskType;
  var assertCredits#_1084: CreditsType;
  var exhaleMask#_1086: MaskType;
  var exhaleHeap#_1085: HeapType;
  var exhaledHolds#_1087: RefSet;
  var k#88#321: int where true;
  var exhaleMask#_1089: MaskType;
  var exhaleHeap#_1088: HeapType;
  var exhaledHolds#_1090: RefSet;
  assume (0.0 < methodK#_947) && ((1000.0 * methodK#_947) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_954: Field (PMaskType) :: 
    (forall ref#_953: ref :: 
      Heap[ref#_953, pmask#_954] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  predRec#_956 := this;
  predVer#_957 := Heap[this, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_955) && (unfoldK#_955 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_955) < methodK#_947);
  assert {:msg "  375.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  375.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  375.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTreeNode.valid)) {
    oldVers#_962 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_963;
    Heap[this, AVLTreeNode.valid] := newVers#_963;
    assume oldVers#_962 < Heap[this, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_956, AVLTreeNode.valid, predVer#_957, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#293: int :: 
      (0 <= lk#79#293) && (lk#79#293 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#293) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_956, AVLTreeNode.valid, predVer#_957, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#294: int :: 
      (0 <= rk#80#294) && (rk#80#294 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#294))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_965 := Heap[this, AVLTreeNode.right] == null;
  assert {:msg "  377.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  377.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (cond#_965) {
    // assigment to r
    assert {:msg "  378.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  378.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    r#35 := Heap[this, AVLTreeNode.left];
    // update field left
    assert {:msg "  379.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := null;
    assume wf(Heap, Mask, SecMask);
    assume (0.0 < methodCallK#_970) && ((1000.0 * methodCallK#_970) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_970) < methodK#_947);
    // call close
    callHeap#_966 := Heap;
    callMask#_967 := Mask;
    callSecMask#_968 := SecMask;
    callCredits#_969 := Credits;
    assume wf(callHeap#_966, callMask#_967, callSecMask#_968);
    assert {:msg "  380.4: The target of the method call might be null."} this != null;
    this#295 := this;
    // begin exhale (precondition)
    exhaleMask#_972 := Mask;
    havoc exhaleHeap#_971;
    exhaledHolds#_973 := ZeroRefSet;
    if (!(Heap[this#295, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#296: int :: 
        (0 <= k#92#296) && (k#92#296 < Seq#Length(Heap[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys], k#92#296) < Heap[this#295, AVLTreeNode.key])
      );
    }
    if (!(Heap[this#295, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#297: int :: 
        (0 <= k#93#297) && (k#93#297 < Seq#Length(Heap[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#295, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys], k#93#297))
      );
    }
    assert {:msg "  380.4: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#295, AVLTreeNode.left] == null, 0, Heap[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#295, AVLTreeNode.right] == null, 0, Heap[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  380.4: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#295, AVLTreeNode.left] == null, 0, Heap[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#295, AVLTreeNode.right] == null, 0, Heap[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    assert {:msg "  380.4: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  380.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_972[this#295, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[this#295, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_972[this#295, AVLTreeNode.key][perm$N]));
    exhaleMask#_972[this#295, AVLTreeNode.key] := exhaleMask#_972[this#295, AVLTreeNode.key][perm$R := exhaleMask#_972[this#295, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_972, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  380.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_972[this#295, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[this#295, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_972[this#295, AVLTreeNode.height][perm$N]));
    exhaleMask#_972[this#295, AVLTreeNode.height] := exhaleMask#_972[this#295, AVLTreeNode.height][perm$R := exhaleMask#_972[this#295, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_972, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  380.4: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_972[this#295, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[this#295, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_972[this#295, AVLTreeNode.left][perm$N]));
    exhaleMask#_972[this#295, AVLTreeNode.left] := exhaleMask#_972[this#295, AVLTreeNode.left][perm$R := exhaleMask#_972[this#295, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_972, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  380.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_972[this#295, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[this#295, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_972[this#295, AVLTreeNode.right][perm$N]));
    exhaleMask#_972[this#295, AVLTreeNode.right] := exhaleMask#_972[this#295, AVLTreeNode.right][perm$R := exhaleMask#_972[this#295, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_972, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  380.4: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_972[this#295, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[this#295, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_972[this#295, AVLTreeNode.keys][perm$N]));
    exhaleMask#_972[this#295, AVLTreeNode.keys] := exhaleMask#_972[this#295, AVLTreeNode.keys][perm$R := exhaleMask#_972[this#295, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_972, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  380.4: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  380.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_972[this#295, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[this#295, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_972[this#295, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_972[this#295, AVLTreeNode.balanceFactor] := exhaleMask#_972[this#295, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_972[this#295, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_972, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#295, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_972, Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_971[Heap[this#295, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.left] == null)) {
      assert {:msg "  380.4: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_972, Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_971[Heap[this#295, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#295, AVLTreeNode.right] == null)) {
      assert {:msg "  380.4: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  380.4: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_972[Heap[this#295, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_972, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_972;
    assume IsGoodExhaleState(exhaleHeap#_971, Heap, Mask, exhaledHolds#_973);
    Heap := exhaleHeap#_971;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#295 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[this#295, AVLTreeNode.valid] := Mask[this#295, AVLTreeNode.valid][perm$R := Mask[this#295, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#295 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#295, AVLTreeNode.height] := Mask[this#295, AVLTreeNode.height][perm$R := Mask[this#295, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#295 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#295, AVLTreeNode.keys] := Mask[this#295, AVLTreeNode.keys][perm$R := Mask[this#295, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#295 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#295, AVLTreeNode.balanceFactor] := Mask[this#295, AVLTreeNode.balanceFactor][perm$R := Mask[this#295, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Equal(Heap[this#295, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_966[this#295, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_966[callHeap#_966[this#295, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_966[this#295, AVLTreeNode.key])), ite(callHeap#_966[this#295, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_966[callHeap#_966[this#295, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Heap[this#295, AVLTreeNode.height] == ite(ite(callHeap#_966[this#295, AVLTreeNode.left] == null, 0, callHeap#_966[callHeap#_966[this#295, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_966[this#295, AVLTreeNode.right] == null, 0, callHeap#_966[callHeap#_966[this#295, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_966[this#295, AVLTreeNode.left] == null, 0, callHeap#_966[callHeap#_966[this#295, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_966[this#295, AVLTreeNode.right] == null, 0, callHeap#_966[callHeap#_966[this#295, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#295, AVLTreeNode.balanceFactor] == (ite(callHeap#_966[this#295, AVLTreeNode.left] == null, 0, callHeap#_966[callHeap#_966[this#295, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_966[this#295, AVLTreeNode.right] == null, 0, callHeap#_966[callHeap#_966[this#295, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    // assigment to m
    m#36 := this;
    // assert
    assertHeap#_991 := Heap;
    assertMask#_992 := Mask;
    assertSecMask#_993 := SecMask;
    assertCredits#_994 := Credits;
    assume wf(assertHeap#_991, assertMask#_992, assertSecMask#_993);
    // begin exhale (assert)
    exhaleMask#_996 := assertMask#_992;
    havoc exhaleHeap#_995;
    exhaledHolds#_997 := ZeroRefSet;
    if (!(r#35 == null)) {
      assert {:msg "  382.11: Receiver might be null."} true && (0 <= k#87#301) ==> (r#35 != null);
      assert {:msg "  382.11: Location might not be readable."} true && (0 <= k#87#301) ==> CanRead(assertMask#_992, r#35, AVLTreeNode.keys);
      assert {:msg "  382.11: Receiver might be null."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
      assert {:msg "  382.11: Location might not be readable."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_992, r#35, AVLTreeNode.keys);
      assert {:msg "  382.45: Sequence index might be negative."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (0 <= k#87#301);
      assert {:msg "  382.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys]));
      assert {:msg "  382.49: Receiver might be null."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
      assert {:msg "  382.49: Location might not be readable."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_992, m#36, AVLTreeNode.keys);
      assert {:msg "  382.49: Sequence index might be negative."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  382.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#87#301) && (k#87#301 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_991[m#36, AVLTreeNode.keys]));
      assert {:msg "  382.4: Assertion might not hold. The expression at 382.23 might not evaluate to true."} (forall k#87#300: int :: 
        (0 <= k#87#300) && (k#87#300 < Seq#Length(assertHeap#_991[r#35, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_991[r#35, AVLTreeNode.keys], k#87#300) < Seq#Index(assertHeap#_991[m#36, AVLTreeNode.keys], 0))
      );
    }
    assertMask#_992 := exhaleMask#_996;
    assume IsGoodExhaleState(exhaleHeap#_995, assertHeap#_991, assertMask#_992, exhaledHolds#_997);
    assertHeap#_991 := exhaleHeap#_995;
    assume IsGoodMask(assertMask#_992);
    assume wf(assertHeap#_991, assertMask#_992, assertSecMask#_993);
    // end exhale
  } else {
    // local var nr
    assume (0.0 < methodCallK#_1002) && ((1000.0 * methodCallK#_1002) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1002) < methodK#_947);
    // call pruneMax
    callHeap#_998 := Heap;
    callMask#_999 := Mask;
    callSecMask#_1000 := SecMask;
    callCredits#_1001 := Credits;
    assume wf(callHeap#_998, callMask#_999, callSecMask#_1000);
    assert {:msg "  387.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  387.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  387.4: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
    this#303 := Heap[this, AVLTreeNode.right];
    // begin exhale (precondition)
    exhaleMask#_1004 := Mask;
    havoc exhaleHeap#_1003;
    exhaledHolds#_1005 := ZeroRefSet;
    assert {:msg "  387.4: The precondition at 349.12 might not hold. The permission at 349.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  387.4: The precondition at 349.12 might not hold. Insufficient fraction at 349.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1004[this#303, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1004[this#303, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1004[this#303, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1004[this#303, AVLTreeNode.valid] := exhaleMask#_1004[this#303, AVLTreeNode.valid][perm$R := exhaleMask#_1004[this#303, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1004, this#303, AVLTreeNode.valid)) {
      assume Heap[this#303, AVLTreeNode.valid] < exhaleHeap#_1003[this#303, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1004, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  387.4: The precondition at 350.12 might not hold. The permission at 350.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  387.4: The precondition at 350.12 might not hold. Insufficient fraction at 350.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1004[this#303, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1004[this#303, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1004[this#303, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1004[this#303, AVLTreeNode.keys] := exhaleMask#_1004[this#303, AVLTreeNode.keys][perm$R := exhaleMask#_1004[this#303, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1004, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  387.4: The precondition at 351.12 might not hold. The permission at 351.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  387.4: The precondition at 351.12 might not hold. Insufficient fraction at 351.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1004[this#303, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1004[this#303, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1004[this#303, AVLTreeNode.height][perm$N]));
    exhaleMask#_1004[this#303, AVLTreeNode.height] := exhaleMask#_1004[this#303, AVLTreeNode.height][perm$R := exhaleMask#_1004[this#303, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1004, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  387.4: The precondition at 352.12 might not hold. The permission at 352.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  387.4: The precondition at 352.12 might not hold. Insufficient fraction at 352.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1004[this#303, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1004[this#303, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1004[this#303, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1004[this#303, AVLTreeNode.balanceFactor] := exhaleMask#_1004[this#303, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1004[this#303, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1004, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_1004;
    assume IsGoodExhaleState(exhaleHeap#_1003, Heap, Mask, exhaledHolds#_1005);
    Heap := exhaleHeap#_1003;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#304;
    havoc m#305;
    // inhale (postcondition)
    if (!(r#304 == null)) {
      assume r#304 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#304, AVLTreeNode.valid] := Mask[r#304, AVLTreeNode.valid][perm$R := Mask[r#304, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#304 == null)) {
      assume r#304 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#304, AVLTreeNode.keys] := Mask[r#304, AVLTreeNode.keys][perm$R := Mask[r#304, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#304 == null)) {
      assume r#304 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#304, AVLTreeNode.height] := Mask[r#304, AVLTreeNode.height][perm$R := Mask[r#304, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#304 == null)) {
      assume r#304 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#304, AVLTreeNode.balanceFactor] := Mask[r#304, AVLTreeNode.balanceFactor][perm$R := Mask[r#304, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#304 == null)) {
      assume (Heap[r#304, AVLTreeNode.height] == callHeap#_998[this#303, AVLTreeNode.height]) || ((Heap[r#304, AVLTreeNode.height] + 1) == callHeap#_998[this#303, AVLTreeNode.height]);
    }
    if (!(r#304 == null)) {
      assume (Seq#Length(Heap[r#304, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_998[this#303, AVLTreeNode.keys]);
    }
    if (callHeap#_998[this#303, AVLTreeNode.height] > 1) {
      assume !(r#304 == null);
    }
    if (callHeap#_998[this#303, AVLTreeNode.height] == 1) {
      assume r#304 == null;
    }
    assume (callHeap#_998[this#303, AVLTreeNode.height] == ite(r#304 == null, 0, Heap[r#304, AVLTreeNode.height])) || (callHeap#_998[this#303, AVLTreeNode.height] == (ite(r#304 == null, 0, Heap[r#304, AVLTreeNode.height]) + 1));
    assume !(m#305 == null);
    assume m#305 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[m#305, AVLTreeNode.valid] := Mask[m#305, AVLTreeNode.valid][perm$R := Mask[m#305, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#305 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[m#305, AVLTreeNode.keys] := Mask[m#305, AVLTreeNode.keys][perm$R := Mask[m#305, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#305 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[m#305, AVLTreeNode.height] := Mask[m#305, AVLTreeNode.height][perm$R := Mask[m#305, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#305 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[m#305, AVLTreeNode.balanceFactor] := Mask[m#305, AVLTreeNode.balanceFactor][perm$R := Mask[m#305, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[m#305, AVLTreeNode.height] == 1;
    assume Seq#Length(Heap[m#305, AVLTreeNode.keys]) == 1;
    assume Seq#Equal(Seq#Append(ite(r#304 == null, Seq#Empty(), Heap[r#304, AVLTreeNode.keys]), Heap[m#305, AVLTreeNode.keys]), callHeap#_998[this#303, AVLTreeNode.keys]);
    if (!(r#304 == null)) {
      assume (forall k#86#306: int :: 
        (0 <= k#86#306) && (k#86#306 < Seq#Length(Heap[r#304, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#304, AVLTreeNode.keys], k#86#306) < Seq#Index(Heap[m#305, AVLTreeNode.keys], 0))
      );
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    nr#38 := r#304;
    m#36 := m#305;
    // update field right
    assert {:msg "  388.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := nr#38;
    assume wf(Heap, Mask, SecMask);
    // local var bf
    assume (0.0 < methodCallK#_1017) && ((1000.0 * methodCallK#_1017) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1017) < methodK#_947);
    // call getBalanceFactorI
    callHeap#_1013 := Heap;
    callMask#_1014 := Mask;
    callSecMask#_1015 := SecMask;
    callCredits#_1016 := Credits;
    assume wf(callHeap#_1013, callMask#_1014, callSecMask#_1015);
    assert {:msg "  390.4: The target of the method call might be null."} this != null;
    this#307 := this;
    // begin exhale (precondition)
    exhaleMask#_1019 := Mask;
    havoc exhaleHeap#_1018;
    exhaledHolds#_1020 := ZeroRefSet;
    assert {:msg "  390.4: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_1017 > 0.0;
    assert {:msg "  390.4: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_1019[this#307, AVLTreeNode.left][perm$R] > 0.0;
    assume methodCallK#_1017 < exhaleMask#_1019[this#307, AVLTreeNode.left][perm$R];
    exhaleMask#_1019[this#307, AVLTreeNode.left] := exhaleMask#_1019[this#307, AVLTreeNode.left][perm$R := exhaleMask#_1019[this#307, AVLTreeNode.left][perm$R] - methodCallK#_1017];
    assume wf(Heap, exhaleMask#_1019, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#307, AVLTreeNode.left] == null)) {
      assert {:msg "  390.4: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_1017 > 0.0;
      assert {:msg "  390.4: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
      assume methodCallK#_1017 < exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height][perm$R];
      exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_1017];
      assume wf(Heap, exhaleMask#_1019, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  390.4: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_1017 > 0.0;
    assert {:msg "  390.4: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_1019[this#307, AVLTreeNode.right][perm$R] > 0.0;
    assume methodCallK#_1017 < exhaleMask#_1019[this#307, AVLTreeNode.right][perm$R];
    exhaleMask#_1019[this#307, AVLTreeNode.right] := exhaleMask#_1019[this#307, AVLTreeNode.right][perm$R := exhaleMask#_1019[this#307, AVLTreeNode.right][perm$R] - methodCallK#_1017];
    assume wf(Heap, exhaleMask#_1019, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#307, AVLTreeNode.right] == null)) {
      assert {:msg "  390.4: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_1017 > 0.0;
      assert {:msg "  390.4: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
      assume methodCallK#_1017 < exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height][perm$R];
      exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_1017];
      assume wf(Heap, exhaleMask#_1019, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#307, AVLTreeNode.left] == null)) {
      assert {:msg "  390.4: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  390.4: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1019[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1019, Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1018[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1019, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#307, AVLTreeNode.right] == null)) {
      assert {:msg "  390.4: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  390.4: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1019[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1019, Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1018[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1019, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1019;
    assume IsGoodExhaleState(exhaleHeap#_1018, Heap, Mask, exhaledHolds#_1020);
    Heap := exhaleHeap#_1018;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc bf#308;
    // inhale (postcondition)
    assume this#307 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#307, AVLTreeNode.left] == null) || (dtype(Heap[this#307, AVLTreeNode.left]) == AVLTreeNode#t);
    assume methodCallK#_1017 > 0.0;
    Mask[this#307, AVLTreeNode.left] := Mask[this#307, AVLTreeNode.left][perm$R := Mask[this#307, AVLTreeNode.left][perm$R] + methodCallK#_1017];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#307, AVLTreeNode.left] == null)) {
      assume Heap[this#307, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#307, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#307, AVLTreeNode.left] == null)) {
      assume Heap[this#307, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_1017 > 0.0;
      Mask[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_1017];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume this#307 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#307, AVLTreeNode.right] == null) || (dtype(Heap[this#307, AVLTreeNode.right]) == AVLTreeNode#t);
    assume methodCallK#_1017 > 0.0;
    Mask[this#307, AVLTreeNode.right] := Mask[this#307, AVLTreeNode.right][perm$R := Mask[this#307, AVLTreeNode.right][perm$R] + methodCallK#_1017];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#307, AVLTreeNode.right] == null)) {
      assume Heap[this#307, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#307, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#307, AVLTreeNode.right] == null)) {
      assume Heap[this#307, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_1017 > 0.0;
      Mask[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_1017];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume bf#308 == (ite(Heap[this#307, AVLTreeNode.left] == null, 0, Heap[Heap[this#307, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#307, AVLTreeNode.right] == null, 0, Heap[Heap[this#307, AVLTreeNode.right], AVLTreeNode.height]));
    if (bf#308 > 0) {
      assume !(Heap[this#307, AVLTreeNode.left] == null);
    }
    if (bf#308 < 0) {
      assume !(Heap[this#307, AVLTreeNode.right] == null);
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    bf#40 := bf#308;
    // if
    cond#_1030 := bf#40 == 2;
    if (cond#_1030) {
      assume (0.0 < methodCallK#_1035) && ((1000.0 * methodCallK#_1035) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1035) < methodK#_947);
      // call rebalanceLeft
      callHeap#_1031 := Heap;
      callMask#_1032 := Mask;
      callSecMask#_1033 := SecMask;
      callCredits#_1034 := Credits;
      assume wf(callHeap#_1031, callMask#_1032, callSecMask#_1033);
      assert {:msg "  392.5: The target of the method call might be null."} this != null;
      this#309 := this;
      // begin exhale (precondition)
      exhaleMask#_1037 := Mask;
      havoc exhaleHeap#_1036;
      exhaledHolds#_1038 := ZeroRefSet;
      assert {:msg "  392.5: The precondition at 608.12 might not hold. The expression at 608.12 might not evaluate to true."} !(Heap[this#309, AVLTreeNode.left] == null);
      assert {:msg "  392.5: The precondition at 613.12 might not hold. The expression at 613.12 might not evaluate to true."} (forall k#94#311: int :: 
        (0 <= k#94#311) && (k#94#311 < Seq#Length(Heap[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys], k#94#311) < Heap[this#309, AVLTreeNode.key])
      );
      if (!(Heap[this#309, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 619.12 might not hold. The expression at 619.28 might not evaluate to true."} (forall k#95#312: int :: 
          (0 <= k#95#312) && (k#95#312 < Seq#Length(Heap[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#309, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys], k#95#312))
        );
      }
      assert {:msg "  392.5: The precondition at 621.12 might not hold. The expression at 621.12 might not evaluate to true."} (Heap[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#309, AVLTreeNode.right] == null, 0, Heap[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height])) == 2;
      assert {:msg "  392.5: The precondition at 600.12 might not hold. The permission at 600.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1037[this#309, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[this#309, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1037[this#309, AVLTreeNode.key][perm$N]));
      exhaleMask#_1037[this#309, AVLTreeNode.key] := exhaleMask#_1037[this#309, AVLTreeNode.key][perm$R := exhaleMask#_1037[this#309, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 601.12 might not hold. The permission at 601.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1037[this#309, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[this#309, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1037[this#309, AVLTreeNode.height][perm$N]));
      exhaleMask#_1037[this#309, AVLTreeNode.height] := exhaleMask#_1037[this#309, AVLTreeNode.height][perm$R := exhaleMask#_1037[this#309, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 602.12 might not hold. The permission at 602.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 602.12 might not hold. Insufficient fraction at 602.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1037[this#309, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[this#309, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1037[this#309, AVLTreeNode.left][perm$N]));
      exhaleMask#_1037[this#309, AVLTreeNode.left] := exhaleMask#_1037[this#309, AVLTreeNode.left][perm$R := exhaleMask#_1037[this#309, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 603.12 might not hold. The permission at 603.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1037[this#309, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[this#309, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1037[this#309, AVLTreeNode.right][perm$N]));
      exhaleMask#_1037[this#309, AVLTreeNode.right] := exhaleMask#_1037[this#309, AVLTreeNode.right][perm$R := exhaleMask#_1037[this#309, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 605.12 might not hold. The permission at 605.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 605.12 might not hold. Insufficient fraction at 605.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1037[this#309, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[this#309, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1037[this#309, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1037[this#309, AVLTreeNode.keys] := exhaleMask#_1037[this#309, AVLTreeNode.keys][perm$R := exhaleMask#_1037[this#309, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 606.12 might not hold. The permission at 606.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 606.12 might not hold. Insufficient fraction at 606.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1037[this#309, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[this#309, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1037[this#309, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1037[this#309, AVLTreeNode.balanceFactor] := exhaleMask#_1037[this#309, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1037[this#309, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 609.12 might not hold. The permission at 609.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1037, Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1036[Heap[this#309, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 610.12 might not hold. The permission at 610.12 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 611.12 might not hold. The permission at 611.12 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 611.12 might not hold. Insufficient fraction at 611.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  392.5: The precondition at 612.12 might not hold. The permission at 612.12 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  392.5: The precondition at 612.12 might not hold. Insufficient fraction at 612.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1037, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#309, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 615.12 might not hold. The permission at 615.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  392.5: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1037, Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1036[Heap[this#309, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1037, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#309, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 616.12 might not hold. The permission at 616.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  392.5: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1037, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#309, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 617.12 might not hold. The permission at 617.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  392.5: The precondition at 617.12 might not hold. Insufficient fraction at 617.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1037, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#309, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 618.12 might not hold. The permission at 618.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  392.5: The precondition at 618.12 might not hold. Insufficient fraction at 618.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1037[Heap[this#309, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1037, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_1037;
      assume IsGoodExhaleState(exhaleHeap#_1036, Heap, Mask, exhaledHolds#_1038);
      Heap := exhaleHeap#_1036;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc r#310;
      // inhale (postcondition)
      assume !(r#310 == null);
      assume r#310 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#310, AVLTreeNode.valid] := Mask[r#310, AVLTreeNode.valid][perm$R := Mask[r#310, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#310 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#310, AVLTreeNode.height] := Mask[r#310, AVLTreeNode.height][perm$R := Mask[r#310, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#310 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#310, AVLTreeNode.keys] := Mask[r#310, AVLTreeNode.keys][perm$R := Mask[r#310, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#310 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#310, AVLTreeNode.balanceFactor] := Mask[r#310, AVLTreeNode.balanceFactor][perm$R := Mask[r#310, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#310, AVLTreeNode.height] == callHeap#_1031[callHeap#_1031[this#309, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#310, AVLTreeNode.height] == (callHeap#_1031[callHeap#_1031[this#309, AVLTreeNode.left], AVLTreeNode.height] + 1));
      assume Seq#Equal(Heap[r#310, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_1031[callHeap#_1031[this#309, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_1031[this#309, AVLTreeNode.key])), ite(callHeap#_1031[this#309, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1031[callHeap#_1031[this#309, AVLTreeNode.right], AVLTreeNode.keys])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      r#35 := r#310;
    } else {
      assume (0.0 < methodCallK#_1060) && ((1000.0 * methodCallK#_1060) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1060) < methodK#_947);
      // call close
      callHeap#_1056 := Heap;
      callMask#_1057 := Mask;
      callSecMask#_1058 := SecMask;
      callCredits#_1059 := Credits;
      assume wf(callHeap#_1056, callMask#_1057, callSecMask#_1058);
      assert {:msg "  394.5: The target of the method call might be null."} this != null;
      this#315 := this;
      // begin exhale (precondition)
      exhaleMask#_1062 := Mask;
      havoc exhaleHeap#_1061;
      exhaledHolds#_1063 := ZeroRefSet;
      if (!(Heap[this#315, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#316: int :: 
          (0 <= k#92#316) && (k#92#316 < Seq#Length(Heap[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys], k#92#316) < Heap[this#315, AVLTreeNode.key])
        );
      }
      if (!(Heap[this#315, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#317: int :: 
          (0 <= k#93#317) && (k#93#317 < Seq#Length(Heap[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#315, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys], k#93#317))
        );
      }
      assert {:msg "  394.5: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#315, AVLTreeNode.left] == null, 0, Heap[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#315, AVLTreeNode.right] == null, 0, Heap[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  394.5: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#315, AVLTreeNode.left] == null, 0, Heap[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#315, AVLTreeNode.right] == null, 0, Heap[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      assert {:msg "  394.5: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  394.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1062[this#315, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[this#315, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1062[this#315, AVLTreeNode.key][perm$N]));
      exhaleMask#_1062[this#315, AVLTreeNode.key] := exhaleMask#_1062[this#315, AVLTreeNode.key][perm$R := exhaleMask#_1062[this#315, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1062, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  394.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1062[this#315, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[this#315, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1062[this#315, AVLTreeNode.height][perm$N]));
      exhaleMask#_1062[this#315, AVLTreeNode.height] := exhaleMask#_1062[this#315, AVLTreeNode.height][perm$R := exhaleMask#_1062[this#315, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1062, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  394.5: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1062[this#315, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[this#315, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1062[this#315, AVLTreeNode.left][perm$N]));
      exhaleMask#_1062[this#315, AVLTreeNode.left] := exhaleMask#_1062[this#315, AVLTreeNode.left][perm$R := exhaleMask#_1062[this#315, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1062, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  394.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1062[this#315, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[this#315, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1062[this#315, AVLTreeNode.right][perm$N]));
      exhaleMask#_1062[this#315, AVLTreeNode.right] := exhaleMask#_1062[this#315, AVLTreeNode.right][perm$R := exhaleMask#_1062[this#315, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1062, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  394.5: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1062[this#315, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[this#315, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1062[this#315, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1062[this#315, AVLTreeNode.keys] := exhaleMask#_1062[this#315, AVLTreeNode.keys][perm$R := exhaleMask#_1062[this#315, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1062, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  394.5: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  394.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1062[this#315, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[this#315, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1062[this#315, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1062[this#315, AVLTreeNode.balanceFactor] := exhaleMask#_1062[this#315, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1062[this#315, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1062, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#315, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1062, Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1061[Heap[this#315, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.left] == null)) {
        assert {:msg "  394.5: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1062, Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1061[Heap[this#315, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#315, AVLTreeNode.right] == null)) {
        assert {:msg "  394.5: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  394.5: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1062[Heap[this#315, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1062, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_1062;
      assume IsGoodExhaleState(exhaleHeap#_1061, Heap, Mask, exhaledHolds#_1063);
      Heap := exhaleHeap#_1061;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (postcondition)
      assume this#315 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[this#315, AVLTreeNode.valid] := Mask[this#315, AVLTreeNode.valid][perm$R := Mask[this#315, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#315 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#315, AVLTreeNode.height] := Mask[this#315, AVLTreeNode.height][perm$R := Mask[this#315, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#315 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#315, AVLTreeNode.keys] := Mask[this#315, AVLTreeNode.keys][perm$R := Mask[this#315, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#315 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#315, AVLTreeNode.balanceFactor] := Mask[this#315, AVLTreeNode.balanceFactor][perm$R := Mask[this#315, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume Seq#Equal(Heap[this#315, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1056[this#315, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1056[this#315, AVLTreeNode.key])), ite(callHeap#_1056[this#315, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Heap[this#315, AVLTreeNode.height] == ite(ite(callHeap#_1056[this#315, AVLTreeNode.left] == null, 0, callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1056[this#315, AVLTreeNode.right] == null, 0, callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1056[this#315, AVLTreeNode.left] == null, 0, callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1056[this#315, AVLTreeNode.right] == null, 0, callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#315, AVLTreeNode.balanceFactor] == (ite(callHeap#_1056[this#315, AVLTreeNode.left] == null, 0, callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1056[this#315, AVLTreeNode.right] == null, 0, callHeap#_1056[callHeap#_1056[this#315, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      // assigment to r
      r#35 := this;
    }
    // assert
    assertHeap#_1081 := Heap;
    assertMask#_1082 := Mask;
    assertSecMask#_1083 := SecMask;
    assertCredits#_1084 := Credits;
    assume wf(assertHeap#_1081, assertMask#_1082, assertSecMask#_1083);
    // begin exhale (assert)
    exhaleMask#_1086 := assertMask#_1082;
    havoc exhaleHeap#_1085;
    exhaledHolds#_1087 := ZeroRefSet;
    if (!(r#35 == null)) {
      assert {:msg "  397.11: Receiver might be null."} true && (0 <= k#88#321) ==> (r#35 != null);
      assert {:msg "  397.11: Location might not be readable."} true && (0 <= k#88#321) ==> CanRead(assertMask#_1082, r#35, AVLTreeNode.keys);
      assert {:msg "  397.11: Receiver might be null."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
      assert {:msg "  397.11: Location might not be readable."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_1082, r#35, AVLTreeNode.keys);
      assert {:msg "  397.45: Sequence index might be negative."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (0 <= k#88#321);
      assert {:msg "  397.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys]));
      assert {:msg "  397.49: Receiver might be null."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
      assert {:msg "  397.49: Location might not be readable."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> CanRead(assertMask#_1082, m#36, AVLTreeNode.keys);
      assert {:msg "  397.49: Sequence index might be negative."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  397.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#88#321) && (k#88#321 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_1081[m#36, AVLTreeNode.keys]));
      assert {:msg "  397.4: Assertion might not hold. The expression at 397.23 might not evaluate to true."} (forall k#88#320: int :: 
        (0 <= k#88#320) && (k#88#320 < Seq#Length(assertHeap#_1081[r#35, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1081[r#35, AVLTreeNode.keys], k#88#320) < Seq#Index(assertHeap#_1081[m#36, AVLTreeNode.keys], 0))
      );
    }
    assertMask#_1082 := exhaleMask#_1086;
    assume IsGoodExhaleState(exhaleHeap#_1085, assertHeap#_1081, assertMask#_1082, exhaledHolds#_1087);
    assertHeap#_1081 := exhaleHeap#_1085;
    assume IsGoodMask(assertMask#_1082);
    assume wf(assertHeap#_1081, assertMask#_1082, assertSecMask#_1083);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_1089 := Mask;
  havoc exhaleHeap#_1088;
  exhaledHolds#_1090 := ZeroRefSet;
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 358.11 might not hold. The expression at 358.26 might not evaluate to true."} (Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#35, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 359.11 might not hold. The expression at 359.24 might not evaluate to true."} (Seq#Length(Heap[r#35, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  348.2: The postcondition at 360.11 might not hold. The expression at 360.30 might not evaluate to true."} !(r#35 == null);
  }
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assert {:msg "  348.2: The postcondition at 361.11 might not hold. The expression at 361.30 might not evaluate to true."} r#35 == null;
  }
  assert {:msg "  348.2: The postcondition at 362.11 might not hold. The expression at 362.11 might not evaluate to true."} (old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]) + 1));
  assert {:msg "  348.2: The postcondition at 364.11 might not hold. The expression at 364.11 might not evaluate to true."} !(m#36 == null);
  assert {:msg "  348.2: The postcondition at 369.11 might not hold. The expression at 369.11 might not evaluate to true."} Heap[m#36, AVLTreeNode.height] == 1;
  assert {:msg "  348.2: The postcondition at 370.11 might not hold. The expression at 370.11 might not evaluate to true."} Seq#Length(Heap[m#36, AVLTreeNode.keys]) == 1;
  assert {:msg "  348.2: The postcondition at 372.11 might not hold. The expression at 372.11 might not evaluate to true."} Seq#Equal(Seq#Append(ite(r#35 == null, Seq#Empty(), Heap[r#35, AVLTreeNode.keys]), Heap[m#36, AVLTreeNode.keys]), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 373.11 might not hold. The expression at 373.23 might not evaluate to true."} (forall k#86#323: int :: 
      (0 <= k#86#323) && (k#86#323 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#35, AVLTreeNode.keys], k#86#323) < Seq#Index(Heap[m#36, AVLTreeNode.keys], 0))
    );
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 354.11 might not hold. The permission at 354.25 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  348.2: The postcondition at 354.11 might not hold. Insufficient fraction at 354.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1089[r#35, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1089[r#35, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1089[r#35, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1089[r#35, AVLTreeNode.valid] := exhaleMask#_1089[r#35, AVLTreeNode.valid][perm$R := exhaleMask#_1089[r#35, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1089, r#35, AVLTreeNode.valid)) {
      assume Heap[r#35, AVLTreeNode.valid] < exhaleHeap#_1088[r#35, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1089, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 355.11 might not hold. The permission at 355.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  348.2: The postcondition at 355.11 might not hold. Insufficient fraction at 355.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1089[r#35, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1089[r#35, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1089[r#35, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1089[r#35, AVLTreeNode.keys] := exhaleMask#_1089[r#35, AVLTreeNode.keys][perm$R := exhaleMask#_1089[r#35, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1089, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 356.11 might not hold. The permission at 356.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  348.2: The postcondition at 356.11 might not hold. Insufficient fraction at 356.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1089[r#35, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1089[r#35, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1089[r#35, AVLTreeNode.height][perm$N]));
    exhaleMask#_1089[r#35, AVLTreeNode.height] := exhaleMask#_1089[r#35, AVLTreeNode.height][perm$R := exhaleMask#_1089[r#35, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1089, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#35 == null)) {
    assert {:msg "  348.2: The postcondition at 357.11 might not hold. The permission at 357.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  348.2: The postcondition at 357.11 might not hold. Insufficient fraction at 357.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1089[r#35, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1089[r#35, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1089[r#35, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1089[r#35, AVLTreeNode.balanceFactor] := exhaleMask#_1089[r#35, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1089[r#35, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1089, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  348.2: The postcondition at 365.11 might not hold. The permission at 365.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  348.2: The postcondition at 365.11 might not hold. Insufficient fraction at 365.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1089[m#36, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1089[m#36, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1089[m#36, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1089[m#36, AVLTreeNode.valid] := exhaleMask#_1089[m#36, AVLTreeNode.valid][perm$R := exhaleMask#_1089[m#36, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1089, m#36, AVLTreeNode.valid)) {
    assume Heap[m#36, AVLTreeNode.valid] < exhaleHeap#_1088[m#36, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1089, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  348.2: The postcondition at 366.11 might not hold. The permission at 366.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  348.2: The postcondition at 366.11 might not hold. Insufficient fraction at 366.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1089[m#36, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1089[m#36, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1089[m#36, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1089[m#36, AVLTreeNode.keys] := exhaleMask#_1089[m#36, AVLTreeNode.keys][perm$R := exhaleMask#_1089[m#36, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1089, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  348.2: The postcondition at 367.11 might not hold. The permission at 367.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  348.2: The postcondition at 367.11 might not hold. Insufficient fraction at 367.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1089[m#36, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1089[m#36, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1089[m#36, AVLTreeNode.height][perm$N]));
  exhaleMask#_1089[m#36, AVLTreeNode.height] := exhaleMask#_1089[m#36, AVLTreeNode.height][perm$R := exhaleMask#_1089[m#36, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1089, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  348.2: The postcondition at 368.11 might not hold. The permission at 368.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  348.2: The postcondition at 368.11 might not hold. Insufficient fraction at 368.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1089[m#36, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1089[m#36, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1089[m#36, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1089[m#36, AVLTreeNode.balanceFactor] := exhaleMask#_1089[m#36, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1089[m#36, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1089, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1089;
  assume IsGoodExhaleState(exhaleHeap#_1088, Heap, Mask, exhaledHolds#_1090);
  Heap := exhaleHeap#_1088;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  348.2: Method might lock/unlock more than allowed."} (forall lk#_1099: ref :: 
    { Heap[lk#_1099, held] }
    { Heap[lk#_1099, rdheld] }
    (((0 < Heap[lk#_1099, held]) == (0 < old(Heap)[lk#_1099, held])) && (Heap[lk#_1099, rdheld] == old(Heap)[lk#_1099, rdheld])) || false
  );
  assert {:msg "  348.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.pruneMin
// -------------------------------------------

// definedness check for method AVLTreeNode.pruneMin
procedure AVLTreeNode.pruneMin$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1100: real;
  var k#89#326: int where true;
  assume (0.0 < methodK#_1100) && ((1000.0 * methodK#_1100) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  404.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1103: Field (PMaskType) :: 
    (forall ref#_1102: ref :: 
      Heap[ref#_1102, pmask#_1103] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  if (!(r#41 == null)) {
    assert {:msg "  409.25: Receiver might be null."} r#41 != null;
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#41, AVLTreeNode.valid] := Mask[r#41, AVLTreeNode.valid][perm$R := Mask[r#41, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#41, AVLTreeNode.keys] := Mask[r#41, AVLTreeNode.keys][perm$R := Mask[r#41, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#41, AVLTreeNode.height] := Mask[r#41, AVLTreeNode.height][perm$R := Mask[r#41, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assume r#41 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#41, AVLTreeNode.balanceFactor] := Mask[r#41, AVLTreeNode.balanceFactor][perm$R := Mask[r#41, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  413.26: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  413.26: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.height);
    assert {:msg "  413.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  413.42: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assert {:msg "  413.53: Receiver might be null."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
    assert {:msg "  413.53: Location might not be readable."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#41, AVLTreeNode.height);
    assert {:msg "  413.69: Receiver might be null."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  413.69: Location might not be readable."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume (Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
  }
  if (!(r#41 == null)) {
    assert {:msg "  414.25: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  414.25: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.keys);
    assert {:msg "  414.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  414.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume (Seq#Length(Heap[r#41, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  assert {:msg "  415.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  415.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#41 == null);
  }
  assert {:msg "  416.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  416.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assume r#41 == null;
  }
  assert {:msg "  417.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  417.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#41 == null) {
  } else {
    assert {:msg "  417.35: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  417.35: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.height);
  }
  assert {:msg "  417.52: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> (this != null);
  assert {:msg "  417.52: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#41 == null) {
  } else {
    assert {:msg "  417.72: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> (r#41 != null);
    assert {:msg "  417.72: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> CanRead(Mask, r#41, AVLTreeNode.height);
  }
  assume (old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]) + 1));
  assume !(m#42 == null);
  assert {:msg "  420.11: Receiver might be null."} m#42 != null;
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[m#42, AVLTreeNode.valid] := Mask[m#42, AVLTreeNode.valid][perm$R := Mask[m#42, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[m#42, AVLTreeNode.keys] := Mask[m#42, AVLTreeNode.keys][perm$R := Mask[m#42, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[m#42, AVLTreeNode.height] := Mask[m#42, AVLTreeNode.height][perm$R := Mask[m#42, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume m#42 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[m#42, AVLTreeNode.balanceFactor] := Mask[m#42, AVLTreeNode.balanceFactor][perm$R := Mask[m#42, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  424.11: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  424.11: Location might not be readable."} true ==> CanRead(Mask, m#42, AVLTreeNode.height);
  assume Heap[m#42, AVLTreeNode.height] == 1;
  assert {:msg "  425.12: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  425.12: Location might not be readable."} true ==> CanRead(Mask, m#42, AVLTreeNode.keys);
  assume Seq#Length(Heap[m#42, AVLTreeNode.keys]) == 1;
  assert {:msg "  427.11: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  427.11: Location might not be readable."} true ==> CanRead(Mask, m#42, AVLTreeNode.keys);
  if (r#41 == null) {
  } else {
    assert {:msg "  427.39: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  427.39: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.keys);
  }
  assert {:msg "  427.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  427.54: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assume Seq#Equal(Seq#Append(Heap[m#42, AVLTreeNode.keys], ite(r#41 == null, Seq#Empty(), Heap[r#41, AVLTreeNode.keys])), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#41 == null)) {
    assert {:msg "  428.11: Receiver might be null."} true && (0 <= k#89#326) ==> (r#41 != null);
    assert {:msg "  428.11: Location might not be readable."} true && (0 <= k#89#326) ==> CanRead(Mask, r#41, AVLTreeNode.keys);
    assert {:msg "  428.45: Receiver might be null."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
    assert {:msg "  428.45: Location might not be readable."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask, m#42, AVLTreeNode.keys);
    assert {:msg "  428.45: Sequence index might be negative."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
    assert {:msg "  428.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap[m#42, AVLTreeNode.keys]));
    assert {:msg "  428.11: Receiver might be null."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
    assert {:msg "  428.11: Location might not be readable."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask, r#41, AVLTreeNode.keys);
    assert {:msg "  428.57: Sequence index might be negative."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= k#89#326);
    assert {:msg "  428.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#89#326) && (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (k#89#326 < Seq#Length(Heap[r#41, AVLTreeNode.keys]));
    assume (forall k#89#325: int :: 
      (0 <= k#89#325) && (k#89#325 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#41, AVLTreeNode.keys], k#89#325))
    );
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.pruneMin
procedure AVLTreeNode.pruneMin(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1100: real;
  var predRec#_1109: ref;
  var predVer#_1110: int;
  var unfoldK#_1108: real;
  var oldVers#_1115: int;
  var newVers#_1116: int;
  var cond#_1118: bool;
  var methodCallK#_1123: real;
  var this#329: ref where (this#329 == null) || (dtype(this#329) == AVLTreeNode#t);
  var callHeap#_1119: HeapType;
  var callMask#_1120: MaskType;
  var callSecMask#_1121: MaskType;
  var callCredits#_1122: CreditsType;
  var exhaleMask#_1125: MaskType;
  var exhaleHeap#_1124: HeapType;
  var exhaledHolds#_1126: RefSet;
  var isHeld#_1141: int;
  var isRdHeld#_1142: bool;
  var assertHeap#_1144: HeapType;
  var assertMask#_1145: MaskType;
  var assertSecMask#_1146: MaskType;
  var assertCredits#_1147: CreditsType;
  var exhaleMask#_1149: MaskType;
  var exhaleHeap#_1148: HeapType;
  var exhaledHolds#_1150: RefSet;
  var assertHeap#_1151: HeapType;
  var assertMask#_1152: MaskType;
  var assertSecMask#_1153: MaskType;
  var assertCredits#_1154: CreditsType;
  var exhaleMask#_1156: MaskType;
  var exhaleHeap#_1155: HeapType;
  var exhaledHolds#_1157: RefSet;
  var k#90#335: int where true;
  var nl#44: ref where (nl#44 == null) || (dtype(nl#44) == AVLTreeNode#t);
  var methodCallK#_1162: real;
  var this#337: ref where (this#337 == null) || (dtype(this#337) == AVLTreeNode#t);
  var r#338: ref where (r#338 == null) || (dtype(r#338) == AVLTreeNode#t);
  var m#339: ref where (m#339 == null) || (dtype(m#339) == AVLTreeNode#t);
  var callHeap#_1158: HeapType;
  var callMask#_1159: MaskType;
  var callSecMask#_1160: MaskType;
  var callCredits#_1161: CreditsType;
  var exhaleMask#_1164: MaskType;
  var exhaleHeap#_1163: HeapType;
  var exhaledHolds#_1165: RefSet;
  var isHeld#_1170: int;
  var isRdHeld#_1171: bool;
  var bf#46: int where true;
  var methodCallK#_1177: real;
  var this#341: ref where (this#341 == null) || (dtype(this#341) == AVLTreeNode#t);
  var bf#342: int where true;
  var callHeap#_1173: HeapType;
  var callMask#_1174: MaskType;
  var callSecMask#_1175: MaskType;
  var callCredits#_1176: CreditsType;
  var exhaleMask#_1179: MaskType;
  var exhaleHeap#_1178: HeapType;
  var exhaledHolds#_1180: RefSet;
  var isHeld#_1187: int;
  var isRdHeld#_1188: bool;
  var cond#_1190: bool;
  var methodCallK#_1195: real;
  var this#343: ref where (this#343 == null) || (dtype(this#343) == AVLTreeNode#t);
  var r#344: ref where (r#344 == null) || (dtype(r#344) == AVLTreeNode#t);
  var callHeap#_1191: HeapType;
  var callMask#_1192: MaskType;
  var callSecMask#_1193: MaskType;
  var callCredits#_1194: CreditsType;
  var exhaleMask#_1197: MaskType;
  var exhaleHeap#_1196: HeapType;
  var exhaledHolds#_1198: RefSet;
  var isHeld#_1213: int;
  var isRdHeld#_1214: bool;
  var assertHeap#_1216: HeapType;
  var assertMask#_1217: MaskType;
  var assertSecMask#_1218: MaskType;
  var assertCredits#_1219: CreditsType;
  var exhaleMask#_1221: MaskType;
  var exhaleHeap#_1220: HeapType;
  var exhaledHolds#_1222: RefSet;
  var methodCallK#_1227: real;
  var this#349: ref where (this#349 == null) || (dtype(this#349) == AVLTreeNode#t);
  var callHeap#_1223: HeapType;
  var callMask#_1224: MaskType;
  var callSecMask#_1225: MaskType;
  var callCredits#_1226: CreditsType;
  var exhaleMask#_1229: MaskType;
  var exhaleHeap#_1228: HeapType;
  var exhaledHolds#_1230: RefSet;
  var isHeld#_1245: int;
  var isRdHeld#_1246: bool;
  var assertHeap#_1248: HeapType;
  var assertMask#_1249: MaskType;
  var assertSecMask#_1250: MaskType;
  var assertCredits#_1251: CreditsType;
  var exhaleMask#_1253: MaskType;
  var exhaleHeap#_1252: HeapType;
  var exhaledHolds#_1254: RefSet;
  var assertHeap#_1255: HeapType;
  var assertMask#_1256: MaskType;
  var assertSecMask#_1257: MaskType;
  var assertCredits#_1258: CreditsType;
  var exhaleMask#_1260: MaskType;
  var exhaleHeap#_1259: HeapType;
  var exhaledHolds#_1261: RefSet;
  var k#91#355: int where true;
  var exhaleMask#_1263: MaskType;
  var exhaleHeap#_1262: HeapType;
  var exhaledHolds#_1264: RefSet;
  assume (0.0 < methodK#_1100) && ((1000.0 * methodK#_1100) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1107: Field (PMaskType) :: 
    (forall ref#_1106: ref :: 
      Heap[ref#_1106, pmask#_1107] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  predRec#_1109 := this;
  predVer#_1110 := Heap[this, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_1108) && (unfoldK#_1108 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_1108) < methodK#_1100);
  assert {:msg "  430.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  430.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  430.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTreeNode.valid)) {
    oldVers#_1115 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_1116;
    Heap[this, AVLTreeNode.valid] := newVers#_1116;
    assume oldVers#_1115 < Heap[this, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1109, AVLTreeNode.valid, predVer#_1110, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#327: int :: 
      (0 <= lk#79#327) && (lk#79#327 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#327) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1109, AVLTreeNode.valid, predVer#_1110, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#328: int :: 
      (0 <= rk#80#328) && (rk#80#328 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#328))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_1118 := Heap[this, AVLTreeNode.left] == null;
  assert {:msg "  431.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  431.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (cond#_1118) {
    // assigment to r
    assert {:msg "  432.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  432.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    r#41 := Heap[this, AVLTreeNode.right];
    // update field right
    assert {:msg "  433.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := null;
    assume wf(Heap, Mask, SecMask);
    assume (0.0 < methodCallK#_1123) && ((1000.0 * methodCallK#_1123) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1123) < methodK#_1100);
    // call close
    callHeap#_1119 := Heap;
    callMask#_1120 := Mask;
    callSecMask#_1121 := SecMask;
    callCredits#_1122 := Credits;
    assume wf(callHeap#_1119, callMask#_1120, callSecMask#_1121);
    assert {:msg "  434.4: The target of the method call might be null."} this != null;
    this#329 := this;
    // begin exhale (precondition)
    exhaleMask#_1125 := Mask;
    havoc exhaleHeap#_1124;
    exhaledHolds#_1126 := ZeroRefSet;
    if (!(Heap[this#329, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#330: int :: 
        (0 <= k#92#330) && (k#92#330 < Seq#Length(Heap[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys], k#92#330) < Heap[this#329, AVLTreeNode.key])
      );
    }
    if (!(Heap[this#329, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#331: int :: 
        (0 <= k#93#331) && (k#93#331 < Seq#Length(Heap[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#329, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys], k#93#331))
      );
    }
    assert {:msg "  434.4: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#329, AVLTreeNode.left] == null, 0, Heap[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#329, AVLTreeNode.right] == null, 0, Heap[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  434.4: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#329, AVLTreeNode.left] == null, 0, Heap[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#329, AVLTreeNode.right] == null, 0, Heap[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    assert {:msg "  434.4: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  434.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1125[this#329, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[this#329, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1125[this#329, AVLTreeNode.key][perm$N]));
    exhaleMask#_1125[this#329, AVLTreeNode.key] := exhaleMask#_1125[this#329, AVLTreeNode.key][perm$R := exhaleMask#_1125[this#329, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1125, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  434.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1125[this#329, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[this#329, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1125[this#329, AVLTreeNode.height][perm$N]));
    exhaleMask#_1125[this#329, AVLTreeNode.height] := exhaleMask#_1125[this#329, AVLTreeNode.height][perm$R := exhaleMask#_1125[this#329, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1125, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  434.4: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1125[this#329, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[this#329, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1125[this#329, AVLTreeNode.left][perm$N]));
    exhaleMask#_1125[this#329, AVLTreeNode.left] := exhaleMask#_1125[this#329, AVLTreeNode.left][perm$R := exhaleMask#_1125[this#329, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1125, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  434.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1125[this#329, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[this#329, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1125[this#329, AVLTreeNode.right][perm$N]));
    exhaleMask#_1125[this#329, AVLTreeNode.right] := exhaleMask#_1125[this#329, AVLTreeNode.right][perm$R := exhaleMask#_1125[this#329, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1125, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  434.4: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1125[this#329, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[this#329, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1125[this#329, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1125[this#329, AVLTreeNode.keys] := exhaleMask#_1125[this#329, AVLTreeNode.keys][perm$R := exhaleMask#_1125[this#329, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1125, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  434.4: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  434.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1125[this#329, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[this#329, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1125[this#329, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1125[this#329, AVLTreeNode.balanceFactor] := exhaleMask#_1125[this#329, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1125[this#329, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1125, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#329, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1125, Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1124[Heap[this#329, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.left] == null)) {
      assert {:msg "  434.4: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1125, Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1124[Heap[this#329, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#329, AVLTreeNode.right] == null)) {
      assert {:msg "  434.4: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  434.4: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1125[Heap[this#329, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1125, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1125;
    assume IsGoodExhaleState(exhaleHeap#_1124, Heap, Mask, exhaledHolds#_1126);
    Heap := exhaleHeap#_1124;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    // inhale (postcondition)
    assume this#329 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[this#329, AVLTreeNode.valid] := Mask[this#329, AVLTreeNode.valid][perm$R := Mask[this#329, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#329 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#329, AVLTreeNode.height] := Mask[this#329, AVLTreeNode.height][perm$R := Mask[this#329, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#329 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#329, AVLTreeNode.keys] := Mask[this#329, AVLTreeNode.keys][perm$R := Mask[this#329, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume this#329 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[this#329, AVLTreeNode.balanceFactor] := Mask[this#329, AVLTreeNode.balanceFactor][perm$R := Mask[this#329, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Seq#Equal(Heap[this#329, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1119[this#329, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1119[this#329, AVLTreeNode.key])), ite(callHeap#_1119[this#329, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Heap[this#329, AVLTreeNode.height] == ite(ite(callHeap#_1119[this#329, AVLTreeNode.left] == null, 0, callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1119[this#329, AVLTreeNode.right] == null, 0, callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1119[this#329, AVLTreeNode.left] == null, 0, callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1119[this#329, AVLTreeNode.right] == null, 0, callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#329, AVLTreeNode.balanceFactor] == (ite(callHeap#_1119[this#329, AVLTreeNode.left] == null, 0, callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1119[this#329, AVLTreeNode.right] == null, 0, callHeap#_1119[callHeap#_1119[this#329, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    // assigment to m
    m#42 := this;
    // assert
    assertHeap#_1144 := Heap;
    assertMask#_1145 := Mask;
    assertSecMask#_1146 := SecMask;
    assertCredits#_1147 := Credits;
    assume wf(assertHeap#_1144, assertMask#_1145, assertSecMask#_1146);
    // begin exhale (assert)
    exhaleMask#_1149 := assertMask#_1145;
    havoc exhaleHeap#_1148;
    exhaledHolds#_1150 := ZeroRefSet;
    if (!(r#41 == null)) {
      assert {:msg "  436.24: Receiver might be null."} true ==> (r#41 != null);
      assert {:msg "  436.24: Location might not be readable."} true ==> CanRead(assertMask#_1145, r#41, AVLTreeNode.height);
      assert {:msg "  436.40: Receiver might be null."} true ==> (this != null);
      assert {:msg "  436.40: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
      assert {:msg "  436.51: Receiver might be null."} true && (!(assertHeap#_1144[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
      assert {:msg "  436.51: Location might not be readable."} true && (!(assertHeap#_1144[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(assertMask#_1145, r#41, AVLTreeNode.height);
      assert {:msg "  436.67: Receiver might be null."} true && (!(assertHeap#_1144[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
      assert {:msg "  436.67: Location might not be readable."} true && (!(assertHeap#_1144[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
      assert {:msg "  436.4: Assertion might not hold. The expression at 436.24 might not evaluate to true."} (assertHeap#_1144[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (assertHeap#_1144[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
    }
    assertMask#_1145 := exhaleMask#_1149;
    assume IsGoodExhaleState(exhaleHeap#_1148, assertHeap#_1144, assertMask#_1145, exhaledHolds#_1150);
    assertHeap#_1144 := exhaleHeap#_1148;
    assume IsGoodMask(assertMask#_1145);
    assume wf(assertHeap#_1144, assertMask#_1145, assertSecMask#_1146);
    // end exhale
    // assert
    assertHeap#_1151 := Heap;
    assertMask#_1152 := Mask;
    assertSecMask#_1153 := SecMask;
    assertCredits#_1154 := Credits;
    assume wf(assertHeap#_1151, assertMask#_1152, assertSecMask#_1153);
    // begin exhale (assert)
    exhaleMask#_1156 := assertMask#_1152;
    havoc exhaleHeap#_1155;
    exhaledHolds#_1157 := ZeroRefSet;
    if (!(r#41 == null)) {
      assert {:msg "  437.11: Receiver might be null."} true && (0 <= k#90#335) ==> (r#41 != null);
      assert {:msg "  437.11: Location might not be readable."} true && (0 <= k#90#335) ==> CanRead(assertMask#_1152, r#41, AVLTreeNode.keys);
      assert {:msg "  437.45: Receiver might be null."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
      assert {:msg "  437.45: Location might not be readable."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1152, m#42, AVLTreeNode.keys);
      assert {:msg "  437.45: Sequence index might be negative."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  437.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_1151[m#42, AVLTreeNode.keys]));
      assert {:msg "  437.11: Receiver might be null."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
      assert {:msg "  437.11: Location might not be readable."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1152, r#41, AVLTreeNode.keys);
      assert {:msg "  437.57: Sequence index might be negative."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (0 <= k#90#335);
      assert {:msg "  437.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#90#335) && (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (k#90#335 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys]));
      assert {:msg "  437.4: Assertion might not hold. The expression at 437.23 might not evaluate to true."} (forall k#90#334: int :: 
        (0 <= k#90#334) && (k#90#334 < Seq#Length(assertHeap#_1151[r#41, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1151[m#42, AVLTreeNode.keys], 0) < Seq#Index(assertHeap#_1151[r#41, AVLTreeNode.keys], k#90#334))
      );
    }
    assertMask#_1152 := exhaleMask#_1156;
    assume IsGoodExhaleState(exhaleHeap#_1155, assertHeap#_1151, assertMask#_1152, exhaledHolds#_1157);
    assertHeap#_1151 := exhaleHeap#_1155;
    assume IsGoodMask(assertMask#_1152);
    assume wf(assertHeap#_1151, assertMask#_1152, assertSecMask#_1153);
    // end exhale
  } else {
    // local var nl
    assume (0.0 < methodCallK#_1162) && ((1000.0 * methodCallK#_1162) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1162) < methodK#_1100);
    // call pruneMin
    callHeap#_1158 := Heap;
    callMask#_1159 := Mask;
    callSecMask#_1160 := SecMask;
    callCredits#_1161 := Credits;
    assume wf(callHeap#_1158, callMask#_1159, callSecMask#_1160);
    assert {:msg "  440.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  440.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  440.4: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
    this#337 := Heap[this, AVLTreeNode.left];
    // begin exhale (precondition)
    exhaleMask#_1164 := Mask;
    havoc exhaleHeap#_1163;
    exhaledHolds#_1165 := ZeroRefSet;
    assert {:msg "  440.4: The precondition at 404.12 might not hold. The permission at 404.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  440.4: The precondition at 404.12 might not hold. Insufficient fraction at 404.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1164[this#337, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1164[this#337, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1164[this#337, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1164[this#337, AVLTreeNode.valid] := exhaleMask#_1164[this#337, AVLTreeNode.valid][perm$R := exhaleMask#_1164[this#337, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1164, this#337, AVLTreeNode.valid)) {
      assume Heap[this#337, AVLTreeNode.valid] < exhaleHeap#_1163[this#337, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1164, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  440.4: The precondition at 405.12 might not hold. The permission at 405.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  440.4: The precondition at 405.12 might not hold. Insufficient fraction at 405.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1164[this#337, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1164[this#337, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1164[this#337, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1164[this#337, AVLTreeNode.keys] := exhaleMask#_1164[this#337, AVLTreeNode.keys][perm$R := exhaleMask#_1164[this#337, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1164, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  440.4: The precondition at 406.12 might not hold. The permission at 406.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  440.4: The precondition at 406.12 might not hold. Insufficient fraction at 406.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1164[this#337, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1164[this#337, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1164[this#337, AVLTreeNode.height][perm$N]));
    exhaleMask#_1164[this#337, AVLTreeNode.height] := exhaleMask#_1164[this#337, AVLTreeNode.height][perm$R := exhaleMask#_1164[this#337, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1164, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  440.4: The precondition at 407.12 might not hold. The permission at 407.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  440.4: The precondition at 407.12 might not hold. Insufficient fraction at 407.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1164[this#337, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1164[this#337, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1164[this#337, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1164[this#337, AVLTreeNode.balanceFactor] := exhaleMask#_1164[this#337, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1164[this#337, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1164, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_1164;
    assume IsGoodExhaleState(exhaleHeap#_1163, Heap, Mask, exhaledHolds#_1165);
    Heap := exhaleHeap#_1163;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#338;
    havoc m#339;
    // inhale (postcondition)
    if (!(r#338 == null)) {
      assume r#338 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#338, AVLTreeNode.valid] := Mask[r#338, AVLTreeNode.valid][perm$R := Mask[r#338, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#338 == null)) {
      assume r#338 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#338, AVLTreeNode.keys] := Mask[r#338, AVLTreeNode.keys][perm$R := Mask[r#338, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#338 == null)) {
      assume r#338 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#338, AVLTreeNode.height] := Mask[r#338, AVLTreeNode.height][perm$R := Mask[r#338, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#338 == null)) {
      assume r#338 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#338, AVLTreeNode.balanceFactor] := Mask[r#338, AVLTreeNode.balanceFactor][perm$R := Mask[r#338, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(r#338 == null)) {
      assume (Heap[r#338, AVLTreeNode.height] == callHeap#_1158[this#337, AVLTreeNode.height]) || (Heap[r#338, AVLTreeNode.height] == (callHeap#_1158[this#337, AVLTreeNode.height] - 1));
    }
    if (!(r#338 == null)) {
      assume (Seq#Length(Heap[r#338, AVLTreeNode.keys]) + 1) == Seq#Length(callHeap#_1158[this#337, AVLTreeNode.keys]);
    }
    if (callHeap#_1158[this#337, AVLTreeNode.height] > 1) {
      assume !(r#338 == null);
    }
    if (callHeap#_1158[this#337, AVLTreeNode.height] == 1) {
      assume r#338 == null;
    }
    assume (callHeap#_1158[this#337, AVLTreeNode.height] == ite(r#338 == null, 0, Heap[r#338, AVLTreeNode.height])) || (callHeap#_1158[this#337, AVLTreeNode.height] == (ite(r#338 == null, 0, Heap[r#338, AVLTreeNode.height]) + 1));
    assume !(m#339 == null);
    assume m#339 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[m#339, AVLTreeNode.valid] := Mask[m#339, AVLTreeNode.valid][perm$R := Mask[m#339, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#339 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[m#339, AVLTreeNode.keys] := Mask[m#339, AVLTreeNode.keys][perm$R := Mask[m#339, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#339 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[m#339, AVLTreeNode.height] := Mask[m#339, AVLTreeNode.height][perm$R := Mask[m#339, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume m#339 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[m#339, AVLTreeNode.balanceFactor] := Mask[m#339, AVLTreeNode.balanceFactor][perm$R := Mask[m#339, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[m#339, AVLTreeNode.height] == 1;
    assume Seq#Length(Heap[m#339, AVLTreeNode.keys]) == 1;
    assume Seq#Equal(Seq#Append(Heap[m#339, AVLTreeNode.keys], ite(r#338 == null, Seq#Empty(), Heap[r#338, AVLTreeNode.keys])), callHeap#_1158[this#337, AVLTreeNode.keys]);
    if (!(r#338 == null)) {
      assume (forall k#89#340: int :: 
        (0 <= k#89#340) && (k#89#340 < Seq#Length(Heap[r#338, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#339, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#338, AVLTreeNode.keys], k#89#340))
      );
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    nl#44 := r#338;
    m#42 := m#339;
    // update field left
    assert {:msg "  441.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := nl#44;
    assume wf(Heap, Mask, SecMask);
    // local var bf
    assume (0.0 < methodCallK#_1177) && ((1000.0 * methodCallK#_1177) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1177) < methodK#_1100);
    // call getBalanceFactorI
    callHeap#_1173 := Heap;
    callMask#_1174 := Mask;
    callSecMask#_1175 := SecMask;
    callCredits#_1176 := Credits;
    assume wf(callHeap#_1173, callMask#_1174, callSecMask#_1175);
    assert {:msg "  443.4: The target of the method call might be null."} this != null;
    this#341 := this;
    // begin exhale (precondition)
    exhaleMask#_1179 := Mask;
    havoc exhaleHeap#_1178;
    exhaledHolds#_1180 := ZeroRefSet;
    assert {:msg "  443.4: The precondition at 511.12 might not hold. The permission at 511.12 might not be positive."} methodCallK#_1177 > 0.0;
    assert {:msg "  443.4: The precondition at 511.12 might not hold. Insufficient fraction at 511.12 for AVLTreeNode.left."} exhaleMask#_1179[this#341, AVLTreeNode.left][perm$R] > 0.0;
    assume methodCallK#_1177 < exhaleMask#_1179[this#341, AVLTreeNode.left][perm$R];
    exhaleMask#_1179[this#341, AVLTreeNode.left] := exhaleMask#_1179[this#341, AVLTreeNode.left][perm$R := exhaleMask#_1179[this#341, AVLTreeNode.left][perm$R] - methodCallK#_1177];
    assume wf(Heap, exhaleMask#_1179, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#341, AVLTreeNode.left] == null)) {
      assert {:msg "  443.4: The precondition at 513.12 might not hold. The permission at 513.27 might not be positive."} methodCallK#_1177 > 0.0;
      assert {:msg "  443.4: The precondition at 513.12 might not hold. Insufficient fraction at 513.27 for AVLTreeNode.height."} exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R] > 0.0;
      assume methodCallK#_1177 < exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R];
      exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodCallK#_1177];
      assume wf(Heap, exhaleMask#_1179, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  443.4: The precondition at 515.12 might not hold. The permission at 515.12 might not be positive."} methodCallK#_1177 > 0.0;
    assert {:msg "  443.4: The precondition at 515.12 might not hold. Insufficient fraction at 515.12 for AVLTreeNode.right."} exhaleMask#_1179[this#341, AVLTreeNode.right][perm$R] > 0.0;
    assume methodCallK#_1177 < exhaleMask#_1179[this#341, AVLTreeNode.right][perm$R];
    exhaleMask#_1179[this#341, AVLTreeNode.right] := exhaleMask#_1179[this#341, AVLTreeNode.right][perm$R := exhaleMask#_1179[this#341, AVLTreeNode.right][perm$R] - methodCallK#_1177];
    assume wf(Heap, exhaleMask#_1179, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#341, AVLTreeNode.right] == null)) {
      assert {:msg "  443.4: The precondition at 517.12 might not hold. The permission at 517.28 might not be positive."} methodCallK#_1177 > 0.0;
      assert {:msg "  443.4: The precondition at 517.12 might not hold. Insufficient fraction at 517.28 for AVLTreeNode.height."} exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R] > 0.0;
      assume methodCallK#_1177 < exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R];
      exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodCallK#_1177];
      assume wf(Heap, exhaleMask#_1179, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#341, AVLTreeNode.left] == null)) {
      assert {:msg "  443.4: The precondition at 512.12 might not hold. The permission at 512.27 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  443.4: The precondition at 512.12 might not hold. Insufficient fraction at 512.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1179[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1179, Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1178[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1179, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#341, AVLTreeNode.right] == null)) {
      assert {:msg "  443.4: The precondition at 516.12 might not hold. The permission at 516.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  443.4: The precondition at 516.12 might not hold. Insufficient fraction at 516.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1179[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1179, Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1178[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1179, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1179;
    assume IsGoodExhaleState(exhaleHeap#_1178, Heap, Mask, exhaledHolds#_1180);
    Heap := exhaleHeap#_1178;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc bf#342;
    // inhale (postcondition)
    assume this#341 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#341, AVLTreeNode.left] == null) || (dtype(Heap[this#341, AVLTreeNode.left]) == AVLTreeNode#t);
    assume methodCallK#_1177 > 0.0;
    Mask[this#341, AVLTreeNode.left] := Mask[this#341, AVLTreeNode.left][perm$R := Mask[this#341, AVLTreeNode.left][perm$R] + methodCallK#_1177];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#341, AVLTreeNode.left] == null)) {
      assume Heap[this#341, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#341, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#341, AVLTreeNode.left] == null)) {
      assume Heap[this#341, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_1177 > 0.0;
      Mask[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodCallK#_1177];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume this#341 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[this#341, AVLTreeNode.right] == null) || (dtype(Heap[this#341, AVLTreeNode.right]) == AVLTreeNode#t);
    assume methodCallK#_1177 > 0.0;
    Mask[this#341, AVLTreeNode.right] := Mask[this#341, AVLTreeNode.right][perm$R := Mask[this#341, AVLTreeNode.right][perm$R] + methodCallK#_1177];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#341, AVLTreeNode.right] == null)) {
      assume Heap[this#341, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#341, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#341, AVLTreeNode.right] == null)) {
      assume Heap[this#341, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume methodCallK#_1177 > 0.0;
      Mask[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodCallK#_1177];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assume bf#342 == (ite(Heap[this#341, AVLTreeNode.left] == null, 0, Heap[Heap[this#341, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#341, AVLTreeNode.right] == null, 0, Heap[Heap[this#341, AVLTreeNode.right], AVLTreeNode.height]));
    if (bf#342 > 0) {
      assume !(Heap[this#341, AVLTreeNode.left] == null);
    }
    if (bf#342 < 0) {
      assume !(Heap[this#341, AVLTreeNode.right] == null);
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    bf#46 := bf#342;
    // if
    cond#_1190 := bf#46 == (0 - 2);
    if (cond#_1190) {
      assume (0.0 < methodCallK#_1195) && ((1000.0 * methodCallK#_1195) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1195) < methodK#_1100);
      // call rebalanceRight
      callHeap#_1191 := Heap;
      callMask#_1192 := Mask;
      callSecMask#_1193 := SecMask;
      callCredits#_1194 := Credits;
      assume wf(callHeap#_1191, callMask#_1192, callSecMask#_1193);
      assert {:msg "  445.5: The target of the method call might be null."} this != null;
      this#343 := this;
      // begin exhale (precondition)
      exhaleMask#_1197 := Mask;
      havoc exhaleHeap#_1196;
      exhaledHolds#_1198 := ZeroRefSet;
      if (!(Heap[this#343, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 758.12 might not hold. The expression at 758.25 might not evaluate to true."} (forall k#104#345: int :: 
          (0 <= k#104#345) && (k#104#345 < Seq#Length(Heap[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys], k#104#345) < Heap[this#343, AVLTreeNode.key])
        );
      }
      assert {:msg "  445.5: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} !(Heap[this#343, AVLTreeNode.right] == null);
      assert {:msg "  445.5: The precondition at 765.12 might not hold. The expression at 765.12 might not evaluate to true."} (forall k#105#346: int :: 
        (0 <= k#105#346) && (k#105#346 < Seq#Length(Heap[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#343, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys], k#105#346))
      );
      assert {:msg "  445.5: The precondition at 768.12 might not hold. The expression at 768.12 might not evaluate to true."} (ite(Heap[this#343, AVLTreeNode.left] == null, 0, Heap[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
      assert {:msg "  445.5: The precondition at 746.12 might not hold. The permission at 746.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1197[this#343, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[this#343, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1197[this#343, AVLTreeNode.key][perm$N]));
      exhaleMask#_1197[this#343, AVLTreeNode.key] := exhaleMask#_1197[this#343, AVLTreeNode.key][perm$R := exhaleMask#_1197[this#343, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 747.12 might not hold. The permission at 747.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1197[this#343, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[this#343, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1197[this#343, AVLTreeNode.height][perm$N]));
      exhaleMask#_1197[this#343, AVLTreeNode.height] := exhaleMask#_1197[this#343, AVLTreeNode.height][perm$R := exhaleMask#_1197[this#343, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 748.12 might not hold. The permission at 748.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 748.12 might not hold. Insufficient fraction at 748.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1197[this#343, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[this#343, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1197[this#343, AVLTreeNode.left][perm$N]));
      exhaleMask#_1197[this#343, AVLTreeNode.left] := exhaleMask#_1197[this#343, AVLTreeNode.left][perm$R := exhaleMask#_1197[this#343, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 749.12 might not hold. The permission at 749.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 749.12 might not hold. Insufficient fraction at 749.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1197[this#343, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[this#343, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1197[this#343, AVLTreeNode.right][perm$N]));
      exhaleMask#_1197[this#343, AVLTreeNode.right] := exhaleMask#_1197[this#343, AVLTreeNode.right][perm$R := exhaleMask#_1197[this#343, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 751.12 might not hold. The permission at 751.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 751.12 might not hold. Insufficient fraction at 751.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1197[this#343, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[this#343, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1197[this#343, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1197[this#343, AVLTreeNode.keys] := exhaleMask#_1197[this#343, AVLTreeNode.keys][perm$R := exhaleMask#_1197[this#343, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 752.12 might not hold. The permission at 752.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 752.12 might not hold. Insufficient fraction at 752.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1197[this#343, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[this#343, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1197[this#343, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1197[this#343, AVLTreeNode.balanceFactor] := exhaleMask#_1197[this#343, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1197[this#343, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#343, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 754.12 might not hold. The permission at 754.25 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  445.5: The precondition at 754.12 might not hold. Insufficient fraction at 754.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1197, Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1196[Heap[this#343, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1197, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#343, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 755.12 might not hold. The permission at 755.25 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  445.5: The precondition at 755.12 might not hold. Insufficient fraction at 755.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1197, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#343, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 756.12 might not hold. The permission at 756.25 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  445.5: The precondition at 756.12 might not hold. Insufficient fraction at 756.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1197, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#343, AVLTreeNode.left] == null)) {
        assert {:msg "  445.5: The precondition at 757.12 might not hold. The permission at 757.25 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  445.5: The precondition at 757.12 might not hold. Insufficient fraction at 757.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1197, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      assert {:msg "  445.5: The precondition at 761.12 might not hold. The permission at 761.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 761.12 might not hold. Insufficient fraction at 761.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1197, Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1196[Heap[this#343, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 762.12 might not hold. The permission at 762.12 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 762.12 might not hold. Insufficient fraction at 762.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 763.12 might not hold. The permission at 763.12 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 763.12 might not hold. Insufficient fraction at 763.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  445.5: The precondition at 764.12 might not hold. The permission at 764.12 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  445.5: The precondition at 764.12 might not hold. Insufficient fraction at 764.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1197[Heap[this#343, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1197, SecMask);
      assume wf(Heap, Mask, SecMask);
      Mask := exhaleMask#_1197;
      assume IsGoodExhaleState(exhaleHeap#_1196, Heap, Mask, exhaledHolds#_1198);
      Heap := exhaleHeap#_1196;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      havoc r#344;
      // inhale (postcondition)
      assume !(r#344 == null);
      assume r#344 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[r#344, AVLTreeNode.valid] := Mask[r#344, AVLTreeNode.valid][perm$R := Mask[r#344, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#344 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#344, AVLTreeNode.height] := Mask[r#344, AVLTreeNode.height][perm$R := Mask[r#344, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#344 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#344, AVLTreeNode.keys] := Mask[r#344, AVLTreeNode.keys][perm$R := Mask[r#344, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume r#344 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[r#344, AVLTreeNode.balanceFactor] := Mask[r#344, AVLTreeNode.balanceFactor][perm$R := Mask[r#344, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume (Heap[r#344, AVLTreeNode.height] == callHeap#_1191[callHeap#_1191[this#343, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#344, AVLTreeNode.height] == (callHeap#_1191[callHeap#_1191[this#343, AVLTreeNode.right], AVLTreeNode.height] + 1));
      assume Seq#Equal(Heap[r#344, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1191[this#343, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1191[callHeap#_1191[this#343, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1191[this#343, AVLTreeNode.key])), callHeap#_1191[callHeap#_1191[this#343, AVLTreeNode.right], AVLTreeNode.keys]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      r#41 := r#344;
      // assert
      assertHeap#_1216 := Heap;
      assertMask#_1217 := Mask;
      assertSecMask#_1218 := SecMask;
      assertCredits#_1219 := Credits;
      assume wf(assertHeap#_1216, assertMask#_1217, assertSecMask#_1218);
      // begin exhale (assert)
      exhaleMask#_1221 := assertMask#_1217;
      havoc exhaleHeap#_1220;
      exhaledHolds#_1222 := ZeroRefSet;
      if (!(r#41 == null)) {
        assert {:msg "  446.27: Receiver might be null."} true ==> (r#41 != null);
        assert {:msg "  446.27: Location might not be readable."} true ==> CanRead(assertMask#_1217, r#41, AVLTreeNode.height);
        assert {:msg "  446.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  446.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  446.54: Receiver might be null."} true && (!(assertHeap#_1216[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
        assert {:msg "  446.54: Location might not be readable."} true && (!(assertHeap#_1216[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(assertMask#_1217, r#41, AVLTreeNode.height);
        assert {:msg "  446.70: Receiver might be null."} true && (!(assertHeap#_1216[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
        assert {:msg "  446.70: Location might not be readable."} true && (!(assertHeap#_1216[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  446.5: Assertion might not hold. The expression at 446.27 might not evaluate to true."} (assertHeap#_1216[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (assertHeap#_1216[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
      }
      assertMask#_1217 := exhaleMask#_1221;
      assume IsGoodExhaleState(exhaleHeap#_1220, assertHeap#_1216, assertMask#_1217, exhaledHolds#_1222);
      assertHeap#_1216 := exhaleHeap#_1220;
      assume IsGoodMask(assertMask#_1217);
      assume wf(assertHeap#_1216, assertMask#_1217, assertSecMask#_1218);
      // end exhale
    } else {
      assume (0.0 < methodCallK#_1227) && ((1000.0 * methodCallK#_1227) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1227) < methodK#_1100);
      // call close
      callHeap#_1223 := Heap;
      callMask#_1224 := Mask;
      callSecMask#_1225 := SecMask;
      callCredits#_1226 := Credits;
      assume wf(callHeap#_1223, callMask#_1224, callSecMask#_1225);
      assert {:msg "  448.5: The target of the method call might be null."} this != null;
      this#349 := this;
      // begin exhale (precondition)
      exhaleMask#_1229 := Mask;
      havoc exhaleHeap#_1228;
      exhaledHolds#_1230 := ZeroRefSet;
      if (!(Heap[this#349, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#350: int :: 
          (0 <= k#92#350) && (k#92#350 < Seq#Length(Heap[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys], k#92#350) < Heap[this#349, AVLTreeNode.key])
        );
      }
      if (!(Heap[this#349, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#351: int :: 
          (0 <= k#93#351) && (k#93#351 < Seq#Length(Heap[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#349, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys], k#93#351))
        );
      }
      assert {:msg "  448.5: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#349, AVLTreeNode.left] == null, 0, Heap[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#349, AVLTreeNode.right] == null, 0, Heap[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  448.5: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#349, AVLTreeNode.left] == null, 0, Heap[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#349, AVLTreeNode.right] == null, 0, Heap[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      assert {:msg "  448.5: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  448.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1229[this#349, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[this#349, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1229[this#349, AVLTreeNode.key][perm$N]));
      exhaleMask#_1229[this#349, AVLTreeNode.key] := exhaleMask#_1229[this#349, AVLTreeNode.key][perm$R := exhaleMask#_1229[this#349, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1229, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  448.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1229[this#349, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[this#349, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1229[this#349, AVLTreeNode.height][perm$N]));
      exhaleMask#_1229[this#349, AVLTreeNode.height] := exhaleMask#_1229[this#349, AVLTreeNode.height][perm$R := exhaleMask#_1229[this#349, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1229, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  448.5: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1229[this#349, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[this#349, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1229[this#349, AVLTreeNode.left][perm$N]));
      exhaleMask#_1229[this#349, AVLTreeNode.left] := exhaleMask#_1229[this#349, AVLTreeNode.left][perm$R := exhaleMask#_1229[this#349, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1229, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  448.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1229[this#349, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[this#349, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1229[this#349, AVLTreeNode.right][perm$N]));
      exhaleMask#_1229[this#349, AVLTreeNode.right] := exhaleMask#_1229[this#349, AVLTreeNode.right][perm$R := exhaleMask#_1229[this#349, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1229, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  448.5: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1229[this#349, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[this#349, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1229[this#349, AVLTreeNode.keys][perm$N]));
      exhaleMask#_1229[this#349, AVLTreeNode.keys] := exhaleMask#_1229[this#349, AVLTreeNode.keys][perm$R := exhaleMask#_1229[this#349, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1229, SecMask);
      assume wf(Heap, Mask, SecMask);
      assert {:msg "  448.5: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  448.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1229[this#349, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[this#349, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1229[this#349, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1229[this#349, AVLTreeNode.balanceFactor] := exhaleMask#_1229[this#349, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1229[this#349, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
      assume wf(Heap, exhaleMask#_1229, SecMask);
      assume wf(Heap, Mask, SecMask);
      if (!(Heap[this#349, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1229, Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid)) {
          assume Heap[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1228[Heap[this#349, AVLTreeNode.left], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.left] == null)) {
        assert {:msg "  448.5: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1229, Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid)) {
          assume Heap[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1228[Heap[this#349, AVLTreeNode.right], AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      if (!(Heap[this#349, AVLTreeNode.right] == null)) {
        assert {:msg "  448.5: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
        assert {:msg "  448.5: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1229[Heap[this#349, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
        assume wf(Heap, exhaleMask#_1229, SecMask);
        assume wf(Heap, Mask, SecMask);
      }
      Mask := exhaleMask#_1229;
      assume IsGoodExhaleState(exhaleHeap#_1228, Heap, Mask, exhaledHolds#_1230);
      Heap := exhaleHeap#_1228;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end exhale
      // inhale (postcondition)
      assume this#349 != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      Mask[this#349, AVLTreeNode.valid] := Mask[this#349, AVLTreeNode.valid][perm$R := Mask[this#349, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#349 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#349, AVLTreeNode.height] := Mask[this#349, AVLTreeNode.height][perm$R := Mask[this#349, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#349 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#349, AVLTreeNode.keys] := Mask[this#349, AVLTreeNode.keys][perm$R := Mask[this#349, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume this#349 != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      Mask[this#349, AVLTreeNode.balanceFactor] := Mask[this#349, AVLTreeNode.balanceFactor][perm$R := Mask[this#349, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
      assume Seq#Equal(Heap[this#349, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1223[this#349, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1223[this#349, AVLTreeNode.key])), ite(callHeap#_1223[this#349, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Heap[this#349, AVLTreeNode.height] == ite(ite(callHeap#_1223[this#349, AVLTreeNode.left] == null, 0, callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1223[this#349, AVLTreeNode.right] == null, 0, callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1223[this#349, AVLTreeNode.left] == null, 0, callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1223[this#349, AVLTreeNode.right] == null, 0, callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#349, AVLTreeNode.balanceFactor] == (ite(callHeap#_1223[this#349, AVLTreeNode.left] == null, 0, callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1223[this#349, AVLTreeNode.right] == null, 0, callHeap#_1223[callHeap#_1223[this#349, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      // end inhale
      // assigment to r
      r#41 := this;
      // assert
      assertHeap#_1248 := Heap;
      assertMask#_1249 := Mask;
      assertSecMask#_1250 := SecMask;
      assertCredits#_1251 := Credits;
      assume wf(assertHeap#_1248, assertMask#_1249, assertSecMask#_1250);
      // begin exhale (assert)
      exhaleMask#_1253 := assertMask#_1249;
      havoc exhaleHeap#_1252;
      exhaledHolds#_1254 := ZeroRefSet;
      if (!(r#41 == null)) {
        assert {:msg "  450.27: Receiver might be null."} true ==> (r#41 != null);
        assert {:msg "  450.27: Location might not be readable."} true ==> CanRead(assertMask#_1249, r#41, AVLTreeNode.height);
        assert {:msg "  450.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  450.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  450.54: Receiver might be null."} true && (!(assertHeap#_1248[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
        assert {:msg "  450.54: Location might not be readable."} true && (!(assertHeap#_1248[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(assertMask#_1249, r#41, AVLTreeNode.height);
        assert {:msg "  450.70: Receiver might be null."} true && (!(assertHeap#_1248[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
        assert {:msg "  450.70: Location might not be readable."} true && (!(assertHeap#_1248[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  450.5: Assertion might not hold. The expression at 450.27 might not evaluate to true."} (assertHeap#_1248[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (assertHeap#_1248[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
      }
      assertMask#_1249 := exhaleMask#_1253;
      assume IsGoodExhaleState(exhaleHeap#_1252, assertHeap#_1248, assertMask#_1249, exhaledHolds#_1254);
      assertHeap#_1248 := exhaleHeap#_1252;
      assume IsGoodMask(assertMask#_1249);
      assume wf(assertHeap#_1248, assertMask#_1249, assertSecMask#_1250);
      // end exhale
    }
    // assert
    assertHeap#_1255 := Heap;
    assertMask#_1256 := Mask;
    assertSecMask#_1257 := SecMask;
    assertCredits#_1258 := Credits;
    assume wf(assertHeap#_1255, assertMask#_1256, assertSecMask#_1257);
    // begin exhale (assert)
    exhaleMask#_1260 := assertMask#_1256;
    havoc exhaleHeap#_1259;
    exhaledHolds#_1261 := ZeroRefSet;
    if (!(r#41 == null)) {
      assert {:msg "  452.11: Receiver might be null."} true && (0 <= k#91#355) ==> (r#41 != null);
      assert {:msg "  452.11: Location might not be readable."} true && (0 <= k#91#355) ==> CanRead(assertMask#_1256, r#41, AVLTreeNode.keys);
      assert {:msg "  452.45: Receiver might be null."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
      assert {:msg "  452.45: Location might not be readable."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1256, m#42, AVLTreeNode.keys);
      assert {:msg "  452.45: Sequence index might be negative."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  452.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(assertHeap#_1255[m#42, AVLTreeNode.keys]));
      assert {:msg "  452.11: Receiver might be null."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
      assert {:msg "  452.11: Location might not be readable."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> CanRead(assertMask#_1256, r#41, AVLTreeNode.keys);
      assert {:msg "  452.57: Sequence index might be negative."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (0 <= k#91#355);
      assert {:msg "  452.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#91#355) && (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (k#91#355 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys]));
      assert {:msg "  452.4: Assertion might not hold. The expression at 452.23 might not evaluate to true."} (forall k#91#354: int :: 
        (0 <= k#91#354) && (k#91#354 < Seq#Length(assertHeap#_1255[r#41, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1255[m#42, AVLTreeNode.keys], 0) < Seq#Index(assertHeap#_1255[r#41, AVLTreeNode.keys], k#91#354))
      );
    }
    assertMask#_1256 := exhaleMask#_1260;
    assume IsGoodExhaleState(exhaleHeap#_1259, assertHeap#_1255, assertMask#_1256, exhaledHolds#_1261);
    assertHeap#_1255 := exhaleHeap#_1259;
    assume IsGoodMask(assertMask#_1256);
    assume wf(assertHeap#_1255, assertMask#_1256, assertSecMask#_1257);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_1263 := Mask;
  havoc exhaleHeap#_1262;
  exhaledHolds#_1264 := ZeroRefSet;
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 413.11 might not hold. The expression at 413.26 might not evaluate to true."} (Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 414.11 might not hold. The expression at 414.24 might not evaluate to true."} (Seq#Length(Heap[r#41, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  403.2: The postcondition at 415.11 might not hold. The expression at 415.30 might not evaluate to true."} !(r#41 == null);
  }
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assert {:msg "  403.2: The postcondition at 416.11 might not hold. The expression at 416.30 might not evaluate to true."} r#41 == null;
  }
  assert {:msg "  403.2: The postcondition at 417.11 might not hold. The expression at 417.11 might not evaluate to true."} (old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]) + 1));
  assert {:msg "  403.2: The postcondition at 419.11 might not hold. The expression at 419.11 might not evaluate to true."} !(m#42 == null);
  assert {:msg "  403.2: The postcondition at 424.11 might not hold. The expression at 424.11 might not evaluate to true."} Heap[m#42, AVLTreeNode.height] == 1;
  assert {:msg "  403.2: The postcondition at 425.11 might not hold. The expression at 425.11 might not evaluate to true."} Seq#Length(Heap[m#42, AVLTreeNode.keys]) == 1;
  assert {:msg "  403.2: The postcondition at 427.11 might not hold. The expression at 427.11 might not evaluate to true."} Seq#Equal(Seq#Append(Heap[m#42, AVLTreeNode.keys], ite(r#41 == null, Seq#Empty(), Heap[r#41, AVLTreeNode.keys])), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 428.11 might not hold. The expression at 428.23 might not evaluate to true."} (forall k#89#357: int :: 
      (0 <= k#89#357) && (k#89#357 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#41, AVLTreeNode.keys], k#89#357))
    );
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 409.11 might not hold. The permission at 409.25 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  403.2: The postcondition at 409.11 might not hold. Insufficient fraction at 409.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1263[r#41, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1263[r#41, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1263[r#41, AVLTreeNode.valid][perm$N]));
    exhaleMask#_1263[r#41, AVLTreeNode.valid] := exhaleMask#_1263[r#41, AVLTreeNode.valid][perm$R := exhaleMask#_1263[r#41, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1263, r#41, AVLTreeNode.valid)) {
      assume Heap[r#41, AVLTreeNode.valid] < exhaleHeap#_1262[r#41, AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 410.11 might not hold. The permission at 410.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  403.2: The postcondition at 410.11 might not hold. Insufficient fraction at 410.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1263[r#41, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1263[r#41, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1263[r#41, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1263[r#41, AVLTreeNode.keys] := exhaleMask#_1263[r#41, AVLTreeNode.keys][perm$R := exhaleMask#_1263[r#41, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 411.11 might not hold. The permission at 411.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  403.2: The postcondition at 411.11 might not hold. Insufficient fraction at 411.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1263[r#41, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1263[r#41, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1263[r#41, AVLTreeNode.height][perm$N]));
    exhaleMask#_1263[r#41, AVLTreeNode.height] := exhaleMask#_1263[r#41, AVLTreeNode.height][perm$R := exhaleMask#_1263[r#41, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(r#41 == null)) {
    assert {:msg "  403.2: The postcondition at 412.11 might not hold. The permission at 412.25 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  403.2: The postcondition at 412.11 might not hold. Insufficient fraction at 412.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1263[r#41, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1263[r#41, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1263[r#41, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1263[r#41, AVLTreeNode.balanceFactor] := exhaleMask#_1263[r#41, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1263[r#41, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1263, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  403.2: The postcondition at 420.11 might not hold. The permission at 420.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  403.2: The postcondition at 420.11 might not hold. Insufficient fraction at 420.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1263[m#42, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1263[m#42, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1263[m#42, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1263[m#42, AVLTreeNode.valid] := exhaleMask#_1263[m#42, AVLTreeNode.valid][perm$R := exhaleMask#_1263[m#42, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1263, m#42, AVLTreeNode.valid)) {
    assume Heap[m#42, AVLTreeNode.valid] < exhaleHeap#_1262[m#42, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  403.2: The postcondition at 421.11 might not hold. The permission at 421.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  403.2: The postcondition at 421.11 might not hold. Insufficient fraction at 421.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1263[m#42, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1263[m#42, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1263[m#42, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1263[m#42, AVLTreeNode.keys] := exhaleMask#_1263[m#42, AVLTreeNode.keys][perm$R := exhaleMask#_1263[m#42, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  403.2: The postcondition at 422.11 might not hold. The permission at 422.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  403.2: The postcondition at 422.11 might not hold. Insufficient fraction at 422.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1263[m#42, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1263[m#42, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1263[m#42, AVLTreeNode.height][perm$N]));
  exhaleMask#_1263[m#42, AVLTreeNode.height] := exhaleMask#_1263[m#42, AVLTreeNode.height][perm$R := exhaleMask#_1263[m#42, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1263, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  403.2: The postcondition at 423.11 might not hold. The permission at 423.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  403.2: The postcondition at 423.11 might not hold. Insufficient fraction at 423.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1263[m#42, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1263[m#42, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1263[m#42, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1263[m#42, AVLTreeNode.balanceFactor] := exhaleMask#_1263[m#42, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1263[m#42, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1263, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1263;
  assume IsGoodExhaleState(exhaleHeap#_1262, Heap, Mask, exhaledHolds#_1264);
  Heap := exhaleHeap#_1262;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  403.2: Method might lock/unlock more than allowed."} (forall lk#_1273: ref :: 
    { Heap[lk#_1273, held] }
    { Heap[lk#_1273, rdheld] }
    (((0 < Heap[lk#_1273, held]) == (0 < old(Heap)[lk#_1273, held])) && (Heap[lk#_1273, rdheld] == old(Heap)[lk#_1273, rdheld])) || false
  );
  assert {:msg "  403.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.has
// -------------------------------------------

// definedness check for method AVLTreeNode.has
procedure AVLTreeNode.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1274: real;
  assume (0.0 < methodK#_1274) && ((1000.0 * methodK#_1274) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  457.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1274 > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + methodK#_1274];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1277: Field (PMaskType) :: 
    (forall ref#_1276: ref :: 
      Heap[ref#_1276, pmask#_1277] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  460.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1274 > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + methodK#_1274];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  462.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  462.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume b#48 == Seq#Contains(Heap[this, AVLTreeNode.keys], k#47);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.has
procedure AVLTreeNode.has(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1274: real;
  var predRec#_1283: ref;
  var predVer#_1284: int;
  var unfoldK#_1282: real;
  var oldVers#_1289: int;
  var newVers#_1290: int;
  var cond#_1292: bool;
  var assertHeap#_1293: HeapType;
  var assertMask#_1294: MaskType;
  var assertSecMask#_1295: MaskType;
  var assertCredits#_1296: CreditsType;
  var exhaleMask#_1298: MaskType;
  var exhaleHeap#_1297: HeapType;
  var exhaledHolds#_1299: RefSet;
  var cond#_1300: bool;
  var cond#_1301: bool;
  var methodCallK#_1306: real;
  var this#361: ref where (this#361 == null) || (dtype(this#361) == AVLTreeNode#t);
  var k#362: int where true;
  var b#363: bool where true;
  var callHeap#_1302: HeapType;
  var callMask#_1303: MaskType;
  var callSecMask#_1304: MaskType;
  var callCredits#_1305: CreditsType;
  var exhaleMask#_1308: MaskType;
  var exhaleHeap#_1307: HeapType;
  var exhaledHolds#_1309: RefSet;
  var isHeld#_1312: int;
  var isRdHeld#_1313: bool;
  var cond#_1315: bool;
  var methodCallK#_1320: real;
  var this#364: ref where (this#364 == null) || (dtype(this#364) == AVLTreeNode#t);
  var k#365: int where true;
  var b#366: bool where true;
  var callHeap#_1316: HeapType;
  var callMask#_1317: MaskType;
  var callSecMask#_1318: MaskType;
  var callCredits#_1319: CreditsType;
  var exhaleMask#_1322: MaskType;
  var exhaleHeap#_1321: HeapType;
  var exhaledHolds#_1323: RefSet;
  var isHeld#_1326: int;
  var isRdHeld#_1327: bool;
  var foldK#_1332: real;
  var predRec#_1329: ref;
  var predVer#_1330: int;
  var predFlag#_1331: bool;
  var newPredicateMask#_1353: PMaskType;
  var newPredicateMask#_1356: PMaskType;
  var exhaleMask#_1358: MaskType;
  var exhaleHeap#_1357: HeapType;
  var exhaledHolds#_1359: RefSet;
  assume (0.0 < methodK#_1274) && ((1000.0 * methodK#_1274) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1274 > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + methodK#_1274];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1281: Field (PMaskType) :: 
    (forall ref#_1280: ref :: 
      Heap[ref#_1280, pmask#_1281] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  predRec#_1283 := this;
  predVer#_1284 := Heap[this, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_1282) && (unfoldK#_1282 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_1282) < methodK#_1274);
  assert {:msg "  464.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  464.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  464.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTreeNode.valid)) {
    oldVers#_1289 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_1290;
    Heap[this, AVLTreeNode.valid] := newVers#_1290;
    assume oldVers#_1289 < Heap[this, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1283, AVLTreeNode.valid, predVer#_1284, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#359: int :: 
      (0 <= lk#79#359) && (lk#79#359 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#359) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1283, AVLTreeNode.valid, predVer#_1284, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#360: int :: 
      (0 <= rk#80#360) && (rk#80#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#360))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // if
  cond#_1292 := k#47 == Heap[this, AVLTreeNode.key];
  assert {:msg "  465.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  465.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (cond#_1292) {
    // assigment to b
    b#48 := true;
    // assert
    assertHeap#_1293 := Heap;
    assertMask#_1294 := Mask;
    assertSecMask#_1295 := SecMask;
    assertCredits#_1296 := Credits;
    assume wf(assertHeap#_1293, assertMask#_1294, assertSecMask#_1295);
    // begin exhale (assert)
    exhaleMask#_1298 := assertMask#_1294;
    havoc exhaleHeap#_1297;
    exhaledHolds#_1299 := ZeroRefSet;
    assert {:msg "  467.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  467.12: Location might not be readable."} true ==> CanRead(assertMask#_1294, this, AVLTreeNode.key);
    assert {:msg "  467.11: Sequence index might be negative."} true ==> (0 <= 0);
    assert {:msg "  467.11: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(assertHeap#_1293[this, AVLTreeNode.key])));
    assert {:msg "  467.4: Assertion might not hold. The expression at 467.11 might not evaluate to true."} Seq#Index(Seq#Singleton(assertHeap#_1293[this, AVLTreeNode.key]), 0) == k#47;
    assertMask#_1294 := exhaleMask#_1298;
    assume IsGoodExhaleState(exhaleHeap#_1297, assertHeap#_1293, assertMask#_1294, exhaledHolds#_1299);
    assertHeap#_1293 := exhaleHeap#_1297;
    assume IsGoodMask(assertMask#_1294);
    assume wf(assertHeap#_1293, assertMask#_1294, assertSecMask#_1295);
    // end exhale
  } else {
    // if
    cond#_1300 := k#47 < Heap[this, AVLTreeNode.key];
    assert {:msg "  469.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  469.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (cond#_1300) {
      // if
      cond#_1301 := !(Heap[this, AVLTreeNode.left] == null);
      assert {:msg "  470.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  470.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (cond#_1301) {
        assume (0.0 < methodCallK#_1306) && ((1000.0 * methodCallK#_1306) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1306) < methodK#_1274);
        // call has
        callHeap#_1302 := Heap;
        callMask#_1303 := Mask;
        callSecMask#_1304 := SecMask;
        callCredits#_1305 := Credits;
        assume wf(callHeap#_1302, callMask#_1303, callSecMask#_1304);
        assert {:msg "  471.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  471.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  471.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#361 := Heap[this, AVLTreeNode.left];
        k#362 := k#47;
        // begin exhale (precondition)
        exhaleMask#_1308 := Mask;
        havoc exhaleHeap#_1307;
        exhaledHolds#_1309 := ZeroRefSet;
        assert {:msg "  471.6: The precondition at 458.12 might not hold. The permission at 458.12 might not be positive."} methodCallK#_1306 > 0.0;
        assert {:msg "  471.6: The precondition at 458.12 might not hold. Insufficient fraction at 458.12 for AVLTreeNode.keys."} exhaleMask#_1308[this#361, AVLTreeNode.keys][perm$R] > 0.0;
        assume methodCallK#_1306 < exhaleMask#_1308[this#361, AVLTreeNode.keys][perm$R];
        exhaleMask#_1308[this#361, AVLTreeNode.keys] := exhaleMask#_1308[this#361, AVLTreeNode.keys][perm$R := exhaleMask#_1308[this#361, AVLTreeNode.keys][perm$R] - methodCallK#_1306];
        assume wf(Heap, exhaleMask#_1308, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  471.6: The precondition at 457.12 might not hold. The permission at 457.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  471.6: The precondition at 457.12 might not hold. Insufficient fraction at 457.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1308[this#361, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1308[this#361, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1308[this#361, AVLTreeNode.valid][perm$N]));
        exhaleMask#_1308[this#361, AVLTreeNode.valid] := exhaleMask#_1308[this#361, AVLTreeNode.valid][perm$R := exhaleMask#_1308[this#361, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1308, this#361, AVLTreeNode.valid)) {
          assume Heap[this#361, AVLTreeNode.valid] < exhaleHeap#_1307[this#361, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1308, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_1308;
        assume IsGoodExhaleState(exhaleHeap#_1307, Heap, Mask, exhaledHolds#_1309);
        Heap := exhaleHeap#_1307;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc b#363;
        // inhale (postcondition)
        assume this#361 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#361, AVLTreeNode.valid] := Mask[this#361, AVLTreeNode.valid][perm$R := Mask[this#361, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#361 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_1306 > 0.0;
        Mask[this#361, AVLTreeNode.keys] := Mask[this#361, AVLTreeNode.keys][perm$R := Mask[this#361, AVLTreeNode.keys][perm$R] + methodCallK#_1306];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume b#363 == Seq#Contains(Heap[this#361, AVLTreeNode.keys], k#362);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        b#48 := b#363;
      } else {
        // assigment to b
        b#48 := false;
      }
    } else {
      // if
      cond#_1315 := !(Heap[this, AVLTreeNode.right] == null);
      assert {:msg "  476.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  476.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (cond#_1315) {
        assume (0.0 < methodCallK#_1320) && ((1000.0 * methodCallK#_1320) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1320) < methodK#_1274);
        // call has
        callHeap#_1316 := Heap;
        callMask#_1317 := Mask;
        callSecMask#_1318 := SecMask;
        callCredits#_1319 := Credits;
        assume wf(callHeap#_1316, callMask#_1317, callSecMask#_1318);
        assert {:msg "  477.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  477.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  477.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#364 := Heap[this, AVLTreeNode.right];
        k#365 := k#47;
        // begin exhale (precondition)
        exhaleMask#_1322 := Mask;
        havoc exhaleHeap#_1321;
        exhaledHolds#_1323 := ZeroRefSet;
        assert {:msg "  477.6: The precondition at 458.12 might not hold. The permission at 458.12 might not be positive."} methodCallK#_1320 > 0.0;
        assert {:msg "  477.6: The precondition at 458.12 might not hold. Insufficient fraction at 458.12 for AVLTreeNode.keys."} exhaleMask#_1322[this#364, AVLTreeNode.keys][perm$R] > 0.0;
        assume methodCallK#_1320 < exhaleMask#_1322[this#364, AVLTreeNode.keys][perm$R];
        exhaleMask#_1322[this#364, AVLTreeNode.keys] := exhaleMask#_1322[this#364, AVLTreeNode.keys][perm$R := exhaleMask#_1322[this#364, AVLTreeNode.keys][perm$R] - methodCallK#_1320];
        assume wf(Heap, exhaleMask#_1322, SecMask);
        assume wf(Heap, Mask, SecMask);
        assert {:msg "  477.6: The precondition at 457.12 might not hold. The permission at 457.12 might not be positive."} (real(100) * 0.01) > 0.0;
        assert {:msg "  477.6: The precondition at 457.12 might not hold. Insufficient fraction at 457.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1322[this#364, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1322[this#364, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1322[this#364, AVLTreeNode.valid][perm$N]));
        exhaleMask#_1322[this#364, AVLTreeNode.valid] := exhaleMask#_1322[this#364, AVLTreeNode.valid][perm$R := exhaleMask#_1322[this#364, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
        if (!CanRead(exhaleMask#_1322, this#364, AVLTreeNode.valid)) {
          assume Heap[this#364, AVLTreeNode.valid] < exhaleHeap#_1321[this#364, AVLTreeNode.valid];
        }
        assume wf(Heap, exhaleMask#_1322, SecMask);
        assume wf(Heap, Mask, SecMask);
        Mask := exhaleMask#_1322;
        assume IsGoodExhaleState(exhaleHeap#_1321, Heap, Mask, exhaledHolds#_1323);
        Heap := exhaleHeap#_1321;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end exhale
        havoc b#366;
        // inhale (postcondition)
        assume this#364 != null;
        assume wf(Heap, Mask, SecMask);
        assume (real(100) * 0.01) > 0.0;
        Mask[this#364, AVLTreeNode.valid] := Mask[this#364, AVLTreeNode.valid][perm$R := Mask[this#364, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume this#364 != null;
        assume wf(Heap, Mask, SecMask);
        assume true;
        assume methodCallK#_1320 > 0.0;
        Mask[this#364, AVLTreeNode.keys] := Mask[this#364, AVLTreeNode.keys][perm$R := Mask[this#364, AVLTreeNode.keys][perm$R] + methodCallK#_1320];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        assume wf(Heap, Mask, SecMask);
        assume b#366 == Seq#Contains(Heap[this#364, AVLTreeNode.keys], k#365);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask, SecMask);
        // end inhale
        b#48 := b#366;
      } else {
        // assigment to b
        b#48 := false;
      }
    }
  }
  // fold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0.0 < foldK#_1332) && ((1000.0 * foldK#_1332) < (real(1) * 0.01)) && ((1000.0 * foldK#_1332) < methodK#_1274);
  assert {:msg "  483.3: The target of the fold statement might be null."} this != null;
  predRec#_1329 := this;
  predVer#_1330 := Heap[this, AVLTreeNode.valid];
  predFlag#_1331 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#79#367: int :: 
      (0 <= lk#79#367) && (lk#79#367 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#367) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#80#368: int :: 
      (0 <= rk#80#368) && (rk#80#368 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#368))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 117.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.key][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.key][perm$N]));
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 118.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.height][perm$N]));
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 119.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.left][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.left][perm$N]));
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 120.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.right][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.right][perm$N]));
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 122.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.keys][perm$N]));
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 123.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.balanceFactor][perm$N]));
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 125.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1329, AVLTreeNode.valid, predVer#_1330, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 126.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 127.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 128.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 132.23 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1329, AVLTreeNode.valid, predVer#_1330, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 133.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 134.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 135.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  483.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.key] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.height] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.left] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.right] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.keys] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.balanceFactor] := true;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_1353;
    assume (forall ref#_1351: ref :: 
      (forall<T#_11> f#_1352: Field (T#_11) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1351, f#_1352] || Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1351, f#_1352]) ==> newPredicateMask#_1353[ref#_1351, f#_1352]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1353;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_1356;
    assume (forall ref#_1354: ref :: 
      (forall<T#_12> f#_1355: Field (T#_12) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1354, f#_1355] || Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1354, f#_1355]) ==> newPredicateMask#_1356[ref#_1354, f#_1355]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1356;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_1358 := Mask;
  havoc exhaleHeap#_1357;
  exhaledHolds#_1359 := ZeroRefSet;
  assert {:msg "  456.2: The postcondition at 462.11 might not hold. The expression at 462.11 might not evaluate to true."} b#48 == Seq#Contains(Heap[this, AVLTreeNode.keys], k#47);
  assert {:msg "  456.2: The postcondition at 460.11 might not hold. The permission at 460.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  456.2: The postcondition at 460.11 might not hold. Insufficient fraction at 460.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1358[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1358[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1358[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1358[this, AVLTreeNode.valid] := exhaleMask#_1358[this, AVLTreeNode.valid][perm$R := exhaleMask#_1358[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1358, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_1357[this, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1358, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  456.2: The postcondition at 461.11 might not hold. The permission at 461.11 might not be positive."} methodK#_1274 > 0.0;
  assert {:msg "  456.2: The postcondition at 461.11 might not hold. Insufficient fraction at 461.11 for AVLTreeNode.keys."} (methodK#_1274 <= exhaleMask#_1358[this, AVLTreeNode.keys][perm$R]) && ((methodK#_1274 == exhaleMask#_1358[this, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1358[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1358[this, AVLTreeNode.keys] := exhaleMask#_1358[this, AVLTreeNode.keys][perm$R := exhaleMask#_1358[this, AVLTreeNode.keys][perm$R] - methodK#_1274];
  assume wf(Heap, exhaleMask#_1358, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1358;
  assume IsGoodExhaleState(exhaleHeap#_1357, Heap, Mask, exhaledHolds#_1359);
  Heap := exhaleHeap#_1357;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  456.2: Method might lock/unlock more than allowed."} (forall lk#_1362: ref :: 
    { Heap[lk#_1362, held] }
    { Heap[lk#_1362, rdheld] }
    (((0 < Heap[lk#_1362, held]) == (0 < old(Heap)[lk#_1362, held])) && (Heap[lk#_1362, rdheld] == old(Heap)[lk#_1362, rdheld])) || false
  );
  assert {:msg "  456.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.getBalanceFactor
// -------------------------------------------

// definedness check for method AVLTreeNode.getBalanceFactor
procedure AVLTreeNode.getBalanceFactor$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1363: real;
  var predRec#_1368: ref;
  var predFlag#_1370: bool;
  var predVer#_1369: int;
  var unfoldingK#_1376: real;
  var predFlag#_1375: bool;
  var predRec#_1377: ref;
  var predVer#_1378: int;
  var unfoldingHeap#_1371: HeapType;
  var unfoldingMask#_1372: MaskType;
  var unfoldingSecMask#_1373: MaskType;
  var unfoldingCredits#_1374: CreditsType;
  var oldVers#_1383: int;
  var newVers#_1384: int;
  var newPredicateMask#_1388: PMaskType;
  var newPredicateMask#_1391: PMaskType;
  var predRec#_1395: ref;
  var predFlag#_1397: bool;
  var predVer#_1396: int;
  var unfoldingK#_1403: real;
  var predFlag#_1402: bool;
  var predRec#_1404: ref;
  var predVer#_1405: int;
  var unfoldingHeap#_1398: HeapType;
  var unfoldingMask#_1399: MaskType;
  var unfoldingSecMask#_1400: MaskType;
  var unfoldingCredits#_1401: CreditsType;
  var oldVers#_1410: int;
  var newVers#_1411: int;
  var newPredicateMask#_1415: PMaskType;
  var newPredicateMask#_1418: PMaskType;
  assume (0.0 < methodK#_1363) && ((1000.0 * methodK#_1363) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assert {:msg "  488.12: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1363 > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + methodK#_1363];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1366: Field (PMaskType) :: 
    (forall ref#_1365: ref :: 
      Heap[ref#_1365, pmask#_1366] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  491.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1363 > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + methodK#_1363];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  493.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  493.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume bf#49 == Heap[this, AVLTreeNode.balanceFactor];
  predRec#_1368 := this;
  predFlag#_1370 := true;
  assume #AVLTreeNode.valid#trigger(this);
  predVer#_1369 := Heap[this, AVLTreeNode.valid];
  // unfolding
  assume (0.0 < unfoldingK#_1376) && ((1000.0 * unfoldingK#_1376) < (real(1) * 0.01));
  predFlag#_1375 := true;
  predRec#_1377 := this;
  predVer#_1378 := Heap[this, AVLTreeNode.valid];
  assert {:msg "  495.21: Receiver might be null."} true ==> (this != null);
  unfoldingHeap#_1371 := Heap;
  unfoldingMask#_1372 := Mask;
  unfoldingSecMask#_1373 := SecMask;
  unfoldingCredits#_1374 := Credits;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  // begin exhale (unfolding)
  assert {:msg "  495.11: Unfolding might fail. The permission at 495.21 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  495.11: Unfolding might fail. Insufficient fraction at 495.21 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1372[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1372[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1372[this, AVLTreeNode.valid][perm$N]));
  unfoldingMask#_1372[this, AVLTreeNode.valid] := unfoldingMask#_1372[this, AVLTreeNode.valid][perm$R := unfoldingMask#_1372[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(unfoldingMask#_1372, this, AVLTreeNode.valid)) {
    oldVers#_1383 := unfoldingHeap#_1371[this, AVLTreeNode.valid];
    havoc newVers#_1384;
    unfoldingHeap#_1371[this, AVLTreeNode.valid] := newVers#_1384;
    assume oldVers#_1383 < unfoldingHeap#_1371[this, AVLTreeNode.valid];
  }
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  // end exhale
  // inhale (unfolding)
  assume this != null;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1372[this, AVLTreeNode.key] := unfoldingMask#_1372[this, AVLTreeNode.key][perm$R := unfoldingMask#_1372[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume this != null;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1372[this, AVLTreeNode.height] := unfoldingMask#_1372[this, AVLTreeNode.height][perm$R := unfoldingMask#_1372[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume this != null;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume (unfoldingHeap#_1371[this, AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1371[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1372[this, AVLTreeNode.left] := unfoldingMask#_1372[this, AVLTreeNode.left][perm$R := unfoldingMask#_1372[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume this != null;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume (unfoldingHeap#_1371[this, AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1371[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1372[this, AVLTreeNode.right] := unfoldingMask#_1372[this, AVLTreeNode.right][perm$R := unfoldingMask#_1372[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume this != null;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1372[this, AVLTreeNode.keys] := unfoldingMask#_1372[this, AVLTreeNode.keys][perm$R := unfoldingMask#_1372[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume this != null;
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1372[this, AVLTreeNode.balanceFactor] := unfoldingMask#_1372[this, AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1372[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1377, AVLTreeNode.valid, predVer#_1378, unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#371: int :: 
      (0 <= lk#79#371) && (lk#79#371 < Seq#Length(unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#371) < unfoldingHeap#_1371[this, AVLTreeNode.key])
    );
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1377, AVLTreeNode.valid, predVer#_1378, unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1371[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1372[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1372);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
    assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#372: int :: 
      (0 <= rk#80#372) && (rk#80#372 < Seq#Length(unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1371[this, AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#372))
    );
  }
  if (!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_1371[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1371[this, AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1371[this, AVLTreeNode.key])), ite(unfoldingHeap#_1371[this, AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_1371[this, AVLTreeNode.keys], unfoldingHeap#_1371[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(unfoldingHeap#_1371[this, AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1371[this, AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1371[this, AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1371[this, AVLTreeNode.key]))
  );
  assume unfoldingHeap#_1371[this, AVLTreeNode.height] == ite(ite(unfoldingHeap#_1371[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1371[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1371[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1371[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_1371[this, AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1371[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1371[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1371[unfoldingHeap#_1371[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_1371[this, AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_1371[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_1371[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_1372);
  assume wf(unfoldingHeap#_1371, unfoldingMask#_1372, unfoldingSecMask#_1373);
  // end inhale
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.key] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.height] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.left] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.right] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.keys] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.balanceFactor] := true;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_1388;
    assume (forall ref#_1386: ref :: 
      (forall<T#_13> f#_1387: Field (T#_13) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1386, f#_1387] || Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1386, f#_1387]) ==> newPredicateMask#_1388[ref#_1386, f#_1387]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1388;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_1391;
    assume (forall ref#_1389: ref :: 
      (forall<T#_14> f#_1390: Field (T#_14) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1389, f#_1390] || Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1389, f#_1390]) ==> newPredicateMask#_1391[ref#_1389, f#_1390]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1391;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assert {:msg "  495.39: Receiver might be null."} true && (bf#49 > 0) ==> (this != null);
  assert {:msg "  495.39: Location might not be readable."} true && (bf#49 > 0) ==> CanRead(unfoldingMask#_1372, this, AVLTreeNode.left);
  assume wf(Heap, Mask, SecMask);
  assume (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  predRec#_1395 := this;
  predFlag#_1397 := true;
  assume #AVLTreeNode.valid#trigger(this);
  predVer#_1396 := Heap[this, AVLTreeNode.valid];
  // unfolding
  assume (0.0 < unfoldingK#_1403) && ((1000.0 * unfoldingK#_1403) < (real(1) * 0.01));
  predFlag#_1402 := true;
  predRec#_1404 := this;
  predVer#_1405 := Heap[this, AVLTreeNode.valid];
  assert {:msg "  496.21: Receiver might be null."} true ==> (this != null);
  unfoldingHeap#_1398 := Heap;
  unfoldingMask#_1399 := Mask;
  unfoldingSecMask#_1400 := SecMask;
  unfoldingCredits#_1401 := Credits;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  // begin exhale (unfolding)
  assert {:msg "  496.11: Unfolding might fail. The permission at 496.21 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  496.11: Unfolding might fail. Insufficient fraction at 496.21 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1399[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1399[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1399[this, AVLTreeNode.valid][perm$N]));
  unfoldingMask#_1399[this, AVLTreeNode.valid] := unfoldingMask#_1399[this, AVLTreeNode.valid][perm$R := unfoldingMask#_1399[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(unfoldingMask#_1399, this, AVLTreeNode.valid)) {
    oldVers#_1410 := unfoldingHeap#_1398[this, AVLTreeNode.valid];
    havoc newVers#_1411;
    unfoldingHeap#_1398[this, AVLTreeNode.valid] := newVers#_1411;
    assume oldVers#_1410 < unfoldingHeap#_1398[this, AVLTreeNode.valid];
  }
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  // end exhale
  // inhale (unfolding)
  assume this != null;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1399[this, AVLTreeNode.key] := unfoldingMask#_1399[this, AVLTreeNode.key][perm$R := unfoldingMask#_1399[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume this != null;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1399[this, AVLTreeNode.height] := unfoldingMask#_1399[this, AVLTreeNode.height][perm$R := unfoldingMask#_1399[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume this != null;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume (unfoldingHeap#_1398[this, AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1398[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1399[this, AVLTreeNode.left] := unfoldingMask#_1399[this, AVLTreeNode.left][perm$R := unfoldingMask#_1399[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume this != null;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume (unfoldingHeap#_1398[this, AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1398[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1399[this, AVLTreeNode.right] := unfoldingMask#_1399[this, AVLTreeNode.right][perm$R := unfoldingMask#_1399[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume this != null;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1399[this, AVLTreeNode.keys] := unfoldingMask#_1399[this, AVLTreeNode.keys][perm$R := unfoldingMask#_1399[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume this != null;
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1399[this, AVLTreeNode.balanceFactor] := unfoldingMask#_1399[this, AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1399[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1404, AVLTreeNode.valid, predVer#_1405, unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#373: int :: 
      (0 <= lk#79#373) && (lk#79#373 < Seq#Length(unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#373) < unfoldingHeap#_1398[this, AVLTreeNode.key])
    );
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1404, AVLTreeNode.valid, predVer#_1405, unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1398[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1399[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1399);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
    assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#374: int :: 
      (0 <= rk#80#374) && (rk#80#374 < Seq#Length(unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1398[this, AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#374))
    );
  }
  if (!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_1398[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1398[this, AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1398[this, AVLTreeNode.key])), ite(unfoldingHeap#_1398[this, AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_1398[this, AVLTreeNode.keys], unfoldingHeap#_1398[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(unfoldingHeap#_1398[this, AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1398[this, AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1398[this, AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1398[this, AVLTreeNode.key]))
  );
  assume unfoldingHeap#_1398[this, AVLTreeNode.height] == ite(ite(unfoldingHeap#_1398[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1398[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1398[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1398[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_1398[this, AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1398[this, AVLTreeNode.left] == null, 0, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1398[this, AVLTreeNode.right] == null, 0, unfoldingHeap#_1398[unfoldingHeap#_1398[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_1398[this, AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_1398[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_1398[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_1399);
  assume wf(unfoldingHeap#_1398, unfoldingMask#_1399, unfoldingSecMask#_1400);
  // end inhale
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.key] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.height] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.left] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.right] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.keys] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.balanceFactor] := true;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_1415;
    assume (forall ref#_1413: ref :: 
      (forall<T#_15> f#_1414: Field (T#_15) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1413, f#_1414] || Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1413, f#_1414]) ==> newPredicateMask#_1415[ref#_1413, f#_1414]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1415;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_1418;
    assume (forall ref#_1416: ref :: 
      (forall<T#_16> f#_1417: Field (T#_16) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1416, f#_1417] || Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1416, f#_1417]) ==> newPredicateMask#_1418[ref#_1416, f#_1417]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1418;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assert {:msg "  496.39: Receiver might be null."} true && (bf#49 < 0) ==> (this != null);
  assert {:msg "  496.39: Location might not be readable."} true && (bf#49 < 0) ==> CanRead(unfoldingMask#_1399, this, AVLTreeNode.right);
  assume wf(Heap, Mask, SecMask);
  assume (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.getBalanceFactor
procedure AVLTreeNode.getBalanceFactor(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1363: real;
  var predRec#_1426: ref;
  var predVer#_1427: int;
  var unfoldK#_1425: real;
  var oldVers#_1432: int;
  var newVers#_1433: int;
  var lh#51: int where true;
  var rh#53: int where true;
  var foldK#_1438: real;
  var predRec#_1435: ref;
  var predVer#_1436: int;
  var predFlag#_1437: bool;
  var newPredicateMask#_1459: PMaskType;
  var newPredicateMask#_1462: PMaskType;
  var exhaleMask#_1464: MaskType;
  var exhaleHeap#_1463: HeapType;
  var exhaledHolds#_1465: RefSet;
  var predRec#_1466: ref;
  var predFlag#_1468: bool;
  var predVer#_1467: int;
  var predRec#_1469: ref;
  var predFlag#_1471: bool;
  var predVer#_1470: int;
  assume (0.0 < methodK#_1363) && ((1000.0 * methodK#_1363) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodK#_1363 > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + methodK#_1363];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1424: Field (PMaskType) :: 
    (forall ref#_1423: ref :: 
      Heap[ref#_1423, pmask#_1424] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(this);
  predRec#_1426 := this;
  predVer#_1427 := Heap[this, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_1425) && (unfoldK#_1425 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_1425) < methodK#_1363);
  assert {:msg "  498.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  assert {:msg "  498.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  498.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.valid][perm$N]));
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, this, AVLTreeNode.valid)) {
    oldVers#_1432 := Heap[this, AVLTreeNode.valid];
    havoc newVers#_1433;
    Heap[this, AVLTreeNode.valid] := newVers#_1433;
    assume oldVers#_1432 < Heap[this, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1426, AVLTreeNode.valid, predVer#_1427, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#79#375: int :: 
      (0 <= lk#79#375) && (lk#79#375 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#375) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1426, AVLTreeNode.valid, predVer#_1427, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#80#376: int :: 
      (0 <= rk#80#376) && (rk#80#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#376))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // local var lh
  // assigment to lh
  assert {:msg "  499.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  499.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  499.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  499.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  499.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  499.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#51 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  500.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  500.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  500.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  500.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  500.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  500.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#53 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assigment to bf
  bf#49 := lh#51 - rh#53;
  // fold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0.0 < foldK#_1438) && ((1000.0 * foldK#_1438) < (real(1) * 0.01)) && ((1000.0 * foldK#_1438) < methodK#_1363);
  assert {:msg "  506.3: The target of the fold statement might be null."} this != null;
  predRec#_1435 := this;
  predVer#_1436 := Heap[this, AVLTreeNode.valid];
  predFlag#_1437 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#79#377: int :: 
      (0 <= lk#79#377) && (lk#79#377 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#377) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#80#378: int :: 
      (0 <= rk#80#378) && (rk#80#378 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#378))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 117.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.key][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.key][perm$N]));
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 118.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.height][perm$N]));
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 119.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.left][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.left][perm$N]));
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 120.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.right][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.right][perm$N]));
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 122.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.keys][perm$N]));
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 123.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.balanceFactor][perm$N]));
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 125.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1435, AVLTreeNode.valid, predVer#_1436, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 126.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 127.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 128.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 132.23 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1435, AVLTreeNode.valid, predVer#_1436, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 133.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 134.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 135.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  506.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.key] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.height] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.left] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.right] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.keys] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.balanceFactor] := true;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_1459;
    assume (forall ref#_1457: ref :: 
      (forall<T#_17> f#_1458: Field (T#_17) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1457, f#_1458] || Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1457, f#_1458]) ==> newPredicateMask#_1459[ref#_1457, f#_1458]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1459;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_1462;
    assume (forall ref#_1460: ref :: 
      (forall<T#_18> f#_1461: Field (T#_18) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1460, f#_1461] || Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1460, f#_1461]) ==> newPredicateMask#_1462[ref#_1460, f#_1461]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1462;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_1464 := Mask;
  havoc exhaleHeap#_1463;
  exhaledHolds#_1465 := ZeroRefSet;
  assert {:msg "  487.2: The postcondition at 493.11 might not hold. The expression at 493.11 might not evaluate to true."} bf#49 == Heap[this, AVLTreeNode.balanceFactor];
  predRec#_1466 := this;
  predFlag#_1468 := true;
  assume #AVLTreeNode.valid#trigger(this);
  predVer#_1467 := Heap[this, AVLTreeNode.valid];
  assume predRec#_1466 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1466, AVLTreeNode.key] := SecMask[predRec#_1466, AVLTreeNode.key][perm$R := SecMask[predRec#_1466, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1466 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1466, AVLTreeNode.height] := SecMask[predRec#_1466, AVLTreeNode.height][perm$R := SecMask[predRec#_1466, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1466 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1466, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1466, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1466, AVLTreeNode.left] := SecMask[predRec#_1466, AVLTreeNode.left][perm$R := SecMask[predRec#_1466, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1466 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1466, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1466, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1466, AVLTreeNode.right] := SecMask[predRec#_1466, AVLTreeNode.right][perm$R := SecMask[predRec#_1466, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1466 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1466, AVLTreeNode.keys] := SecMask[predRec#_1466, AVLTreeNode.keys][perm$R := SecMask[predRec#_1466, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1466 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1466, AVLTreeNode.balanceFactor] := SecMask[predRec#_1466, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1466, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1466, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1466, AVLTreeNode.valid, predVer#_1467, Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.left] == null)) {
    assume (forall lk#79#381: int :: 
      (0 <= lk#79#381) && (lk#79#381 < Seq#Length(Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys], lk#79#381) < Heap[predRec#_1466, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1466, AVLTreeNode.valid, predVer#_1467, Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1466, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.right] == null)) {
    assume (forall rk#80#382: int :: 
      (0 <= rk#80#382) && (rk#80#382 < Seq#Length(Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1466, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys], rk#80#382))
    );
  }
  if (!(Heap[predRec#_1466, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1466, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1466, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1466, AVLTreeNode.key])), ite(Heap[predRec#_1466, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1466, AVLTreeNode.keys], Heap[predRec#_1466, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_1466, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1466, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1466, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1466, AVLTreeNode.key]))
  );
  assume Heap[predRec#_1466, AVLTreeNode.height] == ite(ite(Heap[predRec#_1466, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1466, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1466, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1466, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1466, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1466, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1466, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1466, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1466, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1466, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1466, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1466, AVLTreeNode.height] > 0;
  assert {:msg "  487.2: The postcondition at 495.11 might not hold. The expression at 495.11 might not evaluate to true."} (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  predRec#_1469 := this;
  predFlag#_1471 := true;
  assume #AVLTreeNode.valid#trigger(this);
  predVer#_1470 := Heap[this, AVLTreeNode.valid];
  assume predRec#_1469 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1469, AVLTreeNode.key] := SecMask[predRec#_1469, AVLTreeNode.key][perm$R := SecMask[predRec#_1469, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1469 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1469, AVLTreeNode.height] := SecMask[predRec#_1469, AVLTreeNode.height][perm$R := SecMask[predRec#_1469, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1469 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1469, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1469, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1469, AVLTreeNode.left] := SecMask[predRec#_1469, AVLTreeNode.left][perm$R := SecMask[predRec#_1469, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1469 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1469, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1469, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1469, AVLTreeNode.right] := SecMask[predRec#_1469, AVLTreeNode.right][perm$R := SecMask[predRec#_1469, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1469 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1469, AVLTreeNode.keys] := SecMask[predRec#_1469, AVLTreeNode.keys][perm$R := SecMask[predRec#_1469, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1469 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1469, AVLTreeNode.balanceFactor] := SecMask[predRec#_1469, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1469, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1469, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1469, AVLTreeNode.valid, predVer#_1470, Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.left] == null)) {
    assume (forall lk#79#383: int :: 
      (0 <= lk#79#383) && (lk#79#383 < Seq#Length(Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys], lk#79#383) < Heap[predRec#_1469, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1469, AVLTreeNode.valid, predVer#_1470, Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1469, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.right] == null)) {
    assume (forall rk#80#384: int :: 
      (0 <= rk#80#384) && (rk#80#384 < Seq#Length(Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1469, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys], rk#80#384))
    );
  }
  if (!(Heap[predRec#_1469, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1469, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1469, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1469, AVLTreeNode.key])), ite(Heap[predRec#_1469, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1469, AVLTreeNode.keys], Heap[predRec#_1469, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_1469, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1469, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1469, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1469, AVLTreeNode.key]))
  );
  assume Heap[predRec#_1469, AVLTreeNode.height] == ite(ite(Heap[predRec#_1469, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1469, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1469, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1469, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1469, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1469, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1469, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1469, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1469, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1469, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1469, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1469, AVLTreeNode.height] > 0;
  assert {:msg "  487.2: The postcondition at 496.11 might not hold. The expression at 496.11 might not evaluate to true."} (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  assert {:msg "  487.2: The postcondition at 491.11 might not hold. The permission at 491.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  487.2: The postcondition at 491.11 might not hold. Insufficient fraction at 491.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1464[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1464[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1464[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1464[this, AVLTreeNode.valid] := exhaleMask#_1464[this, AVLTreeNode.valid][perm$R := exhaleMask#_1464[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1464, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_1463[this, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1464, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  487.2: The postcondition at 492.11 might not hold. The permission at 492.11 might not be positive."} methodK#_1363 > 0.0;
  assert {:msg "  487.2: The postcondition at 492.11 might not hold. Insufficient fraction at 492.11 for AVLTreeNode.balanceFactor."} (methodK#_1363 <= exhaleMask#_1464[this, AVLTreeNode.balanceFactor][perm$R]) && ((methodK#_1363 == exhaleMask#_1464[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1464[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1464[this, AVLTreeNode.balanceFactor] := exhaleMask#_1464[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1464[this, AVLTreeNode.balanceFactor][perm$R] - methodK#_1363];
  assume wf(Heap, exhaleMask#_1464, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1464;
  assume IsGoodExhaleState(exhaleHeap#_1463, Heap, Mask, exhaledHolds#_1465);
  Heap := exhaleHeap#_1463;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  487.2: Method might lock/unlock more than allowed."} (forall lk#_1474: ref :: 
    { Heap[lk#_1474, held] }
    { Heap[lk#_1474, rdheld] }
    (((0 < Heap[lk#_1474, held]) == (0 < old(Heap)[lk#_1474, held])) && (Heap[lk#_1474, rdheld] == old(Heap)[lk#_1474, rdheld])) || false
  );
  assert {:msg "  487.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.getBalanceFactorI
// -------------------------------------------

// definedness check for method AVLTreeNode.getBalanceFactorI
procedure AVLTreeNode.getBalanceFactorI$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#54: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1475: real;
  assume (0.0 < methodK#_1475) && ((1000.0 * methodK#_1475) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume methodK#_1475 > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + methodK#_1475];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  512.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  512.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  512.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  512.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  512.27: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  512.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  512.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  513.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  513.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  513.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  513.30: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1475 > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodK#_1475];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume methodK#_1475 > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + methodK#_1475];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  516.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  516.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  516.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  516.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  516.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  516.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  516.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  517.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  517.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  517.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  517.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1475 > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodK#_1475];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1478: Field (PMaskType) :: 
    (forall ref#_1477: ref :: 
      Heap[ref#_1477, pmask#_1478] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume methodK#_1475 > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + methodK#_1475];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  520.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  520.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  520.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  520.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  520.26: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  520.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  520.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  521.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  521.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  521.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  521.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1475 > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodK#_1475];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume methodK#_1475 > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + methodK#_1475];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  524.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  524.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  524.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  524.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  524.27: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  524.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  524.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  525.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  525.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  525.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  525.30: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1475 > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodK#_1475];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  527.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  527.18: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  527.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  527.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  527.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  527.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  527.45: Receiver might be null."} true ==> (this != null);
  assert {:msg "  527.45: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  527.59: Receiver might be null."} true ==> (this != null);
    assert {:msg "  527.59: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  527.59: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  527.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume bf#54 == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  if (bf#54 > 0) {
    assert {:msg "  528.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  528.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume !(Heap[this, AVLTreeNode.left] == null);
  }
  if (bf#54 < 0) {
    assert {:msg "  529.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  529.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume !(Heap[this, AVLTreeNode.right] == null);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.getBalanceFactorI
procedure AVLTreeNode.getBalanceFactorI(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#54: int where true)
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1475: real;
  var lh#56: int where true;
  var rh#58: int where true;
  var assertHeap#_1483: HeapType;
  var assertMask#_1484: MaskType;
  var assertSecMask#_1485: MaskType;
  var assertCredits#_1486: CreditsType;
  var exhaleMask#_1488: MaskType;
  var exhaleHeap#_1487: HeapType;
  var exhaledHolds#_1489: RefSet;
  var unfoldingK#_1498: real;
  var predFlag#_1497: bool;
  var predRec#_1499: ref;
  var predVer#_1500: int;
  var unfoldingHeap#_1493: HeapType;
  var unfoldingMask#_1494: MaskType;
  var unfoldingSecMask#_1495: MaskType;
  var unfoldingCredits#_1496: CreditsType;
  var oldVers#_1505: int;
  var newVers#_1506: int;
  var newPredicateMask#_1510: PMaskType;
  var newPredicateMask#_1513: PMaskType;
  var assertHeap#_1514: HeapType;
  var assertMask#_1515: MaskType;
  var assertSecMask#_1516: MaskType;
  var assertCredits#_1517: CreditsType;
  var exhaleMask#_1519: MaskType;
  var exhaleHeap#_1518: HeapType;
  var exhaledHolds#_1520: RefSet;
  var unfoldingK#_1529: real;
  var predFlag#_1528: bool;
  var predRec#_1530: ref;
  var predVer#_1531: int;
  var unfoldingHeap#_1524: HeapType;
  var unfoldingMask#_1525: MaskType;
  var unfoldingSecMask#_1526: MaskType;
  var unfoldingCredits#_1527: CreditsType;
  var oldVers#_1536: int;
  var newVers#_1537: int;
  var newPredicateMask#_1541: PMaskType;
  var newPredicateMask#_1544: PMaskType;
  var assertHeap#_1545: HeapType;
  var assertMask#_1546: MaskType;
  var assertSecMask#_1547: MaskType;
  var assertCredits#_1548: CreditsType;
  var exhaleMask#_1550: MaskType;
  var exhaleHeap#_1549: HeapType;
  var exhaledHolds#_1551: RefSet;
  var assertHeap#_1552: HeapType;
  var assertMask#_1553: MaskType;
  var assertSecMask#_1554: MaskType;
  var assertCredits#_1555: CreditsType;
  var exhaleMask#_1557: MaskType;
  var exhaleHeap#_1556: HeapType;
  var exhaledHolds#_1558: RefSet;
  var exhaleMask#_1560: MaskType;
  var exhaleHeap#_1559: HeapType;
  var exhaledHolds#_1561: RefSet;
  assume (0.0 < methodK#_1475) && ((1000.0 * methodK#_1475) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume methodK#_1475 > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + methodK#_1475];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1475 > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + methodK#_1475];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume methodK#_1475 > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + methodK#_1475];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume methodK#_1475 > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + methodK#_1475];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1482: Field (PMaskType) :: 
    (forall ref#_1481: ref :: 
      Heap[ref#_1481, pmask#_1482] == ZeroPMask
    )
  );
  // local var lh
  // assigment to lh
  assert {:msg "  531.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  531.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  531.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  531.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  531.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  531.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#56 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  532.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  532.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  532.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  532.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  532.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  532.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#58 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assigment to bf
  bf#54 := lh#56 - rh#58;
  // assert
  assertHeap#_1483 := Heap;
  assertMask#_1484 := Mask;
  assertSecMask#_1485 := SecMask;
  assertCredits#_1486 := Credits;
  assume wf(assertHeap#_1483, assertMask#_1484, assertSecMask#_1485);
  // begin exhale (assert)
  exhaleMask#_1488 := assertMask#_1484;
  havoc exhaleHeap#_1487;
  exhaledHolds#_1489 := ZeroRefSet;
  assert {:msg "  534.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  534.10: Location might not be readable."} true ==> CanRead(assertMask#_1484, this, AVLTreeNode.right);
  if (!(assertHeap#_1483[this, AVLTreeNode.right] == null)) {
    // unfolding
    assume (0.0 < unfoldingK#_1498) && ((1000.0 * unfoldingK#_1498) < (real(1) * 0.01));
    predFlag#_1497 := true;
    predRec#_1499 := assertHeap#_1483[this, AVLTreeNode.right];
    predVer#_1500 := Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid];
    assert {:msg "  534.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  534.36: Location might not be readable."} true ==> CanRead(assertMask#_1484, this, AVLTreeNode.right);
    assert {:msg "  534.36: Receiver might be null."} true ==> (assertHeap#_1483[this, AVLTreeNode.right] != null);
    unfoldingHeap#_1493 := assertHeap#_1483;
    unfoldingMask#_1494 := assertMask#_1484;
    unfoldingSecMask#_1495 := assertSecMask#_1485;
    unfoldingCredits#_1496 := assertCredits#_1486;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    // begin exhale (unfolding)
    assert {:msg "  534.26: Unfolding might fail. The permission at 534.36 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  534.26: Unfolding might fail. Insufficient fraction at 534.36 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(unfoldingMask#_1494, unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      oldVers#_1505 := unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid];
      havoc newVers#_1506;
      unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_1506;
      assume oldVers#_1505 < unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1493[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume unfoldingHeap#_1493[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume unfoldingHeap#_1493[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume (unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume unfoldingHeap#_1493[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume (unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume unfoldingHeap#_1493[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume unfoldingHeap#_1493[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1499, AVLTreeNode.valid, predVer#_1500, unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#387: int :: 
        (0 <= lk#79#387) && (lk#79#387 < Seq#Length(unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#387) < unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key])
      );
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1499, AVLTreeNode.valid, predVer#_1500, unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1494[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1494);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
      assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#388: int :: 
        (0 <= rk#80#388) && (rk#80#388 < Seq#Length(unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#388))
      );
    }
    if (!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.key]))
    );
    assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1493[unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1493[unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1494);
    assume wf(unfoldingHeap#_1493, unfoldingMask#_1494, unfoldingSecMask#_1495);
    // end inhale
    Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.key] := true;
    Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
    Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.left] := true;
    Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.right] := true;
    Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
    Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      havoc newPredicateMask#_1510;
      assume (forall ref#_1508: ref :: 
        (forall<T#_19> f#_1509: Field (T#_19) :: 
          (Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1508, f#_1509] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1508, f#_1509]) ==> newPredicateMask#_1510[ref#_1508, f#_1509]
        )
      );
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_1510;
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      havoc newPredicateMask#_1513;
      assume (forall ref#_1511: ref :: 
        (forall<T#_20> f#_1512: Field (T#_20) :: 
          (Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1511, f#_1512] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1511, f#_1512]) ==> newPredicateMask#_1513[ref#_1511, f#_1512]
        )
      );
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_1513;
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    }
    assert {:msg "  534.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  534.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1494, this, AVLTreeNode.right);
    assert {:msg "  534.51: Receiver might be null."} true ==> (unfoldingHeap#_1493[this, AVLTreeNode.right] != null);
    assert {:msg "  534.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1494, unfoldingHeap#_1493[this, AVLTreeNode.right], AVLTreeNode.height);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  534.3: Assertion might not hold. The expression at 534.26 might not evaluate to true."} assertHeap#_1483[assertHeap#_1483[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assertMask#_1484 := exhaleMask#_1488;
  assume IsGoodExhaleState(exhaleHeap#_1487, assertHeap#_1483, assertMask#_1484, exhaledHolds#_1489);
  assertHeap#_1483 := exhaleHeap#_1487;
  assume IsGoodMask(assertMask#_1484);
  assume wf(assertHeap#_1483, assertMask#_1484, assertSecMask#_1485);
  // end exhale
  // assert
  assertHeap#_1514 := Heap;
  assertMask#_1515 := Mask;
  assertSecMask#_1516 := SecMask;
  assertCredits#_1517 := Credits;
  assume wf(assertHeap#_1514, assertMask#_1515, assertSecMask#_1516);
  // begin exhale (assert)
  exhaleMask#_1519 := assertMask#_1515;
  havoc exhaleHeap#_1518;
  exhaledHolds#_1520 := ZeroRefSet;
  assert {:msg "  535.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  535.10: Location might not be readable."} true ==> CanRead(assertMask#_1515, this, AVLTreeNode.left);
  if (!(assertHeap#_1514[this, AVLTreeNode.left] == null)) {
    // unfolding
    assume (0.0 < unfoldingK#_1529) && ((1000.0 * unfoldingK#_1529) < (real(1) * 0.01));
    predFlag#_1528 := true;
    predRec#_1530 := assertHeap#_1514[this, AVLTreeNode.left];
    predVer#_1531 := Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid];
    assert {:msg "  535.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  535.36: Location might not be readable."} true ==> CanRead(assertMask#_1515, this, AVLTreeNode.left);
    assert {:msg "  535.36: Receiver might be null."} true ==> (assertHeap#_1514[this, AVLTreeNode.left] != null);
    unfoldingHeap#_1524 := assertHeap#_1514;
    unfoldingMask#_1525 := assertMask#_1515;
    unfoldingSecMask#_1526 := assertSecMask#_1516;
    unfoldingCredits#_1527 := assertCredits#_1517;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    // begin exhale (unfolding)
    assert {:msg "  535.26: Unfolding might fail. The permission at 535.36 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  535.26: Unfolding might fail. Insufficient fraction at 535.36 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(unfoldingMask#_1525, unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      oldVers#_1536 := unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid];
      havoc newVers#_1537;
      unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1537;
      assume oldVers#_1536 < unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1524[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume unfoldingHeap#_1524[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume unfoldingHeap#_1524[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume (unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume unfoldingHeap#_1524[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume (unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume unfoldingHeap#_1524[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume unfoldingHeap#_1524[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1530, AVLTreeNode.valid, predVer#_1531, unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#391: int :: 
        (0 <= lk#79#391) && (lk#79#391 < Seq#Length(unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#391) < unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key])
      );
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1530, AVLTreeNode.valid, predVer#_1531, unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1525[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1525);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
      assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#392: int :: 
        (0 <= rk#80#392) && (rk#80#392 < Seq#Length(unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#392))
      );
    }
    if (!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.key]))
    );
    assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1524[unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1524[unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1525);
    assume wf(unfoldingHeap#_1524, unfoldingMask#_1525, unfoldingSecMask#_1526);
    // end inhale
    Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.key] := true;
    Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
    Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.left] := true;
    Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.right] := true;
    Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
    Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      havoc newPredicateMask#_1541;
      assume (forall ref#_1539: ref :: 
        (forall<T#_21> f#_1540: Field (T#_21) :: 
          (Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1539, f#_1540] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1539, f#_1540]) ==> newPredicateMask#_1541[ref#_1539, f#_1540]
        )
      );
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1541;
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      havoc newPredicateMask#_1544;
      assume (forall ref#_1542: ref :: 
        (forall<T#_22> f#_1543: Field (T#_22) :: 
          (Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1542, f#_1543] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1542, f#_1543]) ==> newPredicateMask#_1544[ref#_1542, f#_1543]
        )
      );
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1544;
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    }
    assert {:msg "  535.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  535.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1525, this, AVLTreeNode.left);
    assert {:msg "  535.51: Receiver might be null."} true ==> (unfoldingHeap#_1524[this, AVLTreeNode.left] != null);
    assert {:msg "  535.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1525, unfoldingHeap#_1524[this, AVLTreeNode.left], AVLTreeNode.height);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  535.3: Assertion might not hold. The expression at 535.26 might not evaluate to true."} assertHeap#_1514[assertHeap#_1514[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  assertMask#_1515 := exhaleMask#_1519;
  assume IsGoodExhaleState(exhaleHeap#_1518, assertHeap#_1514, assertMask#_1515, exhaledHolds#_1520);
  assertHeap#_1514 := exhaleHeap#_1518;
  assume IsGoodMask(assertMask#_1515);
  assume wf(assertHeap#_1514, assertMask#_1515, assertSecMask#_1516);
  // end exhale
  // assert
  assertHeap#_1545 := Heap;
  assertMask#_1546 := Mask;
  assertSecMask#_1547 := SecMask;
  assertCredits#_1548 := Credits;
  assume wf(assertHeap#_1545, assertMask#_1546, assertSecMask#_1547);
  // begin exhale (assert)
  exhaleMask#_1550 := assertMask#_1546;
  havoc exhaleHeap#_1549;
  exhaledHolds#_1551 := ZeroRefSet;
  assert {:msg "  536.3: Assertion might not hold. The expression at 536.10 might not evaluate to true."} lh#56 >= 0;
  assertMask#_1546 := exhaleMask#_1550;
  assume IsGoodExhaleState(exhaleHeap#_1549, assertHeap#_1545, assertMask#_1546, exhaledHolds#_1551);
  assertHeap#_1545 := exhaleHeap#_1549;
  assume IsGoodMask(assertMask#_1546);
  assume wf(assertHeap#_1545, assertMask#_1546, assertSecMask#_1547);
  // end exhale
  // assert
  assertHeap#_1552 := Heap;
  assertMask#_1553 := Mask;
  assertSecMask#_1554 := SecMask;
  assertCredits#_1555 := Credits;
  assume wf(assertHeap#_1552, assertMask#_1553, assertSecMask#_1554);
  // begin exhale (assert)
  exhaleMask#_1557 := assertMask#_1553;
  havoc exhaleHeap#_1556;
  exhaledHolds#_1558 := ZeroRefSet;
  assert {:msg "  537.3: Assertion might not hold. The expression at 537.10 might not evaluate to true."} rh#58 >= 0;
  assertMask#_1553 := exhaleMask#_1557;
  assume IsGoodExhaleState(exhaleHeap#_1556, assertHeap#_1552, assertMask#_1553, exhaledHolds#_1558);
  assertHeap#_1552 := exhaleHeap#_1556;
  assume IsGoodMask(assertMask#_1553);
  assume wf(assertHeap#_1552, assertMask#_1553, assertSecMask#_1554);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_1560 := Mask;
  havoc exhaleHeap#_1559;
  exhaledHolds#_1561 := ZeroRefSet;
  assert {:msg "  510.2: The postcondition at 527.11 might not hold. The expression at 527.11 might not evaluate to true."} bf#54 == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  if (bf#54 > 0) {
    assert {:msg "  510.2: The postcondition at 528.11 might not hold. The expression at 528.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.left] == null);
  }
  if (bf#54 < 0) {
    assert {:msg "  510.2: The postcondition at 529.11 might not hold. The expression at 529.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.right] == null);
  }
  assert {:msg "  510.2: The postcondition at 519.11 might not hold. The permission at 519.11 might not be positive."} methodK#_1475 > 0.0;
  assert {:msg "  510.2: The postcondition at 519.11 might not hold. Insufficient fraction at 519.11 for AVLTreeNode.left."} (methodK#_1475 <= exhaleMask#_1560[this, AVLTreeNode.left][perm$R]) && ((methodK#_1475 == exhaleMask#_1560[this, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1560[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_1560[this, AVLTreeNode.left] := exhaleMask#_1560[this, AVLTreeNode.left][perm$R := exhaleMask#_1560[this, AVLTreeNode.left][perm$R] - methodK#_1475];
  assume wf(Heap, exhaleMask#_1560, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  510.2: The postcondition at 520.11 might not hold. The permission at 520.26 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  510.2: The postcondition at 520.11 might not hold. Insufficient fraction at 520.26 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1560, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1559[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1560, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  510.2: The postcondition at 521.11 might not hold. The permission at 521.26 might not be positive."} methodK#_1475 > 0.0;
    assert {:msg "  510.2: The postcondition at 521.11 might not hold. Insufficient fraction at 521.26 for AVLTreeNode.height."} (methodK#_1475 <= exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((methodK#_1475 == exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1560[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - methodK#_1475];
    assume wf(Heap, exhaleMask#_1560, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  510.2: The postcondition at 523.11 might not hold. The permission at 523.11 might not be positive."} methodK#_1475 > 0.0;
  assert {:msg "  510.2: The postcondition at 523.11 might not hold. Insufficient fraction at 523.11 for AVLTreeNode.right."} (methodK#_1475 <= exhaleMask#_1560[this, AVLTreeNode.right][perm$R]) && ((methodK#_1475 == exhaleMask#_1560[this, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1560[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_1560[this, AVLTreeNode.right] := exhaleMask#_1560[this, AVLTreeNode.right][perm$R := exhaleMask#_1560[this, AVLTreeNode.right][perm$R] - methodK#_1475];
  assume wf(Heap, exhaleMask#_1560, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  510.2: The postcondition at 524.11 might not hold. The permission at 524.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  510.2: The postcondition at 524.11 might not hold. Insufficient fraction at 524.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1560, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1559[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1560, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  510.2: The postcondition at 525.11 might not hold. The permission at 525.27 might not be positive."} methodK#_1475 > 0.0;
    assert {:msg "  510.2: The postcondition at 525.11 might not hold. Insufficient fraction at 525.27 for AVLTreeNode.height."} (methodK#_1475 <= exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((methodK#_1475 == exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1560[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - methodK#_1475];
    assume wf(Heap, exhaleMask#_1560, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1560;
  assume IsGoodExhaleState(exhaleHeap#_1559, Heap, Mask, exhaledHolds#_1561);
  Heap := exhaleHeap#_1559;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  510.2: Method might lock/unlock more than allowed."} (forall lk#_1568: ref :: 
    { Heap[lk#_1568, held] }
    { Heap[lk#_1568, rdheld] }
    (((0 < Heap[lk#_1568, held]) == (0 < old(Heap)[lk#_1568, held])) && (Heap[lk#_1568, rdheld] == old(Heap)[lk#_1568, rdheld])) || false
  );
  assert {:msg "  510.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.close
// -------------------------------------------

// definedness check for method AVLTreeNode.close
procedure AVLTreeNode.close$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1569: real;
  var k#92#394: int where true;
  var k#93#396: int where true;
  assume (0.0 < methodK#_1569) && ((1000.0 * methodK#_1569) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  552.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  552.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  552.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  552.27: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  552.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  552.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  553.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  553.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  553.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  553.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  554.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  554.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  554.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  554.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  555.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  555.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  555.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  555.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  556.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  556.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#394) ==> (this != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#394) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#394) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#394) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  556.12: Receiver might be null."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  556.12: Location might not be readable."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  556.52: Sequence index might be negative."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#92#394);
    assert {:msg "  556.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  556.56: Receiver might be null."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  556.56: Location might not be readable."} true && (0 <= k#92#394) && (k#92#394 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#92#393: int :: 
      (0 <= k#92#393) && (k#92#393 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#92#393) < Heap[this, AVLTreeNode.key])
    );
  }
  assert {:msg "  558.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  558.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  558.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  558.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  558.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  558.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  558.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  559.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  559.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  559.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  559.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  560.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  560.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  560.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  560.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  561.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  561.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  561.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  561.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  562.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  562.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#396) ==> (this != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#396) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#396) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#396) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  562.54: Receiver might be null."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  562.54: Location might not be readable."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  562.12: Receiver might be null."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  562.12: Location might not be readable."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  562.60: Sequence index might be negative."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#93#396);
    assert {:msg "  562.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#93#396) && (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#93#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#93#395: int :: 
      (0 <= k#93#395) && (k#93#395 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#93#395))
    );
  }
  assert {:msg "  564.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  564.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  564.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  564.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  564.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  564.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.47: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  564.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  564.65: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  564.65: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  564.65: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  565.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  565.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  565.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  565.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  565.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  565.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  565.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  565.47: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  565.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  565.65: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  565.65: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  565.65: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1572: Field (PMaskType) :: 
    (forall ref#_1571: ref :: 
      Heap[ref#_1571, pmask#_1572] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assert {:msg "  567.11: Receiver might be null."} this != null;
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  572.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  572.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assert {:msg "  573.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.10: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  573.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  573.39: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  573.39: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  573.39: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  573.60: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.60: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  573.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.75: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  573.105: Receiver might be null."} true ==> (this != null);
    assert {:msg "  573.105: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  573.105: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  573.105: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  575.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  575.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assert {:msg "  576.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  576.12: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  576.34: Receiver might be null."} true ==> (this != null);
    assert {:msg "  576.34: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  576.34: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  576.34: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  576.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  576.55: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  576.78: Receiver might be null."} true ==> (this != null);
    assert {:msg "  576.78: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  576.78: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  576.78: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  578.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  578.12: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    if (old(Heap)[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  578.34: Receiver might be null."} true ==> (this != null);
      assert {:msg "  578.34: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
      assert {:msg "  578.34: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
      assert {:msg "  578.34: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  580.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  580.12: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    if (old(Heap)[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  580.35: Receiver might be null."} true ==> (this != null);
      assert {:msg "  580.35: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
      assert {:msg "  580.35: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
      assert {:msg "  580.35: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]), ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  582.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  582.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  583.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  583.10: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  583.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  583.32: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  583.32: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  583.32: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  583.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  583.53: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  583.76: Receiver might be null."} true ==> (this != null);
    assert {:msg "  583.76: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  583.76: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  583.76: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.close
procedure AVLTreeNode.close(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1569: real;
  var lh#60: int where true;
  var rh#62: int where true;
  var assertHeap#_1577: HeapType;
  var assertMask#_1578: MaskType;
  var assertSecMask#_1579: MaskType;
  var assertCredits#_1580: CreditsType;
  var exhaleMask#_1582: MaskType;
  var exhaleHeap#_1581: HeapType;
  var exhaledHolds#_1583: RefSet;
  var unfoldingK#_1592: real;
  var predFlag#_1591: bool;
  var predRec#_1593: ref;
  var predVer#_1594: int;
  var unfoldingHeap#_1587: HeapType;
  var unfoldingMask#_1588: MaskType;
  var unfoldingSecMask#_1589: MaskType;
  var unfoldingCredits#_1590: CreditsType;
  var oldVers#_1599: int;
  var newVers#_1600: int;
  var newPredicateMask#_1604: PMaskType;
  var newPredicateMask#_1607: PMaskType;
  var assertHeap#_1608: HeapType;
  var assertMask#_1609: MaskType;
  var assertSecMask#_1610: MaskType;
  var assertCredits#_1611: CreditsType;
  var exhaleMask#_1613: MaskType;
  var exhaleHeap#_1612: HeapType;
  var exhaledHolds#_1614: RefSet;
  var unfoldingK#_1623: real;
  var predFlag#_1622: bool;
  var predRec#_1624: ref;
  var predVer#_1625: int;
  var unfoldingHeap#_1618: HeapType;
  var unfoldingMask#_1619: MaskType;
  var unfoldingSecMask#_1620: MaskType;
  var unfoldingCredits#_1621: CreditsType;
  var oldVers#_1630: int;
  var newVers#_1631: int;
  var newPredicateMask#_1635: PMaskType;
  var newPredicateMask#_1638: PMaskType;
  var assertHeap#_1639: HeapType;
  var assertMask#_1640: MaskType;
  var assertSecMask#_1641: MaskType;
  var assertCredits#_1642: CreditsType;
  var exhaleMask#_1644: MaskType;
  var exhaleHeap#_1643: HeapType;
  var exhaledHolds#_1645: RefSet;
  var foldK#_1649: real;
  var predRec#_1646: ref;
  var predVer#_1647: int;
  var predFlag#_1648: bool;
  var newPredicateMask#_1670: PMaskType;
  var newPredicateMask#_1673: PMaskType;
  var exhaleMask#_1675: MaskType;
  var exhaleHeap#_1674: HeapType;
  var exhaledHolds#_1676: RefSet;
  assume (0.0 < methodK#_1569) && ((1000.0 * methodK#_1569) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#92#397: int :: 
      (0 <= k#92#397) && (k#92#397 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#92#397) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#93#398: int :: 
      (0 <= k#93#398) && (k#93#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#93#398))
    );
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1576: Field (PMaskType) :: 
    (forall ref#_1575: ref :: 
      Heap[ref#_1575, pmask#_1576] == ZeroPMask
    )
  );
  // local var lh
  // assigment to lh
  assert {:msg "  585.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  585.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  585.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  585.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  585.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  585.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#60 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  586.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  586.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  586.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  586.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  586.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  586.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#62 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assert
  assertHeap#_1577 := Heap;
  assertMask#_1578 := Mask;
  assertSecMask#_1579 := SecMask;
  assertCredits#_1580 := Credits;
  assume wf(assertHeap#_1577, assertMask#_1578, assertSecMask#_1579);
  // begin exhale (assert)
  exhaleMask#_1582 := assertMask#_1578;
  havoc exhaleHeap#_1581;
  exhaledHolds#_1583 := ZeroRefSet;
  assert {:msg "  588.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  588.10: Location might not be readable."} true ==> CanRead(assertMask#_1578, this, AVLTreeNode.left);
  if (!(assertHeap#_1577[this, AVLTreeNode.left] == null)) {
    // unfolding
    assume (0.0 < unfoldingK#_1592) && ((1000.0 * unfoldingK#_1592) < (real(1) * 0.01));
    predFlag#_1591 := true;
    predRec#_1593 := assertHeap#_1577[this, AVLTreeNode.left];
    predVer#_1594 := Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid];
    assert {:msg "  588.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.36: Location might not be readable."} true ==> CanRead(assertMask#_1578, this, AVLTreeNode.left);
    assert {:msg "  588.36: Receiver might be null."} true ==> (assertHeap#_1577[this, AVLTreeNode.left] != null);
    unfoldingHeap#_1587 := assertHeap#_1577;
    unfoldingMask#_1588 := assertMask#_1578;
    unfoldingSecMask#_1589 := assertSecMask#_1579;
    unfoldingCredits#_1590 := assertCredits#_1580;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    // begin exhale (unfolding)
    assert {:msg "  588.26: Unfolding might fail. The permission at 588.36 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  588.26: Unfolding might fail. Insufficient fraction at 588.36 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(unfoldingMask#_1588, unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      oldVers#_1599 := unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid];
      havoc newVers#_1600;
      unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1600;
      assume oldVers#_1599 < unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1587[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume unfoldingHeap#_1587[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume unfoldingHeap#_1587[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume (unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume unfoldingHeap#_1587[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume (unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume unfoldingHeap#_1587[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume unfoldingHeap#_1587[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1593, AVLTreeNode.valid, predVer#_1594, unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#401: int :: 
        (0 <= lk#79#401) && (lk#79#401 < Seq#Length(unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#401) < unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key])
      );
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1593, AVLTreeNode.valid, predVer#_1594, unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1588[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1588);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
      assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#402: int :: 
        (0 <= rk#80#402) && (rk#80#402 < Seq#Length(unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#402))
      );
    }
    if (!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.key]))
    );
    assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1587[unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1587[unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1588);
    assume wf(unfoldingHeap#_1587, unfoldingMask#_1588, unfoldingSecMask#_1589);
    // end inhale
    Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.key] := true;
    Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
    Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.left] := true;
    Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.right] := true;
    Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
    Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      havoc newPredicateMask#_1604;
      assume (forall ref#_1602: ref :: 
        (forall<T#_23> f#_1603: Field (T#_23) :: 
          (Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1602, f#_1603] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1602, f#_1603]) ==> newPredicateMask#_1604[ref#_1602, f#_1603]
        )
      );
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1604;
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      havoc newPredicateMask#_1607;
      assume (forall ref#_1605: ref :: 
        (forall<T#_24> f#_1606: Field (T#_24) :: 
          (Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1605, f#_1606] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1605, f#_1606]) ==> newPredicateMask#_1607[ref#_1605, f#_1606]
        )
      );
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1607;
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    }
    assert {:msg "  588.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1588, this, AVLTreeNode.left);
    assert {:msg "  588.51: Receiver might be null."} true ==> (unfoldingHeap#_1587[this, AVLTreeNode.left] != null);
    assert {:msg "  588.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1588, unfoldingHeap#_1587[this, AVLTreeNode.left], AVLTreeNode.height);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  588.3: Assertion might not hold. The expression at 588.26 might not evaluate to true."} assertHeap#_1577[assertHeap#_1577[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  assertMask#_1578 := exhaleMask#_1582;
  assume IsGoodExhaleState(exhaleHeap#_1581, assertHeap#_1577, assertMask#_1578, exhaledHolds#_1583);
  assertHeap#_1577 := exhaleHeap#_1581;
  assume IsGoodMask(assertMask#_1578);
  assume wf(assertHeap#_1577, assertMask#_1578, assertSecMask#_1579);
  // end exhale
  // assert
  assertHeap#_1608 := Heap;
  assertMask#_1609 := Mask;
  assertSecMask#_1610 := SecMask;
  assertCredits#_1611 := Credits;
  assume wf(assertHeap#_1608, assertMask#_1609, assertSecMask#_1610);
  // begin exhale (assert)
  exhaleMask#_1613 := assertMask#_1609;
  havoc exhaleHeap#_1612;
  exhaledHolds#_1614 := ZeroRefSet;
  assert {:msg "  589.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  589.10: Location might not be readable."} true ==> CanRead(assertMask#_1609, this, AVLTreeNode.right);
  if (!(assertHeap#_1608[this, AVLTreeNode.right] == null)) {
    // unfolding
    assume (0.0 < unfoldingK#_1623) && ((1000.0 * unfoldingK#_1623) < (real(1) * 0.01));
    predFlag#_1622 := true;
    predRec#_1624 := assertHeap#_1608[this, AVLTreeNode.right];
    predVer#_1625 := Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid];
    assert {:msg "  589.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  589.36: Location might not be readable."} true ==> CanRead(assertMask#_1609, this, AVLTreeNode.right);
    assert {:msg "  589.36: Receiver might be null."} true ==> (assertHeap#_1608[this, AVLTreeNode.right] != null);
    unfoldingHeap#_1618 := assertHeap#_1608;
    unfoldingMask#_1619 := assertMask#_1609;
    unfoldingSecMask#_1620 := assertSecMask#_1610;
    unfoldingCredits#_1621 := assertCredits#_1611;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    // begin exhale (unfolding)
    assert {:msg "  589.26: Unfolding might fail. The permission at 589.36 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  589.26: Unfolding might fail. Insufficient fraction at 589.36 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(unfoldingMask#_1619, unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      oldVers#_1630 := unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid];
      havoc newVers#_1631;
      unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_1631;
      assume oldVers#_1630 < unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1618[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume unfoldingHeap#_1618[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume unfoldingHeap#_1618[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume (unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume unfoldingHeap#_1618[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume (unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume unfoldingHeap#_1618[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume unfoldingHeap#_1618[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1624, AVLTreeNode.valid, predVer#_1625, unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#405: int :: 
        (0 <= lk#79#405) && (lk#79#405 < Seq#Length(unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#405) < unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key])
      );
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1624, AVLTreeNode.valid, predVer#_1625, unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1619[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1619);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
      assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#406: int :: 
        (0 <= rk#80#406) && (rk#80#406 < Seq#Length(unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#406))
      );
    }
    if (!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.key]))
    );
    assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_1618[unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1618[unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1619);
    assume wf(unfoldingHeap#_1618, unfoldingMask#_1619, unfoldingSecMask#_1620);
    // end inhale
    Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.key] := true;
    Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
    Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.left] := true;
    Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.right] := true;
    Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
    Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      havoc newPredicateMask#_1635;
      assume (forall ref#_1633: ref :: 
        (forall<T#_25> f#_1634: Field (T#_25) :: 
          (Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1633, f#_1634] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1633, f#_1634]) ==> newPredicateMask#_1635[ref#_1633, f#_1634]
        )
      );
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_1635;
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      havoc newPredicateMask#_1638;
      assume (forall ref#_1636: ref :: 
        (forall<T#_26> f#_1637: Field (T#_26) :: 
          (Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1636, f#_1637] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1636, f#_1637]) ==> newPredicateMask#_1638[ref#_1636, f#_1637]
        )
      );
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_1638;
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    }
    assert {:msg "  589.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  589.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1619, this, AVLTreeNode.right);
    assert {:msg "  589.51: Receiver might be null."} true ==> (unfoldingHeap#_1618[this, AVLTreeNode.right] != null);
    assert {:msg "  589.51: Location might not be readable."} true ==> CanRead(unfoldingMask#_1619, unfoldingHeap#_1618[this, AVLTreeNode.right], AVLTreeNode.height);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  589.3: Assertion might not hold. The expression at 589.26 might not evaluate to true."} assertHeap#_1608[assertHeap#_1608[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assertMask#_1609 := exhaleMask#_1613;
  assume IsGoodExhaleState(exhaleHeap#_1612, assertHeap#_1608, assertMask#_1609, exhaledHolds#_1614);
  assertHeap#_1608 := exhaleHeap#_1612;
  assume IsGoodMask(assertMask#_1609);
  assume wf(assertHeap#_1608, assertMask#_1609, assertSecMask#_1610);
  // end exhale
  // update field height
  assert {:msg "  590.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.height);
  assert {:msg "  590.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  590.18: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  590.35: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.35: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  590.35: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  590.35: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  590.51: Receiver might be null."} true ==> (this != null);
  assert {:msg "  590.51: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  590.69: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.69: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  590.69: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  590.69: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  590.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.89: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    if (Heap[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  590.106: Receiver might be null."} true ==> (this != null);
      assert {:msg "  590.106: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      assert {:msg "  590.106: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
      assert {:msg "  590.106: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  590.126: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.126: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    if (Heap[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  590.144: Receiver might be null."} true ==> (this != null);
      assert {:msg "  590.144: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      assert {:msg "  590.144: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
      assert {:msg "  590.144: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  Heap[this, AVLTreeNode.height] := ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume wf(Heap, Mask, SecMask);
  // update field balanceFactor
  assert {:msg "  592.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  592.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  592.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  592.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  592.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  592.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  592.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  592.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  592.55: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  592.73: Receiver might be null."} true ==> (this != null);
    assert {:msg "  592.73: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  592.73: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  592.73: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  Heap[this, AVLTreeNode.balanceFactor] := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask, SecMask);
  // update field keys
  assert {:msg "  593.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.keys);
  assert {:msg "  593.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  593.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  593.46: Receiver might be null."} true ==> (this != null);
    assert {:msg "  593.46: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  593.46: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  593.46: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  593.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  593.62: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  593.72: Receiver might be null."} true ==> (this != null);
  assert {:msg "  593.72: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  593.97: Receiver might be null."} true ==> (this != null);
    assert {:msg "  593.97: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  593.97: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  593.97: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  Heap[this, AVLTreeNode.keys] := Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_1639 := Heap;
  assertMask#_1640 := Mask;
  assertSecMask#_1641 := SecMask;
  assertCredits#_1642 := Credits;
  assume wf(assertHeap#_1639, assertMask#_1640, assertSecMask#_1641);
  // begin exhale (assert)
  exhaleMask#_1644 := assertMask#_1640;
  havoc exhaleHeap#_1643;
  exhaledHolds#_1645 := ZeroRefSet;
  assert {:msg "  594.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  594.11: Location might not be readable."} true ==> CanRead(assertMask#_1640, this, AVLTreeNode.key);
  assert {:msg "  594.10: Sequence index might be negative."} true ==> (0 <= 0);
  assert {:msg "  594.10: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(assertHeap#_1639[this, AVLTreeNode.key])));
  assert {:msg "  594.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  594.22: Location might not be readable."} true ==> CanRead(assertMask#_1640, this, AVLTreeNode.key);
  assert {:msg "  594.3: Assertion might not hold. The expression at 594.10 might not evaluate to true."} Seq#Index(Seq#Singleton(assertHeap#_1639[this, AVLTreeNode.key]), 0) == assertHeap#_1639[this, AVLTreeNode.key];
  assertMask#_1640 := exhaleMask#_1644;
  assume IsGoodExhaleState(exhaleHeap#_1643, assertHeap#_1639, assertMask#_1640, exhaledHolds#_1645);
  assertHeap#_1639 := exhaleHeap#_1643;
  assume IsGoodMask(assertMask#_1640);
  assume wf(assertHeap#_1639, assertMask#_1640, assertSecMask#_1641);
  // end exhale
  // fold
  assume #AVLTreeNode.valid#trigger(this);
  assume (0.0 < foldK#_1649) && ((1000.0 * foldK#_1649) < (real(1) * 0.01)) && ((1000.0 * foldK#_1649) < methodK#_1569);
  assert {:msg "  595.3: The target of the fold statement might be null."} this != null;
  predRec#_1646 := this;
  predVer#_1647 := Heap[this, AVLTreeNode.valid];
  predFlag#_1648 := true;
  // begin exhale (fold)
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#79#407: int :: 
      (0 <= lk#79#407) && (lk#79#407 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#79#407) < Heap[this, AVLTreeNode.key])
    );
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#80#408: int :: 
      (0 <= rk#80#408) && (rk#80#408 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#80#408))
    );
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#81: int :: 
    Seq#Contains(Heap[this, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[this, AVLTreeNode.key]))
  );
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 117.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.key][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.key][perm$N]));
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 118.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.height][perm$N]));
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 119.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.left][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.left][perm$N]));
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 120.6 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} ((real(100) * 0.01) <= Mask[this, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == Mask[this, AVLTreeNode.right][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.right][perm$N]));
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 122.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.keys][perm$N]));
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 123.6 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[this, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[this, AVLTreeNode.balanceFactor][perm$N]));
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 125.22 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1646, AVLTreeNode.valid, predVer#_1647, Heap[this, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 126.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 127.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 128.22 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 132.23 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1646, AVLTreeNode.valid, predVer#_1647, Heap[this, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 133.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 134.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The permission at 135.23 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  595.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, Mask, SecMask);
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (fold)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.key] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.height] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.left] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.right] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.keys] := true;
  Heap[this, AVLTreeNode.valid#m][this, AVLTreeNode.balanceFactor] := true;
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_1670;
    assume (forall ref#_1668: ref :: 
      (forall<T#_27> f#_1669: Field (T#_27) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1668, f#_1669] || Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1668, f#_1669]) ==> newPredicateMask#_1670[ref#_1668, f#_1669]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1670;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_1673;
    assume (forall ref#_1671: ref :: 
      (forall<T#_28> f#_1672: Field (T#_28) :: 
        (Heap[this, AVLTreeNode.valid#m][ref#_1671, f#_1672] || Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1671, f#_1672]) ==> newPredicateMask#_1673[ref#_1671, f#_1672]
      )
    );
    Heap[this, AVLTreeNode.valid#m] := newPredicateMask#_1673;
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    Heap[this, AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assume wf(Heap, Mask, SecMask);
  // begin exhale (postcondition)
  exhaleMask#_1675 := Mask;
  havoc exhaleHeap#_1674;
  exhaledHolds#_1676 := ZeroRefSet;
  assert {:msg "  543.2: The postcondition at 572.11 might not hold. The expression at 572.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  543.2: The postcondition at 575.11 might not hold. The expression at 575.11 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]), ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  543.2: The postcondition at 582.11 might not hold. The expression at 582.11 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  543.2: The postcondition at 567.11 might not hold. The permission at 567.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  543.2: The postcondition at 567.11 might not hold. Insufficient fraction at 567.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1675[this, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1675[this, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1675[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1675[this, AVLTreeNode.valid] := exhaleMask#_1675[this, AVLTreeNode.valid][perm$R := exhaleMask#_1675[this, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1675, this, AVLTreeNode.valid)) {
    assume Heap[this, AVLTreeNode.valid] < exhaleHeap#_1674[this, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1675, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  543.2: The postcondition at 568.11 might not hold. The permission at 568.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  543.2: The postcondition at 568.11 might not hold. Insufficient fraction at 568.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1675[this, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1675[this, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1675[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_1675[this, AVLTreeNode.height] := exhaleMask#_1675[this, AVLTreeNode.height][perm$R := exhaleMask#_1675[this, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1675, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  543.2: The postcondition at 569.11 might not hold. The permission at 569.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  543.2: The postcondition at 569.11 might not hold. Insufficient fraction at 569.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1675[this, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1675[this, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1675[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1675[this, AVLTreeNode.keys] := exhaleMask#_1675[this, AVLTreeNode.keys][perm$R := exhaleMask#_1675[this, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1675, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  543.2: The postcondition at 570.11 might not hold. The permission at 570.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  543.2: The postcondition at 570.11 might not hold. Insufficient fraction at 570.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1675[this, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1675[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1675[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1675[this, AVLTreeNode.balanceFactor] := exhaleMask#_1675[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1675[this, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1675, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1675;
  assume IsGoodExhaleState(exhaleHeap#_1674, Heap, Mask, exhaledHolds#_1676);
  Heap := exhaleHeap#_1674;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  543.2: Method might lock/unlock more than allowed."} (forall lk#_1681: ref :: 
    { Heap[lk#_1681, held] }
    { Heap[lk#_1681, rdheld] }
    (((0 < Heap[lk#_1681, held]) == (0 < old(Heap)[lk#_1681, held])) && (Heap[lk#_1681, rdheld] == old(Heap)[lk#_1681, rdheld])) || false
  );
  assert {:msg "  543.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.rebalanceLeft
// -------------------------------------------

// definedness check for method AVLTreeNode.rebalanceLeft
procedure AVLTreeNode.rebalanceLeft$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1682: real;
  var k#94#412: int where true;
  var k#95#414: int where true;
  assume (0.0 < methodK#_1682) && ((1000.0 * methodK#_1682) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  608.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  608.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  609.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  609.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  609.12: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
  assert {:msg "  609.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  609.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  610.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  610.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  611.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  611.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  612.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  612.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#412) ==> (this != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#412) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#412) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#412) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  613.12: Receiver might be null."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  613.12: Location might not be readable."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  613.37: Sequence index might be negative."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#94#412);
  assert {:msg "  613.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  613.41: Receiver might be null."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  613.41: Location might not be readable."} true && (0 <= k#94#412) && (k#94#412 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall k#94#411: int :: 
    (0 <= k#94#411) && (k#94#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#94#411) < Heap[this, AVLTreeNode.key])
  );
  assert {:msg "  615.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  615.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  615.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  615.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  615.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  615.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  615.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  616.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  616.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  616.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  616.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  617.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  617.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  617.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  617.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  618.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  618.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  618.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  618.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  619.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  619.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#414) ==> (this != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#414) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#414) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#414) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  619.54: Receiver might be null."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  619.54: Location might not be readable."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  619.12: Receiver might be null."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  619.12: Location might not be readable."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  619.60: Sequence index might be negative."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#95#414);
    assert {:msg "  619.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#95#414) && (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#95#414 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#95#413: int :: 
      (0 <= k#95#413) && (k#95#413 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#95#413))
    );
  }
  assert {:msg "  621.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  621.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  621.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  621.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  621.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  621.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  621.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  621.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  621.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  621.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1685: Field (PMaskType) :: 
    (forall ref#_1684: ref :: 
      Heap[ref#_1684, pmask#_1685] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#63 == null);
  assert {:msg "  624.11: Receiver might be null."} r#63 != null;
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#63, AVLTreeNode.valid] := Mask[r#63, AVLTreeNode.valid][perm$R := Mask[r#63, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#63, AVLTreeNode.height] := Mask[r#63, AVLTreeNode.height][perm$R := Mask[r#63, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#63, AVLTreeNode.keys] := Mask[r#63, AVLTreeNode.keys][perm$R := Mask[r#63, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#63 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#63, AVLTreeNode.balanceFactor] := Mask[r#63, AVLTreeNode.balanceFactor][perm$R := Mask[r#63, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  629.11: Receiver might be null."} true ==> (r#63 != null);
  assert {:msg "  629.11: Location might not be readable."} true ==> CanRead(Mask, r#63, AVLTreeNode.height);
  assert {:msg "  629.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  629.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  629.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  629.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  629.43: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (r#63 != null);
  assert {:msg "  629.43: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(Mask, r#63, AVLTreeNode.height);
  assert {:msg "  629.59: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  629.59: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  629.59: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  629.59: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume (Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#63, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  630.11: Receiver might be null."} true ==> (r#63 != null);
  assert {:msg "  630.11: Location might not be readable."} true ==> CanRead(Mask, r#63, AVLTreeNode.keys);
  assert {:msg "  630.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.25: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  630.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  630.25: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  630.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  630.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.59: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  630.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  630.89: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  630.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  630.89: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#63, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.rebalanceLeft
procedure AVLTreeNode.rebalanceLeft(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1682: real;
  var lbf#65: int where true;
  var methodCallK#_1694: real;
  var this#417: ref where (this#417 == null) || (dtype(this#417) == AVLTreeNode#t);
  var bf#418: int where true;
  var callHeap#_1690: HeapType;
  var callMask#_1691: MaskType;
  var callSecMask#_1692: MaskType;
  var callCredits#_1693: CreditsType;
  var exhaleMask#_1696: MaskType;
  var exhaleHeap#_1695: HeapType;
  var exhaledHolds#_1697: RefSet;
  var isHeld#_1700: int;
  var isRdHeld#_1701: bool;
  var predRec#_1703: ref;
  var predFlag#_1705: bool;
  var predVer#_1704: int;
  var predRec#_1709: ref;
  var predFlag#_1711: bool;
  var predVer#_1710: int;
  var cond#_1715: bool;
  var assertHeap#_1716: HeapType;
  var assertMask#_1717: MaskType;
  var assertSecMask#_1718: MaskType;
  var assertCredits#_1719: CreditsType;
  var exhaleMask#_1721: MaskType;
  var exhaleHeap#_1720: HeapType;
  var exhaledHolds#_1722: RefSet;
  var unfoldingK#_1731: real;
  var predFlag#_1730: bool;
  var predRec#_1732: ref;
  var predVer#_1733: int;
  var unfoldingHeap#_1726: HeapType;
  var unfoldingMask#_1727: MaskType;
  var unfoldingSecMask#_1728: MaskType;
  var unfoldingCredits#_1729: CreditsType;
  var oldVers#_1738: int;
  var newVers#_1739: int;
  var newPredicateMask#_1743: PMaskType;
  var newPredicateMask#_1746: PMaskType;
  var methodCallK#_1751: real;
  var this#427: ref where (this#427 == null) || (dtype(this#427) == AVLTreeNode#t);
  var r#428: ref where (r#428 == null) || (dtype(r#428) == AVLTreeNode#t);
  var callHeap#_1747: HeapType;
  var callMask#_1748: MaskType;
  var callSecMask#_1749: MaskType;
  var callCredits#_1750: CreditsType;
  var exhaleMask#_1753: MaskType;
  var exhaleHeap#_1752: HeapType;
  var exhaledHolds#_1754: RefSet;
  var predRec#_1755: ref;
  var predFlag#_1757: bool;
  var predVer#_1756: int;
  var isHeld#_1772: int;
  var isRdHeld#_1773: bool;
  var methodCallK#_1779: real;
  var this#435: ref where (this#435 == null) || (dtype(this#435) == AVLTreeNode#t);
  var r#436: ref where (r#436 == null) || (dtype(r#436) == AVLTreeNode#t);
  var callHeap#_1775: HeapType;
  var callMask#_1776: MaskType;
  var callSecMask#_1777: MaskType;
  var callCredits#_1778: CreditsType;
  var exhaleMask#_1781: MaskType;
  var exhaleHeap#_1780: HeapType;
  var exhaledHolds#_1782: RefSet;
  var isHeld#_1797: int;
  var isRdHeld#_1798: bool;
  var exhaleMask#_1801: MaskType;
  var exhaleHeap#_1800: HeapType;
  var exhaledHolds#_1802: RefSet;
  assume (0.0 < methodK#_1682) && ((1000.0 * methodK#_1682) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#94#415: int :: 
    (0 <= k#94#415) && (k#94#415 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#94#415) < Heap[this, AVLTreeNode.key])
  );
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#95#416: int :: 
      (0 <= k#95#416) && (k#95#416 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#95#416))
    );
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1689: Field (PMaskType) :: 
    (forall ref#_1688: ref :: 
      Heap[ref#_1688, pmask#_1689] == ZeroPMask
    )
  );
  // local var lbf
  assume (0.0 < methodCallK#_1694) && ((1000.0 * methodCallK#_1694) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1694) < methodK#_1682);
  // call getBalanceFactor
  callHeap#_1690 := Heap;
  callMask#_1691 := Mask;
  callSecMask#_1692 := SecMask;
  callCredits#_1693 := Credits;
  assume wf(callHeap#_1690, callMask#_1691, callSecMask#_1692);
  assert {:msg "  633.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  633.15: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  633.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#417 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_1696 := Mask;
  havoc exhaleHeap#_1695;
  exhaledHolds#_1697 := ZeroRefSet;
  assert {:msg "  633.3: The precondition at 489.12 might not hold. The permission at 489.12 might not be positive."} methodCallK#_1694 > 0.0;
  assert {:msg "  633.3: The precondition at 489.12 might not hold. Insufficient fraction at 489.12 for AVLTreeNode.balanceFactor."} exhaleMask#_1696[this#417, AVLTreeNode.balanceFactor][perm$R] > 0.0;
  assume methodCallK#_1694 < exhaleMask#_1696[this#417, AVLTreeNode.balanceFactor][perm$R];
  exhaleMask#_1696[this#417, AVLTreeNode.balanceFactor] := exhaleMask#_1696[this#417, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1696[this#417, AVLTreeNode.balanceFactor][perm$R] - methodCallK#_1694];
  assume wf(Heap, exhaleMask#_1696, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  633.3: The precondition at 488.12 might not hold. The permission at 488.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  633.3: The precondition at 488.12 might not hold. Insufficient fraction at 488.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1696[this#417, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1696[this#417, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1696[this#417, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1696[this#417, AVLTreeNode.valid] := exhaleMask#_1696[this#417, AVLTreeNode.valid][perm$R := exhaleMask#_1696[this#417, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1696, this#417, AVLTreeNode.valid)) {
    assume Heap[this#417, AVLTreeNode.valid] < exhaleHeap#_1695[this#417, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1696, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1696;
  assume IsGoodExhaleState(exhaleHeap#_1695, Heap, Mask, exhaledHolds#_1697);
  Heap := exhaleHeap#_1695;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  havoc bf#418;
  // inhale (postcondition)
  assume this#417 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#417, AVLTreeNode.valid] := Mask[this#417, AVLTreeNode.valid][perm$R := Mask[this#417, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#417 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodCallK#_1694 > 0.0;
  Mask[this#417, AVLTreeNode.balanceFactor] := Mask[this#417, AVLTreeNode.balanceFactor][perm$R := Mask[this#417, AVLTreeNode.balanceFactor][perm$R] + methodCallK#_1694];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume bf#418 == Heap[this#417, AVLTreeNode.balanceFactor];
  predRec#_1703 := this#417;
  predFlag#_1705 := true;
  assume #AVLTreeNode.valid#trigger(this#417);
  predVer#_1704 := Heap[this#417, AVLTreeNode.valid];
  assume predRec#_1703 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1703, AVLTreeNode.key] := SecMask[predRec#_1703, AVLTreeNode.key][perm$R := SecMask[predRec#_1703, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1703 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1703, AVLTreeNode.height] := SecMask[predRec#_1703, AVLTreeNode.height][perm$R := SecMask[predRec#_1703, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1703 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1703, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1703, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1703, AVLTreeNode.left] := SecMask[predRec#_1703, AVLTreeNode.left][perm$R := SecMask[predRec#_1703, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1703 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1703, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1703, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1703, AVLTreeNode.right] := SecMask[predRec#_1703, AVLTreeNode.right][perm$R := SecMask[predRec#_1703, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1703 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1703, AVLTreeNode.keys] := SecMask[predRec#_1703, AVLTreeNode.keys][perm$R := SecMask[predRec#_1703, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1703 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1703, AVLTreeNode.balanceFactor] := SecMask[predRec#_1703, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1703, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1703, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1703, AVLTreeNode.valid, predVer#_1704, Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.left] == null)) {
    assume (forall lk#79#419: int :: 
      (0 <= lk#79#419) && (lk#79#419 < Seq#Length(Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys], lk#79#419) < Heap[predRec#_1703, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1703, AVLTreeNode.valid, predVer#_1704, Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1703, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.right] == null)) {
    assume (forall rk#80#420: int :: 
      (0 <= rk#80#420) && (rk#80#420 < Seq#Length(Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1703, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys], rk#80#420))
    );
  }
  if (!(Heap[predRec#_1703, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1703, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1703, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1703, AVLTreeNode.key])), ite(Heap[predRec#_1703, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1703, AVLTreeNode.keys], Heap[predRec#_1703, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_1703, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1703, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1703, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1703, AVLTreeNode.key]))
  );
  assume Heap[predRec#_1703, AVLTreeNode.height] == ite(ite(Heap[predRec#_1703, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1703, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1703, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1703, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1703, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1703, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1703, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1703, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1703, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1703, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1703, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1703, AVLTreeNode.height] > 0;
  assume (bf#418 > 0) ==> (!(Heap[this#417, AVLTreeNode.left] == null));
  predRec#_1709 := this#417;
  predFlag#_1711 := true;
  assume #AVLTreeNode.valid#trigger(this#417);
  predVer#_1710 := Heap[this#417, AVLTreeNode.valid];
  assume predRec#_1709 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1709, AVLTreeNode.key] := SecMask[predRec#_1709, AVLTreeNode.key][perm$R := SecMask[predRec#_1709, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1709 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1709, AVLTreeNode.height] := SecMask[predRec#_1709, AVLTreeNode.height][perm$R := SecMask[predRec#_1709, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1709 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1709, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1709, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1709, AVLTreeNode.left] := SecMask[predRec#_1709, AVLTreeNode.left][perm$R := SecMask[predRec#_1709, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1709 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1709, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1709, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1709, AVLTreeNode.right] := SecMask[predRec#_1709, AVLTreeNode.right][perm$R := SecMask[predRec#_1709, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1709 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1709, AVLTreeNode.keys] := SecMask[predRec#_1709, AVLTreeNode.keys][perm$R := SecMask[predRec#_1709, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1709 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1709, AVLTreeNode.balanceFactor] := SecMask[predRec#_1709, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1709, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1709, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1709, AVLTreeNode.valid, predVer#_1710, Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.left] == null)) {
    assume (forall lk#79#421: int :: 
      (0 <= lk#79#421) && (lk#79#421 < Seq#Length(Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys], lk#79#421) < Heap[predRec#_1709, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1709, AVLTreeNode.valid, predVer#_1710, Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1709, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.right] == null)) {
    assume (forall rk#80#422: int :: 
      (0 <= rk#80#422) && (rk#80#422 < Seq#Length(Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1709, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys], rk#80#422))
    );
  }
  if (!(Heap[predRec#_1709, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1709, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1709, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1709, AVLTreeNode.key])), ite(Heap[predRec#_1709, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1709, AVLTreeNode.keys], Heap[predRec#_1709, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_1709, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1709, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1709, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1709, AVLTreeNode.key]))
  );
  assume Heap[predRec#_1709, AVLTreeNode.height] == ite(ite(Heap[predRec#_1709, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1709, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1709, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1709, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1709, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1709, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1709, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1709, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1709, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1709, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1709, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1709, AVLTreeNode.height] > 0;
  assume (bf#418 < 0) ==> (!(Heap[this#417, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  lbf#65 := bf#418;
  // if
  cond#_1715 := lbf#65 < 0;
  if (cond#_1715) {
    // assert
    assertHeap#_1716 := Heap;
    assertMask#_1717 := Mask;
    assertSecMask#_1718 := SecMask;
    assertCredits#_1719 := Credits;
    assume wf(assertHeap#_1716, assertMask#_1717, assertSecMask#_1718);
    // begin exhale (assert)
    exhaleMask#_1721 := assertMask#_1717;
    havoc exhaleHeap#_1720;
    exhaledHolds#_1722 := ZeroRefSet;
    // unfolding
    assume (0.0 < unfoldingK#_1731) && ((1000.0 * unfoldingK#_1731) < (real(1) * 0.01));
    predFlag#_1730 := true;
    predRec#_1732 := assertHeap#_1716[this, AVLTreeNode.left];
    predVer#_1733 := Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid];
    assert {:msg "  635.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  635.21: Location might not be readable."} true ==> CanRead(assertMask#_1717, this, AVLTreeNode.left);
    assert {:msg "  635.21: Receiver might be null."} true ==> (assertHeap#_1716[this, AVLTreeNode.left] != null);
    unfoldingHeap#_1726 := assertHeap#_1716;
    unfoldingMask#_1727 := assertMask#_1717;
    unfoldingSecMask#_1728 := assertSecMask#_1718;
    unfoldingCredits#_1729 := assertCredits#_1719;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    // begin exhale (unfolding)
    assert {:msg "  635.11: Unfolding might fail. The permission at 635.21 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  635.11: Unfolding might fail. Insufficient fraction at 635.21 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(unfoldingMask#_1727, unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid)) {
      oldVers#_1738 := unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid];
      havoc newVers#_1739;
      unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1739;
      assume oldVers#_1738 < unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_1726[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume unfoldingHeap#_1726[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume unfoldingHeap#_1726[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume (unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume unfoldingHeap#_1726[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume (unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume unfoldingHeap#_1726[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume unfoldingHeap#_1726[this, AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1732, AVLTreeNode.valid, predVer#_1733, unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume (forall lk#79#425: int :: 
        (0 <= lk#79#425) && (lk#79#425 < Seq#Length(unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#425) < unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key])
      );
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1732, AVLTreeNode.valid, predVer#_1733, unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1727[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_1727);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
      assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume (forall rk#80#426: int :: 
        (0 <= rk#80#426) && (rk#80#426 < Seq#Length(unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#426))
      );
    }
    if (!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.key]))
    );
    assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1726[unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_1726[unfoldingHeap#_1726[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_1727);
    assume wf(unfoldingHeap#_1726, unfoldingMask#_1727, unfoldingSecMask#_1728);
    // end inhale
    Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.key] := true;
    Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
    Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.left] := true;
    Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.right] := true;
    Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
    Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      havoc newPredicateMask#_1743;
      assume (forall ref#_1741: ref :: 
        (forall<T#_29> f#_1742: Field (T#_29) :: 
          (Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1741, f#_1742] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1741, f#_1742]) ==> newPredicateMask#_1743[ref#_1741, f#_1742]
        )
      );
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1743;
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      havoc newPredicateMask#_1746;
      assume (forall ref#_1744: ref :: 
        (forall<T#_30> f#_1745: Field (T#_30) :: 
          (Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1744, f#_1745] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1744, f#_1745]) ==> newPredicateMask#_1746[ref#_1744, f#_1745]
        )
      );
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1746;
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_1716[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    }
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  635.4: Assertion might not hold. The expression at 635.11 might not evaluate to true."} lbf#65 == (0 - 1);
    assertMask#_1717 := exhaleMask#_1721;
    assume IsGoodExhaleState(exhaleHeap#_1720, assertHeap#_1716, assertMask#_1717, exhaledHolds#_1722);
    assertHeap#_1716 := exhaleHeap#_1720;
    assume IsGoodMask(assertMask#_1717);
    assume wf(assertHeap#_1716, assertMask#_1717, assertSecMask#_1718);
    // end exhale
    assume (0.0 < methodCallK#_1751) && ((1000.0 * methodCallK#_1751) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1751) < methodK#_1682);
    // call rebalanceRL
    callHeap#_1747 := Heap;
    callMask#_1748 := Mask;
    callSecMask#_1749 := SecMask;
    callCredits#_1750 := Credits;
    assume wf(callHeap#_1747, callMask#_1748, callSecMask#_1749);
    assert {:msg "  636.4: The target of the method call might be null."} this != null;
    this#427 := this;
    // begin exhale (precondition)
    exhaleMask#_1753 := Mask;
    havoc exhaleHeap#_1752;
    exhaledHolds#_1754 := ZeroRefSet;
    assert {:msg "  636.4: The precondition at 652.12 might not hold. The expression at 652.12 might not evaluate to true."} !(Heap[this#427, AVLTreeNode.left] == null);
    assert {:msg "  636.4: The precondition at 657.12 might not hold. The expression at 657.12 might not evaluate to true."} (forall k#96#429: int :: 
      (0 <= k#96#429) && (k#96#429 < Seq#Length(Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys], k#96#429) < Heap[this#427, AVLTreeNode.key])
    );
    if (!(Heap[this#427, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 663.12 might not hold. The expression at 663.28 might not evaluate to true."} (forall k#97#430: int :: 
        (0 <= k#97#430) && (k#97#430 < Seq#Length(Heap[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#427, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys], k#97#430))
      );
    }
    predRec#_1755 := Heap[this#427, AVLTreeNode.left];
    predFlag#_1757 := true;
    assume #AVLTreeNode.valid#trigger(Heap[this#427, AVLTreeNode.left]);
    predVer#_1756 := Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid];
    assume predRec#_1755 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    SecMask[predRec#_1755, AVLTreeNode.key] := SecMask[predRec#_1755, AVLTreeNode.key][perm$R := SecMask[predRec#_1755, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_1755 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[predRec#_1755, AVLTreeNode.height] := SecMask[predRec#_1755, AVLTreeNode.height][perm$R := SecMask[predRec#_1755, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_1755 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[predRec#_1755, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1755, AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    SecMask[predRec#_1755, AVLTreeNode.left] := SecMask[predRec#_1755, AVLTreeNode.left][perm$R := SecMask[predRec#_1755, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_1755 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[predRec#_1755, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1755, AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    SecMask[predRec#_1755, AVLTreeNode.right] := SecMask[predRec#_1755, AVLTreeNode.right][perm$R := SecMask[predRec#_1755, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_1755 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[predRec#_1755, AVLTreeNode.keys] := SecMask[predRec#_1755, AVLTreeNode.keys][perm$R := SecMask[predRec#_1755, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_1755 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[predRec#_1755, AVLTreeNode.balanceFactor] := SecMask[predRec#_1755, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1755, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[predRec#_1755, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1755, AVLTreeNode.valid, predVer#_1756, Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.left] == null)) {
      assume (forall lk#79#431: int :: 
        (0 <= lk#79#431) && (lk#79#431 < Seq#Length(Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys], lk#79#431) < Heap[predRec#_1755, AVLTreeNode.key])
      );
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.left] == null)) {
      assume Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_1755, AVLTreeNode.valid, predVer#_1756, Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_1755, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.right] == null)) {
      assume (forall rk#80#432: int :: 
        (0 <= rk#80#432) && (rk#80#432 < Seq#Length(Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1755, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys], rk#80#432))
      );
    }
    if (!(Heap[predRec#_1755, AVLTreeNode.right] == null)) {
      assume Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(Heap[predRec#_1755, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1755, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1755, AVLTreeNode.key])), ite(Heap[predRec#_1755, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(Heap[predRec#_1755, AVLTreeNode.keys], Heap[predRec#_1755, AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(Heap[predRec#_1755, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1755, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1755, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1755, AVLTreeNode.key]))
    );
    assume Heap[predRec#_1755, AVLTreeNode.height] == ite(ite(Heap[predRec#_1755, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1755, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1755, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1755, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[predRec#_1755, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1755, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1755, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1755, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1755, AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap[predRec#_1755, AVLTreeNode.balanceFactor] <= 1;
    assume Heap[predRec#_1755, AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap[predRec#_1755, AVLTreeNode.height] > 0;
    assert {:msg "  636.4: The precondition at 665.12 might not hold. The expression at 665.12 might not evaluate to true."} !(Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.right] == null);
    assert {:msg "  636.4: The precondition at 667.12 might not hold. The expression at 667.12 might not evaluate to true."} (Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#427, AVLTreeNode.right] == null, 0, Heap[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height])) == 2;
    assert {:msg "  636.4: The precondition at 668.12 might not hold. The expression at 668.12 might not evaluate to true."} Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
    assert {:msg "  636.4: The precondition at 644.12 might not hold. The permission at 644.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 644.12 might not hold. Insufficient fraction at 644.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1753[this#427, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[this#427, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1753[this#427, AVLTreeNode.key][perm$N]));
    exhaleMask#_1753[this#427, AVLTreeNode.key] := exhaleMask#_1753[this#427, AVLTreeNode.key][perm$R := exhaleMask#_1753[this#427, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 645.12 might not hold. The permission at 645.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 645.12 might not hold. Insufficient fraction at 645.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1753[this#427, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[this#427, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1753[this#427, AVLTreeNode.height][perm$N]));
    exhaleMask#_1753[this#427, AVLTreeNode.height] := exhaleMask#_1753[this#427, AVLTreeNode.height][perm$R := exhaleMask#_1753[this#427, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 646.12 might not hold. The permission at 646.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 646.12 might not hold. Insufficient fraction at 646.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1753[this#427, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[this#427, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1753[this#427, AVLTreeNode.left][perm$N]));
    exhaleMask#_1753[this#427, AVLTreeNode.left] := exhaleMask#_1753[this#427, AVLTreeNode.left][perm$R := exhaleMask#_1753[this#427, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 647.12 might not hold. The permission at 647.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 647.12 might not hold. Insufficient fraction at 647.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1753[this#427, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[this#427, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1753[this#427, AVLTreeNode.right][perm$N]));
    exhaleMask#_1753[this#427, AVLTreeNode.right] := exhaleMask#_1753[this#427, AVLTreeNode.right][perm$R := exhaleMask#_1753[this#427, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 649.12 might not hold. The permission at 649.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 649.12 might not hold. Insufficient fraction at 649.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1753[this#427, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[this#427, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1753[this#427, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1753[this#427, AVLTreeNode.keys] := exhaleMask#_1753[this#427, AVLTreeNode.keys][perm$R := exhaleMask#_1753[this#427, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 650.12 might not hold. The permission at 650.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 650.12 might not hold. Insufficient fraction at 650.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1753[this#427, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[this#427, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1753[this#427, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1753[this#427, AVLTreeNode.balanceFactor] := exhaleMask#_1753[this#427, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1753[this#427, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 653.12 might not hold. The permission at 653.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 653.12 might not hold. Insufficient fraction at 653.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1753, Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1752[Heap[this#427, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 654.12 might not hold. The permission at 654.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 654.12 might not hold. Insufficient fraction at 654.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 655.12 might not hold. The permission at 655.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 655.12 might not hold. Insufficient fraction at 655.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  636.4: The precondition at 656.12 might not hold. The permission at 656.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  636.4: The precondition at 656.12 might not hold. Insufficient fraction at 656.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1753, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#427, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 659.12 might not hold. The permission at 659.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  636.4: The precondition at 659.12 might not hold. Insufficient fraction at 659.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1753, Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1752[Heap[this#427, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1753, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#427, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 660.12 might not hold. The permission at 660.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  636.4: The precondition at 660.12 might not hold. Insufficient fraction at 660.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1753, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#427, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 661.12 might not hold. The permission at 661.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  636.4: The precondition at 661.12 might not hold. Insufficient fraction at 661.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1753, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#427, AVLTreeNode.right] == null)) {
      assert {:msg "  636.4: The precondition at 662.12 might not hold. The permission at 662.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  636.4: The precondition at 662.12 might not hold. Insufficient fraction at 662.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1753[Heap[this#427, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1753, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1753;
    assume IsGoodExhaleState(exhaleHeap#_1752, Heap, Mask, exhaledHolds#_1754);
    Heap := exhaleHeap#_1752;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#428;
    // inhale (postcondition)
    assume !(r#428 == null);
    assume r#428 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#428, AVLTreeNode.valid] := Mask[r#428, AVLTreeNode.valid][perm$R := Mask[r#428, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#428 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#428, AVLTreeNode.height] := Mask[r#428, AVLTreeNode.height][perm$R := Mask[r#428, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#428 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#428, AVLTreeNode.keys] := Mask[r#428, AVLTreeNode.keys][perm$R := Mask[r#428, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#428 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#428, AVLTreeNode.balanceFactor] := Mask[r#428, AVLTreeNode.balanceFactor][perm$R := Mask[r#428, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[r#428, AVLTreeNode.height] == callHeap#_1747[callHeap#_1747[this#427, AVLTreeNode.left], AVLTreeNode.height];
    assume Seq#Equal(Heap[r#428, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_1747[callHeap#_1747[this#427, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_1747[this#427, AVLTreeNode.key])), ite(callHeap#_1747[this#427, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1747[callHeap#_1747[this#427, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#63 := r#428;
  } else {
    assume (0.0 < methodCallK#_1779) && ((1000.0 * methodCallK#_1779) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1779) < methodK#_1682);
    // call rebalanceRR
    callHeap#_1775 := Heap;
    callMask#_1776 := Mask;
    callSecMask#_1777 := SecMask;
    callCredits#_1778 := Credits;
    assume wf(callHeap#_1775, callMask#_1776, callSecMask#_1777);
    assert {:msg "  638.4: The target of the method call might be null."} this != null;
    this#435 := this;
    // begin exhale (precondition)
    exhaleMask#_1781 := Mask;
    havoc exhaleHeap#_1780;
    exhaledHolds#_1782 := ZeroRefSet;
    assert {:msg "  638.4: The precondition at 710.12 might not hold. The expression at 710.12 might not evaluate to true."} !(Heap[this#435, AVLTreeNode.left] == null);
    assert {:msg "  638.4: The precondition at 715.12 might not hold. The expression at 715.12 might not evaluate to true."} (forall k#102#437: int :: 
      (0 <= k#102#437) && (k#102#437 < Seq#Length(Heap[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys], k#102#437) < Heap[this#435, AVLTreeNode.key])
    );
    if (!(Heap[this#435, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 721.12 might not hold. The expression at 721.28 might not evaluate to true."} (forall k#103#438: int :: 
        (0 <= k#103#438) && (k#103#438 < Seq#Length(Heap[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#435, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys], k#103#438))
      );
    }
    assert {:msg "  638.4: The precondition at 723.12 might not hold. The expression at 723.12 might not evaluate to true."} (Heap[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#435, AVLTreeNode.right] == null, 0, Heap[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height])) == 2;
    assert {:msg "  638.4: The precondition at 724.12 might not hold. The expression at 724.12 might not evaluate to true."} Heap[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
    assert {:msg "  638.4: The precondition at 702.12 might not hold. The permission at 702.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 702.12 might not hold. Insufficient fraction at 702.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1781[this#435, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[this#435, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1781[this#435, AVLTreeNode.key][perm$N]));
    exhaleMask#_1781[this#435, AVLTreeNode.key] := exhaleMask#_1781[this#435, AVLTreeNode.key][perm$R := exhaleMask#_1781[this#435, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 703.12 might not hold. The permission at 703.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 703.12 might not hold. Insufficient fraction at 703.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1781[this#435, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[this#435, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1781[this#435, AVLTreeNode.height][perm$N]));
    exhaleMask#_1781[this#435, AVLTreeNode.height] := exhaleMask#_1781[this#435, AVLTreeNode.height][perm$R := exhaleMask#_1781[this#435, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 704.12 might not hold. The permission at 704.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 704.12 might not hold. Insufficient fraction at 704.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1781[this#435, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[this#435, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1781[this#435, AVLTreeNode.left][perm$N]));
    exhaleMask#_1781[this#435, AVLTreeNode.left] := exhaleMask#_1781[this#435, AVLTreeNode.left][perm$R := exhaleMask#_1781[this#435, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 705.12 might not hold. The permission at 705.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 705.12 might not hold. Insufficient fraction at 705.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1781[this#435, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[this#435, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1781[this#435, AVLTreeNode.right][perm$N]));
    exhaleMask#_1781[this#435, AVLTreeNode.right] := exhaleMask#_1781[this#435, AVLTreeNode.right][perm$R := exhaleMask#_1781[this#435, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 707.12 might not hold. The permission at 707.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 707.12 might not hold. Insufficient fraction at 707.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1781[this#435, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[this#435, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1781[this#435, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1781[this#435, AVLTreeNode.keys] := exhaleMask#_1781[this#435, AVLTreeNode.keys][perm$R := exhaleMask#_1781[this#435, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 708.12 might not hold. The permission at 708.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 708.12 might not hold. Insufficient fraction at 708.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1781[this#435, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[this#435, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1781[this#435, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1781[this#435, AVLTreeNode.balanceFactor] := exhaleMask#_1781[this#435, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1781[this#435, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 711.12 might not hold. The permission at 711.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 711.12 might not hold. Insufficient fraction at 711.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1781, Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1780[Heap[this#435, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 712.12 might not hold. The permission at 712.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 712.12 might not hold. Insufficient fraction at 712.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 713.12 might not hold. The permission at 713.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 713.12 might not hold. Insufficient fraction at 713.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  638.4: The precondition at 714.12 might not hold. The permission at 714.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  638.4: The precondition at 714.12 might not hold. Insufficient fraction at 714.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1781, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#435, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 717.12 might not hold. The permission at 717.28 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  638.4: The precondition at 717.12 might not hold. Insufficient fraction at 717.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_1781, Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid)) {
        assume Heap[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1780[Heap[this#435, AVLTreeNode.right], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_1781, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#435, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 718.12 might not hold. The permission at 718.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  638.4: The precondition at 718.12 might not hold. Insufficient fraction at 718.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1781, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#435, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 719.12 might not hold. The permission at 719.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  638.4: The precondition at 719.12 might not hold. Insufficient fraction at 719.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1781, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#435, AVLTreeNode.right] == null)) {
      assert {:msg "  638.4: The precondition at 720.12 might not hold. The permission at 720.28 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  638.4: The precondition at 720.12 might not hold. Insufficient fraction at 720.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1781[Heap[this#435, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_1781, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    Mask := exhaleMask#_1781;
    assume IsGoodExhaleState(exhaleHeap#_1780, Heap, Mask, exhaledHolds#_1782);
    Heap := exhaleHeap#_1780;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#436;
    // inhale (postcondition)
    assume !(r#436 == null);
    assume r#436 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#436, AVLTreeNode.valid] := Mask[r#436, AVLTreeNode.valid][perm$R := Mask[r#436, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#436 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#436, AVLTreeNode.height] := Mask[r#436, AVLTreeNode.height][perm$R := Mask[r#436, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#436 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#436, AVLTreeNode.keys] := Mask[r#436, AVLTreeNode.keys][perm$R := Mask[r#436, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#436 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#436, AVLTreeNode.balanceFactor] := Mask[r#436, AVLTreeNode.balanceFactor][perm$R := Mask[r#436, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume (Heap[r#436, AVLTreeNode.height] == callHeap#_1775[callHeap#_1775[this#435, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#436, AVLTreeNode.height] == (callHeap#_1775[callHeap#_1775[this#435, AVLTreeNode.left], AVLTreeNode.height] + 1));
    assume Seq#Equal(Heap[r#436, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_1775[callHeap#_1775[this#435, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_1775[this#435, AVLTreeNode.key])), ite(callHeap#_1775[this#435, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1775[callHeap#_1775[this#435, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#63 := r#436;
  }
  // begin exhale (postcondition)
  exhaleMask#_1801 := Mask;
  havoc exhaleHeap#_1800;
  exhaledHolds#_1802 := ZeroRefSet;
  assert {:msg "  599.2: The postcondition at 623.11 might not hold. The expression at 623.11 might not evaluate to true."} !(r#63 == null);
  assert {:msg "  599.2: The postcondition at 629.11 might not hold. The expression at 629.11 might not evaluate to true."} (Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#63, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  599.2: The postcondition at 630.11 might not hold. The expression at 630.11 might not evaluate to true."} Seq#Equal(Heap[r#63, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  599.2: The postcondition at 624.11 might not hold. The permission at 624.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  599.2: The postcondition at 624.11 might not hold. Insufficient fraction at 624.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1801[r#63, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1801[r#63, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1801[r#63, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1801[r#63, AVLTreeNode.valid] := exhaleMask#_1801[r#63, AVLTreeNode.valid][perm$R := exhaleMask#_1801[r#63, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1801, r#63, AVLTreeNode.valid)) {
    assume Heap[r#63, AVLTreeNode.valid] < exhaleHeap#_1800[r#63, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1801, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  599.2: The postcondition at 625.11 might not hold. The permission at 625.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  599.2: The postcondition at 625.11 might not hold. Insufficient fraction at 625.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1801[r#63, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1801[r#63, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1801[r#63, AVLTreeNode.height][perm$N]));
  exhaleMask#_1801[r#63, AVLTreeNode.height] := exhaleMask#_1801[r#63, AVLTreeNode.height][perm$R := exhaleMask#_1801[r#63, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1801, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  599.2: The postcondition at 626.11 might not hold. The permission at 626.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  599.2: The postcondition at 626.11 might not hold. Insufficient fraction at 626.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1801[r#63, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1801[r#63, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1801[r#63, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1801[r#63, AVLTreeNode.keys] := exhaleMask#_1801[r#63, AVLTreeNode.keys][perm$R := exhaleMask#_1801[r#63, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1801, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  599.2: The postcondition at 627.11 might not hold. The permission at 627.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  599.2: The postcondition at 627.11 might not hold. Insufficient fraction at 627.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1801[r#63, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1801[r#63, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1801[r#63, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1801[r#63, AVLTreeNode.balanceFactor] := exhaleMask#_1801[r#63, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1801[r#63, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1801, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1801;
  assume IsGoodExhaleState(exhaleHeap#_1800, Heap, Mask, exhaledHolds#_1802);
  Heap := exhaleHeap#_1800;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  599.2: Method might lock/unlock more than allowed."} (forall lk#_1807: ref :: 
    { Heap[lk#_1807, held] }
    { Heap[lk#_1807, rdheld] }
    (((0 < Heap[lk#_1807, held]) == (0 < old(Heap)[lk#_1807, held])) && (Heap[lk#_1807, rdheld] == old(Heap)[lk#_1807, rdheld])) || false
  );
  assert {:msg "  599.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.rebalanceRL
// -------------------------------------------

// definedness check for method AVLTreeNode.rebalanceRL
procedure AVLTreeNode.rebalanceRL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1808: real;
  var k#96#442: int where true;
  var k#97#444: int where true;
  var predRec#_1810: ref;
  var predFlag#_1812: bool;
  var predVer#_1811: int;
  var unfoldingK#_1818: real;
  var predFlag#_1817: bool;
  var predRec#_1819: ref;
  var predVer#_1820: int;
  var unfoldingHeap#_1813: HeapType;
  var unfoldingMask#_1814: MaskType;
  var unfoldingSecMask#_1815: MaskType;
  var unfoldingCredits#_1816: CreditsType;
  var oldVers#_1825: int;
  var newVers#_1826: int;
  var newPredicateMask#_1830: PMaskType;
  var newPredicateMask#_1833: PMaskType;
  assume (0.0 < methodK#_1808) && ((1000.0 * methodK#_1808) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  652.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  652.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  653.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  653.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  653.12: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
  assert {:msg "  653.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  653.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  654.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  654.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  655.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  655.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  656.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  656.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#442) ==> (this != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#442) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#442) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#442) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  657.12: Receiver might be null."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  657.12: Location might not be readable."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  657.37: Sequence index might be negative."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#96#442);
  assert {:msg "  657.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  657.41: Receiver might be null."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  657.41: Location might not be readable."} true && (0 <= k#96#442) && (k#96#442 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall k#96#441: int :: 
    (0 <= k#96#441) && (k#96#441 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#96#441) < Heap[this, AVLTreeNode.key])
  );
  assert {:msg "  659.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  659.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  659.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  659.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  659.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  659.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  659.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  660.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  660.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  660.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  660.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  661.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  661.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  661.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  661.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  662.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  662.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  662.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  663.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  663.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#444) ==> (this != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#444) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#444) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#444) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  663.54: Receiver might be null."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  663.54: Location might not be readable."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  663.12: Receiver might be null."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  663.12: Location might not be readable."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  663.60: Sequence index might be negative."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#97#444);
    assert {:msg "  663.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#97#444) && (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#97#444 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#97#443: int :: 
      (0 <= k#97#443) && (k#97#443 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#97#443))
    );
  }
  predRec#_1810 := Heap[this, AVLTreeNode.left];
  predFlag#_1812 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  predVer#_1811 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  // unfolding
  assume (0.0 < unfoldingK#_1818) && ((1000.0 * unfoldingK#_1818) < (real(1) * 0.01));
  predFlag#_1817 := true;
  predRec#_1819 := Heap[this, AVLTreeNode.left];
  predVer#_1820 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assert {:msg "  665.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  665.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  665.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  unfoldingHeap#_1813 := Heap;
  unfoldingMask#_1814 := Mask;
  unfoldingSecMask#_1815 := SecMask;
  unfoldingCredits#_1816 := Credits;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  // begin exhale (unfolding)
  assert {:msg "  665.12: Unfolding might fail. The permission at 665.22 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  665.12: Unfolding might fail. Insufficient fraction at 665.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(unfoldingMask#_1814, unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid)) {
    oldVers#_1825 := unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid];
    havoc newVers#_1826;
    unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1826;
    assume oldVers#_1825 < unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.valid];
  }
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  // end exhale
  // inhale (unfolding)
  assume unfoldingHeap#_1813[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume unfoldingHeap#_1813[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume unfoldingHeap#_1813[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume (unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume unfoldingHeap#_1813[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume (unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume unfoldingHeap#_1813[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume unfoldingHeap#_1813[this, AVLTreeNode.left] != null;
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1819, AVLTreeNode.valid, predVer#_1820, unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#445: int :: 
      (0 <= lk#79#445) && (lk#79#445 < Seq#Length(unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#445) < unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key])
    );
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1819, AVLTreeNode.valid, predVer#_1820, unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_1814[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_1814);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
    assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#446: int :: 
      (0 <= rk#80#446) && (rk#80#446 < Seq#Length(unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#446))
    );
  }
  if (!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key])), ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.keys], unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.key]))
  );
  assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, unfoldingHeap#_1813[unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_1813[unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_1814);
  assume wf(unfoldingHeap#_1813, unfoldingMask#_1814, unfoldingSecMask#_1815);
  // end inhale
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.key] := true;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.height] := true;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.left] := true;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.right] := true;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := true;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_1830;
    assume (forall ref#_1828: ref :: 
      (forall<T#_31> f#_1829: Field (T#_31) :: 
        (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1828, f#_1829] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1828, f#_1829]) ==> newPredicateMask#_1830[ref#_1828, f#_1829]
      )
    );
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1830;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_1833;
    assume (forall ref#_1831: ref :: 
      (forall<T#_32> f#_1832: Field (T#_32) :: 
        (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][ref#_1831, f#_1832] || Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_1831, f#_1832]) ==> newPredicateMask#_1833[ref#_1831, f#_1832]
      )
    );
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m] := newPredicateMask#_1833;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assert {:msg "  665.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  665.36: Location might not be readable."} true ==> CanRead(unfoldingMask#_1814, this, AVLTreeNode.left);
  assert {:msg "  665.36: Receiver might be null."} true ==> (unfoldingHeap#_1813[this, AVLTreeNode.left] != null);
  assert {:msg "  665.36: Location might not be readable."} true ==> CanRead(unfoldingMask#_1814, unfoldingHeap#_1813[this, AVLTreeNode.left], AVLTreeNode.right);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null);
  assert {:msg "  667.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  667.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  667.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  667.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  667.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  667.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  667.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  667.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  667.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  667.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assert {:msg "  668.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  668.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  668.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  668.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1838: Field (PMaskType) :: 
    (forall ref#_1837: ref :: 
      Heap[ref#_1837, pmask#_1838] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#66 == null);
  assert {:msg "  671.11: Receiver might be null."} r#66 != null;
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.valid] := Mask[r#66, AVLTreeNode.valid][perm$R := Mask[r#66, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.height] := Mask[r#66, AVLTreeNode.height][perm$R := Mask[r#66, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.keys] := Mask[r#66, AVLTreeNode.keys][perm$R := Mask[r#66, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.balanceFactor] := Mask[r#66, AVLTreeNode.balanceFactor][perm$R := Mask[r#66, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  676.11: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  676.11: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.height);
  assert {:msg "  676.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  676.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  676.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  676.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume Heap[r#66, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height];
  assert {:msg "  677.11: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  677.11: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.keys);
  assert {:msg "  677.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.25: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  677.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  677.25: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  677.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  677.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.59: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  677.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  677.89: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  677.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  677.89: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.rebalanceRL
procedure AVLTreeNode.rebalanceRL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1808: real;
  var predRec#_1841: ref;
  var predFlag#_1843: bool;
  var predVer#_1842: int;
  var assertHeap#_1849: HeapType;
  var assertMask#_1850: MaskType;
  var assertSecMask#_1851: MaskType;
  var assertCredits#_1852: CreditsType;
  var exhaleMask#_1854: MaskType;
  var exhaleHeap#_1853: HeapType;
  var exhaledHolds#_1855: RefSet;
  var k#98#452: int where true;
  var predRec#_1857: ref;
  var predVer#_1858: int;
  var unfoldK#_1856: real;
  var oldVers#_1863: int;
  var newVers#_1864: int;
  var assertHeap#_1866: HeapType;
  var assertMask#_1867: MaskType;
  var assertSecMask#_1868: MaskType;
  var assertCredits#_1869: CreditsType;
  var exhaleMask#_1871: MaskType;
  var exhaleHeap#_1870: HeapType;
  var exhaledHolds#_1872: RefSet;
  var k#99#457: int where true;
  var predRec#_1874: ref;
  var predVer#_1875: int;
  var unfoldK#_1873: real;
  var oldVers#_1880: int;
  var newVers#_1881: int;
  var assertHeap#_1883: HeapType;
  var assertMask#_1884: MaskType;
  var assertSecMask#_1885: MaskType;
  var assertCredits#_1886: CreditsType;
  var exhaleMask#_1888: MaskType;
  var exhaleHeap#_1887: HeapType;
  var exhaledHolds#_1889: RefSet;
  var k#100#462: int where true;
  var methodCallK#_1894: real;
  var this#464: ref where (this#464 == null) || (dtype(this#464) == AVLTreeNode#t);
  var callHeap#_1890: HeapType;
  var callMask#_1891: MaskType;
  var callSecMask#_1892: MaskType;
  var callCredits#_1893: CreditsType;
  var exhaleMask#_1896: MaskType;
  var exhaleHeap#_1895: HeapType;
  var exhaledHolds#_1897: RefSet;
  var isHeld#_1912: int;
  var isRdHeld#_1913: bool;
  var assertHeap#_1915: HeapType;
  var assertMask#_1916: MaskType;
  var assertSecMask#_1917: MaskType;
  var assertCredits#_1918: CreditsType;
  var exhaleMask#_1920: MaskType;
  var exhaleHeap#_1919: HeapType;
  var exhaledHolds#_1921: RefSet;
  var k#101#470: int where true;
  var methodCallK#_1926: real;
  var this#472: ref where (this#472 == null) || (dtype(this#472) == AVLTreeNode#t);
  var callHeap#_1922: HeapType;
  var callMask#_1923: MaskType;
  var callSecMask#_1924: MaskType;
  var callCredits#_1925: CreditsType;
  var exhaleMask#_1928: MaskType;
  var exhaleHeap#_1927: HeapType;
  var exhaledHolds#_1929: RefSet;
  var isHeld#_1944: int;
  var isRdHeld#_1945: bool;
  var methodCallK#_1951: real;
  var this#477: ref where (this#477 == null) || (dtype(this#477) == AVLTreeNode#t);
  var callHeap#_1947: HeapType;
  var callMask#_1948: MaskType;
  var callSecMask#_1949: MaskType;
  var callCredits#_1950: CreditsType;
  var exhaleMask#_1953: MaskType;
  var exhaleHeap#_1952: HeapType;
  var exhaledHolds#_1954: RefSet;
  var isHeld#_1969: int;
  var isRdHeld#_1970: bool;
  var exhaleMask#_1973: MaskType;
  var exhaleHeap#_1972: HeapType;
  var exhaledHolds#_1974: RefSet;
  assume (0.0 < methodK#_1808) && ((1000.0 * methodK#_1808) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#96#447: int :: 
    (0 <= k#96#447) && (k#96#447 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#96#447) < Heap[this, AVLTreeNode.key])
  );
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#97#448: int :: 
      (0 <= k#97#448) && (k#97#448 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#97#448))
    );
  }
  predRec#_1841 := Heap[this, AVLTreeNode.left];
  predFlag#_1843 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  predVer#_1842 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume predRec#_1841 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1841, AVLTreeNode.key] := SecMask[predRec#_1841, AVLTreeNode.key][perm$R := SecMask[predRec#_1841, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1841 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1841, AVLTreeNode.height] := SecMask[predRec#_1841, AVLTreeNode.height][perm$R := SecMask[predRec#_1841, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1841 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1841, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_1841, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1841, AVLTreeNode.left] := SecMask[predRec#_1841, AVLTreeNode.left][perm$R := SecMask[predRec#_1841, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1841 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_1841, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_1841, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_1841, AVLTreeNode.right] := SecMask[predRec#_1841, AVLTreeNode.right][perm$R := SecMask[predRec#_1841, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1841 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1841, AVLTreeNode.keys] := SecMask[predRec#_1841, AVLTreeNode.keys][perm$R := SecMask[predRec#_1841, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_1841 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_1841, AVLTreeNode.balanceFactor] := SecMask[predRec#_1841, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_1841, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_1841, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1841, AVLTreeNode.valid, predVer#_1842, Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.left] == null)) {
    assume (forall lk#79#449: int :: 
      (0 <= lk#79#449) && (lk#79#449 < Seq#Length(Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys], lk#79#449) < Heap[predRec#_1841, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1841, AVLTreeNode.valid, predVer#_1842, Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_1841, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.right] == null)) {
    assume (forall rk#80#450: int :: 
      (0 <= rk#80#450) && (rk#80#450 < Seq#Length(Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_1841, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys], rk#80#450))
    );
  }
  if (!(Heap[predRec#_1841, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_1841, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_1841, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_1841, AVLTreeNode.key])), ite(Heap[predRec#_1841, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_1841, AVLTreeNode.keys], Heap[predRec#_1841, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_1841, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_1841, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_1841, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_1841, AVLTreeNode.key]))
  );
  assume Heap[predRec#_1841, AVLTreeNode.height] == ite(ite(Heap[predRec#_1841, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_1841, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_1841, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_1841, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_1841, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_1841, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_1841, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_1841, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_1841, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_1841, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_1841, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_1841, AVLTreeNode.height] > 0;
  assume !(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1848: Field (PMaskType) :: 
    (forall ref#_1847: ref :: 
      Heap[ref#_1847, pmask#_1848] == ZeroPMask
    )
  );
  // assert
  assertHeap#_1849 := Heap;
  assertMask#_1850 := Mask;
  assertSecMask#_1851 := SecMask;
  assertCredits#_1852 := Credits;
  assume wf(assertHeap#_1849, assertMask#_1850, assertSecMask#_1851);
  // begin exhale (assert)
  exhaleMask#_1854 := assertMask#_1850;
  havoc exhaleHeap#_1853;
  exhaledHolds#_1855 := ZeroRefSet;
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#452) ==> (this != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#452) ==> CanRead(assertMask#_1850, this, AVLTreeNode.left);
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#452) ==> (assertHeap#_1849[this, AVLTreeNode.left] != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#452) ==> CanRead(assertMask#_1850, assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_1850, this, AVLTreeNode.left);
  assert {:msg "  679.10: Receiver might be null."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_1849[this, AVLTreeNode.left] != null);
  assert {:msg "  679.10: Location might not be readable."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_1850, assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  679.35: Sequence index might be negative."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#98#452);
  assert {:msg "  679.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  679.39: Receiver might be null."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  679.39: Location might not be readable."} true && (0 <= k#98#452) && (k#98#452 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_1850, this, AVLTreeNode.key);
  assert {:msg "  679.3: Assertion might not hold. The expression at 679.10 might not evaluate to true."} (forall k#98#451: int :: 
    (0 <= k#98#451) && (k#98#451 < Seq#Length(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1849[assertHeap#_1849[this, AVLTreeNode.left], AVLTreeNode.keys], k#98#451) < assertHeap#_1849[this, AVLTreeNode.key])
  );
  assertMask#_1850 := exhaleMask#_1854;
  assume IsGoodExhaleState(exhaleHeap#_1853, assertHeap#_1849, assertMask#_1850, exhaledHolds#_1855);
  assertHeap#_1849 := exhaleHeap#_1853;
  assume IsGoodMask(assertMask#_1850);
  assume wf(assertHeap#_1849, assertMask#_1850, assertSecMask#_1851);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  predRec#_1857 := Heap[this, AVLTreeNode.left];
  predVer#_1858 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume (0.0 < unfoldK#_1856) && (unfoldK#_1856 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_1856) < methodK#_1808);
  assert {:msg "  680.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  680.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  680.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  assert {:msg "  680.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  680.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
    oldVers#_1863 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    havoc newVers#_1864;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1864;
    assume oldVers#_1863 < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1857, AVLTreeNode.valid, predVer#_1858, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#454: int :: 
      (0 <= lk#79#454) && (lk#79#454 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#454) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1857, AVLTreeNode.valid, predVer#_1858, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#455: int :: 
      (0 <= rk#80#455) && (rk#80#455 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#455))
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]))
  );
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  681.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  681.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  681.8: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  r#66 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  // assert
  assertHeap#_1866 := Heap;
  assertMask#_1867 := Mask;
  assertSecMask#_1868 := SecMask;
  assertCredits#_1869 := Credits;
  assume wf(assertHeap#_1866, assertMask#_1867, assertSecMask#_1868);
  // begin exhale (assert)
  exhaleMask#_1871 := assertMask#_1867;
  havoc exhaleHeap#_1870;
  exhaledHolds#_1872 := ZeroRefSet;
  assert {:msg "  682.10: Receiver might be null."} true && (0 <= k#99#457) ==> (r#66 != null);
  assert {:msg "  682.10: Location might not be readable."} true && (0 <= k#99#457) ==> CanRead(assertMask#_1867, r#66, AVLTreeNode.keys);
  assert {:msg "  682.10: Receiver might be null."} true && (0 <= k#99#457) && (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> (r#66 != null);
  assert {:msg "  682.10: Location might not be readable."} true && (0 <= k#99#457) && (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> CanRead(assertMask#_1867, r#66, AVLTreeNode.keys);
  assert {:msg "  682.32: Sequence index might be negative."} true && (0 <= k#99#457) && (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> (0 <= k#99#457);
  assert {:msg "  682.32: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#99#457) && (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys]));
  assert {:msg "  682.36: Receiver might be null."} true && (0 <= k#99#457) && (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  682.36: Location might not be readable."} true && (0 <= k#99#457) && (k#99#457 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> CanRead(assertMask#_1867, this, AVLTreeNode.key);
  assert {:msg "  682.3: Assertion might not hold. The expression at 682.10 might not evaluate to true."} (forall k#99#456: int :: 
    (0 <= k#99#456) && (k#99#456 < Seq#Length(assertHeap#_1866[r#66, AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1866[r#66, AVLTreeNode.keys], k#99#456) < assertHeap#_1866[this, AVLTreeNode.key])
  );
  assertMask#_1867 := exhaleMask#_1871;
  assume IsGoodExhaleState(exhaleHeap#_1870, assertHeap#_1866, assertMask#_1867, exhaledHolds#_1872);
  assertHeap#_1866 := exhaleHeap#_1870;
  assume IsGoodMask(assertMask#_1867);
  assume wf(assertHeap#_1866, assertMask#_1867, assertSecMask#_1868);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(r#66);
  predRec#_1874 := r#66;
  predVer#_1875 := Heap[r#66, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_1873) && (unfoldK#_1873 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_1873) < methodK#_1808);
  assert {:msg "  683.3: The target of the fold statement might be null."} r#66 != null;
  // begin exhale (unfold)
  assert {:msg "  683.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  683.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[r#66, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[r#66, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[r#66, AVLTreeNode.valid][perm$N]));
  Mask[r#66, AVLTreeNode.valid] := Mask[r#66, AVLTreeNode.valid][perm$R := Mask[r#66, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, r#66, AVLTreeNode.valid)) {
    oldVers#_1880 := Heap[r#66, AVLTreeNode.valid];
    havoc newVers#_1881;
    Heap[r#66, AVLTreeNode.valid] := newVers#_1881;
    assume oldVers#_1880 < Heap[r#66, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.key] := Mask[r#66, AVLTreeNode.key][perm$R := Mask[r#66, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.height] := Mask[r#66, AVLTreeNode.height][perm$R := Mask[r#66, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#66, AVLTreeNode.left] == null) || (dtype(Heap[r#66, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.left] := Mask[r#66, AVLTreeNode.left][perm$R := Mask[r#66, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#66, AVLTreeNode.right] == null) || (dtype(Heap[r#66, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.right] := Mask[r#66, AVLTreeNode.right][perm$R := Mask[r#66, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.keys] := Mask[r#66, AVLTreeNode.keys][perm$R := Mask[r#66, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#66 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#66, AVLTreeNode.balanceFactor] := Mask[r#66, AVLTreeNode.balanceFactor][perm$R := Mask[r#66, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1874, AVLTreeNode.valid, predVer#_1875, Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume (forall lk#79#459: int :: 
      (0 <= lk#79#459) && (lk#79#459 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], lk#79#459) < Heap[r#66, AVLTreeNode.key])
    );
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1874, AVLTreeNode.valid, predVer#_1875, Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume (forall rk#80#460: int :: 
      (0 <= rk#80#460) && (rk#80#460 < Seq#Length(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#66, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], rk#80#460))
    );
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#66, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#66, AVLTreeNode.key])), ite(Heap[r#66, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[r#66, AVLTreeNode.keys], Heap[r#66, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[r#66, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#66, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#66, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#66, AVLTreeNode.key]))
  );
  assume Heap[r#66, AVLTreeNode.height] == ite(ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[r#66, AVLTreeNode.balanceFactor] == (ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[r#66, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[r#66, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[r#66, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assert
  assertHeap#_1883 := Heap;
  assertMask#_1884 := Mask;
  assertSecMask#_1885 := SecMask;
  assertCredits#_1886 := Credits;
  assume wf(assertHeap#_1883, assertMask#_1884, assertSecMask#_1885);
  // begin exhale (assert)
  exhaleMask#_1888 := assertMask#_1884;
  havoc exhaleHeap#_1887;
  exhaledHolds#_1889 := ZeroRefSet;
  assert {:msg "  685.10: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  685.10: Location might not be readable."} true ==> CanRead(assertMask#_1884, r#66, AVLTreeNode.right);
  if (!(assertHeap#_1883[r#66, AVLTreeNode.right] == null)) {
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#462) ==> (r#66 != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#462) ==> CanRead(assertMask#_1884, r#66, AVLTreeNode.right);
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#462) ==> (assertHeap#_1883[r#66, AVLTreeNode.right] != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#462) ==> CanRead(assertMask#_1884, assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (r#66 != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_1884, r#66, AVLTreeNode.right);
    assert {:msg "  685.10: Receiver might be null."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_1883[r#66, AVLTreeNode.right] != null);
    assert {:msg "  685.10: Location might not be readable."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_1884, assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  685.56: Sequence index might be negative."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#100#462);
    assert {:msg "  685.56: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys]));
    assert {:msg "  685.60: Receiver might be null."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  685.60: Location might not be readable."} true && (0 <= k#100#462) && (k#100#462 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_1884, this, AVLTreeNode.key);
    assert {:msg "  685.3: Assertion might not hold. The expression at 685.28 might not evaluate to true."} (forall k#100#461: int :: 
      (0 <= k#100#461) && (k#100#461 < Seq#Length(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1883[assertHeap#_1883[r#66, AVLTreeNode.right], AVLTreeNode.keys], k#100#461) < assertHeap#_1883[this, AVLTreeNode.key])
    );
  }
  assertMask#_1884 := exhaleMask#_1888;
  assume IsGoodExhaleState(exhaleHeap#_1887, assertHeap#_1883, assertMask#_1884, exhaledHolds#_1889);
  assertHeap#_1883 := exhaleHeap#_1887;
  assume IsGoodMask(assertMask#_1884);
  assume wf(assertHeap#_1883, assertMask#_1884, assertSecMask#_1885);
  // end exhale
  // update field right
  assert {:msg "  687.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  687.3: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  687.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  assert {:msg "  687.17: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  687.17: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.left);
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Heap[r#66, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_1894) && ((1000.0 * methodCallK#_1894) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1894) < methodK#_1808);
  // call close
  callHeap#_1890 := Heap;
  callMask#_1891 := Mask;
  callSecMask#_1892 := SecMask;
  callCredits#_1893 := Credits;
  assume wf(callHeap#_1890, callMask#_1891, callSecMask#_1892);
  assert {:msg "  688.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  688.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  688.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#464 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_1896 := Mask;
  havoc exhaleHeap#_1895;
  exhaledHolds#_1897 := ZeroRefSet;
  if (!(Heap[this#464, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#465: int :: 
      (0 <= k#92#465) && (k#92#465 < Seq#Length(Heap[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys], k#92#465) < Heap[this#464, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#464, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#466: int :: 
      (0 <= k#93#466) && (k#93#466 < Seq#Length(Heap[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#464, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys], k#93#466))
    );
  }
  assert {:msg "  688.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#464, AVLTreeNode.left] == null, 0, Heap[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#464, AVLTreeNode.right] == null, 0, Heap[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  688.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#464, AVLTreeNode.left] == null, 0, Heap[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#464, AVLTreeNode.right] == null, 0, Heap[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  688.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  688.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1896[this#464, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[this#464, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1896[this#464, AVLTreeNode.key][perm$N]));
  exhaleMask#_1896[this#464, AVLTreeNode.key] := exhaleMask#_1896[this#464, AVLTreeNode.key][perm$R := exhaleMask#_1896[this#464, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1896, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  688.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1896[this#464, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[this#464, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1896[this#464, AVLTreeNode.height][perm$N]));
  exhaleMask#_1896[this#464, AVLTreeNode.height] := exhaleMask#_1896[this#464, AVLTreeNode.height][perm$R := exhaleMask#_1896[this#464, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1896, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  688.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1896[this#464, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[this#464, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1896[this#464, AVLTreeNode.left][perm$N]));
  exhaleMask#_1896[this#464, AVLTreeNode.left] := exhaleMask#_1896[this#464, AVLTreeNode.left][perm$R := exhaleMask#_1896[this#464, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1896, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  688.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1896[this#464, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[this#464, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1896[this#464, AVLTreeNode.right][perm$N]));
  exhaleMask#_1896[this#464, AVLTreeNode.right] := exhaleMask#_1896[this#464, AVLTreeNode.right][perm$R := exhaleMask#_1896[this#464, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1896, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  688.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1896[this#464, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[this#464, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1896[this#464, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1896[this#464, AVLTreeNode.keys] := exhaleMask#_1896[this#464, AVLTreeNode.keys][perm$R := exhaleMask#_1896[this#464, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1896, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  688.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  688.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1896[this#464, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[this#464, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1896[this#464, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1896[this#464, AVLTreeNode.balanceFactor] := exhaleMask#_1896[this#464, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1896[this#464, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1896, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#464, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1896, Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1895[Heap[this#464, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.left] == null)) {
    assert {:msg "  688.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1896, Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1895[Heap[this#464, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#464, AVLTreeNode.right] == null)) {
    assert {:msg "  688.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  688.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1896[Heap[this#464, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1896, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1896;
  assume IsGoodExhaleState(exhaleHeap#_1895, Heap, Mask, exhaledHolds#_1897);
  Heap := exhaleHeap#_1895;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#464 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#464, AVLTreeNode.valid] := Mask[this#464, AVLTreeNode.valid][perm$R := Mask[this#464, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#464 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#464, AVLTreeNode.height] := Mask[this#464, AVLTreeNode.height][perm$R := Mask[this#464, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#464 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#464, AVLTreeNode.keys] := Mask[this#464, AVLTreeNode.keys][perm$R := Mask[this#464, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#464 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#464, AVLTreeNode.balanceFactor] := Mask[this#464, AVLTreeNode.balanceFactor][perm$R := Mask[this#464, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#464, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1890[this#464, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1890[this#464, AVLTreeNode.key])), ite(callHeap#_1890[this#464, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#464, AVLTreeNode.height] == ite(ite(callHeap#_1890[this#464, AVLTreeNode.left] == null, 0, callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1890[this#464, AVLTreeNode.right] == null, 0, callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1890[this#464, AVLTreeNode.left] == null, 0, callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1890[this#464, AVLTreeNode.right] == null, 0, callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#464, AVLTreeNode.balanceFactor] == (ite(callHeap#_1890[this#464, AVLTreeNode.left] == null, 0, callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1890[this#464, AVLTreeNode.right] == null, 0, callHeap#_1890[callHeap#_1890[this#464, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field left
  assert {:msg "  689.3: Location might not be writable"} CanWrite(Mask, r#66, AVLTreeNode.left);
  assert {:msg "  689.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  689.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  Heap[r#66, AVLTreeNode.left] := Heap[this, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  // update field left
  assert {:msg "  690.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  690.17: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  690.17: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#66, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_1915 := Heap;
  assertMask#_1916 := Mask;
  assertSecMask#_1917 := SecMask;
  assertCredits#_1918 := Credits;
  assume wf(assertHeap#_1915, assertMask#_1916, assertSecMask#_1917);
  // begin exhale (assert)
  exhaleMask#_1920 := assertMask#_1916;
  havoc exhaleHeap#_1919;
  exhaledHolds#_1921 := ZeroRefSet;
  assert {:msg "  692.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  692.10: Location might not be readable."} true ==> CanRead(assertMask#_1916, this, AVLTreeNode.left);
  if (!(assertHeap#_1915[this, AVLTreeNode.left] == null)) {
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#470) ==> (this != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#470) ==> CanRead(assertMask#_1916, this, AVLTreeNode.left);
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#470) ==> (assertHeap#_1915[this, AVLTreeNode.left] != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#470) ==> CanRead(assertMask#_1916, assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_1916, this, AVLTreeNode.left);
    assert {:msg "  692.10: Receiver might be null."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_1915[this, AVLTreeNode.left] != null);
    assert {:msg "  692.10: Location might not be readable."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_1916, assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  692.50: Sequence index might be negative."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#101#470);
    assert {:msg "  692.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  692.54: Receiver might be null."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  692.54: Location might not be readable."} true && (0 <= k#101#470) && (k#101#470 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_1916, this, AVLTreeNode.key);
    assert {:msg "  692.3: Assertion might not hold. The expression at 692.25 might not evaluate to true."} (forall k#101#469: int :: 
      (0 <= k#101#469) && (k#101#469 < Seq#Length(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(assertHeap#_1915[assertHeap#_1915[this, AVLTreeNode.left], AVLTreeNode.keys], k#101#469) < assertHeap#_1915[this, AVLTreeNode.key])
    );
  }
  assertMask#_1916 := exhaleMask#_1920;
  assume IsGoodExhaleState(exhaleHeap#_1919, assertHeap#_1915, assertMask#_1916, exhaledHolds#_1921);
  assertHeap#_1915 := exhaleHeap#_1919;
  assume IsGoodMask(assertMask#_1916);
  assume wf(assertHeap#_1915, assertMask#_1916, assertSecMask#_1917);
  // end exhale
  assume (0.0 < methodCallK#_1926) && ((1000.0 * methodCallK#_1926) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1926) < methodK#_1808);
  // call close
  callHeap#_1922 := Heap;
  callMask#_1923 := Mask;
  callSecMask#_1924 := SecMask;
  callCredits#_1925 := Credits;
  assume wf(callHeap#_1922, callMask#_1923, callSecMask#_1924);
  assert {:msg "  693.3: The target of the method call might be null."} this != null;
  this#472 := this;
  // begin exhale (precondition)
  exhaleMask#_1928 := Mask;
  havoc exhaleHeap#_1927;
  exhaledHolds#_1929 := ZeroRefSet;
  if (!(Heap[this#472, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#473: int :: 
      (0 <= k#92#473) && (k#92#473 < Seq#Length(Heap[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys], k#92#473) < Heap[this#472, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#472, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#474: int :: 
      (0 <= k#93#474) && (k#93#474 < Seq#Length(Heap[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#472, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys], k#93#474))
    );
  }
  assert {:msg "  693.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#472, AVLTreeNode.left] == null, 0, Heap[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#472, AVLTreeNode.right] == null, 0, Heap[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  693.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#472, AVLTreeNode.left] == null, 0, Heap[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#472, AVLTreeNode.right] == null, 0, Heap[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  693.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  693.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1928[this#472, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[this#472, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1928[this#472, AVLTreeNode.key][perm$N]));
  exhaleMask#_1928[this#472, AVLTreeNode.key] := exhaleMask#_1928[this#472, AVLTreeNode.key][perm$R := exhaleMask#_1928[this#472, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1928, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  693.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1928[this#472, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[this#472, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1928[this#472, AVLTreeNode.height][perm$N]));
  exhaleMask#_1928[this#472, AVLTreeNode.height] := exhaleMask#_1928[this#472, AVLTreeNode.height][perm$R := exhaleMask#_1928[this#472, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1928, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  693.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1928[this#472, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[this#472, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1928[this#472, AVLTreeNode.left][perm$N]));
  exhaleMask#_1928[this#472, AVLTreeNode.left] := exhaleMask#_1928[this#472, AVLTreeNode.left][perm$R := exhaleMask#_1928[this#472, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1928, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  693.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1928[this#472, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[this#472, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1928[this#472, AVLTreeNode.right][perm$N]));
  exhaleMask#_1928[this#472, AVLTreeNode.right] := exhaleMask#_1928[this#472, AVLTreeNode.right][perm$R := exhaleMask#_1928[this#472, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1928, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  693.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1928[this#472, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[this#472, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1928[this#472, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1928[this#472, AVLTreeNode.keys] := exhaleMask#_1928[this#472, AVLTreeNode.keys][perm$R := exhaleMask#_1928[this#472, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1928, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  693.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  693.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1928[this#472, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[this#472, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1928[this#472, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1928[this#472, AVLTreeNode.balanceFactor] := exhaleMask#_1928[this#472, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1928[this#472, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1928, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#472, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1928, Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1927[Heap[this#472, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.left] == null)) {
    assert {:msg "  693.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1928, Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1927[Heap[this#472, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#472, AVLTreeNode.right] == null)) {
    assert {:msg "  693.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  693.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1928[Heap[this#472, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1928, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1928;
  assume IsGoodExhaleState(exhaleHeap#_1927, Heap, Mask, exhaledHolds#_1929);
  Heap := exhaleHeap#_1927;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#472 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#472, AVLTreeNode.valid] := Mask[this#472, AVLTreeNode.valid][perm$R := Mask[this#472, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#472 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#472, AVLTreeNode.height] := Mask[this#472, AVLTreeNode.height][perm$R := Mask[this#472, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#472 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#472, AVLTreeNode.keys] := Mask[this#472, AVLTreeNode.keys][perm$R := Mask[this#472, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#472 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#472, AVLTreeNode.balanceFactor] := Mask[this#472, AVLTreeNode.balanceFactor][perm$R := Mask[this#472, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#472, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1922[this#472, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1922[this#472, AVLTreeNode.key])), ite(callHeap#_1922[this#472, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#472, AVLTreeNode.height] == ite(ite(callHeap#_1922[this#472, AVLTreeNode.left] == null, 0, callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1922[this#472, AVLTreeNode.right] == null, 0, callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1922[this#472, AVLTreeNode.left] == null, 0, callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1922[this#472, AVLTreeNode.right] == null, 0, callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#472, AVLTreeNode.balanceFactor] == (ite(callHeap#_1922[this#472, AVLTreeNode.left] == null, 0, callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1922[this#472, AVLTreeNode.right] == null, 0, callHeap#_1922[callHeap#_1922[this#472, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field right
  assert {:msg "  694.3: Location might not be writable"} CanWrite(Mask, r#66, AVLTreeNode.right);
  Heap[r#66, AVLTreeNode.right] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_1951) && ((1000.0 * methodCallK#_1951) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_1951) < methodK#_1808);
  // call close
  callHeap#_1947 := Heap;
  callMask#_1948 := Mask;
  callSecMask#_1949 := SecMask;
  callCredits#_1950 := Credits;
  assume wf(callHeap#_1947, callMask#_1948, callSecMask#_1949);
  assert {:msg "  695.3: The target of the method call might be null."} r#66 != null;
  this#477 := r#66;
  // begin exhale (precondition)
  exhaleMask#_1953 := Mask;
  havoc exhaleHeap#_1952;
  exhaledHolds#_1954 := ZeroRefSet;
  if (!(Heap[this#477, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#478: int :: 
      (0 <= k#92#478) && (k#92#478 < Seq#Length(Heap[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys], k#92#478) < Heap[this#477, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#477, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#479: int :: 
      (0 <= k#93#479) && (k#93#479 < Seq#Length(Heap[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#477, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys], k#93#479))
    );
  }
  assert {:msg "  695.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#477, AVLTreeNode.left] == null, 0, Heap[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#477, AVLTreeNode.right] == null, 0, Heap[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  695.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#477, AVLTreeNode.left] == null, 0, Heap[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#477, AVLTreeNode.right] == null, 0, Heap[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  695.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  695.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_1953[this#477, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[this#477, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_1953[this#477, AVLTreeNode.key][perm$N]));
  exhaleMask#_1953[this#477, AVLTreeNode.key] := exhaleMask#_1953[this#477, AVLTreeNode.key][perm$R := exhaleMask#_1953[this#477, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1953, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  695.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_1953[this#477, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[this#477, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1953[this#477, AVLTreeNode.height][perm$N]));
  exhaleMask#_1953[this#477, AVLTreeNode.height] := exhaleMask#_1953[this#477, AVLTreeNode.height][perm$R := exhaleMask#_1953[this#477, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1953, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  695.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_1953[this#477, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[this#477, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_1953[this#477, AVLTreeNode.left][perm$N]));
  exhaleMask#_1953[this#477, AVLTreeNode.left] := exhaleMask#_1953[this#477, AVLTreeNode.left][perm$R := exhaleMask#_1953[this#477, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1953, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  695.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_1953[this#477, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[this#477, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_1953[this#477, AVLTreeNode.right][perm$N]));
  exhaleMask#_1953[this#477, AVLTreeNode.right] := exhaleMask#_1953[this#477, AVLTreeNode.right][perm$R := exhaleMask#_1953[this#477, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1953, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  695.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_1953[this#477, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[this#477, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1953[this#477, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1953[this#477, AVLTreeNode.keys] := exhaleMask#_1953[this#477, AVLTreeNode.keys][perm$R := exhaleMask#_1953[this#477, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1953, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  695.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  695.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_1953[this#477, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[this#477, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1953[this#477, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1953[this#477, AVLTreeNode.balanceFactor] := exhaleMask#_1953[this#477, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1953[this#477, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_1953, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#477, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1953, Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_1952[Heap[this#477, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.left] == null)) {
    assert {:msg "  695.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_1953, Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_1952[Heap[this#477, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#477, AVLTreeNode.right] == null)) {
    assert {:msg "  695.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  695.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1953[Heap[this#477, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_1953, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_1953;
  assume IsGoodExhaleState(exhaleHeap#_1952, Heap, Mask, exhaledHolds#_1954);
  Heap := exhaleHeap#_1952;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#477 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#477, AVLTreeNode.valid] := Mask[this#477, AVLTreeNode.valid][perm$R := Mask[this#477, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#477 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#477, AVLTreeNode.height] := Mask[this#477, AVLTreeNode.height][perm$R := Mask[this#477, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#477 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#477, AVLTreeNode.keys] := Mask[this#477, AVLTreeNode.keys][perm$R := Mask[this#477, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#477 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#477, AVLTreeNode.balanceFactor] := Mask[this#477, AVLTreeNode.balanceFactor][perm$R := Mask[this#477, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#477, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1947[this#477, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1947[this#477, AVLTreeNode.key])), ite(callHeap#_1947[this#477, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#477, AVLTreeNode.height] == ite(ite(callHeap#_1947[this#477, AVLTreeNode.left] == null, 0, callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1947[this#477, AVLTreeNode.right] == null, 0, callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1947[this#477, AVLTreeNode.left] == null, 0, callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1947[this#477, AVLTreeNode.right] == null, 0, callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#477, AVLTreeNode.balanceFactor] == (ite(callHeap#_1947[this#477, AVLTreeNode.left] == null, 0, callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1947[this#477, AVLTreeNode.right] == null, 0, callHeap#_1947[callHeap#_1947[this#477, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1973 := Mask;
  havoc exhaleHeap#_1972;
  exhaledHolds#_1974 := ZeroRefSet;
  assert {:msg "  643.2: The postcondition at 670.11 might not hold. The expression at 670.11 might not evaluate to true."} !(r#66 == null);
  assert {:msg "  643.2: The postcondition at 676.11 might not hold. The expression at 676.11 might not evaluate to true."} Heap[r#66, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height];
  assert {:msg "  643.2: The postcondition at 677.11 might not hold. The expression at 677.11 might not evaluate to true."} Seq#Equal(Heap[r#66, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  643.2: The postcondition at 671.11 might not hold. The permission at 671.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  643.2: The postcondition at 671.11 might not hold. Insufficient fraction at 671.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_1973[r#66, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_1973[r#66, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_1973[r#66, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1973[r#66, AVLTreeNode.valid] := exhaleMask#_1973[r#66, AVLTreeNode.valid][perm$R := exhaleMask#_1973[r#66, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_1973, r#66, AVLTreeNode.valid)) {
    assume Heap[r#66, AVLTreeNode.valid] < exhaleHeap#_1972[r#66, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_1973, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  643.2: The postcondition at 672.11 might not hold. The permission at 672.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  643.2: The postcondition at 672.11 might not hold. Insufficient fraction at 672.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_1973[r#66, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1973[r#66, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_1973[r#66, AVLTreeNode.height][perm$N]));
  exhaleMask#_1973[r#66, AVLTreeNode.height] := exhaleMask#_1973[r#66, AVLTreeNode.height][perm$R := exhaleMask#_1973[r#66, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1973, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  643.2: The postcondition at 673.11 might not hold. The permission at 673.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  643.2: The postcondition at 673.11 might not hold. Insufficient fraction at 673.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_1973[r#66, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1973[r#66, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_1973[r#66, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1973[r#66, AVLTreeNode.keys] := exhaleMask#_1973[r#66, AVLTreeNode.keys][perm$R := exhaleMask#_1973[r#66, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1973, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  643.2: The postcondition at 674.11 might not hold. The permission at 674.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  643.2: The postcondition at 674.11 might not hold. Insufficient fraction at 674.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_1973[r#66, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_1973[r#66, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_1973[r#66, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1973[r#66, AVLTreeNode.balanceFactor] := exhaleMask#_1973[r#66, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1973[r#66, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_1973, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_1973;
  assume IsGoodExhaleState(exhaleHeap#_1972, Heap, Mask, exhaledHolds#_1974);
  Heap := exhaleHeap#_1972;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  643.2: Method might lock/unlock more than allowed."} (forall lk#_1979: ref :: 
    { Heap[lk#_1979, held] }
    { Heap[lk#_1979, rdheld] }
    (((0 < Heap[lk#_1979, held]) == (0 < old(Heap)[lk#_1979, held])) && (Heap[lk#_1979, rdheld] == old(Heap)[lk#_1979, rdheld])) || false
  );
  assert {:msg "  643.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.rebalanceRR
// -------------------------------------------

// definedness check for method AVLTreeNode.rebalanceRR
procedure AVLTreeNode.rebalanceRR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#67: ref where (r#67 == null) || (dtype(r#67) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1980: real;
  var k#102#483: int where true;
  var k#103#485: int where true;
  assume (0.0 < methodK#_1980) && ((1000.0 * methodK#_1980) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  710.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  710.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  711.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  711.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  711.12: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
  assert {:msg "  711.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  711.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  712.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  712.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  713.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  713.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  714.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  714.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#483) ==> (this != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#483) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#483) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#483) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  715.12: Receiver might be null."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  715.12: Location might not be readable."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  715.37: Sequence index might be negative."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#102#483);
  assert {:msg "  715.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  715.41: Receiver might be null."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  715.41: Location might not be readable."} true && (0 <= k#102#483) && (k#102#483 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall k#102#482: int :: 
    (0 <= k#102#482) && (k#102#482 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#102#482) < Heap[this, AVLTreeNode.key])
  );
  assert {:msg "  717.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  717.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  717.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  717.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  717.28: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
    assert {:msg "  717.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  717.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  718.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  718.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  718.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  718.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  719.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  719.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  719.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  719.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  720.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  720.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  720.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  720.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  721.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  721.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#485) ==> (this != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#485) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#485) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#485) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  721.54: Receiver might be null."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  721.54: Location might not be readable."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  721.12: Receiver might be null."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  721.12: Location might not be readable."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  721.60: Sequence index might be negative."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#103#485);
    assert {:msg "  721.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#103#485) && (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#103#485 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#103#484: int :: 
      (0 <= k#103#484) && (k#103#484 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#103#484))
    );
  }
  assert {:msg "  723.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  723.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  723.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  723.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  723.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  723.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  723.41: Receiver might be null."} true ==> (this != null);
    assert {:msg "  723.41: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  723.41: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  723.41: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assert {:msg "  724.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  724.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  724.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  724.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1983: Field (PMaskType) :: 
    (forall ref#_1982: ref :: 
      Heap[ref#_1982, pmask#_1983] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#67 == null);
  assert {:msg "  728.11: Receiver might be null."} r#67 != null;
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#67, AVLTreeNode.valid] := Mask[r#67, AVLTreeNode.valid][perm$R := Mask[r#67, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#67, AVLTreeNode.height] := Mask[r#67, AVLTreeNode.height][perm$R := Mask[r#67, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#67, AVLTreeNode.keys] := Mask[r#67, AVLTreeNode.keys][perm$R := Mask[r#67, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#67 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#67, AVLTreeNode.balanceFactor] := Mask[r#67, AVLTreeNode.balanceFactor][perm$R := Mask[r#67, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  733.11: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  733.11: Location might not be readable."} true ==> CanRead(Mask, r#67, AVLTreeNode.height);
  assert {:msg "  733.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  733.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  733.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  733.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  733.43: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (r#67 != null);
  assert {:msg "  733.43: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(Mask, r#67, AVLTreeNode.height);
  assert {:msg "  733.59: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  733.59: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  733.59: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  733.59: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume (Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#67, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  734.11: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  734.11: Location might not be readable."} true ==> CanRead(Mask, r#67, AVLTreeNode.keys);
  assert {:msg "  734.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  734.25: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  734.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  734.25: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  734.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  734.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  734.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  734.59: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  734.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  734.89: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  734.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  734.89: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#67, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.rebalanceRR
procedure AVLTreeNode.rebalanceRR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#67: ref where (r#67 == null) || (dtype(r#67) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_1980: real;
  var predRec#_1989: ref;
  var predVer#_1990: int;
  var unfoldK#_1988: real;
  var oldVers#_1995: int;
  var newVers#_1996: int;
  var methodCallK#_2002: real;
  var this#490: ref where (this#490 == null) || (dtype(this#490) == AVLTreeNode#t);
  var callHeap#_1998: HeapType;
  var callMask#_1999: MaskType;
  var callSecMask#_2000: MaskType;
  var callCredits#_2001: CreditsType;
  var exhaleMask#_2004: MaskType;
  var exhaleHeap#_2003: HeapType;
  var exhaledHolds#_2005: RefSet;
  var isHeld#_2020: int;
  var isRdHeld#_2021: bool;
  var methodCallK#_2027: real;
  var this#495: ref where (this#495 == null) || (dtype(this#495) == AVLTreeNode#t);
  var callHeap#_2023: HeapType;
  var callMask#_2024: MaskType;
  var callSecMask#_2025: MaskType;
  var callCredits#_2026: CreditsType;
  var exhaleMask#_2029: MaskType;
  var exhaleHeap#_2028: HeapType;
  var exhaledHolds#_2030: RefSet;
  var isHeld#_2045: int;
  var isRdHeld#_2046: bool;
  var exhaleMask#_2049: MaskType;
  var exhaleHeap#_2048: HeapType;
  var exhaledHolds#_2050: RefSet;
  assume (0.0 < methodK#_1980) && ((1000.0 * methodK#_1980) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#102#486: int :: 
    (0 <= k#102#486) && (k#102#486 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#102#486) < Heap[this, AVLTreeNode.key])
  );
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#103#487: int :: 
      (0 <= k#103#487) && (k#103#487 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#103#487))
    );
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_1987: Field (PMaskType) :: 
    (forall ref#_1986: ref :: 
      Heap[ref#_1986, pmask#_1987] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.left]);
  predRec#_1989 := Heap[this, AVLTreeNode.left];
  predVer#_1990 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume (0.0 < unfoldK#_1988) && (unfoldK#_1988 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_1988) < methodK#_1980);
  assert {:msg "  736.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  736.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  736.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  assert {:msg "  736.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  736.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.valid)) {
    oldVers#_1995 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    havoc newVers#_1996;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := newVers#_1996;
    assume oldVers#_1995 < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.left] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1989, AVLTreeNode.valid, predVer#_1990, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#79#488: int :: 
      (0 <= lk#79#488) && (lk#79#488 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#79#488) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_1989, AVLTreeNode.valid, predVer#_1990, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#80#489: int :: 
      (0 <= rk#80#489) && (rk#80#489 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#80#489))
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]))
  );
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  737.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  737.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  r#67 := Heap[this, AVLTreeNode.left];
  // update field left
  assert {:msg "  738.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  738.14: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  738.14: Location might not be readable."} true ==> CanRead(Mask, r#67, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#67, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_2002) && ((1000.0 * methodCallK#_2002) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2002) < methodK#_1980);
  // call close
  callHeap#_1998 := Heap;
  callMask#_1999 := Mask;
  callSecMask#_2000 := SecMask;
  callCredits#_2001 := Credits;
  assume wf(callHeap#_1998, callMask#_1999, callSecMask#_2000);
  assert {:msg "  739.3: The target of the method call might be null."} this != null;
  this#490 := this;
  // begin exhale (precondition)
  exhaleMask#_2004 := Mask;
  havoc exhaleHeap#_2003;
  exhaledHolds#_2005 := ZeroRefSet;
  if (!(Heap[this#490, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#491: int :: 
      (0 <= k#92#491) && (k#92#491 < Seq#Length(Heap[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys], k#92#491) < Heap[this#490, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#490, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#492: int :: 
      (0 <= k#93#492) && (k#93#492 < Seq#Length(Heap[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#490, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys], k#93#492))
    );
  }
  assert {:msg "  739.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#490, AVLTreeNode.left] == null, 0, Heap[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#490, AVLTreeNode.right] == null, 0, Heap[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  739.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#490, AVLTreeNode.left] == null, 0, Heap[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#490, AVLTreeNode.right] == null, 0, Heap[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  739.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  739.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2004[this#490, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[this#490, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2004[this#490, AVLTreeNode.key][perm$N]));
  exhaleMask#_2004[this#490, AVLTreeNode.key] := exhaleMask#_2004[this#490, AVLTreeNode.key][perm$R := exhaleMask#_2004[this#490, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2004, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  739.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2004[this#490, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[this#490, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2004[this#490, AVLTreeNode.height][perm$N]));
  exhaleMask#_2004[this#490, AVLTreeNode.height] := exhaleMask#_2004[this#490, AVLTreeNode.height][perm$R := exhaleMask#_2004[this#490, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2004, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  739.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2004[this#490, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[this#490, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2004[this#490, AVLTreeNode.left][perm$N]));
  exhaleMask#_2004[this#490, AVLTreeNode.left] := exhaleMask#_2004[this#490, AVLTreeNode.left][perm$R := exhaleMask#_2004[this#490, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2004, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  739.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2004[this#490, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[this#490, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2004[this#490, AVLTreeNode.right][perm$N]));
  exhaleMask#_2004[this#490, AVLTreeNode.right] := exhaleMask#_2004[this#490, AVLTreeNode.right][perm$R := exhaleMask#_2004[this#490, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2004, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  739.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2004[this#490, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[this#490, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2004[this#490, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2004[this#490, AVLTreeNode.keys] := exhaleMask#_2004[this#490, AVLTreeNode.keys][perm$R := exhaleMask#_2004[this#490, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2004, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  739.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  739.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2004[this#490, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[this#490, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2004[this#490, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2004[this#490, AVLTreeNode.balanceFactor] := exhaleMask#_2004[this#490, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2004[this#490, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2004, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#490, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2004, Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2003[Heap[this#490, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.left] == null)) {
    assert {:msg "  739.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2004, Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2003[Heap[this#490, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#490, AVLTreeNode.right] == null)) {
    assert {:msg "  739.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  739.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2004[Heap[this#490, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2004, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2004;
  assume IsGoodExhaleState(exhaleHeap#_2003, Heap, Mask, exhaledHolds#_2005);
  Heap := exhaleHeap#_2003;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#490 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#490, AVLTreeNode.valid] := Mask[this#490, AVLTreeNode.valid][perm$R := Mask[this#490, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#490 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#490, AVLTreeNode.height] := Mask[this#490, AVLTreeNode.height][perm$R := Mask[this#490, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#490 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#490, AVLTreeNode.keys] := Mask[this#490, AVLTreeNode.keys][perm$R := Mask[this#490, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#490 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#490, AVLTreeNode.balanceFactor] := Mask[this#490, AVLTreeNode.balanceFactor][perm$R := Mask[this#490, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#490, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1998[this#490, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1998[this#490, AVLTreeNode.key])), ite(callHeap#_1998[this#490, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#490, AVLTreeNode.height] == ite(ite(callHeap#_1998[this#490, AVLTreeNode.left] == null, 0, callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1998[this#490, AVLTreeNode.right] == null, 0, callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1998[this#490, AVLTreeNode.left] == null, 0, callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1998[this#490, AVLTreeNode.right] == null, 0, callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#490, AVLTreeNode.balanceFactor] == (ite(callHeap#_1998[this#490, AVLTreeNode.left] == null, 0, callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1998[this#490, AVLTreeNode.right] == null, 0, callHeap#_1998[callHeap#_1998[this#490, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field right
  assert {:msg "  740.3: Location might not be writable"} CanWrite(Mask, r#67, AVLTreeNode.right);
  Heap[r#67, AVLTreeNode.right] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_2027) && ((1000.0 * methodCallK#_2027) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2027) < methodK#_1980);
  // call close
  callHeap#_2023 := Heap;
  callMask#_2024 := Mask;
  callSecMask#_2025 := SecMask;
  callCredits#_2026 := Credits;
  assume wf(callHeap#_2023, callMask#_2024, callSecMask#_2025);
  assert {:msg "  741.3: The target of the method call might be null."} r#67 != null;
  this#495 := r#67;
  // begin exhale (precondition)
  exhaleMask#_2029 := Mask;
  havoc exhaleHeap#_2028;
  exhaledHolds#_2030 := ZeroRefSet;
  if (!(Heap[this#495, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#496: int :: 
      (0 <= k#92#496) && (k#92#496 < Seq#Length(Heap[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys], k#92#496) < Heap[this#495, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#495, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#497: int :: 
      (0 <= k#93#497) && (k#93#497 < Seq#Length(Heap[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#495, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys], k#93#497))
    );
  }
  assert {:msg "  741.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#495, AVLTreeNode.left] == null, 0, Heap[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#495, AVLTreeNode.right] == null, 0, Heap[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  741.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#495, AVLTreeNode.left] == null, 0, Heap[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#495, AVLTreeNode.right] == null, 0, Heap[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  741.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  741.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2029[this#495, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[this#495, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2029[this#495, AVLTreeNode.key][perm$N]));
  exhaleMask#_2029[this#495, AVLTreeNode.key] := exhaleMask#_2029[this#495, AVLTreeNode.key][perm$R := exhaleMask#_2029[this#495, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2029, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  741.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2029[this#495, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[this#495, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2029[this#495, AVLTreeNode.height][perm$N]));
  exhaleMask#_2029[this#495, AVLTreeNode.height] := exhaleMask#_2029[this#495, AVLTreeNode.height][perm$R := exhaleMask#_2029[this#495, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2029, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  741.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2029[this#495, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[this#495, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2029[this#495, AVLTreeNode.left][perm$N]));
  exhaleMask#_2029[this#495, AVLTreeNode.left] := exhaleMask#_2029[this#495, AVLTreeNode.left][perm$R := exhaleMask#_2029[this#495, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2029, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  741.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2029[this#495, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[this#495, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2029[this#495, AVLTreeNode.right][perm$N]));
  exhaleMask#_2029[this#495, AVLTreeNode.right] := exhaleMask#_2029[this#495, AVLTreeNode.right][perm$R := exhaleMask#_2029[this#495, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2029, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  741.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2029[this#495, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[this#495, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2029[this#495, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2029[this#495, AVLTreeNode.keys] := exhaleMask#_2029[this#495, AVLTreeNode.keys][perm$R := exhaleMask#_2029[this#495, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2029, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  741.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  741.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2029[this#495, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[this#495, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2029[this#495, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2029[this#495, AVLTreeNode.balanceFactor] := exhaleMask#_2029[this#495, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2029[this#495, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2029, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#495, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2029, Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2028[Heap[this#495, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.left] == null)) {
    assert {:msg "  741.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2029, Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2028[Heap[this#495, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#495, AVLTreeNode.right] == null)) {
    assert {:msg "  741.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  741.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2029[Heap[this#495, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2029, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2029;
  assume IsGoodExhaleState(exhaleHeap#_2028, Heap, Mask, exhaledHolds#_2030);
  Heap := exhaleHeap#_2028;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#495 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#495, AVLTreeNode.valid] := Mask[this#495, AVLTreeNode.valid][perm$R := Mask[this#495, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#495 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#495, AVLTreeNode.height] := Mask[this#495, AVLTreeNode.height][perm$R := Mask[this#495, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#495 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#495, AVLTreeNode.keys] := Mask[this#495, AVLTreeNode.keys][perm$R := Mask[this#495, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#495 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#495, AVLTreeNode.balanceFactor] := Mask[this#495, AVLTreeNode.balanceFactor][perm$R := Mask[this#495, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#495, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2023[this#495, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2023[this#495, AVLTreeNode.key])), ite(callHeap#_2023[this#495, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#495, AVLTreeNode.height] == ite(ite(callHeap#_2023[this#495, AVLTreeNode.left] == null, 0, callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2023[this#495, AVLTreeNode.right] == null, 0, callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2023[this#495, AVLTreeNode.left] == null, 0, callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2023[this#495, AVLTreeNode.right] == null, 0, callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#495, AVLTreeNode.balanceFactor] == (ite(callHeap#_2023[this#495, AVLTreeNode.left] == null, 0, callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2023[this#495, AVLTreeNode.right] == null, 0, callHeap#_2023[callHeap#_2023[this#495, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_2049 := Mask;
  havoc exhaleHeap#_2048;
  exhaledHolds#_2050 := ZeroRefSet;
  assert {:msg "  701.2: The postcondition at 727.11 might not hold. The expression at 727.11 might not evaluate to true."} !(r#67 == null);
  assert {:msg "  701.2: The postcondition at 733.11 might not hold. The expression at 733.11 might not evaluate to true."} (Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#67, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assert {:msg "  701.2: The postcondition at 734.11 might not hold. The expression at 734.11 might not evaluate to true."} Seq#Equal(Heap[r#67, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  701.2: The postcondition at 728.11 might not hold. The permission at 728.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  701.2: The postcondition at 728.11 might not hold. Insufficient fraction at 728.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2049[r#67, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2049[r#67, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2049[r#67, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2049[r#67, AVLTreeNode.valid] := exhaleMask#_2049[r#67, AVLTreeNode.valid][perm$R := exhaleMask#_2049[r#67, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_2049, r#67, AVLTreeNode.valid)) {
    assume Heap[r#67, AVLTreeNode.valid] < exhaleHeap#_2048[r#67, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_2049, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  701.2: The postcondition at 729.11 might not hold. The permission at 729.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  701.2: The postcondition at 729.11 might not hold. Insufficient fraction at 729.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2049[r#67, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2049[r#67, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2049[r#67, AVLTreeNode.height][perm$N]));
  exhaleMask#_2049[r#67, AVLTreeNode.height] := exhaleMask#_2049[r#67, AVLTreeNode.height][perm$R := exhaleMask#_2049[r#67, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2049, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  701.2: The postcondition at 730.11 might not hold. The permission at 730.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  701.2: The postcondition at 730.11 might not hold. Insufficient fraction at 730.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2049[r#67, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2049[r#67, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2049[r#67, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2049[r#67, AVLTreeNode.keys] := exhaleMask#_2049[r#67, AVLTreeNode.keys][perm$R := exhaleMask#_2049[r#67, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2049, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  701.2: The postcondition at 731.11 might not hold. The permission at 731.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  701.2: The postcondition at 731.11 might not hold. Insufficient fraction at 731.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2049[r#67, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2049[r#67, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2049[r#67, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2049[r#67, AVLTreeNode.balanceFactor] := exhaleMask#_2049[r#67, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2049[r#67, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2049, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2049;
  assume IsGoodExhaleState(exhaleHeap#_2048, Heap, Mask, exhaledHolds#_2050);
  Heap := exhaleHeap#_2048;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  701.2: Method might lock/unlock more than allowed."} (forall lk#_2055: ref :: 
    { Heap[lk#_2055, held] }
    { Heap[lk#_2055, rdheld] }
    (((0 < Heap[lk#_2055, held]) == (0 < old(Heap)[lk#_2055, held])) && (Heap[lk#_2055, rdheld] == old(Heap)[lk#_2055, rdheld])) || false
  );
  assert {:msg "  701.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.rebalanceRight
// -------------------------------------------

// definedness check for method AVLTreeNode.rebalanceRight
procedure AVLTreeNode.rebalanceRight$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#68: ref where (r#68 == null) || (dtype(r#68) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2056: real;
  var k#104#501: int where true;
  var k#105#503: int where true;
  assume (0.0 < methodK#_2056) && ((1000.0 * methodK#_2056) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  754.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  754.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  754.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  754.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  754.25: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  754.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  754.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  755.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  755.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  755.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  755.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  756.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  756.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  756.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  756.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  757.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  757.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  757.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  757.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  758.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  758.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#501) ==> (this != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#501) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#501) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#501) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  758.12: Receiver might be null."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  758.12: Location might not be readable."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  758.50: Sequence index might be negative."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#104#501);
    assert {:msg "  758.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  758.54: Receiver might be null."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  758.54: Location might not be readable."} true && (0 <= k#104#501) && (k#104#501 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#104#500: int :: 
      (0 <= k#104#500) && (k#104#500 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#104#500) < Heap[this, AVLTreeNode.key])
    );
  }
  assert {:msg "  760.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  760.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  761.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  761.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  761.12: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
  assert {:msg "  761.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  761.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  762.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  762.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  763.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  763.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  764.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  764.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#503) ==> (this != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#503) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#503) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#503) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  765.38: Receiver might be null."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  765.38: Location might not be readable."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  765.12: Receiver might be null."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  765.12: Location might not be readable."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  765.44: Sequence index might be negative."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#105#503);
  assert {:msg "  765.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#105#503) && (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#105#503 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#105#502: int :: 
    (0 <= k#105#502) && (k#105#502 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#105#502))
  );
  assert {:msg "  768.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  768.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  768.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  768.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  768.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  768.26: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  768.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  768.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  768.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  768.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_2059: Field (PMaskType) :: 
    (forall ref#_2058: ref :: 
      Heap[ref#_2058, pmask#_2059] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#68 == null);
  assert {:msg "  771.11: Receiver might be null."} r#68 != null;
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#68, AVLTreeNode.valid] := Mask[r#68, AVLTreeNode.valid][perm$R := Mask[r#68, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#68, AVLTreeNode.height] := Mask[r#68, AVLTreeNode.height][perm$R := Mask[r#68, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#68, AVLTreeNode.keys] := Mask[r#68, AVLTreeNode.keys][perm$R := Mask[r#68, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#68 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#68, AVLTreeNode.balanceFactor] := Mask[r#68, AVLTreeNode.balanceFactor][perm$R := Mask[r#68, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  776.11: Receiver might be null."} true ==> (r#68 != null);
  assert {:msg "  776.11: Location might not be readable."} true ==> CanRead(Mask, r#68, AVLTreeNode.height);
  assert {:msg "  776.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  776.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  776.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  776.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assert {:msg "  776.44: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (r#68 != null);
  assert {:msg "  776.44: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(Mask, r#68, AVLTreeNode.height);
  assert {:msg "  776.60: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  776.60: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  776.60: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  776.60: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#68, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  777.11: Receiver might be null."} true ==> (r#68 != null);
  assert {:msg "  777.11: Location might not be readable."} true ==> CanRead(Mask, r#68, AVLTreeNode.keys);
  assert {:msg "  777.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  777.26: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  777.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  777.51: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  777.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  777.51: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  777.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  777.71: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  777.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  777.84: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  777.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  777.84: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#68, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.rebalanceRight
procedure AVLTreeNode.rebalanceRight(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#68: ref where (r#68 == null) || (dtype(r#68) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2056: real;
  var rbf#70: int where true;
  var methodCallK#_2068: real;
  var this#506: ref where (this#506 == null) || (dtype(this#506) == AVLTreeNode#t);
  var bf#507: int where true;
  var callHeap#_2064: HeapType;
  var callMask#_2065: MaskType;
  var callSecMask#_2066: MaskType;
  var callCredits#_2067: CreditsType;
  var exhaleMask#_2070: MaskType;
  var exhaleHeap#_2069: HeapType;
  var exhaledHolds#_2071: RefSet;
  var isHeld#_2074: int;
  var isRdHeld#_2075: bool;
  var predRec#_2077: ref;
  var predFlag#_2079: bool;
  var predVer#_2078: int;
  var predRec#_2083: ref;
  var predFlag#_2085: bool;
  var predVer#_2084: int;
  var cond#_2089: bool;
  var assertHeap#_2090: HeapType;
  var assertMask#_2091: MaskType;
  var assertSecMask#_2092: MaskType;
  var assertCredits#_2093: CreditsType;
  var exhaleMask#_2095: MaskType;
  var exhaleHeap#_2094: HeapType;
  var exhaledHolds#_2096: RefSet;
  var unfoldingK#_2105: real;
  var predFlag#_2104: bool;
  var predRec#_2106: ref;
  var predVer#_2107: int;
  var unfoldingHeap#_2100: HeapType;
  var unfoldingMask#_2101: MaskType;
  var unfoldingSecMask#_2102: MaskType;
  var unfoldingCredits#_2103: CreditsType;
  var oldVers#_2112: int;
  var newVers#_2113: int;
  var newPredicateMask#_2117: PMaskType;
  var newPredicateMask#_2120: PMaskType;
  var methodCallK#_2125: real;
  var this#516: ref where (this#516 == null) || (dtype(this#516) == AVLTreeNode#t);
  var r#517: ref where (r#517 == null) || (dtype(r#517) == AVLTreeNode#t);
  var callHeap#_2121: HeapType;
  var callMask#_2122: MaskType;
  var callSecMask#_2123: MaskType;
  var callCredits#_2124: CreditsType;
  var exhaleMask#_2127: MaskType;
  var exhaleHeap#_2126: HeapType;
  var exhaledHolds#_2128: RefSet;
  var predRec#_2129: ref;
  var predFlag#_2131: bool;
  var predVer#_2130: int;
  var isHeld#_2146: int;
  var isRdHeld#_2147: bool;
  var methodCallK#_2153: real;
  var this#524: ref where (this#524 == null) || (dtype(this#524) == AVLTreeNode#t);
  var r#525: ref where (r#525 == null) || (dtype(r#525) == AVLTreeNode#t);
  var callHeap#_2149: HeapType;
  var callMask#_2150: MaskType;
  var callSecMask#_2151: MaskType;
  var callCredits#_2152: CreditsType;
  var exhaleMask#_2155: MaskType;
  var exhaleHeap#_2154: HeapType;
  var exhaledHolds#_2156: RefSet;
  var isHeld#_2171: int;
  var isRdHeld#_2172: bool;
  var exhaleMask#_2175: MaskType;
  var exhaleHeap#_2174: HeapType;
  var exhaledHolds#_2176: RefSet;
  assume (0.0 < methodK#_2056) && ((1000.0 * methodK#_2056) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#104#504: int :: 
      (0 <= k#104#504) && (k#104#504 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#104#504) < Heap[this, AVLTreeNode.key])
    );
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#105#505: int :: 
    (0 <= k#105#505) && (k#105#505 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#105#505))
  );
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_2063: Field (PMaskType) :: 
    (forall ref#_2062: ref :: 
      Heap[ref#_2062, pmask#_2063] == ZeroPMask
    )
  );
  // local var rbf
  assume (0.0 < methodCallK#_2068) && ((1000.0 * methodCallK#_2068) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2068) < methodK#_2056);
  // call getBalanceFactor
  callHeap#_2064 := Heap;
  callMask#_2065 := Mask;
  callSecMask#_2066 := SecMask;
  callCredits#_2067 := Credits;
  assume wf(callHeap#_2064, callMask#_2065, callSecMask#_2066);
  assert {:msg "  780.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  780.15: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  780.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#506 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_2070 := Mask;
  havoc exhaleHeap#_2069;
  exhaledHolds#_2071 := ZeroRefSet;
  assert {:msg "  780.3: The precondition at 489.12 might not hold. The permission at 489.12 might not be positive."} methodCallK#_2068 > 0.0;
  assert {:msg "  780.3: The precondition at 489.12 might not hold. Insufficient fraction at 489.12 for AVLTreeNode.balanceFactor."} exhaleMask#_2070[this#506, AVLTreeNode.balanceFactor][perm$R] > 0.0;
  assume methodCallK#_2068 < exhaleMask#_2070[this#506, AVLTreeNode.balanceFactor][perm$R];
  exhaleMask#_2070[this#506, AVLTreeNode.balanceFactor] := exhaleMask#_2070[this#506, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2070[this#506, AVLTreeNode.balanceFactor][perm$R] - methodCallK#_2068];
  assume wf(Heap, exhaleMask#_2070, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  780.3: The precondition at 488.12 might not hold. The permission at 488.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  780.3: The precondition at 488.12 might not hold. Insufficient fraction at 488.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2070[this#506, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2070[this#506, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2070[this#506, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2070[this#506, AVLTreeNode.valid] := exhaleMask#_2070[this#506, AVLTreeNode.valid][perm$R := exhaleMask#_2070[this#506, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_2070, this#506, AVLTreeNode.valid)) {
    assume Heap[this#506, AVLTreeNode.valid] < exhaleHeap#_2069[this#506, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_2070, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2070;
  assume IsGoodExhaleState(exhaleHeap#_2069, Heap, Mask, exhaledHolds#_2071);
  Heap := exhaleHeap#_2069;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  havoc bf#507;
  // inhale (postcondition)
  assume this#506 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#506, AVLTreeNode.valid] := Mask[this#506, AVLTreeNode.valid][perm$R := Mask[this#506, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#506 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume methodCallK#_2068 > 0.0;
  Mask[this#506, AVLTreeNode.balanceFactor] := Mask[this#506, AVLTreeNode.balanceFactor][perm$R := Mask[this#506, AVLTreeNode.balanceFactor][perm$R] + methodCallK#_2068];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume bf#507 == Heap[this#506, AVLTreeNode.balanceFactor];
  predRec#_2077 := this#506;
  predFlag#_2079 := true;
  assume #AVLTreeNode.valid#trigger(this#506);
  predVer#_2078 := Heap[this#506, AVLTreeNode.valid];
  assume predRec#_2077 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2077, AVLTreeNode.key] := SecMask[predRec#_2077, AVLTreeNode.key][perm$R := SecMask[predRec#_2077, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2077 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2077, AVLTreeNode.height] := SecMask[predRec#_2077, AVLTreeNode.height][perm$R := SecMask[predRec#_2077, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2077 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2077, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2077, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2077, AVLTreeNode.left] := SecMask[predRec#_2077, AVLTreeNode.left][perm$R := SecMask[predRec#_2077, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2077 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2077, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2077, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2077, AVLTreeNode.right] := SecMask[predRec#_2077, AVLTreeNode.right][perm$R := SecMask[predRec#_2077, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2077 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2077, AVLTreeNode.keys] := SecMask[predRec#_2077, AVLTreeNode.keys][perm$R := SecMask[predRec#_2077, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2077 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2077, AVLTreeNode.balanceFactor] := SecMask[predRec#_2077, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2077, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2077, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2077, AVLTreeNode.valid, predVer#_2078, Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.left] == null)) {
    assume (forall lk#79#508: int :: 
      (0 <= lk#79#508) && (lk#79#508 < Seq#Length(Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys], lk#79#508) < Heap[predRec#_2077, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2077, AVLTreeNode.valid, predVer#_2078, Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2077, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.right] == null)) {
    assume (forall rk#80#509: int :: 
      (0 <= rk#80#509) && (rk#80#509 < Seq#Length(Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2077, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys], rk#80#509))
    );
  }
  if (!(Heap[predRec#_2077, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2077, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2077, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2077, AVLTreeNode.key])), ite(Heap[predRec#_2077, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2077, AVLTreeNode.keys], Heap[predRec#_2077, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_2077, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2077, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2077, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2077, AVLTreeNode.key]))
  );
  assume Heap[predRec#_2077, AVLTreeNode.height] == ite(ite(Heap[predRec#_2077, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2077, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2077, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2077, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2077, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2077, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2077, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2077, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2077, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2077, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2077, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2077, AVLTreeNode.height] > 0;
  assume (bf#507 > 0) ==> (!(Heap[this#506, AVLTreeNode.left] == null));
  predRec#_2083 := this#506;
  predFlag#_2085 := true;
  assume #AVLTreeNode.valid#trigger(this#506);
  predVer#_2084 := Heap[this#506, AVLTreeNode.valid];
  assume predRec#_2083 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2083, AVLTreeNode.key] := SecMask[predRec#_2083, AVLTreeNode.key][perm$R := SecMask[predRec#_2083, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2083 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2083, AVLTreeNode.height] := SecMask[predRec#_2083, AVLTreeNode.height][perm$R := SecMask[predRec#_2083, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2083 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2083, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2083, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2083, AVLTreeNode.left] := SecMask[predRec#_2083, AVLTreeNode.left][perm$R := SecMask[predRec#_2083, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2083 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2083, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2083, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2083, AVLTreeNode.right] := SecMask[predRec#_2083, AVLTreeNode.right][perm$R := SecMask[predRec#_2083, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2083 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2083, AVLTreeNode.keys] := SecMask[predRec#_2083, AVLTreeNode.keys][perm$R := SecMask[predRec#_2083, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2083 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2083, AVLTreeNode.balanceFactor] := SecMask[predRec#_2083, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2083, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2083, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2083, AVLTreeNode.valid, predVer#_2084, Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.left] == null)) {
    assume (forall lk#79#510: int :: 
      (0 <= lk#79#510) && (lk#79#510 < Seq#Length(Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys], lk#79#510) < Heap[predRec#_2083, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2083, AVLTreeNode.valid, predVer#_2084, Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2083, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.right] == null)) {
    assume (forall rk#80#511: int :: 
      (0 <= rk#80#511) && (rk#80#511 < Seq#Length(Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2083, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys], rk#80#511))
    );
  }
  if (!(Heap[predRec#_2083, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2083, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2083, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2083, AVLTreeNode.key])), ite(Heap[predRec#_2083, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2083, AVLTreeNode.keys], Heap[predRec#_2083, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_2083, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2083, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2083, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2083, AVLTreeNode.key]))
  );
  assume Heap[predRec#_2083, AVLTreeNode.height] == ite(ite(Heap[predRec#_2083, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2083, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2083, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2083, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2083, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2083, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2083, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2083, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2083, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2083, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2083, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2083, AVLTreeNode.height] > 0;
  assume (bf#507 < 0) ==> (!(Heap[this#506, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  rbf#70 := bf#507;
  // if
  cond#_2089 := rbf#70 > 0;
  if (cond#_2089) {
    // assert
    assertHeap#_2090 := Heap;
    assertMask#_2091 := Mask;
    assertSecMask#_2092 := SecMask;
    assertCredits#_2093 := Credits;
    assume wf(assertHeap#_2090, assertMask#_2091, assertSecMask#_2092);
    // begin exhale (assert)
    exhaleMask#_2095 := assertMask#_2091;
    havoc exhaleHeap#_2094;
    exhaledHolds#_2096 := ZeroRefSet;
    // unfolding
    assume (0.0 < unfoldingK#_2105) && ((1000.0 * unfoldingK#_2105) < (real(1) * 0.01));
    predFlag#_2104 := true;
    predRec#_2106 := assertHeap#_2090[this, AVLTreeNode.right];
    predVer#_2107 := Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid];
    assert {:msg "  782.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  782.21: Location might not be readable."} true ==> CanRead(assertMask#_2091, this, AVLTreeNode.right);
    assert {:msg "  782.21: Receiver might be null."} true ==> (assertHeap#_2090[this, AVLTreeNode.right] != null);
    unfoldingHeap#_2100 := assertHeap#_2090;
    unfoldingMask#_2101 := assertMask#_2091;
    unfoldingSecMask#_2102 := assertSecMask#_2092;
    unfoldingCredits#_2103 := assertCredits#_2093;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    // begin exhale (unfolding)
    assert {:msg "  782.11: Unfolding might fail. The permission at 782.21 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  782.11: Unfolding might fail. Insufficient fraction at 782.21 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(unfoldingMask#_2101, unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid)) {
      oldVers#_2112 := unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid];
      havoc newVers#_2113;
      unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_2113;
      assume oldVers#_2112 < unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    // end exhale
    // inhale (unfolding)
    assume unfoldingHeap#_2100[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume unfoldingHeap#_2100[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume unfoldingHeap#_2100[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume (unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume unfoldingHeap#_2100[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume (unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume unfoldingHeap#_2100[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume unfoldingHeap#_2100[this, AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_2106, AVLTreeNode.valid, predVer#_2107, unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume (forall lk#79#514: int :: 
        (0 <= lk#79#514) && (lk#79#514 < Seq#Length(unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#514) < unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key])
      );
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume (real(100) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_2106, AVLTreeNode.valid, predVer#_2107, unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2101[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(unfoldingMask#_2101);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
      assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume (forall rk#80#515: int :: 
        (0 <= rk#80#515) && (rk#80#515 < Seq#Length(unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#515))
      );
    }
    if (!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.key]))
    );
    assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2100[unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume unfoldingHeap#_2100[unfoldingHeap#_2100[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(unfoldingMask#_2101);
    assume wf(unfoldingHeap#_2100, unfoldingMask#_2101, unfoldingSecMask#_2102);
    // end inhale
    Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.key] := true;
    Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
    Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.left] := true;
    Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.right] := true;
    Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
    Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      havoc newPredicateMask#_2117;
      assume (forall ref#_2115: ref :: 
        (forall<T#_33> f#_2116: Field (T#_33) :: 
          (Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_2115, f#_2116] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_2115, f#_2116]) ==> newPredicateMask#_2117[ref#_2115, f#_2116]
        )
      );
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_2117;
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      havoc newPredicateMask#_2120;
      assume (forall ref#_2118: ref :: 
        (forall<T#_34> f#_2119: Field (T#_34) :: 
          (Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_2118, f#_2119] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_2118, f#_2119]) ==> newPredicateMask#_2120[ref#_2118, f#_2119]
        )
      );
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_2120;
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := true;
    }
    if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      Heap[assertHeap#_2090[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
    }
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  782.4: Assertion might not hold. The expression at 782.11 might not evaluate to true."} rbf#70 == 1;
    assertMask#_2091 := exhaleMask#_2095;
    assume IsGoodExhaleState(exhaleHeap#_2094, assertHeap#_2090, assertMask#_2091, exhaledHolds#_2096);
    assertHeap#_2090 := exhaleHeap#_2094;
    assume IsGoodMask(assertMask#_2091);
    assume wf(assertHeap#_2090, assertMask#_2091, assertSecMask#_2092);
    // end exhale
    assume (0.0 < methodCallK#_2125) && ((1000.0 * methodCallK#_2125) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2125) < methodK#_2056);
    // call rebalanceLR
    callHeap#_2121 := Heap;
    callMask#_2122 := Mask;
    callSecMask#_2123 := SecMask;
    callCredits#_2124 := Credits;
    assume wf(callHeap#_2121, callMask#_2122, callSecMask#_2123);
    assert {:msg "  783.4: The target of the method call might be null."} this != null;
    this#516 := this;
    // begin exhale (precondition)
    exhaleMask#_2127 := Mask;
    havoc exhaleHeap#_2126;
    exhaledHolds#_2128 := ZeroRefSet;
    if (!(Heap[this#516, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 803.12 might not hold. The expression at 803.25 might not evaluate to true."} (forall k#106#518: int :: 
        (0 <= k#106#518) && (k#106#518 < Seq#Length(Heap[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys], k#106#518) < Heap[this#516, AVLTreeNode.key])
      );
    }
    assert {:msg "  783.4: The precondition at 805.12 might not hold. The expression at 805.12 might not evaluate to true."} !(Heap[this#516, AVLTreeNode.right] == null);
    assert {:msg "  783.4: The precondition at 810.12 might not hold. The expression at 810.12 might not evaluate to true."} (forall k#107#519: int :: 
      (0 <= k#107#519) && (k#107#519 < Seq#Length(Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#516, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys], k#107#519))
    );
    predRec#_2129 := Heap[this#516, AVLTreeNode.right];
    predFlag#_2131 := true;
    assume #AVLTreeNode.valid#trigger(Heap[this#516, AVLTreeNode.right]);
    predVer#_2130 := Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid];
    assume predRec#_2129 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(100) * 0.01) > 0.0;
    SecMask[predRec#_2129, AVLTreeNode.key] := SecMask[predRec#_2129, AVLTreeNode.key][perm$R := SecMask[predRec#_2129, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_2129 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[predRec#_2129, AVLTreeNode.height] := SecMask[predRec#_2129, AVLTreeNode.height][perm$R := SecMask[predRec#_2129, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_2129 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[predRec#_2129, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2129, AVLTreeNode.left]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    SecMask[predRec#_2129, AVLTreeNode.left] := SecMask[predRec#_2129, AVLTreeNode.left][perm$R := SecMask[predRec#_2129, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_2129 != null;
    assume wf(Heap, Mask, SecMask);
    assume (Heap[predRec#_2129, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2129, AVLTreeNode.right]) == AVLTreeNode#t);
    assume (real(100) * 0.01) > 0.0;
    SecMask[predRec#_2129, AVLTreeNode.right] := SecMask[predRec#_2129, AVLTreeNode.right][perm$R := SecMask[predRec#_2129, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_2129 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[predRec#_2129, AVLTreeNode.keys] := SecMask[predRec#_2129, AVLTreeNode.keys][perm$R := SecMask[predRec#_2129, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume predRec#_2129 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[predRec#_2129, AVLTreeNode.balanceFactor] := SecMask[predRec#_2129, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2129, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[predRec#_2129, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_2129, AVLTreeNode.valid, predVer#_2130, Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.valid]);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.left] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.left] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.left] == null)) {
      assume (forall lk#79#520: int :: 
        (0 <= lk#79#520) && (lk#79#520 < Seq#Length(Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys], lk#79#520) < Heap[predRec#_2129, AVLTreeNode.key])
      );
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.left] == null)) {
      assume Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height] > 0;
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume (real(100) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
      assume #predicateInside#(predRec#_2129, AVLTreeNode.valid, predVer#_2130, Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.valid]);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.right] == null)) {
      assume Heap[predRec#_2129, AVLTreeNode.right] != null;
      assume wf(Heap, Mask, SecMask);
      assume true;
      assume (real(50) * 0.01) > 0.0;
      SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.right] == null)) {
      assume (forall rk#80#521: int :: 
        (0 <= rk#80#521) && (rk#80#521 < Seq#Length(Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2129, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys], rk#80#521))
      );
    }
    if (!(Heap[predRec#_2129, AVLTreeNode.right] == null)) {
      assume Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height] > 0;
    }
    assume Seq#Equal(Heap[predRec#_2129, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2129, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2129, AVLTreeNode.key])), ite(Heap[predRec#_2129, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys])));
    assume Seq#Contains(Heap[predRec#_2129, AVLTreeNode.keys], Heap[predRec#_2129, AVLTreeNode.key]);
    assume (forall kk#81: int :: 
      Seq#Contains(Heap[predRec#_2129, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2129, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2129, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2129, AVLTreeNode.key]))
    );
    assume Heap[predRec#_2129, AVLTreeNode.height] == ite(ite(Heap[predRec#_2129, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2129, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2129, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2129, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[predRec#_2129, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2129, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2129, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2129, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2129, AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap[predRec#_2129, AVLTreeNode.balanceFactor] <= 1;
    assume Heap[predRec#_2129, AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap[predRec#_2129, AVLTreeNode.height] > 0;
    assert {:msg "  783.4: The precondition at 812.12 might not hold. The expression at 812.12 might not evaluate to true."} !(Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.left] == null);
    assert {:msg "  783.4: The precondition at 814.12 might not hold. The expression at 814.12 might not evaluate to true."} (ite(Heap[this#516, AVLTreeNode.left] == null, 0, Heap[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
    assert {:msg "  783.4: The precondition at 815.12 might not hold. The expression at 815.12 might not evaluate to true."} Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
    assert {:msg "  783.4: The precondition at 791.12 might not hold. The permission at 791.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 791.12 might not hold. Insufficient fraction at 791.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2127[this#516, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[this#516, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2127[this#516, AVLTreeNode.key][perm$N]));
    exhaleMask#_2127[this#516, AVLTreeNode.key] := exhaleMask#_2127[this#516, AVLTreeNode.key][perm$R := exhaleMask#_2127[this#516, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 792.12 might not hold. The permission at 792.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 792.12 might not hold. Insufficient fraction at 792.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2127[this#516, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[this#516, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2127[this#516, AVLTreeNode.height][perm$N]));
    exhaleMask#_2127[this#516, AVLTreeNode.height] := exhaleMask#_2127[this#516, AVLTreeNode.height][perm$R := exhaleMask#_2127[this#516, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 793.12 might not hold. The permission at 793.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 793.12 might not hold. Insufficient fraction at 793.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2127[this#516, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[this#516, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2127[this#516, AVLTreeNode.left][perm$N]));
    exhaleMask#_2127[this#516, AVLTreeNode.left] := exhaleMask#_2127[this#516, AVLTreeNode.left][perm$R := exhaleMask#_2127[this#516, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 794.12 might not hold. The permission at 794.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 794.12 might not hold. Insufficient fraction at 794.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2127[this#516, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[this#516, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2127[this#516, AVLTreeNode.right][perm$N]));
    exhaleMask#_2127[this#516, AVLTreeNode.right] := exhaleMask#_2127[this#516, AVLTreeNode.right][perm$R := exhaleMask#_2127[this#516, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 796.12 might not hold. The permission at 796.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 796.12 might not hold. Insufficient fraction at 796.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2127[this#516, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[this#516, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2127[this#516, AVLTreeNode.keys][perm$N]));
    exhaleMask#_2127[this#516, AVLTreeNode.keys] := exhaleMask#_2127[this#516, AVLTreeNode.keys][perm$R := exhaleMask#_2127[this#516, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 797.12 might not hold. The permission at 797.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 797.12 might not hold. Insufficient fraction at 797.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2127[this#516, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[this#516, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2127[this#516, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2127[this#516, AVLTreeNode.balanceFactor] := exhaleMask#_2127[this#516, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2127[this#516, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#516, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 799.12 might not hold. The permission at 799.25 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  783.4: The precondition at 799.12 might not hold. Insufficient fraction at 799.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_2127, Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2126[Heap[this#516, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_2127, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#516, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 800.12 might not hold. The permission at 800.25 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  783.4: The precondition at 800.12 might not hold. Insufficient fraction at 800.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_2127, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#516, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 801.12 might not hold. The permission at 801.25 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  783.4: The precondition at 801.12 might not hold. Insufficient fraction at 801.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_2127, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#516, AVLTreeNode.left] == null)) {
      assert {:msg "  783.4: The precondition at 802.12 might not hold. The permission at 802.25 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  783.4: The precondition at 802.12 might not hold. Insufficient fraction at 802.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_2127, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  783.4: The precondition at 806.12 might not hold. The permission at 806.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 806.12 might not hold. Insufficient fraction at 806.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2127, Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2126[Heap[this#516, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 807.12 might not hold. The permission at 807.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 807.12 might not hold. Insufficient fraction at 807.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 808.12 might not hold. The permission at 808.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 808.12 might not hold. Insufficient fraction at 808.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  783.4: The precondition at 809.12 might not hold. The permission at 809.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  783.4: The precondition at 809.12 might not hold. Insufficient fraction at 809.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2127[Heap[this#516, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2127, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_2127;
    assume IsGoodExhaleState(exhaleHeap#_2126, Heap, Mask, exhaledHolds#_2128);
    Heap := exhaleHeap#_2126;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#517;
    // inhale (postcondition)
    assume !(r#517 == null);
    assume r#517 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#517, AVLTreeNode.valid] := Mask[r#517, AVLTreeNode.valid][perm$R := Mask[r#517, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#517 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#517, AVLTreeNode.height] := Mask[r#517, AVLTreeNode.height][perm$R := Mask[r#517, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#517 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#517, AVLTreeNode.keys] := Mask[r#517, AVLTreeNode.keys][perm$R := Mask[r#517, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#517 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#517, AVLTreeNode.balanceFactor] := Mask[r#517, AVLTreeNode.balanceFactor][perm$R := Mask[r#517, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume Heap[r#517, AVLTreeNode.height] == callHeap#_2121[callHeap#_2121[this#516, AVLTreeNode.right], AVLTreeNode.height];
    assume Seq#Equal(Heap[r#517, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2121[this#516, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2121[callHeap#_2121[this#516, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2121[this#516, AVLTreeNode.key])), callHeap#_2121[callHeap#_2121[this#516, AVLTreeNode.right], AVLTreeNode.keys]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#68 := r#517;
  } else {
    assume (0.0 < methodCallK#_2153) && ((1000.0 * methodCallK#_2153) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2153) < methodK#_2056);
    // call rebalanceLL
    callHeap#_2149 := Heap;
    callMask#_2150 := Mask;
    callSecMask#_2151 := SecMask;
    callCredits#_2152 := Credits;
    assume wf(callHeap#_2149, callMask#_2150, callSecMask#_2151);
    assert {:msg "  785.4: The target of the method call might be null."} this != null;
    this#524 := this;
    // begin exhale (precondition)
    exhaleMask#_2155 := Mask;
    havoc exhaleHeap#_2154;
    exhaledHolds#_2156 := ZeroRefSet;
    if (!(Heap[this#524, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 858.12 might not hold. The expression at 858.25 might not evaluate to true."} (forall k#112#526: int :: 
        (0 <= k#112#526) && (k#112#526 < Seq#Length(Heap[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys], k#112#526) < Heap[this#524, AVLTreeNode.key])
      );
    }
    assert {:msg "  785.4: The precondition at 860.12 might not hold. The expression at 860.12 might not evaluate to true."} !(Heap[this#524, AVLTreeNode.right] == null);
    assert {:msg "  785.4: The precondition at 865.12 might not hold. The expression at 865.12 might not evaluate to true."} (forall k#113#527: int :: 
      (0 <= k#113#527) && (k#113#527 < Seq#Length(Heap[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#524, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys], k#113#527))
    );
    assert {:msg "  785.4: The precondition at 867.12 might not hold. The expression at 867.12 might not evaluate to true."} (ite(Heap[this#524, AVLTreeNode.left] == null, 0, Heap[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
    assert {:msg "  785.4: The precondition at 868.12 might not hold. The expression at 868.12 might not evaluate to true."} Heap[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
    assert {:msg "  785.4: The precondition at 846.12 might not hold. The permission at 846.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 846.12 might not hold. Insufficient fraction at 846.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2155[this#524, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[this#524, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2155[this#524, AVLTreeNode.key][perm$N]));
    exhaleMask#_2155[this#524, AVLTreeNode.key] := exhaleMask#_2155[this#524, AVLTreeNode.key][perm$R := exhaleMask#_2155[this#524, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 847.12 might not hold. The permission at 847.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 847.12 might not hold. Insufficient fraction at 847.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2155[this#524, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[this#524, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2155[this#524, AVLTreeNode.height][perm$N]));
    exhaleMask#_2155[this#524, AVLTreeNode.height] := exhaleMask#_2155[this#524, AVLTreeNode.height][perm$R := exhaleMask#_2155[this#524, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 848.12 might not hold. The permission at 848.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 848.12 might not hold. Insufficient fraction at 848.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2155[this#524, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[this#524, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2155[this#524, AVLTreeNode.left][perm$N]));
    exhaleMask#_2155[this#524, AVLTreeNode.left] := exhaleMask#_2155[this#524, AVLTreeNode.left][perm$R := exhaleMask#_2155[this#524, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 849.12 might not hold. The permission at 849.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 849.12 might not hold. Insufficient fraction at 849.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2155[this#524, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[this#524, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2155[this#524, AVLTreeNode.right][perm$N]));
    exhaleMask#_2155[this#524, AVLTreeNode.right] := exhaleMask#_2155[this#524, AVLTreeNode.right][perm$R := exhaleMask#_2155[this#524, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 851.12 might not hold. The permission at 851.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 851.12 might not hold. Insufficient fraction at 851.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2155[this#524, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[this#524, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2155[this#524, AVLTreeNode.keys][perm$N]));
    exhaleMask#_2155[this#524, AVLTreeNode.keys] := exhaleMask#_2155[this#524, AVLTreeNode.keys][perm$R := exhaleMask#_2155[this#524, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 852.12 might not hold. The permission at 852.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 852.12 might not hold. Insufficient fraction at 852.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2155[this#524, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[this#524, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2155[this#524, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2155[this#524, AVLTreeNode.balanceFactor] := exhaleMask#_2155[this#524, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2155[this#524, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    if (!(Heap[this#524, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 854.12 might not hold. The permission at 854.25 might not be positive."} (real(100) * 0.01) > 0.0;
      assert {:msg "  785.4: The precondition at 854.12 might not hold. Insufficient fraction at 854.25 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
      if (!CanRead(exhaleMask#_2155, Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid)) {
        assume Heap[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2154[Heap[this#524, AVLTreeNode.left], AVLTreeNode.valid];
      }
      assume wf(Heap, exhaleMask#_2155, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#524, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 855.12 might not hold. The permission at 855.25 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  785.4: The precondition at 855.12 might not hold. Insufficient fraction at 855.25 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_2155, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#524, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 856.12 might not hold. The permission at 856.25 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  785.4: The precondition at 856.12 might not hold. Insufficient fraction at 856.25 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_2155, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    if (!(Heap[this#524, AVLTreeNode.left] == null)) {
      assert {:msg "  785.4: The precondition at 857.12 might not hold. The permission at 857.25 might not be positive."} (real(50) * 0.01) > 0.0;
      assert {:msg "  785.4: The precondition at 857.12 might not hold. Insufficient fraction at 857.25 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
      assume wf(Heap, exhaleMask#_2155, SecMask);
      assume wf(Heap, Mask, SecMask);
    }
    assert {:msg "  785.4: The precondition at 861.12 might not hold. The permission at 861.12 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 861.12 might not hold. Insufficient fraction at 861.12 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2155, Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2154[Heap[this#524, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 862.12 might not hold. The permission at 862.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 862.12 might not hold. Insufficient fraction at 862.12 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 863.12 might not hold. The permission at 863.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 863.12 might not hold. Insufficient fraction at 863.12 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    assert {:msg "  785.4: The precondition at 864.12 might not hold. The permission at 864.12 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  785.4: The precondition at 864.12 might not hold. Insufficient fraction at 864.12 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2155[Heap[this#524, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2155, SecMask);
    assume wf(Heap, Mask, SecMask);
    Mask := exhaleMask#_2155;
    assume IsGoodExhaleState(exhaleHeap#_2154, Heap, Mask, exhaledHolds#_2156);
    Heap := exhaleHeap#_2154;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end exhale
    havoc r#525;
    // inhale (postcondition)
    assume !(r#525 == null);
    assume r#525 != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[r#525, AVLTreeNode.valid] := Mask[r#525, AVLTreeNode.valid][perm$R := Mask[r#525, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#525 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#525, AVLTreeNode.height] := Mask[r#525, AVLTreeNode.height][perm$R := Mask[r#525, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#525 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#525, AVLTreeNode.keys] := Mask[r#525, AVLTreeNode.keys][perm$R := Mask[r#525, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume r#525 != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[r#525, AVLTreeNode.balanceFactor] := Mask[r#525, AVLTreeNode.balanceFactor][perm$R := Mask[r#525, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
    assume (Heap[r#525, AVLTreeNode.height] == callHeap#_2149[callHeap#_2149[this#524, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#525, AVLTreeNode.height] == (callHeap#_2149[callHeap#_2149[this#524, AVLTreeNode.right], AVLTreeNode.height] + 1));
    assume Seq#Equal(Heap[r#525, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2149[this#524, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2149[callHeap#_2149[this#524, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2149[this#524, AVLTreeNode.key])), callHeap#_2149[callHeap#_2149[this#524, AVLTreeNode.right], AVLTreeNode.keys]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    // end inhale
    r#68 := r#525;
  }
  // begin exhale (postcondition)
  exhaleMask#_2175 := Mask;
  havoc exhaleHeap#_2174;
  exhaledHolds#_2176 := ZeroRefSet;
  assert {:msg "  745.2: The postcondition at 770.11 might not hold. The expression at 770.11 might not evaluate to true."} !(r#68 == null);
  assert {:msg "  745.2: The postcondition at 776.11 might not hold. The expression at 776.11 might not evaluate to true."} (Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#68, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  745.2: The postcondition at 777.11 might not hold. The expression at 777.11 might not evaluate to true."} Seq#Equal(Heap[r#68, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  745.2: The postcondition at 771.11 might not hold. The permission at 771.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  745.2: The postcondition at 771.11 might not hold. Insufficient fraction at 771.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2175[r#68, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2175[r#68, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2175[r#68, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2175[r#68, AVLTreeNode.valid] := exhaleMask#_2175[r#68, AVLTreeNode.valid][perm$R := exhaleMask#_2175[r#68, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_2175, r#68, AVLTreeNode.valid)) {
    assume Heap[r#68, AVLTreeNode.valid] < exhaleHeap#_2174[r#68, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_2175, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  745.2: The postcondition at 772.11 might not hold. The permission at 772.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  745.2: The postcondition at 772.11 might not hold. Insufficient fraction at 772.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2175[r#68, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2175[r#68, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2175[r#68, AVLTreeNode.height][perm$N]));
  exhaleMask#_2175[r#68, AVLTreeNode.height] := exhaleMask#_2175[r#68, AVLTreeNode.height][perm$R := exhaleMask#_2175[r#68, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2175, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  745.2: The postcondition at 773.11 might not hold. The permission at 773.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  745.2: The postcondition at 773.11 might not hold. Insufficient fraction at 773.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2175[r#68, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2175[r#68, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2175[r#68, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2175[r#68, AVLTreeNode.keys] := exhaleMask#_2175[r#68, AVLTreeNode.keys][perm$R := exhaleMask#_2175[r#68, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2175, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  745.2: The postcondition at 774.11 might not hold. The permission at 774.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  745.2: The postcondition at 774.11 might not hold. Insufficient fraction at 774.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2175[r#68, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2175[r#68, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2175[r#68, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2175[r#68, AVLTreeNode.balanceFactor] := exhaleMask#_2175[r#68, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2175[r#68, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2175, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2175;
  assume IsGoodExhaleState(exhaleHeap#_2174, Heap, Mask, exhaledHolds#_2176);
  Heap := exhaleHeap#_2174;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  745.2: Method might lock/unlock more than allowed."} (forall lk#_2181: ref :: 
    { Heap[lk#_2181, held] }
    { Heap[lk#_2181, rdheld] }
    (((0 < Heap[lk#_2181, held]) == (0 < old(Heap)[lk#_2181, held])) && (Heap[lk#_2181, rdheld] == old(Heap)[lk#_2181, rdheld])) || false
  );
  assert {:msg "  745.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.rebalanceLR
// -------------------------------------------

// definedness check for method AVLTreeNode.rebalanceLR
procedure AVLTreeNode.rebalanceLR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#71: ref where (r#71 == null) || (dtype(r#71) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2182: real;
  var k#106#531: int where true;
  var k#107#533: int where true;
  var predRec#_2184: ref;
  var predFlag#_2186: bool;
  var predVer#_2185: int;
  var unfoldingK#_2192: real;
  var predFlag#_2191: bool;
  var predRec#_2193: ref;
  var predVer#_2194: int;
  var unfoldingHeap#_2187: HeapType;
  var unfoldingMask#_2188: MaskType;
  var unfoldingSecMask#_2189: MaskType;
  var unfoldingCredits#_2190: CreditsType;
  var oldVers#_2199: int;
  var newVers#_2200: int;
  var newPredicateMask#_2204: PMaskType;
  var newPredicateMask#_2207: PMaskType;
  assume (0.0 < methodK#_2182) && ((1000.0 * methodK#_2182) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  799.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  799.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  799.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  799.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  799.25: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  799.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  799.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  800.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  800.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  800.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  800.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  801.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  801.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  801.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  801.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  802.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  802.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  802.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  802.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  803.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  803.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#531) ==> (this != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#531) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#531) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#531) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  803.12: Receiver might be null."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  803.12: Location might not be readable."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  803.50: Sequence index might be negative."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#106#531);
    assert {:msg "  803.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  803.54: Receiver might be null."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  803.54: Location might not be readable."} true && (0 <= k#106#531) && (k#106#531 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#106#530: int :: 
      (0 <= k#106#530) && (k#106#530 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#106#530) < Heap[this, AVLTreeNode.key])
    );
  }
  assert {:msg "  805.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  805.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  806.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  806.12: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
  assert {:msg "  806.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  807.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  807.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  808.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  808.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  809.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  809.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#533) ==> (this != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#533) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#533) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#533) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  810.38: Receiver might be null."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  810.38: Location might not be readable."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  810.12: Receiver might be null."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  810.12: Location might not be readable."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  810.44: Sequence index might be negative."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#107#533);
  assert {:msg "  810.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#107#533) && (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#107#533 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#107#532: int :: 
    (0 <= k#107#532) && (k#107#532 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#107#532))
  );
  predRec#_2184 := Heap[this, AVLTreeNode.right];
  predFlag#_2186 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  predVer#_2185 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  // unfolding
  assume (0.0 < unfoldingK#_2192) && ((1000.0 * unfoldingK#_2192) < (real(1) * 0.01));
  predFlag#_2191 := true;
  predRec#_2193 := Heap[this, AVLTreeNode.right];
  predVer#_2194 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assert {:msg "  812.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  812.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  812.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  unfoldingHeap#_2187 := Heap;
  unfoldingMask#_2188 := Mask;
  unfoldingSecMask#_2189 := SecMask;
  unfoldingCredits#_2190 := Credits;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  // begin exhale (unfolding)
  assert {:msg "  812.12: Unfolding might fail. The permission at 812.22 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  812.12: Unfolding might fail. Insufficient fraction at 812.22 for AVLTreeNode.valid."} ((real(100) * 0.01) <= unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(unfoldingMask#_2188, unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid)) {
    oldVers#_2199 := unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid];
    havoc newVers#_2200;
    unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_2200;
    assume oldVers#_2199 < unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.valid];
  }
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  // end exhale
  // inhale (unfolding)
  assume unfoldingHeap#_2187[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume unfoldingHeap#_2187[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume unfoldingHeap#_2187[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume (unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume unfoldingHeap#_2187[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume (unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume unfoldingHeap#_2187[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume unfoldingHeap#_2187[this, AVLTreeNode.right] != null;
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2193, AVLTreeNode.valid, predVer#_2194, unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#534: int :: 
      (0 <= lk#79#534) && (lk#79#534 < Seq#Length(unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#534) < unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key])
    );
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume (real(100) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2193, AVLTreeNode.valid, predVer#_2194, unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := unfoldingMask#_2188[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(unfoldingMask#_2188);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
    assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#535: int :: 
      (0 <= rk#80#535) && (rk#80#535 < Seq#Length(unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#535))
    );
  }
  if (!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key])), ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.keys], unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.key]))
  );
  assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, unfoldingHeap#_2187[unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume unfoldingHeap#_2187[unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(unfoldingMask#_2188);
  assume wf(unfoldingHeap#_2187, unfoldingMask#_2188, unfoldingSecMask#_2189);
  // end inhale
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.key] := true;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.height] := true;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.left] := true;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.right] := true;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := true;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    havoc newPredicateMask#_2204;
    assume (forall ref#_2202: ref :: 
      (forall<T#_35> f#_2203: Field (T#_35) :: 
        (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_2202, f#_2203] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid#m][ref#_2202, f#_2203]) ==> newPredicateMask#_2204[ref#_2202, f#_2203]
      )
    );
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_2204;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    havoc newPredicateMask#_2207;
    assume (forall ref#_2205: ref :: 
      (forall<T#_36> f#_2206: Field (T#_36) :: 
        (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][ref#_2205, f#_2206] || Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid#m][ref#_2205, f#_2206]) ==> newPredicateMask#_2207[ref#_2205, f#_2206]
      )
    );
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m] := newPredicateMask#_2207;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := true;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid#m][Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := true;
  }
  assert {:msg "  812.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  812.37: Location might not be readable."} true ==> CanRead(unfoldingMask#_2188, this, AVLTreeNode.right);
  assert {:msg "  812.37: Receiver might be null."} true ==> (unfoldingHeap#_2187[this, AVLTreeNode.right] != null);
  assert {:msg "  812.37: Location might not be readable."} true ==> CanRead(unfoldingMask#_2188, unfoldingHeap#_2187[this, AVLTreeNode.right], AVLTreeNode.left);
  assume wf(Heap, Mask, SecMask);
  assume !(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null);
  assert {:msg "  814.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  814.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  814.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  814.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  814.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  814.26: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  814.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  814.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  814.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  814.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assert {:msg "  815.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  815.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  815.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  815.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_2212: Field (PMaskType) :: 
    (forall ref#_2211: ref :: 
      Heap[ref#_2211, pmask#_2212] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#71 == null);
  assert {:msg "  818.11: Receiver might be null."} r#71 != null;
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.valid] := Mask[r#71, AVLTreeNode.valid][perm$R := Mask[r#71, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.height] := Mask[r#71, AVLTreeNode.height][perm$R := Mask[r#71, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.keys] := Mask[r#71, AVLTreeNode.keys][perm$R := Mask[r#71, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.balanceFactor] := Mask[r#71, AVLTreeNode.balanceFactor][perm$R := Mask[r#71, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  823.11: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  823.11: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.height);
  assert {:msg "  823.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  823.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  823.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  823.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume Heap[r#71, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height];
  assert {:msg "  824.11: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  824.11: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.keys);
  assert {:msg "  824.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.26: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  824.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  824.51: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  824.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  824.51: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  824.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.71: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  824.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.84: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  824.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  824.84: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.rebalanceLR
procedure AVLTreeNode.rebalanceLR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#71: ref where (r#71 == null) || (dtype(r#71) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2182: real;
  var predRec#_2215: ref;
  var predFlag#_2217: bool;
  var predVer#_2216: int;
  var assertHeap#_2223: HeapType;
  var assertMask#_2224: MaskType;
  var assertSecMask#_2225: MaskType;
  var assertCredits#_2226: CreditsType;
  var exhaleMask#_2228: MaskType;
  var exhaleHeap#_2227: HeapType;
  var exhaledHolds#_2229: RefSet;
  var k#108#541: int where true;
  var predRec#_2231: ref;
  var predVer#_2232: int;
  var unfoldK#_2230: real;
  var oldVers#_2237: int;
  var newVers#_2238: int;
  var assertHeap#_2240: HeapType;
  var assertMask#_2241: MaskType;
  var assertSecMask#_2242: MaskType;
  var assertCredits#_2243: CreditsType;
  var exhaleMask#_2245: MaskType;
  var exhaleHeap#_2244: HeapType;
  var exhaledHolds#_2246: RefSet;
  var k#109#546: int where true;
  var predRec#_2248: ref;
  var predVer#_2249: int;
  var unfoldK#_2247: real;
  var oldVers#_2254: int;
  var newVers#_2255: int;
  var assertHeap#_2257: HeapType;
  var assertMask#_2258: MaskType;
  var assertSecMask#_2259: MaskType;
  var assertCredits#_2260: CreditsType;
  var exhaleMask#_2262: MaskType;
  var exhaleHeap#_2261: HeapType;
  var exhaledHolds#_2263: RefSet;
  var k#110#551: int where true;
  var methodCallK#_2268: real;
  var this#553: ref where (this#553 == null) || (dtype(this#553) == AVLTreeNode#t);
  var callHeap#_2264: HeapType;
  var callMask#_2265: MaskType;
  var callSecMask#_2266: MaskType;
  var callCredits#_2267: CreditsType;
  var exhaleMask#_2270: MaskType;
  var exhaleHeap#_2269: HeapType;
  var exhaledHolds#_2271: RefSet;
  var isHeld#_2286: int;
  var isRdHeld#_2287: bool;
  var assertHeap#_2289: HeapType;
  var assertMask#_2290: MaskType;
  var assertSecMask#_2291: MaskType;
  var assertCredits#_2292: CreditsType;
  var exhaleMask#_2294: MaskType;
  var exhaleHeap#_2293: HeapType;
  var exhaledHolds#_2295: RefSet;
  var k#111#559: int where true;
  var methodCallK#_2300: real;
  var this#561: ref where (this#561 == null) || (dtype(this#561) == AVLTreeNode#t);
  var callHeap#_2296: HeapType;
  var callMask#_2297: MaskType;
  var callSecMask#_2298: MaskType;
  var callCredits#_2299: CreditsType;
  var exhaleMask#_2302: MaskType;
  var exhaleHeap#_2301: HeapType;
  var exhaledHolds#_2303: RefSet;
  var isHeld#_2318: int;
  var isRdHeld#_2319: bool;
  var methodCallK#_2325: real;
  var this#566: ref where (this#566 == null) || (dtype(this#566) == AVLTreeNode#t);
  var callHeap#_2321: HeapType;
  var callMask#_2322: MaskType;
  var callSecMask#_2323: MaskType;
  var callCredits#_2324: CreditsType;
  var exhaleMask#_2327: MaskType;
  var exhaleHeap#_2326: HeapType;
  var exhaledHolds#_2328: RefSet;
  var isHeld#_2343: int;
  var isRdHeld#_2344: bool;
  var exhaleMask#_2347: MaskType;
  var exhaleHeap#_2346: HeapType;
  var exhaledHolds#_2348: RefSet;
  assume (0.0 < methodK#_2182) && ((1000.0 * methodK#_2182) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#106#536: int :: 
      (0 <= k#106#536) && (k#106#536 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#106#536) < Heap[this, AVLTreeNode.key])
    );
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#107#537: int :: 
    (0 <= k#107#537) && (k#107#537 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#107#537))
  );
  predRec#_2215 := Heap[this, AVLTreeNode.right];
  predFlag#_2217 := true;
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  predVer#_2216 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume predRec#_2215 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2215, AVLTreeNode.key] := SecMask[predRec#_2215, AVLTreeNode.key][perm$R := SecMask[predRec#_2215, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2215 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2215, AVLTreeNode.height] := SecMask[predRec#_2215, AVLTreeNode.height][perm$R := SecMask[predRec#_2215, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2215 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2215, AVLTreeNode.left] == null) || (dtype(Heap[predRec#_2215, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2215, AVLTreeNode.left] := SecMask[predRec#_2215, AVLTreeNode.left][perm$R := SecMask[predRec#_2215, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2215 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[predRec#_2215, AVLTreeNode.right] == null) || (dtype(Heap[predRec#_2215, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  SecMask[predRec#_2215, AVLTreeNode.right] := SecMask[predRec#_2215, AVLTreeNode.right][perm$R := SecMask[predRec#_2215, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2215 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2215, AVLTreeNode.keys] := SecMask[predRec#_2215, AVLTreeNode.keys][perm$R := SecMask[predRec#_2215, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume predRec#_2215 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  SecMask[predRec#_2215, AVLTreeNode.balanceFactor] := SecMask[predRec#_2215, AVLTreeNode.balanceFactor][perm$R := SecMask[predRec#_2215, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[predRec#_2215, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.valid] := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2215, AVLTreeNode.valid, predVer#_2216, Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height] := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys] := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.left] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.left] == null)) {
    assume (forall lk#79#538: int :: 
      (0 <= lk#79#538) && (lk#79#538 < Seq#Length(Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys], lk#79#538) < Heap[predRec#_2215, AVLTreeNode.key])
    );
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.left] == null)) {
    assume Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.valid] := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.valid][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2215, AVLTreeNode.valid, predVer#_2216, Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height] := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys] := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.right] == null)) {
    assume Heap[predRec#_2215, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.balanceFactor] := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := SecMask[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.right] == null)) {
    assume (forall rk#80#539: int :: 
      (0 <= rk#80#539) && (rk#80#539 < Seq#Length(Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[predRec#_2215, AVLTreeNode.key] < Seq#Index(Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys], rk#80#539))
    );
  }
  if (!(Heap[predRec#_2215, AVLTreeNode.right] == null)) {
    assume Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[predRec#_2215, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[predRec#_2215, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[predRec#_2215, AVLTreeNode.key])), ite(Heap[predRec#_2215, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[predRec#_2215, AVLTreeNode.keys], Heap[predRec#_2215, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[predRec#_2215, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[predRec#_2215, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[predRec#_2215, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[predRec#_2215, AVLTreeNode.key]))
  );
  assume Heap[predRec#_2215, AVLTreeNode.height] == ite(ite(Heap[predRec#_2215, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[predRec#_2215, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[predRec#_2215, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[predRec#_2215, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[predRec#_2215, AVLTreeNode.balanceFactor] == (ite(Heap[predRec#_2215, AVLTreeNode.left] == null, 0, Heap[Heap[predRec#_2215, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[predRec#_2215, AVLTreeNode.right] == null, 0, Heap[Heap[predRec#_2215, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[predRec#_2215, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[predRec#_2215, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[predRec#_2215, AVLTreeNode.height] > 0;
  assume !(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_2222: Field (PMaskType) :: 
    (forall ref#_2221: ref :: 
      Heap[ref#_2221, pmask#_2222] == ZeroPMask
    )
  );
  // assert
  assertHeap#_2223 := Heap;
  assertMask#_2224 := Mask;
  assertSecMask#_2225 := SecMask;
  assertCredits#_2226 := Credits;
  assume wf(assertHeap#_2223, assertMask#_2224, assertSecMask#_2225);
  // begin exhale (assert)
  exhaleMask#_2228 := assertMask#_2224;
  havoc exhaleHeap#_2227;
  exhaledHolds#_2229 := ZeroRefSet;
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#541) ==> (this != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#541) ==> CanRead(assertMask#_2224, this, AVLTreeNode.right);
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#541) ==> (assertHeap#_2223[this, AVLTreeNode.right] != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#541) ==> CanRead(assertMask#_2224, assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  826.36: Receiver might be null."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  826.36: Location might not be readable."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2224, this, AVLTreeNode.key);
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2224, this, AVLTreeNode.right);
  assert {:msg "  826.10: Receiver might be null."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2223[this, AVLTreeNode.right] != null);
  assert {:msg "  826.10: Location might not be readable."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2224, assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  826.42: Sequence index might be negative."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#108#541);
  assert {:msg "  826.42: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#108#541) && (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#108#541 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  826.3: Assertion might not hold. The expression at 826.10 might not evaluate to true."} (forall k#108#540: int :: 
    (0 <= k#108#540) && (k#108#540 < Seq#Length(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2223[this, AVLTreeNode.key] < Seq#Index(assertHeap#_2223[assertHeap#_2223[this, AVLTreeNode.right], AVLTreeNode.keys], k#108#540))
  );
  assertMask#_2224 := exhaleMask#_2228;
  assume IsGoodExhaleState(exhaleHeap#_2227, assertHeap#_2223, assertMask#_2224, exhaledHolds#_2229);
  assertHeap#_2223 := exhaleHeap#_2227;
  assume IsGoodMask(assertMask#_2224);
  assume wf(assertHeap#_2223, assertMask#_2224, assertSecMask#_2225);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  predRec#_2231 := Heap[this, AVLTreeNode.right];
  predVer#_2232 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume (0.0 < unfoldK#_2230) && (unfoldK#_2230 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_2230) < methodK#_2182);
  assert {:msg "  827.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  827.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  827.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  assert {:msg "  827.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  827.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
    oldVers#_2237 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    havoc newVers#_2238;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_2238;
    assume oldVers#_2237 < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2231, AVLTreeNode.valid, predVer#_2232, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#543: int :: 
      (0 <= lk#79#543) && (lk#79#543 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#543) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2231, AVLTreeNode.valid, predVer#_2232, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#544: int :: 
      (0 <= rk#80#544) && (rk#80#544 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#544))
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]))
  );
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  828.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  828.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  828.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  828.8: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  r#71 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  // assert
  assertHeap#_2240 := Heap;
  assertMask#_2241 := Mask;
  assertSecMask#_2242 := SecMask;
  assertCredits#_2243 := Credits;
  assume wf(assertHeap#_2240, assertMask#_2241, assertSecMask#_2242);
  // begin exhale (assert)
  exhaleMask#_2245 := assertMask#_2241;
  havoc exhaleHeap#_2244;
  exhaledHolds#_2246 := ZeroRefSet;
  assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#109#546) ==> (r#71 != null);
  assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#109#546) ==> CanRead(assertMask#_2241, r#71, AVLTreeNode.keys);
  assert {:msg "  829.32: Receiver might be null."} true && (0 <= k#109#546) && (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  829.32: Location might not be readable."} true && (0 <= k#109#546) && (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> CanRead(assertMask#_2241, this, AVLTreeNode.key);
  assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#109#546) && (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> (r#71 != null);
  assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#109#546) && (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> CanRead(assertMask#_2241, r#71, AVLTreeNode.keys);
  assert {:msg "  829.38: Sequence index might be negative."} true && (0 <= k#109#546) && (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> (0 <= k#109#546);
  assert {:msg "  829.38: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#109#546) && (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> (k#109#546 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys]));
  assert {:msg "  829.3: Assertion might not hold. The expression at 829.10 might not evaluate to true."} (forall k#109#545: int :: 
    (0 <= k#109#545) && (k#109#545 < Seq#Length(assertHeap#_2240[r#71, AVLTreeNode.keys])) ==> (assertHeap#_2240[this, AVLTreeNode.key] < Seq#Index(assertHeap#_2240[r#71, AVLTreeNode.keys], k#109#545))
  );
  assertMask#_2241 := exhaleMask#_2245;
  assume IsGoodExhaleState(exhaleHeap#_2244, assertHeap#_2240, assertMask#_2241, exhaledHolds#_2246);
  assertHeap#_2240 := exhaleHeap#_2244;
  assume IsGoodMask(assertMask#_2241);
  assume wf(assertHeap#_2240, assertMask#_2241, assertSecMask#_2242);
  // end exhale
  // unfold
  assume #AVLTreeNode.valid#trigger(r#71);
  predRec#_2248 := r#71;
  predVer#_2249 := Heap[r#71, AVLTreeNode.valid];
  assume (0.0 < unfoldK#_2247) && (unfoldK#_2247 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_2247) < methodK#_2182);
  assert {:msg "  830.3: The target of the fold statement might be null."} r#71 != null;
  // begin exhale (unfold)
  assert {:msg "  830.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  830.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[r#71, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[r#71, AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[r#71, AVLTreeNode.valid][perm$N]));
  Mask[r#71, AVLTreeNode.valid] := Mask[r#71, AVLTreeNode.valid][perm$R := Mask[r#71, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, r#71, AVLTreeNode.valid)) {
    oldVers#_2254 := Heap[r#71, AVLTreeNode.valid];
    havoc newVers#_2255;
    Heap[r#71, AVLTreeNode.valid] := newVers#_2255;
    assume oldVers#_2254 < Heap[r#71, AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.key] := Mask[r#71, AVLTreeNode.key][perm$R := Mask[r#71, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.height] := Mask[r#71, AVLTreeNode.height][perm$R := Mask[r#71, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#71, AVLTreeNode.left] == null) || (dtype(Heap[r#71, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.left] := Mask[r#71, AVLTreeNode.left][perm$R := Mask[r#71, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[r#71, AVLTreeNode.right] == null) || (dtype(Heap[r#71, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.right] := Mask[r#71, AVLTreeNode.right][perm$R := Mask[r#71, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.keys] := Mask[r#71, AVLTreeNode.keys][perm$R := Mask[r#71, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#71 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#71, AVLTreeNode.balanceFactor] := Mask[r#71, AVLTreeNode.balanceFactor][perm$R := Mask[r#71, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2248, AVLTreeNode.valid, predVer#_2249, Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume (forall lk#79#548: int :: 
      (0 <= lk#79#548) && (lk#79#548 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], lk#79#548) < Heap[r#71, AVLTreeNode.key])
    );
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2248, AVLTreeNode.valid, predVer#_2249, Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume (forall rk#80#549: int :: 
      (0 <= rk#80#549) && (rk#80#549 < Seq#Length(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#71, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], rk#80#549))
    );
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#71, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#71, AVLTreeNode.key])), ite(Heap[r#71, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[r#71, AVLTreeNode.keys], Heap[r#71, AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[r#71, AVLTreeNode.keys], kk#81) <==> ((((!(Heap[r#71, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[r#71, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[r#71, AVLTreeNode.key]))
  );
  assume Heap[r#71, AVLTreeNode.height] == ite(ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[r#71, AVLTreeNode.balanceFactor] == (ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[r#71, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[r#71, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[r#71, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assert
  assertHeap#_2257 := Heap;
  assertMask#_2258 := Mask;
  assertSecMask#_2259 := SecMask;
  assertCredits#_2260 := Credits;
  assume wf(assertHeap#_2257, assertMask#_2258, assertSecMask#_2259);
  // begin exhale (assert)
  exhaleMask#_2262 := assertMask#_2258;
  havoc exhaleHeap#_2261;
  exhaledHolds#_2263 := ZeroRefSet;
  assert {:msg "  831.10: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  831.10: Location might not be readable."} true ==> CanRead(assertMask#_2258, r#71, AVLTreeNode.left);
  if (!(assertHeap#_2257[r#71, AVLTreeNode.left] == null)) {
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#551) ==> (r#71 != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#551) ==> CanRead(assertMask#_2258, r#71, AVLTreeNode.left);
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#551) ==> (assertHeap#_2257[r#71, AVLTreeNode.left] != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#551) ==> CanRead(assertMask#_2258, assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  831.54: Receiver might be null."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  831.54: Location might not be readable."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2258, this, AVLTreeNode.key);
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (r#71 != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2258, r#71, AVLTreeNode.left);
    assert {:msg "  831.10: Receiver might be null."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_2257[r#71, AVLTreeNode.left] != null);
    assert {:msg "  831.10: Location might not be readable."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(assertMask#_2258, assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  831.60: Sequence index might be negative."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#110#551);
    assert {:msg "  831.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#110#551) && (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#110#551 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  831.3: Assertion might not hold. The expression at 831.27 might not evaluate to true."} (forall k#110#550: int :: 
      (0 <= k#110#550) && (k#110#550 < Seq#Length(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys])) ==> (assertHeap#_2257[this, AVLTreeNode.key] < Seq#Index(assertHeap#_2257[assertHeap#_2257[r#71, AVLTreeNode.left], AVLTreeNode.keys], k#110#550))
    );
  }
  assertMask#_2258 := exhaleMask#_2262;
  assume IsGoodExhaleState(exhaleHeap#_2261, assertHeap#_2257, assertMask#_2258, exhaledHolds#_2263);
  assertHeap#_2257 := exhaleHeap#_2261;
  assume IsGoodMask(assertMask#_2258);
  assume wf(assertHeap#_2257, assertMask#_2258, assertSecMask#_2259);
  // end exhale
  // update field left
  assert {:msg "  832.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  832.3: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  832.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  assert {:msg "  832.17: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  832.17: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.right);
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Heap[r#71, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_2268) && ((1000.0 * methodCallK#_2268) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2268) < methodK#_2182);
  // call close
  callHeap#_2264 := Heap;
  callMask#_2265 := Mask;
  callSecMask#_2266 := SecMask;
  callCredits#_2267 := Credits;
  assume wf(callHeap#_2264, callMask#_2265, callSecMask#_2266);
  assert {:msg "  833.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  833.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  833.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#553 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_2270 := Mask;
  havoc exhaleHeap#_2269;
  exhaledHolds#_2271 := ZeroRefSet;
  if (!(Heap[this#553, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#554: int :: 
      (0 <= k#92#554) && (k#92#554 < Seq#Length(Heap[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys], k#92#554) < Heap[this#553, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#553, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#555: int :: 
      (0 <= k#93#555) && (k#93#555 < Seq#Length(Heap[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#553, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys], k#93#555))
    );
  }
  assert {:msg "  833.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#553, AVLTreeNode.left] == null, 0, Heap[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#553, AVLTreeNode.right] == null, 0, Heap[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  833.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#553, AVLTreeNode.left] == null, 0, Heap[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#553, AVLTreeNode.right] == null, 0, Heap[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  833.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  833.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2270[this#553, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[this#553, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2270[this#553, AVLTreeNode.key][perm$N]));
  exhaleMask#_2270[this#553, AVLTreeNode.key] := exhaleMask#_2270[this#553, AVLTreeNode.key][perm$R := exhaleMask#_2270[this#553, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2270, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  833.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2270[this#553, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[this#553, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2270[this#553, AVLTreeNode.height][perm$N]));
  exhaleMask#_2270[this#553, AVLTreeNode.height] := exhaleMask#_2270[this#553, AVLTreeNode.height][perm$R := exhaleMask#_2270[this#553, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2270, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  833.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2270[this#553, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[this#553, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2270[this#553, AVLTreeNode.left][perm$N]));
  exhaleMask#_2270[this#553, AVLTreeNode.left] := exhaleMask#_2270[this#553, AVLTreeNode.left][perm$R := exhaleMask#_2270[this#553, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2270, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  833.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2270[this#553, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[this#553, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2270[this#553, AVLTreeNode.right][perm$N]));
  exhaleMask#_2270[this#553, AVLTreeNode.right] := exhaleMask#_2270[this#553, AVLTreeNode.right][perm$R := exhaleMask#_2270[this#553, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2270, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  833.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2270[this#553, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[this#553, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2270[this#553, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2270[this#553, AVLTreeNode.keys] := exhaleMask#_2270[this#553, AVLTreeNode.keys][perm$R := exhaleMask#_2270[this#553, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2270, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  833.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  833.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2270[this#553, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[this#553, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2270[this#553, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2270[this#553, AVLTreeNode.balanceFactor] := exhaleMask#_2270[this#553, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2270[this#553, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2270, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#553, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2270, Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2269[Heap[this#553, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.left] == null)) {
    assert {:msg "  833.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2270, Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2269[Heap[this#553, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#553, AVLTreeNode.right] == null)) {
    assert {:msg "  833.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  833.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2270[Heap[this#553, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2270, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2270;
  assume IsGoodExhaleState(exhaleHeap#_2269, Heap, Mask, exhaledHolds#_2271);
  Heap := exhaleHeap#_2269;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#553 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#553, AVLTreeNode.valid] := Mask[this#553, AVLTreeNode.valid][perm$R := Mask[this#553, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#553 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#553, AVLTreeNode.height] := Mask[this#553, AVLTreeNode.height][perm$R := Mask[this#553, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#553 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#553, AVLTreeNode.keys] := Mask[this#553, AVLTreeNode.keys][perm$R := Mask[this#553, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#553 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#553, AVLTreeNode.balanceFactor] := Mask[this#553, AVLTreeNode.balanceFactor][perm$R := Mask[this#553, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#553, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2264[this#553, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2264[this#553, AVLTreeNode.key])), ite(callHeap#_2264[this#553, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#553, AVLTreeNode.height] == ite(ite(callHeap#_2264[this#553, AVLTreeNode.left] == null, 0, callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2264[this#553, AVLTreeNode.right] == null, 0, callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2264[this#553, AVLTreeNode.left] == null, 0, callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2264[this#553, AVLTreeNode.right] == null, 0, callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#553, AVLTreeNode.balanceFactor] == (ite(callHeap#_2264[this#553, AVLTreeNode.left] == null, 0, callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2264[this#553, AVLTreeNode.right] == null, 0, callHeap#_2264[callHeap#_2264[this#553, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field right
  assert {:msg "  834.3: Location might not be writable"} CanWrite(Mask, r#71, AVLTreeNode.right);
  assert {:msg "  834.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  834.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  Heap[r#71, AVLTreeNode.right] := Heap[this, AVLTreeNode.right];
  assume wf(Heap, Mask, SecMask);
  // update field right
  assert {:msg "  835.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  835.17: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  835.17: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#71, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  // assert
  assertHeap#_2289 := Heap;
  assertMask#_2290 := Mask;
  assertSecMask#_2291 := SecMask;
  assertCredits#_2292 := Credits;
  assume wf(assertHeap#_2289, assertMask#_2290, assertSecMask#_2291);
  // begin exhale (assert)
  exhaleMask#_2294 := assertMask#_2290;
  havoc exhaleHeap#_2293;
  exhaledHolds#_2295 := ZeroRefSet;
  assert {:msg "  836.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  836.10: Location might not be readable."} true ==> CanRead(assertMask#_2290, this, AVLTreeNode.right);
  if (!(assertHeap#_2289[this, AVLTreeNode.right] == null)) {
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#559) ==> (this != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#559) ==> CanRead(assertMask#_2290, this, AVLTreeNode.right);
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#559) ==> (assertHeap#_2289[this, AVLTreeNode.right] != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#559) ==> CanRead(assertMask#_2290, assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  836.52: Receiver might be null."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  836.52: Location might not be readable."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2290, this, AVLTreeNode.key);
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2290, this, AVLTreeNode.right);
    assert {:msg "  836.10: Receiver might be null."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2289[this, AVLTreeNode.right] != null);
    assert {:msg "  836.10: Location might not be readable."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(assertMask#_2290, assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  836.58: Sequence index might be negative."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#111#559);
    assert {:msg "  836.58: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#111#559) && (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#111#559 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assert {:msg "  836.3: Assertion might not hold. The expression at 836.26 might not evaluate to true."} (forall k#111#558: int :: 
      (0 <= k#111#558) && (k#111#558 < Seq#Length(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (assertHeap#_2289[this, AVLTreeNode.key] < Seq#Index(assertHeap#_2289[assertHeap#_2289[this, AVLTreeNode.right], AVLTreeNode.keys], k#111#558))
    );
  }
  assertMask#_2290 := exhaleMask#_2294;
  assume IsGoodExhaleState(exhaleHeap#_2293, assertHeap#_2289, assertMask#_2290, exhaledHolds#_2295);
  assertHeap#_2289 := exhaleHeap#_2293;
  assume IsGoodMask(assertMask#_2290);
  assume wf(assertHeap#_2289, assertMask#_2290, assertSecMask#_2291);
  // end exhale
  assume (0.0 < methodCallK#_2300) && ((1000.0 * methodCallK#_2300) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2300) < methodK#_2182);
  // call close
  callHeap#_2296 := Heap;
  callMask#_2297 := Mask;
  callSecMask#_2298 := SecMask;
  callCredits#_2299 := Credits;
  assume wf(callHeap#_2296, callMask#_2297, callSecMask#_2298);
  assert {:msg "  837.3: The target of the method call might be null."} this != null;
  this#561 := this;
  // begin exhale (precondition)
  exhaleMask#_2302 := Mask;
  havoc exhaleHeap#_2301;
  exhaledHolds#_2303 := ZeroRefSet;
  if (!(Heap[this#561, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#562: int :: 
      (0 <= k#92#562) && (k#92#562 < Seq#Length(Heap[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys], k#92#562) < Heap[this#561, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#561, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#563: int :: 
      (0 <= k#93#563) && (k#93#563 < Seq#Length(Heap[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#561, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys], k#93#563))
    );
  }
  assert {:msg "  837.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#561, AVLTreeNode.left] == null, 0, Heap[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#561, AVLTreeNode.right] == null, 0, Heap[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  837.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#561, AVLTreeNode.left] == null, 0, Heap[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#561, AVLTreeNode.right] == null, 0, Heap[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  837.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  837.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2302[this#561, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[this#561, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2302[this#561, AVLTreeNode.key][perm$N]));
  exhaleMask#_2302[this#561, AVLTreeNode.key] := exhaleMask#_2302[this#561, AVLTreeNode.key][perm$R := exhaleMask#_2302[this#561, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2302, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  837.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2302[this#561, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[this#561, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2302[this#561, AVLTreeNode.height][perm$N]));
  exhaleMask#_2302[this#561, AVLTreeNode.height] := exhaleMask#_2302[this#561, AVLTreeNode.height][perm$R := exhaleMask#_2302[this#561, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2302, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  837.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2302[this#561, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[this#561, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2302[this#561, AVLTreeNode.left][perm$N]));
  exhaleMask#_2302[this#561, AVLTreeNode.left] := exhaleMask#_2302[this#561, AVLTreeNode.left][perm$R := exhaleMask#_2302[this#561, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2302, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  837.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2302[this#561, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[this#561, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2302[this#561, AVLTreeNode.right][perm$N]));
  exhaleMask#_2302[this#561, AVLTreeNode.right] := exhaleMask#_2302[this#561, AVLTreeNode.right][perm$R := exhaleMask#_2302[this#561, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2302, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  837.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2302[this#561, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[this#561, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2302[this#561, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2302[this#561, AVLTreeNode.keys] := exhaleMask#_2302[this#561, AVLTreeNode.keys][perm$R := exhaleMask#_2302[this#561, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2302, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  837.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  837.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2302[this#561, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[this#561, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2302[this#561, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2302[this#561, AVLTreeNode.balanceFactor] := exhaleMask#_2302[this#561, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2302[this#561, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2302, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#561, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2302, Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2301[Heap[this#561, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.left] == null)) {
    assert {:msg "  837.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2302, Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2301[Heap[this#561, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#561, AVLTreeNode.right] == null)) {
    assert {:msg "  837.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  837.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2302[Heap[this#561, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2302, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2302;
  assume IsGoodExhaleState(exhaleHeap#_2301, Heap, Mask, exhaledHolds#_2303);
  Heap := exhaleHeap#_2301;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#561 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#561, AVLTreeNode.valid] := Mask[this#561, AVLTreeNode.valid][perm$R := Mask[this#561, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#561 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#561, AVLTreeNode.height] := Mask[this#561, AVLTreeNode.height][perm$R := Mask[this#561, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#561 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#561, AVLTreeNode.keys] := Mask[this#561, AVLTreeNode.keys][perm$R := Mask[this#561, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#561 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#561, AVLTreeNode.balanceFactor] := Mask[this#561, AVLTreeNode.balanceFactor][perm$R := Mask[this#561, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#561, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2296[this#561, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2296[this#561, AVLTreeNode.key])), ite(callHeap#_2296[this#561, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#561, AVLTreeNode.height] == ite(ite(callHeap#_2296[this#561, AVLTreeNode.left] == null, 0, callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2296[this#561, AVLTreeNode.right] == null, 0, callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2296[this#561, AVLTreeNode.left] == null, 0, callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2296[this#561, AVLTreeNode.right] == null, 0, callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#561, AVLTreeNode.balanceFactor] == (ite(callHeap#_2296[this#561, AVLTreeNode.left] == null, 0, callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2296[this#561, AVLTreeNode.right] == null, 0, callHeap#_2296[callHeap#_2296[this#561, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field left
  assert {:msg "  838.3: Location might not be writable"} CanWrite(Mask, r#71, AVLTreeNode.left);
  Heap[r#71, AVLTreeNode.left] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_2325) && ((1000.0 * methodCallK#_2325) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2325) < methodK#_2182);
  // call close
  callHeap#_2321 := Heap;
  callMask#_2322 := Mask;
  callSecMask#_2323 := SecMask;
  callCredits#_2324 := Credits;
  assume wf(callHeap#_2321, callMask#_2322, callSecMask#_2323);
  assert {:msg "  839.3: The target of the method call might be null."} r#71 != null;
  this#566 := r#71;
  // begin exhale (precondition)
  exhaleMask#_2327 := Mask;
  havoc exhaleHeap#_2326;
  exhaledHolds#_2328 := ZeroRefSet;
  if (!(Heap[this#566, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#567: int :: 
      (0 <= k#92#567) && (k#92#567 < Seq#Length(Heap[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys], k#92#567) < Heap[this#566, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#566, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#568: int :: 
      (0 <= k#93#568) && (k#93#568 < Seq#Length(Heap[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#566, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys], k#93#568))
    );
  }
  assert {:msg "  839.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#566, AVLTreeNode.left] == null, 0, Heap[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#566, AVLTreeNode.right] == null, 0, Heap[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  839.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#566, AVLTreeNode.left] == null, 0, Heap[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#566, AVLTreeNode.right] == null, 0, Heap[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  839.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  839.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2327[this#566, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[this#566, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2327[this#566, AVLTreeNode.key][perm$N]));
  exhaleMask#_2327[this#566, AVLTreeNode.key] := exhaleMask#_2327[this#566, AVLTreeNode.key][perm$R := exhaleMask#_2327[this#566, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  839.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2327[this#566, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[this#566, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2327[this#566, AVLTreeNode.height][perm$N]));
  exhaleMask#_2327[this#566, AVLTreeNode.height] := exhaleMask#_2327[this#566, AVLTreeNode.height][perm$R := exhaleMask#_2327[this#566, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  839.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2327[this#566, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[this#566, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2327[this#566, AVLTreeNode.left][perm$N]));
  exhaleMask#_2327[this#566, AVLTreeNode.left] := exhaleMask#_2327[this#566, AVLTreeNode.left][perm$R := exhaleMask#_2327[this#566, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  839.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2327[this#566, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[this#566, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2327[this#566, AVLTreeNode.right][perm$N]));
  exhaleMask#_2327[this#566, AVLTreeNode.right] := exhaleMask#_2327[this#566, AVLTreeNode.right][perm$R := exhaleMask#_2327[this#566, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  839.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2327[this#566, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[this#566, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2327[this#566, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2327[this#566, AVLTreeNode.keys] := exhaleMask#_2327[this#566, AVLTreeNode.keys][perm$R := exhaleMask#_2327[this#566, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2327, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  839.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  839.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2327[this#566, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[this#566, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2327[this#566, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2327[this#566, AVLTreeNode.balanceFactor] := exhaleMask#_2327[this#566, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2327[this#566, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2327, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#566, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2327, Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2326[Heap[this#566, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.left] == null)) {
    assert {:msg "  839.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2327, Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2326[Heap[this#566, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#566, AVLTreeNode.right] == null)) {
    assert {:msg "  839.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  839.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2327[Heap[this#566, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2327, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2327;
  assume IsGoodExhaleState(exhaleHeap#_2326, Heap, Mask, exhaledHolds#_2328);
  Heap := exhaleHeap#_2326;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#566 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#566, AVLTreeNode.valid] := Mask[this#566, AVLTreeNode.valid][perm$R := Mask[this#566, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#566 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#566, AVLTreeNode.height] := Mask[this#566, AVLTreeNode.height][perm$R := Mask[this#566, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#566 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#566, AVLTreeNode.keys] := Mask[this#566, AVLTreeNode.keys][perm$R := Mask[this#566, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#566 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#566, AVLTreeNode.balanceFactor] := Mask[this#566, AVLTreeNode.balanceFactor][perm$R := Mask[this#566, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#566, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2321[this#566, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2321[this#566, AVLTreeNode.key])), ite(callHeap#_2321[this#566, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#566, AVLTreeNode.height] == ite(ite(callHeap#_2321[this#566, AVLTreeNode.left] == null, 0, callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2321[this#566, AVLTreeNode.right] == null, 0, callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2321[this#566, AVLTreeNode.left] == null, 0, callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2321[this#566, AVLTreeNode.right] == null, 0, callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#566, AVLTreeNode.balanceFactor] == (ite(callHeap#_2321[this#566, AVLTreeNode.left] == null, 0, callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2321[this#566, AVLTreeNode.right] == null, 0, callHeap#_2321[callHeap#_2321[this#566, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_2347 := Mask;
  havoc exhaleHeap#_2346;
  exhaledHolds#_2348 := ZeroRefSet;
  assert {:msg "  790.2: The postcondition at 817.11 might not hold. The expression at 817.11 might not evaluate to true."} !(r#71 == null);
  assert {:msg "  790.2: The postcondition at 823.11 might not hold. The expression at 823.11 might not evaluate to true."} Heap[r#71, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height];
  assert {:msg "  790.2: The postcondition at 824.11 might not hold. The expression at 824.11 might not evaluate to true."} Seq#Equal(Heap[r#71, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  790.2: The postcondition at 818.11 might not hold. The permission at 818.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  790.2: The postcondition at 818.11 might not hold. Insufficient fraction at 818.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2347[r#71, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2347[r#71, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2347[r#71, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2347[r#71, AVLTreeNode.valid] := exhaleMask#_2347[r#71, AVLTreeNode.valid][perm$R := exhaleMask#_2347[r#71, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_2347, r#71, AVLTreeNode.valid)) {
    assume Heap[r#71, AVLTreeNode.valid] < exhaleHeap#_2346[r#71, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_2347, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  790.2: The postcondition at 819.11 might not hold. The permission at 819.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  790.2: The postcondition at 819.11 might not hold. Insufficient fraction at 819.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2347[r#71, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2347[r#71, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2347[r#71, AVLTreeNode.height][perm$N]));
  exhaleMask#_2347[r#71, AVLTreeNode.height] := exhaleMask#_2347[r#71, AVLTreeNode.height][perm$R := exhaleMask#_2347[r#71, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2347, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  790.2: The postcondition at 820.11 might not hold. The permission at 820.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  790.2: The postcondition at 820.11 might not hold. Insufficient fraction at 820.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2347[r#71, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2347[r#71, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2347[r#71, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2347[r#71, AVLTreeNode.keys] := exhaleMask#_2347[r#71, AVLTreeNode.keys][perm$R := exhaleMask#_2347[r#71, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2347, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  790.2: The postcondition at 821.11 might not hold. The permission at 821.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  790.2: The postcondition at 821.11 might not hold. Insufficient fraction at 821.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2347[r#71, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2347[r#71, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2347[r#71, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2347[r#71, AVLTreeNode.balanceFactor] := exhaleMask#_2347[r#71, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2347[r#71, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2347, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2347;
  assume IsGoodExhaleState(exhaleHeap#_2346, Heap, Mask, exhaledHolds#_2348);
  Heap := exhaleHeap#_2346;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  790.2: Method might lock/unlock more than allowed."} (forall lk#_2353: ref :: 
    { Heap[lk#_2353, held] }
    { Heap[lk#_2353, rdheld] }
    (((0 < Heap[lk#_2353, held]) == (0 < old(Heap)[lk#_2353, held])) && (Heap[lk#_2353, rdheld] == old(Heap)[lk#_2353, rdheld])) || false
  );
  assert {:msg "  790.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}


// -------------------------------------------
// Translation of the method AVLTreeNode.rebalanceLL
// -------------------------------------------

// definedness check for method AVLTreeNode.rebalanceLL
procedure AVLTreeNode.rebalanceLL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#72: ref where (r#72 == null) || (dtype(r#72) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2354: real;
  var k#112#572: int where true;
  var k#113#574: int where true;
  assume (0.0 < methodK#_2354) && ((1000.0 * methodK#_2354) < (real(1) * 0.01));
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  854.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  854.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  854.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  854.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  854.25: Receiver might be null."} Heap[this, AVLTreeNode.left] != null;
    assert {:msg "  854.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  854.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  855.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  855.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  855.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  855.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  856.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  856.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  856.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  856.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  857.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  857.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  857.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  857.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  assert {:msg "  858.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  858.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#572) ==> (this != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#572) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#572) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#572) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  858.50: Sequence index might be negative."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#112#572);
    assert {:msg "  858.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  858.54: Receiver might be null."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  858.54: Location might not be readable."} true && (0 <= k#112#572) && (k#112#572 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#112#571: int :: 
      (0 <= k#112#571) && (k#112#571 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#112#571) < Heap[this, AVLTreeNode.key])
    );
  }
  assert {:msg "  860.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  860.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  861.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  861.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  861.12: Receiver might be null."} Heap[this, AVLTreeNode.right] != null;
  assert {:msg "  861.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  861.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  862.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  862.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  863.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  863.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  864.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  864.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#574) ==> (this != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#574) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#574) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#574) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  865.38: Receiver might be null."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  865.38: Location might not be readable."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  865.12: Receiver might be null."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  865.12: Location might not be readable."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  865.44: Sequence index might be negative."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#113#574);
  assert {:msg "  865.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#113#574) && (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#113#574 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#113#573: int :: 
    (0 <= k#113#573) && (k#113#573 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#113#573))
  );
  assert {:msg "  867.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  867.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  867.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  867.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  867.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  867.26: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  867.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  867.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  867.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  867.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assert {:msg "  868.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  868.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  868.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  868.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_2357: Field (PMaskType) :: 
    (forall ref#_2356: ref :: 
      Heap[ref#_2356, pmask#_2357] == ZeroPMask
    )
  );
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  assume !(r#72 == null);
  assert {:msg "  871.11: Receiver might be null."} r#72 != null;
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[r#72, AVLTreeNode.valid] := Mask[r#72, AVLTreeNode.valid][perm$R := Mask[r#72, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#72, AVLTreeNode.height] := Mask[r#72, AVLTreeNode.height][perm$R := Mask[r#72, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#72, AVLTreeNode.keys] := Mask[r#72, AVLTreeNode.keys][perm$R := Mask[r#72, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume r#72 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[r#72, AVLTreeNode.balanceFactor] := Mask[r#72, AVLTreeNode.balanceFactor][perm$R := Mask[r#72, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  876.11: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  876.11: Location might not be readable."} true ==> CanRead(Mask, r#72, AVLTreeNode.height);
  assert {:msg "  876.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  876.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  876.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  876.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assert {:msg "  876.44: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (r#72 != null);
  assert {:msg "  876.44: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(Mask, r#72, AVLTreeNode.height);
  assert {:msg "  876.60: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  876.60: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  876.60: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  876.60: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#72, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  877.11: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  877.11: Location might not be readable."} true ==> CanRead(Mask, r#72, AVLTreeNode.keys);
  assert {:msg "  877.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  877.26: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  877.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  877.51: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  877.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  877.51: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  877.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  877.71: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  877.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  877.84: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  877.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  877.84: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#72, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
}

// verification of the body for method AVLTreeNode.rebalanceLL
procedure AVLTreeNode.rebalanceLL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#72: ref where (r#72 == null) || (dtype(r#72) == AVLTreeNode#t))
  modifies Heap, Mask, SecMask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask, SecMask);
{
  var methodK#_2354: real;
  var predRec#_2363: ref;
  var predVer#_2364: int;
  var unfoldK#_2362: real;
  var oldVers#_2369: int;
  var newVers#_2370: int;
  var methodCallK#_2376: real;
  var this#579: ref where (this#579 == null) || (dtype(this#579) == AVLTreeNode#t);
  var callHeap#_2372: HeapType;
  var callMask#_2373: MaskType;
  var callSecMask#_2374: MaskType;
  var callCredits#_2375: CreditsType;
  var exhaleMask#_2378: MaskType;
  var exhaleHeap#_2377: HeapType;
  var exhaledHolds#_2379: RefSet;
  var isHeld#_2394: int;
  var isRdHeld#_2395: bool;
  var methodCallK#_2401: real;
  var this#584: ref where (this#584 == null) || (dtype(this#584) == AVLTreeNode#t);
  var callHeap#_2397: HeapType;
  var callMask#_2398: MaskType;
  var callSecMask#_2399: MaskType;
  var callCredits#_2400: CreditsType;
  var exhaleMask#_2403: MaskType;
  var exhaleHeap#_2402: HeapType;
  var exhaledHolds#_2404: RefSet;
  var isHeld#_2419: int;
  var isRdHeld#_2420: bool;
  var exhaleMask#_2423: MaskType;
  var exhaleHeap#_2422: HeapType;
  var exhaledHolds#_2424: RefSet;
  assume (0.0 < methodK#_2354) && ((1000.0 * methodK#_2354) < (real(1) * 0.01));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  SecMask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#112#575: int :: 
      (0 <= k#112#575) && (k#112#575 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#112#575) < Heap[this, AVLTreeNode.key])
    );
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume (forall k#113#576: int :: 
    (0 <= k#113#576) && (k#113#576 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#113#576))
  );
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume SecMask == old(SecMask);
  assume Credits == old(Credits);
  assume (forall pmask#_2361: Field (PMaskType) :: 
    (forall ref#_2360: ref :: 
      Heap[ref#_2360, pmask#_2361] == ZeroPMask
    )
  );
  // unfold
  assume #AVLTreeNode.valid#trigger(Heap[this, AVLTreeNode.right]);
  predRec#_2363 := Heap[this, AVLTreeNode.right];
  predVer#_2364 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume (0.0 < unfoldK#_2362) && (unfoldK#_2362 < (real(1) * 0.01)) && ((1000.0 * unfoldK#_2362) < methodK#_2354);
  assert {:msg "  879.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  879.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  879.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  assert {:msg "  879.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. The permission at <undefined position> might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  879.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} ((real(100) * 0.01) <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.valid)) {
    oldVers#_2369 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    havoc newVers#_2370;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := newVers#_2370;
    assume oldVers#_2369 < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  }
  assume wf(Heap, Mask, SecMask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (unfold)
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  assume (real(100) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Heap[this, AVLTreeNode.right] != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2363, AVLTreeNode.valid, predVer#_2364, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#79#577: int :: 
      (0 <= lk#79#577) && (lk#79#577 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#79#577) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume (real(100) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
    assume #predicateInside#(predRec#_2363, AVLTreeNode.valid, predVer#_2364, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    assume wf(Heap, Mask, SecMask);
    assume true;
    assume (real(50) * 0.01) > 0.0;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#80#578: int :: 
      (0 <= rk#80#578) && (rk#80#578 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#80#578))
    );
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#81: int :: 
    Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#81) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#81)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#81))) || (kk#81 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]))
  );
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // assigment to r
  assert {:msg "  880.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  880.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  r#72 := Heap[this, AVLTreeNode.right];
  // update field right
  assert {:msg "  881.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  881.15: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  881.15: Location might not be readable."} true ==> CanRead(Mask, r#72, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#72, AVLTreeNode.left];
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_2376) && ((1000.0 * methodCallK#_2376) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2376) < methodK#_2354);
  // call close
  callHeap#_2372 := Heap;
  callMask#_2373 := Mask;
  callSecMask#_2374 := SecMask;
  callCredits#_2375 := Credits;
  assume wf(callHeap#_2372, callMask#_2373, callSecMask#_2374);
  assert {:msg "  882.3: The target of the method call might be null."} this != null;
  this#579 := this;
  // begin exhale (precondition)
  exhaleMask#_2378 := Mask;
  havoc exhaleHeap#_2377;
  exhaledHolds#_2379 := ZeroRefSet;
  if (!(Heap[this#579, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#580: int :: 
      (0 <= k#92#580) && (k#92#580 < Seq#Length(Heap[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys], k#92#580) < Heap[this#579, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#579, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#581: int :: 
      (0 <= k#93#581) && (k#93#581 < Seq#Length(Heap[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#579, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys], k#93#581))
    );
  }
  assert {:msg "  882.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#579, AVLTreeNode.left] == null, 0, Heap[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#579, AVLTreeNode.right] == null, 0, Heap[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  882.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#579, AVLTreeNode.left] == null, 0, Heap[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#579, AVLTreeNode.right] == null, 0, Heap[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  882.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  882.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2378[this#579, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[this#579, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2378[this#579, AVLTreeNode.key][perm$N]));
  exhaleMask#_2378[this#579, AVLTreeNode.key] := exhaleMask#_2378[this#579, AVLTreeNode.key][perm$R := exhaleMask#_2378[this#579, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2378, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  882.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2378[this#579, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[this#579, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2378[this#579, AVLTreeNode.height][perm$N]));
  exhaleMask#_2378[this#579, AVLTreeNode.height] := exhaleMask#_2378[this#579, AVLTreeNode.height][perm$R := exhaleMask#_2378[this#579, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2378, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  882.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2378[this#579, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[this#579, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2378[this#579, AVLTreeNode.left][perm$N]));
  exhaleMask#_2378[this#579, AVLTreeNode.left] := exhaleMask#_2378[this#579, AVLTreeNode.left][perm$R := exhaleMask#_2378[this#579, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2378, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  882.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2378[this#579, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[this#579, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2378[this#579, AVLTreeNode.right][perm$N]));
  exhaleMask#_2378[this#579, AVLTreeNode.right] := exhaleMask#_2378[this#579, AVLTreeNode.right][perm$R := exhaleMask#_2378[this#579, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2378, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  882.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2378[this#579, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[this#579, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2378[this#579, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2378[this#579, AVLTreeNode.keys] := exhaleMask#_2378[this#579, AVLTreeNode.keys][perm$R := exhaleMask#_2378[this#579, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2378, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  882.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  882.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2378[this#579, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[this#579, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2378[this#579, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2378[this#579, AVLTreeNode.balanceFactor] := exhaleMask#_2378[this#579, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2378[this#579, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2378, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#579, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2378, Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2377[Heap[this#579, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.left] == null)) {
    assert {:msg "  882.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2378, Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2377[Heap[this#579, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#579, AVLTreeNode.right] == null)) {
    assert {:msg "  882.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  882.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2378[Heap[this#579, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2378, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2378;
  assume IsGoodExhaleState(exhaleHeap#_2377, Heap, Mask, exhaledHolds#_2379);
  Heap := exhaleHeap#_2377;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#579 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#579, AVLTreeNode.valid] := Mask[this#579, AVLTreeNode.valid][perm$R := Mask[this#579, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#579 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#579, AVLTreeNode.height] := Mask[this#579, AVLTreeNode.height][perm$R := Mask[this#579, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#579 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#579, AVLTreeNode.keys] := Mask[this#579, AVLTreeNode.keys][perm$R := Mask[this#579, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#579 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#579, AVLTreeNode.balanceFactor] := Mask[this#579, AVLTreeNode.balanceFactor][perm$R := Mask[this#579, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#579, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2372[this#579, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2372[this#579, AVLTreeNode.key])), ite(callHeap#_2372[this#579, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#579, AVLTreeNode.height] == ite(ite(callHeap#_2372[this#579, AVLTreeNode.left] == null, 0, callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2372[this#579, AVLTreeNode.right] == null, 0, callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2372[this#579, AVLTreeNode.left] == null, 0, callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2372[this#579, AVLTreeNode.right] == null, 0, callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#579, AVLTreeNode.balanceFactor] == (ite(callHeap#_2372[this#579, AVLTreeNode.left] == null, 0, callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2372[this#579, AVLTreeNode.right] == null, 0, callHeap#_2372[callHeap#_2372[this#579, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // update field left
  assert {:msg "  883.3: Location might not be writable"} CanWrite(Mask, r#72, AVLTreeNode.left);
  Heap[r#72, AVLTreeNode.left] := this;
  assume wf(Heap, Mask, SecMask);
  assume (0.0 < methodCallK#_2401) && ((1000.0 * methodCallK#_2401) < (real(1) * 0.01)) && ((1000.0 * methodCallK#_2401) < methodK#_2354);
  // call close
  callHeap#_2397 := Heap;
  callMask#_2398 := Mask;
  callSecMask#_2399 := SecMask;
  callCredits#_2400 := Credits;
  assume wf(callHeap#_2397, callMask#_2398, callSecMask#_2399);
  assert {:msg "  884.3: The target of the method call might be null."} r#72 != null;
  this#584 := r#72;
  // begin exhale (precondition)
  exhaleMask#_2403 := Mask;
  havoc exhaleHeap#_2402;
  exhaledHolds#_2404 := ZeroRefSet;
  if (!(Heap[this#584, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 556.12 might not hold. The expression at 556.27 might not evaluate to true."} (forall k#92#585: int :: 
      (0 <= k#92#585) && (k#92#585 < Seq#Length(Heap[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys], k#92#585) < Heap[this#584, AVLTreeNode.key])
    );
  }
  if (!(Heap[this#584, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 562.12 might not hold. The expression at 562.28 might not evaluate to true."} (forall k#93#586: int :: 
      (0 <= k#93#586) && (k#93#586 < Seq#Length(Heap[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#584, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys], k#93#586))
    );
  }
  assert {:msg "  884.3: The precondition at 564.12 might not hold. The expression at 564.12 might not evaluate to true."} (ite(Heap[this#584, AVLTreeNode.left] == null, 0, Heap[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#584, AVLTreeNode.right] == null, 0, Heap[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  884.3: The precondition at 565.12 might not hold. The expression at 565.12 might not evaluate to true."} (ite(Heap[this#584, AVLTreeNode.left] == null, 0, Heap[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#584, AVLTreeNode.right] == null, 0, Heap[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assert {:msg "  884.3: The precondition at 544.12 might not hold. The permission at 544.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  884.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.key."} ((real(100) * 0.01) <= exhaleMask#_2403[this#584, AVLTreeNode.key][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[this#584, AVLTreeNode.key][perm$R]) ==> (0.0 <= exhaleMask#_2403[this#584, AVLTreeNode.key][perm$N]));
  exhaleMask#_2403[this#584, AVLTreeNode.key] := exhaleMask#_2403[this#584, AVLTreeNode.key][perm$R := exhaleMask#_2403[this#584, AVLTreeNode.key][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2403, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 545.12 might not hold. The permission at 545.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  884.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.height."} ((real(100) * 0.01) <= exhaleMask#_2403[this#584, AVLTreeNode.height][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[this#584, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2403[this#584, AVLTreeNode.height][perm$N]));
  exhaleMask#_2403[this#584, AVLTreeNode.height] := exhaleMask#_2403[this#584, AVLTreeNode.height][perm$R := exhaleMask#_2403[this#584, AVLTreeNode.height][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2403, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 546.12 might not hold. The permission at 546.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  884.3: The precondition at 546.12 might not hold. Insufficient fraction at 546.12 for AVLTreeNode.left."} ((real(100) * 0.01) <= exhaleMask#_2403[this#584, AVLTreeNode.left][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[this#584, AVLTreeNode.left][perm$R]) ==> (0.0 <= exhaleMask#_2403[this#584, AVLTreeNode.left][perm$N]));
  exhaleMask#_2403[this#584, AVLTreeNode.left] := exhaleMask#_2403[this#584, AVLTreeNode.left][perm$R := exhaleMask#_2403[this#584, AVLTreeNode.left][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2403, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 547.12 might not hold. The permission at 547.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  884.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.right."} ((real(100) * 0.01) <= exhaleMask#_2403[this#584, AVLTreeNode.right][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[this#584, AVLTreeNode.right][perm$R]) ==> (0.0 <= exhaleMask#_2403[this#584, AVLTreeNode.right][perm$N]));
  exhaleMask#_2403[this#584, AVLTreeNode.right] := exhaleMask#_2403[this#584, AVLTreeNode.right][perm$R := exhaleMask#_2403[this#584, AVLTreeNode.right][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2403, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 549.12 might not hold. The permission at 549.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  884.3: The precondition at 549.12 might not hold. Insufficient fraction at 549.12 for AVLTreeNode.keys."} ((real(100) * 0.01) <= exhaleMask#_2403[this#584, AVLTreeNode.keys][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[this#584, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2403[this#584, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2403[this#584, AVLTreeNode.keys] := exhaleMask#_2403[this#584, AVLTreeNode.keys][perm$R := exhaleMask#_2403[this#584, AVLTreeNode.keys][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2403, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  884.3: The precondition at 550.12 might not hold. The permission at 550.12 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  884.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.12 for AVLTreeNode.balanceFactor."} ((real(100) * 0.01) <= exhaleMask#_2403[this#584, AVLTreeNode.balanceFactor][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[this#584, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2403[this#584, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2403[this#584, AVLTreeNode.balanceFactor] := exhaleMask#_2403[this#584, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2403[this#584, AVLTreeNode.balanceFactor][perm$R] - (real(100) * 0.01)];
  assume wf(Heap, exhaleMask#_2403, SecMask);
  assume wf(Heap, Mask, SecMask);
  if (!(Heap[this#584, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 552.12 might not hold. The permission at 552.27 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2403, Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid)) {
      assume Heap[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid] < exhaleHeap#_2402[Heap[this#584, AVLTreeNode.left], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 553.12 might not hold. The permission at 553.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 554.12 might not hold. The permission at 554.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 554.12 might not hold. Insufficient fraction at 554.27 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.left] == null)) {
    assert {:msg "  884.3: The precondition at 555.12 might not hold. The permission at 555.27 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 555.12 might not hold. Insufficient fraction at 555.27 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 558.12 might not hold. The permission at 558.28 might not be positive."} (real(100) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
    if (!CanRead(exhaleMask#_2403, Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid)) {
      assume Heap[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid] < exhaleHeap#_2402[Heap[this#584, AVLTreeNode.right], AVLTreeNode.valid];
    }
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 559.12 might not hold. The permission at 559.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 560.12 might not hold. The permission at 560.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 560.12 might not hold. Insufficient fraction at 560.28 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  if (!(Heap[this#584, AVLTreeNode.right] == null)) {
    assert {:msg "  884.3: The precondition at 561.12 might not hold. The permission at 561.28 might not be positive."} (real(50) * 0.01) > 0.0;
    assert {:msg "  884.3: The precondition at 561.12 might not hold. Insufficient fraction at 561.28 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2403[Heap[this#584, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
    assume wf(Heap, exhaleMask#_2403, SecMask);
    assume wf(Heap, Mask, SecMask);
  }
  Mask := exhaleMask#_2403;
  assume IsGoodExhaleState(exhaleHeap#_2402, Heap, Mask, exhaledHolds#_2404);
  Heap := exhaleHeap#_2402;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  // inhale (postcondition)
  assume this#584 != null;
  assume wf(Heap, Mask, SecMask);
  assume (real(100) * 0.01) > 0.0;
  Mask[this#584, AVLTreeNode.valid] := Mask[this#584, AVLTreeNode.valid][perm$R := Mask[this#584, AVLTreeNode.valid][perm$R] + (real(100) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#584 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#584, AVLTreeNode.height] := Mask[this#584, AVLTreeNode.height][perm$R := Mask[this#584, AVLTreeNode.height][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#584 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#584, AVLTreeNode.keys] := Mask[this#584, AVLTreeNode.keys][perm$R := Mask[this#584, AVLTreeNode.keys][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume this#584 != null;
  assume wf(Heap, Mask, SecMask);
  assume true;
  assume (real(50) * 0.01) > 0.0;
  Mask[this#584, AVLTreeNode.balanceFactor] := Mask[this#584, AVLTreeNode.balanceFactor][perm$R := Mask[this#584, AVLTreeNode.balanceFactor][perm$R] + (real(50) * 0.01)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  assume wf(Heap, Mask, SecMask);
  assume Seq#Equal(Heap[this#584, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_2397[this#584, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_2397[this#584, AVLTreeNode.key])), ite(callHeap#_2397[this#584, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Heap[this#584, AVLTreeNode.height] == ite(ite(callHeap#_2397[this#584, AVLTreeNode.left] == null, 0, callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_2397[this#584, AVLTreeNode.right] == null, 0, callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_2397[this#584, AVLTreeNode.left] == null, 0, callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_2397[this#584, AVLTreeNode.right] == null, 0, callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#584, AVLTreeNode.balanceFactor] == (ite(callHeap#_2397[this#584, AVLTreeNode.left] == null, 0, callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_2397[this#584, AVLTreeNode.right] == null, 0, callHeap#_2397[callHeap#_2397[this#584, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_2423 := Mask;
  havoc exhaleHeap#_2422;
  exhaledHolds#_2424 := ZeroRefSet;
  assert {:msg "  845.2: The postcondition at 870.11 might not hold. The expression at 870.11 might not evaluate to true."} !(r#72 == null);
  assert {:msg "  845.2: The postcondition at 876.11 might not hold. The expression at 876.11 might not evaluate to true."} (Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#72, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assert {:msg "  845.2: The postcondition at 877.11 might not hold. The expression at 877.11 might not evaluate to true."} Seq#Equal(Heap[r#72, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  845.2: The postcondition at 871.11 might not hold. The permission at 871.11 might not be positive."} (real(100) * 0.01) > 0.0;
  assert {:msg "  845.2: The postcondition at 871.11 might not hold. Insufficient fraction at 871.11 for AVLTreeNode.valid."} ((real(100) * 0.01) <= exhaleMask#_2423[r#72, AVLTreeNode.valid][perm$R]) && (((real(100) * 0.01) == exhaleMask#_2423[r#72, AVLTreeNode.valid][perm$R]) ==> (0.0 <= exhaleMask#_2423[r#72, AVLTreeNode.valid][perm$N]));
  exhaleMask#_2423[r#72, AVLTreeNode.valid] := exhaleMask#_2423[r#72, AVLTreeNode.valid][perm$R := exhaleMask#_2423[r#72, AVLTreeNode.valid][perm$R] - (real(100) * 0.01)];
  if (!CanRead(exhaleMask#_2423, r#72, AVLTreeNode.valid)) {
    assume Heap[r#72, AVLTreeNode.valid] < exhaleHeap#_2422[r#72, AVLTreeNode.valid];
  }
  assume wf(Heap, exhaleMask#_2423, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  845.2: The postcondition at 872.11 might not hold. The permission at 872.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  845.2: The postcondition at 872.11 might not hold. Insufficient fraction at 872.11 for AVLTreeNode.height."} ((real(50) * 0.01) <= exhaleMask#_2423[r#72, AVLTreeNode.height][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2423[r#72, AVLTreeNode.height][perm$R]) ==> (0.0 <= exhaleMask#_2423[r#72, AVLTreeNode.height][perm$N]));
  exhaleMask#_2423[r#72, AVLTreeNode.height] := exhaleMask#_2423[r#72, AVLTreeNode.height][perm$R := exhaleMask#_2423[r#72, AVLTreeNode.height][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2423, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  845.2: The postcondition at 873.11 might not hold. The permission at 873.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  845.2: The postcondition at 873.11 might not hold. Insufficient fraction at 873.11 for AVLTreeNode.keys."} ((real(50) * 0.01) <= exhaleMask#_2423[r#72, AVLTreeNode.keys][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2423[r#72, AVLTreeNode.keys][perm$R]) ==> (0.0 <= exhaleMask#_2423[r#72, AVLTreeNode.keys][perm$N]));
  exhaleMask#_2423[r#72, AVLTreeNode.keys] := exhaleMask#_2423[r#72, AVLTreeNode.keys][perm$R := exhaleMask#_2423[r#72, AVLTreeNode.keys][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2423, SecMask);
  assume wf(Heap, Mask, SecMask);
  assert {:msg "  845.2: The postcondition at 874.11 might not hold. The permission at 874.11 might not be positive."} (real(50) * 0.01) > 0.0;
  assert {:msg "  845.2: The postcondition at 874.11 might not hold. Insufficient fraction at 874.11 for AVLTreeNode.balanceFactor."} ((real(50) * 0.01) <= exhaleMask#_2423[r#72, AVLTreeNode.balanceFactor][perm$R]) && (((real(50) * 0.01) == exhaleMask#_2423[r#72, AVLTreeNode.balanceFactor][perm$R]) ==> (0.0 <= exhaleMask#_2423[r#72, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_2423[r#72, AVLTreeNode.balanceFactor] := exhaleMask#_2423[r#72, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_2423[r#72, AVLTreeNode.balanceFactor][perm$R] - (real(50) * 0.01)];
  assume wf(Heap, exhaleMask#_2423, SecMask);
  assume wf(Heap, Mask, SecMask);
  Mask := exhaleMask#_2423;
  assume IsGoodExhaleState(exhaleHeap#_2422, Heap, Mask, exhaledHolds#_2424);
  Heap := exhaleHeap#_2422;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask, SecMask);
  // end exhale
  assert {:msg "  845.2: Method might lock/unlock more than allowed."} (forall lk#_2429: ref :: 
    { Heap[lk#_2429, held] }
    { Heap[lk#_2429, rdheld] }
    (((0 < Heap[lk#_2429, held]) == (0 < old(Heap)[lk#_2429, held])) && (Heap[lk#_2429, rdheld] == old(Heap)[lk#_2429, rdheld])) || false
  );
  assert {:msg "  845.2: Method body is not allowed to leave any debt."} (forall ch: ref :: 
    (ch == null) || (0 <= Credits[ch])
  );
}
