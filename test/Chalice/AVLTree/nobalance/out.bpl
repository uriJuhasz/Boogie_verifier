// Copyright (c) 2008, Microsoft
type Field a;
type HeapType = <a>[ref,Field a]a;
type MaskType = <a>[ref,Field a][PermissionComponent]int;
type CreditsType = [ref]int;
type ref;
const null: ref;

var Heap: HeapType;

type PermissionComponent;
const unique perm$R: PermissionComponent;
const unique perm$N: PermissionComponent;
const Permission$MinusInfinity: int;
axiom Permission$MinusInfinity < -10000;
const Permission$PlusInfinity: int;
axiom 10000 < Permission$PlusInfinity;
var Mask: MaskType where IsGoodMask(Mask);
const Permission$Zero: [PermissionComponent]int;
axiom Permission$Zero[perm$R] == 0 && Permission$Zero[perm$N] == 0;
const Permission$Full: [PermissionComponent]int;
axiom Permission$Full[perm$R] == 100 && Permission$Full[perm$N] == 0;
const ZeroMask: MaskType;
axiom (forall<T> o: ref, f: Field T, pc: PermissionComponent :: ZeroMask[o,f][pc] == 0);
axiom IsGoodMask(ZeroMask);
function {:expand false} CanRead<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  0 < m[obj,f][perm$R] || 0 < m[obj,f][perm$N]
}
function {:expand false} CanWrite<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  m[obj,f][perm$R] == 100 && m[obj,f][perm$N] == 0
}
function {:expand true} IsGoodMask(m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T ::
      0 <= m[o,f][perm$R] && 
      (NonPredicateField(f) ==> 
        (m[o,f][perm$R]<=100 &&
        (0 < m[o,f][perm$N] ==> m[o,f][perm$R] < 100))) &&
      (m[o,f][perm$N] < 0 ==> 0 < m[o,f][perm$R]))
}

var Credits: CreditsType;

function IsGoodState<T>(T) returns (bool);
function combine<T,U>(T, U) returns (T);
const nostate: HeapType;

axiom (forall<T,U> a: T, b: U :: {IsGoodState(combine(a, b))} IsGoodState(combine(a, b)) <==> IsGoodState(a) && IsGoodState(b));
axiom IsGoodState(nostate);

type ModuleName;
const CurrentModule: ModuleName;
type TypeName;
function dtype(ref) returns (TypeName);
const CanAssumeFunctionDefs: bool;

type Mu;
const unique mu: Field Mu;
axiom NonPredicateField(mu);
function MuBelow(Mu, Mu) returns (bool);  // strict partial order
axiom (forall m: Mu, n: Mu ::
  { MuBelow(m,n), MuBelow(n,m) }
  !(MuBelow(m,n) && MuBelow(n,m)));
axiom (forall m: Mu, n: Mu, o: Mu ::
  { MuBelow(m,n), MuBelow(n,o) }
  MuBelow(m,n) && MuBelow(n,o) ==> MuBelow(m,o));
const $LockBottom: Mu;
axiom (forall m, n: Mu :: MuBelow(m, n) ==> n != $LockBottom);

const unique held: Field int;
function Acquire$Heap(int) returns (HeapType);
function Acquire$Mask(int) returns (MaskType);
function Acquire$Credits(int) returns (CreditsType);
axiom NonPredicateField(held);

function LastSeen$Heap(Mu, int) returns (HeapType);
function LastSeen$Mask(Mu, int) returns (MaskType);
function LastSeen$Credits(Mu, int) returns (CreditsType);

const unique rdheld: Field bool;
axiom NonPredicateField(rdheld);
function wf(h: HeapType, m: MaskType) returns (bool);

function IsGoodInhaleState(ih: HeapType, h: HeapType,
                           m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { ih[o, f] }  CanRead(m, o, f) ==> ih[o, f] == h[o, f]) &&
  (forall o: ref :: { ih[o, held] }  (0<ih[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { ih[o, rdheld] }  ih[o, rdheld] == h[o, rdheld]) &&
  (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> ih[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, rdheld] }  h[o, rdheld] ==> ih[o, mu] == h[o, mu])
}

// ---------------------------------------------------------------
// -- If then else -----------------------------------------------
// ---------------------------------------------------------------

function ite<T>(bool, T, T) returns (T);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} con ==> ite(con, a, b) == a);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} ! con ==> ite(con, a, b) == b);

// ---------------------------------------------------------------
// -- Axiomatization of sequences --------------------------------
// ---------------------------------------------------------------

type Seq T;

function Seq#Length<T>(Seq T) returns (int);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } 0 <= Seq#Length(s));

function Seq#Empty<T>() returns (Seq T);
axiom (forall<T> :: Seq#Length(Seq#Empty(): Seq T) == 0);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } Seq#Length(s) == 0 ==> s == Seq#Empty());

function Seq#Singleton<T>(T) returns (Seq T);
axiom (forall<T> t: T :: { Seq#Length(Seq#Singleton(t)) } Seq#Length(Seq#Singleton(t)) == 1);

function Seq#Build<T>(s: Seq T, index: int, val: T, newLength: int) returns (Seq T);
axiom (forall<T> s: Seq T, i: int, v: T, len: int :: { Seq#Length(Seq#Build(s,i,v,len)) }
  0 <= len ==> Seq#Length(Seq#Build(s,i,v,len)) == len);

function Seq#Append<T>(Seq T, Seq T) returns (Seq T);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Length(Seq#Append(s0,s1)) }
  Seq#Length(Seq#Append(s0,s1)) == Seq#Length(s0) + Seq#Length(s1));

function Seq#Index<T>(Seq T, int) returns (T);
axiom (forall<T> t: T :: { Seq#Index(Seq#Singleton(t), 0) } Seq#Index(Seq#Singleton(t), 0) == t);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#Index(Seq#Append(s0,s1), n) }
  (n < Seq#Length(s0) ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s0, n)) &&
  (Seq#Length(s0) <= n ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s1, n - Seq#Length(s0))));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, n: int :: { Seq#Index(Seq#Build(s,i,v,len),n) }
  0 <= n && n < len ==>
    (i == n ==> Seq#Index(Seq#Build(s,i,v,len),n) == v) &&
    (i != n ==> Seq#Index(Seq#Build(s,i,v,len),n) == Seq#Index(s,n)));

function Seq#Contains<T>(Seq T, T) returns (bool);
axiom (forall<T> s: Seq T, x: T :: { Seq#Contains(s,x) }
  Seq#Contains(s,x) <==>
    (exists i: int :: { Seq#Index(s,i) } 0 <= i && i < Seq#Length(s) && Seq#Index(s,i) == x));
axiom (forall x: ref ::
  { Seq#Contains(Seq#Empty(), x) }
  !Seq#Contains(Seq#Empty(), x));
axiom (forall<T> s0: Seq T, s1: Seq T, x: T ::
  { Seq#Contains(Seq#Append(s0, s1), x) }
  Seq#Contains(Seq#Append(s0, s1), x) <==>
    Seq#Contains(s0, x) || Seq#Contains(s1, x));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, x: T ::
  { Seq#Contains(Seq#Build(s, i, v, len), x) }
  Seq#Contains(Seq#Build(s, i, v, len), x) <==>
    (0 <= i && i < len && x == v)  ||  
    (exists j: int :: { Seq#Index(s,j) } 0 <= j && j < Seq#Length(s) && j < len && j!=i && Seq#Index(s,j) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Take(s, n), x) }
  Seq#Contains(Seq#Take(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= i && i < n && i < Seq#Length(s) && Seq#Index(s, i) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Drop(s, n), x) }
  Seq#Contains(Seq#Drop(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= n && n <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

function Seq#Equal<T>(Seq T, Seq T) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Equal(s0,s1) }
  Seq#Equal(s0,s1) <==>
    Seq#Length(s0) == Seq#Length(s1) &&
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < Seq#Length(s0) ==> Seq#Index(s0,j) == Seq#Index(s1,j)));
axiom(forall<T> a: Seq T, b: Seq T :: { Seq#Equal(a,b) }  // extensionality axiom for sequences
  Seq#Equal(a,b) ==> a == b);

function Seq#SameUntil<T>(Seq T, Seq T, int) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#SameUntil(s0,s1,n) }
  Seq#SameUntil(s0,s1,n) <==>
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < n ==> Seq#Index(s0,j) == Seq#Index(s1,j)));

function Seq#Take<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Take(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Take(s,n)) == n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Take(s,n)) == Seq#Length(s)));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Take(s,n), j) } {:weight 25}
  0 <= j && j < n && j < Seq#Length(s) ==>
    Seq#Index(Seq#Take(s,n), j) == Seq#Index(s, j));

function Seq#Drop<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Drop(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Drop(s,n)) == Seq#Length(s) - n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Drop(s,n)) == 0));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Drop(s,n), j) } {:weight 25}
  0 <= n && 0 <= j && j < Seq#Length(s)-n ==>
    Seq#Index(Seq#Drop(s,n), j) == Seq#Index(s, j+n));

axiom (forall<T> s, t: Seq T ::
  { Seq#Append(s, t) }
  Seq#Take(Seq#Append(s, t), Seq#Length(s)) == s &&
  Seq#Drop(Seq#Append(s, t), Seq#Length(s)) == t);

function Seq#Range(min: int, max: int) returns (Seq int);

axiom (forall min: int, max: int :: { Seq#Length(Seq#Range(min, max)) } (min < max ==> Seq#Length(Seq#Range(min, max)) == max-min) && (max <= min ==> Seq#Length(Seq#Range(min, max)) == 0));
axiom (forall min: int, max: int, j: int :: { Seq#Index(Seq#Range(min, max), j) } 0<=j && j<max-min ==> Seq#Index(Seq#Range(min, max), j) == min + j);

//urij

axiom (forall<T> x, y: T ::
  { Seq#Contains(Seq#Singleton(x),y) }
    Seq#Contains(Seq#Singleton(x),y) ==> x==y
);

axiom (forall<T> x: T ::
  { Seq#Contains(Seq#Singleton(x),x) }
    Seq#Contains(Seq#Singleton(x),x)
);

//-urij

// ---------------------------------------------------------------
// -- Permissions ------------------------------------------------
// ---------------------------------------------------------------

axiom (forall h: HeapType, m: MaskType, o: ref, q: ref :: {wf(h, m), h[o, mu], h[q, mu]} wf(h, m) && o!=q && (0 < h[o, held] || h[o, rdheld]) && (0 < h[q, held] || h[q, rdheld]) ==> h[o, mu] != h[q, mu]);

function DecPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$R]}
      DecPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] - howMuch, m[q, g][perm$R])
);

function DecEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$N]}
         DecEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] - howMuch, m[q, g][perm$N])
);

function IncPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$R]}
         IncPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] + howMuch, m[q, g][perm$R])
);

function IncEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$N]}
         IncEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] + howMuch, m[q, g][perm$N])
);

function Havocing<T,U>(h: HeapType, o: ref, f: Field T, newValue: U) returns (HeapType);

axiom (forall<T,U> h: HeapType, o: ref, f: Field T, newValue: U, q: ref, g: Field U :: {Havocing(h, o, f, newValue)[q, g]}
         Havocing(h, o, f, newValue)[q, g] == ite(o==q && f ==g, newValue, h[q, g])
);

const unique joinable: Field int;
axiom NonPredicateField(joinable);
const unique token#t: TypeName;

function Call$Heap(int) returns (HeapType);
function Call$Mask(int) returns (MaskType);
function Call$Credits(int) returns (CreditsType);
function Call$Args(int) returns (ArgSeq);
type ArgSeq = <T>[int]T;

function EmptyMask(m: MaskType) returns (bool);
axiom (forall m: MaskType :: {EmptyMask(m)} EmptyMask(m) <==> (forall<T> o: ref, f: Field T :: NonPredicateField(f) ==> m[o, f][perm$R]<=0 && m[o, f][perm$N]<=0));

const ZeroCredits: CreditsType;
axiom (forall o: ref :: ZeroCredits[o] == 0);
function EmptyCredits(c: CreditsType) returns (bool);
axiom (forall c: CreditsType :: {EmptyCredits(c)} EmptyCredits(c) <==> (forall o: ref :: o != null ==> c[o] == 0));

function NonPredicateField<T>(f: Field T) returns (bool);
function PredicateField<T>(f: Field T) returns (bool);
axiom (forall<T> f: Field T :: NonPredicateField(f) ==> ! PredicateField(f));
axiom (forall<T> f: Field T :: PredicateField(f) ==> ! NonPredicateField(f));

function submask(m1: MaskType, m2: MaskType) returns (bool);

axiom (forall m1: MaskType, m2: MaskType :: {submask(m1, m2)}
  submask(m1, m2) <==> (forall<T> o: ref, f: Field T :: (m1[o, f][perm$R] < m2[o, f][perm$R]) || (m1[o, f][perm$R] == m2[o, f][perm$R] && m1[o, f][perm$N] <= m2[o, f][perm$N]))
);

// ---------------------------------------------------------------
// -- Arithmetic -------------------------------------------------
// ---------------------------------------------------------------

// the connection between % and /
axiom (forall x:int, y:int :: {x % y} {x / y}  x % y == x - x / y * y);

// sign of denominator determines sign of remainder
axiom (forall x:int, y:int :: {x % y}  0 < y  ==>  0 <= x % y  &&  x % y < y);
axiom (forall x:int, y:int :: {x % y}  y < 0  ==>  y < x % y  &&  x % y <= 0);

// the following axiom has some unfortunate matching, but it does state a property about % that
// is sometime useful
axiom (forall a: int, b: int, d: int :: { a % d, b % d } 2 <= d && a % d == b % d && a < b  ==>  a + d <= b);

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------
const unique AVLTree#t: TypeName;
const unique module#default: ModuleName;
procedure AVLTree$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var h0#_0: HeapType;
  var m0#_1: MaskType;
  var c0#_2: CreditsType;
  var h1#_3: HeapType;
  var m1#_4: MaskType;
  var c1#_5: CreditsType;
  var lk#_6: ref;
  assume wf(h0#_0, m0#_1);
  assume wf(h1#_3, m1#_4);
  m1#_4 := ZeroMask;
  c1#_5 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  3.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTree.root: Field (ref);
axiom NonPredicateField(AVLTree.root);
const unique AVLTree.keys: Field (Seq (int));
axiom NonPredicateField(AVLTree.keys);
const unique AVLTree.valid: Field (HeapType);
axiom PredicateField(AVLTree.valid);
procedure AVLTree.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_7: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_7;
  assume IsGoodInhaleState(inhaleHeap#_7, Heap, Mask);
  assert {:msg "  10.15: Fraction might be negative."} 0 <= 100;
  assert {:msg "  10.15: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_7[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_7[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_7, Mask);
  assert {:msg "  11.15: Fraction might be negative."} 0 <= 50;
  assert {:msg "  11.15: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_7[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_7[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_7, Mask);
  assert {:msg "  12.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  12.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  12.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  12.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_7, Mask);
  } else {
  }
  assert {:msg "  14.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  14.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  14.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  14.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  14.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  14.45: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.keys] := inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_7, Mask);
  } else {
  }
  assert {:msg "  16.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  16.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  16.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  16.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
    assert {:msg "  16.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  16.30: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  16.30: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
    assert {:msg "  16.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTree.root], AVLTreeNode.keys);
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  assert {:msg "  17.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  17.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  17.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  17.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_8: HeapType;
  var inhaleHeap#_9: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_8;
  assume IsGoodInhaleState(inhaleHeap#_8, Heap, Mask);
  assert {:msg "  22.21: Fraction might be negative."} 0 <= 100;
  assert {:msg "  22.21: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_8[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_8[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_8, Mask);
  assert {:msg "  23.21: Fraction might be negative."} 0 <= 100;
  assert {:msg "  23.21: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_8[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_8[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_8, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_9;
  assume IsGoodInhaleState(inhaleHeap#_9, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_9[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_9[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_9[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_9, Mask);
  assert {:msg "  26.20: Fraction might be negative."} 0 <= 50;
  assert {:msg "  26.20: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_9[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_9[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_9, Mask);
  assert {:msg "  27.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  27.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.init(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_10: HeapType;
  var exhaleMask#_11: MaskType;
  var fraction#_12: int;
  var fraction#_13: int;
  var fraction#_14: int;
  var fraction#_15: int;
  var inhaleHeap#_16: HeapType;
  var exhaleMask#_17: MaskType;
  var fraction#_18: int;
  var fraction#_19: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_10;
  assume IsGoodInhaleState(inhaleHeap#_10, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_10[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_10[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_10, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_10[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_10[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_10, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field root
  assert {:msg "  29.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
  Heap[this, AVLTree.root] := null;
  assume wf(Heap, Mask);
  // update field keys
  assert {:msg "  30.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
  Heap[this, AVLTree.keys] := Seq#Empty();
  assume wf(Heap, Mask);
  // fold
  assert {:msg "  31.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_11 := Mask;
  fraction#_12 := 100;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_12 <= exhaleMask#_11[this, AVLTree.root][perm$R]) && ((fraction#_12 == exhaleMask#_11[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_11[this, AVLTree.root][perm$N]));
  exhaleMask#_11[this, AVLTree.root] := exhaleMask#_11[this, AVLTree.root][perm$R := exhaleMask#_11[this, AVLTree.root][perm$R] - fraction#_12];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_11);
  fraction#_13 := 50;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (fraction#_13 <= exhaleMask#_11[this, AVLTree.keys][perm$R]) && ((fraction#_13 == exhaleMask#_11[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_11[this, AVLTree.keys][perm$N]));
  exhaleMask#_11[this, AVLTree.keys] := exhaleMask#_11[this, AVLTree.keys][perm$R := exhaleMask#_11[this, AVLTree.keys][perm$R] - fraction#_13];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_11);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_14 := 100;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_14 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_14 == exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_14];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_11);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_15 := 50;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (fraction#_15 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((fraction#_15 == exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - fraction#_15];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_11);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  Mask := exhaleMask#_11;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_16;
  assume IsGoodInhaleState(inhaleHeap#_16, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_16[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_16[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_16[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_16, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_17 := Mask;
  fraction#_18 := 100;
  assert {:msg "  21.2: The postcondition at 25.11 might not hold. Insufficient fraction at 25.11 for AVLTree.valid."} (fraction#_18 <= exhaleMask#_17[this, AVLTree.valid][perm$R]) && ((fraction#_18 == exhaleMask#_17[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_17[this, AVLTree.valid][perm$N]));
  exhaleMask#_17[this, AVLTree.valid] := exhaleMask#_17[this, AVLTree.valid][perm$R := exhaleMask#_17[this, AVLTree.valid][perm$R] - fraction#_18];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_17);
  fraction#_19 := 50;
  assert {:msg "  21.2: The postcondition at 26.11 might not hold. Insufficient fraction at 26.11 for AVLTree.keys."} (fraction#_19 <= exhaleMask#_17[this, AVLTree.keys][perm$R]) && ((fraction#_19 == exhaleMask#_17[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_17[this, AVLTree.keys][perm$N]));
  exhaleMask#_17[this, AVLTree.keys] := exhaleMask#_17[this, AVLTree.keys][perm$R := exhaleMask#_17[this, AVLTree.keys][perm$R] - fraction#_19];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_17);
  assert {:msg "  21.2: The postcondition at 27.11 might not hold. The expression at 27.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  Mask := exhaleMask#_17;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  21.2: Method might lock/unlock more than allowed."} (forall lk#_20: ref :: {Heap[lk#_20, held]} {Heap[lk#_20, rdheld]} (((0 < Heap[lk#_20, held]) == (0 < old(Heap)[lk#_20, held])) && (Heap[lk#_20, rdheld] == old(Heap)[lk#_20, rdheld])) || false);
  assert {:msg "  21.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_21: HeapType;
  var inhaleHeap#_22: HeapType;
  var j#61#102: int where true;
  var j#62#104: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_21;
  assume IsGoodInhaleState(inhaleHeap#_21, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_21[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_21[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_21[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_21, Mask);
  assert {:msg "  37.21: Fraction might be negative."} 0 <= 50;
  assert {:msg "  37.21: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_21[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_21[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_21, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_22;
  assume IsGoodInhaleState(inhaleHeap#_22, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_22[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_22[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_22[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_22, Mask);
  assert {:msg "  40.20: Fraction might be negative."} 0 <= 50;
  assert {:msg "  40.20: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_22[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_22[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_22, Mask);
  assert {:msg "  42.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  42.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume Seq#Contains(Heap[this, AVLTree.keys], k#0);
  assert {:msg "  43.11: Receiver might be null."} true && (0 <= j#61#102) ==> (this != null);
  assert {:msg "  43.11: Location might not be readable."} true && (0 <= j#61#102) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  43.11: Receiver might be null."} true && (0 <= j#61#102) && (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  43.11: Location might not be readable."} true && (0 <= j#61#102) && (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  43.36: Sequence index might be negative."} true && (0 <= j#61#102) && (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (0 <= j#61#102);
  assert {:msg "  43.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#61#102) && (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assert {:msg "  43.41: Receiver might be null."} true && (0 <= j#61#102) && (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  43.41: Location might not be readable."} true && (0 <= j#61#102) && (j#61#102 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assume (forall j#61#101: int :: (0 <= j#61#101) && (j#61#101 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#61#101)));
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#62#104) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#62#104) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  44.33: Sequence index might be negative."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) ==> (0 <= j#62#104);
  assert {:msg "  44.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) ==> (j#62#104 < Seq#Length(Heap[this, AVLTree.keys]));
  assert {:msg "  44.42: Receiver might be null."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  44.42: Location might not be readable."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  44.11: Receiver might be null."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#62#104))) ==> (this != null);
  assert {:msg "  44.11: Location might not be readable."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#62#104))) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  44.33: Sequence index might be negative."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#62#104))) ==> (0 <= j#62#104);
  assert {:msg "  44.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#62#104) && (j#62#104 < Seq#Length(Heap[this, AVLTree.keys])) && (!Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#62#104))) ==> (j#62#104 < Seq#Length(Heap[this, AVLTree.keys]));
  assume (forall j#62#103: int :: (0 <= j#62#103) && (j#62#103 < Seq#Length(Heap[this, AVLTree.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#62#103)) || (Seq#Index(Heap[this, AVLTree.keys], j#62#103) == k#0)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.insert(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_23: HeapType;
  var exhaleMask#_24: MaskType;
  var fraction#_25: int;
  var inhaleHeap#_26: HeapType;
  var n#2: ref where (n#2 == null) || (dtype(n#2) == AVLTreeNode#t);
  var nw#_27: ref;
  var this#105: ref where (this#105 == null) || (dtype(this#105) == AVLTreeNode#t);
  var k#106: int where true;
  var callHeap#_28: HeapType;
  var callMask#_29: MaskType;
  var callCredits#_30: CreditsType;
  var exhaleMask#_31: MaskType;
  var fraction#_32: int;
  var fraction#_33: int;
  var fraction#_34: int;
  var fraction#_35: int;
  var isHeld#_36: int;
  var isRdHeld#_37: bool;
  var inhaleHeap#_38: HeapType;
  var this#107: ref where (this#107 == null) || (dtype(this#107) == AVLTreeNode#t);
  var k#108: int where true;
  var r#109: ref where (r#109 == null) || (dtype(r#109) == AVLTreeNode#t);
  var callHeap#_39: HeapType;
  var callMask#_40: MaskType;
  var callCredits#_41: CreditsType;
  var exhaleMask#_42: MaskType;
  var fraction#_43: int;
  var fraction#_44: int;
  var isHeld#_45: int;
  var isRdHeld#_46: bool;
  var inhaleHeap#_47: HeapType;
  var r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t);
  var exhaleMask#_48: MaskType;
  var fraction#_49: int;
  var fraction#_50: int;
  var fraction#_51: int;
  var fraction#_52: int;
  var inhaleHeap#_53: HeapType;
  var exhaleMask#_54: MaskType;
  var fraction#_55: int;
  var fraction#_56: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_23;
  assume IsGoodInhaleState(inhaleHeap#_23, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_23[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_23[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_23[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_23, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_23[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_23[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_23, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  46.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_24 := Mask;
  fraction#_25 := 100;
  assert {:msg "  46.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (fraction#_25 <= exhaleMask#_24[this, AVLTree.valid][perm$R]) && ((fraction#_25 == exhaleMask#_24[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_24[this, AVLTree.valid][perm$N]));
  exhaleMask#_24[this, AVLTree.valid] := exhaleMask#_24[this, AVLTree.valid][perm$R := exhaleMask#_24[this, AVLTree.valid][perm$R] - fraction#_25];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_24);
  Mask := exhaleMask#_24;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_26 := Heap[this, AVLTree.valid];
  assume IsGoodInhaleState(inhaleHeap#_26, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_26[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_26[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_26, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_26[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_26[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_26, Mask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_26[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_26[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_26[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_26, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.keys] := inhaleHeap#_26[Heap[this, AVLTree.root], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_26[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_26, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  47.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  47.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    // local var n
    // assigment to n
    // new
    havoc nw#_27;
    assume (nw#_27 != null) && (dtype(nw#_27) == AVLTreeNode#t);
    assume (forall<T#_0> f: Field (T#_0) :: (Mask[nw#_27, f][perm$R] == 0) && (Mask[nw#_27, f][perm$N] == 0));
    assume Heap[nw#_27, mu] == $LockBottom;
    assume Heap[nw#_27, held] <= 0;
    assume Heap[nw#_27, rdheld] == false;
    Mask[nw#_27, AVLTreeNode.key] := Mask[nw#_27, AVLTreeNode.key][perm$R := Mask[nw#_27, AVLTreeNode.key][perm$R] + 100];
    Mask[nw#_27, AVLTreeNode.left] := Mask[nw#_27, AVLTreeNode.left][perm$R := Mask[nw#_27, AVLTreeNode.left][perm$R] + 100];
    Mask[nw#_27, AVLTreeNode.right] := Mask[nw#_27, AVLTreeNode.right][perm$R := Mask[nw#_27, AVLTreeNode.right][perm$R] + 100];
    Mask[nw#_27, AVLTreeNode.keys] := Mask[nw#_27, AVLTreeNode.keys][perm$R := Mask[nw#_27, AVLTreeNode.keys][perm$R] + 100];
    Mask[nw#_27, mu] := Mask[nw#_27, mu][perm$R := Mask[nw#_27, mu][perm$R] + 100];
    n#2 := nw#_27;
    // call init
    callHeap#_28 := Heap;
    callMask#_29 := Mask;
    callCredits#_30 := Credits;
    assert {:msg "  49.4: The target of the method call might be null."} n#2 != null;
    this#105 := n#2;
    k#106 := k#0;
    // begin exhale (precondition)
    exhaleMask#_31 := Mask;
    fraction#_32 := 100;
    assert {:msg "  49.4: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (fraction#_32 <= exhaleMask#_31[this#105, AVLTreeNode.key][perm$R]) && ((fraction#_32 == exhaleMask#_31[this#105, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_31[this#105, AVLTreeNode.key][perm$N]));
    exhaleMask#_31[this#105, AVLTreeNode.key] := exhaleMask#_31[this#105, AVLTreeNode.key][perm$R := exhaleMask#_31[this#105, AVLTreeNode.key][perm$R] - fraction#_32];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_31);
    fraction#_33 := 100;
    assert {:msg "  49.4: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (fraction#_33 <= exhaleMask#_31[this#105, AVLTreeNode.left][perm$R]) && ((fraction#_33 == exhaleMask#_31[this#105, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_31[this#105, AVLTreeNode.left][perm$N]));
    exhaleMask#_31[this#105, AVLTreeNode.left] := exhaleMask#_31[this#105, AVLTreeNode.left][perm$R := exhaleMask#_31[this#105, AVLTreeNode.left][perm$R] - fraction#_33];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_31);
    fraction#_34 := 100;
    assert {:msg "  49.4: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (fraction#_34 <= exhaleMask#_31[this#105, AVLTreeNode.right][perm$R]) && ((fraction#_34 == exhaleMask#_31[this#105, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_31[this#105, AVLTreeNode.right][perm$N]));
    exhaleMask#_31[this#105, AVLTreeNode.right] := exhaleMask#_31[this#105, AVLTreeNode.right][perm$R := exhaleMask#_31[this#105, AVLTreeNode.right][perm$R] - fraction#_34];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_31);
    fraction#_35 := 100;
    assert {:msg "  49.4: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} (fraction#_35 <= exhaleMask#_31[this#105, AVLTreeNode.keys][perm$R]) && ((fraction#_35 == exhaleMask#_31[this#105, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_31[this#105, AVLTreeNode.keys][perm$N]));
    exhaleMask#_31[this#105, AVLTreeNode.keys] := exhaleMask#_31[this#105, AVLTreeNode.keys][perm$R := exhaleMask#_31[this#105, AVLTreeNode.keys][perm$R] - fraction#_35];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_31);
    Mask := exhaleMask#_31;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_38;
    assume IsGoodInhaleState(inhaleHeap#_38, Heap, Mask);
    assume this#105 != null;
    Heap[this#105, AVLTreeNode.valid] := inhaleHeap#_38[this#105, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_38[this#105, AVLTreeNode.valid] == Heap;
    Mask[this#105, AVLTreeNode.valid] := Mask[this#105, AVLTreeNode.valid][perm$R := Mask[this#105, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_38[this#105, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_38, Mask);
    assume this#105 != null;
    Heap[this#105, AVLTreeNode.keys] := inhaleHeap#_38[this#105, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#105, AVLTreeNode.keys] := Mask[this#105, AVLTreeNode.keys][perm$R := Mask[this#105, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_38[this#105, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_38, Mask);
    assume Seq#Equal(Heap[this#105, AVLTreeNode.keys], Seq#Singleton(k#106));
    assume Seq#Contains(Heap[this#105, AVLTreeNode.keys], k#106);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // update field root
    assert {:msg "  50.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := n#2;
    assume wf(Heap, Mask);
  } else {
    // call insert
    callHeap#_39 := Heap;
    callMask#_40 := Mask;
    callCredits#_41 := Credits;
    assert {:msg "  52.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  52.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  52.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#107 := Heap[this, AVLTree.root];
    k#108 := k#0;
    // begin exhale (precondition)
    exhaleMask#_42 := Mask;
    fraction#_43 := 100;
    assert {:msg "  52.4: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (fraction#_43 <= exhaleMask#_42[this#107, AVLTreeNode.valid][perm$R]) && ((fraction#_43 == exhaleMask#_42[this#107, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_42[this#107, AVLTreeNode.valid][perm$N]));
    exhaleMask#_42[this#107, AVLTreeNode.valid] := exhaleMask#_42[this#107, AVLTreeNode.valid][perm$R := exhaleMask#_42[this#107, AVLTreeNode.valid][perm$R] - fraction#_43];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_42);
    fraction#_44 := 50;
    assert {:msg "  52.4: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} (fraction#_44 <= exhaleMask#_42[this#107, AVLTreeNode.keys][perm$R]) && ((fraction#_44 == exhaleMask#_42[this#107, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_42[this#107, AVLTreeNode.keys][perm$N]));
    exhaleMask#_42[this#107, AVLTreeNode.keys] := exhaleMask#_42[this#107, AVLTreeNode.keys][perm$R := exhaleMask#_42[this#107, AVLTreeNode.keys][perm$R] - fraction#_44];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_42);
    Mask := exhaleMask#_42;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#109;
    // inhale (postcondition)
    havoc inhaleHeap#_47;
    assume IsGoodInhaleState(inhaleHeap#_47, Heap, Mask);
    assume !(r#109 == null);
    assume r#109 != null;
    Heap[r#109, AVLTreeNode.valid] := inhaleHeap#_47[r#109, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_47[r#109, AVLTreeNode.valid] == Heap;
    Mask[r#109, AVLTreeNode.valid] := Mask[r#109, AVLTreeNode.valid][perm$R := Mask[r#109, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_47[r#109, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_47, Mask);
    assume r#109 != null;
    Heap[r#109, AVLTreeNode.keys] := inhaleHeap#_47[r#109, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#109, AVLTreeNode.keys] := Mask[r#109, AVLTreeNode.keys][perm$R := Mask[r#109, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_47[r#109, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_47, Mask);
    assume Seq#Contains(Heap[r#109, AVLTreeNode.keys], k#108);
    assume (forall i#70#110: int :: (0 <= i#70#110) && (i#70#110 < Seq#Length(old(Heap)[this#107, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#109, AVLTreeNode.keys], Seq#Index(callHeap#_39[this#107, AVLTreeNode.keys], i#70#110)));
    assume (forall i#71#111: int :: (0 <= i#71#111) && (i#71#111 < Seq#Length(Heap[r#109, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_39[this#107, AVLTreeNode.keys], Seq#Index(Heap[r#109, AVLTreeNode.keys], i#71#111)) || (Seq#Index(Heap[r#109, AVLTreeNode.keys], i#71#111) == k#108)));
    if (Seq#Contains(callHeap#_39[this#107, AVLTreeNode.keys], k#108)) {
      assume Seq#Equal(Heap[r#109, AVLTreeNode.keys], callHeap#_39[this#107, AVLTreeNode.keys]);
    } else {
    }
    if (!Seq#Contains(callHeap#_39[this#107, AVLTreeNode.keys], k#108)) {
      assume Seq#Length(Heap[r#109, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this#107, AVLTreeNode.keys]) + 1);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#63 := r#109;
    // update field root
    assert {:msg "  53.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#63;
    assume wf(Heap, Mask);
  }
  // update field keys
  assert {:msg "  55.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
  assert {:msg "  55.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  55.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  assert {:msg "  55.11: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
  assert {:msg "  55.11: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTree.root], AVLTreeNode.keys);
  Heap[this, AVLTree.keys] := Heap[Heap[this, AVLTree.root], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  // fold
  assert {:msg "  56.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_48 := Mask;
  fraction#_49 := 100;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_49 <= exhaleMask#_48[this, AVLTree.root][perm$R]) && ((fraction#_49 == exhaleMask#_48[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_48[this, AVLTree.root][perm$N]));
  exhaleMask#_48[this, AVLTree.root] := exhaleMask#_48[this, AVLTree.root][perm$R := exhaleMask#_48[this, AVLTree.root][perm$R] - fraction#_49];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_48);
  fraction#_50 := 50;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (fraction#_50 <= exhaleMask#_48[this, AVLTree.keys][perm$R]) && ((fraction#_50 == exhaleMask#_48[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_48[this, AVLTree.keys][perm$N]));
  exhaleMask#_48[this, AVLTree.keys] := exhaleMask#_48[this, AVLTree.keys][perm$R := exhaleMask#_48[this, AVLTree.keys][perm$R] - fraction#_50];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_48);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_51 := 100;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_51 <= exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_51 == exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_51];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_48);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_52 := 50;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (fraction#_52 <= exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((fraction#_52 == exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_48[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - fraction#_52];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_48);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  Mask := exhaleMask#_48;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_53;
  assume IsGoodInhaleState(inhaleHeap#_53, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_53[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_53[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_53[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_53, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_54 := Mask;
  fraction#_55 := 100;
  assert {:msg "  35.2: The postcondition at 39.11 might not hold. Insufficient fraction at 39.11 for AVLTree.valid."} (fraction#_55 <= exhaleMask#_54[this, AVLTree.valid][perm$R]) && ((fraction#_55 == exhaleMask#_54[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_54[this, AVLTree.valid][perm$N]));
  exhaleMask#_54[this, AVLTree.valid] := exhaleMask#_54[this, AVLTree.valid][perm$R := exhaleMask#_54[this, AVLTree.valid][perm$R] - fraction#_55];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_54);
  fraction#_56 := 50;
  assert {:msg "  35.2: The postcondition at 40.11 might not hold. Insufficient fraction at 40.11 for AVLTree.keys."} (fraction#_56 <= exhaleMask#_54[this, AVLTree.keys][perm$R]) && ((fraction#_56 == exhaleMask#_54[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_54[this, AVLTree.keys][perm$N]));
  exhaleMask#_54[this, AVLTree.keys] := exhaleMask#_54[this, AVLTree.keys][perm$R := exhaleMask#_54[this, AVLTree.keys][perm$R] - fraction#_56];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_54);
  assert {:msg "  35.2: The postcondition at 42.11 might not hold. The expression at 42.11 might not evaluate to true."} Seq#Contains(Heap[this, AVLTree.keys], k#0);
  assert {:msg "  35.2: The postcondition at 43.11 might not hold. The expression at 43.11 might not evaluate to true."} (forall j#61#112: int :: (0 <= j#61#112) && (j#61#112 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#61#112)));
  assert {:msg "  35.2: The postcondition at 44.11 might not hold. The expression at 44.11 might not evaluate to true."} (forall j#62#113: int :: (0 <= j#62#113) && (j#62#113 < Seq#Length(Heap[this, AVLTree.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#62#113)) || (Seq#Index(Heap[this, AVLTree.keys], j#62#113) == k#0)));
  Mask := exhaleMask#_54;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  35.2: Method might lock/unlock more than allowed."} (forall lk#_57: ref :: {Heap[lk#_57, held]} {Heap[lk#_57, rdheld]} (((0 < Heap[lk#_57, held]) == (0 < old(Heap)[lk#_57, held])) && (Heap[lk#_57, rdheld] == old(Heap)[lk#_57, rdheld])) || false);
  assert {:msg "  35.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_58: HeapType;
  var inhaleHeap#_59: HeapType;
  var j#64#115: int where true;
  var j#65#117: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_58;
  assume IsGoodInhaleState(inhaleHeap#_58, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_58[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_58[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_58[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_58, Mask);
  assert {:msg "  62.21: Fraction might be negative."} 0 <= 50;
  assert {:msg "  62.21: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_58[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_58[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_58, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_59;
  assume IsGoodInhaleState(inhaleHeap#_59, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_59[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_59[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_59[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_59, Mask);
  assert {:msg "  65.20: Fraction might be negative."} 0 <= 50;
  assert {:msg "  65.20: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_59[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_59[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_59, Mask);
  assert {:msg "  67.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  67.18: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume !Seq#Contains(Heap[this, AVLTree.keys], k#3);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#64#115) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#64#115) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  68.36: Sequence index might be negative."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (0 <= j#64#115);
  assert {:msg "  68.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assert {:msg "  68.41: Receiver might be null."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  68.41: Location might not be readable."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  68.11: Receiver might be null."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#64#115))) ==> (this != null);
  assert {:msg "  68.11: Location might not be readable."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#64#115))) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  68.36: Sequence index might be negative."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#64#115))) ==> (0 <= j#64#115);
  assert {:msg "  68.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#64#115) && (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys])) && (!Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#64#115))) ==> (j#64#115 < Seq#Length(old(Heap)[this, AVLTree.keys]));
  assume (forall j#64#114: int :: (0 <= j#64#114) && (j#64#114 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#64#114)) || (Seq#Index(old(Heap)[this, AVLTree.keys], j#64#114) == k#3)));
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#65#117) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#65#117) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  69.33: Sequence index might be negative."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (0 <= j#65#117);
  assert {:msg "  69.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (j#65#117 < Seq#Length(Heap[this, AVLTree.keys]));
  assert {:msg "  69.42: Receiver might be null."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> (this != null);
  assert {:msg "  69.42: Location might not be readable."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) ==> CanRead(old(Mask), this, AVLTree.keys);
  assert {:msg "  69.11: Receiver might be null."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#65#117)) ==> (this != null);
  assert {:msg "  69.11: Location might not be readable."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#65#117)) ==> CanRead(Mask, this, AVLTree.keys);
  assert {:msg "  69.33: Sequence index might be negative."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#65#117)) ==> (0 <= j#65#117);
  assert {:msg "  69.33: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= j#65#117) && (j#65#117 < Seq#Length(Heap[this, AVLTree.keys])) && Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#65#117)) ==> (j#65#117 < Seq#Length(Heap[this, AVLTree.keys]));
  assume (forall j#65#116: int :: (0 <= j#65#116) && (j#65#116 < Seq#Length(Heap[this, AVLTree.keys])) ==> Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#65#116)) && (!(Seq#Index(Heap[this, AVLTree.keys], j#65#116) == k#3)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.remove(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_60: HeapType;
  var exhaleMask#_61: MaskType;
  var fraction#_62: int;
  var inhaleHeap#_63: HeapType;
  var this#118: ref where (this#118 == null) || (dtype(this#118) == AVLTreeNode#t);
  var k#119: int where true;
  var r#120: ref where (r#120 == null) || (dtype(r#120) == AVLTreeNode#t);
  var callHeap#_64: HeapType;
  var callMask#_65: MaskType;
  var callCredits#_66: CreditsType;
  var exhaleMask#_67: MaskType;
  var fraction#_68: int;
  var fraction#_69: int;
  var isHeld#_70: int;
  var isRdHeld#_71: bool;
  var inhaleHeap#_72: HeapType;
  var r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t);
  var exhaleMask#_73: MaskType;
  var fraction#_74: int;
  var fraction#_75: int;
  var fraction#_76: int;
  var fraction#_77: int;
  var inhaleHeap#_78: HeapType;
  var exhaleMask#_79: MaskType;
  var fraction#_80: int;
  var fraction#_81: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_60;
  assume IsGoodInhaleState(inhaleHeap#_60, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_60[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_60[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_60[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_60, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_60[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_60[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_60, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  71.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_61 := Mask;
  fraction#_62 := 100;
  assert {:msg "  71.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (fraction#_62 <= exhaleMask#_61[this, AVLTree.valid][perm$R]) && ((fraction#_62 == exhaleMask#_61[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_61[this, AVLTree.valid][perm$N]));
  exhaleMask#_61[this, AVLTree.valid] := exhaleMask#_61[this, AVLTree.valid][perm$R := exhaleMask#_61[this, AVLTree.valid][perm$R] - fraction#_62];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_61);
  Mask := exhaleMask#_61;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_63 := Heap[this, AVLTree.valid];
  assume IsGoodInhaleState(inhaleHeap#_63, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_63[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_63[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_63, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_63[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_63[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_63, Mask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_63, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.keys] := inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_63, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  72.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  72.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
  } else {
    // call remove
    callHeap#_64 := Heap;
    callMask#_65 := Mask;
    callCredits#_66 := Credits;
    assert {:msg "  74.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  74.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  74.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#118 := Heap[this, AVLTree.root];
    k#119 := k#3;
    // begin exhale (precondition)
    exhaleMask#_67 := Mask;
    fraction#_68 := 100;
    assert {:msg "  74.4: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (fraction#_68 <= exhaleMask#_67[this#118, AVLTreeNode.valid][perm$R]) && ((fraction#_68 == exhaleMask#_67[this#118, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_67[this#118, AVLTreeNode.valid][perm$N]));
    exhaleMask#_67[this#118, AVLTreeNode.valid] := exhaleMask#_67[this#118, AVLTreeNode.valid][perm$R := exhaleMask#_67[this#118, AVLTreeNode.valid][perm$R] - fraction#_68];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_67);
    fraction#_69 := 50;
    assert {:msg "  74.4: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} (fraction#_69 <= exhaleMask#_67[this#118, AVLTreeNode.keys][perm$R]) && ((fraction#_69 == exhaleMask#_67[this#118, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_67[this#118, AVLTreeNode.keys][perm$N]));
    exhaleMask#_67[this#118, AVLTreeNode.keys] := exhaleMask#_67[this#118, AVLTreeNode.keys][perm$R := exhaleMask#_67[this#118, AVLTreeNode.keys][perm$R] - fraction#_69];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_67);
    Mask := exhaleMask#_67;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#120;
    // inhale (postcondition)
    havoc inhaleHeap#_72;
    assume IsGoodInhaleState(inhaleHeap#_72, Heap, Mask);
    if (Seq#Equal(callHeap#_64[this#118, AVLTreeNode.keys], Seq#Singleton(k#119))) {
      assume r#120 == null;
    } else {
    }
    if (!Seq#Equal(callHeap#_64[this#118, AVLTreeNode.keys], Seq#Singleton(k#119))) {
      assume !(r#120 == null);
    } else {
    }
    if (!(r#120 == null)) {
      assume r#120 != null;
      Heap[r#120, AVLTreeNode.valid] := inhaleHeap#_72[r#120, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_72[r#120, AVLTreeNode.valid] == Heap;
      Mask[r#120, AVLTreeNode.valid] := Mask[r#120, AVLTreeNode.valid][perm$R := Mask[r#120, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_72[r#120, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_72, Mask);
    } else {
    }
    if (!(r#120 == null)) {
      assume r#120 != null;
      Heap[r#120, AVLTreeNode.keys] := inhaleHeap#_72[r#120, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#120, AVLTreeNode.keys] := Mask[r#120, AVLTreeNode.keys][perm$R := Mask[r#120, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_72[r#120, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_72, Mask);
    } else {
    }
    if (!(r#120 == null)) {
      assume !Seq#Contains(Heap[r#120, AVLTreeNode.keys], k#119);
    } else {
    }
    if (!(r#120 == null)) {
      assume (forall i#72#121: int :: (0 <= i#72#121) && (i#72#121 < Seq#Length(old(Heap)[this#118, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#120, AVLTreeNode.keys], Seq#Index(callHeap#_64[this#118, AVLTreeNode.keys], i#72#121)) || (Seq#Index(callHeap#_64[this#118, AVLTreeNode.keys], i#72#121) == k#119)));
    } else {
    }
    if (!(r#120 == null)) {
      assume (forall i#73#122: int :: (0 <= i#73#122) && (i#73#122 < Seq#Length(Heap[r#120, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_64[this#118, AVLTreeNode.keys], Seq#Index(Heap[r#120, AVLTreeNode.keys], i#73#122)) && (!(Seq#Index(Heap[r#120, AVLTreeNode.keys], i#73#122) == k#119)));
    } else {
    }
    if (!Seq#Contains(callHeap#_64[this#118, AVLTreeNode.keys], k#119)) {
      assume Seq#Equal(Heap[r#120, AVLTreeNode.keys], callHeap#_64[this#118, AVLTreeNode.keys]);
    } else {
    }
    if (!(r#120 == null)) {
      if (Seq#Contains(callHeap#_64[this#118, AVLTreeNode.keys], k#119)) {
        assume Seq#Length(Heap[r#120, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this#118, AVLTreeNode.keys]) - 1);
      } else {
      }
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#66 := r#120;
    // update field root
    assert {:msg "  75.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#66;
    assume wf(Heap, Mask);
    // update field keys
    assert {:msg "  76.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.keys);
    assert {:msg "  76.13: Receiver might be null."} true ==> (this != null);
    assert {:msg "  76.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    if (Heap[this, AVLTree.root] == null) {
    } else {
      assert {:msg "  76.33: Receiver might be null."} true ==> (this != null);
      assert {:msg "  76.33: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
      assert {:msg "  76.33: Receiver might be null."} true ==> (Heap[this, AVLTree.root] != null);
      assert {:msg "  76.33: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTree.root], AVLTreeNode.keys);
    }
    Heap[this, AVLTree.keys] := ite(Heap[this, AVLTree.root] == null, Seq#Empty(), Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
  }
  // fold
  assert {:msg "  78.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_73 := Mask;
  fraction#_74 := 100;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_74 <= exhaleMask#_73[this, AVLTree.root][perm$R]) && ((fraction#_74 == exhaleMask#_73[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_73[this, AVLTree.root][perm$N]));
  exhaleMask#_73[this, AVLTree.root] := exhaleMask#_73[this, AVLTree.root][perm$R := exhaleMask#_73[this, AVLTree.root][perm$R] - fraction#_74];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_73);
  fraction#_75 := 50;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (fraction#_75 <= exhaleMask#_73[this, AVLTree.keys][perm$R]) && ((fraction#_75 == exhaleMask#_73[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_73[this, AVLTree.keys][perm$N]));
  exhaleMask#_73[this, AVLTree.keys] := exhaleMask#_73[this, AVLTree.keys][perm$R := exhaleMask#_73[this, AVLTree.keys][perm$R] - fraction#_75];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_73);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_76 := 100;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_76 <= exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_76 == exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_76];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_73);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_77 := 50;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (fraction#_77 <= exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((fraction#_77 == exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_73[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - fraction#_77];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_73);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  Mask := exhaleMask#_73;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_78;
  assume IsGoodInhaleState(inhaleHeap#_78, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_78[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_78[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_78[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_78, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_79 := Mask;
  fraction#_80 := 100;
  assert {:msg "  60.2: The postcondition at 64.11 might not hold. Insufficient fraction at 64.11 for AVLTree.valid."} (fraction#_80 <= exhaleMask#_79[this, AVLTree.valid][perm$R]) && ((fraction#_80 == exhaleMask#_79[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_79[this, AVLTree.valid][perm$N]));
  exhaleMask#_79[this, AVLTree.valid] := exhaleMask#_79[this, AVLTree.valid][perm$R := exhaleMask#_79[this, AVLTree.valid][perm$R] - fraction#_80];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_79);
  fraction#_81 := 50;
  assert {:msg "  60.2: The postcondition at 65.11 might not hold. Insufficient fraction at 65.11 for AVLTree.keys."} (fraction#_81 <= exhaleMask#_79[this, AVLTree.keys][perm$R]) && ((fraction#_81 == exhaleMask#_79[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_79[this, AVLTree.keys][perm$N]));
  exhaleMask#_79[this, AVLTree.keys] := exhaleMask#_79[this, AVLTree.keys][perm$R := exhaleMask#_79[this, AVLTree.keys][perm$R] - fraction#_81];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_79);
  assert {:msg "  60.2: The postcondition at 67.11 might not hold. The expression at 67.11 might not evaluate to true."} !Seq#Contains(Heap[this, AVLTree.keys], k#3);
  assert {:msg "  60.2: The postcondition at 68.11 might not hold. The expression at 68.11 might not evaluate to true."} (forall j#64#123: int :: (0 <= j#64#123) && (j#64#123 < Seq#Length(old(Heap)[this, AVLTree.keys])) ==> (Seq#Contains(Heap[this, AVLTree.keys], Seq#Index(old(Heap)[this, AVLTree.keys], j#64#123)) || (Seq#Index(old(Heap)[this, AVLTree.keys], j#64#123) == k#3)));
  assert {:msg "  60.2: The postcondition at 69.11 might not hold. The expression at 69.11 might not evaluate to true."} (forall j#65#124: int :: (0 <= j#65#124) && (j#65#124 < Seq#Length(Heap[this, AVLTree.keys])) ==> Seq#Contains(old(Heap)[this, AVLTree.keys], Seq#Index(Heap[this, AVLTree.keys], j#65#124)) && (!(Seq#Index(Heap[this, AVLTree.keys], j#65#124) == k#3)));
  Mask := exhaleMask#_79;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  60.2: Method might lock/unlock more than allowed."} (forall lk#_82: ref :: {Heap[lk#_82, held]} {Heap[lk#_82, rdheld]} (((0 < Heap[lk#_82, held]) == (0 < old(Heap)[lk#_82, held])) && (Heap[lk#_82, rdheld] == old(Heap)[lk#_82, rdheld])) || false);
  assert {:msg "  60.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_83: HeapType;
  var inhaleHeap#_84: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_83;
  assume IsGoodInhaleState(inhaleHeap#_83, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_83[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_83[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_83[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTree.keys][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTree.keys][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$N := Mask[this, AVLTree.keys][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_84;
  assume IsGoodInhaleState(inhaleHeap#_84, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_84[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_84[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_84[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_84, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_84[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTree.keys][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTree.keys][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$N := Mask[this, AVLTree.keys][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_84[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_84, Mask);
  assert {:msg "  88.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  88.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.keys);
  assume b#5 == Seq#Contains(Heap[this, AVLTree.keys], k#4);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.has(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_85: HeapType;
  var exhaleMask#_86: MaskType;
  var fraction#_87: int;
  var inhaleHeap#_88: HeapType;
  var bb#7: bool where true;
  var this#125: ref where (this#125 == null) || (dtype(this#125) == AVLTreeNode#t);
  var k#126: int where true;
  var b#127: bool where true;
  var callHeap#_89: HeapType;
  var callMask#_90: MaskType;
  var callCredits#_91: CreditsType;
  var exhaleMask#_92: MaskType;
  var fraction#_93: int;
  var epsilons#_94: int;
  var isHeld#_95: int;
  var isRdHeld#_96: bool;
  var inhaleHeap#_97: HeapType;
  var exhaleMask#_98: MaskType;
  var fraction#_99: int;
  var fraction#_100: int;
  var fraction#_101: int;
  var fraction#_102: int;
  var inhaleHeap#_103: HeapType;
  var exhaleMask#_104: MaskType;
  var fraction#_105: int;
  var epsilons#_106: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_85;
  assume IsGoodInhaleState(inhaleHeap#_85, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_85[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_85[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_85[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTree.keys][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTree.keys][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$N := Mask[this, AVLTree.keys][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  90.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_86 := Mask;
  fraction#_87 := 100;
  assert {:msg "  90.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (fraction#_87 <= exhaleMask#_86[this, AVLTree.valid][perm$R]) && ((fraction#_87 == exhaleMask#_86[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_86[this, AVLTree.valid][perm$N]));
  exhaleMask#_86[this, AVLTree.valid] := exhaleMask#_86[this, AVLTree.valid][perm$R := exhaleMask#_86[this, AVLTree.valid][perm$R] - fraction#_87];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_86);
  Mask := exhaleMask#_86;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_88 := Heap[this, AVLTree.valid];
  assume IsGoodInhaleState(inhaleHeap#_88, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_88[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_88[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_88, Mask);
  assume this != null;
  Heap[this, AVLTree.keys] := inhaleHeap#_88[this, AVLTree.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTree.keys] := Mask[this, AVLTree.keys][perm$R := Mask[this, AVLTree.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_88[this, AVLTree.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_88, Mask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_88, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.keys] := inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.keys] := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_88, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assume Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  91.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  91.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    // assigment to b
    b#5 := false;
  } else {
    // local var bb
    // call has
    callHeap#_89 := Heap;
    callMask#_90 := Mask;
    callCredits#_91 := Credits;
    assert {:msg "  95.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  95.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  95.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#125 := Heap[this, AVLTree.root];
    k#126 := k#4;
    // begin exhale (precondition)
    exhaleMask#_92 := Mask;
    fraction#_93 := 100;
    assert {:msg "  95.4: The precondition at 455.12 might not hold. Insufficient fraction at 455.12 for AVLTreeNode.valid."} (fraction#_93 <= exhaleMask#_92[this#125, AVLTreeNode.valid][perm$R]) && ((fraction#_93 == exhaleMask#_92[this#125, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_92[this#125, AVLTreeNode.valid][perm$N]));
    exhaleMask#_92[this#125, AVLTreeNode.valid] := exhaleMask#_92[this#125, AVLTreeNode.valid][perm$R := exhaleMask#_92[this#125, AVLTreeNode.valid][perm$R] - fraction#_93];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_92);
    epsilons#_94 := 1;
    assert {:msg "  95.4: The precondition at 456.12 might not hold. Insufficient epsilons at 456.12  for AVLTreeNode.keys."} (exhaleMask#_92[this#125, AVLTreeNode.keys][perm$R] == 0) ==> (epsilons#_94 <= exhaleMask#_92[this#125, AVLTreeNode.keys][perm$N]);
    if ((exhaleMask#_92[this#125, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (exhaleMask#_92[this#125, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_92[this#125, AVLTreeNode.keys] := exhaleMask#_92[this#125, AVLTreeNode.keys][perm$N := exhaleMask#_92[this#125, AVLTreeNode.keys][perm$N] - epsilons#_94];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_92);
    Mask := exhaleMask#_92;
    assume wf(Heap, Mask);
    // end exhale
    havoc b#127;
    // inhale (postcondition)
    havoc inhaleHeap#_97;
    assume IsGoodInhaleState(inhaleHeap#_97, Heap, Mask);
    assume this#125 != null;
    Heap[this#125, AVLTreeNode.valid] := inhaleHeap#_97[this#125, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_97[this#125, AVLTreeNode.valid] == Heap;
    Mask[this#125, AVLTreeNode.valid] := Mask[this#125, AVLTreeNode.valid][perm$R := Mask[this#125, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_97[this#125, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_97, Mask);
    assume this#125 != null;
    Heap[this#125, AVLTreeNode.keys] := inhaleHeap#_97[this#125, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[this#125, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (Mask[this#125, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
      Mask[this#125, AVLTreeNode.keys] := Mask[this#125, AVLTreeNode.keys][perm$N := Mask[this#125, AVLTreeNode.keys][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_97[this#125, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_97, Mask);
    assume b#127 == Seq#Contains(Heap[this#125, AVLTreeNode.keys], k#126);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    bb#7 := b#127;
    // assigment to b
    b#5 := bb#7;
  }
  // fold
  assert {:msg "  98.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_98 := Mask;
  fraction#_99 := 100;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_99 <= exhaleMask#_98[this, AVLTree.root][perm$R]) && ((fraction#_99 == exhaleMask#_98[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_98[this, AVLTree.root][perm$N]));
  exhaleMask#_98[this, AVLTree.root] := exhaleMask#_98[this, AVLTree.root][perm$R := exhaleMask#_98[this, AVLTree.root][perm$R] - fraction#_99];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_98);
  fraction#_100 := 50;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 11.6 for AVLTree.keys."} (fraction#_100 <= exhaleMask#_98[this, AVLTree.keys][perm$R]) && ((fraction#_100 == exhaleMask#_98[this, AVLTree.keys][perm$R]) ==> (0 <= exhaleMask#_98[this, AVLTree.keys][perm$N]));
  exhaleMask#_98[this, AVLTree.keys] := exhaleMask#_98[this, AVLTree.keys][perm$R := exhaleMask#_98[this, AVLTree.keys][perm$R] - fraction#_100];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_98);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_101 := 100;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_101 <= exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_101 == exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_101];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_98);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_102 := 50;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 14.22 for AVLTreeNode.keys."} (fraction#_102 <= exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) && ((fraction#_102 == exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$N]));
    exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.keys] := exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R := exhaleMask#_98[Heap[this, AVLTree.root], AVLTreeNode.keys][perm$R] - fraction#_102];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_98);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 16.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Heap[Heap[this, AVLTree.root], AVLTreeNode.keys]);
  } else {
  }
  if (Heap[this, AVLTree.root] == null) {
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. The expression at 17.22 might not evaluate to true."} Seq#Equal(Heap[this, AVLTree.keys], Seq#Empty());
  } else {
  }
  Mask := exhaleMask#_98;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_103;
  assume IsGoodInhaleState(inhaleHeap#_103, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_103[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_103[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_103[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_103, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_104 := Mask;
  fraction#_105 := 100;
  assert {:msg "  82.2: The postcondition at 86.11 might not hold. Insufficient fraction at 86.11 for AVLTree.valid."} (fraction#_105 <= exhaleMask#_104[this, AVLTree.valid][perm$R]) && ((fraction#_105 == exhaleMask#_104[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_104[this, AVLTree.valid][perm$N]));
  exhaleMask#_104[this, AVLTree.valid] := exhaleMask#_104[this, AVLTree.valid][perm$R := exhaleMask#_104[this, AVLTree.valid][perm$R] - fraction#_105];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_104);
  epsilons#_106 := 1;
  assert {:msg "  82.2: The postcondition at 87.11 might not hold. Insufficient epsilons at 87.11  for AVLTree.keys."} (exhaleMask#_104[this, AVLTree.keys][perm$R] == 0) ==> (epsilons#_106 <= exhaleMask#_104[this, AVLTree.keys][perm$N]);
  if ((exhaleMask#_104[this, AVLTree.keys][perm$N] != Permission$MinusInfinity) && (exhaleMask#_104[this, AVLTree.keys][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_104[this, AVLTree.keys] := exhaleMask#_104[this, AVLTree.keys][perm$N := exhaleMask#_104[this, AVLTree.keys][perm$N] - epsilons#_106];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_104);
  assert {:msg "  82.2: The postcondition at 88.11 might not hold. The expression at 88.11 might not evaluate to true."} b#5 == Seq#Contains(Heap[this, AVLTree.keys], k#4);
  Mask := exhaleMask#_104;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  82.2: Method might lock/unlock more than allowed."} (forall lk#_107: ref :: {Heap[lk#_107, held]} {Heap[lk#_107, rdheld]} (((0 < Heap[lk#_107, held]) == (0 < old(Heap)[lk#_107, held])) && (Heap[lk#_107, rdheld] == old(Heap)[lk#_107, rdheld])) || false);
  assert {:msg "  82.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTreeNode#t: TypeName;
procedure AVLTreeNode$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var h0#_108: HeapType;
  var m0#_109: MaskType;
  var c0#_110: CreditsType;
  var h1#_111: HeapType;
  var m1#_112: MaskType;
  var c1#_113: CreditsType;
  var lk#_114: ref;
  assume wf(h0#_108, m0#_109);
  assume wf(h1#_111, m1#_112);
  m1#_112 := ZeroMask;
  c1#_113 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  104.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTreeNode.key: Field (int);
axiom NonPredicateField(AVLTreeNode.key);
const unique AVLTreeNode.left: Field (ref);
axiom NonPredicateField(AVLTreeNode.left);
const unique AVLTreeNode.right: Field (ref);
axiom NonPredicateField(AVLTreeNode.right);
const unique AVLTreeNode.keys: Field (Seq (int));
axiom NonPredicateField(AVLTreeNode.keys);
const unique AVLTreeNode.valid: Field (HeapType);
axiom PredicateField(AVLTreeNode.valid);
procedure AVLTreeNode.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_115: HeapType;
  var lk#67#130: int where true;
  var rk#68#131: int where true;
  var kk#132: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_115;
  assume IsGoodInhaleState(inhaleHeap#_115, Heap, Mask);
  assert {:msg "  117.17: Fraction might be negative."} 0 <= 100;
  assert {:msg "  117.17: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_115[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  119.17: Fraction might be negative."} 0 <= 100;
  assert {:msg "  119.17: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_115[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  120.17: Fraction might be negative."} 0 <= 100;
  assert {:msg "  120.17: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_115[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  122.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  122.24: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_115[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  125.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  125.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  125.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  125.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_115[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_115[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_115[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_115, Mask);
  } else {
  }
  assert {:msg "  127.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  127.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  127.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  127.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  127.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  127.45: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_115[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_115[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_115, Mask);
  } else {
  }
  assert {:msg "  129.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  129.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#67#130) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#67#130) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#67#130) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#67#130) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  129.48: Sequence index might be negative."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= lk#67#130);
    assert {:msg "  129.48: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  129.53: Receiver might be null."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  129.53: Location might not be readable."} true && (0 <= lk#67#130) && (lk#67#130 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall lk#67#128: int :: (0 <= lk#67#128) && (lk#67#128 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#128) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assert {:msg "  132.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  132.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  132.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  132.23: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_115[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_115[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_115[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_115, Mask);
  } else {
  }
  assert {:msg "  134.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  134.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  134.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  134.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  134.47: Fraction might be negative."} 0 <= 50;
    assert {:msg "  134.47: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_115[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_115[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_115, Mask);
  } else {
  }
  assert {:msg "  136.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  136.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#68#131) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#68#131) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#68#131) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#68#131) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  136.51: Receiver might be null."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  136.51: Location might not be readable."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  117.6: Receiver might be null."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  117.6: Location might not be readable."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  136.57: Sequence index might be negative."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= rk#68#131);
    assert {:msg "  136.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= rk#68#131) && (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (rk#68#131 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall rk#68#129: int :: (0 <= rk#68#129) && (rk#68#129 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#129)));
  } else {
  }
  assert {:msg "  139.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assert {:msg "  139.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  139.49: Receiver might be null."} true ==> (this != null);
    assert {:msg "  139.49: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  139.49: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  139.49: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  139.65: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.65: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  139.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.75: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  139.100: Receiver might be null."} true ==> (this != null);
    assert {:msg "  139.100: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  139.100: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  139.100: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  140.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  140.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  140.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  140.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  142.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  142.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assert {:msg "  144.9: Receiver might be null."} true ==> (this != null);
  assert {:msg "  144.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  144.30: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
  assert {:msg "  144.30: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  144.30: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  144.30: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  144.48: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132))) ==> (this != null);
  assert {:msg "  144.48: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132))) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  144.69: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> (this != null);
  assert {:msg "  144.69: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  144.69: Receiver might be null."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  144.69: Location might not be readable."} true && (!((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132))) && (!(Heap[this, AVLTreeNode.right] == null)) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  144.91: Receiver might be null."} true && (!(((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#132)))) ==> (this != null);
  assert {:msg "  144.91: Location might not be readable."} true && (!(((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#132)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#132)))) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_116: HeapType;
  var inhaleHeap#_117: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_116;
  assume IsGoodInhaleState(inhaleHeap#_116, Heap, Mask);
  assert {:msg "  155.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  155.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_116[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assert {:msg "  157.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  157.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_116[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assert {:msg "  158.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  158.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_116[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assert {:msg "  160.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  160.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_116[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_117;
  assume IsGoodInhaleState(inhaleHeap#_117, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_117[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_117[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_117[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_117, Mask);
  assert {:msg "  164.22: Fraction might be negative."} 0 <= 50;
  assert {:msg "  164.22: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_117[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_117[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_117, Mask);
  assert {:msg "  169.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  169.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Singleton(k#8));
  assert {:msg "  172.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  172.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], k#8);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.init(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_118: HeapType;
  var this#133: ref where (this#133 == null) || (dtype(this#133) == AVLTreeNode#t);
  var callHeap#_119: HeapType;
  var callMask#_120: MaskType;
  var callCredits#_121: CreditsType;
  var exhaleMask#_122: MaskType;
  var fraction#_123: int;
  var fraction#_124: int;
  var fraction#_125: int;
  var fraction#_126: int;
  var fraction#_127: int;
  var fraction#_128: int;
  var fraction#_129: int;
  var fraction#_130: int;
  var isHeld#_131: int;
  var isRdHeld#_132: bool;
  var inhaleHeap#_133: HeapType;
  var exhaleMask#_134: MaskType;
  var fraction#_135: int;
  var fraction#_136: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_118;
  assume IsGoodInhaleState(inhaleHeap#_118, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_118[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_118[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_118, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_118[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_118[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_118, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_118[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_118[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_118, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_118[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_118[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_118, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field left
  assert {:msg "  174.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  Heap[this, AVLTreeNode.left] := null;
  assume wf(Heap, Mask);
  // update field right
  assert {:msg "  175.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  Heap[this, AVLTreeNode.right] := null;
  assume wf(Heap, Mask);
  // update field key
  assert {:msg "  176.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.key);
  Heap[this, AVLTreeNode.key] := k#8;
  assume wf(Heap, Mask);
  // call close
  callHeap#_119 := Heap;
  callMask#_120 := Mask;
  callCredits#_121 := Credits;
  assert {:msg "  179.3: The target of the method call might be null."} this != null;
  this#133 := this;
  // begin exhale (precondition)
  exhaleMask#_122 := Mask;
  fraction#_123 := 100;
  assert {:msg "  179.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_123 <= exhaleMask#_122[this#133, AVLTreeNode.key][perm$R]) && ((fraction#_123 == exhaleMask#_122[this#133, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_122[this#133, AVLTreeNode.key][perm$N]));
  exhaleMask#_122[this#133, AVLTreeNode.key] := exhaleMask#_122[this#133, AVLTreeNode.key][perm$R := exhaleMask#_122[this#133, AVLTreeNode.key][perm$R] - fraction#_123];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_122);
  fraction#_124 := 100;
  assert {:msg "  179.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_124 <= exhaleMask#_122[this#133, AVLTreeNode.left][perm$R]) && ((fraction#_124 == exhaleMask#_122[this#133, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_122[this#133, AVLTreeNode.left][perm$N]));
  exhaleMask#_122[this#133, AVLTreeNode.left] := exhaleMask#_122[this#133, AVLTreeNode.left][perm$R := exhaleMask#_122[this#133, AVLTreeNode.left][perm$R] - fraction#_124];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_122);
  fraction#_125 := 100;
  assert {:msg "  179.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_125 <= exhaleMask#_122[this#133, AVLTreeNode.right][perm$R]) && ((fraction#_125 == exhaleMask#_122[this#133, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_122[this#133, AVLTreeNode.right][perm$N]));
  exhaleMask#_122[this#133, AVLTreeNode.right] := exhaleMask#_122[this#133, AVLTreeNode.right][perm$R := exhaleMask#_122[this#133, AVLTreeNode.right][perm$R] - fraction#_125];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_122);
  fraction#_126 := 100;
  assert {:msg "  179.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_126 <= exhaleMask#_122[this#133, AVLTreeNode.keys][perm$R]) && ((fraction#_126 == exhaleMask#_122[this#133, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_122[this#133, AVLTreeNode.keys][perm$N]));
  exhaleMask#_122[this#133, AVLTreeNode.keys] := exhaleMask#_122[this#133, AVLTreeNode.keys][perm$R := exhaleMask#_122[this#133, AVLTreeNode.keys][perm$R] - fraction#_126];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_122);
  if (!(Heap[this#133, AVLTreeNode.left] == null)) {
    fraction#_127 := 100;
    assert {:msg "  179.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_127 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_127 == exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_127];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_122);
  } else {
  }
  if (!(Heap[this#133, AVLTreeNode.left] == null)) {
    fraction#_128 := 50;
    assert {:msg "  179.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_128 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_128 == exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_122[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_128];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_122);
  } else {
  }
  if (!(Heap[this#133, AVLTreeNode.left] == null)) {
    assert {:msg "  179.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#134: int :: (0 <= k#79#134) && (k#79#134 < Seq#Length(Heap[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#133, AVLTreeNode.left], AVLTreeNode.keys], k#79#134) < Heap[this#133, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#133, AVLTreeNode.right] == null)) {
    fraction#_129 := 100;
    assert {:msg "  179.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_129 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_129 == exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_129];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_122);
  } else {
  }
  if (!(Heap[this#133, AVLTreeNode.right] == null)) {
    fraction#_130 := 50;
    assert {:msg "  179.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_130 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_130 == exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_122[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_130];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_122);
  } else {
  }
  if (!(Heap[this#133, AVLTreeNode.right] == null)) {
    assert {:msg "  179.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#135: int :: (0 <= k#80#135) && (k#80#135 < Seq#Length(Heap[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#133, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#133, AVLTreeNode.right], AVLTreeNode.keys], k#80#135)));
  } else {
  }
  Mask := exhaleMask#_122;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_133;
  assume IsGoodInhaleState(inhaleHeap#_133, Heap, Mask);
  assume this#133 != null;
  Heap[this#133, AVLTreeNode.valid] := inhaleHeap#_133[this#133, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_133[this#133, AVLTreeNode.valid] == Heap;
  Mask[this#133, AVLTreeNode.valid] := Mask[this#133, AVLTreeNode.valid][perm$R := Mask[this#133, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_133[this#133, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_133, Mask);
  assume this#133 != null;
  Heap[this#133, AVLTreeNode.keys] := inhaleHeap#_133[this#133, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#133, AVLTreeNode.keys] := Mask[this#133, AVLTreeNode.keys][perm$R := Mask[this#133, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_133[this#133, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_133, Mask);
  assume Seq#Equal(Heap[this#133, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_119[this#133, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_119[callHeap#_119[this#133, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_119[this#133, AVLTreeNode.key])), ite(callHeap#_119[this#133, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_119[callHeap#_119[this#133, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_134 := Mask;
  fraction#_135 := 100;
  assert {:msg "  154.2: The postcondition at 163.11 might not hold. Insufficient fraction at 163.11 for AVLTreeNode.valid."} (fraction#_135 <= exhaleMask#_134[this, AVLTreeNode.valid][perm$R]) && ((fraction#_135 == exhaleMask#_134[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_134[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_134[this, AVLTreeNode.valid] := exhaleMask#_134[this, AVLTreeNode.valid][perm$R := exhaleMask#_134[this, AVLTreeNode.valid][perm$R] - fraction#_135];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_134);
  fraction#_136 := 50;
  assert {:msg "  154.2: The postcondition at 164.11 might not hold. Insufficient fraction at 164.11 for AVLTreeNode.keys."} (fraction#_136 <= exhaleMask#_134[this, AVLTreeNode.keys][perm$R]) && ((fraction#_136 == exhaleMask#_134[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_134[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_134[this, AVLTreeNode.keys] := exhaleMask#_134[this, AVLTreeNode.keys][perm$R := exhaleMask#_134[this, AVLTreeNode.keys][perm$R] - fraction#_136];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_134);
  assert {:msg "  154.2: The postcondition at 169.11 might not hold. The expression at 169.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Singleton(k#8));
  assert {:msg "  154.2: The postcondition at 172.11 might not hold. The expression at 172.11 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], k#8);
  Mask := exhaleMask#_134;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  154.2: Method might lock/unlock more than allowed."} (forall lk#_137: ref :: {Heap[lk#_137, held]} {Heap[lk#_137, rdheld]} (((0 < Heap[lk#_137, held]) == (0 < old(Heap)[lk#_137, held])) && (Heap[lk#_137, rdheld] == old(Heap)[lk#_137, rdheld])) || false);
  assert {:msg "  154.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_138: HeapType;
  var inhaleHeap#_139: HeapType;
  var i#70#137: int where true;
  var i#71#139: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_138;
  assume IsGoodInhaleState(inhaleHeap#_138, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_138[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_138[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_138[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_138, Mask);
  assert {:msg "  186.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  186.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_138[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_138[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_138, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_139;
  assume IsGoodInhaleState(inhaleHeap#_139, Heap, Mask);
  assume !(r#10 == null);
  assume r#10 != null;
  Heap[r#10, AVLTreeNode.valid] := inhaleHeap#_139[r#10, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_139[r#10, AVLTreeNode.valid] == Heap;
  Mask[r#10, AVLTreeNode.valid] := Mask[r#10, AVLTreeNode.valid][perm$R := Mask[r#10, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_139[r#10, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_139, Mask);
  assert {:msg "  192.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  192.24: Fraction might exceed 100."} 50 <= 100;
  assume r#10 != null;
  Heap[r#10, AVLTreeNode.keys] := inhaleHeap#_139[r#10, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#10, AVLTreeNode.keys] := Mask[r#10, AVLTreeNode.keys][perm$R := Mask[r#10, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_139[r#10, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_139, Mask);
  assert {:msg "  196.16: Receiver might be null."} true ==> (r#10 != null);
  assert {:msg "  196.16: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assume Seq#Contains(Heap[r#10, AVLTreeNode.keys], k#9);
  assert {:msg "  197.11: Receiver might be null."} true && (0 <= i#70#137) ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true && (0 <= i#70#137) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assert {:msg "  197.11: Receiver might be null."} true && (0 <= i#70#137) && (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true && (0 <= i#70#137) && (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assert {:msg "  197.36: Sequence index might be negative."} true && (0 <= i#70#137) && (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (0 <= i#70#137);
  assert {:msg "  197.36: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#70#137) && (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
  assert {:msg "  197.41: Receiver might be null."} true && (0 <= i#70#137) && (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (r#10 != null);
  assert {:msg "  197.41: Location might not be readable."} true && (0 <= i#70#137) && (i#70#137 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assume (forall i#70#136: int :: (0 <= i#70#136) && (i#70#136 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#10, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#70#136)));
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#71#139) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#71#139) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.35: Sequence index might be negative."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (0 <= i#71#139);
  assert {:msg "  198.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys]));
  assert {:msg "  198.44: Receiver might be null."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  198.44: Location might not be readable."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assert {:msg "  198.11: Receiver might be null."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#139))) ==> (r#10 != null);
  assert {:msg "  198.11: Location might not be readable."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#139))) ==> CanRead(Mask, r#10, AVLTreeNode.keys);
  assert {:msg "  198.35: Sequence index might be negative."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#139))) ==> (0 <= i#71#139);
  assert {:msg "  198.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#71#139) && (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) && (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#139))) ==> (i#71#139 < Seq#Length(Heap[r#10, AVLTreeNode.keys]));
  assume (forall i#71#138: int :: (0 <= i#71#138) && (i#71#138 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#138)) || (Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#138) == k#9)));
  assert {:msg "  199.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  199.20: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  199.30: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  199.30: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.keys);
    assert {:msg "  199.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  199.42: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume Seq#Equal(Heap[r#10, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  assert {:msg "  200.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  200.22: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  200.34: Receiver might be null."} true ==> (r#10 != null);
    assert {:msg "  200.34: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.keys);
    assert {:msg "  200.50: Receiver might be null."} true ==> (this != null);
    assert {:msg "  200.50: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume Seq#Length(Heap[r#10, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) + 1);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.insert(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_140: HeapType;
  var exhaleMask#_141: MaskType;
  var fraction#_142: int;
  var inhaleHeap#_143: HeapType;
  var Heap#_147: HeapType;
  var Mask#_148: MaskType;
  var Credits#_149: CreditsType;
  var exhaleMask#_150: MaskType;
  var this#142: ref where (this#142 == null) || (dtype(this#142) == AVLTreeNode#t);
  var callHeap#_151: HeapType;
  var callMask#_152: MaskType;
  var callCredits#_153: CreditsType;
  var exhaleMask#_154: MaskType;
  var fraction#_155: int;
  var fraction#_156: int;
  var fraction#_157: int;
  var fraction#_158: int;
  var fraction#_159: int;
  var fraction#_160: int;
  var fraction#_161: int;
  var fraction#_162: int;
  var isHeld#_163: int;
  var isRdHeld#_164: bool;
  var inhaleHeap#_165: HeapType;
  var nl#12: ref where (nl#12 == null) || (dtype(nl#12) == AVLTreeNode#t);
  var nw#_166: ref;
  var this#145: ref where (this#145 == null) || (dtype(this#145) == AVLTreeNode#t);
  var k#146: int where true;
  var callHeap#_167: HeapType;
  var callMask#_168: MaskType;
  var callCredits#_169: CreditsType;
  var exhaleMask#_170: MaskType;
  var fraction#_171: int;
  var fraction#_172: int;
  var fraction#_173: int;
  var fraction#_174: int;
  var isHeld#_175: int;
  var isRdHeld#_176: bool;
  var inhaleHeap#_177: HeapType;
  var this#147: ref where (this#147 == null) || (dtype(this#147) == AVLTreeNode#t);
  var k#148: int where true;
  var r#149: ref where (r#149 == null) || (dtype(r#149) == AVLTreeNode#t);
  var callHeap#_178: HeapType;
  var callMask#_179: MaskType;
  var callCredits#_180: CreditsType;
  var exhaleMask#_181: MaskType;
  var fraction#_182: int;
  var fraction#_183: int;
  var isHeld#_184: int;
  var isRdHeld#_185: bool;
  var inhaleHeap#_186: HeapType;
  var bf#14: int where true;
  var this#152: ref where (this#152 == null) || (dtype(this#152) == AVLTreeNode#t);
  var bf#153: int where true;
  var callHeap#_187: HeapType;
  var callMask#_188: MaskType;
  var callCredits#_189: CreditsType;
  var exhaleMask#_190: MaskType;
  var epsilons#_191: int;
  var fraction#_192: int;
  var epsilons#_193: int;
  var fraction#_194: int;
  var isHeld#_195: int;
  var isRdHeld#_196: bool;
  var inhaleHeap#_197: HeapType;
  var this#154: ref where (this#154 == null) || (dtype(this#154) == AVLTreeNode#t);
  var r#155: ref where (r#155 == null) || (dtype(r#155) == AVLTreeNode#t);
  var callHeap#_198: HeapType;
  var callMask#_199: MaskType;
  var callCredits#_200: CreditsType;
  var exhaleMask#_201: MaskType;
  var fraction#_202: int;
  var fraction#_203: int;
  var fraction#_204: int;
  var fraction#_205: int;
  var fraction#_206: int;
  var fraction#_207: int;
  var fraction#_208: int;
  var fraction#_209: int;
  var isHeld#_210: int;
  var isRdHeld#_211: bool;
  var inhaleHeap#_212: HeapType;
  var this#158: ref where (this#158 == null) || (dtype(this#158) == AVLTreeNode#t);
  var callHeap#_213: HeapType;
  var callMask#_214: MaskType;
  var callCredits#_215: CreditsType;
  var exhaleMask#_216: MaskType;
  var fraction#_217: int;
  var fraction#_218: int;
  var fraction#_219: int;
  var fraction#_220: int;
  var fraction#_221: int;
  var fraction#_222: int;
  var fraction#_223: int;
  var fraction#_224: int;
  var isHeld#_225: int;
  var isRdHeld#_226: bool;
  var inhaleHeap#_227: HeapType;
  var nr#16: ref where (nr#16 == null) || (dtype(nr#16) == AVLTreeNode#t);
  var nw#_228: ref;
  var this#161: ref where (this#161 == null) || (dtype(this#161) == AVLTreeNode#t);
  var k#162: int where true;
  var callHeap#_229: HeapType;
  var callMask#_230: MaskType;
  var callCredits#_231: CreditsType;
  var exhaleMask#_232: MaskType;
  var fraction#_233: int;
  var fraction#_234: int;
  var fraction#_235: int;
  var fraction#_236: int;
  var isHeld#_237: int;
  var isRdHeld#_238: bool;
  var inhaleHeap#_239: HeapType;
  var this#163: ref where (this#163 == null) || (dtype(this#163) == AVLTreeNode#t);
  var k#164: int where true;
  var r#165: ref where (r#165 == null) || (dtype(r#165) == AVLTreeNode#t);
  var callHeap#_240: HeapType;
  var callMask#_241: MaskType;
  var callCredits#_242: CreditsType;
  var exhaleMask#_243: MaskType;
  var fraction#_244: int;
  var fraction#_245: int;
  var isHeld#_246: int;
  var isRdHeld#_247: bool;
  var inhaleHeap#_248: HeapType;
  var bf#18: int where true;
  var this#168: ref where (this#168 == null) || (dtype(this#168) == AVLTreeNode#t);
  var bf#169: int where true;
  var callHeap#_249: HeapType;
  var callMask#_250: MaskType;
  var callCredits#_251: CreditsType;
  var exhaleMask#_252: MaskType;
  var epsilons#_253: int;
  var fraction#_254: int;
  var epsilons#_255: int;
  var fraction#_256: int;
  var isHeld#_257: int;
  var isRdHeld#_258: bool;
  var inhaleHeap#_259: HeapType;
  var this#170: ref where (this#170 == null) || (dtype(this#170) == AVLTreeNode#t);
  var r#171: ref where (r#171 == null) || (dtype(r#171) == AVLTreeNode#t);
  var callHeap#_260: HeapType;
  var callMask#_261: MaskType;
  var callCredits#_262: CreditsType;
  var exhaleMask#_263: MaskType;
  var fraction#_264: int;
  var fraction#_265: int;
  var fraction#_266: int;
  var fraction#_267: int;
  var fraction#_268: int;
  var fraction#_269: int;
  var fraction#_270: int;
  var fraction#_271: int;
  var isHeld#_272: int;
  var isRdHeld#_273: bool;
  var inhaleHeap#_274: HeapType;
  var this#174: ref where (this#174 == null) || (dtype(this#174) == AVLTreeNode#t);
  var callHeap#_275: HeapType;
  var callMask#_276: MaskType;
  var callCredits#_277: CreditsType;
  var exhaleMask#_278: MaskType;
  var fraction#_279: int;
  var fraction#_280: int;
  var fraction#_281: int;
  var fraction#_282: int;
  var fraction#_283: int;
  var fraction#_284: int;
  var fraction#_285: int;
  var fraction#_286: int;
  var isHeld#_287: int;
  var isRdHeld#_288: bool;
  var inhaleHeap#_289: HeapType;
  var exhaleMask#_290: MaskType;
  var fraction#_291: int;
  var fraction#_292: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_140;
  assume IsGoodInhaleState(inhaleHeap#_140, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_140[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_140[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_140[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_140, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_140[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_140[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_140, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  205.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_141 := Mask;
  fraction#_142 := 100;
  assert {:msg "  205.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_142 <= exhaleMask#_141[this, AVLTreeNode.valid][perm$R]) && ((fraction#_142 == exhaleMask#_141[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_141[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_141[this, AVLTreeNode.valid] := exhaleMask#_141[this, AVLTreeNode.valid][perm$R := exhaleMask#_141[this, AVLTreeNode.valid][perm$R] - fraction#_142];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_141);
  Mask := exhaleMask#_141;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_143 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_143, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_143[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_143[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_143[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_143[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_143[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_143[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_143[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_143, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_143[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_143[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_143, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#140: int :: (0 <= lk#67#140) && (lk#67#140 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#140) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_143[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_143[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_143[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_143, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_143[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_143[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_143, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#141: int :: (0 <= rk#68#141) && (rk#68#141 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#141)));
  } else {
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  206.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  206.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (Heap[this, AVLTreeNode.key] == k#9) {
    // assigment to r
    r#10 := this;
    // assert
    Heap#_147 := Heap;
    Mask#_148 := Mask;
    Credits#_149 := Credits;
    // begin exhale (assert)
    exhaleMask#_150 := Mask#_148;
    assert {:msg "  208.15: Receiver might be null."} true ==> (this != null);
    assert {:msg "  208.15: Location might not be readable."} true ==> CanRead(Mask#_148, this, AVLTreeNode.key);
    assert {:msg "  208.14: Sequence index might be negative."} true ==> (0 <= 0);
    assert {:msg "  208.14: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(Heap#_147[this, AVLTreeNode.key])));
    assert {:msg "  208.4: Assertion might not hold. The expression at 208.11 might not evaluate to true."} k#9 == Seq#Index(Seq#Singleton(Heap#_147[this, AVLTreeNode.key]), 0);
    Mask#_148 := exhaleMask#_150;
    assume wf(Heap#_147, Mask#_148);
    // end exhale
    // call close
    callHeap#_151 := Heap;
    callMask#_152 := Mask;
    callCredits#_153 := Credits;
    assert {:msg "  209.4: The target of the method call might be null."} r#10 != null;
    this#142 := r#10;
    // begin exhale (precondition)
    exhaleMask#_154 := Mask;
    fraction#_155 := 100;
    assert {:msg "  209.4: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_155 <= exhaleMask#_154[this#142, AVLTreeNode.key][perm$R]) && ((fraction#_155 == exhaleMask#_154[this#142, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_154[this#142, AVLTreeNode.key][perm$N]));
    exhaleMask#_154[this#142, AVLTreeNode.key] := exhaleMask#_154[this#142, AVLTreeNode.key][perm$R := exhaleMask#_154[this#142, AVLTreeNode.key][perm$R] - fraction#_155];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_154);
    fraction#_156 := 100;
    assert {:msg "  209.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_156 <= exhaleMask#_154[this#142, AVLTreeNode.left][perm$R]) && ((fraction#_156 == exhaleMask#_154[this#142, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_154[this#142, AVLTreeNode.left][perm$N]));
    exhaleMask#_154[this#142, AVLTreeNode.left] := exhaleMask#_154[this#142, AVLTreeNode.left][perm$R := exhaleMask#_154[this#142, AVLTreeNode.left][perm$R] - fraction#_156];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_154);
    fraction#_157 := 100;
    assert {:msg "  209.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_157 <= exhaleMask#_154[this#142, AVLTreeNode.right][perm$R]) && ((fraction#_157 == exhaleMask#_154[this#142, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_154[this#142, AVLTreeNode.right][perm$N]));
    exhaleMask#_154[this#142, AVLTreeNode.right] := exhaleMask#_154[this#142, AVLTreeNode.right][perm$R := exhaleMask#_154[this#142, AVLTreeNode.right][perm$R] - fraction#_157];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_154);
    fraction#_158 := 100;
    assert {:msg "  209.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_158 <= exhaleMask#_154[this#142, AVLTreeNode.keys][perm$R]) && ((fraction#_158 == exhaleMask#_154[this#142, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_154[this#142, AVLTreeNode.keys][perm$N]));
    exhaleMask#_154[this#142, AVLTreeNode.keys] := exhaleMask#_154[this#142, AVLTreeNode.keys][perm$R := exhaleMask#_154[this#142, AVLTreeNode.keys][perm$R] - fraction#_158];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_154);
    if (!(Heap[this#142, AVLTreeNode.left] == null)) {
      fraction#_159 := 100;
      assert {:msg "  209.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_159 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_159 == exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_159];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_154);
    } else {
    }
    if (!(Heap[this#142, AVLTreeNode.left] == null)) {
      fraction#_160 := 50;
      assert {:msg "  209.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_160 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_160 == exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_154[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_160];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_154);
    } else {
    }
    if (!(Heap[this#142, AVLTreeNode.left] == null)) {
      assert {:msg "  209.4: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#143: int :: (0 <= k#79#143) && (k#79#143 < Seq#Length(Heap[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#142, AVLTreeNode.left], AVLTreeNode.keys], k#79#143) < Heap[this#142, AVLTreeNode.key]));
    } else {
    }
    if (!(Heap[this#142, AVLTreeNode.right] == null)) {
      fraction#_161 := 100;
      assert {:msg "  209.4: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_161 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_161 == exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_161];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_154);
    } else {
    }
    if (!(Heap[this#142, AVLTreeNode.right] == null)) {
      fraction#_162 := 50;
      assert {:msg "  209.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_162 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_162 == exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_154[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_162];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_154);
    } else {
    }
    if (!(Heap[this#142, AVLTreeNode.right] == null)) {
      assert {:msg "  209.4: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#144: int :: (0 <= k#80#144) && (k#80#144 < Seq#Length(Heap[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#142, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#142, AVLTreeNode.right], AVLTreeNode.keys], k#80#144)));
    } else {
    }
    Mask := exhaleMask#_154;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_165;
    assume IsGoodInhaleState(inhaleHeap#_165, Heap, Mask);
    assume this#142 != null;
    Heap[this#142, AVLTreeNode.valid] := inhaleHeap#_165[this#142, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_165[this#142, AVLTreeNode.valid] == Heap;
    Mask[this#142, AVLTreeNode.valid] := Mask[this#142, AVLTreeNode.valid][perm$R := Mask[this#142, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_165[this#142, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_165, Mask);
    assume this#142 != null;
    Heap[this#142, AVLTreeNode.keys] := inhaleHeap#_165[this#142, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#142, AVLTreeNode.keys] := Mask[this#142, AVLTreeNode.keys][perm$R := Mask[this#142, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_165[this#142, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_165, Mask);
    assume Seq#Equal(Heap[this#142, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_151[this#142, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_151[callHeap#_151[this#142, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_151[this#142, AVLTreeNode.key])), ite(callHeap#_151[this#142, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_151[callHeap#_151[this#142, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
  } else {
    // if
    assert {:msg "  211.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  211.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (k#9 < Heap[this, AVLTreeNode.key]) {
      // local var nl
      // if
      assert {:msg "  213.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  213.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (Heap[this, AVLTreeNode.left] == null) {
        // assigment to nl
        // new
        havoc nw#_166;
        assume (nw#_166 != null) && (dtype(nw#_166) == AVLTreeNode#t);
        assume (forall<T#_1> f: Field (T#_1) :: (Mask[nw#_166, f][perm$R] == 0) && (Mask[nw#_166, f][perm$N] == 0));
        assume Heap[nw#_166, mu] == $LockBottom;
        assume Heap[nw#_166, held] <= 0;
        assume Heap[nw#_166, rdheld] == false;
        Mask[nw#_166, AVLTreeNode.key] := Mask[nw#_166, AVLTreeNode.key][perm$R := Mask[nw#_166, AVLTreeNode.key][perm$R] + 100];
        Mask[nw#_166, AVLTreeNode.left] := Mask[nw#_166, AVLTreeNode.left][perm$R := Mask[nw#_166, AVLTreeNode.left][perm$R] + 100];
        Mask[nw#_166, AVLTreeNode.right] := Mask[nw#_166, AVLTreeNode.right][perm$R := Mask[nw#_166, AVLTreeNode.right][perm$R] + 100];
        Mask[nw#_166, AVLTreeNode.keys] := Mask[nw#_166, AVLTreeNode.keys][perm$R := Mask[nw#_166, AVLTreeNode.keys][perm$R] + 100];
        Mask[nw#_166, mu] := Mask[nw#_166, mu][perm$R := Mask[nw#_166, mu][perm$R] + 100];
        nl#12 := nw#_166;
        // call init
        callHeap#_167 := Heap;
        callMask#_168 := Mask;
        callCredits#_169 := Credits;
        assert {:msg "  215.6: The target of the method call might be null."} nl#12 != null;
        this#145 := nl#12;
        k#146 := k#9;
        // begin exhale (precondition)
        exhaleMask#_170 := Mask;
        fraction#_171 := 100;
        assert {:msg "  215.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (fraction#_171 <= exhaleMask#_170[this#145, AVLTreeNode.key][perm$R]) && ((fraction#_171 == exhaleMask#_170[this#145, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_170[this#145, AVLTreeNode.key][perm$N]));
        exhaleMask#_170[this#145, AVLTreeNode.key] := exhaleMask#_170[this#145, AVLTreeNode.key][perm$R := exhaleMask#_170[this#145, AVLTreeNode.key][perm$R] - fraction#_171];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_170);
        fraction#_172 := 100;
        assert {:msg "  215.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (fraction#_172 <= exhaleMask#_170[this#145, AVLTreeNode.left][perm$R]) && ((fraction#_172 == exhaleMask#_170[this#145, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_170[this#145, AVLTreeNode.left][perm$N]));
        exhaleMask#_170[this#145, AVLTreeNode.left] := exhaleMask#_170[this#145, AVLTreeNode.left][perm$R := exhaleMask#_170[this#145, AVLTreeNode.left][perm$R] - fraction#_172];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_170);
        fraction#_173 := 100;
        assert {:msg "  215.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (fraction#_173 <= exhaleMask#_170[this#145, AVLTreeNode.right][perm$R]) && ((fraction#_173 == exhaleMask#_170[this#145, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_170[this#145, AVLTreeNode.right][perm$N]));
        exhaleMask#_170[this#145, AVLTreeNode.right] := exhaleMask#_170[this#145, AVLTreeNode.right][perm$R := exhaleMask#_170[this#145, AVLTreeNode.right][perm$R] - fraction#_173];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_170);
        fraction#_174 := 100;
        assert {:msg "  215.6: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} (fraction#_174 <= exhaleMask#_170[this#145, AVLTreeNode.keys][perm$R]) && ((fraction#_174 == exhaleMask#_170[this#145, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_170[this#145, AVLTreeNode.keys][perm$N]));
        exhaleMask#_170[this#145, AVLTreeNode.keys] := exhaleMask#_170[this#145, AVLTreeNode.keys][perm$R := exhaleMask#_170[this#145, AVLTreeNode.keys][perm$R] - fraction#_174];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_170);
        Mask := exhaleMask#_170;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_177;
        assume IsGoodInhaleState(inhaleHeap#_177, Heap, Mask);
        assume this#145 != null;
        Heap[this#145, AVLTreeNode.valid] := inhaleHeap#_177[this#145, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_177[this#145, AVLTreeNode.valid] == Heap;
        Mask[this#145, AVLTreeNode.valid] := Mask[this#145, AVLTreeNode.valid][perm$R := Mask[this#145, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_177[this#145, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_177, Mask);
        assume this#145 != null;
        Heap[this#145, AVLTreeNode.keys] := inhaleHeap#_177[this#145, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#145, AVLTreeNode.keys] := Mask[this#145, AVLTreeNode.keys][perm$R := Mask[this#145, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_177[this#145, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_177, Mask);
        assume Seq#Equal(Heap[this#145, AVLTreeNode.keys], Seq#Singleton(k#146));
        assume Seq#Contains(Heap[this#145, AVLTreeNode.keys], k#146);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      } else {
        // call insert
        callHeap#_178 := Heap;
        callMask#_179 := Mask;
        callCredits#_180 := Credits;
        assert {:msg "  217.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  217.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  217.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#147 := Heap[this, AVLTreeNode.left];
        k#148 := k#9;
        // begin exhale (precondition)
        exhaleMask#_181 := Mask;
        fraction#_182 := 100;
        assert {:msg "  217.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (fraction#_182 <= exhaleMask#_181[this#147, AVLTreeNode.valid][perm$R]) && ((fraction#_182 == exhaleMask#_181[this#147, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_181[this#147, AVLTreeNode.valid][perm$N]));
        exhaleMask#_181[this#147, AVLTreeNode.valid] := exhaleMask#_181[this#147, AVLTreeNode.valid][perm$R := exhaleMask#_181[this#147, AVLTreeNode.valid][perm$R] - fraction#_182];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_181);
        fraction#_183 := 50;
        assert {:msg "  217.6: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} (fraction#_183 <= exhaleMask#_181[this#147, AVLTreeNode.keys][perm$R]) && ((fraction#_183 == exhaleMask#_181[this#147, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_181[this#147, AVLTreeNode.keys][perm$N]));
        exhaleMask#_181[this#147, AVLTreeNode.keys] := exhaleMask#_181[this#147, AVLTreeNode.keys][perm$R := exhaleMask#_181[this#147, AVLTreeNode.keys][perm$R] - fraction#_183];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_181);
        Mask := exhaleMask#_181;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#149;
        // inhale (postcondition)
        havoc inhaleHeap#_186;
        assume IsGoodInhaleState(inhaleHeap#_186, Heap, Mask);
        assume !(r#149 == null);
        assume r#149 != null;
        Heap[r#149, AVLTreeNode.valid] := inhaleHeap#_186[r#149, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_186[r#149, AVLTreeNode.valid] == Heap;
        Mask[r#149, AVLTreeNode.valid] := Mask[r#149, AVLTreeNode.valid][perm$R := Mask[r#149, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_186[r#149, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_186, Mask);
        assume r#149 != null;
        Heap[r#149, AVLTreeNode.keys] := inhaleHeap#_186[r#149, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#149, AVLTreeNode.keys] := Mask[r#149, AVLTreeNode.keys][perm$R := Mask[r#149, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_186[r#149, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_186, Mask);
        assume Seq#Contains(Heap[r#149, AVLTreeNode.keys], k#148);
        assume (forall i#70#150: int :: (0 <= i#70#150) && (i#70#150 < Seq#Length(old(Heap)[this#147, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#149, AVLTreeNode.keys], Seq#Index(callHeap#_178[this#147, AVLTreeNode.keys], i#70#150)));
        assume (forall i#71#151: int :: (0 <= i#71#151) && (i#71#151 < Seq#Length(Heap[r#149, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_178[this#147, AVLTreeNode.keys], Seq#Index(Heap[r#149, AVLTreeNode.keys], i#71#151)) || (Seq#Index(Heap[r#149, AVLTreeNode.keys], i#71#151) == k#148)));
        if (Seq#Contains(callHeap#_178[this#147, AVLTreeNode.keys], k#148)) {
          assume Seq#Equal(Heap[r#149, AVLTreeNode.keys], callHeap#_178[this#147, AVLTreeNode.keys]);
        } else {
        }
        if (!Seq#Contains(callHeap#_178[this#147, AVLTreeNode.keys], k#148)) {
          assume Seq#Length(Heap[r#149, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this#147, AVLTreeNode.keys]) + 1);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nl#12 := r#149;
      }
      // update field left
      assert {:msg "  219.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
      Heap[this, AVLTreeNode.left] := nl#12;
      assume wf(Heap, Mask);
      // local var bf
      // call getBalanceFactorI
      callHeap#_187 := Heap;
      callMask#_188 := Mask;
      callCredits#_189 := Credits;
      assert {:msg "  221.5: The target of the method call might be null."} this != null;
      this#152 := this;
      // begin exhale (precondition)
      exhaleMask#_190 := Mask;
      epsilons#_191 := 1;
      assert {:msg "  221.5: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_190[this#152, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_191 <= exhaleMask#_190[this#152, AVLTreeNode.left][perm$N]);
      if ((exhaleMask#_190[this#152, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_190[this#152, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_190[this#152, AVLTreeNode.left] := exhaleMask#_190[this#152, AVLTreeNode.left][perm$N := exhaleMask#_190[this#152, AVLTreeNode.left][perm$N] - epsilons#_191];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_190);
      if (!(Heap[this#152, AVLTreeNode.left] == null)) {
        fraction#_192 := 100;
        assert {:msg "  221.5: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_192 <= exhaleMask#_190[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_192 == exhaleMask#_190[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_190[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_190[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_190[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_190[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_192];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_190);
      } else {
      }
      epsilons#_193 := 1;
      assert {:msg "  221.5: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_190[this#152, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_193 <= exhaleMask#_190[this#152, AVLTreeNode.right][perm$N]);
      if ((exhaleMask#_190[this#152, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_190[this#152, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_190[this#152, AVLTreeNode.right] := exhaleMask#_190[this#152, AVLTreeNode.right][perm$N := exhaleMask#_190[this#152, AVLTreeNode.right][perm$N] - epsilons#_193];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_190);
      if (!(Heap[this#152, AVLTreeNode.right] == null)) {
        fraction#_194 := 100;
        assert {:msg "  221.5: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_194 <= exhaleMask#_190[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_194 == exhaleMask#_190[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_190[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_190[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_190[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_190[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_194];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_190);
      } else {
      }
      Mask := exhaleMask#_190;
      assume wf(Heap, Mask);
      // end exhale
      havoc bf#153;
      // inhale (postcondition)
      havoc inhaleHeap#_197;
      assume IsGoodInhaleState(inhaleHeap#_197, Heap, Mask);
      assume this#152 != null;
      Heap[this#152, AVLTreeNode.left] := inhaleHeap#_197[this#152, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[this#152, AVLTreeNode.left] == null) || (dtype(Heap[this#152, AVLTreeNode.left]) == AVLTreeNode#t);
      if ((Mask[this#152, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#152, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        Mask[this#152, AVLTreeNode.left] := Mask[this#152, AVLTreeNode.left][perm$N := Mask[this#152, AVLTreeNode.left][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_197[this#152, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_197, Mask);
      if (!(Heap[this#152, AVLTreeNode.left] == null)) {
        assume Heap[this#152, AVLTreeNode.left] != null;
        Heap[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_197[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_197[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_197[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_197, Mask);
      } else {
      }
      assume this#152 != null;
      Heap[this#152, AVLTreeNode.right] := inhaleHeap#_197[this#152, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[this#152, AVLTreeNode.right] == null) || (dtype(Heap[this#152, AVLTreeNode.right]) == AVLTreeNode#t);
      if ((Mask[this#152, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#152, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        Mask[this#152, AVLTreeNode.right] := Mask[this#152, AVLTreeNode.right][perm$N := Mask[this#152, AVLTreeNode.right][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_197[this#152, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_197, Mask);
      if (!(Heap[this#152, AVLTreeNode.right] == null)) {
        assume Heap[this#152, AVLTreeNode.right] != null;
        Heap[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_197[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_197[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_197[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_197, Mask);
      } else {
      }
      if (bf#153 > 0) {
        assume !(Heap[this#152, AVLTreeNode.left] == null);
      } else {
      }
      if (bf#153 < 0) {
        assume !(Heap[this#152, AVLTreeNode.right] == null);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      bf#14 := bf#153;
      // if
      if (bf#14 == 2) {
        // call rebalanceLeft
        callHeap#_198 := Heap;
        callMask#_199 := Mask;
        callCredits#_200 := Credits;
        assert {:msg "  224.6: The target of the method call might be null."} this != null;
        this#154 := this;
        // begin exhale (precondition)
        exhaleMask#_201 := Mask;
        fraction#_202 := 100;
        assert {:msg "  224.6: The precondition at 598.12 might not hold. Insufficient fraction at 598.12 for AVLTreeNode.key."} (fraction#_202 <= exhaleMask#_201[this#154, AVLTreeNode.key][perm$R]) && ((fraction#_202 == exhaleMask#_201[this#154, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_201[this#154, AVLTreeNode.key][perm$N]));
        exhaleMask#_201[this#154, AVLTreeNode.key] := exhaleMask#_201[this#154, AVLTreeNode.key][perm$R := exhaleMask#_201[this#154, AVLTreeNode.key][perm$R] - fraction#_202];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_201);
        fraction#_203 := 100;
        assert {:msg "  224.6: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.left."} (fraction#_203 <= exhaleMask#_201[this#154, AVLTreeNode.left][perm$R]) && ((fraction#_203 == exhaleMask#_201[this#154, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_201[this#154, AVLTreeNode.left][perm$N]));
        exhaleMask#_201[this#154, AVLTreeNode.left] := exhaleMask#_201[this#154, AVLTreeNode.left][perm$R := exhaleMask#_201[this#154, AVLTreeNode.left][perm$R] - fraction#_203];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_201);
        fraction#_204 := 100;
        assert {:msg "  224.6: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.right."} (fraction#_204 <= exhaleMask#_201[this#154, AVLTreeNode.right][perm$R]) && ((fraction#_204 == exhaleMask#_201[this#154, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_201[this#154, AVLTreeNode.right][perm$N]));
        exhaleMask#_201[this#154, AVLTreeNode.right] := exhaleMask#_201[this#154, AVLTreeNode.right][perm$R := exhaleMask#_201[this#154, AVLTreeNode.right][perm$R] - fraction#_204];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_201);
        fraction#_205 := 100;
        assert {:msg "  224.6: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.keys."} (fraction#_205 <= exhaleMask#_201[this#154, AVLTreeNode.keys][perm$R]) && ((fraction#_205 == exhaleMask#_201[this#154, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_201[this#154, AVLTreeNode.keys][perm$N]));
        exhaleMask#_201[this#154, AVLTreeNode.keys] := exhaleMask#_201[this#154, AVLTreeNode.keys][perm$R := exhaleMask#_201[this#154, AVLTreeNode.keys][perm$R] - fraction#_205];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_201);
        assert {:msg "  224.6: The precondition at 606.12 might not hold. The expression at 606.12 might not evaluate to true."} !(Heap[this#154, AVLTreeNode.left] == null);
        fraction#_206 := 100;
        assert {:msg "  224.6: The precondition at 607.12 might not hold. Insufficient fraction at 607.12 for AVLTreeNode.valid."} (fraction#_206 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_206 == exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_206];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_201);
        fraction#_207 := 50;
        assert {:msg "  224.6: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.keys."} (fraction#_207 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_207 == exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_201[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_207];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_201);
        assert {:msg "  224.6: The precondition at 611.12 might not hold. The expression at 611.12 might not evaluate to true."} (forall k#81#156: int :: (0 <= k#81#156) && (k#81#156 < Seq#Length(Heap[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#154, AVLTreeNode.left], AVLTreeNode.keys], k#81#156) < Heap[this#154, AVLTreeNode.key]));
        if (!(Heap[this#154, AVLTreeNode.right] == null)) {
          fraction#_208 := 100;
          assert {:msg "  224.6: The precondition at 613.12 might not hold. Insufficient fraction at 613.28 for AVLTreeNode.valid."} (fraction#_208 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_208 == exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_208];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_201);
        } else {
        }
        if (!(Heap[this#154, AVLTreeNode.right] == null)) {
          fraction#_209 := 50;
          assert {:msg "  224.6: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.keys."} (fraction#_209 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_209 == exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_201[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_209];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_201);
        } else {
        }
        if (!(Heap[this#154, AVLTreeNode.right] == null)) {
          assert {:msg "  224.6: The precondition at 617.12 might not hold. The expression at 617.28 might not evaluate to true."} (forall k#82#157: int :: (0 <= k#82#157) && (k#82#157 < Seq#Length(Heap[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#154, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#154, AVLTreeNode.right], AVLTreeNode.keys], k#82#157)));
        } else {
        }
        Mask := exhaleMask#_201;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#155;
        // inhale (postcondition)
        havoc inhaleHeap#_212;
        assume IsGoodInhaleState(inhaleHeap#_212, Heap, Mask);
        assume r#155 != null;
        Heap[r#155, AVLTreeNode.valid] := inhaleHeap#_212[r#155, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_212[r#155, AVLTreeNode.valid] == Heap;
        Mask[r#155, AVLTreeNode.valid] := Mask[r#155, AVLTreeNode.valid][perm$R := Mask[r#155, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_212[r#155, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_212, Mask);
        assume r#155 != null;
        Heap[r#155, AVLTreeNode.keys] := inhaleHeap#_212[r#155, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#155, AVLTreeNode.keys] := Mask[r#155, AVLTreeNode.keys][perm$R := Mask[r#155, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_212[r#155, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_212, Mask);
        assume Seq#Equal(Heap[r#155, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_198[callHeap#_198[this#154, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_198[this#154, AVLTreeNode.key])), ite(callHeap#_198[this#154, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_198[callHeap#_198[this#154, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        r#10 := r#155;
      } else {
        // assigment to r
        r#10 := this;
        // call close
        callHeap#_213 := Heap;
        callMask#_214 := Mask;
        callCredits#_215 := Credits;
        assert {:msg "  227.6: The target of the method call might be null."} r#10 != null;
        this#158 := r#10;
        // begin exhale (precondition)
        exhaleMask#_216 := Mask;
        fraction#_217 := 100;
        assert {:msg "  227.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_217 <= exhaleMask#_216[this#158, AVLTreeNode.key][perm$R]) && ((fraction#_217 == exhaleMask#_216[this#158, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_216[this#158, AVLTreeNode.key][perm$N]));
        exhaleMask#_216[this#158, AVLTreeNode.key] := exhaleMask#_216[this#158, AVLTreeNode.key][perm$R := exhaleMask#_216[this#158, AVLTreeNode.key][perm$R] - fraction#_217];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_216);
        fraction#_218 := 100;
        assert {:msg "  227.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_218 <= exhaleMask#_216[this#158, AVLTreeNode.left][perm$R]) && ((fraction#_218 == exhaleMask#_216[this#158, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_216[this#158, AVLTreeNode.left][perm$N]));
        exhaleMask#_216[this#158, AVLTreeNode.left] := exhaleMask#_216[this#158, AVLTreeNode.left][perm$R := exhaleMask#_216[this#158, AVLTreeNode.left][perm$R] - fraction#_218];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_216);
        fraction#_219 := 100;
        assert {:msg "  227.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_219 <= exhaleMask#_216[this#158, AVLTreeNode.right][perm$R]) && ((fraction#_219 == exhaleMask#_216[this#158, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_216[this#158, AVLTreeNode.right][perm$N]));
        exhaleMask#_216[this#158, AVLTreeNode.right] := exhaleMask#_216[this#158, AVLTreeNode.right][perm$R := exhaleMask#_216[this#158, AVLTreeNode.right][perm$R] - fraction#_219];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_216);
        fraction#_220 := 100;
        assert {:msg "  227.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_220 <= exhaleMask#_216[this#158, AVLTreeNode.keys][perm$R]) && ((fraction#_220 == exhaleMask#_216[this#158, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_216[this#158, AVLTreeNode.keys][perm$N]));
        exhaleMask#_216[this#158, AVLTreeNode.keys] := exhaleMask#_216[this#158, AVLTreeNode.keys][perm$R := exhaleMask#_216[this#158, AVLTreeNode.keys][perm$R] - fraction#_220];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_216);
        if (!(Heap[this#158, AVLTreeNode.left] == null)) {
          fraction#_221 := 100;
          assert {:msg "  227.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_221 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_221 == exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_221];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_216);
        } else {
        }
        if (!(Heap[this#158, AVLTreeNode.left] == null)) {
          fraction#_222 := 50;
          assert {:msg "  227.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_222 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_222 == exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_216[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_222];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_216);
        } else {
        }
        if (!(Heap[this#158, AVLTreeNode.left] == null)) {
          assert {:msg "  227.6: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#159: int :: (0 <= k#79#159) && (k#79#159 < Seq#Length(Heap[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#158, AVLTreeNode.left], AVLTreeNode.keys], k#79#159) < Heap[this#158, AVLTreeNode.key]));
        } else {
        }
        if (!(Heap[this#158, AVLTreeNode.right] == null)) {
          fraction#_223 := 100;
          assert {:msg "  227.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_223 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_223 == exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_223];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_216);
        } else {
        }
        if (!(Heap[this#158, AVLTreeNode.right] == null)) {
          fraction#_224 := 50;
          assert {:msg "  227.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_224 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_224 == exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_216[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_224];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_216);
        } else {
        }
        if (!(Heap[this#158, AVLTreeNode.right] == null)) {
          assert {:msg "  227.6: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#160: int :: (0 <= k#80#160) && (k#80#160 < Seq#Length(Heap[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#158, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#158, AVLTreeNode.right], AVLTreeNode.keys], k#80#160)));
        } else {
        }
        Mask := exhaleMask#_216;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_227;
        assume IsGoodInhaleState(inhaleHeap#_227, Heap, Mask);
        assume this#158 != null;
        Heap[this#158, AVLTreeNode.valid] := inhaleHeap#_227[this#158, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_227[this#158, AVLTreeNode.valid] == Heap;
        Mask[this#158, AVLTreeNode.valid] := Mask[this#158, AVLTreeNode.valid][perm$R := Mask[this#158, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_227[this#158, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_227, Mask);
        assume this#158 != null;
        Heap[this#158, AVLTreeNode.keys] := inhaleHeap#_227[this#158, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#158, AVLTreeNode.keys] := Mask[this#158, AVLTreeNode.keys][perm$R := Mask[this#158, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_227[this#158, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_227, Mask);
        assume Seq#Equal(Heap[this#158, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_213[this#158, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_213[callHeap#_213[this#158, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_213[this#158, AVLTreeNode.key])), ite(callHeap#_213[this#158, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_213[callHeap#_213[this#158, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    } else {
      // local var nr
      // if
      assert {:msg "  231.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  231.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (Heap[this, AVLTreeNode.right] == null) {
        // assigment to nr
        // new
        havoc nw#_228;
        assume (nw#_228 != null) && (dtype(nw#_228) == AVLTreeNode#t);
        assume (forall<T#_2> f: Field (T#_2) :: (Mask[nw#_228, f][perm$R] == 0) && (Mask[nw#_228, f][perm$N] == 0));
        assume Heap[nw#_228, mu] == $LockBottom;
        assume Heap[nw#_228, held] <= 0;
        assume Heap[nw#_228, rdheld] == false;
        Mask[nw#_228, AVLTreeNode.key] := Mask[nw#_228, AVLTreeNode.key][perm$R := Mask[nw#_228, AVLTreeNode.key][perm$R] + 100];
        Mask[nw#_228, AVLTreeNode.left] := Mask[nw#_228, AVLTreeNode.left][perm$R := Mask[nw#_228, AVLTreeNode.left][perm$R] + 100];
        Mask[nw#_228, AVLTreeNode.right] := Mask[nw#_228, AVLTreeNode.right][perm$R := Mask[nw#_228, AVLTreeNode.right][perm$R] + 100];
        Mask[nw#_228, AVLTreeNode.keys] := Mask[nw#_228, AVLTreeNode.keys][perm$R := Mask[nw#_228, AVLTreeNode.keys][perm$R] + 100];
        Mask[nw#_228, mu] := Mask[nw#_228, mu][perm$R := Mask[nw#_228, mu][perm$R] + 100];
        nr#16 := nw#_228;
        // call init
        callHeap#_229 := Heap;
        callMask#_230 := Mask;
        callCredits#_231 := Credits;
        assert {:msg "  233.6: The target of the method call might be null."} nr#16 != null;
        this#161 := nr#16;
        k#162 := k#9;
        // begin exhale (precondition)
        exhaleMask#_232 := Mask;
        fraction#_233 := 100;
        assert {:msg "  233.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (fraction#_233 <= exhaleMask#_232[this#161, AVLTreeNode.key][perm$R]) && ((fraction#_233 == exhaleMask#_232[this#161, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_232[this#161, AVLTreeNode.key][perm$N]));
        exhaleMask#_232[this#161, AVLTreeNode.key] := exhaleMask#_232[this#161, AVLTreeNode.key][perm$R := exhaleMask#_232[this#161, AVLTreeNode.key][perm$R] - fraction#_233];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_232);
        fraction#_234 := 100;
        assert {:msg "  233.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (fraction#_234 <= exhaleMask#_232[this#161, AVLTreeNode.left][perm$R]) && ((fraction#_234 == exhaleMask#_232[this#161, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_232[this#161, AVLTreeNode.left][perm$N]));
        exhaleMask#_232[this#161, AVLTreeNode.left] := exhaleMask#_232[this#161, AVLTreeNode.left][perm$R := exhaleMask#_232[this#161, AVLTreeNode.left][perm$R] - fraction#_234];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_232);
        fraction#_235 := 100;
        assert {:msg "  233.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (fraction#_235 <= exhaleMask#_232[this#161, AVLTreeNode.right][perm$R]) && ((fraction#_235 == exhaleMask#_232[this#161, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_232[this#161, AVLTreeNode.right][perm$N]));
        exhaleMask#_232[this#161, AVLTreeNode.right] := exhaleMask#_232[this#161, AVLTreeNode.right][perm$R := exhaleMask#_232[this#161, AVLTreeNode.right][perm$R] - fraction#_235];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_232);
        fraction#_236 := 100;
        assert {:msg "  233.6: The precondition at 160.12 might not hold. Insufficient fraction at 160.12 for AVLTreeNode.keys."} (fraction#_236 <= exhaleMask#_232[this#161, AVLTreeNode.keys][perm$R]) && ((fraction#_236 == exhaleMask#_232[this#161, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_232[this#161, AVLTreeNode.keys][perm$N]));
        exhaleMask#_232[this#161, AVLTreeNode.keys] := exhaleMask#_232[this#161, AVLTreeNode.keys][perm$R := exhaleMask#_232[this#161, AVLTreeNode.keys][perm$R] - fraction#_236];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_232);
        Mask := exhaleMask#_232;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_239;
        assume IsGoodInhaleState(inhaleHeap#_239, Heap, Mask);
        assume this#161 != null;
        Heap[this#161, AVLTreeNode.valid] := inhaleHeap#_239[this#161, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_239[this#161, AVLTreeNode.valid] == Heap;
        Mask[this#161, AVLTreeNode.valid] := Mask[this#161, AVLTreeNode.valid][perm$R := Mask[this#161, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_239[this#161, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_239, Mask);
        assume this#161 != null;
        Heap[this#161, AVLTreeNode.keys] := inhaleHeap#_239[this#161, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#161, AVLTreeNode.keys] := Mask[this#161, AVLTreeNode.keys][perm$R := Mask[this#161, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_239[this#161, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_239, Mask);
        assume Seq#Equal(Heap[this#161, AVLTreeNode.keys], Seq#Singleton(k#162));
        assume Seq#Contains(Heap[this#161, AVLTreeNode.keys], k#162);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      } else {
        // call insert
        callHeap#_240 := Heap;
        callMask#_241 := Mask;
        callCredits#_242 := Credits;
        assert {:msg "  235.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  235.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  235.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#163 := Heap[this, AVLTreeNode.right];
        k#164 := k#9;
        // begin exhale (precondition)
        exhaleMask#_243 := Mask;
        fraction#_244 := 100;
        assert {:msg "  235.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (fraction#_244 <= exhaleMask#_243[this#163, AVLTreeNode.valid][perm$R]) && ((fraction#_244 == exhaleMask#_243[this#163, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_243[this#163, AVLTreeNode.valid][perm$N]));
        exhaleMask#_243[this#163, AVLTreeNode.valid] := exhaleMask#_243[this#163, AVLTreeNode.valid][perm$R := exhaleMask#_243[this#163, AVLTreeNode.valid][perm$R] - fraction#_244];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_243);
        fraction#_245 := 50;
        assert {:msg "  235.6: The precondition at 186.12 might not hold. Insufficient fraction at 186.12 for AVLTreeNode.keys."} (fraction#_245 <= exhaleMask#_243[this#163, AVLTreeNode.keys][perm$R]) && ((fraction#_245 == exhaleMask#_243[this#163, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_243[this#163, AVLTreeNode.keys][perm$N]));
        exhaleMask#_243[this#163, AVLTreeNode.keys] := exhaleMask#_243[this#163, AVLTreeNode.keys][perm$R := exhaleMask#_243[this#163, AVLTreeNode.keys][perm$R] - fraction#_245];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_243);
        Mask := exhaleMask#_243;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#165;
        // inhale (postcondition)
        havoc inhaleHeap#_248;
        assume IsGoodInhaleState(inhaleHeap#_248, Heap, Mask);
        assume !(r#165 == null);
        assume r#165 != null;
        Heap[r#165, AVLTreeNode.valid] := inhaleHeap#_248[r#165, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_248[r#165, AVLTreeNode.valid] == Heap;
        Mask[r#165, AVLTreeNode.valid] := Mask[r#165, AVLTreeNode.valid][perm$R := Mask[r#165, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_248[r#165, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_248, Mask);
        assume r#165 != null;
        Heap[r#165, AVLTreeNode.keys] := inhaleHeap#_248[r#165, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#165, AVLTreeNode.keys] := Mask[r#165, AVLTreeNode.keys][perm$R := Mask[r#165, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_248[r#165, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_248, Mask);
        assume Seq#Contains(Heap[r#165, AVLTreeNode.keys], k#164);
        assume (forall i#70#166: int :: (0 <= i#70#166) && (i#70#166 < Seq#Length(old(Heap)[this#163, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#165, AVLTreeNode.keys], Seq#Index(callHeap#_240[this#163, AVLTreeNode.keys], i#70#166)));
        assume (forall i#71#167: int :: (0 <= i#71#167) && (i#71#167 < Seq#Length(Heap[r#165, AVLTreeNode.keys])) ==> (Seq#Contains(callHeap#_240[this#163, AVLTreeNode.keys], Seq#Index(Heap[r#165, AVLTreeNode.keys], i#71#167)) || (Seq#Index(Heap[r#165, AVLTreeNode.keys], i#71#167) == k#164)));
        if (Seq#Contains(callHeap#_240[this#163, AVLTreeNode.keys], k#164)) {
          assume Seq#Equal(Heap[r#165, AVLTreeNode.keys], callHeap#_240[this#163, AVLTreeNode.keys]);
        } else {
        }
        if (!Seq#Contains(callHeap#_240[this#163, AVLTreeNode.keys], k#164)) {
          assume Seq#Length(Heap[r#165, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this#163, AVLTreeNode.keys]) + 1);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nr#16 := r#165;
      }
      // update field right
      assert {:msg "  237.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
      Heap[this, AVLTreeNode.right] := nr#16;
      assume wf(Heap, Mask);
      // local var bf
      // call getBalanceFactorI
      callHeap#_249 := Heap;
      callMask#_250 := Mask;
      callCredits#_251 := Credits;
      assert {:msg "  240.5: The target of the method call might be null."} this != null;
      this#168 := this;
      // begin exhale (precondition)
      exhaleMask#_252 := Mask;
      epsilons#_253 := 1;
      assert {:msg "  240.5: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_252[this#168, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_253 <= exhaleMask#_252[this#168, AVLTreeNode.left][perm$N]);
      if ((exhaleMask#_252[this#168, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_252[this#168, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_252[this#168, AVLTreeNode.left] := exhaleMask#_252[this#168, AVLTreeNode.left][perm$N := exhaleMask#_252[this#168, AVLTreeNode.left][perm$N] - epsilons#_253];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_252);
      if (!(Heap[this#168, AVLTreeNode.left] == null)) {
        fraction#_254 := 100;
        assert {:msg "  240.5: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_254 <= exhaleMask#_252[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_254 == exhaleMask#_252[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_252[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_252[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_252[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_252[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_254];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_252);
      } else {
      }
      epsilons#_255 := 1;
      assert {:msg "  240.5: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_252[this#168, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_255 <= exhaleMask#_252[this#168, AVLTreeNode.right][perm$N]);
      if ((exhaleMask#_252[this#168, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_252[this#168, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_252[this#168, AVLTreeNode.right] := exhaleMask#_252[this#168, AVLTreeNode.right][perm$N := exhaleMask#_252[this#168, AVLTreeNode.right][perm$N] - epsilons#_255];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_252);
      if (!(Heap[this#168, AVLTreeNode.right] == null)) {
        fraction#_256 := 100;
        assert {:msg "  240.5: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_256 <= exhaleMask#_252[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_256 == exhaleMask#_252[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_252[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_252[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_252[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_252[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_256];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_252);
      } else {
      }
      Mask := exhaleMask#_252;
      assume wf(Heap, Mask);
      // end exhale
      havoc bf#169;
      // inhale (postcondition)
      havoc inhaleHeap#_259;
      assume IsGoodInhaleState(inhaleHeap#_259, Heap, Mask);
      assume this#168 != null;
      Heap[this#168, AVLTreeNode.left] := inhaleHeap#_259[this#168, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[this#168, AVLTreeNode.left] == null) || (dtype(Heap[this#168, AVLTreeNode.left]) == AVLTreeNode#t);
      if ((Mask[this#168, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#168, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        Mask[this#168, AVLTreeNode.left] := Mask[this#168, AVLTreeNode.left][perm$N := Mask[this#168, AVLTreeNode.left][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_259[this#168, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_259, Mask);
      if (!(Heap[this#168, AVLTreeNode.left] == null)) {
        assume Heap[this#168, AVLTreeNode.left] != null;
        Heap[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_259[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_259[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_259[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_259, Mask);
      } else {
      }
      assume this#168 != null;
      Heap[this#168, AVLTreeNode.right] := inhaleHeap#_259[this#168, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[this#168, AVLTreeNode.right] == null) || (dtype(Heap[this#168, AVLTreeNode.right]) == AVLTreeNode#t);
      if ((Mask[this#168, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#168, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        Mask[this#168, AVLTreeNode.right] := Mask[this#168, AVLTreeNode.right][perm$N := Mask[this#168, AVLTreeNode.right][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_259[this#168, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_259, Mask);
      if (!(Heap[this#168, AVLTreeNode.right] == null)) {
        assume Heap[this#168, AVLTreeNode.right] != null;
        Heap[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_259[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_259[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_259[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_259, Mask);
      } else {
      }
      if (bf#169 > 0) {
        assume !(Heap[this#168, AVLTreeNode.left] == null);
      } else {
      }
      if (bf#169 < 0) {
        assume !(Heap[this#168, AVLTreeNode.right] == null);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      bf#18 := bf#169;
      // if
      if (bf#18 == (0 - 2)) {
        // call rebalanceRight
        callHeap#_260 := Heap;
        callMask#_261 := Mask;
        callCredits#_262 := Credits;
        assert {:msg "  242.6: The target of the method call might be null."} this != null;
        this#170 := this;
        // begin exhale (precondition)
        exhaleMask#_263 := Mask;
        fraction#_264 := 100;
        assert {:msg "  242.6: The precondition at 741.12 might not hold. Insufficient fraction at 741.12 for AVLTreeNode.key."} (fraction#_264 <= exhaleMask#_263[this#170, AVLTreeNode.key][perm$R]) && ((fraction#_264 == exhaleMask#_263[this#170, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_263[this#170, AVLTreeNode.key][perm$N]));
        exhaleMask#_263[this#170, AVLTreeNode.key] := exhaleMask#_263[this#170, AVLTreeNode.key][perm$R := exhaleMask#_263[this#170, AVLTreeNode.key][perm$R] - fraction#_264];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_263);
        fraction#_265 := 100;
        assert {:msg "  242.6: The precondition at 743.12 might not hold. Insufficient fraction at 743.12 for AVLTreeNode.left."} (fraction#_265 <= exhaleMask#_263[this#170, AVLTreeNode.left][perm$R]) && ((fraction#_265 == exhaleMask#_263[this#170, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_263[this#170, AVLTreeNode.left][perm$N]));
        exhaleMask#_263[this#170, AVLTreeNode.left] := exhaleMask#_263[this#170, AVLTreeNode.left][perm$R := exhaleMask#_263[this#170, AVLTreeNode.left][perm$R] - fraction#_265];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_263);
        fraction#_266 := 100;
        assert {:msg "  242.6: The precondition at 744.12 might not hold. Insufficient fraction at 744.12 for AVLTreeNode.right."} (fraction#_266 <= exhaleMask#_263[this#170, AVLTreeNode.right][perm$R]) && ((fraction#_266 == exhaleMask#_263[this#170, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_263[this#170, AVLTreeNode.right][perm$N]));
        exhaleMask#_263[this#170, AVLTreeNode.right] := exhaleMask#_263[this#170, AVLTreeNode.right][perm$R := exhaleMask#_263[this#170, AVLTreeNode.right][perm$R] - fraction#_266];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_263);
        fraction#_267 := 100;
        assert {:msg "  242.6: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.keys."} (fraction#_267 <= exhaleMask#_263[this#170, AVLTreeNode.keys][perm$R]) && ((fraction#_267 == exhaleMask#_263[this#170, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_263[this#170, AVLTreeNode.keys][perm$N]));
        exhaleMask#_263[this#170, AVLTreeNode.keys] := exhaleMask#_263[this#170, AVLTreeNode.keys][perm$R := exhaleMask#_263[this#170, AVLTreeNode.keys][perm$R] - fraction#_267];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_263);
        if (!(Heap[this#170, AVLTreeNode.left] == null)) {
          fraction#_268 := 100;
          assert {:msg "  242.6: The precondition at 749.12 might not hold. Insufficient fraction at 749.25 for AVLTreeNode.valid."} (fraction#_268 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_268 == exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_268];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_263);
        } else {
        }
        if (!(Heap[this#170, AVLTreeNode.left] == null)) {
          fraction#_269 := 50;
          assert {:msg "  242.6: The precondition at 751.12 might not hold. Insufficient fraction at 751.25 for AVLTreeNode.keys."} (fraction#_269 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_269 == exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_263[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_269];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_263);
        } else {
        }
        if (!(Heap[this#170, AVLTreeNode.left] == null)) {
          assert {:msg "  242.6: The precondition at 753.12 might not hold. The expression at 753.25 might not evaluate to true."} (forall k#91#172: int :: (0 <= k#91#172) && (k#91#172 < Seq#Length(Heap[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#170, AVLTreeNode.left], AVLTreeNode.keys], k#91#172) < Heap[this#170, AVLTreeNode.key]));
        } else {
        }
        assert {:msg "  242.6: The precondition at 755.12 might not hold. The expression at 755.12 might not evaluate to true."} !(Heap[this#170, AVLTreeNode.right] == null);
        fraction#_270 := 100;
        assert {:msg "  242.6: The precondition at 756.12 might not hold. Insufficient fraction at 756.12 for AVLTreeNode.valid."} (fraction#_270 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_270 == exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_270];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_263);
        fraction#_271 := 50;
        assert {:msg "  242.6: The precondition at 758.12 might not hold. Insufficient fraction at 758.12 for AVLTreeNode.keys."} (fraction#_271 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_271 == exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_263[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_271];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_263);
        assert {:msg "  242.6: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} (forall k#92#173: int :: (0 <= k#92#173) && (k#92#173 < Seq#Length(Heap[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#170, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#170, AVLTreeNode.right], AVLTreeNode.keys], k#92#173)));
        Mask := exhaleMask#_263;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#171;
        // inhale (postcondition)
        havoc inhaleHeap#_274;
        assume IsGoodInhaleState(inhaleHeap#_274, Heap, Mask);
        assume r#171 != null;
        Heap[r#171, AVLTreeNode.valid] := inhaleHeap#_274[r#171, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_274[r#171, AVLTreeNode.valid] == Heap;
        Mask[r#171, AVLTreeNode.valid] := Mask[r#171, AVLTreeNode.valid][perm$R := Mask[r#171, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_274[r#171, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_274, Mask);
        assume r#171 != null;
        Heap[r#171, AVLTreeNode.keys] := inhaleHeap#_274[r#171, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#171, AVLTreeNode.keys] := Mask[r#171, AVLTreeNode.keys][perm$R := Mask[r#171, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_274[r#171, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_274, Mask);
        assume Seq#Equal(Heap[r#171, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_260[this#170, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_260[callHeap#_260[this#170, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_260[this#170, AVLTreeNode.key])), callHeap#_260[callHeap#_260[this#170, AVLTreeNode.right], AVLTreeNode.keys]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        r#10 := r#171;
      } else {
        // assigment to r
        r#10 := this;
        // call close
        callHeap#_275 := Heap;
        callMask#_276 := Mask;
        callCredits#_277 := Credits;
        assert {:msg "  245.6: The target of the method call might be null."} r#10 != null;
        this#174 := r#10;
        // begin exhale (precondition)
        exhaleMask#_278 := Mask;
        fraction#_279 := 100;
        assert {:msg "  245.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_279 <= exhaleMask#_278[this#174, AVLTreeNode.key][perm$R]) && ((fraction#_279 == exhaleMask#_278[this#174, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_278[this#174, AVLTreeNode.key][perm$N]));
        exhaleMask#_278[this#174, AVLTreeNode.key] := exhaleMask#_278[this#174, AVLTreeNode.key][perm$R := exhaleMask#_278[this#174, AVLTreeNode.key][perm$R] - fraction#_279];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_278);
        fraction#_280 := 100;
        assert {:msg "  245.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_280 <= exhaleMask#_278[this#174, AVLTreeNode.left][perm$R]) && ((fraction#_280 == exhaleMask#_278[this#174, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_278[this#174, AVLTreeNode.left][perm$N]));
        exhaleMask#_278[this#174, AVLTreeNode.left] := exhaleMask#_278[this#174, AVLTreeNode.left][perm$R := exhaleMask#_278[this#174, AVLTreeNode.left][perm$R] - fraction#_280];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_278);
        fraction#_281 := 100;
        assert {:msg "  245.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_281 <= exhaleMask#_278[this#174, AVLTreeNode.right][perm$R]) && ((fraction#_281 == exhaleMask#_278[this#174, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_278[this#174, AVLTreeNode.right][perm$N]));
        exhaleMask#_278[this#174, AVLTreeNode.right] := exhaleMask#_278[this#174, AVLTreeNode.right][perm$R := exhaleMask#_278[this#174, AVLTreeNode.right][perm$R] - fraction#_281];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_278);
        fraction#_282 := 100;
        assert {:msg "  245.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_282 <= exhaleMask#_278[this#174, AVLTreeNode.keys][perm$R]) && ((fraction#_282 == exhaleMask#_278[this#174, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_278[this#174, AVLTreeNode.keys][perm$N]));
        exhaleMask#_278[this#174, AVLTreeNode.keys] := exhaleMask#_278[this#174, AVLTreeNode.keys][perm$R := exhaleMask#_278[this#174, AVLTreeNode.keys][perm$R] - fraction#_282];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_278);
        if (!(Heap[this#174, AVLTreeNode.left] == null)) {
          fraction#_283 := 100;
          assert {:msg "  245.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_283 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_283 == exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_283];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_278);
        } else {
        }
        if (!(Heap[this#174, AVLTreeNode.left] == null)) {
          fraction#_284 := 50;
          assert {:msg "  245.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_284 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_284 == exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_278[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_284];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_278);
        } else {
        }
        if (!(Heap[this#174, AVLTreeNode.left] == null)) {
          assert {:msg "  245.6: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#175: int :: (0 <= k#79#175) && (k#79#175 < Seq#Length(Heap[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#174, AVLTreeNode.left], AVLTreeNode.keys], k#79#175) < Heap[this#174, AVLTreeNode.key]));
        } else {
        }
        if (!(Heap[this#174, AVLTreeNode.right] == null)) {
          fraction#_285 := 100;
          assert {:msg "  245.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_285 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_285 == exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_285];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_278);
        } else {
        }
        if (!(Heap[this#174, AVLTreeNode.right] == null)) {
          fraction#_286 := 50;
          assert {:msg "  245.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_286 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_286 == exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_278[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_286];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_278);
        } else {
        }
        if (!(Heap[this#174, AVLTreeNode.right] == null)) {
          assert {:msg "  245.6: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#176: int :: (0 <= k#80#176) && (k#80#176 < Seq#Length(Heap[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#174, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#174, AVLTreeNode.right], AVLTreeNode.keys], k#80#176)));
        } else {
        }
        Mask := exhaleMask#_278;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_289;
        assume IsGoodInhaleState(inhaleHeap#_289, Heap, Mask);
        assume this#174 != null;
        Heap[this#174, AVLTreeNode.valid] := inhaleHeap#_289[this#174, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_289[this#174, AVLTreeNode.valid] == Heap;
        Mask[this#174, AVLTreeNode.valid] := Mask[this#174, AVLTreeNode.valid][perm$R := Mask[this#174, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_289[this#174, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_289, Mask);
        assume this#174 != null;
        Heap[this#174, AVLTreeNode.keys] := inhaleHeap#_289[this#174, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#174, AVLTreeNode.keys] := Mask[this#174, AVLTreeNode.keys][perm$R := Mask[this#174, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_289[this#174, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_289, Mask);
        assume Seq#Equal(Heap[this#174, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_275[this#174, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_275[callHeap#_275[this#174, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_275[this#174, AVLTreeNode.key])), ite(callHeap#_275[this#174, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_275[callHeap#_275[this#174, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_290 := Mask;
  assert {:msg "  184.2: The postcondition at 190.11 might not hold. The expression at 190.11 might not evaluate to true."} !(r#10 == null);
  fraction#_291 := 100;
  assert {:msg "  184.2: The postcondition at 191.11 might not hold. Insufficient fraction at 191.11 for AVLTreeNode.valid."} (fraction#_291 <= exhaleMask#_290[r#10, AVLTreeNode.valid][perm$R]) && ((fraction#_291 == exhaleMask#_290[r#10, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_290[r#10, AVLTreeNode.valid][perm$N]));
  exhaleMask#_290[r#10, AVLTreeNode.valid] := exhaleMask#_290[r#10, AVLTreeNode.valid][perm$R := exhaleMask#_290[r#10, AVLTreeNode.valid][perm$R] - fraction#_291];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_290);
  fraction#_292 := 50;
  assert {:msg "  184.2: The postcondition at 192.11 might not hold. Insufficient fraction at 192.11 for AVLTreeNode.keys."} (fraction#_292 <= exhaleMask#_290[r#10, AVLTreeNode.keys][perm$R]) && ((fraction#_292 == exhaleMask#_290[r#10, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_290[r#10, AVLTreeNode.keys][perm$N]));
  exhaleMask#_290[r#10, AVLTreeNode.keys] := exhaleMask#_290[r#10, AVLTreeNode.keys][perm$R := exhaleMask#_290[r#10, AVLTreeNode.keys][perm$R] - fraction#_292];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_290);
  assert {:msg "  184.2: The postcondition at 196.11 might not hold. The expression at 196.11 might not evaluate to true."} Seq#Contains(Heap[r#10, AVLTreeNode.keys], k#9);
  assert {:msg "  184.2: The postcondition at 197.11 might not hold. The expression at 197.11 might not evaluate to true."} (forall i#70#177: int :: (0 <= i#70#177) && (i#70#177 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> Seq#Contains(Heap[r#10, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#70#177)));
  assert {:msg "  184.2: The postcondition at 198.11 might not hold. The expression at 198.11 might not evaluate to true."} (forall i#71#178: int :: (0 <= i#71#178) && (i#71#178 < Seq#Length(Heap[r#10, AVLTreeNode.keys])) ==> (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#178)) || (Seq#Index(Heap[r#10, AVLTreeNode.keys], i#71#178) == k#9)));
  if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 199.11 might not hold. The expression at 199.30 might not evaluate to true."} Seq#Equal(Heap[r#10, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#9)) {
    assert {:msg "  184.2: The postcondition at 200.11 might not hold. The expression at 200.33 might not evaluate to true."} Seq#Length(Heap[r#10, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) + 1);
  } else {
  }
  Mask := exhaleMask#_290;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  184.2: Method might lock/unlock more than allowed."} (forall lk#_293: ref :: {Heap[lk#_293, held]} {Heap[lk#_293, rdheld]} (((0 < Heap[lk#_293, held]) == (0 < old(Heap)[lk#_293, held])) && (Heap[lk#_293, rdheld] == old(Heap)[lk#_293, rdheld])) || false);
  assert {:msg "  184.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_294: HeapType;
  var inhaleHeap#_295: HeapType;
  var i#72#180: int where true;
  var i#73#182: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_294;
  assume IsGoodInhaleState(inhaleHeap#_294, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_294[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_294[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_294[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_294, Mask);
  assert {:msg "  255.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  255.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_294[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_294[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_294, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_295;
  assume IsGoodInhaleState(inhaleHeap#_295, Heap, Mask);
  assert {:msg "  259.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  259.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assume r#20 == null;
  } else {
  }
  assert {:msg "  260.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  260.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assume !(r#20 == null);
  } else {
  }
  if (!(r#20 == null)) {
    assume r#20 != null;
    Heap[r#20, AVLTreeNode.valid] := inhaleHeap#_295[r#20, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_295[r#20, AVLTreeNode.valid] == Heap;
    Mask[r#20, AVLTreeNode.valid] := Mask[r#20, AVLTreeNode.valid][perm$R := Mask[r#20, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_295[r#20, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_295, Mask);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  263.38: Fraction might be negative."} 0 <= 50;
    assert {:msg "  263.38: Fraction might exceed 100."} 50 <= 100;
    assume r#20 != null;
    Heap[r#20, AVLTreeNode.keys] := inhaleHeap#_295[r#20, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#20, AVLTreeNode.keys] := Mask[r#20, AVLTreeNode.keys][perm$R := Mask[r#20, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_295[r#20, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_295, Mask);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  267.32: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  267.32: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assume !Seq#Contains(Heap[r#20, AVLTreeNode.keys], k#19);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#72#180) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#72#180) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  268.52: Sequence index might be negative."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (0 <= i#72#180);
    assert {:msg "  268.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
    assert {:msg "  268.59: Receiver might be null."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (r#20 != null);
    assert {:msg "  268.59: Location might not be readable."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  268.11: Receiver might be null."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#180))) ==> (this != null);
    assert {:msg "  268.11: Location might not be readable."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#180))) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  268.52: Sequence index might be negative."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#180))) ==> (0 <= i#72#180);
    assert {:msg "  268.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#72#180) && (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) && (!Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#180))) ==> (i#72#180 < Seq#Length(old(Heap)[this, AVLTreeNode.keys]));
    assume (forall i#72#179: int :: (0 <= i#72#179) && (i#72#179 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#179)) || (Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#179) == k#19)));
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#73#182) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#73#182) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.52: Sequence index might be negative."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (0 <= i#73#182);
    assert {:msg "  269.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys]));
    assert {:msg "  269.61: Receiver might be null."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  269.61: Location might not be readable."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assert {:msg "  269.11: Receiver might be null."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#182)) ==> (r#20 != null);
    assert {:msg "  269.11: Location might not be readable."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#182)) ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  269.52: Sequence index might be negative."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#182)) ==> (0 <= i#73#182);
    assert {:msg "  269.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= i#73#182) && (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) && Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#182)) ==> (i#73#182 < Seq#Length(Heap[r#20, AVLTreeNode.keys]));
    assume (forall i#73#181: int :: (0 <= i#73#181) && (i#73#181 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#181)) && (!(Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#181) == k#19)));
  } else {
  }
  assert {:msg "  270.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  270.22: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  270.34: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  270.34: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.keys);
    assert {:msg "  270.50: Receiver might be null."} true ==> (this != null);
    assert {:msg "  270.50: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  271.34: Receiver might be null."} true ==> (this != null);
    assert {:msg "  271.34: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
      assert {:msg "  271.46: Receiver might be null."} true ==> (r#20 != null);
      assert {:msg "  271.46: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.keys);
      assert {:msg "  271.62: Receiver might be null."} true ==> (this != null);
      assert {:msg "  271.62: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
      assume Seq#Length(Heap[r#20, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) - 1);
    } else {
    }
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.remove(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_296: HeapType;
  var exhaleMask#_297: MaskType;
  var fraction#_298: int;
  var inhaleHeap#_299: HeapType;
  var Heap#_303: HeapType;
  var Mask#_304: MaskType;
  var Credits#_305: CreditsType;
  var exhaleMask#_306: MaskType;
  var Heap#_310: HeapType;
  var Mask#_311: MaskType;
  var Credits#_312: CreditsType;
  var exhaleMask#_313: MaskType;
  var fraction#_314: int;
  var inhaleHeap#_315: HeapType;
  var Heap#_319: HeapType;
  var Mask#_320: MaskType;
  var Credits#_321: CreditsType;
  var exhaleMask#_322: MaskType;
  var Heap#_326: HeapType;
  var Mask#_327: MaskType;
  var Credits#_328: CreditsType;
  var exhaleMask#_329: MaskType;
  var fraction#_330: int;
  var inhaleHeap#_331: HeapType;
  var bf#22: int where true;
  var nl#24: ref where (nl#24 == null) || (dtype(nl#24) == AVLTreeNode#t);
  var nr#26: ref where (nr#26 == null) || (dtype(nr#26) == AVLTreeNode#t);
  var this#189: ref where (this#189 == null) || (dtype(this#189) == AVLTreeNode#t);
  var bf#190: int where true;
  var callHeap#_332: HeapType;
  var callMask#_333: MaskType;
  var callCredits#_334: CreditsType;
  var exhaleMask#_335: MaskType;
  var epsilons#_336: int;
  var fraction#_337: int;
  var epsilons#_338: int;
  var fraction#_339: int;
  var isHeld#_340: int;
  var isRdHeld#_341: bool;
  var inhaleHeap#_342: HeapType;
  var this#191: ref where (this#191 == null) || (dtype(this#191) == AVLTreeNode#t);
  var r#192: ref where (r#192 == null) || (dtype(r#192) == AVLTreeNode#t);
  var m#193: ref where (m#193 == null) || (dtype(m#193) == AVLTreeNode#t);
  var callHeap#_343: HeapType;
  var callMask#_344: MaskType;
  var callCredits#_345: CreditsType;
  var exhaleMask#_346: MaskType;
  var fraction#_347: int;
  var fraction#_348: int;
  var isHeld#_349: int;
  var isRdHeld#_350: bool;
  var inhaleHeap#_351: HeapType;
  var this#195: ref where (this#195 == null) || (dtype(this#195) == AVLTreeNode#t);
  var r#196: ref where (r#196 == null) || (dtype(r#196) == AVLTreeNode#t);
  var m#197: ref where (m#197 == null) || (dtype(m#197) == AVLTreeNode#t);
  var callHeap#_352: HeapType;
  var callMask#_353: MaskType;
  var callCredits#_354: CreditsType;
  var exhaleMask#_355: MaskType;
  var fraction#_356: int;
  var fraction#_357: int;
  var isHeld#_358: int;
  var isRdHeld#_359: bool;
  var inhaleHeap#_360: HeapType;
  var exhaleMask#_361: MaskType;
  var fraction#_362: int;
  var inhaleHeap#_363: HeapType;
  var this#201: ref where (this#201 == null) || (dtype(this#201) == AVLTreeNode#t);
  var callHeap#_364: HeapType;
  var callMask#_365: MaskType;
  var callCredits#_366: CreditsType;
  var exhaleMask#_367: MaskType;
  var fraction#_368: int;
  var fraction#_369: int;
  var fraction#_370: int;
  var fraction#_371: int;
  var fraction#_372: int;
  var fraction#_373: int;
  var fraction#_374: int;
  var fraction#_375: int;
  var isHeld#_376: int;
  var isRdHeld#_377: bool;
  var inhaleHeap#_378: HeapType;
  var nl#28: ref where (nl#28 == null) || (dtype(nl#28) == AVLTreeNode#t);
  var this#204: ref where (this#204 == null) || (dtype(this#204) == AVLTreeNode#t);
  var k#205: int where true;
  var r#206: ref where (r#206 == null) || (dtype(r#206) == AVLTreeNode#t);
  var callHeap#_379: HeapType;
  var callMask#_380: MaskType;
  var callCredits#_381: CreditsType;
  var exhaleMask#_382: MaskType;
  var fraction#_383: int;
  var fraction#_384: int;
  var isHeld#_385: int;
  var isRdHeld#_386: bool;
  var inhaleHeap#_387: HeapType;
  var bf#30: int where true;
  var this#209: ref where (this#209 == null) || (dtype(this#209) == AVLTreeNode#t);
  var bf#210: int where true;
  var callHeap#_388: HeapType;
  var callMask#_389: MaskType;
  var callCredits#_390: CreditsType;
  var exhaleMask#_391: MaskType;
  var epsilons#_392: int;
  var fraction#_393: int;
  var epsilons#_394: int;
  var fraction#_395: int;
  var isHeld#_396: int;
  var isRdHeld#_397: bool;
  var inhaleHeap#_398: HeapType;
  var this#211: ref where (this#211 == null) || (dtype(this#211) == AVLTreeNode#t);
  var r#212: ref where (r#212 == null) || (dtype(r#212) == AVLTreeNode#t);
  var callHeap#_399: HeapType;
  var callMask#_400: MaskType;
  var callCredits#_401: CreditsType;
  var exhaleMask#_402: MaskType;
  var fraction#_403: int;
  var fraction#_404: int;
  var fraction#_405: int;
  var fraction#_406: int;
  var fraction#_407: int;
  var fraction#_408: int;
  var fraction#_409: int;
  var fraction#_410: int;
  var isHeld#_411: int;
  var isRdHeld#_412: bool;
  var inhaleHeap#_413: HeapType;
  var this#215: ref where (this#215 == null) || (dtype(this#215) == AVLTreeNode#t);
  var callHeap#_414: HeapType;
  var callMask#_415: MaskType;
  var callCredits#_416: CreditsType;
  var exhaleMask#_417: MaskType;
  var fraction#_418: int;
  var fraction#_419: int;
  var fraction#_420: int;
  var fraction#_421: int;
  var fraction#_422: int;
  var fraction#_423: int;
  var fraction#_424: int;
  var fraction#_425: int;
  var isHeld#_426: int;
  var isRdHeld#_427: bool;
  var inhaleHeap#_428: HeapType;
  var this#218: ref where (this#218 == null) || (dtype(this#218) == AVLTreeNode#t);
  var callHeap#_429: HeapType;
  var callMask#_430: MaskType;
  var callCredits#_431: CreditsType;
  var exhaleMask#_432: MaskType;
  var fraction#_433: int;
  var fraction#_434: int;
  var fraction#_435: int;
  var fraction#_436: int;
  var fraction#_437: int;
  var fraction#_438: int;
  var fraction#_439: int;
  var fraction#_440: int;
  var isHeld#_441: int;
  var isRdHeld#_442: bool;
  var inhaleHeap#_443: HeapType;
  var nr#32: ref where (nr#32 == null) || (dtype(nr#32) == AVLTreeNode#t);
  var this#221: ref where (this#221 == null) || (dtype(this#221) == AVLTreeNode#t);
  var k#222: int where true;
  var r#223: ref where (r#223 == null) || (dtype(r#223) == AVLTreeNode#t);
  var callHeap#_444: HeapType;
  var callMask#_445: MaskType;
  var callCredits#_446: CreditsType;
  var exhaleMask#_447: MaskType;
  var fraction#_448: int;
  var fraction#_449: int;
  var isHeld#_450: int;
  var isRdHeld#_451: bool;
  var inhaleHeap#_452: HeapType;
  var bf#34: int where true;
  var this#226: ref where (this#226 == null) || (dtype(this#226) == AVLTreeNode#t);
  var bf#227: int where true;
  var callHeap#_453: HeapType;
  var callMask#_454: MaskType;
  var callCredits#_455: CreditsType;
  var exhaleMask#_456: MaskType;
  var epsilons#_457: int;
  var fraction#_458: int;
  var epsilons#_459: int;
  var fraction#_460: int;
  var isHeld#_461: int;
  var isRdHeld#_462: bool;
  var inhaleHeap#_463: HeapType;
  var this#228: ref where (this#228 == null) || (dtype(this#228) == AVLTreeNode#t);
  var r#229: ref where (r#229 == null) || (dtype(r#229) == AVLTreeNode#t);
  var callHeap#_464: HeapType;
  var callMask#_465: MaskType;
  var callCredits#_466: CreditsType;
  var exhaleMask#_467: MaskType;
  var fraction#_468: int;
  var fraction#_469: int;
  var fraction#_470: int;
  var fraction#_471: int;
  var fraction#_472: int;
  var fraction#_473: int;
  var fraction#_474: int;
  var fraction#_475: int;
  var isHeld#_476: int;
  var isRdHeld#_477: bool;
  var inhaleHeap#_478: HeapType;
  var this#232: ref where (this#232 == null) || (dtype(this#232) == AVLTreeNode#t);
  var callHeap#_479: HeapType;
  var callMask#_480: MaskType;
  var callCredits#_481: CreditsType;
  var exhaleMask#_482: MaskType;
  var fraction#_483: int;
  var fraction#_484: int;
  var fraction#_485: int;
  var fraction#_486: int;
  var fraction#_487: int;
  var fraction#_488: int;
  var fraction#_489: int;
  var fraction#_490: int;
  var isHeld#_491: int;
  var isRdHeld#_492: bool;
  var inhaleHeap#_493: HeapType;
  var this#235: ref where (this#235 == null) || (dtype(this#235) == AVLTreeNode#t);
  var callHeap#_494: HeapType;
  var callMask#_495: MaskType;
  var callCredits#_496: CreditsType;
  var exhaleMask#_497: MaskType;
  var fraction#_498: int;
  var fraction#_499: int;
  var fraction#_500: int;
  var fraction#_501: int;
  var fraction#_502: int;
  var fraction#_503: int;
  var fraction#_504: int;
  var fraction#_505: int;
  var isHeld#_506: int;
  var isRdHeld#_507: bool;
  var inhaleHeap#_508: HeapType;
  var exhaleMask#_509: MaskType;
  var fraction#_510: int;
  var fraction#_511: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_296;
  assume IsGoodInhaleState(inhaleHeap#_296, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_296[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_296[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_296[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_296, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_296[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_296[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_296, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  277.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_297 := Mask;
  fraction#_298 := 100;
  assert {:msg "  277.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_298 <= exhaleMask#_297[this, AVLTreeNode.valid][perm$R]) && ((fraction#_298 == exhaleMask#_297[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_297[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_297[this, AVLTreeNode.valid] := exhaleMask#_297[this, AVLTreeNode.valid][perm$R := exhaleMask#_297[this, AVLTreeNode.valid][perm$R] - fraction#_298];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_297);
  Mask := exhaleMask#_297;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_299 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_299, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_299[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_299[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_299, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_299[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_299[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_299, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_299[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_299[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_299, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_299[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_299[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_299, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_299[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_299[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_299[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_299, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_299[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_299[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_299, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#183: int :: (0 <= lk#67#183) && (lk#67#183 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#183) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_299[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_299[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_299[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_299, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_299[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_299[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_299, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#184: int :: (0 <= rk#68#184) && (rk#68#184 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#184)));
  } else {
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  278.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  278.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (Heap[this, AVLTreeNode.key] == k#19) {
    // if
    assert {:msg "  279.8: Receiver might be null."} true ==> (this != null);
    assert {:msg "  279.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  279.22: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
    assert {:msg "  279.22: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, this, AVLTreeNode.right);
    if ((Heap[this, AVLTreeNode.left] == null) || (Heap[this, AVLTreeNode.right] == null)) {
      // assert
      Heap#_303 := Heap;
      Mask#_304 := Mask;
      Credits#_305 := Credits;
      // begin exhale (assert)
      exhaleMask#_306 := Mask#_304;
      assert {:msg "  280.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  280.12: Location might not be readable."} true ==> CanRead(Mask#_304, this, AVLTreeNode.right);
      if (!(Heap#_303[this, AVLTreeNode.right] == null)) {
        // unfolding
        assert {:msg "  280.38: Receiver might be null."} true ==> (this != null);
        assert {:msg "  280.38: Location might not be readable."} true ==> CanRead(Mask#_304, this, AVLTreeNode.right);
        assert {:msg "  280.38: Receiver might be null."} true ==> (Heap#_303[this, AVLTreeNode.right] != null);
        Heap#_310 := Heap#_303;
        Mask#_311 := Mask#_304;
        Credits#_312 := Credits#_305;
        // begin exhale (unfolding)
        exhaleMask#_313 := Mask#_311;
        fraction#_314 := 100;
        assert {:msg "  280.28: Unfolding might fail. Insufficient fraction at 280.38 for AVLTreeNode.valid."} (fraction#_314 <= exhaleMask#_313[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_314 == exhaleMask#_313[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_313[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_313[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_313[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_313[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_314];
        assume IsGoodMask(Mask#_311);
        assume wf(Heap#_310, Mask#_311);
        assume wf(Heap#_310, exhaleMask#_313);
        Mask#_311 := exhaleMask#_313;
        assume wf(Heap#_310, Mask#_311);
        // end exhale
        // inhale (unfolding)
        inhaleHeap#_315 := Heap#_303[Heap#_303[this, AVLTreeNode.right], AVLTreeNode.valid];
        assume IsGoodInhaleState(inhaleHeap#_315, Heap#_310, Mask#_311);
        assume Heap#_310[this, AVLTreeNode.right] != null;
        Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key];
        assume wf(Heap#_310, Mask#_311);
        assume true;
        Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key] := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
        assume IsGoodMask(Mask#_311);
        assume IsGoodState(inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key]);
        assume wf(Heap#_310, Mask#_311);
        assume wf(inhaleHeap#_315, Mask#_311);
        assume Heap#_310[this, AVLTreeNode.right] != null;
        Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left];
        assume wf(Heap#_310, Mask#_311);
        assume (Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
        Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
        assume IsGoodMask(Mask#_311);
        assume IsGoodState(inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left]);
        assume wf(Heap#_310, Mask#_311);
        assume wf(inhaleHeap#_315, Mask#_311);
        assume Heap#_310[this, AVLTreeNode.right] != null;
        Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right];
        assume wf(Heap#_310, Mask#_311);
        assume (Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
        Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
        assume IsGoodMask(Mask#_311);
        assume IsGoodState(inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right]);
        assume wf(Heap#_310, Mask#_311);
        assume wf(inhaleHeap#_315, Mask#_311);
        assume Heap#_310[this, AVLTreeNode.right] != null;
        Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys];
        assume wf(Heap#_310, Mask#_311);
        assume true;
        Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_311[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask#_311);
        assume IsGoodState(inhaleHeap#_315[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys]);
        assume wf(Heap#_310, Mask#_311);
        assume wf(inhaleHeap#_315, Mask#_311);
        if (!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
          assume wf(Heap#_310, Mask#_311);
          assume inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_310;
          Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask#_311);
          assume IsGoodState(inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
          assume wf(Heap#_310, Mask#_311);
          assume wf(inhaleHeap#_315, Mask#_311);
        } else {
        }
        if (!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] != null;
          Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys];
          assume wf(Heap#_310, Mask#_311);
          assume true;
          Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask#_311);
          assume IsGoodState(inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]);
          assume wf(Heap#_310, Mask#_311);
          assume wf(inhaleHeap#_315, Mask#_311);
        } else {
        }
        if (!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
          assume (forall lk#67#185: int :: (0 <= lk#67#185) && (lk#67#185 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#67#185) < Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key]));
        } else {
        }
        if (!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
          assume wf(Heap#_310, Mask#_311);
          assume inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_310;
          Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask#_311);
          assume IsGoodState(inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
          assume wf(Heap#_310, Mask#_311);
          assume wf(inhaleHeap#_315, Mask#_311);
        } else {
        }
        if (!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] != null;
          Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys];
          assume wf(Heap#_310, Mask#_311);
          assume true;
          Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_311[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask#_311);
          assume IsGoodState(inhaleHeap#_315[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]);
          assume wf(Heap#_310, Mask#_311);
          assume wf(inhaleHeap#_315, Mask#_311);
        } else {
        }
        if (!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
          assume (forall rk#68#186: int :: (0 <= rk#68#186) && (rk#68#186 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#68#186)));
        } else {
        }
        assume Seq#Equal(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys], Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key]);
        assume (forall kk#69: int :: Seq#Contains(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69) <==> ((((!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap#_310[Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap#_310[Heap#_310[this, AVLTreeNode.right], AVLTreeNode.key])));
        assume IsGoodMask(Mask#_311);
        assume wf(Heap#_310, Mask#_311);
        // end inhale
        assert {:msg "  280.53: Receiver might be null."} true ==> (this != null);
        assert {:msg "  280.53: Location might not be readable."} true ==> CanRead(Mask#_311, this, AVLTreeNode.right);
        assert {:msg "  280.53: Receiver might be null."} true ==> (Heap#_310[this, AVLTreeNode.right] != null);
        assert {:msg "  280.53: Location might not be readable."} true ==> CanRead(Mask#_311, Heap#_310[this, AVLTreeNode.right], AVLTreeNode.keys);
        assert {:msg "  280.5: Assertion might not hold. The expression at 280.28 might not evaluate to true."} !Seq#Equal(Heap#_303[Heap#_303[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Empty());
      } else {
      }
      Mask#_304 := exhaleMask#_306;
      assume wf(Heap#_303, Mask#_304);
      // end exhale
      // assert
      Heap#_319 := Heap;
      Mask#_320 := Mask;
      Credits#_321 := Credits;
      // begin exhale (assert)
      exhaleMask#_322 := Mask#_320;
      assert {:msg "  281.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  281.12: Location might not be readable."} true ==> CanRead(Mask#_320, this, AVLTreeNode.left);
      if (!(Heap#_319[this, AVLTreeNode.left] == null)) {
        // unfolding
        assert {:msg "  281.38: Receiver might be null."} true ==> (this != null);
        assert {:msg "  281.38: Location might not be readable."} true ==> CanRead(Mask#_320, this, AVLTreeNode.left);
        assert {:msg "  281.38: Receiver might be null."} true ==> (Heap#_319[this, AVLTreeNode.left] != null);
        Heap#_326 := Heap#_319;
        Mask#_327 := Mask#_320;
        Credits#_328 := Credits#_321;
        // begin exhale (unfolding)
        exhaleMask#_329 := Mask#_327;
        fraction#_330 := 100;
        assert {:msg "  281.28: Unfolding might fail. Insufficient fraction at 281.38 for AVLTreeNode.valid."} (fraction#_330 <= exhaleMask#_329[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_330 == exhaleMask#_329[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_329[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_329[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_329[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_329[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_330];
        assume IsGoodMask(Mask#_327);
        assume wf(Heap#_326, Mask#_327);
        assume wf(Heap#_326, exhaleMask#_329);
        Mask#_327 := exhaleMask#_329;
        assume wf(Heap#_326, Mask#_327);
        // end exhale
        // inhale (unfolding)
        inhaleHeap#_331 := Heap#_319[Heap#_319[this, AVLTreeNode.left], AVLTreeNode.valid];
        assume IsGoodInhaleState(inhaleHeap#_331, Heap#_326, Mask#_327);
        assume Heap#_326[this, AVLTreeNode.left] != null;
        Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key];
        assume wf(Heap#_326, Mask#_327);
        assume true;
        Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key] := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
        assume IsGoodMask(Mask#_327);
        assume IsGoodState(inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key]);
        assume wf(Heap#_326, Mask#_327);
        assume wf(inhaleHeap#_331, Mask#_327);
        assume Heap#_326[this, AVLTreeNode.left] != null;
        Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left];
        assume wf(Heap#_326, Mask#_327);
        assume (Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
        Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
        assume IsGoodMask(Mask#_327);
        assume IsGoodState(inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left]);
        assume wf(Heap#_326, Mask#_327);
        assume wf(inhaleHeap#_331, Mask#_327);
        assume Heap#_326[this, AVLTreeNode.left] != null;
        Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right];
        assume wf(Heap#_326, Mask#_327);
        assume (Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
        Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
        assume IsGoodMask(Mask#_327);
        assume IsGoodState(inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right]);
        assume wf(Heap#_326, Mask#_327);
        assume wf(inhaleHeap#_331, Mask#_327);
        assume Heap#_326[this, AVLTreeNode.left] != null;
        Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys];
        assume wf(Heap#_326, Mask#_327);
        assume true;
        Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_327[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask#_327);
        assume IsGoodState(inhaleHeap#_331[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys]);
        assume wf(Heap#_326, Mask#_327);
        assume wf(inhaleHeap#_331, Mask#_327);
        if (!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
          assume wf(Heap#_326, Mask#_327);
          assume inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_326;
          Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask#_327);
          assume IsGoodState(inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
          assume wf(Heap#_326, Mask#_327);
          assume wf(inhaleHeap#_331, Mask#_327);
        } else {
        }
        if (!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] != null;
          Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys];
          assume wf(Heap#_326, Mask#_327);
          assume true;
          Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask#_327);
          assume IsGoodState(inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]);
          assume wf(Heap#_326, Mask#_327);
          assume wf(inhaleHeap#_331, Mask#_327);
        } else {
        }
        if (!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
          assume (forall lk#67#187: int :: (0 <= lk#67#187) && (lk#67#187 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#67#187) < Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key]));
        } else {
        }
        if (!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
          assume wf(Heap#_326, Mask#_327);
          assume inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_326;
          Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask#_327);
          assume IsGoodState(inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
          assume wf(Heap#_326, Mask#_327);
          assume wf(inhaleHeap#_331, Mask#_327);
        } else {
        }
        if (!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] != null;
          Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys];
          assume wf(Heap#_326, Mask#_327);
          assume true;
          Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_327[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask#_327);
          assume IsGoodState(inhaleHeap#_331[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]);
          assume wf(Heap#_326, Mask#_327);
          assume wf(inhaleHeap#_331, Mask#_327);
        } else {
        }
        if (!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
          assume (forall rk#68#188: int :: (0 <= rk#68#188) && (rk#68#188 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#68#188)));
        } else {
        }
        assume Seq#Equal(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
        assume Seq#Contains(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys], Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key]);
        assume (forall kk#69: int :: Seq#Contains(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69) <==> ((((!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap#_326[Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap#_326[Heap#_326[this, AVLTreeNode.left], AVLTreeNode.key])));
        assume IsGoodMask(Mask#_327);
        assume wf(Heap#_326, Mask#_327);
        // end inhale
        assert {:msg "  281.53: Receiver might be null."} true ==> (this != null);
        assert {:msg "  281.53: Location might not be readable."} true ==> CanRead(Mask#_327, this, AVLTreeNode.left);
        assert {:msg "  281.53: Receiver might be null."} true ==> (Heap#_326[this, AVLTreeNode.left] != null);
        assert {:msg "  281.53: Location might not be readable."} true ==> CanRead(Mask#_327, Heap#_326[this, AVLTreeNode.left], AVLTreeNode.keys);
        assert {:msg "  281.5: Assertion might not hold. The expression at 281.28 might not evaluate to true."} !Seq#Equal(Heap#_319[Heap#_319[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Empty());
      } else {
      }
      Mask#_320 := exhaleMask#_322;
      assume wf(Heap#_319, Mask#_320);
      // end exhale
      // if
      assert {:msg "  282.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  282.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (Heap[this, AVLTreeNode.left] == null) {
        // assigment to r
        assert {:msg "  283.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  283.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        r#20 := Heap[this, AVLTreeNode.right];
      } else {
        // assigment to r
        assert {:msg "  285.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  285.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        r#20 := Heap[this, AVLTreeNode.left];
      }
    } else {
      // local var bf
      // local var nl
      // assigment to nl
      assert {:msg "  289.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  289.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      nl#24 := Heap[this, AVLTreeNode.left];
      // local var nr
      // assigment to nr
      assert {:msg "  290.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  290.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      nr#26 := Heap[this, AVLTreeNode.right];
      // call getBalanceFactorI
      callHeap#_332 := Heap;
      callMask#_333 := Mask;
      callCredits#_334 := Credits;
      assert {:msg "  292.5: The target of the method call might be null."} this != null;
      this#189 := this;
      // begin exhale (precondition)
      exhaleMask#_335 := Mask;
      epsilons#_336 := 1;
      assert {:msg "  292.5: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_335[this#189, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_336 <= exhaleMask#_335[this#189, AVLTreeNode.left][perm$N]);
      if ((exhaleMask#_335[this#189, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_335[this#189, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_335[this#189, AVLTreeNode.left] := exhaleMask#_335[this#189, AVLTreeNode.left][perm$N := exhaleMask#_335[this#189, AVLTreeNode.left][perm$N] - epsilons#_336];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_335);
      if (!(Heap[this#189, AVLTreeNode.left] == null)) {
        fraction#_337 := 100;
        assert {:msg "  292.5: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_337 <= exhaleMask#_335[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_337 == exhaleMask#_335[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_335[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_335[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_335[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_335[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_337];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_335);
      } else {
      }
      epsilons#_338 := 1;
      assert {:msg "  292.5: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_335[this#189, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_338 <= exhaleMask#_335[this#189, AVLTreeNode.right][perm$N]);
      if ((exhaleMask#_335[this#189, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_335[this#189, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_335[this#189, AVLTreeNode.right] := exhaleMask#_335[this#189, AVLTreeNode.right][perm$N := exhaleMask#_335[this#189, AVLTreeNode.right][perm$N] - epsilons#_338];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_335);
      if (!(Heap[this#189, AVLTreeNode.right] == null)) {
        fraction#_339 := 100;
        assert {:msg "  292.5: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_339 <= exhaleMask#_335[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_339 == exhaleMask#_335[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_335[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_335[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_335[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_335[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_339];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_335);
      } else {
      }
      Mask := exhaleMask#_335;
      assume wf(Heap, Mask);
      // end exhale
      havoc bf#190;
      // inhale (postcondition)
      havoc inhaleHeap#_342;
      assume IsGoodInhaleState(inhaleHeap#_342, Heap, Mask);
      assume this#189 != null;
      Heap[this#189, AVLTreeNode.left] := inhaleHeap#_342[this#189, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[this#189, AVLTreeNode.left] == null) || (dtype(Heap[this#189, AVLTreeNode.left]) == AVLTreeNode#t);
      if ((Mask[this#189, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#189, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        Mask[this#189, AVLTreeNode.left] := Mask[this#189, AVLTreeNode.left][perm$N := Mask[this#189, AVLTreeNode.left][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_342[this#189, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_342, Mask);
      if (!(Heap[this#189, AVLTreeNode.left] == null)) {
        assume Heap[this#189, AVLTreeNode.left] != null;
        Heap[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_342[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_342[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_342[Heap[this#189, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_342, Mask);
      } else {
      }
      assume this#189 != null;
      Heap[this#189, AVLTreeNode.right] := inhaleHeap#_342[this#189, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[this#189, AVLTreeNode.right] == null) || (dtype(Heap[this#189, AVLTreeNode.right]) == AVLTreeNode#t);
      if ((Mask[this#189, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#189, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        Mask[this#189, AVLTreeNode.right] := Mask[this#189, AVLTreeNode.right][perm$N := Mask[this#189, AVLTreeNode.right][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_342[this#189, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_342, Mask);
      if (!(Heap[this#189, AVLTreeNode.right] == null)) {
        assume Heap[this#189, AVLTreeNode.right] != null;
        Heap[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_342[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_342[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_342[Heap[this#189, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_342, Mask);
      } else {
      }
      if (bf#190 > 0) {
        assume !(Heap[this#189, AVLTreeNode.left] == null);
      } else {
      }
      if (bf#190 < 0) {
        assume !(Heap[this#189, AVLTreeNode.right] == null);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      bf#22 := bf#190;
      // if
      if (bf#22 > 0) {
        // call pruneMax
        callHeap#_343 := Heap;
        callMask#_344 := Mask;
        callCredits#_345 := Credits;
        assert {:msg "  294.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  294.19: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  294.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#191 := Heap[this, AVLTreeNode.left];
        // begin exhale (precondition)
        exhaleMask#_346 := Mask;
        fraction#_347 := 100;
        assert {:msg "  294.6: The precondition at 348.12 might not hold. Insufficient fraction at 348.12 for AVLTreeNode.valid."} (fraction#_347 <= exhaleMask#_346[this#191, AVLTreeNode.valid][perm$R]) && ((fraction#_347 == exhaleMask#_346[this#191, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_346[this#191, AVLTreeNode.valid][perm$N]));
        exhaleMask#_346[this#191, AVLTreeNode.valid] := exhaleMask#_346[this#191, AVLTreeNode.valid][perm$R := exhaleMask#_346[this#191, AVLTreeNode.valid][perm$R] - fraction#_347];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_346);
        fraction#_348 := 50;
        assert {:msg "  294.6: The precondition at 349.12 might not hold. Insufficient fraction at 349.12 for AVLTreeNode.keys."} (fraction#_348 <= exhaleMask#_346[this#191, AVLTreeNode.keys][perm$R]) && ((fraction#_348 == exhaleMask#_346[this#191, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_346[this#191, AVLTreeNode.keys][perm$N]));
        exhaleMask#_346[this#191, AVLTreeNode.keys] := exhaleMask#_346[this#191, AVLTreeNode.keys][perm$R := exhaleMask#_346[this#191, AVLTreeNode.keys][perm$R] - fraction#_348];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_346);
        Mask := exhaleMask#_346;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#192;
        havoc m#193;
        // inhale (postcondition)
        havoc inhaleHeap#_351;
        assume IsGoodInhaleState(inhaleHeap#_351, Heap, Mask);
        if (!(r#192 == null)) {
          assume r#192 != null;
          Heap[r#192, AVLTreeNode.valid] := inhaleHeap#_351[r#192, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_351[r#192, AVLTreeNode.valid] == Heap;
          Mask[r#192, AVLTreeNode.valid] := Mask[r#192, AVLTreeNode.valid][perm$R := Mask[r#192, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_351[r#192, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_351, Mask);
        } else {
        }
        if (!(r#192 == null)) {
          assume r#192 != null;
          Heap[r#192, AVLTreeNode.keys] := inhaleHeap#_351[r#192, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#192, AVLTreeNode.keys] := Mask[r#192, AVLTreeNode.keys][perm$R := Mask[r#192, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_351[r#192, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_351, Mask);
        } else {
        }
        if (!(r#192 == null)) {
          assume (Seq#Length(Heap[r#192, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this#191, AVLTreeNode.keys]);
        } else {
        }
        assume !(m#193 == null);
        assume m#193 != null;
        Heap[m#193, AVLTreeNode.valid] := inhaleHeap#_351[m#193, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_351[m#193, AVLTreeNode.valid] == Heap;
        Mask[m#193, AVLTreeNode.valid] := Mask[m#193, AVLTreeNode.valid][perm$R := Mask[m#193, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_351[m#193, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_351, Mask);
        assume m#193 != null;
        Heap[m#193, AVLTreeNode.keys] := inhaleHeap#_351[m#193, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[m#193, AVLTreeNode.keys] := Mask[m#193, AVLTreeNode.keys][perm$R := Mask[m#193, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_351[m#193, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_351, Mask);
        assume Seq#Length(Heap[m#193, AVLTreeNode.keys]) == 1;
        assume Seq#Equal(Seq#Append(ite(r#192 == null, Seq#Empty(), Heap[r#192, AVLTreeNode.keys]), Heap[m#193, AVLTreeNode.keys]), callHeap#_343[this#191, AVLTreeNode.keys]);
        if (!(r#192 == null)) {
          assume (forall k#74#194: int :: (0 <= k#74#194) && (k#74#194 < Seq#Length(Heap[r#192, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#192, AVLTreeNode.keys], k#74#194) < Seq#Index(Heap[m#193, AVLTreeNode.keys], 0)));
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nl#24 := r#192;
        r#20 := m#193;
      } else {
        // call pruneMin
        callHeap#_352 := Heap;
        callMask#_353 := Mask;
        callCredits#_354 := Credits;
        assert {:msg "  296.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  296.19: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  296.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#195 := Heap[this, AVLTreeNode.right];
        // begin exhale (precondition)
        exhaleMask#_355 := Mask;
        fraction#_356 := 100;
        assert {:msg "  296.6: The precondition at 402.12 might not hold. Insufficient fraction at 402.12 for AVLTreeNode.valid."} (fraction#_356 <= exhaleMask#_355[this#195, AVLTreeNode.valid][perm$R]) && ((fraction#_356 == exhaleMask#_355[this#195, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_355[this#195, AVLTreeNode.valid][perm$N]));
        exhaleMask#_355[this#195, AVLTreeNode.valid] := exhaleMask#_355[this#195, AVLTreeNode.valid][perm$R := exhaleMask#_355[this#195, AVLTreeNode.valid][perm$R] - fraction#_356];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_355);
        fraction#_357 := 50;
        assert {:msg "  296.6: The precondition at 403.12 might not hold. Insufficient fraction at 403.12 for AVLTreeNode.keys."} (fraction#_357 <= exhaleMask#_355[this#195, AVLTreeNode.keys][perm$R]) && ((fraction#_357 == exhaleMask#_355[this#195, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_355[this#195, AVLTreeNode.keys][perm$N]));
        exhaleMask#_355[this#195, AVLTreeNode.keys] := exhaleMask#_355[this#195, AVLTreeNode.keys][perm$R := exhaleMask#_355[this#195, AVLTreeNode.keys][perm$R] - fraction#_357];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_355);
        Mask := exhaleMask#_355;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#196;
        havoc m#197;
        // inhale (postcondition)
        havoc inhaleHeap#_360;
        assume IsGoodInhaleState(inhaleHeap#_360, Heap, Mask);
        if (!(r#196 == null)) {
          assume r#196 != null;
          Heap[r#196, AVLTreeNode.valid] := inhaleHeap#_360[r#196, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_360[r#196, AVLTreeNode.valid] == Heap;
          Mask[r#196, AVLTreeNode.valid] := Mask[r#196, AVLTreeNode.valid][perm$R := Mask[r#196, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_360[r#196, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_360, Mask);
        } else {
        }
        if (!(r#196 == null)) {
          assume r#196 != null;
          Heap[r#196, AVLTreeNode.keys] := inhaleHeap#_360[r#196, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#196, AVLTreeNode.keys] := Mask[r#196, AVLTreeNode.keys][perm$R := Mask[r#196, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_360[r#196, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_360, Mask);
        } else {
        }
        if (!(r#196 == null)) {
          assume (Seq#Length(Heap[r#196, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this#195, AVLTreeNode.keys]);
        } else {
        }
        assume !(m#197 == null);
        assume m#197 != null;
        Heap[m#197, AVLTreeNode.valid] := inhaleHeap#_360[m#197, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_360[m#197, AVLTreeNode.valid] == Heap;
        Mask[m#197, AVLTreeNode.valid] := Mask[m#197, AVLTreeNode.valid][perm$R := Mask[m#197, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_360[m#197, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_360, Mask);
        assume m#197 != null;
        Heap[m#197, AVLTreeNode.keys] := inhaleHeap#_360[m#197, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[m#197, AVLTreeNode.keys] := Mask[m#197, AVLTreeNode.keys][perm$R := Mask[m#197, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_360[m#197, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_360, Mask);
        assume Seq#Length(Heap[m#197, AVLTreeNode.keys]) == 1;
        assume Seq#Equal(Seq#Append(Heap[m#197, AVLTreeNode.keys], ite(r#196 == null, Seq#Empty(), Heap[r#196, AVLTreeNode.keys])), callHeap#_352[this#195, AVLTreeNode.keys]);
        if (!(r#196 == null)) {
          assume (forall k#77#198: int :: (0 <= k#77#198) && (k#77#198 < Seq#Length(Heap[r#196, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#197, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#196, AVLTreeNode.keys], k#77#198)));
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nr#26 := r#196;
        r#20 := m#197;
      }
      // unfold
      assert {:msg "  298.5: The target of the fold statement might be null."} r#20 != null;
      // begin exhale (unfold)
      exhaleMask#_361 := Mask;
      fraction#_362 := 100;
      assert {:msg "  298.5: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_362 <= exhaleMask#_361[r#20, AVLTreeNode.valid][perm$R]) && ((fraction#_362 == exhaleMask#_361[r#20, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_361[r#20, AVLTreeNode.valid][perm$N]));
      exhaleMask#_361[r#20, AVLTreeNode.valid] := exhaleMask#_361[r#20, AVLTreeNode.valid][perm$R := exhaleMask#_361[r#20, AVLTreeNode.valid][perm$R] - fraction#_362];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_361);
      Mask := exhaleMask#_361;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (unfold)
      inhaleHeap#_363 := Heap[r#20, AVLTreeNode.valid];
      assume IsGoodInhaleState(inhaleHeap#_363, Heap, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.key] := inhaleHeap#_363[r#20, AVLTreeNode.key];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#20, AVLTreeNode.key] := Mask[r#20, AVLTreeNode.key][perm$R := Mask[r#20, AVLTreeNode.key][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_363[r#20, AVLTreeNode.key]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_363, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.left] := inhaleHeap#_363[r#20, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[r#20, AVLTreeNode.left] == null) || (dtype(Heap[r#20, AVLTreeNode.left]) == AVLTreeNode#t);
      Mask[r#20, AVLTreeNode.left] := Mask[r#20, AVLTreeNode.left][perm$R := Mask[r#20, AVLTreeNode.left][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_363[r#20, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_363, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.right] := inhaleHeap#_363[r#20, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[r#20, AVLTreeNode.right] == null) || (dtype(Heap[r#20, AVLTreeNode.right]) == AVLTreeNode#t);
      Mask[r#20, AVLTreeNode.right] := Mask[r#20, AVLTreeNode.right][perm$R := Mask[r#20, AVLTreeNode.right][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_363[r#20, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_363, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.keys] := inhaleHeap#_363[r#20, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#20, AVLTreeNode.keys] := Mask[r#20, AVLTreeNode.keys][perm$R := Mask[r#20, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_363[r#20, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_363, Mask);
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_363[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_363[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_363[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_363, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_363[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_363[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_363, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume (forall lk#67#199: int :: (0 <= lk#67#199) && (lk#67#199 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], lk#67#199) < Heap[r#20, AVLTreeNode.key]));
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_363[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_363[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_363[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_363, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_363[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_363[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_363, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume (forall rk#68#200: int :: (0 <= rk#68#200) && (rk#68#200 < Seq#Length(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#20, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], rk#68#200)));
      } else {
      }
      assume Seq#Equal(Heap[r#20, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#20, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#20, AVLTreeNode.key])), ite(Heap[r#20, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys])));
      assume Seq#Contains(Heap[r#20, AVLTreeNode.keys], Heap[r#20, AVLTreeNode.key]);
      assume (forall kk#69: int :: Seq#Contains(Heap[r#20, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[r#20, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[r#20, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[r#20, AVLTreeNode.key])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // update field left
      assert {:msg "  299.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.left);
      Heap[r#20, AVLTreeNode.left] := nl#24;
      assume wf(Heap, Mask);
      // update field right
      assert {:msg "  300.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.right);
      Heap[r#20, AVLTreeNode.right] := nr#26;
      assume wf(Heap, Mask);
      // call close
      callHeap#_364 := Heap;
      callMask#_365 := Mask;
      callCredits#_366 := Credits;
      assert {:msg "  301.5: The target of the method call might be null."} r#20 != null;
      this#201 := r#20;
      // begin exhale (precondition)
      exhaleMask#_367 := Mask;
      fraction#_368 := 100;
      assert {:msg "  301.5: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_368 <= exhaleMask#_367[this#201, AVLTreeNode.key][perm$R]) && ((fraction#_368 == exhaleMask#_367[this#201, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_367[this#201, AVLTreeNode.key][perm$N]));
      exhaleMask#_367[this#201, AVLTreeNode.key] := exhaleMask#_367[this#201, AVLTreeNode.key][perm$R := exhaleMask#_367[this#201, AVLTreeNode.key][perm$R] - fraction#_368];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_367);
      fraction#_369 := 100;
      assert {:msg "  301.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_369 <= exhaleMask#_367[this#201, AVLTreeNode.left][perm$R]) && ((fraction#_369 == exhaleMask#_367[this#201, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_367[this#201, AVLTreeNode.left][perm$N]));
      exhaleMask#_367[this#201, AVLTreeNode.left] := exhaleMask#_367[this#201, AVLTreeNode.left][perm$R := exhaleMask#_367[this#201, AVLTreeNode.left][perm$R] - fraction#_369];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_367);
      fraction#_370 := 100;
      assert {:msg "  301.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_370 <= exhaleMask#_367[this#201, AVLTreeNode.right][perm$R]) && ((fraction#_370 == exhaleMask#_367[this#201, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_367[this#201, AVLTreeNode.right][perm$N]));
      exhaleMask#_367[this#201, AVLTreeNode.right] := exhaleMask#_367[this#201, AVLTreeNode.right][perm$R := exhaleMask#_367[this#201, AVLTreeNode.right][perm$R] - fraction#_370];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_367);
      fraction#_371 := 100;
      assert {:msg "  301.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_371 <= exhaleMask#_367[this#201, AVLTreeNode.keys][perm$R]) && ((fraction#_371 == exhaleMask#_367[this#201, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_367[this#201, AVLTreeNode.keys][perm$N]));
      exhaleMask#_367[this#201, AVLTreeNode.keys] := exhaleMask#_367[this#201, AVLTreeNode.keys][perm$R := exhaleMask#_367[this#201, AVLTreeNode.keys][perm$R] - fraction#_371];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_367);
      if (!(Heap[this#201, AVLTreeNode.left] == null)) {
        fraction#_372 := 100;
        assert {:msg "  301.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_372 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_372 == exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_372];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_367);
      } else {
      }
      if (!(Heap[this#201, AVLTreeNode.left] == null)) {
        fraction#_373 := 50;
        assert {:msg "  301.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_373 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_373 == exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_367[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_373];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_367);
      } else {
      }
      if (!(Heap[this#201, AVLTreeNode.left] == null)) {
        assert {:msg "  301.5: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#202: int :: (0 <= k#79#202) && (k#79#202 < Seq#Length(Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#201, AVLTreeNode.left], AVLTreeNode.keys], k#79#202) < Heap[this#201, AVLTreeNode.key]));
      } else {
      }
      if (!(Heap[this#201, AVLTreeNode.right] == null)) {
        fraction#_374 := 100;
        assert {:msg "  301.5: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_374 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_374 == exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_374];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_367);
      } else {
      }
      if (!(Heap[this#201, AVLTreeNode.right] == null)) {
        fraction#_375 := 50;
        assert {:msg "  301.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_375 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_375 == exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_367[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_375];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_367);
      } else {
      }
      if (!(Heap[this#201, AVLTreeNode.right] == null)) {
        assert {:msg "  301.5: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#203: int :: (0 <= k#80#203) && (k#80#203 < Seq#Length(Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#201, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#201, AVLTreeNode.right], AVLTreeNode.keys], k#80#203)));
      } else {
      }
      Mask := exhaleMask#_367;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_378;
      assume IsGoodInhaleState(inhaleHeap#_378, Heap, Mask);
      assume this#201 != null;
      Heap[this#201, AVLTreeNode.valid] := inhaleHeap#_378[this#201, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_378[this#201, AVLTreeNode.valid] == Heap;
      Mask[this#201, AVLTreeNode.valid] := Mask[this#201, AVLTreeNode.valid][perm$R := Mask[this#201, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_378[this#201, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_378, Mask);
      assume this#201 != null;
      Heap[this#201, AVLTreeNode.keys] := inhaleHeap#_378[this#201, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#201, AVLTreeNode.keys] := Mask[this#201, AVLTreeNode.keys][perm$R := Mask[this#201, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_378[this#201, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_378, Mask);
      assume Seq#Equal(Heap[this#201, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_364[this#201, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_364[callHeap#_364[this#201, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_364[this#201, AVLTreeNode.key])), ite(callHeap#_364[this#201, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_364[callHeap#_364[this#201, AVLTreeNode.right], AVLTreeNode.keys])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
    }
  } else {
    // if
    assert {:msg "  304.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  304.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (k#19 < Heap[this, AVLTreeNode.key]) {
      // if
      assert {:msg "  305.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  305.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (!(Heap[this, AVLTreeNode.left] == null)) {
        // local var nl
        // call remove
        callHeap#_379 := Heap;
        callMask#_380 := Mask;
        callCredits#_381 := Credits;
        assert {:msg "  307.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  307.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  307.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#204 := Heap[this, AVLTreeNode.left];
        k#205 := k#19;
        // begin exhale (precondition)
        exhaleMask#_382 := Mask;
        fraction#_383 := 100;
        assert {:msg "  307.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (fraction#_383 <= exhaleMask#_382[this#204, AVLTreeNode.valid][perm$R]) && ((fraction#_383 == exhaleMask#_382[this#204, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_382[this#204, AVLTreeNode.valid][perm$N]));
        exhaleMask#_382[this#204, AVLTreeNode.valid] := exhaleMask#_382[this#204, AVLTreeNode.valid][perm$R := exhaleMask#_382[this#204, AVLTreeNode.valid][perm$R] - fraction#_383];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_382);
        fraction#_384 := 50;
        assert {:msg "  307.6: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} (fraction#_384 <= exhaleMask#_382[this#204, AVLTreeNode.keys][perm$R]) && ((fraction#_384 == exhaleMask#_382[this#204, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_382[this#204, AVLTreeNode.keys][perm$N]));
        exhaleMask#_382[this#204, AVLTreeNode.keys] := exhaleMask#_382[this#204, AVLTreeNode.keys][perm$R := exhaleMask#_382[this#204, AVLTreeNode.keys][perm$R] - fraction#_384];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_382);
        Mask := exhaleMask#_382;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#206;
        // inhale (postcondition)
        havoc inhaleHeap#_387;
        assume IsGoodInhaleState(inhaleHeap#_387, Heap, Mask);
        if (Seq#Equal(callHeap#_379[this#204, AVLTreeNode.keys], Seq#Singleton(k#205))) {
          assume r#206 == null;
        } else {
        }
        if (!Seq#Equal(callHeap#_379[this#204, AVLTreeNode.keys], Seq#Singleton(k#205))) {
          assume !(r#206 == null);
        } else {
        }
        if (!(r#206 == null)) {
          assume r#206 != null;
          Heap[r#206, AVLTreeNode.valid] := inhaleHeap#_387[r#206, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_387[r#206, AVLTreeNode.valid] == Heap;
          Mask[r#206, AVLTreeNode.valid] := Mask[r#206, AVLTreeNode.valid][perm$R := Mask[r#206, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_387[r#206, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_387, Mask);
        } else {
        }
        if (!(r#206 == null)) {
          assume r#206 != null;
          Heap[r#206, AVLTreeNode.keys] := inhaleHeap#_387[r#206, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#206, AVLTreeNode.keys] := Mask[r#206, AVLTreeNode.keys][perm$R := Mask[r#206, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_387[r#206, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_387, Mask);
        } else {
        }
        if (!(r#206 == null)) {
          assume !Seq#Contains(Heap[r#206, AVLTreeNode.keys], k#205);
        } else {
        }
        if (!(r#206 == null)) {
          assume (forall i#72#207: int :: (0 <= i#72#207) && (i#72#207 < Seq#Length(old(Heap)[this#204, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#206, AVLTreeNode.keys], Seq#Index(callHeap#_379[this#204, AVLTreeNode.keys], i#72#207)) || (Seq#Index(callHeap#_379[this#204, AVLTreeNode.keys], i#72#207) == k#205)));
        } else {
        }
        if (!(r#206 == null)) {
          assume (forall i#73#208: int :: (0 <= i#73#208) && (i#73#208 < Seq#Length(Heap[r#206, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_379[this#204, AVLTreeNode.keys], Seq#Index(Heap[r#206, AVLTreeNode.keys], i#73#208)) && (!(Seq#Index(Heap[r#206, AVLTreeNode.keys], i#73#208) == k#205)));
        } else {
        }
        if (!Seq#Contains(callHeap#_379[this#204, AVLTreeNode.keys], k#205)) {
          assume Seq#Equal(Heap[r#206, AVLTreeNode.keys], callHeap#_379[this#204, AVLTreeNode.keys]);
        } else {
        }
        if (!(r#206 == null)) {
          if (Seq#Contains(callHeap#_379[this#204, AVLTreeNode.keys], k#205)) {
            assume Seq#Length(Heap[r#206, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this#204, AVLTreeNode.keys]) - 1);
          } else {
          }
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nl#28 := r#206;
        // update field left
        assert {:msg "  308.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
        Heap[this, AVLTreeNode.left] := nl#28;
        assume wf(Heap, Mask);
        // local var bf
        // call getBalanceFactorI
        callHeap#_388 := Heap;
        callMask#_389 := Mask;
        callCredits#_390 := Credits;
        assert {:msg "  311.6: The target of the method call might be null."} this != null;
        this#209 := this;
        // begin exhale (precondition)
        exhaleMask#_391 := Mask;
        epsilons#_392 := 1;
        assert {:msg "  311.6: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_391[this#209, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_392 <= exhaleMask#_391[this#209, AVLTreeNode.left][perm$N]);
        if ((exhaleMask#_391[this#209, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_391[this#209, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_391[this#209, AVLTreeNode.left] := exhaleMask#_391[this#209, AVLTreeNode.left][perm$N := exhaleMask#_391[this#209, AVLTreeNode.left][perm$N] - epsilons#_392];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_391);
        if (!(Heap[this#209, AVLTreeNode.left] == null)) {
          fraction#_393 := 100;
          assert {:msg "  311.6: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_393 <= exhaleMask#_391[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_393 == exhaleMask#_391[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_391[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_391[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_391[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_391[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_393];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_391);
        } else {
        }
        epsilons#_394 := 1;
        assert {:msg "  311.6: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_391[this#209, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_394 <= exhaleMask#_391[this#209, AVLTreeNode.right][perm$N]);
        if ((exhaleMask#_391[this#209, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_391[this#209, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_391[this#209, AVLTreeNode.right] := exhaleMask#_391[this#209, AVLTreeNode.right][perm$N := exhaleMask#_391[this#209, AVLTreeNode.right][perm$N] - epsilons#_394];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_391);
        if (!(Heap[this#209, AVLTreeNode.right] == null)) {
          fraction#_395 := 100;
          assert {:msg "  311.6: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_395 <= exhaleMask#_391[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_395 == exhaleMask#_391[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_391[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_391[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_391[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_391[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_395];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_391);
        } else {
        }
        Mask := exhaleMask#_391;
        assume wf(Heap, Mask);
        // end exhale
        havoc bf#210;
        // inhale (postcondition)
        havoc inhaleHeap#_398;
        assume IsGoodInhaleState(inhaleHeap#_398, Heap, Mask);
        assume this#209 != null;
        Heap[this#209, AVLTreeNode.left] := inhaleHeap#_398[this#209, AVLTreeNode.left];
        assume wf(Heap, Mask);
        assume (Heap[this#209, AVLTreeNode.left] == null) || (dtype(Heap[this#209, AVLTreeNode.left]) == AVLTreeNode#t);
        if ((Mask[this#209, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#209, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          Mask[this#209, AVLTreeNode.left] := Mask[this#209, AVLTreeNode.left][perm$N := Mask[this#209, AVLTreeNode.left][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_398[this#209, AVLTreeNode.left]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_398, Mask);
        if (!(Heap[this#209, AVLTreeNode.left] == null)) {
          assume Heap[this#209, AVLTreeNode.left] != null;
          Heap[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_398[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_398[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_398[Heap[this#209, AVLTreeNode.left], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_398, Mask);
        } else {
        }
        assume this#209 != null;
        Heap[this#209, AVLTreeNode.right] := inhaleHeap#_398[this#209, AVLTreeNode.right];
        assume wf(Heap, Mask);
        assume (Heap[this#209, AVLTreeNode.right] == null) || (dtype(Heap[this#209, AVLTreeNode.right]) == AVLTreeNode#t);
        if ((Mask[this#209, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#209, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          Mask[this#209, AVLTreeNode.right] := Mask[this#209, AVLTreeNode.right][perm$N := Mask[this#209, AVLTreeNode.right][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_398[this#209, AVLTreeNode.right]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_398, Mask);
        if (!(Heap[this#209, AVLTreeNode.right] == null)) {
          assume Heap[this#209, AVLTreeNode.right] != null;
          Heap[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_398[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_398[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_398[Heap[this#209, AVLTreeNode.right], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_398, Mask);
        } else {
        }
        if (bf#210 > 0) {
          assume !(Heap[this#209, AVLTreeNode.left] == null);
        } else {
        }
        if (bf#210 < 0) {
          assume !(Heap[this#209, AVLTreeNode.right] == null);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        bf#30 := bf#210;
        // if
        if (bf#30 == (0 - 2)) {
          // call rebalanceRight
          callHeap#_399 := Heap;
          callMask#_400 := Mask;
          callCredits#_401 := Credits;
          assert {:msg "  314.7: The target of the method call might be null."} this != null;
          this#211 := this;
          // begin exhale (precondition)
          exhaleMask#_402 := Mask;
          fraction#_403 := 100;
          assert {:msg "  314.7: The precondition at 741.12 might not hold. Insufficient fraction at 741.12 for AVLTreeNode.key."} (fraction#_403 <= exhaleMask#_402[this#211, AVLTreeNode.key][perm$R]) && ((fraction#_403 == exhaleMask#_402[this#211, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_402[this#211, AVLTreeNode.key][perm$N]));
          exhaleMask#_402[this#211, AVLTreeNode.key] := exhaleMask#_402[this#211, AVLTreeNode.key][perm$R := exhaleMask#_402[this#211, AVLTreeNode.key][perm$R] - fraction#_403];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_402);
          fraction#_404 := 100;
          assert {:msg "  314.7: The precondition at 743.12 might not hold. Insufficient fraction at 743.12 for AVLTreeNode.left."} (fraction#_404 <= exhaleMask#_402[this#211, AVLTreeNode.left][perm$R]) && ((fraction#_404 == exhaleMask#_402[this#211, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_402[this#211, AVLTreeNode.left][perm$N]));
          exhaleMask#_402[this#211, AVLTreeNode.left] := exhaleMask#_402[this#211, AVLTreeNode.left][perm$R := exhaleMask#_402[this#211, AVLTreeNode.left][perm$R] - fraction#_404];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_402);
          fraction#_405 := 100;
          assert {:msg "  314.7: The precondition at 744.12 might not hold. Insufficient fraction at 744.12 for AVLTreeNode.right."} (fraction#_405 <= exhaleMask#_402[this#211, AVLTreeNode.right][perm$R]) && ((fraction#_405 == exhaleMask#_402[this#211, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_402[this#211, AVLTreeNode.right][perm$N]));
          exhaleMask#_402[this#211, AVLTreeNode.right] := exhaleMask#_402[this#211, AVLTreeNode.right][perm$R := exhaleMask#_402[this#211, AVLTreeNode.right][perm$R] - fraction#_405];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_402);
          fraction#_406 := 100;
          assert {:msg "  314.7: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.keys."} (fraction#_406 <= exhaleMask#_402[this#211, AVLTreeNode.keys][perm$R]) && ((fraction#_406 == exhaleMask#_402[this#211, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_402[this#211, AVLTreeNode.keys][perm$N]));
          exhaleMask#_402[this#211, AVLTreeNode.keys] := exhaleMask#_402[this#211, AVLTreeNode.keys][perm$R := exhaleMask#_402[this#211, AVLTreeNode.keys][perm$R] - fraction#_406];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_402);
          if (!(Heap[this#211, AVLTreeNode.left] == null)) {
            fraction#_407 := 100;
            assert {:msg "  314.7: The precondition at 749.12 might not hold. Insufficient fraction at 749.25 for AVLTreeNode.valid."} (fraction#_407 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_407 == exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_407];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_402);
          } else {
          }
          if (!(Heap[this#211, AVLTreeNode.left] == null)) {
            fraction#_408 := 50;
            assert {:msg "  314.7: The precondition at 751.12 might not hold. Insufficient fraction at 751.25 for AVLTreeNode.keys."} (fraction#_408 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_408 == exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_402[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_408];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_402);
          } else {
          }
          if (!(Heap[this#211, AVLTreeNode.left] == null)) {
            assert {:msg "  314.7: The precondition at 753.12 might not hold. The expression at 753.25 might not evaluate to true."} (forall k#91#213: int :: (0 <= k#91#213) && (k#91#213 < Seq#Length(Heap[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#211, AVLTreeNode.left], AVLTreeNode.keys], k#91#213) < Heap[this#211, AVLTreeNode.key]));
          } else {
          }
          assert {:msg "  314.7: The precondition at 755.12 might not hold. The expression at 755.12 might not evaluate to true."} !(Heap[this#211, AVLTreeNode.right] == null);
          fraction#_409 := 100;
          assert {:msg "  314.7: The precondition at 756.12 might not hold. Insufficient fraction at 756.12 for AVLTreeNode.valid."} (fraction#_409 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_409 == exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_409];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_402);
          fraction#_410 := 50;
          assert {:msg "  314.7: The precondition at 758.12 might not hold. Insufficient fraction at 758.12 for AVLTreeNode.keys."} (fraction#_410 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_410 == exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_402[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_410];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_402);
          assert {:msg "  314.7: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} (forall k#92#214: int :: (0 <= k#92#214) && (k#92#214 < Seq#Length(Heap[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#211, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#211, AVLTreeNode.right], AVLTreeNode.keys], k#92#214)));
          Mask := exhaleMask#_402;
          assume wf(Heap, Mask);
          // end exhale
          havoc r#212;
          // inhale (postcondition)
          havoc inhaleHeap#_413;
          assume IsGoodInhaleState(inhaleHeap#_413, Heap, Mask);
          assume r#212 != null;
          Heap[r#212, AVLTreeNode.valid] := inhaleHeap#_413[r#212, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_413[r#212, AVLTreeNode.valid] == Heap;
          Mask[r#212, AVLTreeNode.valid] := Mask[r#212, AVLTreeNode.valid][perm$R := Mask[r#212, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_413[r#212, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_413, Mask);
          assume r#212 != null;
          Heap[r#212, AVLTreeNode.keys] := inhaleHeap#_413[r#212, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#212, AVLTreeNode.keys] := Mask[r#212, AVLTreeNode.keys][perm$R := Mask[r#212, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_413[r#212, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_413, Mask);
          assume Seq#Equal(Heap[r#212, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_399[this#211, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_399[callHeap#_399[this#211, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_399[this#211, AVLTreeNode.key])), callHeap#_399[callHeap#_399[this#211, AVLTreeNode.right], AVLTreeNode.keys]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          r#20 := r#212;
        } else {
          // call close
          callHeap#_414 := Heap;
          callMask#_415 := Mask;
          callCredits#_416 := Credits;
          assert {:msg "  316.7: The target of the method call might be null."} this != null;
          this#215 := this;
          // begin exhale (precondition)
          exhaleMask#_417 := Mask;
          fraction#_418 := 100;
          assert {:msg "  316.7: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_418 <= exhaleMask#_417[this#215, AVLTreeNode.key][perm$R]) && ((fraction#_418 == exhaleMask#_417[this#215, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_417[this#215, AVLTreeNode.key][perm$N]));
          exhaleMask#_417[this#215, AVLTreeNode.key] := exhaleMask#_417[this#215, AVLTreeNode.key][perm$R := exhaleMask#_417[this#215, AVLTreeNode.key][perm$R] - fraction#_418];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_419 := 100;
          assert {:msg "  316.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_419 <= exhaleMask#_417[this#215, AVLTreeNode.left][perm$R]) && ((fraction#_419 == exhaleMask#_417[this#215, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_417[this#215, AVLTreeNode.left][perm$N]));
          exhaleMask#_417[this#215, AVLTreeNode.left] := exhaleMask#_417[this#215, AVLTreeNode.left][perm$R := exhaleMask#_417[this#215, AVLTreeNode.left][perm$R] - fraction#_419];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_420 := 100;
          assert {:msg "  316.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_420 <= exhaleMask#_417[this#215, AVLTreeNode.right][perm$R]) && ((fraction#_420 == exhaleMask#_417[this#215, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_417[this#215, AVLTreeNode.right][perm$N]));
          exhaleMask#_417[this#215, AVLTreeNode.right] := exhaleMask#_417[this#215, AVLTreeNode.right][perm$R := exhaleMask#_417[this#215, AVLTreeNode.right][perm$R] - fraction#_420];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_421 := 100;
          assert {:msg "  316.7: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_421 <= exhaleMask#_417[this#215, AVLTreeNode.keys][perm$R]) && ((fraction#_421 == exhaleMask#_417[this#215, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_417[this#215, AVLTreeNode.keys][perm$N]));
          exhaleMask#_417[this#215, AVLTreeNode.keys] := exhaleMask#_417[this#215, AVLTreeNode.keys][perm$R := exhaleMask#_417[this#215, AVLTreeNode.keys][perm$R] - fraction#_421];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          if (!(Heap[this#215, AVLTreeNode.left] == null)) {
            fraction#_422 := 100;
            assert {:msg "  316.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_422 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_422 == exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_422];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#215, AVLTreeNode.left] == null)) {
            fraction#_423 := 50;
            assert {:msg "  316.7: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_423 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_423 == exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_417[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_423];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#215, AVLTreeNode.left] == null)) {
            assert {:msg "  316.7: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#216: int :: (0 <= k#79#216) && (k#79#216 < Seq#Length(Heap[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#215, AVLTreeNode.left], AVLTreeNode.keys], k#79#216) < Heap[this#215, AVLTreeNode.key]));
          } else {
          }
          if (!(Heap[this#215, AVLTreeNode.right] == null)) {
            fraction#_424 := 100;
            assert {:msg "  316.7: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_424 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_424 == exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_424];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#215, AVLTreeNode.right] == null)) {
            fraction#_425 := 50;
            assert {:msg "  316.7: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_425 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_425 == exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_417[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_425];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#215, AVLTreeNode.right] == null)) {
            assert {:msg "  316.7: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#217: int :: (0 <= k#80#217) && (k#80#217 < Seq#Length(Heap[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#215, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#215, AVLTreeNode.right], AVLTreeNode.keys], k#80#217)));
          } else {
          }
          Mask := exhaleMask#_417;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_428;
          assume IsGoodInhaleState(inhaleHeap#_428, Heap, Mask);
          assume this#215 != null;
          Heap[this#215, AVLTreeNode.valid] := inhaleHeap#_428[this#215, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_428[this#215, AVLTreeNode.valid] == Heap;
          Mask[this#215, AVLTreeNode.valid] := Mask[this#215, AVLTreeNode.valid][perm$R := Mask[this#215, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_428[this#215, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_428, Mask);
          assume this#215 != null;
          Heap[this#215, AVLTreeNode.keys] := inhaleHeap#_428[this#215, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[this#215, AVLTreeNode.keys] := Mask[this#215, AVLTreeNode.keys][perm$R := Mask[this#215, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_428[this#215, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_428, Mask);
          assume Seq#Equal(Heap[this#215, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_414[this#215, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_414[callHeap#_414[this#215, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_414[this#215, AVLTreeNode.key])), ite(callHeap#_414[this#215, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_414[callHeap#_414[this#215, AVLTreeNode.right], AVLTreeNode.keys])));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          // assigment to r
          r#20 := this;
        }
      } else {
        // assigment to r
        r#20 := this;
        // call close
        callHeap#_429 := Heap;
        callMask#_430 := Mask;
        callCredits#_431 := Credits;
        assert {:msg "  321.6: The target of the method call might be null."} r#20 != null;
        this#218 := r#20;
        // begin exhale (precondition)
        exhaleMask#_432 := Mask;
        fraction#_433 := 100;
        assert {:msg "  321.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_433 <= exhaleMask#_432[this#218, AVLTreeNode.key][perm$R]) && ((fraction#_433 == exhaleMask#_432[this#218, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_432[this#218, AVLTreeNode.key][perm$N]));
        exhaleMask#_432[this#218, AVLTreeNode.key] := exhaleMask#_432[this#218, AVLTreeNode.key][perm$R := exhaleMask#_432[this#218, AVLTreeNode.key][perm$R] - fraction#_433];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_432);
        fraction#_434 := 100;
        assert {:msg "  321.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_434 <= exhaleMask#_432[this#218, AVLTreeNode.left][perm$R]) && ((fraction#_434 == exhaleMask#_432[this#218, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_432[this#218, AVLTreeNode.left][perm$N]));
        exhaleMask#_432[this#218, AVLTreeNode.left] := exhaleMask#_432[this#218, AVLTreeNode.left][perm$R := exhaleMask#_432[this#218, AVLTreeNode.left][perm$R] - fraction#_434];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_432);
        fraction#_435 := 100;
        assert {:msg "  321.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_435 <= exhaleMask#_432[this#218, AVLTreeNode.right][perm$R]) && ((fraction#_435 == exhaleMask#_432[this#218, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_432[this#218, AVLTreeNode.right][perm$N]));
        exhaleMask#_432[this#218, AVLTreeNode.right] := exhaleMask#_432[this#218, AVLTreeNode.right][perm$R := exhaleMask#_432[this#218, AVLTreeNode.right][perm$R] - fraction#_435];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_432);
        fraction#_436 := 100;
        assert {:msg "  321.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_436 <= exhaleMask#_432[this#218, AVLTreeNode.keys][perm$R]) && ((fraction#_436 == exhaleMask#_432[this#218, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_432[this#218, AVLTreeNode.keys][perm$N]));
        exhaleMask#_432[this#218, AVLTreeNode.keys] := exhaleMask#_432[this#218, AVLTreeNode.keys][perm$R := exhaleMask#_432[this#218, AVLTreeNode.keys][perm$R] - fraction#_436];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_432);
        if (!(Heap[this#218, AVLTreeNode.left] == null)) {
          fraction#_437 := 100;
          assert {:msg "  321.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_437 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_437 == exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_437];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_432);
        } else {
        }
        if (!(Heap[this#218, AVLTreeNode.left] == null)) {
          fraction#_438 := 50;
          assert {:msg "  321.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_438 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_438 == exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_432[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_438];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_432);
        } else {
        }
        if (!(Heap[this#218, AVLTreeNode.left] == null)) {
          assert {:msg "  321.6: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#219: int :: (0 <= k#79#219) && (k#79#219 < Seq#Length(Heap[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#218, AVLTreeNode.left], AVLTreeNode.keys], k#79#219) < Heap[this#218, AVLTreeNode.key]));
        } else {
        }
        if (!(Heap[this#218, AVLTreeNode.right] == null)) {
          fraction#_439 := 100;
          assert {:msg "  321.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_439 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_439 == exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_439];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_432);
        } else {
        }
        if (!(Heap[this#218, AVLTreeNode.right] == null)) {
          fraction#_440 := 50;
          assert {:msg "  321.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_440 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_440 == exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_432[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_440];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_432);
        } else {
        }
        if (!(Heap[this#218, AVLTreeNode.right] == null)) {
          assert {:msg "  321.6: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#220: int :: (0 <= k#80#220) && (k#80#220 < Seq#Length(Heap[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#218, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#218, AVLTreeNode.right], AVLTreeNode.keys], k#80#220)));
        } else {
        }
        Mask := exhaleMask#_432;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_443;
        assume IsGoodInhaleState(inhaleHeap#_443, Heap, Mask);
        assume this#218 != null;
        Heap[this#218, AVLTreeNode.valid] := inhaleHeap#_443[this#218, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_443[this#218, AVLTreeNode.valid] == Heap;
        Mask[this#218, AVLTreeNode.valid] := Mask[this#218, AVLTreeNode.valid][perm$R := Mask[this#218, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_443[this#218, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_443, Mask);
        assume this#218 != null;
        Heap[this#218, AVLTreeNode.keys] := inhaleHeap#_443[this#218, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#218, AVLTreeNode.keys] := Mask[this#218, AVLTreeNode.keys][perm$R := Mask[this#218, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_443[this#218, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_443, Mask);
        assume Seq#Equal(Heap[this#218, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_429[this#218, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_429[callHeap#_429[this#218, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_429[this#218, AVLTreeNode.key])), ite(callHeap#_429[this#218, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_429[callHeap#_429[this#218, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    } else {
      // if
      assert {:msg "  324.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  324.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (!(Heap[this, AVLTreeNode.right] == null)) {
        // local var nr
        // call remove
        callHeap#_444 := Heap;
        callMask#_445 := Mask;
        callCredits#_446 := Credits;
        assert {:msg "  326.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  326.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  326.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#221 := Heap[this, AVLTreeNode.right];
        k#222 := k#19;
        // begin exhale (precondition)
        exhaleMask#_447 := Mask;
        fraction#_448 := 100;
        assert {:msg "  326.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (fraction#_448 <= exhaleMask#_447[this#221, AVLTreeNode.valid][perm$R]) && ((fraction#_448 == exhaleMask#_447[this#221, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_447[this#221, AVLTreeNode.valid][perm$N]));
        exhaleMask#_447[this#221, AVLTreeNode.valid] := exhaleMask#_447[this#221, AVLTreeNode.valid][perm$R := exhaleMask#_447[this#221, AVLTreeNode.valid][perm$R] - fraction#_448];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_447);
        fraction#_449 := 50;
        assert {:msg "  326.6: The precondition at 255.12 might not hold. Insufficient fraction at 255.12 for AVLTreeNode.keys."} (fraction#_449 <= exhaleMask#_447[this#221, AVLTreeNode.keys][perm$R]) && ((fraction#_449 == exhaleMask#_447[this#221, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_447[this#221, AVLTreeNode.keys][perm$N]));
        exhaleMask#_447[this#221, AVLTreeNode.keys] := exhaleMask#_447[this#221, AVLTreeNode.keys][perm$R := exhaleMask#_447[this#221, AVLTreeNode.keys][perm$R] - fraction#_449];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_447);
        Mask := exhaleMask#_447;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#223;
        // inhale (postcondition)
        havoc inhaleHeap#_452;
        assume IsGoodInhaleState(inhaleHeap#_452, Heap, Mask);
        if (Seq#Equal(callHeap#_444[this#221, AVLTreeNode.keys], Seq#Singleton(k#222))) {
          assume r#223 == null;
        } else {
        }
        if (!Seq#Equal(callHeap#_444[this#221, AVLTreeNode.keys], Seq#Singleton(k#222))) {
          assume !(r#223 == null);
        } else {
        }
        if (!(r#223 == null)) {
          assume r#223 != null;
          Heap[r#223, AVLTreeNode.valid] := inhaleHeap#_452[r#223, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_452[r#223, AVLTreeNode.valid] == Heap;
          Mask[r#223, AVLTreeNode.valid] := Mask[r#223, AVLTreeNode.valid][perm$R := Mask[r#223, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_452[r#223, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_452, Mask);
        } else {
        }
        if (!(r#223 == null)) {
          assume r#223 != null;
          Heap[r#223, AVLTreeNode.keys] := inhaleHeap#_452[r#223, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#223, AVLTreeNode.keys] := Mask[r#223, AVLTreeNode.keys][perm$R := Mask[r#223, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_452[r#223, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_452, Mask);
        } else {
        }
        if (!(r#223 == null)) {
          assume !Seq#Contains(Heap[r#223, AVLTreeNode.keys], k#222);
        } else {
        }
        if (!(r#223 == null)) {
          assume (forall i#72#224: int :: (0 <= i#72#224) && (i#72#224 < Seq#Length(old(Heap)[this#221, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#223, AVLTreeNode.keys], Seq#Index(callHeap#_444[this#221, AVLTreeNode.keys], i#72#224)) || (Seq#Index(callHeap#_444[this#221, AVLTreeNode.keys], i#72#224) == k#222)));
        } else {
        }
        if (!(r#223 == null)) {
          assume (forall i#73#225: int :: (0 <= i#73#225) && (i#73#225 < Seq#Length(Heap[r#223, AVLTreeNode.keys])) ==> Seq#Contains(callHeap#_444[this#221, AVLTreeNode.keys], Seq#Index(Heap[r#223, AVLTreeNode.keys], i#73#225)) && (!(Seq#Index(Heap[r#223, AVLTreeNode.keys], i#73#225) == k#222)));
        } else {
        }
        if (!Seq#Contains(callHeap#_444[this#221, AVLTreeNode.keys], k#222)) {
          assume Seq#Equal(Heap[r#223, AVLTreeNode.keys], callHeap#_444[this#221, AVLTreeNode.keys]);
        } else {
        }
        if (!(r#223 == null)) {
          if (Seq#Contains(callHeap#_444[this#221, AVLTreeNode.keys], k#222)) {
            assume Seq#Length(Heap[r#223, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this#221, AVLTreeNode.keys]) - 1);
          } else {
          }
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nr#32 := r#223;
        // update field right
        assert {:msg "  327.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
        Heap[this, AVLTreeNode.right] := nr#32;
        assume wf(Heap, Mask);
        // local var bf
        // call getBalanceFactorI
        callHeap#_453 := Heap;
        callMask#_454 := Mask;
        callCredits#_455 := Credits;
        assert {:msg "  330.6: The target of the method call might be null."} this != null;
        this#226 := this;
        // begin exhale (precondition)
        exhaleMask#_456 := Mask;
        epsilons#_457 := 1;
        assert {:msg "  330.6: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_456[this#226, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_457 <= exhaleMask#_456[this#226, AVLTreeNode.left][perm$N]);
        if ((exhaleMask#_456[this#226, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_456[this#226, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_456[this#226, AVLTreeNode.left] := exhaleMask#_456[this#226, AVLTreeNode.left][perm$N := exhaleMask#_456[this#226, AVLTreeNode.left][perm$N] - epsilons#_457];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_456);
        if (!(Heap[this#226, AVLTreeNode.left] == null)) {
          fraction#_458 := 100;
          assert {:msg "  330.6: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_458 <= exhaleMask#_456[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_458 == exhaleMask#_456[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_456[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_456[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_456[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_456[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_458];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_456);
        } else {
        }
        epsilons#_459 := 1;
        assert {:msg "  330.6: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_456[this#226, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_459 <= exhaleMask#_456[this#226, AVLTreeNode.right][perm$N]);
        if ((exhaleMask#_456[this#226, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_456[this#226, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_456[this#226, AVLTreeNode.right] := exhaleMask#_456[this#226, AVLTreeNode.right][perm$N := exhaleMask#_456[this#226, AVLTreeNode.right][perm$N] - epsilons#_459];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_456);
        if (!(Heap[this#226, AVLTreeNode.right] == null)) {
          fraction#_460 := 100;
          assert {:msg "  330.6: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_460 <= exhaleMask#_456[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_460 == exhaleMask#_456[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_456[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_456[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_456[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_456[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_460];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_456);
        } else {
        }
        Mask := exhaleMask#_456;
        assume wf(Heap, Mask);
        // end exhale
        havoc bf#227;
        // inhale (postcondition)
        havoc inhaleHeap#_463;
        assume IsGoodInhaleState(inhaleHeap#_463, Heap, Mask);
        assume this#226 != null;
        Heap[this#226, AVLTreeNode.left] := inhaleHeap#_463[this#226, AVLTreeNode.left];
        assume wf(Heap, Mask);
        assume (Heap[this#226, AVLTreeNode.left] == null) || (dtype(Heap[this#226, AVLTreeNode.left]) == AVLTreeNode#t);
        if ((Mask[this#226, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#226, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          Mask[this#226, AVLTreeNode.left] := Mask[this#226, AVLTreeNode.left][perm$N := Mask[this#226, AVLTreeNode.left][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_463[this#226, AVLTreeNode.left]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_463, Mask);
        if (!(Heap[this#226, AVLTreeNode.left] == null)) {
          assume Heap[this#226, AVLTreeNode.left] != null;
          Heap[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_463[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_463[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_463[Heap[this#226, AVLTreeNode.left], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_463, Mask);
        } else {
        }
        assume this#226 != null;
        Heap[this#226, AVLTreeNode.right] := inhaleHeap#_463[this#226, AVLTreeNode.right];
        assume wf(Heap, Mask);
        assume (Heap[this#226, AVLTreeNode.right] == null) || (dtype(Heap[this#226, AVLTreeNode.right]) == AVLTreeNode#t);
        if ((Mask[this#226, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#226, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          Mask[this#226, AVLTreeNode.right] := Mask[this#226, AVLTreeNode.right][perm$N := Mask[this#226, AVLTreeNode.right][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_463[this#226, AVLTreeNode.right]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_463, Mask);
        if (!(Heap[this#226, AVLTreeNode.right] == null)) {
          assume Heap[this#226, AVLTreeNode.right] != null;
          Heap[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_463[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_463[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_463[Heap[this#226, AVLTreeNode.right], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_463, Mask);
        } else {
        }
        if (bf#227 > 0) {
          assume !(Heap[this#226, AVLTreeNode.left] == null);
        } else {
        }
        if (bf#227 < 0) {
          assume !(Heap[this#226, AVLTreeNode.right] == null);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        bf#34 := bf#227;
        // if
        if (bf#34 == 2) {
          // call rebalanceLeft
          callHeap#_464 := Heap;
          callMask#_465 := Mask;
          callCredits#_466 := Credits;
          assert {:msg "  332.7: The target of the method call might be null."} this != null;
          this#228 := this;
          // begin exhale (precondition)
          exhaleMask#_467 := Mask;
          fraction#_468 := 100;
          assert {:msg "  332.7: The precondition at 598.12 might not hold. Insufficient fraction at 598.12 for AVLTreeNode.key."} (fraction#_468 <= exhaleMask#_467[this#228, AVLTreeNode.key][perm$R]) && ((fraction#_468 == exhaleMask#_467[this#228, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_467[this#228, AVLTreeNode.key][perm$N]));
          exhaleMask#_467[this#228, AVLTreeNode.key] := exhaleMask#_467[this#228, AVLTreeNode.key][perm$R := exhaleMask#_467[this#228, AVLTreeNode.key][perm$R] - fraction#_468];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_467);
          fraction#_469 := 100;
          assert {:msg "  332.7: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.left."} (fraction#_469 <= exhaleMask#_467[this#228, AVLTreeNode.left][perm$R]) && ((fraction#_469 == exhaleMask#_467[this#228, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_467[this#228, AVLTreeNode.left][perm$N]));
          exhaleMask#_467[this#228, AVLTreeNode.left] := exhaleMask#_467[this#228, AVLTreeNode.left][perm$R := exhaleMask#_467[this#228, AVLTreeNode.left][perm$R] - fraction#_469];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_467);
          fraction#_470 := 100;
          assert {:msg "  332.7: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.right."} (fraction#_470 <= exhaleMask#_467[this#228, AVLTreeNode.right][perm$R]) && ((fraction#_470 == exhaleMask#_467[this#228, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_467[this#228, AVLTreeNode.right][perm$N]));
          exhaleMask#_467[this#228, AVLTreeNode.right] := exhaleMask#_467[this#228, AVLTreeNode.right][perm$R := exhaleMask#_467[this#228, AVLTreeNode.right][perm$R] - fraction#_470];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_467);
          fraction#_471 := 100;
          assert {:msg "  332.7: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.keys."} (fraction#_471 <= exhaleMask#_467[this#228, AVLTreeNode.keys][perm$R]) && ((fraction#_471 == exhaleMask#_467[this#228, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_467[this#228, AVLTreeNode.keys][perm$N]));
          exhaleMask#_467[this#228, AVLTreeNode.keys] := exhaleMask#_467[this#228, AVLTreeNode.keys][perm$R := exhaleMask#_467[this#228, AVLTreeNode.keys][perm$R] - fraction#_471];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_467);
          assert {:msg "  332.7: The precondition at 606.12 might not hold. The expression at 606.12 might not evaluate to true."} !(Heap[this#228, AVLTreeNode.left] == null);
          fraction#_472 := 100;
          assert {:msg "  332.7: The precondition at 607.12 might not hold. Insufficient fraction at 607.12 for AVLTreeNode.valid."} (fraction#_472 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_472 == exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_472];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_467);
          fraction#_473 := 50;
          assert {:msg "  332.7: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.keys."} (fraction#_473 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_473 == exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_467[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_473];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_467);
          assert {:msg "  332.7: The precondition at 611.12 might not hold. The expression at 611.12 might not evaluate to true."} (forall k#81#230: int :: (0 <= k#81#230) && (k#81#230 < Seq#Length(Heap[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#228, AVLTreeNode.left], AVLTreeNode.keys], k#81#230) < Heap[this#228, AVLTreeNode.key]));
          if (!(Heap[this#228, AVLTreeNode.right] == null)) {
            fraction#_474 := 100;
            assert {:msg "  332.7: The precondition at 613.12 might not hold. Insufficient fraction at 613.28 for AVLTreeNode.valid."} (fraction#_474 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_474 == exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_474];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_467);
          } else {
          }
          if (!(Heap[this#228, AVLTreeNode.right] == null)) {
            fraction#_475 := 50;
            assert {:msg "  332.7: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.keys."} (fraction#_475 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_475 == exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_467[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_475];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_467);
          } else {
          }
          if (!(Heap[this#228, AVLTreeNode.right] == null)) {
            assert {:msg "  332.7: The precondition at 617.12 might not hold. The expression at 617.28 might not evaluate to true."} (forall k#82#231: int :: (0 <= k#82#231) && (k#82#231 < Seq#Length(Heap[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#228, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#228, AVLTreeNode.right], AVLTreeNode.keys], k#82#231)));
          } else {
          }
          Mask := exhaleMask#_467;
          assume wf(Heap, Mask);
          // end exhale
          havoc r#229;
          // inhale (postcondition)
          havoc inhaleHeap#_478;
          assume IsGoodInhaleState(inhaleHeap#_478, Heap, Mask);
          assume r#229 != null;
          Heap[r#229, AVLTreeNode.valid] := inhaleHeap#_478[r#229, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_478[r#229, AVLTreeNode.valid] == Heap;
          Mask[r#229, AVLTreeNode.valid] := Mask[r#229, AVLTreeNode.valid][perm$R := Mask[r#229, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_478[r#229, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_478, Mask);
          assume r#229 != null;
          Heap[r#229, AVLTreeNode.keys] := inhaleHeap#_478[r#229, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#229, AVLTreeNode.keys] := Mask[r#229, AVLTreeNode.keys][perm$R := Mask[r#229, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_478[r#229, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_478, Mask);
          assume Seq#Equal(Heap[r#229, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_464[callHeap#_464[this#228, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_464[this#228, AVLTreeNode.key])), ite(callHeap#_464[this#228, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_464[callHeap#_464[this#228, AVLTreeNode.right], AVLTreeNode.keys])));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          r#20 := r#229;
        } else {
          // assigment to r
          r#20 := this;
          // call close
          callHeap#_479 := Heap;
          callMask#_480 := Mask;
          callCredits#_481 := Credits;
          assert {:msg "  335.7: The target of the method call might be null."} r#20 != null;
          this#232 := r#20;
          // begin exhale (precondition)
          exhaleMask#_482 := Mask;
          fraction#_483 := 100;
          assert {:msg "  335.7: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_483 <= exhaleMask#_482[this#232, AVLTreeNode.key][perm$R]) && ((fraction#_483 == exhaleMask#_482[this#232, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_482[this#232, AVLTreeNode.key][perm$N]));
          exhaleMask#_482[this#232, AVLTreeNode.key] := exhaleMask#_482[this#232, AVLTreeNode.key][perm$R := exhaleMask#_482[this#232, AVLTreeNode.key][perm$R] - fraction#_483];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_482);
          fraction#_484 := 100;
          assert {:msg "  335.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_484 <= exhaleMask#_482[this#232, AVLTreeNode.left][perm$R]) && ((fraction#_484 == exhaleMask#_482[this#232, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_482[this#232, AVLTreeNode.left][perm$N]));
          exhaleMask#_482[this#232, AVLTreeNode.left] := exhaleMask#_482[this#232, AVLTreeNode.left][perm$R := exhaleMask#_482[this#232, AVLTreeNode.left][perm$R] - fraction#_484];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_482);
          fraction#_485 := 100;
          assert {:msg "  335.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_485 <= exhaleMask#_482[this#232, AVLTreeNode.right][perm$R]) && ((fraction#_485 == exhaleMask#_482[this#232, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_482[this#232, AVLTreeNode.right][perm$N]));
          exhaleMask#_482[this#232, AVLTreeNode.right] := exhaleMask#_482[this#232, AVLTreeNode.right][perm$R := exhaleMask#_482[this#232, AVLTreeNode.right][perm$R] - fraction#_485];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_482);
          fraction#_486 := 100;
          assert {:msg "  335.7: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_486 <= exhaleMask#_482[this#232, AVLTreeNode.keys][perm$R]) && ((fraction#_486 == exhaleMask#_482[this#232, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_482[this#232, AVLTreeNode.keys][perm$N]));
          exhaleMask#_482[this#232, AVLTreeNode.keys] := exhaleMask#_482[this#232, AVLTreeNode.keys][perm$R := exhaleMask#_482[this#232, AVLTreeNode.keys][perm$R] - fraction#_486];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_482);
          if (!(Heap[this#232, AVLTreeNode.left] == null)) {
            fraction#_487 := 100;
            assert {:msg "  335.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_487 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_487 == exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_487];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_482);
          } else {
          }
          if (!(Heap[this#232, AVLTreeNode.left] == null)) {
            fraction#_488 := 50;
            assert {:msg "  335.7: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_488 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_488 == exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
            exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_482[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_488];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_482);
          } else {
          }
          if (!(Heap[this#232, AVLTreeNode.left] == null)) {
            assert {:msg "  335.7: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#233: int :: (0 <= k#79#233) && (k#79#233 < Seq#Length(Heap[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#232, AVLTreeNode.left], AVLTreeNode.keys], k#79#233) < Heap[this#232, AVLTreeNode.key]));
          } else {
          }
          if (!(Heap[this#232, AVLTreeNode.right] == null)) {
            fraction#_489 := 100;
            assert {:msg "  335.7: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_489 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_489 == exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_489];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_482);
          } else {
          }
          if (!(Heap[this#232, AVLTreeNode.right] == null)) {
            fraction#_490 := 50;
            assert {:msg "  335.7: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_490 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_490 == exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
            exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_482[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_490];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_482);
          } else {
          }
          if (!(Heap[this#232, AVLTreeNode.right] == null)) {
            assert {:msg "  335.7: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#234: int :: (0 <= k#80#234) && (k#80#234 < Seq#Length(Heap[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#232, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#232, AVLTreeNode.right], AVLTreeNode.keys], k#80#234)));
          } else {
          }
          Mask := exhaleMask#_482;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_493;
          assume IsGoodInhaleState(inhaleHeap#_493, Heap, Mask);
          assume this#232 != null;
          Heap[this#232, AVLTreeNode.valid] := inhaleHeap#_493[this#232, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_493[this#232, AVLTreeNode.valid] == Heap;
          Mask[this#232, AVLTreeNode.valid] := Mask[this#232, AVLTreeNode.valid][perm$R := Mask[this#232, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_493[this#232, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_493, Mask);
          assume this#232 != null;
          Heap[this#232, AVLTreeNode.keys] := inhaleHeap#_493[this#232, AVLTreeNode.keys];
          assume wf(Heap, Mask);
          assume true;
          Mask[this#232, AVLTreeNode.keys] := Mask[this#232, AVLTreeNode.keys][perm$R := Mask[this#232, AVLTreeNode.keys][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_493[this#232, AVLTreeNode.keys]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_493, Mask);
          assume Seq#Equal(Heap[this#232, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_479[this#232, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_479[callHeap#_479[this#232, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_479[this#232, AVLTreeNode.key])), ite(callHeap#_479[this#232, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_479[callHeap#_479[this#232, AVLTreeNode.right], AVLTreeNode.keys])));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
        }
      } else {
        // assigment to r
        r#20 := this;
        // call close
        callHeap#_494 := Heap;
        callMask#_495 := Mask;
        callCredits#_496 := Credits;
        assert {:msg "  339.6: The target of the method call might be null."} r#20 != null;
        this#235 := r#20;
        // begin exhale (precondition)
        exhaleMask#_497 := Mask;
        fraction#_498 := 100;
        assert {:msg "  339.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_498 <= exhaleMask#_497[this#235, AVLTreeNode.key][perm$R]) && ((fraction#_498 == exhaleMask#_497[this#235, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_497[this#235, AVLTreeNode.key][perm$N]));
        exhaleMask#_497[this#235, AVLTreeNode.key] := exhaleMask#_497[this#235, AVLTreeNode.key][perm$R := exhaleMask#_497[this#235, AVLTreeNode.key][perm$R] - fraction#_498];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_497);
        fraction#_499 := 100;
        assert {:msg "  339.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_499 <= exhaleMask#_497[this#235, AVLTreeNode.left][perm$R]) && ((fraction#_499 == exhaleMask#_497[this#235, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_497[this#235, AVLTreeNode.left][perm$N]));
        exhaleMask#_497[this#235, AVLTreeNode.left] := exhaleMask#_497[this#235, AVLTreeNode.left][perm$R := exhaleMask#_497[this#235, AVLTreeNode.left][perm$R] - fraction#_499];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_497);
        fraction#_500 := 100;
        assert {:msg "  339.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_500 <= exhaleMask#_497[this#235, AVLTreeNode.right][perm$R]) && ((fraction#_500 == exhaleMask#_497[this#235, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_497[this#235, AVLTreeNode.right][perm$N]));
        exhaleMask#_497[this#235, AVLTreeNode.right] := exhaleMask#_497[this#235, AVLTreeNode.right][perm$R := exhaleMask#_497[this#235, AVLTreeNode.right][perm$R] - fraction#_500];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_497);
        fraction#_501 := 100;
        assert {:msg "  339.6: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_501 <= exhaleMask#_497[this#235, AVLTreeNode.keys][perm$R]) && ((fraction#_501 == exhaleMask#_497[this#235, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_497[this#235, AVLTreeNode.keys][perm$N]));
        exhaleMask#_497[this#235, AVLTreeNode.keys] := exhaleMask#_497[this#235, AVLTreeNode.keys][perm$R := exhaleMask#_497[this#235, AVLTreeNode.keys][perm$R] - fraction#_501];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_497);
        if (!(Heap[this#235, AVLTreeNode.left] == null)) {
          fraction#_502 := 100;
          assert {:msg "  339.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_502 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_502 == exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_502];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_497);
        } else {
        }
        if (!(Heap[this#235, AVLTreeNode.left] == null)) {
          fraction#_503 := 50;
          assert {:msg "  339.6: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_503 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_503 == exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
          exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_497[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_503];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_497);
        } else {
        }
        if (!(Heap[this#235, AVLTreeNode.left] == null)) {
          assert {:msg "  339.6: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#236: int :: (0 <= k#79#236) && (k#79#236 < Seq#Length(Heap[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#235, AVLTreeNode.left], AVLTreeNode.keys], k#79#236) < Heap[this#235, AVLTreeNode.key]));
        } else {
        }
        if (!(Heap[this#235, AVLTreeNode.right] == null)) {
          fraction#_504 := 100;
          assert {:msg "  339.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_504 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_504 == exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_504];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_497);
        } else {
        }
        if (!(Heap[this#235, AVLTreeNode.right] == null)) {
          fraction#_505 := 50;
          assert {:msg "  339.6: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_505 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_505 == exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
          exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_497[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_505];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_497);
        } else {
        }
        if (!(Heap[this#235, AVLTreeNode.right] == null)) {
          assert {:msg "  339.6: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#237: int :: (0 <= k#80#237) && (k#80#237 < Seq#Length(Heap[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#235, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#235, AVLTreeNode.right], AVLTreeNode.keys], k#80#237)));
        } else {
        }
        Mask := exhaleMask#_497;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_508;
        assume IsGoodInhaleState(inhaleHeap#_508, Heap, Mask);
        assume this#235 != null;
        Heap[this#235, AVLTreeNode.valid] := inhaleHeap#_508[this#235, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_508[this#235, AVLTreeNode.valid] == Heap;
        Mask[this#235, AVLTreeNode.valid] := Mask[this#235, AVLTreeNode.valid][perm$R := Mask[this#235, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_508[this#235, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_508, Mask);
        assume this#235 != null;
        Heap[this#235, AVLTreeNode.keys] := inhaleHeap#_508[this#235, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#235, AVLTreeNode.keys] := Mask[this#235, AVLTreeNode.keys][perm$R := Mask[this#235, AVLTreeNode.keys][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_508[this#235, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_508, Mask);
        assume Seq#Equal(Heap[this#235, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_494[this#235, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_494[callHeap#_494[this#235, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_494[this#235, AVLTreeNode.key])), ite(callHeap#_494[this#235, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_494[callHeap#_494[this#235, AVLTreeNode.right], AVLTreeNode.keys])));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_509 := Mask;
  if (Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assert {:msg "  253.2: The postcondition at 259.11 might not hold. The expression at 259.30 might not evaluate to true."} r#20 == null;
  } else {
  }
  if (!Seq#Equal(old(Heap)[this, AVLTreeNode.keys], Seq#Singleton(k#19))) {
    assert {:msg "  253.2: The postcondition at 260.11 might not hold. The expression at 260.30 might not evaluate to true."} !(r#20 == null);
  } else {
  }
  if (!(r#20 == null)) {
    fraction#_510 := 100;
    assert {:msg "  253.2: The postcondition at 262.11 might not hold. Insufficient fraction at 262.25 for AVLTreeNode.valid."} (fraction#_510 <= exhaleMask#_509[r#20, AVLTreeNode.valid][perm$R]) && ((fraction#_510 == exhaleMask#_509[r#20, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_509[r#20, AVLTreeNode.valid][perm$N]));
    exhaleMask#_509[r#20, AVLTreeNode.valid] := exhaleMask#_509[r#20, AVLTreeNode.valid][perm$R := exhaleMask#_509[r#20, AVLTreeNode.valid][perm$R] - fraction#_510];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_509);
  } else {
  }
  if (!(r#20 == null)) {
    fraction#_511 := 50;
    assert {:msg "  253.2: The postcondition at 263.11 might not hold. Insufficient fraction at 263.25 for AVLTreeNode.keys."} (fraction#_511 <= exhaleMask#_509[r#20, AVLTreeNode.keys][perm$R]) && ((fraction#_511 == exhaleMask#_509[r#20, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_509[r#20, AVLTreeNode.keys][perm$N]));
    exhaleMask#_509[r#20, AVLTreeNode.keys] := exhaleMask#_509[r#20, AVLTreeNode.keys][perm$R := exhaleMask#_509[r#20, AVLTreeNode.keys][perm$R] - fraction#_511];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_509);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 267.11 might not hold. The expression at 267.25 might not evaluate to true."} !Seq#Contains(Heap[r#20, AVLTreeNode.keys], k#19);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 268.11 might not hold. The expression at 268.25 might not evaluate to true."} (forall i#72#238: int :: (0 <= i#72#238) && (i#72#238 < Seq#Length(old(Heap)[this, AVLTreeNode.keys])) ==> (Seq#Contains(Heap[r#20, AVLTreeNode.keys], Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#238)) || (Seq#Index(old(Heap)[this, AVLTreeNode.keys], i#72#238) == k#19)));
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 269.11 might not hold. The expression at 269.25 might not evaluate to true."} (forall i#73#239: int :: (0 <= i#73#239) && (i#73#239 < Seq#Length(Heap[r#20, AVLTreeNode.keys])) ==> Seq#Contains(old(Heap)[this, AVLTreeNode.keys], Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#239)) && (!(Seq#Index(Heap[r#20, AVLTreeNode.keys], i#73#239) == k#19)));
  } else {
  }
  if (!Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
    assert {:msg "  253.2: The postcondition at 270.11 might not hold. The expression at 270.34 might not evaluate to true."} Seq#Equal(Heap[r#20, AVLTreeNode.keys], old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  if (!(r#20 == null)) {
    if (Seq#Contains(old(Heap)[this, AVLTreeNode.keys], k#19)) {
      assert {:msg "  253.2: The postcondition at 271.11 might not hold. The expression at 271.45 might not evaluate to true."} Seq#Length(Heap[r#20, AVLTreeNode.keys]) == (Seq#Length(old(Heap)[this, AVLTreeNode.keys]) - 1);
    } else {
    }
  } else {
  }
  Mask := exhaleMask#_509;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  253.2: Method might lock/unlock more than allowed."} (forall lk#_512: ref :: {Heap[lk#_512, held]} {Heap[lk#_512, rdheld]} (((0 < Heap[lk#_512, held]) == (0 < old(Heap)[lk#_512, held])) && (Heap[lk#_512, rdheld] == old(Heap)[lk#_512, rdheld])) || false);
  assert {:msg "  253.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.pruneMax$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_513: HeapType;
  var inhaleHeap#_514: HeapType;
  var k#74#241: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_513;
  assume IsGoodInhaleState(inhaleHeap#_513, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_513[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_513[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_513[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_513, Mask);
  assert {:msg "  349.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  349.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_513[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_513[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_513, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_514;
  assume IsGoodInhaleState(inhaleHeap#_514, Heap, Mask);
  if (!(r#35 == null)) {
    assume r#35 != null;
    Heap[r#35, AVLTreeNode.valid] := inhaleHeap#_514[r#35, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_514[r#35, AVLTreeNode.valid] == Heap;
    Mask[r#35, AVLTreeNode.valid] := Mask[r#35, AVLTreeNode.valid][perm$R := Mask[r#35, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_514[r#35, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_514, Mask);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  354.38: Fraction might be negative."} 0 <= 50;
    assert {:msg "  354.38: Fraction might exceed 100."} 50 <= 100;
    assume r#35 != null;
    Heap[r#35, AVLTreeNode.keys] := inhaleHeap#_514[r#35, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#35, AVLTreeNode.keys] := Mask[r#35, AVLTreeNode.keys][perm$R := Mask[r#35, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_514[r#35, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_514, Mask);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  358.25: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  358.25: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.keys);
    assert {:msg "  358.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  358.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume (Seq#Length(Heap[r#35, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  assume !(m#36 == null);
  assume m#36 != null;
  Heap[m#36, AVLTreeNode.valid] := inhaleHeap#_514[m#36, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_514[m#36, AVLTreeNode.valid] == Heap;
  Mask[m#36, AVLTreeNode.valid] := Mask[m#36, AVLTreeNode.valid][perm$R := Mask[m#36, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_514[m#36, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_514, Mask);
  assert {:msg "  365.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  365.24: Fraction might exceed 100."} 50 <= 100;
  assume m#36 != null;
  Heap[m#36, AVLTreeNode.keys] := inhaleHeap#_514[m#36, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[m#36, AVLTreeNode.keys] := Mask[m#36, AVLTreeNode.keys][perm$R := Mask[m#36, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_514[m#36, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_514, Mask);
  assert {:msg "  369.12: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  369.12: Location might not be readable."} true ==> CanRead(Mask, m#36, AVLTreeNode.keys);
  assume Seq#Length(Heap[m#36, AVLTreeNode.keys]) == 1;
  if (r#35 == null) {
  } else {
    assert {:msg "  371.29: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  371.29: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.keys);
  }
  assert {:msg "  371.40: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  371.40: Location might not be readable."} true ==> CanRead(Mask, m#36, AVLTreeNode.keys);
  assert {:msg "  371.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  371.54: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assume Seq#Equal(Seq#Append(ite(r#35 == null, Seq#Empty(), Heap[r#35, AVLTreeNode.keys]), Heap[m#36, AVLTreeNode.keys]), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#35 == null)) {
    assert {:msg "  372.11: Receiver might be null."} true && (0 <= k#74#241) ==> (r#35 != null);
    assert {:msg "  372.11: Location might not be readable."} true && (0 <= k#74#241) ==> CanRead(Mask, r#35, AVLTreeNode.keys);
    assert {:msg "  372.11: Receiver might be null."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
    assert {:msg "  372.11: Location might not be readable."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask, r#35, AVLTreeNode.keys);
    assert {:msg "  372.45: Sequence index might be negative."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= k#74#241);
    assert {:msg "  372.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys]));
    assert {:msg "  372.49: Receiver might be null."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
    assert {:msg "  372.49: Location might not be readable."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask, m#36, AVLTreeNode.keys);
    assert {:msg "  372.49: Sequence index might be negative."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
    assert {:msg "  372.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#74#241) && (k#74#241 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap[m#36, AVLTreeNode.keys]));
    assume (forall k#74#240: int :: (0 <= k#74#240) && (k#74#240 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#35, AVLTreeNode.keys], k#74#240) < Seq#Index(Heap[m#36, AVLTreeNode.keys], 0)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.pruneMax(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_515: HeapType;
  var exhaleMask#_516: MaskType;
  var fraction#_517: int;
  var inhaleHeap#_518: HeapType;
  var this#244: ref where (this#244 == null) || (dtype(this#244) == AVLTreeNode#t);
  var callHeap#_519: HeapType;
  var callMask#_520: MaskType;
  var callCredits#_521: CreditsType;
  var exhaleMask#_522: MaskType;
  var fraction#_523: int;
  var fraction#_524: int;
  var fraction#_525: int;
  var fraction#_526: int;
  var fraction#_527: int;
  var fraction#_528: int;
  var fraction#_529: int;
  var fraction#_530: int;
  var isHeld#_531: int;
  var isRdHeld#_532: bool;
  var inhaleHeap#_533: HeapType;
  var Heap#_537: HeapType;
  var Mask#_538: MaskType;
  var Credits#_539: CreditsType;
  var exhaleMask#_540: MaskType;
  var k#75#248: int where true;
  var nr#38: ref where (nr#38 == null) || (dtype(nr#38) == AVLTreeNode#t);
  var this#249: ref where (this#249 == null) || (dtype(this#249) == AVLTreeNode#t);
  var r#250: ref where (r#250 == null) || (dtype(r#250) == AVLTreeNode#t);
  var m#251: ref where (m#251 == null) || (dtype(m#251) == AVLTreeNode#t);
  var callHeap#_541: HeapType;
  var callMask#_542: MaskType;
  var callCredits#_543: CreditsType;
  var exhaleMask#_544: MaskType;
  var fraction#_545: int;
  var fraction#_546: int;
  var isHeld#_547: int;
  var isRdHeld#_548: bool;
  var inhaleHeap#_549: HeapType;
  var bf#40: int where true;
  var this#253: ref where (this#253 == null) || (dtype(this#253) == AVLTreeNode#t);
  var bf#254: int where true;
  var callHeap#_550: HeapType;
  var callMask#_551: MaskType;
  var callCredits#_552: CreditsType;
  var exhaleMask#_553: MaskType;
  var epsilons#_554: int;
  var fraction#_555: int;
  var epsilons#_556: int;
  var fraction#_557: int;
  var isHeld#_558: int;
  var isRdHeld#_559: bool;
  var inhaleHeap#_560: HeapType;
  var this#255: ref where (this#255 == null) || (dtype(this#255) == AVLTreeNode#t);
  var r#256: ref where (r#256 == null) || (dtype(r#256) == AVLTreeNode#t);
  var callHeap#_561: HeapType;
  var callMask#_562: MaskType;
  var callCredits#_563: CreditsType;
  var exhaleMask#_564: MaskType;
  var fraction#_565: int;
  var fraction#_566: int;
  var fraction#_567: int;
  var fraction#_568: int;
  var fraction#_569: int;
  var fraction#_570: int;
  var fraction#_571: int;
  var fraction#_572: int;
  var isHeld#_573: int;
  var isRdHeld#_574: bool;
  var inhaleHeap#_575: HeapType;
  var this#259: ref where (this#259 == null) || (dtype(this#259) == AVLTreeNode#t);
  var callHeap#_576: HeapType;
  var callMask#_577: MaskType;
  var callCredits#_578: CreditsType;
  var exhaleMask#_579: MaskType;
  var fraction#_580: int;
  var fraction#_581: int;
  var fraction#_582: int;
  var fraction#_583: int;
  var fraction#_584: int;
  var fraction#_585: int;
  var fraction#_586: int;
  var fraction#_587: int;
  var isHeld#_588: int;
  var isRdHeld#_589: bool;
  var inhaleHeap#_590: HeapType;
  var Heap#_594: HeapType;
  var Mask#_595: MaskType;
  var Credits#_596: CreditsType;
  var exhaleMask#_597: MaskType;
  var k#76#263: int where true;
  var exhaleMask#_598: MaskType;
  var fraction#_599: int;
  var fraction#_600: int;
  var fraction#_601: int;
  var fraction#_602: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_515;
  assume IsGoodInhaleState(inhaleHeap#_515, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_515[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_515[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_515[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_515, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_515[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_515[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_515, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  374.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_516 := Mask;
  fraction#_517 := 100;
  assert {:msg "  374.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_517 <= exhaleMask#_516[this, AVLTreeNode.valid][perm$R]) && ((fraction#_517 == exhaleMask#_516[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_516[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_516[this, AVLTreeNode.valid] := exhaleMask#_516[this, AVLTreeNode.valid][perm$R := exhaleMask#_516[this, AVLTreeNode.valid][perm$R] - fraction#_517];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_516);
  Mask := exhaleMask#_516;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_518 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_518, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_518[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_518[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_518, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_518[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_518[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_518, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_518[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_518[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_518, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_518[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_518[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_518, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_518[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_518[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_518[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_518, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_518[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_518[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_518, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#242: int :: (0 <= lk#67#242) && (lk#67#242 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#242) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_518[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_518[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_518[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_518, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_518[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_518[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_518, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#243: int :: (0 <= rk#68#243) && (rk#68#243 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#243)));
  } else {
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  376.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  376.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
    // assigment to r
    assert {:msg "  377.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  377.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    r#35 := Heap[this, AVLTreeNode.left];
    // update field left
    assert {:msg "  378.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := null;
    assume wf(Heap, Mask);
    // call close
    callHeap#_519 := Heap;
    callMask#_520 := Mask;
    callCredits#_521 := Credits;
    assert {:msg "  379.4: The target of the method call might be null."} this != null;
    this#244 := this;
    // begin exhale (precondition)
    exhaleMask#_522 := Mask;
    fraction#_523 := 100;
    assert {:msg "  379.4: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_523 <= exhaleMask#_522[this#244, AVLTreeNode.key][perm$R]) && ((fraction#_523 == exhaleMask#_522[this#244, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_522[this#244, AVLTreeNode.key][perm$N]));
    exhaleMask#_522[this#244, AVLTreeNode.key] := exhaleMask#_522[this#244, AVLTreeNode.key][perm$R := exhaleMask#_522[this#244, AVLTreeNode.key][perm$R] - fraction#_523];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_522);
    fraction#_524 := 100;
    assert {:msg "  379.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_524 <= exhaleMask#_522[this#244, AVLTreeNode.left][perm$R]) && ((fraction#_524 == exhaleMask#_522[this#244, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_522[this#244, AVLTreeNode.left][perm$N]));
    exhaleMask#_522[this#244, AVLTreeNode.left] := exhaleMask#_522[this#244, AVLTreeNode.left][perm$R := exhaleMask#_522[this#244, AVLTreeNode.left][perm$R] - fraction#_524];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_522);
    fraction#_525 := 100;
    assert {:msg "  379.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_525 <= exhaleMask#_522[this#244, AVLTreeNode.right][perm$R]) && ((fraction#_525 == exhaleMask#_522[this#244, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_522[this#244, AVLTreeNode.right][perm$N]));
    exhaleMask#_522[this#244, AVLTreeNode.right] := exhaleMask#_522[this#244, AVLTreeNode.right][perm$R := exhaleMask#_522[this#244, AVLTreeNode.right][perm$R] - fraction#_525];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_522);
    fraction#_526 := 100;
    assert {:msg "  379.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_526 <= exhaleMask#_522[this#244, AVLTreeNode.keys][perm$R]) && ((fraction#_526 == exhaleMask#_522[this#244, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_522[this#244, AVLTreeNode.keys][perm$N]));
    exhaleMask#_522[this#244, AVLTreeNode.keys] := exhaleMask#_522[this#244, AVLTreeNode.keys][perm$R := exhaleMask#_522[this#244, AVLTreeNode.keys][perm$R] - fraction#_526];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_522);
    if (!(Heap[this#244, AVLTreeNode.left] == null)) {
      fraction#_527 := 100;
      assert {:msg "  379.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_527 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_527 == exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_527];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_522);
    } else {
    }
    if (!(Heap[this#244, AVLTreeNode.left] == null)) {
      fraction#_528 := 50;
      assert {:msg "  379.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_528 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_528 == exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_522[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_528];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_522);
    } else {
    }
    if (!(Heap[this#244, AVLTreeNode.left] == null)) {
      assert {:msg "  379.4: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#245: int :: (0 <= k#79#245) && (k#79#245 < Seq#Length(Heap[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#244, AVLTreeNode.left], AVLTreeNode.keys], k#79#245) < Heap[this#244, AVLTreeNode.key]));
    } else {
    }
    if (!(Heap[this#244, AVLTreeNode.right] == null)) {
      fraction#_529 := 100;
      assert {:msg "  379.4: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_529 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_529 == exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_529];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_522);
    } else {
    }
    if (!(Heap[this#244, AVLTreeNode.right] == null)) {
      fraction#_530 := 50;
      assert {:msg "  379.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_530 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_530 == exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_522[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_530];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_522);
    } else {
    }
    if (!(Heap[this#244, AVLTreeNode.right] == null)) {
      assert {:msg "  379.4: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#246: int :: (0 <= k#80#246) && (k#80#246 < Seq#Length(Heap[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#244, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#244, AVLTreeNode.right], AVLTreeNode.keys], k#80#246)));
    } else {
    }
    Mask := exhaleMask#_522;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_533;
    assume IsGoodInhaleState(inhaleHeap#_533, Heap, Mask);
    assume this#244 != null;
    Heap[this#244, AVLTreeNode.valid] := inhaleHeap#_533[this#244, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_533[this#244, AVLTreeNode.valid] == Heap;
    Mask[this#244, AVLTreeNode.valid] := Mask[this#244, AVLTreeNode.valid][perm$R := Mask[this#244, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_533[this#244, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_533, Mask);
    assume this#244 != null;
    Heap[this#244, AVLTreeNode.keys] := inhaleHeap#_533[this#244, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#244, AVLTreeNode.keys] := Mask[this#244, AVLTreeNode.keys][perm$R := Mask[this#244, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_533[this#244, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_533, Mask);
    assume Seq#Equal(Heap[this#244, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_519[this#244, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_519[callHeap#_519[this#244, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_519[this#244, AVLTreeNode.key])), ite(callHeap#_519[this#244, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_519[callHeap#_519[this#244, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // assigment to m
    m#36 := this;
    // assert
    Heap#_537 := Heap;
    Mask#_538 := Mask;
    Credits#_539 := Credits;
    // begin exhale (assert)
    exhaleMask#_540 := Mask#_538;
    if (!(r#35 == null)) {
      assert {:msg "  381.11: Receiver might be null."} true && (0 <= k#75#248) ==> (r#35 != null);
      assert {:msg "  381.11: Location might not be readable."} true && (0 <= k#75#248) ==> CanRead(Mask#_538, r#35, AVLTreeNode.keys);
      assert {:msg "  381.11: Receiver might be null."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
      assert {:msg "  381.11: Location might not be readable."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask#_538, r#35, AVLTreeNode.keys);
      assert {:msg "  381.45: Sequence index might be negative."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= k#75#248);
      assert {:msg "  381.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (k#75#248 < Seq#Length(Heap#_537[r#35, AVLTreeNode.keys]));
      assert {:msg "  381.49: Receiver might be null."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
      assert {:msg "  381.49: Location might not be readable."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask#_538, m#36, AVLTreeNode.keys);
      assert {:msg "  381.49: Sequence index might be negative."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  381.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#75#248) && (k#75#248 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap#_537[m#36, AVLTreeNode.keys]));
      assert {:msg "  381.4: Assertion might not hold. The expression at 381.23 might not evaluate to true."} (forall k#75#247: int :: (0 <= k#75#247) && (k#75#247 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap#_537[r#35, AVLTreeNode.keys], k#75#247) < Seq#Index(Heap#_537[m#36, AVLTreeNode.keys], 0)));
    } else {
    }
    Mask#_538 := exhaleMask#_540;
    assume wf(Heap#_537, Mask#_538);
    // end exhale
  } else {
    // local var nr
    // call pruneMax
    callHeap#_541 := Heap;
    callMask#_542 := Mask;
    callCredits#_543 := Credits;
    assert {:msg "  385.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  385.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  385.4: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
    this#249 := Heap[this, AVLTreeNode.right];
    // begin exhale (precondition)
    exhaleMask#_544 := Mask;
    fraction#_545 := 100;
    assert {:msg "  385.4: The precondition at 348.12 might not hold. Insufficient fraction at 348.12 for AVLTreeNode.valid."} (fraction#_545 <= exhaleMask#_544[this#249, AVLTreeNode.valid][perm$R]) && ((fraction#_545 == exhaleMask#_544[this#249, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_544[this#249, AVLTreeNode.valid][perm$N]));
    exhaleMask#_544[this#249, AVLTreeNode.valid] := exhaleMask#_544[this#249, AVLTreeNode.valid][perm$R := exhaleMask#_544[this#249, AVLTreeNode.valid][perm$R] - fraction#_545];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_544);
    fraction#_546 := 50;
    assert {:msg "  385.4: The precondition at 349.12 might not hold. Insufficient fraction at 349.12 for AVLTreeNode.keys."} (fraction#_546 <= exhaleMask#_544[this#249, AVLTreeNode.keys][perm$R]) && ((fraction#_546 == exhaleMask#_544[this#249, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_544[this#249, AVLTreeNode.keys][perm$N]));
    exhaleMask#_544[this#249, AVLTreeNode.keys] := exhaleMask#_544[this#249, AVLTreeNode.keys][perm$R := exhaleMask#_544[this#249, AVLTreeNode.keys][perm$R] - fraction#_546];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_544);
    Mask := exhaleMask#_544;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#250;
    havoc m#251;
    // inhale (postcondition)
    havoc inhaleHeap#_549;
    assume IsGoodInhaleState(inhaleHeap#_549, Heap, Mask);
    if (!(r#250 == null)) {
      assume r#250 != null;
      Heap[r#250, AVLTreeNode.valid] := inhaleHeap#_549[r#250, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_549[r#250, AVLTreeNode.valid] == Heap;
      Mask[r#250, AVLTreeNode.valid] := Mask[r#250, AVLTreeNode.valid][perm$R := Mask[r#250, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_549[r#250, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_549, Mask);
    } else {
    }
    if (!(r#250 == null)) {
      assume r#250 != null;
      Heap[r#250, AVLTreeNode.keys] := inhaleHeap#_549[r#250, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#250, AVLTreeNode.keys] := Mask[r#250, AVLTreeNode.keys][perm$R := Mask[r#250, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_549[r#250, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_549, Mask);
    } else {
    }
    if (!(r#250 == null)) {
      assume (Seq#Length(Heap[r#250, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this#249, AVLTreeNode.keys]);
    } else {
    }
    assume !(m#251 == null);
    assume m#251 != null;
    Heap[m#251, AVLTreeNode.valid] := inhaleHeap#_549[m#251, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_549[m#251, AVLTreeNode.valid] == Heap;
    Mask[m#251, AVLTreeNode.valid] := Mask[m#251, AVLTreeNode.valid][perm$R := Mask[m#251, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_549[m#251, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_549, Mask);
    assume m#251 != null;
    Heap[m#251, AVLTreeNode.keys] := inhaleHeap#_549[m#251, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[m#251, AVLTreeNode.keys] := Mask[m#251, AVLTreeNode.keys][perm$R := Mask[m#251, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_549[m#251, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_549, Mask);
    assume Seq#Length(Heap[m#251, AVLTreeNode.keys]) == 1;
    assume Seq#Equal(Seq#Append(ite(r#250 == null, Seq#Empty(), Heap[r#250, AVLTreeNode.keys]), Heap[m#251, AVLTreeNode.keys]), callHeap#_541[this#249, AVLTreeNode.keys]);
    if (!(r#250 == null)) {
      assume (forall k#74#252: int :: (0 <= k#74#252) && (k#74#252 < Seq#Length(Heap[r#250, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#250, AVLTreeNode.keys], k#74#252) < Seq#Index(Heap[m#251, AVLTreeNode.keys], 0)));
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    nr#38 := r#250;
    m#36 := m#251;
    // update field right
    assert {:msg "  386.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := nr#38;
    assume wf(Heap, Mask);
    // local var bf
    // call getBalanceFactorI
    callHeap#_550 := Heap;
    callMask#_551 := Mask;
    callCredits#_552 := Credits;
    assert {:msg "  388.4: The target of the method call might be null."} this != null;
    this#253 := this;
    // begin exhale (precondition)
    exhaleMask#_553 := Mask;
    epsilons#_554 := 1;
    assert {:msg "  388.4: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_553[this#253, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_554 <= exhaleMask#_553[this#253, AVLTreeNode.left][perm$N]);
    if ((exhaleMask#_553[this#253, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_553[this#253, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_553[this#253, AVLTreeNode.left] := exhaleMask#_553[this#253, AVLTreeNode.left][perm$N := exhaleMask#_553[this#253, AVLTreeNode.left][perm$N] - epsilons#_554];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_553);
    if (!(Heap[this#253, AVLTreeNode.left] == null)) {
      fraction#_555 := 100;
      assert {:msg "  388.4: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_555 <= exhaleMask#_553[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_555 == exhaleMask#_553[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_553[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_553[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_553[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_553[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_555];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_553);
    } else {
    }
    epsilons#_556 := 1;
    assert {:msg "  388.4: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_553[this#253, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_556 <= exhaleMask#_553[this#253, AVLTreeNode.right][perm$N]);
    if ((exhaleMask#_553[this#253, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_553[this#253, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_553[this#253, AVLTreeNode.right] := exhaleMask#_553[this#253, AVLTreeNode.right][perm$N := exhaleMask#_553[this#253, AVLTreeNode.right][perm$N] - epsilons#_556];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_553);
    if (!(Heap[this#253, AVLTreeNode.right] == null)) {
      fraction#_557 := 100;
      assert {:msg "  388.4: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_557 <= exhaleMask#_553[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_557 == exhaleMask#_553[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_553[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_553[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_553[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_553[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_557];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_553);
    } else {
    }
    Mask := exhaleMask#_553;
    assume wf(Heap, Mask);
    // end exhale
    havoc bf#254;
    // inhale (postcondition)
    havoc inhaleHeap#_560;
    assume IsGoodInhaleState(inhaleHeap#_560, Heap, Mask);
    assume this#253 != null;
    Heap[this#253, AVLTreeNode.left] := inhaleHeap#_560[this#253, AVLTreeNode.left];
    assume wf(Heap, Mask);
    assume (Heap[this#253, AVLTreeNode.left] == null) || (dtype(Heap[this#253, AVLTreeNode.left]) == AVLTreeNode#t);
    if ((Mask[this#253, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#253, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      Mask[this#253, AVLTreeNode.left] := Mask[this#253, AVLTreeNode.left][perm$N := Mask[this#253, AVLTreeNode.left][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_560[this#253, AVLTreeNode.left]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_560, Mask);
    if (!(Heap[this#253, AVLTreeNode.left] == null)) {
      assume Heap[this#253, AVLTreeNode.left] != null;
      Heap[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_560[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_560[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_560[Heap[this#253, AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_560, Mask);
    } else {
    }
    assume this#253 != null;
    Heap[this#253, AVLTreeNode.right] := inhaleHeap#_560[this#253, AVLTreeNode.right];
    assume wf(Heap, Mask);
    assume (Heap[this#253, AVLTreeNode.right] == null) || (dtype(Heap[this#253, AVLTreeNode.right]) == AVLTreeNode#t);
    if ((Mask[this#253, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#253, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      Mask[this#253, AVLTreeNode.right] := Mask[this#253, AVLTreeNode.right][perm$N := Mask[this#253, AVLTreeNode.right][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_560[this#253, AVLTreeNode.right]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_560, Mask);
    if (!(Heap[this#253, AVLTreeNode.right] == null)) {
      assume Heap[this#253, AVLTreeNode.right] != null;
      Heap[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_560[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_560[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_560[Heap[this#253, AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_560, Mask);
    } else {
    }
    if (bf#254 > 0) {
      assume !(Heap[this#253, AVLTreeNode.left] == null);
    } else {
    }
    if (bf#254 < 0) {
      assume !(Heap[this#253, AVLTreeNode.right] == null);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    bf#40 := bf#254;
    // if
    if (bf#40 == 2) {
      // call rebalanceLeft
      callHeap#_561 := Heap;
      callMask#_562 := Mask;
      callCredits#_563 := Credits;
      assert {:msg "  390.5: The target of the method call might be null."} this != null;
      this#255 := this;
      // begin exhale (precondition)
      exhaleMask#_564 := Mask;
      fraction#_565 := 100;
      assert {:msg "  390.5: The precondition at 598.12 might not hold. Insufficient fraction at 598.12 for AVLTreeNode.key."} (fraction#_565 <= exhaleMask#_564[this#255, AVLTreeNode.key][perm$R]) && ((fraction#_565 == exhaleMask#_564[this#255, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_564[this#255, AVLTreeNode.key][perm$N]));
      exhaleMask#_564[this#255, AVLTreeNode.key] := exhaleMask#_564[this#255, AVLTreeNode.key][perm$R := exhaleMask#_564[this#255, AVLTreeNode.key][perm$R] - fraction#_565];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_564);
      fraction#_566 := 100;
      assert {:msg "  390.5: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.left."} (fraction#_566 <= exhaleMask#_564[this#255, AVLTreeNode.left][perm$R]) && ((fraction#_566 == exhaleMask#_564[this#255, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_564[this#255, AVLTreeNode.left][perm$N]));
      exhaleMask#_564[this#255, AVLTreeNode.left] := exhaleMask#_564[this#255, AVLTreeNode.left][perm$R := exhaleMask#_564[this#255, AVLTreeNode.left][perm$R] - fraction#_566];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_564);
      fraction#_567 := 100;
      assert {:msg "  390.5: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.right."} (fraction#_567 <= exhaleMask#_564[this#255, AVLTreeNode.right][perm$R]) && ((fraction#_567 == exhaleMask#_564[this#255, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_564[this#255, AVLTreeNode.right][perm$N]));
      exhaleMask#_564[this#255, AVLTreeNode.right] := exhaleMask#_564[this#255, AVLTreeNode.right][perm$R := exhaleMask#_564[this#255, AVLTreeNode.right][perm$R] - fraction#_567];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_564);
      fraction#_568 := 100;
      assert {:msg "  390.5: The precondition at 603.12 might not hold. Insufficient fraction at 603.12 for AVLTreeNode.keys."} (fraction#_568 <= exhaleMask#_564[this#255, AVLTreeNode.keys][perm$R]) && ((fraction#_568 == exhaleMask#_564[this#255, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_564[this#255, AVLTreeNode.keys][perm$N]));
      exhaleMask#_564[this#255, AVLTreeNode.keys] := exhaleMask#_564[this#255, AVLTreeNode.keys][perm$R := exhaleMask#_564[this#255, AVLTreeNode.keys][perm$R] - fraction#_568];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_564);
      assert {:msg "  390.5: The precondition at 606.12 might not hold. The expression at 606.12 might not evaluate to true."} !(Heap[this#255, AVLTreeNode.left] == null);
      fraction#_569 := 100;
      assert {:msg "  390.5: The precondition at 607.12 might not hold. Insufficient fraction at 607.12 for AVLTreeNode.valid."} (fraction#_569 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_569 == exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_569];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_564);
      fraction#_570 := 50;
      assert {:msg "  390.5: The precondition at 609.12 might not hold. Insufficient fraction at 609.12 for AVLTreeNode.keys."} (fraction#_570 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_570 == exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_564[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_570];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_564);
      assert {:msg "  390.5: The precondition at 611.12 might not hold. The expression at 611.12 might not evaluate to true."} (forall k#81#257: int :: (0 <= k#81#257) && (k#81#257 < Seq#Length(Heap[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#255, AVLTreeNode.left], AVLTreeNode.keys], k#81#257) < Heap[this#255, AVLTreeNode.key]));
      if (!(Heap[this#255, AVLTreeNode.right] == null)) {
        fraction#_571 := 100;
        assert {:msg "  390.5: The precondition at 613.12 might not hold. Insufficient fraction at 613.28 for AVLTreeNode.valid."} (fraction#_571 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_571 == exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_571];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_564);
      } else {
      }
      if (!(Heap[this#255, AVLTreeNode.right] == null)) {
        fraction#_572 := 50;
        assert {:msg "  390.5: The precondition at 615.12 might not hold. Insufficient fraction at 615.28 for AVLTreeNode.keys."} (fraction#_572 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_572 == exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_564[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_572];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_564);
      } else {
      }
      if (!(Heap[this#255, AVLTreeNode.right] == null)) {
        assert {:msg "  390.5: The precondition at 617.12 might not hold. The expression at 617.28 might not evaluate to true."} (forall k#82#258: int :: (0 <= k#82#258) && (k#82#258 < Seq#Length(Heap[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#255, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#255, AVLTreeNode.right], AVLTreeNode.keys], k#82#258)));
      } else {
      }
      Mask := exhaleMask#_564;
      assume wf(Heap, Mask);
      // end exhale
      havoc r#256;
      // inhale (postcondition)
      havoc inhaleHeap#_575;
      assume IsGoodInhaleState(inhaleHeap#_575, Heap, Mask);
      assume r#256 != null;
      Heap[r#256, AVLTreeNode.valid] := inhaleHeap#_575[r#256, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_575[r#256, AVLTreeNode.valid] == Heap;
      Mask[r#256, AVLTreeNode.valid] := Mask[r#256, AVLTreeNode.valid][perm$R := Mask[r#256, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_575[r#256, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_575, Mask);
      assume r#256 != null;
      Heap[r#256, AVLTreeNode.keys] := inhaleHeap#_575[r#256, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#256, AVLTreeNode.keys] := Mask[r#256, AVLTreeNode.keys][perm$R := Mask[r#256, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_575[r#256, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_575, Mask);
      assume Seq#Equal(Heap[r#256, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_561[callHeap#_561[this#255, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_561[this#255, AVLTreeNode.key])), ite(callHeap#_561[this#255, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_561[callHeap#_561[this#255, AVLTreeNode.right], AVLTreeNode.keys])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      r#35 := r#256;
    } else {
      // call close
      callHeap#_576 := Heap;
      callMask#_577 := Mask;
      callCredits#_578 := Credits;
      assert {:msg "  392.5: The target of the method call might be null."} this != null;
      this#259 := this;
      // begin exhale (precondition)
      exhaleMask#_579 := Mask;
      fraction#_580 := 100;
      assert {:msg "  392.5: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_580 <= exhaleMask#_579[this#259, AVLTreeNode.key][perm$R]) && ((fraction#_580 == exhaleMask#_579[this#259, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_579[this#259, AVLTreeNode.key][perm$N]));
      exhaleMask#_579[this#259, AVLTreeNode.key] := exhaleMask#_579[this#259, AVLTreeNode.key][perm$R := exhaleMask#_579[this#259, AVLTreeNode.key][perm$R] - fraction#_580];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_579);
      fraction#_581 := 100;
      assert {:msg "  392.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_581 <= exhaleMask#_579[this#259, AVLTreeNode.left][perm$R]) && ((fraction#_581 == exhaleMask#_579[this#259, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_579[this#259, AVLTreeNode.left][perm$N]));
      exhaleMask#_579[this#259, AVLTreeNode.left] := exhaleMask#_579[this#259, AVLTreeNode.left][perm$R := exhaleMask#_579[this#259, AVLTreeNode.left][perm$R] - fraction#_581];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_579);
      fraction#_582 := 100;
      assert {:msg "  392.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_582 <= exhaleMask#_579[this#259, AVLTreeNode.right][perm$R]) && ((fraction#_582 == exhaleMask#_579[this#259, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_579[this#259, AVLTreeNode.right][perm$N]));
      exhaleMask#_579[this#259, AVLTreeNode.right] := exhaleMask#_579[this#259, AVLTreeNode.right][perm$R := exhaleMask#_579[this#259, AVLTreeNode.right][perm$R] - fraction#_582];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_579);
      fraction#_583 := 100;
      assert {:msg "  392.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_583 <= exhaleMask#_579[this#259, AVLTreeNode.keys][perm$R]) && ((fraction#_583 == exhaleMask#_579[this#259, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_579[this#259, AVLTreeNode.keys][perm$N]));
      exhaleMask#_579[this#259, AVLTreeNode.keys] := exhaleMask#_579[this#259, AVLTreeNode.keys][perm$R := exhaleMask#_579[this#259, AVLTreeNode.keys][perm$R] - fraction#_583];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_579);
      if (!(Heap[this#259, AVLTreeNode.left] == null)) {
        fraction#_584 := 100;
        assert {:msg "  392.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_584 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_584 == exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_584];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_579);
      } else {
      }
      if (!(Heap[this#259, AVLTreeNode.left] == null)) {
        fraction#_585 := 50;
        assert {:msg "  392.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_585 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_585 == exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_579[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_585];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_579);
      } else {
      }
      if (!(Heap[this#259, AVLTreeNode.left] == null)) {
        assert {:msg "  392.5: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#260: int :: (0 <= k#79#260) && (k#79#260 < Seq#Length(Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#259, AVLTreeNode.left], AVLTreeNode.keys], k#79#260) < Heap[this#259, AVLTreeNode.key]));
      } else {
      }
      if (!(Heap[this#259, AVLTreeNode.right] == null)) {
        fraction#_586 := 100;
        assert {:msg "  392.5: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_586 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_586 == exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_586];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_579);
      } else {
      }
      if (!(Heap[this#259, AVLTreeNode.right] == null)) {
        fraction#_587 := 50;
        assert {:msg "  392.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_587 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_587 == exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_579[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_587];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_579);
      } else {
      }
      if (!(Heap[this#259, AVLTreeNode.right] == null)) {
        assert {:msg "  392.5: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#261: int :: (0 <= k#80#261) && (k#80#261 < Seq#Length(Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#259, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#259, AVLTreeNode.right], AVLTreeNode.keys], k#80#261)));
      } else {
      }
      Mask := exhaleMask#_579;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_590;
      assume IsGoodInhaleState(inhaleHeap#_590, Heap, Mask);
      assume this#259 != null;
      Heap[this#259, AVLTreeNode.valid] := inhaleHeap#_590[this#259, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_590[this#259, AVLTreeNode.valid] == Heap;
      Mask[this#259, AVLTreeNode.valid] := Mask[this#259, AVLTreeNode.valid][perm$R := Mask[this#259, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_590[this#259, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_590, Mask);
      assume this#259 != null;
      Heap[this#259, AVLTreeNode.keys] := inhaleHeap#_590[this#259, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#259, AVLTreeNode.keys] := Mask[this#259, AVLTreeNode.keys][perm$R := Mask[this#259, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_590[this#259, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_590, Mask);
      assume Seq#Equal(Heap[this#259, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_576[this#259, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_576[callHeap#_576[this#259, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_576[this#259, AVLTreeNode.key])), ite(callHeap#_576[this#259, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_576[callHeap#_576[this#259, AVLTreeNode.right], AVLTreeNode.keys])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // assigment to r
      r#35 := this;
    }
    // assert
    Heap#_594 := Heap;
    Mask#_595 := Mask;
    Credits#_596 := Credits;
    // begin exhale (assert)
    exhaleMask#_597 := Mask#_595;
    if (!(r#35 == null)) {
      assert {:msg "  395.11: Receiver might be null."} true && (0 <= k#76#263) ==> (r#35 != null);
      assert {:msg "  395.11: Location might not be readable."} true && (0 <= k#76#263) ==> CanRead(Mask#_595, r#35, AVLTreeNode.keys);
      assert {:msg "  395.11: Receiver might be null."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (r#35 != null);
      assert {:msg "  395.11: Location might not be readable."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask#_595, r#35, AVLTreeNode.keys);
      assert {:msg "  395.45: Sequence index might be negative."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= k#76#263);
      assert {:msg "  395.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (k#76#263 < Seq#Length(Heap#_594[r#35, AVLTreeNode.keys]));
      assert {:msg "  395.49: Receiver might be null."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (m#36 != null);
      assert {:msg "  395.49: Location might not be readable."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> CanRead(Mask#_595, m#36, AVLTreeNode.keys);
      assert {:msg "  395.49: Sequence index might be negative."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  395.49: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#76#263) && (k#76#263 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap#_594[m#36, AVLTreeNode.keys]));
      assert {:msg "  395.4: Assertion might not hold. The expression at 395.23 might not evaluate to true."} (forall k#76#262: int :: (0 <= k#76#262) && (k#76#262 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap#_594[r#35, AVLTreeNode.keys], k#76#262) < Seq#Index(Heap#_594[m#36, AVLTreeNode.keys], 0)));
    } else {
    }
    Mask#_595 := exhaleMask#_597;
    assume wf(Heap#_594, Mask#_595);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_598 := Mask;
  if (!(r#35 == null)) {
    fraction#_599 := 100;
    assert {:msg "  347.2: The postcondition at 353.11 might not hold. Insufficient fraction at 353.25 for AVLTreeNode.valid."} (fraction#_599 <= exhaleMask#_598[r#35, AVLTreeNode.valid][perm$R]) && ((fraction#_599 == exhaleMask#_598[r#35, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_598[r#35, AVLTreeNode.valid][perm$N]));
    exhaleMask#_598[r#35, AVLTreeNode.valid] := exhaleMask#_598[r#35, AVLTreeNode.valid][perm$R := exhaleMask#_598[r#35, AVLTreeNode.valid][perm$R] - fraction#_599];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_598);
  } else {
  }
  if (!(r#35 == null)) {
    fraction#_600 := 50;
    assert {:msg "  347.2: The postcondition at 354.11 might not hold. Insufficient fraction at 354.25 for AVLTreeNode.keys."} (fraction#_600 <= exhaleMask#_598[r#35, AVLTreeNode.keys][perm$R]) && ((fraction#_600 == exhaleMask#_598[r#35, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_598[r#35, AVLTreeNode.keys][perm$N]));
    exhaleMask#_598[r#35, AVLTreeNode.keys] := exhaleMask#_598[r#35, AVLTreeNode.keys][perm$R := exhaleMask#_598[r#35, AVLTreeNode.keys][perm$R] - fraction#_600];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_598);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  347.2: The postcondition at 358.11 might not hold. The expression at 358.24 might not evaluate to true."} (Seq#Length(Heap[r#35, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  assert {:msg "  347.2: The postcondition at 363.11 might not hold. The expression at 363.11 might not evaluate to true."} !(m#36 == null);
  fraction#_601 := 100;
  assert {:msg "  347.2: The postcondition at 364.11 might not hold. Insufficient fraction at 364.11 for AVLTreeNode.valid."} (fraction#_601 <= exhaleMask#_598[m#36, AVLTreeNode.valid][perm$R]) && ((fraction#_601 == exhaleMask#_598[m#36, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_598[m#36, AVLTreeNode.valid][perm$N]));
  exhaleMask#_598[m#36, AVLTreeNode.valid] := exhaleMask#_598[m#36, AVLTreeNode.valid][perm$R := exhaleMask#_598[m#36, AVLTreeNode.valid][perm$R] - fraction#_601];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_598);
  fraction#_602 := 50;
  assert {:msg "  347.2: The postcondition at 365.11 might not hold. Insufficient fraction at 365.11 for AVLTreeNode.keys."} (fraction#_602 <= exhaleMask#_598[m#36, AVLTreeNode.keys][perm$R]) && ((fraction#_602 == exhaleMask#_598[m#36, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_598[m#36, AVLTreeNode.keys][perm$N]));
  exhaleMask#_598[m#36, AVLTreeNode.keys] := exhaleMask#_598[m#36, AVLTreeNode.keys][perm$R := exhaleMask#_598[m#36, AVLTreeNode.keys][perm$R] - fraction#_602];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_598);
  assert {:msg "  347.2: The postcondition at 369.11 might not hold. The expression at 369.11 might not evaluate to true."} Seq#Length(Heap[m#36, AVLTreeNode.keys]) == 1;
  assert {:msg "  347.2: The postcondition at 371.11 might not hold. The expression at 371.11 might not evaluate to true."} Seq#Equal(Seq#Append(ite(r#35 == null, Seq#Empty(), Heap[r#35, AVLTreeNode.keys]), Heap[m#36, AVLTreeNode.keys]), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#35 == null)) {
    assert {:msg "  347.2: The postcondition at 372.11 might not hold. The expression at 372.23 might not evaluate to true."} (forall k#74#264: int :: (0 <= k#74#264) && (k#74#264 < Seq#Length(Heap[r#35, AVLTreeNode.keys])) ==> (Seq#Index(Heap[r#35, AVLTreeNode.keys], k#74#264) < Seq#Index(Heap[m#36, AVLTreeNode.keys], 0)));
  } else {
  }
  Mask := exhaleMask#_598;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  347.2: Method might lock/unlock more than allowed."} (forall lk#_603: ref :: {Heap[lk#_603, held]} {Heap[lk#_603, rdheld]} (((0 < Heap[lk#_603, held]) == (0 < old(Heap)[lk#_603, held])) && (Heap[lk#_603, rdheld] == old(Heap)[lk#_603, rdheld])) || false);
  assert {:msg "  347.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.pruneMin$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_604: HeapType;
  var inhaleHeap#_605: HeapType;
  var k#77#266: int where true;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_604;
  assume IsGoodInhaleState(inhaleHeap#_604, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_604[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_604[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_604[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_604, Mask);
  assert {:msg "  403.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  403.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_604[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_604[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_604, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_605;
  assume IsGoodInhaleState(inhaleHeap#_605, Heap, Mask);
  if (!(r#41 == null)) {
    assume r#41 != null;
    Heap[r#41, AVLTreeNode.valid] := inhaleHeap#_605[r#41, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_605[r#41, AVLTreeNode.valid] == Heap;
    Mask[r#41, AVLTreeNode.valid] := Mask[r#41, AVLTreeNode.valid][perm$R := Mask[r#41, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_605[r#41, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_605, Mask);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  408.38: Fraction might be negative."} 0 <= 50;
    assert {:msg "  408.38: Fraction might exceed 100."} 50 <= 100;
    assume r#41 != null;
    Heap[r#41, AVLTreeNode.keys] := inhaleHeap#_605[r#41, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#41, AVLTreeNode.keys] := Mask[r#41, AVLTreeNode.keys][perm$R := Mask[r#41, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_605[r#41, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_605, Mask);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  412.25: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  412.25: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.keys);
    assert {:msg "  412.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  412.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
    assume (Seq#Length(Heap[r#41, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  assume !(m#42 == null);
  assume m#42 != null;
  Heap[m#42, AVLTreeNode.valid] := inhaleHeap#_605[m#42, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_605[m#42, AVLTreeNode.valid] == Heap;
  Mask[m#42, AVLTreeNode.valid] := Mask[m#42, AVLTreeNode.valid][perm$R := Mask[m#42, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_605[m#42, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_605, Mask);
  assert {:msg "  419.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  419.24: Fraction might exceed 100."} 50 <= 100;
  assume m#42 != null;
  Heap[m#42, AVLTreeNode.keys] := inhaleHeap#_605[m#42, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[m#42, AVLTreeNode.keys] := Mask[m#42, AVLTreeNode.keys][perm$R := Mask[m#42, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_605[m#42, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_605, Mask);
  assert {:msg "  423.12: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  423.12: Location might not be readable."} true ==> CanRead(Mask, m#42, AVLTreeNode.keys);
  assume Seq#Length(Heap[m#42, AVLTreeNode.keys]) == 1;
  assert {:msg "  425.11: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  425.11: Location might not be readable."} true ==> CanRead(Mask, m#42, AVLTreeNode.keys);
  if (r#41 == null) {
  } else {
    assert {:msg "  425.39: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  425.39: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.keys);
  }
  assert {:msg "  425.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  425.54: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.keys);
  assume Seq#Equal(Seq#Append(Heap[m#42, AVLTreeNode.keys], ite(r#41 == null, Seq#Empty(), Heap[r#41, AVLTreeNode.keys])), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#41 == null)) {
    assert {:msg "  426.11: Receiver might be null."} true && (0 <= k#77#266) ==> (r#41 != null);
    assert {:msg "  426.11: Location might not be readable."} true && (0 <= k#77#266) ==> CanRead(Mask, r#41, AVLTreeNode.keys);
    assert {:msg "  426.45: Receiver might be null."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
    assert {:msg "  426.45: Location might not be readable."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask, m#42, AVLTreeNode.keys);
    assert {:msg "  426.45: Sequence index might be negative."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
    assert {:msg "  426.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap[m#42, AVLTreeNode.keys]));
    assert {:msg "  426.11: Receiver might be null."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
    assert {:msg "  426.11: Location might not be readable."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask, r#41, AVLTreeNode.keys);
    assert {:msg "  426.57: Sequence index might be negative."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= k#77#266);
    assert {:msg "  426.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#77#266) && (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (k#77#266 < Seq#Length(Heap[r#41, AVLTreeNode.keys]));
    assume (forall k#77#265: int :: (0 <= k#77#265) && (k#77#265 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#41, AVLTreeNode.keys], k#77#265)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.pruneMin(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_606: HeapType;
  var exhaleMask#_607: MaskType;
  var fraction#_608: int;
  var inhaleHeap#_609: HeapType;
  var this#269: ref where (this#269 == null) || (dtype(this#269) == AVLTreeNode#t);
  var callHeap#_610: HeapType;
  var callMask#_611: MaskType;
  var callCredits#_612: CreditsType;
  var exhaleMask#_613: MaskType;
  var fraction#_614: int;
  var fraction#_615: int;
  var fraction#_616: int;
  var fraction#_617: int;
  var fraction#_618: int;
  var fraction#_619: int;
  var fraction#_620: int;
  var fraction#_621: int;
  var isHeld#_622: int;
  var isRdHeld#_623: bool;
  var inhaleHeap#_624: HeapType;
  var nl#44: ref where (nl#44 == null) || (dtype(nl#44) == AVLTreeNode#t);
  var this#272: ref where (this#272 == null) || (dtype(this#272) == AVLTreeNode#t);
  var r#273: ref where (r#273 == null) || (dtype(r#273) == AVLTreeNode#t);
  var m#274: ref where (m#274 == null) || (dtype(m#274) == AVLTreeNode#t);
  var callHeap#_625: HeapType;
  var callMask#_626: MaskType;
  var callCredits#_627: CreditsType;
  var exhaleMask#_628: MaskType;
  var fraction#_629: int;
  var fraction#_630: int;
  var isHeld#_631: int;
  var isRdHeld#_632: bool;
  var inhaleHeap#_633: HeapType;
  var bf#46: int where true;
  var this#276: ref where (this#276 == null) || (dtype(this#276) == AVLTreeNode#t);
  var bf#277: int where true;
  var callHeap#_634: HeapType;
  var callMask#_635: MaskType;
  var callCredits#_636: CreditsType;
  var exhaleMask#_637: MaskType;
  var epsilons#_638: int;
  var fraction#_639: int;
  var epsilons#_640: int;
  var fraction#_641: int;
  var isHeld#_642: int;
  var isRdHeld#_643: bool;
  var inhaleHeap#_644: HeapType;
  var this#278: ref where (this#278 == null) || (dtype(this#278) == AVLTreeNode#t);
  var r#279: ref where (r#279 == null) || (dtype(r#279) == AVLTreeNode#t);
  var callHeap#_645: HeapType;
  var callMask#_646: MaskType;
  var callCredits#_647: CreditsType;
  var exhaleMask#_648: MaskType;
  var fraction#_649: int;
  var fraction#_650: int;
  var fraction#_651: int;
  var fraction#_652: int;
  var fraction#_653: int;
  var fraction#_654: int;
  var fraction#_655: int;
  var fraction#_656: int;
  var isHeld#_657: int;
  var isRdHeld#_658: bool;
  var inhaleHeap#_659: HeapType;
  var this#282: ref where (this#282 == null) || (dtype(this#282) == AVLTreeNode#t);
  var callHeap#_660: HeapType;
  var callMask#_661: MaskType;
  var callCredits#_662: CreditsType;
  var exhaleMask#_663: MaskType;
  var fraction#_664: int;
  var fraction#_665: int;
  var fraction#_666: int;
  var fraction#_667: int;
  var fraction#_668: int;
  var fraction#_669: int;
  var fraction#_670: int;
  var fraction#_671: int;
  var isHeld#_672: int;
  var isRdHeld#_673: bool;
  var inhaleHeap#_674: HeapType;
  var Heap#_678: HeapType;
  var Mask#_679: MaskType;
  var Credits#_680: CreditsType;
  var exhaleMask#_681: MaskType;
  var k#78#286: int where true;
  var exhaleMask#_682: MaskType;
  var fraction#_683: int;
  var fraction#_684: int;
  var fraction#_685: int;
  var fraction#_686: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_606;
  assume IsGoodInhaleState(inhaleHeap#_606, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_606[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_606[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_606[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  428.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_607 := Mask;
  fraction#_608 := 100;
  assert {:msg "  428.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_608 <= exhaleMask#_607[this, AVLTreeNode.valid][perm$R]) && ((fraction#_608 == exhaleMask#_607[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_607[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_607[this, AVLTreeNode.valid] := exhaleMask#_607[this, AVLTreeNode.valid][perm$R := exhaleMask#_607[this, AVLTreeNode.valid][perm$R] - fraction#_608];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_607);
  Mask := exhaleMask#_607;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_609 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_609, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_609[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_609[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_609, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_609[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_609[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_609, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_609[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_609[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_609, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_609[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_609[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_609, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_609[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_609[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_609[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_609, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_609[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_609[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_609, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#267: int :: (0 <= lk#67#267) && (lk#67#267 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#267) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_609[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_609[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_609[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_609, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_609[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_609[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_609, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#268: int :: (0 <= rk#68#268) && (rk#68#268 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#268)));
  } else {
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  429.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  429.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
    // assigment to r
    assert {:msg "  430.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  430.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    r#41 := Heap[this, AVLTreeNode.right];
    // update field right
    assert {:msg "  431.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := null;
    assume wf(Heap, Mask);
    // call close
    callHeap#_610 := Heap;
    callMask#_611 := Mask;
    callCredits#_612 := Credits;
    assert {:msg "  432.4: The target of the method call might be null."} this != null;
    this#269 := this;
    // begin exhale (precondition)
    exhaleMask#_613 := Mask;
    fraction#_614 := 100;
    assert {:msg "  432.4: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_614 <= exhaleMask#_613[this#269, AVLTreeNode.key][perm$R]) && ((fraction#_614 == exhaleMask#_613[this#269, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_613[this#269, AVLTreeNode.key][perm$N]));
    exhaleMask#_613[this#269, AVLTreeNode.key] := exhaleMask#_613[this#269, AVLTreeNode.key][perm$R := exhaleMask#_613[this#269, AVLTreeNode.key][perm$R] - fraction#_614];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_613);
    fraction#_615 := 100;
    assert {:msg "  432.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_615 <= exhaleMask#_613[this#269, AVLTreeNode.left][perm$R]) && ((fraction#_615 == exhaleMask#_613[this#269, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_613[this#269, AVLTreeNode.left][perm$N]));
    exhaleMask#_613[this#269, AVLTreeNode.left] := exhaleMask#_613[this#269, AVLTreeNode.left][perm$R := exhaleMask#_613[this#269, AVLTreeNode.left][perm$R] - fraction#_615];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_613);
    fraction#_616 := 100;
    assert {:msg "  432.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_616 <= exhaleMask#_613[this#269, AVLTreeNode.right][perm$R]) && ((fraction#_616 == exhaleMask#_613[this#269, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_613[this#269, AVLTreeNode.right][perm$N]));
    exhaleMask#_613[this#269, AVLTreeNode.right] := exhaleMask#_613[this#269, AVLTreeNode.right][perm$R := exhaleMask#_613[this#269, AVLTreeNode.right][perm$R] - fraction#_616];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_613);
    fraction#_617 := 100;
    assert {:msg "  432.4: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_617 <= exhaleMask#_613[this#269, AVLTreeNode.keys][perm$R]) && ((fraction#_617 == exhaleMask#_613[this#269, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_613[this#269, AVLTreeNode.keys][perm$N]));
    exhaleMask#_613[this#269, AVLTreeNode.keys] := exhaleMask#_613[this#269, AVLTreeNode.keys][perm$R := exhaleMask#_613[this#269, AVLTreeNode.keys][perm$R] - fraction#_617];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_613);
    if (!(Heap[this#269, AVLTreeNode.left] == null)) {
      fraction#_618 := 100;
      assert {:msg "  432.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_618 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_618 == exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_618];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_613);
    } else {
    }
    if (!(Heap[this#269, AVLTreeNode.left] == null)) {
      fraction#_619 := 50;
      assert {:msg "  432.4: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_619 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_619 == exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_613[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_619];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_613);
    } else {
    }
    if (!(Heap[this#269, AVLTreeNode.left] == null)) {
      assert {:msg "  432.4: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#270: int :: (0 <= k#79#270) && (k#79#270 < Seq#Length(Heap[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#269, AVLTreeNode.left], AVLTreeNode.keys], k#79#270) < Heap[this#269, AVLTreeNode.key]));
    } else {
    }
    if (!(Heap[this#269, AVLTreeNode.right] == null)) {
      fraction#_620 := 100;
      assert {:msg "  432.4: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_620 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_620 == exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_620];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_613);
    } else {
    }
    if (!(Heap[this#269, AVLTreeNode.right] == null)) {
      fraction#_621 := 50;
      assert {:msg "  432.4: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_621 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_621 == exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_613[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_621];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_613);
    } else {
    }
    if (!(Heap[this#269, AVLTreeNode.right] == null)) {
      assert {:msg "  432.4: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#271: int :: (0 <= k#80#271) && (k#80#271 < Seq#Length(Heap[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#269, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#269, AVLTreeNode.right], AVLTreeNode.keys], k#80#271)));
    } else {
    }
    Mask := exhaleMask#_613;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_624;
    assume IsGoodInhaleState(inhaleHeap#_624, Heap, Mask);
    assume this#269 != null;
    Heap[this#269, AVLTreeNode.valid] := inhaleHeap#_624[this#269, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_624[this#269, AVLTreeNode.valid] == Heap;
    Mask[this#269, AVLTreeNode.valid] := Mask[this#269, AVLTreeNode.valid][perm$R := Mask[this#269, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_624[this#269, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_624, Mask);
    assume this#269 != null;
    Heap[this#269, AVLTreeNode.keys] := inhaleHeap#_624[this#269, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#269, AVLTreeNode.keys] := Mask[this#269, AVLTreeNode.keys][perm$R := Mask[this#269, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_624[this#269, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_624, Mask);
    assume Seq#Equal(Heap[this#269, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_610[this#269, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_610[callHeap#_610[this#269, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_610[this#269, AVLTreeNode.key])), ite(callHeap#_610[this#269, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_610[callHeap#_610[this#269, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // assigment to m
    m#42 := this;
  } else {
    // local var nl
    // call pruneMin
    callHeap#_625 := Heap;
    callMask#_626 := Mask;
    callCredits#_627 := Credits;
    assert {:msg "  438.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  438.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  438.4: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
    this#272 := Heap[this, AVLTreeNode.left];
    // begin exhale (precondition)
    exhaleMask#_628 := Mask;
    fraction#_629 := 100;
    assert {:msg "  438.4: The precondition at 402.12 might not hold. Insufficient fraction at 402.12 for AVLTreeNode.valid."} (fraction#_629 <= exhaleMask#_628[this#272, AVLTreeNode.valid][perm$R]) && ((fraction#_629 == exhaleMask#_628[this#272, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_628[this#272, AVLTreeNode.valid][perm$N]));
    exhaleMask#_628[this#272, AVLTreeNode.valid] := exhaleMask#_628[this#272, AVLTreeNode.valid][perm$R := exhaleMask#_628[this#272, AVLTreeNode.valid][perm$R] - fraction#_629];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_628);
    fraction#_630 := 50;
    assert {:msg "  438.4: The precondition at 403.12 might not hold. Insufficient fraction at 403.12 for AVLTreeNode.keys."} (fraction#_630 <= exhaleMask#_628[this#272, AVLTreeNode.keys][perm$R]) && ((fraction#_630 == exhaleMask#_628[this#272, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_628[this#272, AVLTreeNode.keys][perm$N]));
    exhaleMask#_628[this#272, AVLTreeNode.keys] := exhaleMask#_628[this#272, AVLTreeNode.keys][perm$R := exhaleMask#_628[this#272, AVLTreeNode.keys][perm$R] - fraction#_630];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_628);
    Mask := exhaleMask#_628;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#273;
    havoc m#274;
    // inhale (postcondition)
    havoc inhaleHeap#_633;
    assume IsGoodInhaleState(inhaleHeap#_633, Heap, Mask);
    if (!(r#273 == null)) {
      assume r#273 != null;
      Heap[r#273, AVLTreeNode.valid] := inhaleHeap#_633[r#273, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_633[r#273, AVLTreeNode.valid] == Heap;
      Mask[r#273, AVLTreeNode.valid] := Mask[r#273, AVLTreeNode.valid][perm$R := Mask[r#273, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_633[r#273, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_633, Mask);
    } else {
    }
    if (!(r#273 == null)) {
      assume r#273 != null;
      Heap[r#273, AVLTreeNode.keys] := inhaleHeap#_633[r#273, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#273, AVLTreeNode.keys] := Mask[r#273, AVLTreeNode.keys][perm$R := Mask[r#273, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_633[r#273, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_633, Mask);
    } else {
    }
    if (!(r#273 == null)) {
      assume (Seq#Length(Heap[r#273, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this#272, AVLTreeNode.keys]);
    } else {
    }
    assume !(m#274 == null);
    assume m#274 != null;
    Heap[m#274, AVLTreeNode.valid] := inhaleHeap#_633[m#274, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_633[m#274, AVLTreeNode.valid] == Heap;
    Mask[m#274, AVLTreeNode.valid] := Mask[m#274, AVLTreeNode.valid][perm$R := Mask[m#274, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_633[m#274, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_633, Mask);
    assume m#274 != null;
    Heap[m#274, AVLTreeNode.keys] := inhaleHeap#_633[m#274, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[m#274, AVLTreeNode.keys] := Mask[m#274, AVLTreeNode.keys][perm$R := Mask[m#274, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_633[m#274, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_633, Mask);
    assume Seq#Length(Heap[m#274, AVLTreeNode.keys]) == 1;
    assume Seq#Equal(Seq#Append(Heap[m#274, AVLTreeNode.keys], ite(r#273 == null, Seq#Empty(), Heap[r#273, AVLTreeNode.keys])), callHeap#_625[this#272, AVLTreeNode.keys]);
    if (!(r#273 == null)) {
      assume (forall k#77#275: int :: (0 <= k#77#275) && (k#77#275 < Seq#Length(Heap[r#273, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#274, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#273, AVLTreeNode.keys], k#77#275)));
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    nl#44 := r#273;
    m#42 := m#274;
    // update field left
    assert {:msg "  439.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := nl#44;
    assume wf(Heap, Mask);
    // local var bf
    // call getBalanceFactorI
    callHeap#_634 := Heap;
    callMask#_635 := Mask;
    callCredits#_636 := Credits;
    assert {:msg "  441.4: The target of the method call might be null."} this != null;
    this#276 := this;
    // begin exhale (precondition)
    exhaleMask#_637 := Mask;
    epsilons#_638 := 1;
    assert {:msg "  441.4: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_637[this#276, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_638 <= exhaleMask#_637[this#276, AVLTreeNode.left][perm$N]);
    if ((exhaleMask#_637[this#276, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_637[this#276, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_637[this#276, AVLTreeNode.left] := exhaleMask#_637[this#276, AVLTreeNode.left][perm$N := exhaleMask#_637[this#276, AVLTreeNode.left][perm$N] - epsilons#_638];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_637);
    if (!(Heap[this#276, AVLTreeNode.left] == null)) {
      fraction#_639 := 100;
      assert {:msg "  441.4: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_639 <= exhaleMask#_637[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_639 == exhaleMask#_637[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_637[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_637[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_637[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_637[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_639];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_637);
    } else {
    }
    epsilons#_640 := 1;
    assert {:msg "  441.4: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_637[this#276, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_640 <= exhaleMask#_637[this#276, AVLTreeNode.right][perm$N]);
    if ((exhaleMask#_637[this#276, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_637[this#276, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_637[this#276, AVLTreeNode.right] := exhaleMask#_637[this#276, AVLTreeNode.right][perm$N := exhaleMask#_637[this#276, AVLTreeNode.right][perm$N] - epsilons#_640];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_637);
    if (!(Heap[this#276, AVLTreeNode.right] == null)) {
      fraction#_641 := 100;
      assert {:msg "  441.4: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_641 <= exhaleMask#_637[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_641 == exhaleMask#_637[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_637[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_637[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_637[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_637[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_641];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_637);
    } else {
    }
    Mask := exhaleMask#_637;
    assume wf(Heap, Mask);
    // end exhale
    havoc bf#277;
    // inhale (postcondition)
    havoc inhaleHeap#_644;
    assume IsGoodInhaleState(inhaleHeap#_644, Heap, Mask);
    assume this#276 != null;
    Heap[this#276, AVLTreeNode.left] := inhaleHeap#_644[this#276, AVLTreeNode.left];
    assume wf(Heap, Mask);
    assume (Heap[this#276, AVLTreeNode.left] == null) || (dtype(Heap[this#276, AVLTreeNode.left]) == AVLTreeNode#t);
    if ((Mask[this#276, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#276, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      Mask[this#276, AVLTreeNode.left] := Mask[this#276, AVLTreeNode.left][perm$N := Mask[this#276, AVLTreeNode.left][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_644[this#276, AVLTreeNode.left]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_644, Mask);
    if (!(Heap[this#276, AVLTreeNode.left] == null)) {
      assume Heap[this#276, AVLTreeNode.left] != null;
      Heap[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_644[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_644[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_644[Heap[this#276, AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_644, Mask);
    } else {
    }
    assume this#276 != null;
    Heap[this#276, AVLTreeNode.right] := inhaleHeap#_644[this#276, AVLTreeNode.right];
    assume wf(Heap, Mask);
    assume (Heap[this#276, AVLTreeNode.right] == null) || (dtype(Heap[this#276, AVLTreeNode.right]) == AVLTreeNode#t);
    if ((Mask[this#276, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#276, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      Mask[this#276, AVLTreeNode.right] := Mask[this#276, AVLTreeNode.right][perm$N := Mask[this#276, AVLTreeNode.right][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_644[this#276, AVLTreeNode.right]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_644, Mask);
    if (!(Heap[this#276, AVLTreeNode.right] == null)) {
      assume Heap[this#276, AVLTreeNode.right] != null;
      Heap[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_644[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_644[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_644[Heap[this#276, AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_644, Mask);
    } else {
    }
    if (bf#277 > 0) {
      assume !(Heap[this#276, AVLTreeNode.left] == null);
    } else {
    }
    if (bf#277 < 0) {
      assume !(Heap[this#276, AVLTreeNode.right] == null);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    bf#46 := bf#277;
    // if
    if (bf#46 == (0 - 2)) {
      // call rebalanceRight
      callHeap#_645 := Heap;
      callMask#_646 := Mask;
      callCredits#_647 := Credits;
      assert {:msg "  443.5: The target of the method call might be null."} this != null;
      this#278 := this;
      // begin exhale (precondition)
      exhaleMask#_648 := Mask;
      fraction#_649 := 100;
      assert {:msg "  443.5: The precondition at 741.12 might not hold. Insufficient fraction at 741.12 for AVLTreeNode.key."} (fraction#_649 <= exhaleMask#_648[this#278, AVLTreeNode.key][perm$R]) && ((fraction#_649 == exhaleMask#_648[this#278, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_648[this#278, AVLTreeNode.key][perm$N]));
      exhaleMask#_648[this#278, AVLTreeNode.key] := exhaleMask#_648[this#278, AVLTreeNode.key][perm$R := exhaleMask#_648[this#278, AVLTreeNode.key][perm$R] - fraction#_649];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_648);
      fraction#_650 := 100;
      assert {:msg "  443.5: The precondition at 743.12 might not hold. Insufficient fraction at 743.12 for AVLTreeNode.left."} (fraction#_650 <= exhaleMask#_648[this#278, AVLTreeNode.left][perm$R]) && ((fraction#_650 == exhaleMask#_648[this#278, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_648[this#278, AVLTreeNode.left][perm$N]));
      exhaleMask#_648[this#278, AVLTreeNode.left] := exhaleMask#_648[this#278, AVLTreeNode.left][perm$R := exhaleMask#_648[this#278, AVLTreeNode.left][perm$R] - fraction#_650];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_648);
      fraction#_651 := 100;
      assert {:msg "  443.5: The precondition at 744.12 might not hold. Insufficient fraction at 744.12 for AVLTreeNode.right."} (fraction#_651 <= exhaleMask#_648[this#278, AVLTreeNode.right][perm$R]) && ((fraction#_651 == exhaleMask#_648[this#278, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_648[this#278, AVLTreeNode.right][perm$N]));
      exhaleMask#_648[this#278, AVLTreeNode.right] := exhaleMask#_648[this#278, AVLTreeNode.right][perm$R := exhaleMask#_648[this#278, AVLTreeNode.right][perm$R] - fraction#_651];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_648);
      fraction#_652 := 100;
      assert {:msg "  443.5: The precondition at 746.12 might not hold. Insufficient fraction at 746.12 for AVLTreeNode.keys."} (fraction#_652 <= exhaleMask#_648[this#278, AVLTreeNode.keys][perm$R]) && ((fraction#_652 == exhaleMask#_648[this#278, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_648[this#278, AVLTreeNode.keys][perm$N]));
      exhaleMask#_648[this#278, AVLTreeNode.keys] := exhaleMask#_648[this#278, AVLTreeNode.keys][perm$R := exhaleMask#_648[this#278, AVLTreeNode.keys][perm$R] - fraction#_652];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_648);
      if (!(Heap[this#278, AVLTreeNode.left] == null)) {
        fraction#_653 := 100;
        assert {:msg "  443.5: The precondition at 749.12 might not hold. Insufficient fraction at 749.25 for AVLTreeNode.valid."} (fraction#_653 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_653 == exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_653];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_648);
      } else {
      }
      if (!(Heap[this#278, AVLTreeNode.left] == null)) {
        fraction#_654 := 50;
        assert {:msg "  443.5: The precondition at 751.12 might not hold. Insufficient fraction at 751.25 for AVLTreeNode.keys."} (fraction#_654 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_654 == exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_648[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_654];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_648);
      } else {
      }
      if (!(Heap[this#278, AVLTreeNode.left] == null)) {
        assert {:msg "  443.5: The precondition at 753.12 might not hold. The expression at 753.25 might not evaluate to true."} (forall k#91#280: int :: (0 <= k#91#280) && (k#91#280 < Seq#Length(Heap[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#278, AVLTreeNode.left], AVLTreeNode.keys], k#91#280) < Heap[this#278, AVLTreeNode.key]));
      } else {
      }
      assert {:msg "  443.5: The precondition at 755.12 might not hold. The expression at 755.12 might not evaluate to true."} !(Heap[this#278, AVLTreeNode.right] == null);
      fraction#_655 := 100;
      assert {:msg "  443.5: The precondition at 756.12 might not hold. Insufficient fraction at 756.12 for AVLTreeNode.valid."} (fraction#_655 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_655 == exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_655];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_648);
      fraction#_656 := 50;
      assert {:msg "  443.5: The precondition at 758.12 might not hold. Insufficient fraction at 758.12 for AVLTreeNode.keys."} (fraction#_656 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_656 == exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_648[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_656];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_648);
      assert {:msg "  443.5: The precondition at 760.12 might not hold. The expression at 760.12 might not evaluate to true."} (forall k#92#281: int :: (0 <= k#92#281) && (k#92#281 < Seq#Length(Heap[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#278, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#278, AVLTreeNode.right], AVLTreeNode.keys], k#92#281)));
      Mask := exhaleMask#_648;
      assume wf(Heap, Mask);
      // end exhale
      havoc r#279;
      // inhale (postcondition)
      havoc inhaleHeap#_659;
      assume IsGoodInhaleState(inhaleHeap#_659, Heap, Mask);
      assume r#279 != null;
      Heap[r#279, AVLTreeNode.valid] := inhaleHeap#_659[r#279, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_659[r#279, AVLTreeNode.valid] == Heap;
      Mask[r#279, AVLTreeNode.valid] := Mask[r#279, AVLTreeNode.valid][perm$R := Mask[r#279, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_659[r#279, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_659, Mask);
      assume r#279 != null;
      Heap[r#279, AVLTreeNode.keys] := inhaleHeap#_659[r#279, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#279, AVLTreeNode.keys] := Mask[r#279, AVLTreeNode.keys][perm$R := Mask[r#279, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_659[r#279, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_659, Mask);
      assume Seq#Equal(Heap[r#279, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_645[this#278, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_645[callHeap#_645[this#278, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_645[this#278, AVLTreeNode.key])), callHeap#_645[callHeap#_645[this#278, AVLTreeNode.right], AVLTreeNode.keys]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      r#41 := r#279;
    } else {
      // call close
      callHeap#_660 := Heap;
      callMask#_661 := Mask;
      callCredits#_662 := Credits;
      assert {:msg "  446.5: The target of the method call might be null."} this != null;
      this#282 := this;
      // begin exhale (precondition)
      exhaleMask#_663 := Mask;
      fraction#_664 := 100;
      assert {:msg "  446.5: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_664 <= exhaleMask#_663[this#282, AVLTreeNode.key][perm$R]) && ((fraction#_664 == exhaleMask#_663[this#282, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_663[this#282, AVLTreeNode.key][perm$N]));
      exhaleMask#_663[this#282, AVLTreeNode.key] := exhaleMask#_663[this#282, AVLTreeNode.key][perm$R := exhaleMask#_663[this#282, AVLTreeNode.key][perm$R] - fraction#_664];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_663);
      fraction#_665 := 100;
      assert {:msg "  446.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_665 <= exhaleMask#_663[this#282, AVLTreeNode.left][perm$R]) && ((fraction#_665 == exhaleMask#_663[this#282, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_663[this#282, AVLTreeNode.left][perm$N]));
      exhaleMask#_663[this#282, AVLTreeNode.left] := exhaleMask#_663[this#282, AVLTreeNode.left][perm$R := exhaleMask#_663[this#282, AVLTreeNode.left][perm$R] - fraction#_665];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_663);
      fraction#_666 := 100;
      assert {:msg "  446.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_666 <= exhaleMask#_663[this#282, AVLTreeNode.right][perm$R]) && ((fraction#_666 == exhaleMask#_663[this#282, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_663[this#282, AVLTreeNode.right][perm$N]));
      exhaleMask#_663[this#282, AVLTreeNode.right] := exhaleMask#_663[this#282, AVLTreeNode.right][perm$R := exhaleMask#_663[this#282, AVLTreeNode.right][perm$R] - fraction#_666];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_663);
      fraction#_667 := 100;
      assert {:msg "  446.5: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_667 <= exhaleMask#_663[this#282, AVLTreeNode.keys][perm$R]) && ((fraction#_667 == exhaleMask#_663[this#282, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_663[this#282, AVLTreeNode.keys][perm$N]));
      exhaleMask#_663[this#282, AVLTreeNode.keys] := exhaleMask#_663[this#282, AVLTreeNode.keys][perm$R := exhaleMask#_663[this#282, AVLTreeNode.keys][perm$R] - fraction#_667];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_663);
      if (!(Heap[this#282, AVLTreeNode.left] == null)) {
        fraction#_668 := 100;
        assert {:msg "  446.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_668 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_668 == exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_668];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_663);
      } else {
      }
      if (!(Heap[this#282, AVLTreeNode.left] == null)) {
        fraction#_669 := 50;
        assert {:msg "  446.5: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_669 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_669 == exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
        exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_663[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_669];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_663);
      } else {
      }
      if (!(Heap[this#282, AVLTreeNode.left] == null)) {
        assert {:msg "  446.5: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#283: int :: (0 <= k#79#283) && (k#79#283 < Seq#Length(Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#282, AVLTreeNode.left], AVLTreeNode.keys], k#79#283) < Heap[this#282, AVLTreeNode.key]));
      } else {
      }
      if (!(Heap[this#282, AVLTreeNode.right] == null)) {
        fraction#_670 := 100;
        assert {:msg "  446.5: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_670 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_670 == exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_670];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_663);
      } else {
      }
      if (!(Heap[this#282, AVLTreeNode.right] == null)) {
        fraction#_671 := 50;
        assert {:msg "  446.5: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_671 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_671 == exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
        exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_663[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_671];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_663);
      } else {
      }
      if (!(Heap[this#282, AVLTreeNode.right] == null)) {
        assert {:msg "  446.5: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#284: int :: (0 <= k#80#284) && (k#80#284 < Seq#Length(Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#282, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#282, AVLTreeNode.right], AVLTreeNode.keys], k#80#284)));
      } else {
      }
      Mask := exhaleMask#_663;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_674;
      assume IsGoodInhaleState(inhaleHeap#_674, Heap, Mask);
      assume this#282 != null;
      Heap[this#282, AVLTreeNode.valid] := inhaleHeap#_674[this#282, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_674[this#282, AVLTreeNode.valid] == Heap;
      Mask[this#282, AVLTreeNode.valid] := Mask[this#282, AVLTreeNode.valid][perm$R := Mask[this#282, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_674[this#282, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_674, Mask);
      assume this#282 != null;
      Heap[this#282, AVLTreeNode.keys] := inhaleHeap#_674[this#282, AVLTreeNode.keys];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#282, AVLTreeNode.keys] := Mask[this#282, AVLTreeNode.keys][perm$R := Mask[this#282, AVLTreeNode.keys][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_674[this#282, AVLTreeNode.keys]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_674, Mask);
      assume Seq#Equal(Heap[this#282, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_660[this#282, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_660[callHeap#_660[this#282, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_660[this#282, AVLTreeNode.key])), ite(callHeap#_660[this#282, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_660[callHeap#_660[this#282, AVLTreeNode.right], AVLTreeNode.keys])));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // assigment to r
      r#41 := this;
    }
    // assert
    Heap#_678 := Heap;
    Mask#_679 := Mask;
    Credits#_680 := Credits;
    // begin exhale (assert)
    exhaleMask#_681 := Mask#_679;
    if (!(r#41 == null)) {
      assert {:msg "  450.11: Receiver might be null."} true && (0 <= k#78#286) ==> (r#41 != null);
      assert {:msg "  450.11: Location might not be readable."} true && (0 <= k#78#286) ==> CanRead(Mask#_679, r#41, AVLTreeNode.keys);
      assert {:msg "  450.45: Receiver might be null."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (m#42 != null);
      assert {:msg "  450.45: Location might not be readable."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask#_679, m#42, AVLTreeNode.keys);
      assert {:msg "  450.45: Sequence index might be negative."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= 0);
      assert {:msg "  450.45: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 < Seq#Length(Heap#_678[m#42, AVLTreeNode.keys]));
      assert {:msg "  450.11: Receiver might be null."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (r#41 != null);
      assert {:msg "  450.11: Location might not be readable."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> CanRead(Mask#_679, r#41, AVLTreeNode.keys);
      assert {:msg "  450.57: Sequence index might be negative."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (0 <= k#78#286);
      assert {:msg "  450.57: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#78#286) && (k#78#286 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (k#78#286 < Seq#Length(Heap#_678[r#41, AVLTreeNode.keys]));
      assert {:msg "  450.4: Assertion might not hold. The expression at 450.23 might not evaluate to true."} (forall k#78#285: int :: (0 <= k#78#285) && (k#78#285 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap#_678[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap#_678[r#41, AVLTreeNode.keys], k#78#285)));
    } else {
    }
    Mask#_679 := exhaleMask#_681;
    assume wf(Heap#_678, Mask#_679);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_682 := Mask;
  if (!(r#41 == null)) {
    fraction#_683 := 100;
    assert {:msg "  401.2: The postcondition at 407.11 might not hold. Insufficient fraction at 407.25 for AVLTreeNode.valid."} (fraction#_683 <= exhaleMask#_682[r#41, AVLTreeNode.valid][perm$R]) && ((fraction#_683 == exhaleMask#_682[r#41, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_682[r#41, AVLTreeNode.valid][perm$N]));
    exhaleMask#_682[r#41, AVLTreeNode.valid] := exhaleMask#_682[r#41, AVLTreeNode.valid][perm$R := exhaleMask#_682[r#41, AVLTreeNode.valid][perm$R] - fraction#_683];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_682);
  } else {
  }
  if (!(r#41 == null)) {
    fraction#_684 := 50;
    assert {:msg "  401.2: The postcondition at 408.11 might not hold. Insufficient fraction at 408.25 for AVLTreeNode.keys."} (fraction#_684 <= exhaleMask#_682[r#41, AVLTreeNode.keys][perm$R]) && ((fraction#_684 == exhaleMask#_682[r#41, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_682[r#41, AVLTreeNode.keys][perm$N]));
    exhaleMask#_682[r#41, AVLTreeNode.keys] := exhaleMask#_682[r#41, AVLTreeNode.keys][perm$R := exhaleMask#_682[r#41, AVLTreeNode.keys][perm$R] - fraction#_684];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_682);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  401.2: The postcondition at 412.11 might not hold. The expression at 412.24 might not evaluate to true."} (Seq#Length(Heap[r#41, AVLTreeNode.keys]) + 1) == Seq#Length(old(Heap)[this, AVLTreeNode.keys]);
  } else {
  }
  assert {:msg "  401.2: The postcondition at 417.11 might not hold. The expression at 417.11 might not evaluate to true."} !(m#42 == null);
  fraction#_685 := 100;
  assert {:msg "  401.2: The postcondition at 418.11 might not hold. Insufficient fraction at 418.11 for AVLTreeNode.valid."} (fraction#_685 <= exhaleMask#_682[m#42, AVLTreeNode.valid][perm$R]) && ((fraction#_685 == exhaleMask#_682[m#42, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_682[m#42, AVLTreeNode.valid][perm$N]));
  exhaleMask#_682[m#42, AVLTreeNode.valid] := exhaleMask#_682[m#42, AVLTreeNode.valid][perm$R := exhaleMask#_682[m#42, AVLTreeNode.valid][perm$R] - fraction#_685];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_682);
  fraction#_686 := 50;
  assert {:msg "  401.2: The postcondition at 419.11 might not hold. Insufficient fraction at 419.11 for AVLTreeNode.keys."} (fraction#_686 <= exhaleMask#_682[m#42, AVLTreeNode.keys][perm$R]) && ((fraction#_686 == exhaleMask#_682[m#42, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_682[m#42, AVLTreeNode.keys][perm$N]));
  exhaleMask#_682[m#42, AVLTreeNode.keys] := exhaleMask#_682[m#42, AVLTreeNode.keys][perm$R := exhaleMask#_682[m#42, AVLTreeNode.keys][perm$R] - fraction#_686];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_682);
  assert {:msg "  401.2: The postcondition at 423.11 might not hold. The expression at 423.11 might not evaluate to true."} Seq#Length(Heap[m#42, AVLTreeNode.keys]) == 1;
  assert {:msg "  401.2: The postcondition at 425.11 might not hold. The expression at 425.11 might not evaluate to true."} Seq#Equal(Seq#Append(Heap[m#42, AVLTreeNode.keys], ite(r#41 == null, Seq#Empty(), Heap[r#41, AVLTreeNode.keys])), old(Heap)[this, AVLTreeNode.keys]);
  if (!(r#41 == null)) {
    assert {:msg "  401.2: The postcondition at 426.11 might not hold. The expression at 426.23 might not evaluate to true."} (forall k#77#287: int :: (0 <= k#77#287) && (k#77#287 < Seq#Length(Heap[r#41, AVLTreeNode.keys])) ==> (Seq#Index(Heap[m#42, AVLTreeNode.keys], 0) < Seq#Index(Heap[r#41, AVLTreeNode.keys], k#77#287)));
  } else {
  }
  Mask := exhaleMask#_682;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  401.2: Method might lock/unlock more than allowed."} (forall lk#_687: ref :: {Heap[lk#_687, held]} {Heap[lk#_687, rdheld]} (((0 < Heap[lk#_687, held]) == (0 < old(Heap)[lk#_687, held])) && (Heap[lk#_687, rdheld] == old(Heap)[lk#_687, rdheld])) || false);
  assert {:msg "  401.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_688: HeapType;
  var inhaleHeap#_689: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_688;
  assume IsGoodInhaleState(inhaleHeap#_688, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_688[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_688[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_688[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_688, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_688[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$N := Mask[this, AVLTreeNode.keys][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_688[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_688, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_689;
  assume IsGoodInhaleState(inhaleHeap#_689, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_689[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_689[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_689[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_689, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_689[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$N := Mask[this, AVLTreeNode.keys][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_689[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_689, Mask);
  assert {:msg "  460.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  460.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assume b#48 == Seq#Contains(Heap[this, AVLTreeNode.keys], k#47);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.has(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_690: HeapType;
  var exhaleMask#_691: MaskType;
  var fraction#_692: int;
  var inhaleHeap#_693: HeapType;
  var Heap#_697: HeapType;
  var Mask#_698: MaskType;
  var Credits#_699: CreditsType;
  var exhaleMask#_700: MaskType;
  var this#290: ref where (this#290 == null) || (dtype(this#290) == AVLTreeNode#t);
  var k#291: int where true;
  var b#292: bool where true;
  var callHeap#_701: HeapType;
  var callMask#_702: MaskType;
  var callCredits#_703: CreditsType;
  var exhaleMask#_704: MaskType;
  var fraction#_705: int;
  var epsilons#_706: int;
  var isHeld#_707: int;
  var isRdHeld#_708: bool;
  var inhaleHeap#_709: HeapType;
  var this#293: ref where (this#293 == null) || (dtype(this#293) == AVLTreeNode#t);
  var k#294: int where true;
  var b#295: bool where true;
  var callHeap#_710: HeapType;
  var callMask#_711: MaskType;
  var callCredits#_712: CreditsType;
  var exhaleMask#_713: MaskType;
  var fraction#_714: int;
  var epsilons#_715: int;
  var isHeld#_716: int;
  var isRdHeld#_717: bool;
  var inhaleHeap#_718: HeapType;
  var exhaleMask#_719: MaskType;
  var fraction#_720: int;
  var fraction#_721: int;
  var fraction#_722: int;
  var fraction#_723: int;
  var fraction#_724: int;
  var fraction#_725: int;
  var fraction#_726: int;
  var fraction#_727: int;
  var inhaleHeap#_728: HeapType;
  var exhaleMask#_729: MaskType;
  var fraction#_730: int;
  var epsilons#_731: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_690;
  assume IsGoodInhaleState(inhaleHeap#_690, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_690[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_690[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_690[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_690, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_690[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$N := Mask[this, AVLTreeNode.keys][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_690[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_690, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  462.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_691 := Mask;
  fraction#_692 := 100;
  assert {:msg "  462.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_692 <= exhaleMask#_691[this, AVLTreeNode.valid][perm$R]) && ((fraction#_692 == exhaleMask#_691[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_691[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_691[this, AVLTreeNode.valid] := exhaleMask#_691[this, AVLTreeNode.valid][perm$R := exhaleMask#_691[this, AVLTreeNode.valid][perm$R] - fraction#_692];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_691);
  Mask := exhaleMask#_691;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_693 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_693, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_693[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_693[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_693, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_693[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_693[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_693, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_693[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_693[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_693, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_693[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_693[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_693, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_693[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_693[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_693[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_693, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_693[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_693[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_693, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#288: int :: (0 <= lk#67#288) && (lk#67#288 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#288) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_693[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_693[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_693[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_693, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_693[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_693[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_693, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#289: int :: (0 <= rk#68#289) && (rk#68#289 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#289)));
  } else {
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  463.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  463.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (k#47 == Heap[this, AVLTreeNode.key]) {
    // assigment to b
    b#48 := true;
    // assert
    Heap#_697 := Heap;
    Mask#_698 := Mask;
    Credits#_699 := Credits;
    // begin exhale (assert)
    exhaleMask#_700 := Mask#_698;
    assert {:msg "  465.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  465.12: Location might not be readable."} true ==> CanRead(Mask#_698, this, AVLTreeNode.key);
    assert {:msg "  465.11: Sequence index might be negative."} true ==> (0 <= 0);
    assert {:msg "  465.11: Sequence index might be larger than or equal to the length of the sequence."} true ==> (0 < Seq#Length(Seq#Singleton(Heap#_697[this, AVLTreeNode.key])));
    assert {:msg "  465.4: Assertion might not hold. The expression at 465.11 might not evaluate to true."} Seq#Index(Seq#Singleton(Heap#_697[this, AVLTreeNode.key]), 0) == k#47;
    Mask#_698 := exhaleMask#_700;
    assume wf(Heap#_697, Mask#_698);
    // end exhale
  } else {
    // if
    assert {:msg "  467.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  467.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (k#47 < Heap[this, AVLTreeNode.key]) {
      // if
      assert {:msg "  468.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  468.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (!(Heap[this, AVLTreeNode.left] == null)) {
        // call has
        callHeap#_701 := Heap;
        callMask#_702 := Mask;
        callCredits#_703 := Credits;
        assert {:msg "  469.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  469.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  469.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#290 := Heap[this, AVLTreeNode.left];
        k#291 := k#47;
        // begin exhale (precondition)
        exhaleMask#_704 := Mask;
        fraction#_705 := 100;
        assert {:msg "  469.6: The precondition at 455.12 might not hold. Insufficient fraction at 455.12 for AVLTreeNode.valid."} (fraction#_705 <= exhaleMask#_704[this#290, AVLTreeNode.valid][perm$R]) && ((fraction#_705 == exhaleMask#_704[this#290, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_704[this#290, AVLTreeNode.valid][perm$N]));
        exhaleMask#_704[this#290, AVLTreeNode.valid] := exhaleMask#_704[this#290, AVLTreeNode.valid][perm$R := exhaleMask#_704[this#290, AVLTreeNode.valid][perm$R] - fraction#_705];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_704);
        epsilons#_706 := 1;
        assert {:msg "  469.6: The precondition at 456.12 might not hold. Insufficient epsilons at 456.12  for AVLTreeNode.keys."} (exhaleMask#_704[this#290, AVLTreeNode.keys][perm$R] == 0) ==> (epsilons#_706 <= exhaleMask#_704[this#290, AVLTreeNode.keys][perm$N]);
        if ((exhaleMask#_704[this#290, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (exhaleMask#_704[this#290, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_704[this#290, AVLTreeNode.keys] := exhaleMask#_704[this#290, AVLTreeNode.keys][perm$N := exhaleMask#_704[this#290, AVLTreeNode.keys][perm$N] - epsilons#_706];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_704);
        Mask := exhaleMask#_704;
        assume wf(Heap, Mask);
        // end exhale
        havoc b#292;
        // inhale (postcondition)
        havoc inhaleHeap#_709;
        assume IsGoodInhaleState(inhaleHeap#_709, Heap, Mask);
        assume this#290 != null;
        Heap[this#290, AVLTreeNode.valid] := inhaleHeap#_709[this#290, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_709[this#290, AVLTreeNode.valid] == Heap;
        Mask[this#290, AVLTreeNode.valid] := Mask[this#290, AVLTreeNode.valid][perm$R := Mask[this#290, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_709[this#290, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_709, Mask);
        assume this#290 != null;
        Heap[this#290, AVLTreeNode.keys] := inhaleHeap#_709[this#290, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[this#290, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (Mask[this#290, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
          Mask[this#290, AVLTreeNode.keys] := Mask[this#290, AVLTreeNode.keys][perm$N := Mask[this#290, AVLTreeNode.keys][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_709[this#290, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_709, Mask);
        assume b#292 == Seq#Contains(Heap[this#290, AVLTreeNode.keys], k#291);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        b#48 := b#292;
      } else {
        // assigment to b
        b#48 := false;
      }
    } else {
      // if
      assert {:msg "  474.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  474.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (!(Heap[this, AVLTreeNode.right] == null)) {
        // call has
        callHeap#_710 := Heap;
        callMask#_711 := Mask;
        callCredits#_712 := Credits;
        assert {:msg "  475.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  475.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  475.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#293 := Heap[this, AVLTreeNode.right];
        k#294 := k#47;
        // begin exhale (precondition)
        exhaleMask#_713 := Mask;
        fraction#_714 := 100;
        assert {:msg "  475.6: The precondition at 455.12 might not hold. Insufficient fraction at 455.12 for AVLTreeNode.valid."} (fraction#_714 <= exhaleMask#_713[this#293, AVLTreeNode.valid][perm$R]) && ((fraction#_714 == exhaleMask#_713[this#293, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_713[this#293, AVLTreeNode.valid][perm$N]));
        exhaleMask#_713[this#293, AVLTreeNode.valid] := exhaleMask#_713[this#293, AVLTreeNode.valid][perm$R := exhaleMask#_713[this#293, AVLTreeNode.valid][perm$R] - fraction#_714];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_713);
        epsilons#_715 := 1;
        assert {:msg "  475.6: The precondition at 456.12 might not hold. Insufficient epsilons at 456.12  for AVLTreeNode.keys."} (exhaleMask#_713[this#293, AVLTreeNode.keys][perm$R] == 0) ==> (epsilons#_715 <= exhaleMask#_713[this#293, AVLTreeNode.keys][perm$N]);
        if ((exhaleMask#_713[this#293, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (exhaleMask#_713[this#293, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_713[this#293, AVLTreeNode.keys] := exhaleMask#_713[this#293, AVLTreeNode.keys][perm$N := exhaleMask#_713[this#293, AVLTreeNode.keys][perm$N] - epsilons#_715];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_713);
        Mask := exhaleMask#_713;
        assume wf(Heap, Mask);
        // end exhale
        havoc b#295;
        // inhale (postcondition)
        havoc inhaleHeap#_718;
        assume IsGoodInhaleState(inhaleHeap#_718, Heap, Mask);
        assume this#293 != null;
        Heap[this#293, AVLTreeNode.valid] := inhaleHeap#_718[this#293, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_718[this#293, AVLTreeNode.valid] == Heap;
        Mask[this#293, AVLTreeNode.valid] := Mask[this#293, AVLTreeNode.valid][perm$R := Mask[this#293, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_718[this#293, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_718, Mask);
        assume this#293 != null;
        Heap[this#293, AVLTreeNode.keys] := inhaleHeap#_718[this#293, AVLTreeNode.keys];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[this#293, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (Mask[this#293, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
          Mask[this#293, AVLTreeNode.keys] := Mask[this#293, AVLTreeNode.keys][perm$N := Mask[this#293, AVLTreeNode.keys][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_718[this#293, AVLTreeNode.keys]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_718, Mask);
        assume b#295 == Seq#Contains(Heap[this#293, AVLTreeNode.keys], k#294);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        b#48 := b#295;
      } else {
        // assigment to b
        b#48 := false;
      }
    }
  }
  // fold
  assert {:msg "  481.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_719 := Mask;
  fraction#_720 := 100;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (fraction#_720 <= exhaleMask#_719[this, AVLTreeNode.key][perm$R]) && ((fraction#_720 == exhaleMask#_719[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_719[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_719[this, AVLTreeNode.key] := exhaleMask#_719[this, AVLTreeNode.key][perm$R := exhaleMask#_719[this, AVLTreeNode.key][perm$R] - fraction#_720];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_719);
  fraction#_721 := 100;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (fraction#_721 <= exhaleMask#_719[this, AVLTreeNode.left][perm$R]) && ((fraction#_721 == exhaleMask#_719[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_719[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_719[this, AVLTreeNode.left] := exhaleMask#_719[this, AVLTreeNode.left][perm$R := exhaleMask#_719[this, AVLTreeNode.left][perm$R] - fraction#_721];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_719);
  fraction#_722 := 100;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (fraction#_722 <= exhaleMask#_719[this, AVLTreeNode.right][perm$R]) && ((fraction#_722 == exhaleMask#_719[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_719[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_719[this, AVLTreeNode.right] := exhaleMask#_719[this, AVLTreeNode.right][perm$R := exhaleMask#_719[this, AVLTreeNode.right][perm$R] - fraction#_722];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_719);
  fraction#_723 := 50;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} (fraction#_723 <= exhaleMask#_719[this, AVLTreeNode.keys][perm$R]) && ((fraction#_723 == exhaleMask#_719[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_719[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_719[this, AVLTreeNode.keys] := exhaleMask#_719[this, AVLTreeNode.keys][perm$R := exhaleMask#_719[this, AVLTreeNode.keys][perm$R] - fraction#_723];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_719);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_724 := 100;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (fraction#_724 <= exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_724 == exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_724];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_719);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_725 := 50;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} (fraction#_725 <= exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_725 == exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_719[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_725];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_719);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#67#296: int :: (0 <= lk#67#296) && (lk#67#296 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#296) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_726 := 100;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (fraction#_726 <= exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_726 == exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_726];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_719);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_727 := 50;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} (fraction#_727 <= exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_727 == exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_719[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_727];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_719);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#68#297: int :: (0 <= rk#68#297) && (rk#68#297 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#297)));
  } else {
  }
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  Mask := exhaleMask#_719;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_728;
  assume IsGoodInhaleState(inhaleHeap#_728, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_728[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_728[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_728[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_728, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTreeNode.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_729 := Mask;
  fraction#_730 := 100;
  assert {:msg "  454.2: The postcondition at 458.11 might not hold. Insufficient fraction at 458.11 for AVLTreeNode.valid."} (fraction#_730 <= exhaleMask#_729[this, AVLTreeNode.valid][perm$R]) && ((fraction#_730 == exhaleMask#_729[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_729[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_729[this, AVLTreeNode.valid] := exhaleMask#_729[this, AVLTreeNode.valid][perm$R := exhaleMask#_729[this, AVLTreeNode.valid][perm$R] - fraction#_730];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_729);
  epsilons#_731 := 1;
  assert {:msg "  454.2: The postcondition at 459.11 might not hold. Insufficient epsilons at 459.11  for AVLTreeNode.keys."} (exhaleMask#_729[this, AVLTreeNode.keys][perm$R] == 0) ==> (epsilons#_731 <= exhaleMask#_729[this, AVLTreeNode.keys][perm$N]);
  if ((exhaleMask#_729[this, AVLTreeNode.keys][perm$N] != Permission$MinusInfinity) && (exhaleMask#_729[this, AVLTreeNode.keys][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_729[this, AVLTreeNode.keys] := exhaleMask#_729[this, AVLTreeNode.keys][perm$N := exhaleMask#_729[this, AVLTreeNode.keys][perm$N] - epsilons#_731];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_729);
  assert {:msg "  454.2: The postcondition at 460.11 might not hold. The expression at 460.11 might not evaluate to true."} b#48 == Seq#Contains(Heap[this, AVLTreeNode.keys], k#47);
  Mask := exhaleMask#_729;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  454.2: Method might lock/unlock more than allowed."} (forall lk#_732: ref :: {Heap[lk#_732, held]} {Heap[lk#_732, rdheld]} (((0 < Heap[lk#_732, held]) == (0 < old(Heap)[lk#_732, held])) && (Heap[lk#_732, rdheld] == old(Heap)[lk#_732, rdheld])) || false);
  assert {:msg "  454.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.getBalanceFactor$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_733: HeapType;
  var inhaleHeap#_734: HeapType;
  var Heap#_738: HeapType;
  var Mask#_739: MaskType;
  var Credits#_740: CreditsType;
  var exhaleMask#_741: MaskType;
  var fraction#_742: int;
  var inhaleHeap#_743: HeapType;
  var Heap#_747: HeapType;
  var Mask#_748: MaskType;
  var Credits#_749: CreditsType;
  var exhaleMask#_750: MaskType;
  var fraction#_751: int;
  var inhaleHeap#_752: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_733;
  assume IsGoodInhaleState(inhaleHeap#_733, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_733[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_733[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_733[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_733, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_734;
  assume IsGoodInhaleState(inhaleHeap#_734, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_734[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_734[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_734[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_734, Mask);
  // unfolding
  assert {:msg "  493.21: Receiver might be null."} true ==> (this != null);
  Heap#_738 := Heap;
  Mask#_739 := Mask;
  Credits#_740 := Credits;
  // begin exhale (unfolding)
  exhaleMask#_741 := Mask#_739;
  fraction#_742 := 100;
  assert {:msg "  493.11: Unfolding might fail. Insufficient fraction at 493.21 for AVLTreeNode.valid."} (fraction#_742 <= exhaleMask#_741[this, AVLTreeNode.valid][perm$R]) && ((fraction#_742 == exhaleMask#_741[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_741[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_741[this, AVLTreeNode.valid] := exhaleMask#_741[this, AVLTreeNode.valid][perm$R := exhaleMask#_741[this, AVLTreeNode.valid][perm$R] - fraction#_742];
  assume IsGoodMask(Mask#_739);
  assume wf(Heap#_738, Mask#_739);
  assume wf(Heap#_738, exhaleMask#_741);
  Mask#_739 := exhaleMask#_741;
  assume wf(Heap#_738, Mask#_739);
  // end exhale
  // inhale (unfolding)
  inhaleHeap#_743 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_743, Heap#_738, Mask#_739);
  assume this != null;
  Heap#_738[this, AVLTreeNode.key] := inhaleHeap#_743[this, AVLTreeNode.key];
  assume wf(Heap#_738, Mask#_739);
  assume true;
  Mask#_739[this, AVLTreeNode.key] := Mask#_739[this, AVLTreeNode.key][perm$R := Mask#_739[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask#_739);
  assume IsGoodState(inhaleHeap#_743[this, AVLTreeNode.key]);
  assume wf(Heap#_738, Mask#_739);
  assume wf(inhaleHeap#_743, Mask#_739);
  assume this != null;
  Heap#_738[this, AVLTreeNode.left] := inhaleHeap#_743[this, AVLTreeNode.left];
  assume wf(Heap#_738, Mask#_739);
  assume (Heap#_738[this, AVLTreeNode.left] == null) || (dtype(Heap#_738[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask#_739[this, AVLTreeNode.left] := Mask#_739[this, AVLTreeNode.left][perm$R := Mask#_739[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask#_739);
  assume IsGoodState(inhaleHeap#_743[this, AVLTreeNode.left]);
  assume wf(Heap#_738, Mask#_739);
  assume wf(inhaleHeap#_743, Mask#_739);
  assume this != null;
  Heap#_738[this, AVLTreeNode.right] := inhaleHeap#_743[this, AVLTreeNode.right];
  assume wf(Heap#_738, Mask#_739);
  assume (Heap#_738[this, AVLTreeNode.right] == null) || (dtype(Heap#_738[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask#_739[this, AVLTreeNode.right] := Mask#_739[this, AVLTreeNode.right][perm$R := Mask#_739[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask#_739);
  assume IsGoodState(inhaleHeap#_743[this, AVLTreeNode.right]);
  assume wf(Heap#_738, Mask#_739);
  assume wf(inhaleHeap#_743, Mask#_739);
  assume this != null;
  Heap#_738[this, AVLTreeNode.keys] := inhaleHeap#_743[this, AVLTreeNode.keys];
  assume wf(Heap#_738, Mask#_739);
  assume true;
  Mask#_739[this, AVLTreeNode.keys] := Mask#_739[this, AVLTreeNode.keys][perm$R := Mask#_739[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask#_739);
  assume IsGoodState(inhaleHeap#_743[this, AVLTreeNode.keys]);
  assume wf(Heap#_738, Mask#_739);
  assume wf(inhaleHeap#_743, Mask#_739);
  if (!(Heap#_738[this, AVLTreeNode.left] == null)) {
    assume Heap#_738[this, AVLTreeNode.left] != null;
    Heap#_738[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_743[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap#_738, Mask#_739);
    assume inhaleHeap#_743[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap#_738;
    Mask#_739[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask#_739[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_739[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_739);
    assume IsGoodState(inhaleHeap#_743[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap#_738, Mask#_739);
    assume wf(inhaleHeap#_743, Mask#_739);
  } else {
  }
  if (!(Heap#_738[this, AVLTreeNode.left] == null)) {
    assume Heap#_738[this, AVLTreeNode.left] != null;
    Heap#_738[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_743[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap#_738, Mask#_739);
    assume true;
    Mask#_739[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask#_739[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_739[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_739);
    assume IsGoodState(inhaleHeap#_743[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap#_738, Mask#_739);
    assume wf(inhaleHeap#_743, Mask#_739);
  } else {
  }
  if (!(Heap#_738[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#298: int :: (0 <= lk#67#298) && (lk#67#298 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_738[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#298) < Heap#_738[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap#_738[this, AVLTreeNode.right] == null)) {
    assume Heap#_738[this, AVLTreeNode.right] != null;
    Heap#_738[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_743[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap#_738, Mask#_739);
    assume inhaleHeap#_743[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap#_738;
    Mask#_739[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask#_739[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_739[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_739);
    assume IsGoodState(inhaleHeap#_743[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap#_738, Mask#_739);
    assume wf(inhaleHeap#_743, Mask#_739);
  } else {
  }
  if (!(Heap#_738[this, AVLTreeNode.right] == null)) {
    assume Heap#_738[this, AVLTreeNode.right] != null;
    Heap#_738[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_743[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap#_738, Mask#_739);
    assume true;
    Mask#_739[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask#_739[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_739[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_739);
    assume IsGoodState(inhaleHeap#_743[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap#_738, Mask#_739);
    assume wf(inhaleHeap#_743, Mask#_739);
  } else {
  }
  if (!(Heap#_738[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#299: int :: (0 <= rk#68#299) && (rk#68#299 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_738[this, AVLTreeNode.key] < Seq#Index(Heap#_738[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#299)));
  } else {
  }
  assume Seq#Equal(Heap#_738[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap#_738[this, AVLTreeNode.left] == null, Seq#Empty(), Heap#_738[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap#_738[this, AVLTreeNode.key])), ite(Heap#_738[this, AVLTreeNode.right] == null, Seq#Empty(), Heap#_738[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap#_738[this, AVLTreeNode.keys], Heap#_738[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap#_738[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap#_738[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap#_738[Heap#_738[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap#_738[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap#_738[Heap#_738[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap#_738[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask#_739);
  assume wf(Heap#_738, Mask#_739);
  // end inhale
  assert {:msg "  493.39: Receiver might be null."} true && (bf#49 > 0) ==> (this != null);
  assert {:msg "  493.39: Location might not be readable."} true && (bf#49 > 0) ==> CanRead(Mask#_739, this, AVLTreeNode.left);
  assume (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  // unfolding
  assert {:msg "  494.21: Receiver might be null."} true ==> (this != null);
  Heap#_747 := Heap;
  Mask#_748 := Mask;
  Credits#_749 := Credits;
  // begin exhale (unfolding)
  exhaleMask#_750 := Mask#_748;
  fraction#_751 := 100;
  assert {:msg "  494.11: Unfolding might fail. Insufficient fraction at 494.21 for AVLTreeNode.valid."} (fraction#_751 <= exhaleMask#_750[this, AVLTreeNode.valid][perm$R]) && ((fraction#_751 == exhaleMask#_750[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_750[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_750[this, AVLTreeNode.valid] := exhaleMask#_750[this, AVLTreeNode.valid][perm$R := exhaleMask#_750[this, AVLTreeNode.valid][perm$R] - fraction#_751];
  assume IsGoodMask(Mask#_748);
  assume wf(Heap#_747, Mask#_748);
  assume wf(Heap#_747, exhaleMask#_750);
  Mask#_748 := exhaleMask#_750;
  assume wf(Heap#_747, Mask#_748);
  // end exhale
  // inhale (unfolding)
  inhaleHeap#_752 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_752, Heap#_747, Mask#_748);
  assume this != null;
  Heap#_747[this, AVLTreeNode.key] := inhaleHeap#_752[this, AVLTreeNode.key];
  assume wf(Heap#_747, Mask#_748);
  assume true;
  Mask#_748[this, AVLTreeNode.key] := Mask#_748[this, AVLTreeNode.key][perm$R := Mask#_748[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask#_748);
  assume IsGoodState(inhaleHeap#_752[this, AVLTreeNode.key]);
  assume wf(Heap#_747, Mask#_748);
  assume wf(inhaleHeap#_752, Mask#_748);
  assume this != null;
  Heap#_747[this, AVLTreeNode.left] := inhaleHeap#_752[this, AVLTreeNode.left];
  assume wf(Heap#_747, Mask#_748);
  assume (Heap#_747[this, AVLTreeNode.left] == null) || (dtype(Heap#_747[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask#_748[this, AVLTreeNode.left] := Mask#_748[this, AVLTreeNode.left][perm$R := Mask#_748[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask#_748);
  assume IsGoodState(inhaleHeap#_752[this, AVLTreeNode.left]);
  assume wf(Heap#_747, Mask#_748);
  assume wf(inhaleHeap#_752, Mask#_748);
  assume this != null;
  Heap#_747[this, AVLTreeNode.right] := inhaleHeap#_752[this, AVLTreeNode.right];
  assume wf(Heap#_747, Mask#_748);
  assume (Heap#_747[this, AVLTreeNode.right] == null) || (dtype(Heap#_747[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask#_748[this, AVLTreeNode.right] := Mask#_748[this, AVLTreeNode.right][perm$R := Mask#_748[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask#_748);
  assume IsGoodState(inhaleHeap#_752[this, AVLTreeNode.right]);
  assume wf(Heap#_747, Mask#_748);
  assume wf(inhaleHeap#_752, Mask#_748);
  assume this != null;
  Heap#_747[this, AVLTreeNode.keys] := inhaleHeap#_752[this, AVLTreeNode.keys];
  assume wf(Heap#_747, Mask#_748);
  assume true;
  Mask#_748[this, AVLTreeNode.keys] := Mask#_748[this, AVLTreeNode.keys][perm$R := Mask#_748[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask#_748);
  assume IsGoodState(inhaleHeap#_752[this, AVLTreeNode.keys]);
  assume wf(Heap#_747, Mask#_748);
  assume wf(inhaleHeap#_752, Mask#_748);
  if (!(Heap#_747[this, AVLTreeNode.left] == null)) {
    assume Heap#_747[this, AVLTreeNode.left] != null;
    Heap#_747[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_752[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap#_747, Mask#_748);
    assume inhaleHeap#_752[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap#_747;
    Mask#_748[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask#_748[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_748[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_748);
    assume IsGoodState(inhaleHeap#_752[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap#_747, Mask#_748);
    assume wf(inhaleHeap#_752, Mask#_748);
  } else {
  }
  if (!(Heap#_747[this, AVLTreeNode.left] == null)) {
    assume Heap#_747[this, AVLTreeNode.left] != null;
    Heap#_747[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_752[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap#_747, Mask#_748);
    assume true;
    Mask#_748[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask#_748[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_748[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_748);
    assume IsGoodState(inhaleHeap#_752[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap#_747, Mask#_748);
    assume wf(inhaleHeap#_752, Mask#_748);
  } else {
  }
  if (!(Heap#_747[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#300: int :: (0 <= lk#67#300) && (lk#67#300 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_747[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#300) < Heap#_747[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap#_747[this, AVLTreeNode.right] == null)) {
    assume Heap#_747[this, AVLTreeNode.right] != null;
    Heap#_747[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_752[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap#_747, Mask#_748);
    assume inhaleHeap#_752[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap#_747;
    Mask#_748[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask#_748[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_748[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_748);
    assume IsGoodState(inhaleHeap#_752[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap#_747, Mask#_748);
    assume wf(inhaleHeap#_752, Mask#_748);
  } else {
  }
  if (!(Heap#_747[this, AVLTreeNode.right] == null)) {
    assume Heap#_747[this, AVLTreeNode.right] != null;
    Heap#_747[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_752[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap#_747, Mask#_748);
    assume true;
    Mask#_748[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask#_748[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_748[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_748);
    assume IsGoodState(inhaleHeap#_752[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap#_747, Mask#_748);
    assume wf(inhaleHeap#_752, Mask#_748);
  } else {
  }
  if (!(Heap#_747[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#301: int :: (0 <= rk#68#301) && (rk#68#301 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_747[this, AVLTreeNode.key] < Seq#Index(Heap#_747[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#301)));
  } else {
  }
  assume Seq#Equal(Heap#_747[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap#_747[this, AVLTreeNode.left] == null, Seq#Empty(), Heap#_747[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap#_747[this, AVLTreeNode.key])), ite(Heap#_747[this, AVLTreeNode.right] == null, Seq#Empty(), Heap#_747[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap#_747[this, AVLTreeNode.keys], Heap#_747[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap#_747[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap#_747[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap#_747[Heap#_747[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap#_747[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap#_747[Heap#_747[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap#_747[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask#_748);
  assume wf(Heap#_747, Mask#_748);
  // end inhale
  assert {:msg "  494.39: Receiver might be null."} true && (bf#49 < 0) ==> (this != null);
  assert {:msg "  494.39: Location might not be readable."} true && (bf#49 < 0) ==> CanRead(Mask#_748, this, AVLTreeNode.right);
  assume (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.getBalanceFactor(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_753: HeapType;
  var exhaleMask#_754: MaskType;
  var fraction#_755: int;
  var inhaleHeap#_756: HeapType;
  var exhaleMask#_757: MaskType;
  var fraction#_758: int;
  var fraction#_759: int;
  var fraction#_760: int;
  var fraction#_761: int;
  var fraction#_762: int;
  var fraction#_763: int;
  var fraction#_764: int;
  var fraction#_765: int;
  var inhaleHeap#_766: HeapType;
  var exhaleMask#_767: MaskType;
  var fraction#_768: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_753;
  assume IsGoodInhaleState(inhaleHeap#_753, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_753[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_753[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_753[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_753, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  496.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_754 := Mask;
  fraction#_755 := 100;
  assert {:msg "  496.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_755 <= exhaleMask#_754[this, AVLTreeNode.valid][perm$R]) && ((fraction#_755 == exhaleMask#_754[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_754[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_754[this, AVLTreeNode.valid] := exhaleMask#_754[this, AVLTreeNode.valid][perm$R := exhaleMask#_754[this, AVLTreeNode.valid][perm$R] - fraction#_755];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_754);
  Mask := exhaleMask#_754;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_756 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_756, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_756[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_756[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_756, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_756[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_756[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_756, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_756[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_756[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_756, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_756[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_756[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_756, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_756[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_756[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_756[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_756, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_756[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_756[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_756, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall lk#67#302: int :: (0 <= lk#67#302) && (lk#67#302 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#302) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_756[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_756[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_756[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_756, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_756[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_756[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_756, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall rk#68#303: int :: (0 <= rk#68#303) && (rk#68#303 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#303)));
  } else {
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assume
  assert {:msg "  501.19: Receiver might be null."} true && (bf#49 > 0) ==> (this != null);
  assert {:msg "  501.19: Location might not be readable."} true && (bf#49 > 0) ==> CanRead(Mask, this, AVLTreeNode.left);
  assume (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  // assume
  assert {:msg "  502.19: Receiver might be null."} true && (bf#49 < 0) ==> (this != null);
  assert {:msg "  502.19: Location might not be readable."} true && (bf#49 < 0) ==> CanRead(Mask, this, AVLTreeNode.right);
  assume (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  // fold
  assert {:msg "  504.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_757 := Mask;
  fraction#_758 := 100;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (fraction#_758 <= exhaleMask#_757[this, AVLTreeNode.key][perm$R]) && ((fraction#_758 == exhaleMask#_757[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.key] := exhaleMask#_757[this, AVLTreeNode.key][perm$R := exhaleMask#_757[this, AVLTreeNode.key][perm$R] - fraction#_758];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_759 := 100;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (fraction#_759 <= exhaleMask#_757[this, AVLTreeNode.left][perm$R]) && ((fraction#_759 == exhaleMask#_757[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.left] := exhaleMask#_757[this, AVLTreeNode.left][perm$R := exhaleMask#_757[this, AVLTreeNode.left][perm$R] - fraction#_759];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_760 := 100;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (fraction#_760 <= exhaleMask#_757[this, AVLTreeNode.right][perm$R]) && ((fraction#_760 == exhaleMask#_757[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.right] := exhaleMask#_757[this, AVLTreeNode.right][perm$R := exhaleMask#_757[this, AVLTreeNode.right][perm$R] - fraction#_760];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_761 := 50;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} (fraction#_761 <= exhaleMask#_757[this, AVLTreeNode.keys][perm$R]) && ((fraction#_761 == exhaleMask#_757[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.keys] := exhaleMask#_757[this, AVLTreeNode.keys][perm$R := exhaleMask#_757[this, AVLTreeNode.keys][perm$R] - fraction#_761];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_762 := 100;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (fraction#_762 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_762 == exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_762];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_763 := 50;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} (fraction#_763 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_763 == exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_763];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#67#304: int :: (0 <= lk#67#304) && (lk#67#304 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#304) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_764 := 100;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (fraction#_764 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_764 == exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_764];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_765 := 50;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} (fraction#_765 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_765 == exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_765];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#68#305: int :: (0 <= rk#68#305) && (rk#68#305 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#305)));
  } else {
  }
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  Mask := exhaleMask#_757;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_766;
  assume IsGoodInhaleState(inhaleHeap#_766, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_766[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_766[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_766[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_766, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTreeNode.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_767 := Mask;
  fraction#_768 := 100;
  assert {:msg "  485.2: The postcondition at 489.11 might not hold. Insufficient fraction at 489.11 for AVLTreeNode.valid."} (fraction#_768 <= exhaleMask#_767[this, AVLTreeNode.valid][perm$R]) && ((fraction#_768 == exhaleMask#_767[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_767[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_767[this, AVLTreeNode.valid] := exhaleMask#_767[this, AVLTreeNode.valid][perm$R := exhaleMask#_767[this, AVLTreeNode.valid][perm$R] - fraction#_768];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_767);
  assert {:msg "  485.2: The postcondition at 493.11 might not hold. The expression at 493.11 might not evaluate to true."} (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  assert {:msg "  485.2: The postcondition at 494.11 might not hold. The expression at 494.11 might not evaluate to true."} (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  Mask := exhaleMask#_767;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  485.2: Method might lock/unlock more than allowed."} (forall lk#_769: ref :: {Heap[lk#_769, held]} {Heap[lk#_769, rdheld]} (((0 < Heap[lk#_769, held]) == (0 < old(Heap)[lk#_769, held])) && (Heap[lk#_769, rdheld] == old(Heap)[lk#_769, rdheld])) || false);
  assert {:msg "  485.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.getBalanceFactorI$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#50: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_770: HeapType;
  var inhaleHeap#_771: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_770;
  assume IsGoodInhaleState(inhaleHeap#_770, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_770[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$N := Mask[this, AVLTreeNode.left][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_770[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_770, Mask);
  assert {:msg "  510.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  510.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  510.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  510.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_770[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_770[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_770[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_770, Mask);
  } else {
  }
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_770[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$N := Mask[this, AVLTreeNode.right][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_770[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_770, Mask);
  assert {:msg "  514.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  514.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  514.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  514.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_770[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_770[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_770[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_770, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_771;
  assume IsGoodInhaleState(inhaleHeap#_771, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_771[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$N := Mask[this, AVLTreeNode.left][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_771[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_771, Mask);
  assert {:msg "  518.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  518.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  518.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  518.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_771[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_771[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_771[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_771, Mask);
  } else {
  }
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_771[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$N := Mask[this, AVLTreeNode.right][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_771[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_771, Mask);
  assert {:msg "  522.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  522.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  522.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  522.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_771[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_771[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_771[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_771, Mask);
  } else {
  }
  if (bf#50 > 0) {
    assert {:msg "  526.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  526.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume !(Heap[this, AVLTreeNode.left] == null);
  } else {
  }
  if (bf#50 < 0) {
    assert {:msg "  527.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  527.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume !(Heap[this, AVLTreeNode.right] == null);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.getBalanceFactorI(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#50: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_772: HeapType;
  var exhaleMask#_773: MaskType;
  var epsilons#_774: int;
  var fraction#_775: int;
  var epsilons#_776: int;
  var fraction#_777: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_772;
  assume IsGoodInhaleState(inhaleHeap#_772, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_772[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$N := Mask[this, AVLTreeNode.left][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_772[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_772, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_772[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_772[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_772[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_772, Mask);
  } else {
  }
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_772[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$N := Mask[this, AVLTreeNode.right][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_772[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_772, Mask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_772[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_772[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_772[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_772, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assume
  assert {:msg "  536.19: Receiver might be null."} true && (bf#50 > 0) ==> (this != null);
  assert {:msg "  536.19: Location might not be readable."} true && (bf#50 > 0) ==> CanRead(Mask, this, AVLTreeNode.left);
  assume (bf#50 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  // assume
  assert {:msg "  537.19: Receiver might be null."} true && (bf#50 < 0) ==> (this != null);
  assert {:msg "  537.19: Location might not be readable."} true && (bf#50 < 0) ==> CanRead(Mask, this, AVLTreeNode.right);
  assume (bf#50 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  // begin exhale (postcondition)
  exhaleMask#_773 := Mask;
  epsilons#_774 := 1;
  assert {:msg "  508.2: The postcondition at 517.11 might not hold. Insufficient epsilons at 517.11  for AVLTreeNode.left."} (exhaleMask#_773[this, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_774 <= exhaleMask#_773[this, AVLTreeNode.left][perm$N]);
  if ((exhaleMask#_773[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_773[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_773[this, AVLTreeNode.left] := exhaleMask#_773[this, AVLTreeNode.left][perm$N := exhaleMask#_773[this, AVLTreeNode.left][perm$N] - epsilons#_774];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_773);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_775 := 100;
    assert {:msg "  508.2: The postcondition at 518.11 might not hold. Insufficient fraction at 518.26 for AVLTreeNode.valid."} (fraction#_775 <= exhaleMask#_773[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_775 == exhaleMask#_773[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_773[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_773[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_773[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_773[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_775];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_773);
  } else {
  }
  epsilons#_776 := 1;
  assert {:msg "  508.2: The postcondition at 521.11 might not hold. Insufficient epsilons at 521.11  for AVLTreeNode.right."} (exhaleMask#_773[this, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_776 <= exhaleMask#_773[this, AVLTreeNode.right][perm$N]);
  if ((exhaleMask#_773[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_773[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_773[this, AVLTreeNode.right] := exhaleMask#_773[this, AVLTreeNode.right][perm$N := exhaleMask#_773[this, AVLTreeNode.right][perm$N] - epsilons#_776];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_773);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_777 := 100;
    assert {:msg "  508.2: The postcondition at 522.11 might not hold. Insufficient fraction at 522.27 for AVLTreeNode.valid."} (fraction#_777 <= exhaleMask#_773[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_777 == exhaleMask#_773[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_773[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_773[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_773[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_773[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_777];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_773);
  } else {
  }
  if (bf#50 > 0) {
    assert {:msg "  508.2: The postcondition at 526.11 might not hold. The expression at 526.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.left] == null);
  } else {
  }
  if (bf#50 < 0) {
    assert {:msg "  508.2: The postcondition at 527.11 might not hold. The expression at 527.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.right] == null);
  } else {
  }
  Mask := exhaleMask#_773;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  508.2: Method might lock/unlock more than allowed."} (forall lk#_778: ref :: {Heap[lk#_778, held]} {Heap[lk#_778, rdheld]} (((0 < Heap[lk#_778, held]) == (0 < old(Heap)[lk#_778, held])) && (Heap[lk#_778, rdheld] == old(Heap)[lk#_778, rdheld])) || false);
  assert {:msg "  508.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.close$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_779: HeapType;
  var k#79#307: int where true;
  var k#80#309: int where true;
  var inhaleHeap#_780: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_779;
  assume IsGoodInhaleState(inhaleHeap#_779, Heap, Mask);
  assert {:msg "  542.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  542.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_779[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_779[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_779, Mask);
  assert {:msg "  544.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  544.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_779[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_779[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_779, Mask);
  assert {:msg "  545.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  545.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_779[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_779[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_779, Mask);
  assert {:msg "  547.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  547.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_779[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_779[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_779, Mask);
  assert {:msg "  550.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  550.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  550.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  550.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_779[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_779[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_779[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_779, Mask);
  } else {
  }
  assert {:msg "  552.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  552.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  552.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  552.50: Fraction might be negative."} 0 <= 50;
    assert {:msg "  552.50: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_779[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_779[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_779, Mask);
  } else {
  }
  assert {:msg "  554.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  554.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  554.12: Receiver might be null."} true && (0 <= k#79#307) ==> (this != null);
    assert {:msg "  554.12: Location might not be readable."} true && (0 <= k#79#307) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  554.12: Receiver might be null."} true && (0 <= k#79#307) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  554.12: Location might not be readable."} true && (0 <= k#79#307) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  554.12: Receiver might be null."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  554.12: Location might not be readable."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  554.12: Receiver might be null."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  554.12: Location might not be readable."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  554.52: Sequence index might be negative."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#79#307);
    assert {:msg "  554.52: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  554.56: Receiver might be null."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  554.56: Location might not be readable."} true && (0 <= k#79#307) && (k#79#307 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#79#306: int :: (0 <= k#79#306) && (k#79#306 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#79#306) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assert {:msg "  556.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  556.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  556.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  556.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_779[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_779[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_779[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_779, Mask);
  } else {
  }
  assert {:msg "  558.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  558.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  558.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  558.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  558.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  558.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_779[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_779[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_779, Mask);
  } else {
  }
  assert {:msg "  560.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  560.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  560.12: Receiver might be null."} true && (0 <= k#80#309) ==> (this != null);
    assert {:msg "  560.12: Location might not be readable."} true && (0 <= k#80#309) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  560.12: Receiver might be null."} true && (0 <= k#80#309) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  560.12: Location might not be readable."} true && (0 <= k#80#309) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  560.54: Receiver might be null."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  560.54: Location might not be readable."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  560.12: Receiver might be null."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  560.12: Location might not be readable."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  560.12: Receiver might be null."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  560.12: Location might not be readable."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  560.60: Sequence index might be negative."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#80#309);
    assert {:msg "  560.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#80#309) && (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#80#309 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#80#308: int :: (0 <= k#80#308) && (k#80#308 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#80#308)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_780;
  assume IsGoodInhaleState(inhaleHeap#_780, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_780[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_780[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_780[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_780, Mask);
  assert {:msg "  567.29: Fraction might be negative."} 0 <= 50;
  assert {:msg "  567.29: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_780[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_780[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_780, Mask);
  assert {:msg "  570.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.keys);
  assert {:msg "  571.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  571.10: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  571.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  571.39: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  571.39: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  571.39: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  571.60: Receiver might be null."} true ==> (this != null);
  assert {:msg "  571.60: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  571.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  571.75: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  571.105: Receiver might be null."} true ==> (this != null);
    assert {:msg "  571.105: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  571.105: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  571.105: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.close(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_781: HeapType;
  var exhaleMask#_782: MaskType;
  var fraction#_783: int;
  var fraction#_784: int;
  var fraction#_785: int;
  var fraction#_786: int;
  var fraction#_787: int;
  var fraction#_788: int;
  var fraction#_789: int;
  var fraction#_790: int;
  var inhaleHeap#_791: HeapType;
  var exhaleMask#_792: MaskType;
  var fraction#_793: int;
  var fraction#_794: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_781;
  assume IsGoodInhaleState(inhaleHeap#_781, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_781[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_781[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_781, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_781[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_781[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_781, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_781[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_781[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_781, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_781[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_781[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_781, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_781[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_781[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_781[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_781, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_781[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_781[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_781, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#79#310: int :: (0 <= k#79#310) && (k#79#310 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#79#310) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_781[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_781[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_781[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_781, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_781[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_781[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_781, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#80#311: int :: (0 <= k#80#311) && (k#80#311 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#80#311)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field keys
  assert {:msg "  591.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.keys);
  assert {:msg "  591.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  591.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  591.46: Receiver might be null."} true ==> (this != null);
    assert {:msg "  591.46: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  591.46: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  591.46: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  591.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  591.62: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  591.72: Receiver might be null."} true ==> (this != null);
  assert {:msg "  591.72: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  591.97: Receiver might be null."} true ==> (this != null);
    assert {:msg "  591.97: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  591.97: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  591.97: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  Heap[this, AVLTreeNode.keys] := Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume wf(Heap, Mask);
  // fold
  assert {:msg "  593.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_782 := Mask;
  fraction#_783 := 100;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (fraction#_783 <= exhaleMask#_782[this, AVLTreeNode.key][perm$R]) && ((fraction#_783 == exhaleMask#_782[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_782[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_782[this, AVLTreeNode.key] := exhaleMask#_782[this, AVLTreeNode.key][perm$R := exhaleMask#_782[this, AVLTreeNode.key][perm$R] - fraction#_783];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_782);
  fraction#_784 := 100;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (fraction#_784 <= exhaleMask#_782[this, AVLTreeNode.left][perm$R]) && ((fraction#_784 == exhaleMask#_782[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_782[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_782[this, AVLTreeNode.left] := exhaleMask#_782[this, AVLTreeNode.left][perm$R := exhaleMask#_782[this, AVLTreeNode.left][perm$R] - fraction#_784];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_782);
  fraction#_785 := 100;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (fraction#_785 <= exhaleMask#_782[this, AVLTreeNode.right][perm$R]) && ((fraction#_785 == exhaleMask#_782[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_782[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_782[this, AVLTreeNode.right] := exhaleMask#_782[this, AVLTreeNode.right][perm$R := exhaleMask#_782[this, AVLTreeNode.right][perm$R] - fraction#_785];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_782);
  fraction#_786 := 50;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 122.6 for AVLTreeNode.keys."} (fraction#_786 <= exhaleMask#_782[this, AVLTreeNode.keys][perm$R]) && ((fraction#_786 == exhaleMask#_782[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_782[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_782[this, AVLTreeNode.keys] := exhaleMask#_782[this, AVLTreeNode.keys][perm$R := exhaleMask#_782[this, AVLTreeNode.keys][perm$R] - fraction#_786];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_782);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_787 := 100;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (fraction#_787 <= exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_787 == exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_787];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_782);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_788 := 50;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 127.22 for AVLTreeNode.keys."} (fraction#_788 <= exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_788 == exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_782[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_788];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_782);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 129.22 might not evaluate to true."} (forall lk#67#312: int :: (0 <= lk#67#312) && (lk#67#312 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], lk#67#312) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_789 := 100;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (fraction#_789 <= exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_789 == exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_789];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_782);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_790 := 50;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 134.23 for AVLTreeNode.keys."} (fraction#_790 <= exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_790 == exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_782[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_790];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_782);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 136.24 might not evaluate to true."} (forall rk#68#313: int :: (0 <= rk#68#313) && (rk#68#313 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], rk#68#313)));
  } else {
  }
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 139.6 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[this, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[this, AVLTreeNode.key])), ite(Heap[this, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 140.6 might not evaluate to true."} Seq#Contains(Heap[this, AVLTreeNode.keys], Heap[this, AVLTreeNode.key]);
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 141.7 might not evaluate to true."} (forall kk#69: int :: Seq#Contains(Heap[this, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[this, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[this, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[this, AVLTreeNode.key])));
  Mask := exhaleMask#_782;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_791;
  assume IsGoodInhaleState(inhaleHeap#_791, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_791[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_791[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_791[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_791, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTreeNode.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_792 := Mask;
  fraction#_793 := 100;
  assert {:msg "  541.2: The postcondition at 565.11 might not hold. Insufficient fraction at 565.11 for AVLTreeNode.valid."} (fraction#_793 <= exhaleMask#_792[this, AVLTreeNode.valid][perm$R]) && ((fraction#_793 == exhaleMask#_792[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_792[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_792[this, AVLTreeNode.valid] := exhaleMask#_792[this, AVLTreeNode.valid][perm$R := exhaleMask#_792[this, AVLTreeNode.valid][perm$R] - fraction#_793];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  fraction#_794 := 50;
  assert {:msg "  541.2: The postcondition at 567.11 might not hold. Insufficient fraction at 567.11 for AVLTreeNode.keys."} (fraction#_794 <= exhaleMask#_792[this, AVLTreeNode.keys][perm$R]) && ((fraction#_794 == exhaleMask#_792[this, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_792[this, AVLTreeNode.keys][perm$N]));
  exhaleMask#_792[this, AVLTreeNode.keys] := exhaleMask#_792[this, AVLTreeNode.keys][perm$R := exhaleMask#_792[this, AVLTreeNode.keys][perm$R] - fraction#_794];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  541.2: The postcondition at 570.11 might not hold. The expression at 570.11 might not evaluate to true."} Seq#Equal(Heap[this, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  Mask := exhaleMask#_792;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  541.2: Method might lock/unlock more than allowed."} (forall lk#_795: ref :: {Heap[lk#_795, held]} {Heap[lk#_795, rdheld]} (((0 < Heap[lk#_795, held]) == (0 < old(Heap)[lk#_795, held])) && (Heap[lk#_795, rdheld] == old(Heap)[lk#_795, rdheld])) || false);
  assert {:msg "  541.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLeft$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#51: ref where (r#51 == null) || (dtype(r#51) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_796: HeapType;
  var k#81#315: int where true;
  var k#82#317: int where true;
  var inhaleHeap#_797: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_796;
  assume IsGoodInhaleState(inhaleHeap#_796, Heap, Mask);
  assert {:msg "  598.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  598.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_796[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assert {:msg "  600.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  600.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_796[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assert {:msg "  601.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  601.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_796[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assert {:msg "  603.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  603.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_796[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assert {:msg "  606.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  606.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  607.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  607.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assert {:msg "  609.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  609.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  609.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  609.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assert {:msg "  611.12: Receiver might be null."} true && (0 <= k#81#315) ==> (this != null);
  assert {:msg "  611.12: Location might not be readable."} true && (0 <= k#81#315) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  611.12: Receiver might be null."} true && (0 <= k#81#315) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  611.12: Location might not be readable."} true && (0 <= k#81#315) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  611.12: Receiver might be null."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  611.12: Location might not be readable."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  611.12: Receiver might be null."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  611.12: Location might not be readable."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  611.37: Sequence index might be negative."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#81#315);
  assert {:msg "  611.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  611.41: Receiver might be null."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  611.41: Location might not be readable."} true && (0 <= k#81#315) && (k#81#315 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall k#81#314: int :: (0 <= k#81#314) && (k#81#314 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#81#314) < Heap[this, AVLTreeNode.key]));
  assert {:msg "  613.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  613.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  613.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  613.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  assert {:msg "  615.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  615.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  615.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  615.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  615.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  615.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  assert {:msg "  617.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  617.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  617.12: Receiver might be null."} true && (0 <= k#82#317) ==> (this != null);
    assert {:msg "  617.12: Location might not be readable."} true && (0 <= k#82#317) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  617.12: Receiver might be null."} true && (0 <= k#82#317) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  617.12: Location might not be readable."} true && (0 <= k#82#317) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  617.54: Receiver might be null."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  617.54: Location might not be readable."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  617.12: Receiver might be null."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  617.12: Location might not be readable."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  617.12: Receiver might be null."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  617.12: Location might not be readable."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  617.60: Sequence index might be negative."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#82#317);
    assert {:msg "  617.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#82#317) && (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#82#317 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#82#316: int :: (0 <= k#82#316) && (k#82#316 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#82#316)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_797;
  assume IsGoodInhaleState(inhaleHeap#_797, Heap, Mask);
  assume r#51 != null;
  Heap[r#51, AVLTreeNode.valid] := inhaleHeap#_797[r#51, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_797[r#51, AVLTreeNode.valid] == Heap;
  Mask[r#51, AVLTreeNode.valid] := Mask[r#51, AVLTreeNode.valid][perm$R := Mask[r#51, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_797[r#51, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_797, Mask);
  assert {:msg "  623.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  623.31: Fraction might exceed 100."} 50 <= 100;
  assume r#51 != null;
  Heap[r#51, AVLTreeNode.keys] := inhaleHeap#_797[r#51, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#51, AVLTreeNode.keys] := Mask[r#51, AVLTreeNode.keys][perm$R := Mask[r#51, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_797[r#51, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_797, Mask);
  assert {:msg "  627.11: Receiver might be null."} true ==> (r#51 != null);
  assert {:msg "  627.11: Location might not be readable."} true ==> CanRead(Mask, r#51, AVLTreeNode.keys);
  assert {:msg "  627.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.25: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  627.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  627.25: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  627.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  627.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.59: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  627.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  627.89: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  627.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  627.89: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#51, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLeft(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#51: ref where (r#51 == null) || (dtype(r#51) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_798: HeapType;
  var lbf#53: int where true;
  var this#320: ref where (this#320 == null) || (dtype(this#320) == AVLTreeNode#t);
  var bf#321: int where true;
  var callHeap#_799: HeapType;
  var callMask#_800: MaskType;
  var callCredits#_801: CreditsType;
  var exhaleMask#_802: MaskType;
  var fraction#_803: int;
  var isHeld#_804: int;
  var isRdHeld#_805: bool;
  var inhaleHeap#_806: HeapType;
  var this#322: ref where (this#322 == null) || (dtype(this#322) == AVLTreeNode#t);
  var r#323: ref where (r#323 == null) || (dtype(r#323) == AVLTreeNode#t);
  var callHeap#_807: HeapType;
  var callMask#_808: MaskType;
  var callCredits#_809: CreditsType;
  var exhaleMask#_810: MaskType;
  var fraction#_811: int;
  var fraction#_812: int;
  var fraction#_813: int;
  var fraction#_814: int;
  var fraction#_815: int;
  var fraction#_816: int;
  var fraction#_817: int;
  var fraction#_818: int;
  var isHeld#_819: int;
  var isRdHeld#_820: bool;
  var inhaleHeap#_821: HeapType;
  var this#326: ref where (this#326 == null) || (dtype(this#326) == AVLTreeNode#t);
  var r#327: ref where (r#327 == null) || (dtype(r#327) == AVLTreeNode#t);
  var callHeap#_822: HeapType;
  var callMask#_823: MaskType;
  var callCredits#_824: CreditsType;
  var exhaleMask#_825: MaskType;
  var fraction#_826: int;
  var fraction#_827: int;
  var fraction#_828: int;
  var fraction#_829: int;
  var fraction#_830: int;
  var fraction#_831: int;
  var fraction#_832: int;
  var fraction#_833: int;
  var isHeld#_834: int;
  var isRdHeld#_835: bool;
  var inhaleHeap#_836: HeapType;
  var exhaleMask#_837: MaskType;
  var fraction#_838: int;
  var fraction#_839: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_798;
  assume IsGoodInhaleState(inhaleHeap#_798, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_798[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_798[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_798, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_798[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_798[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_798, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_798[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_798[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_798, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_798[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_798[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_798, Mask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_798[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_798[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_798[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_798, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_798[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_798[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_798, Mask);
  assume (forall k#81#318: int :: (0 <= k#81#318) && (k#81#318 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#81#318) < Heap[this, AVLTreeNode.key]));
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_798[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_798[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_798[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_798, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_798[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_798[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_798, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#82#319: int :: (0 <= k#82#319) && (k#82#319 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#82#319)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var lbf
  // call getBalanceFactor
  callHeap#_799 := Heap;
  callMask#_800 := Mask;
  callCredits#_801 := Credits;
  assert {:msg "  630.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.15: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  630.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#320 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_802 := Mask;
  fraction#_803 := 100;
  assert {:msg "  630.3: The precondition at 486.12 might not hold. Insufficient fraction at 486.12 for AVLTreeNode.valid."} (fraction#_803 <= exhaleMask#_802[this#320, AVLTreeNode.valid][perm$R]) && ((fraction#_803 == exhaleMask#_802[this#320, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_802[this#320, AVLTreeNode.valid][perm$N]));
  exhaleMask#_802[this#320, AVLTreeNode.valid] := exhaleMask#_802[this#320, AVLTreeNode.valid][perm$R := exhaleMask#_802[this#320, AVLTreeNode.valid][perm$R] - fraction#_803];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_802);
  Mask := exhaleMask#_802;
  assume wf(Heap, Mask);
  // end exhale
  havoc bf#321;
  // inhale (postcondition)
  havoc inhaleHeap#_806;
  assume IsGoodInhaleState(inhaleHeap#_806, Heap, Mask);
  assume this#320 != null;
  Heap[this#320, AVLTreeNode.valid] := inhaleHeap#_806[this#320, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_806[this#320, AVLTreeNode.valid] == Heap;
  Mask[this#320, AVLTreeNode.valid] := Mask[this#320, AVLTreeNode.valid][perm$R := Mask[this#320, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_806[this#320, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_806, Mask);
  assume (bf#321 > 0) ==> (!(Heap[this#320, AVLTreeNode.left] == null));
  assume (bf#321 < 0) ==> (!(Heap[this#320, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  lbf#53 := bf#321;
  // if
  if (lbf#53 < 0) {
    // call rebalanceRL
    callHeap#_807 := Heap;
    callMask#_808 := Mask;
    callCredits#_809 := Credits;
    assert {:msg "  633.4: The target of the method call might be null."} this != null;
    this#322 := this;
    // begin exhale (precondition)
    exhaleMask#_810 := Mask;
    fraction#_811 := 100;
    assert {:msg "  633.4: The precondition at 641.12 might not hold. Insufficient fraction at 641.12 for AVLTreeNode.key."} (fraction#_811 <= exhaleMask#_810[this#322, AVLTreeNode.key][perm$R]) && ((fraction#_811 == exhaleMask#_810[this#322, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_810[this#322, AVLTreeNode.key][perm$N]));
    exhaleMask#_810[this#322, AVLTreeNode.key] := exhaleMask#_810[this#322, AVLTreeNode.key][perm$R := exhaleMask#_810[this#322, AVLTreeNode.key][perm$R] - fraction#_811];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_810);
    fraction#_812 := 100;
    assert {:msg "  633.4: The precondition at 643.12 might not hold. Insufficient fraction at 643.12 for AVLTreeNode.left."} (fraction#_812 <= exhaleMask#_810[this#322, AVLTreeNode.left][perm$R]) && ((fraction#_812 == exhaleMask#_810[this#322, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_810[this#322, AVLTreeNode.left][perm$N]));
    exhaleMask#_810[this#322, AVLTreeNode.left] := exhaleMask#_810[this#322, AVLTreeNode.left][perm$R := exhaleMask#_810[this#322, AVLTreeNode.left][perm$R] - fraction#_812];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_810);
    fraction#_813 := 100;
    assert {:msg "  633.4: The precondition at 644.12 might not hold. Insufficient fraction at 644.12 for AVLTreeNode.right."} (fraction#_813 <= exhaleMask#_810[this#322, AVLTreeNode.right][perm$R]) && ((fraction#_813 == exhaleMask#_810[this#322, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_810[this#322, AVLTreeNode.right][perm$N]));
    exhaleMask#_810[this#322, AVLTreeNode.right] := exhaleMask#_810[this#322, AVLTreeNode.right][perm$R := exhaleMask#_810[this#322, AVLTreeNode.right][perm$R] - fraction#_813];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_810);
    fraction#_814 := 100;
    assert {:msg "  633.4: The precondition at 646.12 might not hold. Insufficient fraction at 646.12 for AVLTreeNode.keys."} (fraction#_814 <= exhaleMask#_810[this#322, AVLTreeNode.keys][perm$R]) && ((fraction#_814 == exhaleMask#_810[this#322, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_810[this#322, AVLTreeNode.keys][perm$N]));
    exhaleMask#_810[this#322, AVLTreeNode.keys] := exhaleMask#_810[this#322, AVLTreeNode.keys][perm$R := exhaleMask#_810[this#322, AVLTreeNode.keys][perm$R] - fraction#_814];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_810);
    assert {:msg "  633.4: The precondition at 649.12 might not hold. The expression at 649.12 might not evaluate to true."} !(Heap[this#322, AVLTreeNode.left] == null);
    fraction#_815 := 100;
    assert {:msg "  633.4: The precondition at 650.12 might not hold. Insufficient fraction at 650.12 for AVLTreeNode.valid."} (fraction#_815 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_815 == exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_815];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_810);
    fraction#_816 := 50;
    assert {:msg "  633.4: The precondition at 652.12 might not hold. Insufficient fraction at 652.12 for AVLTreeNode.keys."} (fraction#_816 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_816 == exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_810[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_816];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_810);
    assert {:msg "  633.4: The precondition at 654.12 might not hold. The expression at 654.12 might not evaluate to true."} (forall k#83#324: int :: (0 <= k#83#324) && (k#83#324 < Seq#Length(Heap[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#322, AVLTreeNode.left], AVLTreeNode.keys], k#83#324) < Heap[this#322, AVLTreeNode.key]));
    if (!(Heap[this#322, AVLTreeNode.right] == null)) {
      fraction#_817 := 100;
      assert {:msg "  633.4: The precondition at 656.12 might not hold. Insufficient fraction at 656.28 for AVLTreeNode.valid."} (fraction#_817 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_817 == exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_817];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_810);
    } else {
    }
    if (!(Heap[this#322, AVLTreeNode.right] == null)) {
      fraction#_818 := 50;
      assert {:msg "  633.4: The precondition at 658.12 might not hold. Insufficient fraction at 658.28 for AVLTreeNode.keys."} (fraction#_818 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_818 == exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_810[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_818];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_810);
    } else {
    }
    if (!(Heap[this#322, AVLTreeNode.right] == null)) {
      assert {:msg "  633.4: The precondition at 660.12 might not hold. The expression at 660.28 might not evaluate to true."} (forall k#84#325: int :: (0 <= k#84#325) && (k#84#325 < Seq#Length(Heap[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#322, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#322, AVLTreeNode.right], AVLTreeNode.keys], k#84#325)));
    } else {
    }
    assert {:msg "  633.4: The precondition at 662.12 might not hold. The expression at 662.12 might not evaluate to true."} !(Heap[Heap[this#322, AVLTreeNode.left], AVLTreeNode.right] == null);
    Mask := exhaleMask#_810;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#323;
    // inhale (postcondition)
    havoc inhaleHeap#_821;
    assume IsGoodInhaleState(inhaleHeap#_821, Heap, Mask);
    assume r#323 != null;
    Heap[r#323, AVLTreeNode.valid] := inhaleHeap#_821[r#323, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_821[r#323, AVLTreeNode.valid] == Heap;
    Mask[r#323, AVLTreeNode.valid] := Mask[r#323, AVLTreeNode.valid][perm$R := Mask[r#323, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_821[r#323, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_821, Mask);
    assume r#323 != null;
    Heap[r#323, AVLTreeNode.keys] := inhaleHeap#_821[r#323, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#323, AVLTreeNode.keys] := Mask[r#323, AVLTreeNode.keys][perm$R := Mask[r#323, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_821[r#323, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_821, Mask);
    assume Seq#Equal(Heap[r#323, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_807[callHeap#_807[this#322, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_807[this#322, AVLTreeNode.key])), ite(callHeap#_807[this#322, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_807[callHeap#_807[this#322, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#51 := r#323;
  } else {
    // call rebalanceRR
    callHeap#_822 := Heap;
    callMask#_823 := Mask;
    callCredits#_824 := Credits;
    assert {:msg "  635.4: The target of the method call might be null."} this != null;
    this#326 := this;
    // begin exhale (precondition)
    exhaleMask#_825 := Mask;
    fraction#_826 := 100;
    assert {:msg "  635.4: The precondition at 698.12 might not hold. Insufficient fraction at 698.12 for AVLTreeNode.key."} (fraction#_826 <= exhaleMask#_825[this#326, AVLTreeNode.key][perm$R]) && ((fraction#_826 == exhaleMask#_825[this#326, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_825[this#326, AVLTreeNode.key][perm$N]));
    exhaleMask#_825[this#326, AVLTreeNode.key] := exhaleMask#_825[this#326, AVLTreeNode.key][perm$R := exhaleMask#_825[this#326, AVLTreeNode.key][perm$R] - fraction#_826];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_825);
    fraction#_827 := 100;
    assert {:msg "  635.4: The precondition at 700.12 might not hold. Insufficient fraction at 700.12 for AVLTreeNode.left."} (fraction#_827 <= exhaleMask#_825[this#326, AVLTreeNode.left][perm$R]) && ((fraction#_827 == exhaleMask#_825[this#326, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_825[this#326, AVLTreeNode.left][perm$N]));
    exhaleMask#_825[this#326, AVLTreeNode.left] := exhaleMask#_825[this#326, AVLTreeNode.left][perm$R := exhaleMask#_825[this#326, AVLTreeNode.left][perm$R] - fraction#_827];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_825);
    fraction#_828 := 100;
    assert {:msg "  635.4: The precondition at 701.12 might not hold. Insufficient fraction at 701.12 for AVLTreeNode.right."} (fraction#_828 <= exhaleMask#_825[this#326, AVLTreeNode.right][perm$R]) && ((fraction#_828 == exhaleMask#_825[this#326, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_825[this#326, AVLTreeNode.right][perm$N]));
    exhaleMask#_825[this#326, AVLTreeNode.right] := exhaleMask#_825[this#326, AVLTreeNode.right][perm$R := exhaleMask#_825[this#326, AVLTreeNode.right][perm$R] - fraction#_828];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_825);
    fraction#_829 := 100;
    assert {:msg "  635.4: The precondition at 703.12 might not hold. Insufficient fraction at 703.12 for AVLTreeNode.keys."} (fraction#_829 <= exhaleMask#_825[this#326, AVLTreeNode.keys][perm$R]) && ((fraction#_829 == exhaleMask#_825[this#326, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_825[this#326, AVLTreeNode.keys][perm$N]));
    exhaleMask#_825[this#326, AVLTreeNode.keys] := exhaleMask#_825[this#326, AVLTreeNode.keys][perm$R := exhaleMask#_825[this#326, AVLTreeNode.keys][perm$R] - fraction#_829];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_825);
    assert {:msg "  635.4: The precondition at 706.12 might not hold. The expression at 706.12 might not evaluate to true."} !(Heap[this#326, AVLTreeNode.left] == null);
    fraction#_830 := 100;
    assert {:msg "  635.4: The precondition at 707.12 might not hold. Insufficient fraction at 707.12 for AVLTreeNode.valid."} (fraction#_830 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_830 == exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_830];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_825);
    fraction#_831 := 50;
    assert {:msg "  635.4: The precondition at 709.12 might not hold. Insufficient fraction at 709.12 for AVLTreeNode.keys."} (fraction#_831 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_831 == exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_825[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_831];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_825);
    assert {:msg "  635.4: The precondition at 711.12 might not hold. The expression at 711.12 might not evaluate to true."} (forall k#89#328: int :: (0 <= k#89#328) && (k#89#328 < Seq#Length(Heap[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#326, AVLTreeNode.left], AVLTreeNode.keys], k#89#328) < Heap[this#326, AVLTreeNode.key]));
    if (!(Heap[this#326, AVLTreeNode.right] == null)) {
      fraction#_832 := 100;
      assert {:msg "  635.4: The precondition at 713.12 might not hold. Insufficient fraction at 713.28 for AVLTreeNode.valid."} (fraction#_832 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_832 == exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_832];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_825);
    } else {
    }
    if (!(Heap[this#326, AVLTreeNode.right] == null)) {
      fraction#_833 := 50;
      assert {:msg "  635.4: The precondition at 715.12 might not hold. Insufficient fraction at 715.28 for AVLTreeNode.keys."} (fraction#_833 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_833 == exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
      exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_825[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_833];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_825);
    } else {
    }
    if (!(Heap[this#326, AVLTreeNode.right] == null)) {
      assert {:msg "  635.4: The precondition at 717.12 might not hold. The expression at 717.28 might not evaluate to true."} (forall k#90#329: int :: (0 <= k#90#329) && (k#90#329 < Seq#Length(Heap[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#326, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#326, AVLTreeNode.right], AVLTreeNode.keys], k#90#329)));
    } else {
    }
    Mask := exhaleMask#_825;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#327;
    // inhale (postcondition)
    havoc inhaleHeap#_836;
    assume IsGoodInhaleState(inhaleHeap#_836, Heap, Mask);
    assume r#327 != null;
    Heap[r#327, AVLTreeNode.valid] := inhaleHeap#_836[r#327, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_836[r#327, AVLTreeNode.valid] == Heap;
    Mask[r#327, AVLTreeNode.valid] := Mask[r#327, AVLTreeNode.valid][perm$R := Mask[r#327, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_836[r#327, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_836, Mask);
    assume r#327 != null;
    Heap[r#327, AVLTreeNode.keys] := inhaleHeap#_836[r#327, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#327, AVLTreeNode.keys] := Mask[r#327, AVLTreeNode.keys][perm$R := Mask[r#327, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_836[r#327, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_836, Mask);
    assume Seq#Equal(Heap[r#327, AVLTreeNode.keys], Seq#Append(Seq#Append(callHeap#_822[callHeap#_822[this#326, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(callHeap#_822[this#326, AVLTreeNode.key])), ite(callHeap#_822[this#326, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_822[callHeap#_822[this#326, AVLTreeNode.right], AVLTreeNode.keys])));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#51 := r#327;
  }
  // begin exhale (postcondition)
  exhaleMask#_837 := Mask;
  fraction#_838 := 100;
  assert {:msg "  597.2: The postcondition at 621.11 might not hold. Insufficient fraction at 621.11 for AVLTreeNode.valid."} (fraction#_838 <= exhaleMask#_837[r#51, AVLTreeNode.valid][perm$R]) && ((fraction#_838 == exhaleMask#_837[r#51, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_837[r#51, AVLTreeNode.valid][perm$N]));
  exhaleMask#_837[r#51, AVLTreeNode.valid] := exhaleMask#_837[r#51, AVLTreeNode.valid][perm$R := exhaleMask#_837[r#51, AVLTreeNode.valid][perm$R] - fraction#_838];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_837);
  fraction#_839 := 50;
  assert {:msg "  597.2: The postcondition at 623.11 might not hold. Insufficient fraction at 623.11 for AVLTreeNode.keys."} (fraction#_839 <= exhaleMask#_837[r#51, AVLTreeNode.keys][perm$R]) && ((fraction#_839 == exhaleMask#_837[r#51, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_837[r#51, AVLTreeNode.keys][perm$N]));
  exhaleMask#_837[r#51, AVLTreeNode.keys] := exhaleMask#_837[r#51, AVLTreeNode.keys][perm$R := exhaleMask#_837[r#51, AVLTreeNode.keys][perm$R] - fraction#_839];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_837);
  assert {:msg "  597.2: The postcondition at 627.11 might not hold. The expression at 627.11 might not evaluate to true."} Seq#Equal(Heap[r#51, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  Mask := exhaleMask#_837;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  597.2: Method might lock/unlock more than allowed."} (forall lk#_840: ref :: {Heap[lk#_840, held]} {Heap[lk#_840, rdheld]} (((0 < Heap[lk#_840, held]) == (0 < old(Heap)[lk#_840, held])) && (Heap[lk#_840, rdheld] == old(Heap)[lk#_840, rdheld])) || false);
  assert {:msg "  597.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#54: ref where (r#54 == null) || (dtype(r#54) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_841: HeapType;
  var k#83#331: int where true;
  var k#84#333: int where true;
  var Heap#_845: HeapType;
  var Mask#_846: MaskType;
  var Credits#_847: CreditsType;
  var exhaleMask#_848: MaskType;
  var fraction#_849: int;
  var inhaleHeap#_850: HeapType;
  var inhaleHeap#_851: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_841;
  assume IsGoodInhaleState(inhaleHeap#_841, Heap, Mask);
  assert {:msg "  641.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  641.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_841[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_841[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_841, Mask);
  assert {:msg "  643.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  643.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_841[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_841[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_841, Mask);
  assert {:msg "  644.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  644.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_841[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_841[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_841, Mask);
  assert {:msg "  646.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  646.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_841[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_841[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_841, Mask);
  assert {:msg "  649.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  649.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  650.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  650.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_841[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_841[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_841[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_841, Mask);
  assert {:msg "  652.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  652.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  652.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  652.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_841[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_841[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_841, Mask);
  assert {:msg "  654.12: Receiver might be null."} true && (0 <= k#83#331) ==> (this != null);
  assert {:msg "  654.12: Location might not be readable."} true && (0 <= k#83#331) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  654.12: Receiver might be null."} true && (0 <= k#83#331) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  654.12: Location might not be readable."} true && (0 <= k#83#331) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  654.12: Receiver might be null."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  654.12: Location might not be readable."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  654.12: Receiver might be null."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  654.12: Location might not be readable."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  654.37: Sequence index might be negative."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#83#331);
  assert {:msg "  654.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  654.41: Receiver might be null."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  654.41: Location might not be readable."} true && (0 <= k#83#331) && (k#83#331 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall k#83#330: int :: (0 <= k#83#330) && (k#83#330 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#83#330) < Heap[this, AVLTreeNode.key]));
  assert {:msg "  656.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  656.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  656.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  656.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_841[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_841[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_841[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_841, Mask);
  } else {
  }
  assert {:msg "  658.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  658.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  658.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  658.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  658.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  658.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_841[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_841[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_841, Mask);
  } else {
  }
  assert {:msg "  660.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  660.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  660.12: Receiver might be null."} true && (0 <= k#84#333) ==> (this != null);
    assert {:msg "  660.12: Location might not be readable."} true && (0 <= k#84#333) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  660.12: Receiver might be null."} true && (0 <= k#84#333) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  660.12: Location might not be readable."} true && (0 <= k#84#333) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  660.54: Receiver might be null."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  660.54: Location might not be readable."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  660.12: Receiver might be null."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  660.12: Location might not be readable."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  660.12: Receiver might be null."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  660.12: Location might not be readable."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  660.60: Sequence index might be negative."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#84#333);
    assert {:msg "  660.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#84#333) && (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#84#333 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#84#332: int :: (0 <= k#84#332) && (k#84#332 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#84#332)));
  } else {
  }
  // unfolding
  assert {:msg "  662.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  662.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  Heap#_845 := Heap;
  Mask#_846 := Mask;
  Credits#_847 := Credits;
  // begin exhale (unfolding)
  exhaleMask#_848 := Mask#_846;
  fraction#_849 := 100;
  assert {:msg "  662.12: Unfolding might fail. Insufficient fraction at 662.22 for AVLTreeNode.valid."} (fraction#_849 <= exhaleMask#_848[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_849 == exhaleMask#_848[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_848[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  exhaleMask#_848[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_848[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_848[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_849];
  assume IsGoodMask(Mask#_846);
  assume wf(Heap#_845, Mask#_846);
  assume wf(Heap#_845, exhaleMask#_848);
  Mask#_846 := exhaleMask#_848;
  assume wf(Heap#_845, Mask#_846);
  // end exhale
  // inhale (unfolding)
  inhaleHeap#_850 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_850, Heap#_845, Mask#_846);
  assume Heap#_845[this, AVLTreeNode.left] != null;
  Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key];
  assume wf(Heap#_845, Mask#_846);
  assume true;
  Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key] := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask#_846);
  assume IsGoodState(inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume wf(Heap#_845, Mask#_846);
  assume wf(inhaleHeap#_850, Mask#_846);
  assume Heap#_845[this, AVLTreeNode.left] != null;
  Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left];
  assume wf(Heap#_845, Mask#_846);
  assume (Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask#_846);
  assume IsGoodState(inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left]);
  assume wf(Heap#_845, Mask#_846);
  assume wf(inhaleHeap#_850, Mask#_846);
  assume Heap#_845[this, AVLTreeNode.left] != null;
  Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right];
  assume wf(Heap#_845, Mask#_846);
  assume (Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask#_846);
  assume IsGoodState(inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right]);
  assume wf(Heap#_845, Mask#_846);
  assume wf(inhaleHeap#_850, Mask#_846);
  assume Heap#_845[this, AVLTreeNode.left] != null;
  Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap#_845, Mask#_846);
  assume true;
  Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_846[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask#_846);
  assume IsGoodState(inhaleHeap#_850[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap#_845, Mask#_846);
  assume wf(inhaleHeap#_850, Mask#_846);
  if (!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap#_845, Mask#_846);
    assume inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_845;
    Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_846);
    assume IsGoodState(inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap#_845, Mask#_846);
    assume wf(inhaleHeap#_850, Mask#_846);
  } else {
  }
  if (!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap#_845, Mask#_846);
    assume true;
    Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_846);
    assume IsGoodState(inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap#_845, Mask#_846);
    assume wf(inhaleHeap#_850, Mask#_846);
  } else {
  }
  if (!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#67#334: int :: (0 <= lk#67#334) && (lk#67#334 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#67#334) < Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key]));
  } else {
  }
  if (!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap#_845, Mask#_846);
    assume inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_845;
    Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_846);
    assume IsGoodState(inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap#_845, Mask#_846);
    assume wf(inhaleHeap#_850, Mask#_846);
  } else {
  }
  if (!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap#_845, Mask#_846);
    assume true;
    Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_846[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_846);
    assume IsGoodState(inhaleHeap#_850[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap#_845, Mask#_846);
    assume wf(inhaleHeap#_850, Mask#_846);
  } else {
  }
  if (!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#68#335: int :: (0 <= rk#68#335) && (rk#68#335 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#68#335)));
  } else {
  }
  assume Seq#Equal(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys], Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69) <==> ((((!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap#_845[Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap#_845[Heap#_845[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume IsGoodMask(Mask#_846);
  assume wf(Heap#_845, Mask#_846);
  // end inhale
  assert {:msg "  662.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.36: Location might not be readable."} true ==> CanRead(Mask#_846, this, AVLTreeNode.left);
  assert {:msg "  662.36: Receiver might be null."} true ==> (Heap#_845[this, AVLTreeNode.left] != null);
  assert {:msg "  662.36: Location might not be readable."} true ==> CanRead(Mask#_846, Heap#_845[this, AVLTreeNode.left], AVLTreeNode.right);
  assume !(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_851;
  assume IsGoodInhaleState(inhaleHeap#_851, Heap, Mask);
  assume r#54 != null;
  Heap[r#54, AVLTreeNode.valid] := inhaleHeap#_851[r#54, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_851[r#54, AVLTreeNode.valid] == Heap;
  Mask[r#54, AVLTreeNode.valid] := Mask[r#54, AVLTreeNode.valid][perm$R := Mask[r#54, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_851[r#54, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_851, Mask);
  assert {:msg "  669.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  669.31: Fraction might exceed 100."} 50 <= 100;
  assume r#54 != null;
  Heap[r#54, AVLTreeNode.keys] := inhaleHeap#_851[r#54, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#54, AVLTreeNode.keys] := Mask[r#54, AVLTreeNode.keys][perm$R := Mask[r#54, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_851[r#54, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_851, Mask);
  assert {:msg "  673.11: Receiver might be null."} true ==> (r#54 != null);
  assert {:msg "  673.11: Location might not be readable."} true ==> CanRead(Mask, r#54, AVLTreeNode.keys);
  assert {:msg "  673.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  673.25: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  673.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  673.25: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  673.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  673.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  673.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  673.59: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  673.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  673.89: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  673.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  673.89: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#54, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#54: ref where (r#54 == null) || (dtype(r#54) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_852: HeapType;
  var Heap#_856: HeapType;
  var Mask#_857: MaskType;
  var Credits#_858: CreditsType;
  var exhaleMask#_859: MaskType;
  var k#85#339: int where true;
  var exhaleMask#_860: MaskType;
  var fraction#_861: int;
  var inhaleHeap#_862: HeapType;
  var Heap#_866: HeapType;
  var Mask#_867: MaskType;
  var Credits#_868: CreditsType;
  var exhaleMask#_869: MaskType;
  var k#86#343: int where true;
  var exhaleMask#_870: MaskType;
  var fraction#_871: int;
  var inhaleHeap#_872: HeapType;
  var Heap#_876: HeapType;
  var Mask#_877: MaskType;
  var Credits#_878: CreditsType;
  var exhaleMask#_879: MaskType;
  var k#87#347: int where true;
  var this#348: ref where (this#348 == null) || (dtype(this#348) == AVLTreeNode#t);
  var callHeap#_880: HeapType;
  var callMask#_881: MaskType;
  var callCredits#_882: CreditsType;
  var exhaleMask#_883: MaskType;
  var fraction#_884: int;
  var fraction#_885: int;
  var fraction#_886: int;
  var fraction#_887: int;
  var fraction#_888: int;
  var fraction#_889: int;
  var fraction#_890: int;
  var fraction#_891: int;
  var isHeld#_892: int;
  var isRdHeld#_893: bool;
  var inhaleHeap#_894: HeapType;
  var Heap#_898: HeapType;
  var Mask#_899: MaskType;
  var Credits#_900: CreditsType;
  var exhaleMask#_901: MaskType;
  var k#88#352: int where true;
  var this#353: ref where (this#353 == null) || (dtype(this#353) == AVLTreeNode#t);
  var callHeap#_902: HeapType;
  var callMask#_903: MaskType;
  var callCredits#_904: CreditsType;
  var exhaleMask#_905: MaskType;
  var fraction#_906: int;
  var fraction#_907: int;
  var fraction#_908: int;
  var fraction#_909: int;
  var fraction#_910: int;
  var fraction#_911: int;
  var fraction#_912: int;
  var fraction#_913: int;
  var isHeld#_914: int;
  var isRdHeld#_915: bool;
  var inhaleHeap#_916: HeapType;
  var this#356: ref where (this#356 == null) || (dtype(this#356) == AVLTreeNode#t);
  var callHeap#_917: HeapType;
  var callMask#_918: MaskType;
  var callCredits#_919: CreditsType;
  var exhaleMask#_920: MaskType;
  var fraction#_921: int;
  var fraction#_922: int;
  var fraction#_923: int;
  var fraction#_924: int;
  var fraction#_925: int;
  var fraction#_926: int;
  var fraction#_927: int;
  var fraction#_928: int;
  var isHeld#_929: int;
  var isRdHeld#_930: bool;
  var inhaleHeap#_931: HeapType;
  var exhaleMask#_932: MaskType;
  var fraction#_933: int;
  var fraction#_934: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_852;
  assume IsGoodInhaleState(inhaleHeap#_852, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_852[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_852[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_852, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_852[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_852[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_852, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_852[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_852[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_852, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_852[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_852[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_852, Mask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_852[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_852[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_852[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_852, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_852[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_852[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_852, Mask);
  assume (forall k#83#336: int :: (0 <= k#83#336) && (k#83#336 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#83#336) < Heap[this, AVLTreeNode.key]));
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_852[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_852[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_852[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_852, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_852[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_852[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_852, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#84#337: int :: (0 <= k#84#337) && (k#84#337 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#84#337)));
  } else {
  }
  assume !(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_856 := Heap;
  Mask#_857 := Mask;
  Credits#_858 := Credits;
  // begin exhale (assert)
  exhaleMask#_859 := Mask#_857;
  assert {:msg "  675.10: Receiver might be null."} true && (0 <= k#85#339) ==> (this != null);
  assert {:msg "  675.10: Location might not be readable."} true && (0 <= k#85#339) ==> CanRead(Mask#_857, this, AVLTreeNode.left);
  assert {:msg "  675.10: Receiver might be null."} true && (0 <= k#85#339) ==> (Heap#_856[this, AVLTreeNode.left] != null);
  assert {:msg "  675.10: Location might not be readable."} true && (0 <= k#85#339) ==> CanRead(Mask#_857, Heap#_856[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  675.10: Receiver might be null."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  675.10: Location might not be readable."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_857, this, AVLTreeNode.left);
  assert {:msg "  675.10: Receiver might be null."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap#_856[this, AVLTreeNode.left] != null);
  assert {:msg "  675.10: Location might not be readable."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_857, Heap#_856[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  675.35: Sequence index might be negative."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#85#339);
  assert {:msg "  675.35: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#85#339 < Seq#Length(Heap#_856[Heap#_856[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  675.39: Receiver might be null."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  675.39: Location might not be readable."} true && (0 <= k#85#339) && (k#85#339 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_857, this, AVLTreeNode.key);
  assert {:msg "  675.3: Assertion might not hold. The expression at 675.10 might not evaluate to true."} (forall k#85#338: int :: (0 <= k#85#338) && (k#85#338 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_856[Heap#_856[this, AVLTreeNode.left], AVLTreeNode.keys], k#85#338) < Heap#_856[this, AVLTreeNode.key]));
  Mask#_857 := exhaleMask#_859;
  assume wf(Heap#_856, Mask#_857);
  // end exhale
  // unfold
  assert {:msg "  676.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  676.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  676.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  exhaleMask#_860 := Mask;
  fraction#_861 := 100;
  assert {:msg "  676.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_861 <= exhaleMask#_860[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_861 == exhaleMask#_860[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_860[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  exhaleMask#_860[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_860[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_860[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_861];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_860);
  Mask := exhaleMask#_860;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_862 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_862, Heap, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_862, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_862, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_862, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_862[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_862, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_862, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_862, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#67#340: int :: (0 <= lk#67#340) && (lk#67#340 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#67#340) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_862, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_862[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_862, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#68#341: int :: (0 <= rk#68#341) && (rk#68#341 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#68#341)));
  } else {
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  677.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  677.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  677.8: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  r#54 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  // assert
  Heap#_866 := Heap;
  Mask#_867 := Mask;
  Credits#_868 := Credits;
  // begin exhale (assert)
  exhaleMask#_869 := Mask#_867;
  assert {:msg "  678.10: Receiver might be null."} true && (0 <= k#86#343) ==> (r#54 != null);
  assert {:msg "  678.10: Location might not be readable."} true && (0 <= k#86#343) ==> CanRead(Mask#_867, r#54, AVLTreeNode.keys);
  assert {:msg "  678.10: Receiver might be null."} true && (0 <= k#86#343) && (k#86#343 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> (r#54 != null);
  assert {:msg "  678.10: Location might not be readable."} true && (0 <= k#86#343) && (k#86#343 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> CanRead(Mask#_867, r#54, AVLTreeNode.keys);
  assert {:msg "  678.32: Sequence index might be negative."} true && (0 <= k#86#343) && (k#86#343 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> (0 <= k#86#343);
  assert {:msg "  678.32: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#86#343) && (k#86#343 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> (k#86#343 < Seq#Length(Heap#_866[r#54, AVLTreeNode.keys]));
  assert {:msg "  678.36: Receiver might be null."} true && (0 <= k#86#343) && (k#86#343 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  678.36: Location might not be readable."} true && (0 <= k#86#343) && (k#86#343 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> CanRead(Mask#_867, this, AVLTreeNode.key);
  assert {:msg "  678.3: Assertion might not hold. The expression at 678.10 might not evaluate to true."} (forall k#86#342: int :: (0 <= k#86#342) && (k#86#342 < Seq#Length(Heap[r#54, AVLTreeNode.keys])) ==> (Seq#Index(Heap#_866[r#54, AVLTreeNode.keys], k#86#342) < Heap#_866[this, AVLTreeNode.key]));
  Mask#_867 := exhaleMask#_869;
  assume wf(Heap#_866, Mask#_867);
  // end exhale
  // unfold
  assert {:msg "  679.3: The target of the fold statement might be null."} r#54 != null;
  // begin exhale (unfold)
  exhaleMask#_870 := Mask;
  fraction#_871 := 100;
  assert {:msg "  679.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_871 <= exhaleMask#_870[r#54, AVLTreeNode.valid][perm$R]) && ((fraction#_871 == exhaleMask#_870[r#54, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_870[r#54, AVLTreeNode.valid][perm$N]));
  exhaleMask#_870[r#54, AVLTreeNode.valid] := exhaleMask#_870[r#54, AVLTreeNode.valid][perm$R := exhaleMask#_870[r#54, AVLTreeNode.valid][perm$R] - fraction#_871];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_870);
  Mask := exhaleMask#_870;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_872 := Heap[r#54, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_872, Heap, Mask);
  assume r#54 != null;
  Heap[r#54, AVLTreeNode.key] := inhaleHeap#_872[r#54, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#54, AVLTreeNode.key] := Mask[r#54, AVLTreeNode.key][perm$R := Mask[r#54, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[r#54, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  assume r#54 != null;
  Heap[r#54, AVLTreeNode.left] := inhaleHeap#_872[r#54, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[r#54, AVLTreeNode.left] == null) || (dtype(Heap[r#54, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[r#54, AVLTreeNode.left] := Mask[r#54, AVLTreeNode.left][perm$R := Mask[r#54, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[r#54, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  assume r#54 != null;
  Heap[r#54, AVLTreeNode.right] := inhaleHeap#_872[r#54, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[r#54, AVLTreeNode.right] == null) || (dtype(Heap[r#54, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[r#54, AVLTreeNode.right] := Mask[r#54, AVLTreeNode.right][perm$R := Mask[r#54, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[r#54, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  assume r#54 != null;
  Heap[r#54, AVLTreeNode.keys] := inhaleHeap#_872[r#54, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#54, AVLTreeNode.keys] := Mask[r#54, AVLTreeNode.keys][perm$R := Mask[r#54, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[r#54, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  if (!(Heap[r#54, AVLTreeNode.left] == null)) {
    assume Heap[r#54, AVLTreeNode.left] != null;
    Heap[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_872[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_872[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_872[Heap[r#54, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_872, Mask);
  } else {
  }
  if (!(Heap[r#54, AVLTreeNode.left] == null)) {
    assume Heap[r#54, AVLTreeNode.left] != null;
    Heap[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_872[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_872[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_872, Mask);
  } else {
  }
  if (!(Heap[r#54, AVLTreeNode.left] == null)) {
    assume (forall lk#67#344: int :: (0 <= lk#67#344) && (lk#67#344 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys], lk#67#344) < Heap[r#54, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[r#54, AVLTreeNode.right] == null)) {
    assume Heap[r#54, AVLTreeNode.right] != null;
    Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_872[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_872[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_872[Heap[r#54, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_872, Mask);
  } else {
  }
  if (!(Heap[r#54, AVLTreeNode.right] == null)) {
    assume Heap[r#54, AVLTreeNode.right] != null;
    Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_872[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_872[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_872, Mask);
  } else {
  }
  if (!(Heap[r#54, AVLTreeNode.right] == null)) {
    assume (forall rk#68#345: int :: (0 <= rk#68#345) && (rk#68#345 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#54, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys], rk#68#345)));
  } else {
  }
  assume Seq#Equal(Heap[r#54, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#54, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#54, AVLTreeNode.key])), ite(Heap[r#54, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[r#54, AVLTreeNode.keys], Heap[r#54, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[r#54, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[r#54, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#54, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[r#54, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[r#54, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assert
  Heap#_876 := Heap;
  Mask#_877 := Mask;
  Credits#_878 := Credits;
  // begin exhale (assert)
  exhaleMask#_879 := Mask#_877;
  assert {:msg "  681.10: Receiver might be null."} true ==> (r#54 != null);
  assert {:msg "  681.10: Location might not be readable."} true ==> CanRead(Mask#_877, r#54, AVLTreeNode.right);
  if (!(Heap#_876[r#54, AVLTreeNode.right] == null)) {
    assert {:msg "  681.10: Receiver might be null."} true && (0 <= k#87#347) ==> (r#54 != null);
    assert {:msg "  681.10: Location might not be readable."} true && (0 <= k#87#347) ==> CanRead(Mask#_877, r#54, AVLTreeNode.right);
    assert {:msg "  681.10: Receiver might be null."} true && (0 <= k#87#347) ==> (Heap#_876[r#54, AVLTreeNode.right] != null);
    assert {:msg "  681.10: Location might not be readable."} true && (0 <= k#87#347) ==> CanRead(Mask#_877, Heap#_876[r#54, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  681.10: Receiver might be null."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (r#54 != null);
    assert {:msg "  681.10: Location might not be readable."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_877, r#54, AVLTreeNode.right);
    assert {:msg "  681.10: Receiver might be null."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_876[r#54, AVLTreeNode.right] != null);
    assert {:msg "  681.10: Location might not be readable."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_877, Heap#_876[r#54, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  681.56: Sequence index might be negative."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#87#347);
    assert {:msg "  681.56: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#87#347 < Seq#Length(Heap#_876[Heap#_876[r#54, AVLTreeNode.right], AVLTreeNode.keys]));
    assert {:msg "  681.60: Receiver might be null."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  681.60: Location might not be readable."} true && (0 <= k#87#347) && (k#87#347 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_877, this, AVLTreeNode.key);
    assert {:msg "  681.3: Assertion might not hold. The expression at 681.28 might not evaluate to true."} (forall k#87#346: int :: (0 <= k#87#346) && (k#87#346 < Seq#Length(Heap[Heap[r#54, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_876[Heap#_876[r#54, AVLTreeNode.right], AVLTreeNode.keys], k#87#346) < Heap#_876[this, AVLTreeNode.key]));
  } else {
  }
  Mask#_877 := exhaleMask#_879;
  assume wf(Heap#_876, Mask#_877);
  // end exhale
  // update field right
  assert {:msg "  683.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  683.3: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  683.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  assert {:msg "  683.17: Receiver might be null."} true ==> (r#54 != null);
  assert {:msg "  683.17: Location might not be readable."} true ==> CanRead(Mask, r#54, AVLTreeNode.left);
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Heap[r#54, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // call close
  callHeap#_880 := Heap;
  callMask#_881 := Mask;
  callCredits#_882 := Credits;
  assert {:msg "  684.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  684.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  684.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#348 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_883 := Mask;
  fraction#_884 := 100;
  assert {:msg "  684.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_884 <= exhaleMask#_883[this#348, AVLTreeNode.key][perm$R]) && ((fraction#_884 == exhaleMask#_883[this#348, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_883[this#348, AVLTreeNode.key][perm$N]));
  exhaleMask#_883[this#348, AVLTreeNode.key] := exhaleMask#_883[this#348, AVLTreeNode.key][perm$R := exhaleMask#_883[this#348, AVLTreeNode.key][perm$R] - fraction#_884];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_883);
  fraction#_885 := 100;
  assert {:msg "  684.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_885 <= exhaleMask#_883[this#348, AVLTreeNode.left][perm$R]) && ((fraction#_885 == exhaleMask#_883[this#348, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_883[this#348, AVLTreeNode.left][perm$N]));
  exhaleMask#_883[this#348, AVLTreeNode.left] := exhaleMask#_883[this#348, AVLTreeNode.left][perm$R := exhaleMask#_883[this#348, AVLTreeNode.left][perm$R] - fraction#_885];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_883);
  fraction#_886 := 100;
  assert {:msg "  684.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_886 <= exhaleMask#_883[this#348, AVLTreeNode.right][perm$R]) && ((fraction#_886 == exhaleMask#_883[this#348, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_883[this#348, AVLTreeNode.right][perm$N]));
  exhaleMask#_883[this#348, AVLTreeNode.right] := exhaleMask#_883[this#348, AVLTreeNode.right][perm$R := exhaleMask#_883[this#348, AVLTreeNode.right][perm$R] - fraction#_886];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_883);
  fraction#_887 := 100;
  assert {:msg "  684.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_887 <= exhaleMask#_883[this#348, AVLTreeNode.keys][perm$R]) && ((fraction#_887 == exhaleMask#_883[this#348, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_883[this#348, AVLTreeNode.keys][perm$N]));
  exhaleMask#_883[this#348, AVLTreeNode.keys] := exhaleMask#_883[this#348, AVLTreeNode.keys][perm$R := exhaleMask#_883[this#348, AVLTreeNode.keys][perm$R] - fraction#_887];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_883);
  if (!(Heap[this#348, AVLTreeNode.left] == null)) {
    fraction#_888 := 100;
    assert {:msg "  684.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_888 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_888 == exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_888];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_883);
  } else {
  }
  if (!(Heap[this#348, AVLTreeNode.left] == null)) {
    fraction#_889 := 50;
    assert {:msg "  684.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_889 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_889 == exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_883[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_889];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_883);
  } else {
  }
  if (!(Heap[this#348, AVLTreeNode.left] == null)) {
    assert {:msg "  684.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#349: int :: (0 <= k#79#349) && (k#79#349 < Seq#Length(Heap[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#348, AVLTreeNode.left], AVLTreeNode.keys], k#79#349) < Heap[this#348, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#348, AVLTreeNode.right] == null)) {
    fraction#_890 := 100;
    assert {:msg "  684.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_890 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_890 == exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_890];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_883);
  } else {
  }
  if (!(Heap[this#348, AVLTreeNode.right] == null)) {
    fraction#_891 := 50;
    assert {:msg "  684.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_891 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_891 == exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_883[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_891];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_883);
  } else {
  }
  if (!(Heap[this#348, AVLTreeNode.right] == null)) {
    assert {:msg "  684.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#350: int :: (0 <= k#80#350) && (k#80#350 < Seq#Length(Heap[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#348, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#348, AVLTreeNode.right], AVLTreeNode.keys], k#80#350)));
  } else {
  }
  Mask := exhaleMask#_883;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_894;
  assume IsGoodInhaleState(inhaleHeap#_894, Heap, Mask);
  assume this#348 != null;
  Heap[this#348, AVLTreeNode.valid] := inhaleHeap#_894[this#348, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_894[this#348, AVLTreeNode.valid] == Heap;
  Mask[this#348, AVLTreeNode.valid] := Mask[this#348, AVLTreeNode.valid][perm$R := Mask[this#348, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_894[this#348, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_894, Mask);
  assume this#348 != null;
  Heap[this#348, AVLTreeNode.keys] := inhaleHeap#_894[this#348, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#348, AVLTreeNode.keys] := Mask[this#348, AVLTreeNode.keys][perm$R := Mask[this#348, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_894[this#348, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_894, Mask);
  assume Seq#Equal(Heap[this#348, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_880[this#348, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_880[callHeap#_880[this#348, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_880[this#348, AVLTreeNode.key])), ite(callHeap#_880[this#348, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_880[callHeap#_880[this#348, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  685.3: Location might not be writable"} CanWrite(Mask, r#54, AVLTreeNode.left);
  assert {:msg "  685.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  685.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  Heap[r#54, AVLTreeNode.left] := Heap[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // update field left
  assert {:msg "  686.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  686.17: Receiver might be null."} true ==> (r#54 != null);
  assert {:msg "  686.17: Location might not be readable."} true ==> CanRead(Mask, r#54, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#54, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // assert
  Heap#_898 := Heap;
  Mask#_899 := Mask;
  Credits#_900 := Credits;
  // begin exhale (assert)
  exhaleMask#_901 := Mask#_899;
  assert {:msg "  688.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  688.10: Location might not be readable."} true ==> CanRead(Mask#_899, this, AVLTreeNode.left);
  if (!(Heap#_898[this, AVLTreeNode.left] == null)) {
    assert {:msg "  688.10: Receiver might be null."} true && (0 <= k#88#352) ==> (this != null);
    assert {:msg "  688.10: Location might not be readable."} true && (0 <= k#88#352) ==> CanRead(Mask#_899, this, AVLTreeNode.left);
    assert {:msg "  688.10: Receiver might be null."} true && (0 <= k#88#352) ==> (Heap#_898[this, AVLTreeNode.left] != null);
    assert {:msg "  688.10: Location might not be readable."} true && (0 <= k#88#352) ==> CanRead(Mask#_899, Heap#_898[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  688.10: Receiver might be null."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  688.10: Location might not be readable."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_899, this, AVLTreeNode.left);
    assert {:msg "  688.10: Receiver might be null."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap#_898[this, AVLTreeNode.left] != null);
    assert {:msg "  688.10: Location might not be readable."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_899, Heap#_898[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  688.50: Sequence index might be negative."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#88#352);
    assert {:msg "  688.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#88#352 < Seq#Length(Heap#_898[Heap#_898[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  688.54: Receiver might be null."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  688.54: Location might not be readable."} true && (0 <= k#88#352) && (k#88#352 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_899, this, AVLTreeNode.key);
    assert {:msg "  688.3: Assertion might not hold. The expression at 688.25 might not evaluate to true."} (forall k#88#351: int :: (0 <= k#88#351) && (k#88#351 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_898[Heap#_898[this, AVLTreeNode.left], AVLTreeNode.keys], k#88#351) < Heap#_898[this, AVLTreeNode.key]));
  } else {
  }
  Mask#_899 := exhaleMask#_901;
  assume wf(Heap#_898, Mask#_899);
  // end exhale
  // call close
  callHeap#_902 := Heap;
  callMask#_903 := Mask;
  callCredits#_904 := Credits;
  assert {:msg "  689.3: The target of the method call might be null."} this != null;
  this#353 := this;
  // begin exhale (precondition)
  exhaleMask#_905 := Mask;
  fraction#_906 := 100;
  assert {:msg "  689.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_906 <= exhaleMask#_905[this#353, AVLTreeNode.key][perm$R]) && ((fraction#_906 == exhaleMask#_905[this#353, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_905[this#353, AVLTreeNode.key][perm$N]));
  exhaleMask#_905[this#353, AVLTreeNode.key] := exhaleMask#_905[this#353, AVLTreeNode.key][perm$R := exhaleMask#_905[this#353, AVLTreeNode.key][perm$R] - fraction#_906];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_905);
  fraction#_907 := 100;
  assert {:msg "  689.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_907 <= exhaleMask#_905[this#353, AVLTreeNode.left][perm$R]) && ((fraction#_907 == exhaleMask#_905[this#353, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_905[this#353, AVLTreeNode.left][perm$N]));
  exhaleMask#_905[this#353, AVLTreeNode.left] := exhaleMask#_905[this#353, AVLTreeNode.left][perm$R := exhaleMask#_905[this#353, AVLTreeNode.left][perm$R] - fraction#_907];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_905);
  fraction#_908 := 100;
  assert {:msg "  689.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_908 <= exhaleMask#_905[this#353, AVLTreeNode.right][perm$R]) && ((fraction#_908 == exhaleMask#_905[this#353, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_905[this#353, AVLTreeNode.right][perm$N]));
  exhaleMask#_905[this#353, AVLTreeNode.right] := exhaleMask#_905[this#353, AVLTreeNode.right][perm$R := exhaleMask#_905[this#353, AVLTreeNode.right][perm$R] - fraction#_908];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_905);
  fraction#_909 := 100;
  assert {:msg "  689.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_909 <= exhaleMask#_905[this#353, AVLTreeNode.keys][perm$R]) && ((fraction#_909 == exhaleMask#_905[this#353, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_905[this#353, AVLTreeNode.keys][perm$N]));
  exhaleMask#_905[this#353, AVLTreeNode.keys] := exhaleMask#_905[this#353, AVLTreeNode.keys][perm$R := exhaleMask#_905[this#353, AVLTreeNode.keys][perm$R] - fraction#_909];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_905);
  if (!(Heap[this#353, AVLTreeNode.left] == null)) {
    fraction#_910 := 100;
    assert {:msg "  689.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_910 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_910 == exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_910];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_905);
  } else {
  }
  if (!(Heap[this#353, AVLTreeNode.left] == null)) {
    fraction#_911 := 50;
    assert {:msg "  689.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_911 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_911 == exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_905[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_911];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_905);
  } else {
  }
  if (!(Heap[this#353, AVLTreeNode.left] == null)) {
    assert {:msg "  689.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#354: int :: (0 <= k#79#354) && (k#79#354 < Seq#Length(Heap[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#353, AVLTreeNode.left], AVLTreeNode.keys], k#79#354) < Heap[this#353, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#353, AVLTreeNode.right] == null)) {
    fraction#_912 := 100;
    assert {:msg "  689.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_912 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_912 == exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_912];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_905);
  } else {
  }
  if (!(Heap[this#353, AVLTreeNode.right] == null)) {
    fraction#_913 := 50;
    assert {:msg "  689.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_913 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_913 == exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_905[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_913];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_905);
  } else {
  }
  if (!(Heap[this#353, AVLTreeNode.right] == null)) {
    assert {:msg "  689.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#355: int :: (0 <= k#80#355) && (k#80#355 < Seq#Length(Heap[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#353, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#353, AVLTreeNode.right], AVLTreeNode.keys], k#80#355)));
  } else {
  }
  Mask := exhaleMask#_905;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_916;
  assume IsGoodInhaleState(inhaleHeap#_916, Heap, Mask);
  assume this#353 != null;
  Heap[this#353, AVLTreeNode.valid] := inhaleHeap#_916[this#353, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_916[this#353, AVLTreeNode.valid] == Heap;
  Mask[this#353, AVLTreeNode.valid] := Mask[this#353, AVLTreeNode.valid][perm$R := Mask[this#353, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_916[this#353, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_916, Mask);
  assume this#353 != null;
  Heap[this#353, AVLTreeNode.keys] := inhaleHeap#_916[this#353, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#353, AVLTreeNode.keys] := Mask[this#353, AVLTreeNode.keys][perm$R := Mask[this#353, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_916[this#353, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_916, Mask);
  assume Seq#Equal(Heap[this#353, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_902[this#353, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_902[callHeap#_902[this#353, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_902[this#353, AVLTreeNode.key])), ite(callHeap#_902[this#353, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_902[callHeap#_902[this#353, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  690.3: Location might not be writable"} CanWrite(Mask, r#54, AVLTreeNode.right);
  Heap[r#54, AVLTreeNode.right] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_917 := Heap;
  callMask#_918 := Mask;
  callCredits#_919 := Credits;
  assert {:msg "  691.3: The target of the method call might be null."} r#54 != null;
  this#356 := r#54;
  // begin exhale (precondition)
  exhaleMask#_920 := Mask;
  fraction#_921 := 100;
  assert {:msg "  691.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_921 <= exhaleMask#_920[this#356, AVLTreeNode.key][perm$R]) && ((fraction#_921 == exhaleMask#_920[this#356, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_920[this#356, AVLTreeNode.key][perm$N]));
  exhaleMask#_920[this#356, AVLTreeNode.key] := exhaleMask#_920[this#356, AVLTreeNode.key][perm$R := exhaleMask#_920[this#356, AVLTreeNode.key][perm$R] - fraction#_921];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_920);
  fraction#_922 := 100;
  assert {:msg "  691.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_922 <= exhaleMask#_920[this#356, AVLTreeNode.left][perm$R]) && ((fraction#_922 == exhaleMask#_920[this#356, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_920[this#356, AVLTreeNode.left][perm$N]));
  exhaleMask#_920[this#356, AVLTreeNode.left] := exhaleMask#_920[this#356, AVLTreeNode.left][perm$R := exhaleMask#_920[this#356, AVLTreeNode.left][perm$R] - fraction#_922];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_920);
  fraction#_923 := 100;
  assert {:msg "  691.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_923 <= exhaleMask#_920[this#356, AVLTreeNode.right][perm$R]) && ((fraction#_923 == exhaleMask#_920[this#356, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_920[this#356, AVLTreeNode.right][perm$N]));
  exhaleMask#_920[this#356, AVLTreeNode.right] := exhaleMask#_920[this#356, AVLTreeNode.right][perm$R := exhaleMask#_920[this#356, AVLTreeNode.right][perm$R] - fraction#_923];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_920);
  fraction#_924 := 100;
  assert {:msg "  691.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_924 <= exhaleMask#_920[this#356, AVLTreeNode.keys][perm$R]) && ((fraction#_924 == exhaleMask#_920[this#356, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_920[this#356, AVLTreeNode.keys][perm$N]));
  exhaleMask#_920[this#356, AVLTreeNode.keys] := exhaleMask#_920[this#356, AVLTreeNode.keys][perm$R := exhaleMask#_920[this#356, AVLTreeNode.keys][perm$R] - fraction#_924];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_920);
  if (!(Heap[this#356, AVLTreeNode.left] == null)) {
    fraction#_925 := 100;
    assert {:msg "  691.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_925 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_925 == exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_925];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_920);
  } else {
  }
  if (!(Heap[this#356, AVLTreeNode.left] == null)) {
    fraction#_926 := 50;
    assert {:msg "  691.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_926 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_926 == exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_920[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_926];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_920);
  } else {
  }
  if (!(Heap[this#356, AVLTreeNode.left] == null)) {
    assert {:msg "  691.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#357: int :: (0 <= k#79#357) && (k#79#357 < Seq#Length(Heap[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#356, AVLTreeNode.left], AVLTreeNode.keys], k#79#357) < Heap[this#356, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#356, AVLTreeNode.right] == null)) {
    fraction#_927 := 100;
    assert {:msg "  691.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_927 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_927 == exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_927];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_920);
  } else {
  }
  if (!(Heap[this#356, AVLTreeNode.right] == null)) {
    fraction#_928 := 50;
    assert {:msg "  691.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_928 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_928 == exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_920[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_928];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_920);
  } else {
  }
  if (!(Heap[this#356, AVLTreeNode.right] == null)) {
    assert {:msg "  691.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#358: int :: (0 <= k#80#358) && (k#80#358 < Seq#Length(Heap[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#356, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#356, AVLTreeNode.right], AVLTreeNode.keys], k#80#358)));
  } else {
  }
  Mask := exhaleMask#_920;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_931;
  assume IsGoodInhaleState(inhaleHeap#_931, Heap, Mask);
  assume this#356 != null;
  Heap[this#356, AVLTreeNode.valid] := inhaleHeap#_931[this#356, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_931[this#356, AVLTreeNode.valid] == Heap;
  Mask[this#356, AVLTreeNode.valid] := Mask[this#356, AVLTreeNode.valid][perm$R := Mask[this#356, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_931[this#356, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_931, Mask);
  assume this#356 != null;
  Heap[this#356, AVLTreeNode.keys] := inhaleHeap#_931[this#356, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#356, AVLTreeNode.keys] := Mask[this#356, AVLTreeNode.keys][perm$R := Mask[this#356, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_931[this#356, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_931, Mask);
  assume Seq#Equal(Heap[this#356, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_917[this#356, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_917[callHeap#_917[this#356, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_917[this#356, AVLTreeNode.key])), ite(callHeap#_917[this#356, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_917[callHeap#_917[this#356, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_932 := Mask;
  fraction#_933 := 100;
  assert {:msg "  640.2: The postcondition at 667.11 might not hold. Insufficient fraction at 667.11 for AVLTreeNode.valid."} (fraction#_933 <= exhaleMask#_932[r#54, AVLTreeNode.valid][perm$R]) && ((fraction#_933 == exhaleMask#_932[r#54, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_932[r#54, AVLTreeNode.valid][perm$N]));
  exhaleMask#_932[r#54, AVLTreeNode.valid] := exhaleMask#_932[r#54, AVLTreeNode.valid][perm$R := exhaleMask#_932[r#54, AVLTreeNode.valid][perm$R] - fraction#_933];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_932);
  fraction#_934 := 50;
  assert {:msg "  640.2: The postcondition at 669.11 might not hold. Insufficient fraction at 669.11 for AVLTreeNode.keys."} (fraction#_934 <= exhaleMask#_932[r#54, AVLTreeNode.keys][perm$R]) && ((fraction#_934 == exhaleMask#_932[r#54, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_932[r#54, AVLTreeNode.keys][perm$N]));
  exhaleMask#_932[r#54, AVLTreeNode.keys] := exhaleMask#_932[r#54, AVLTreeNode.keys][perm$R := exhaleMask#_932[r#54, AVLTreeNode.keys][perm$R] - fraction#_934];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_932);
  assert {:msg "  640.2: The postcondition at 673.11 might not hold. The expression at 673.11 might not evaluate to true."} Seq#Equal(Heap[r#54, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  Mask := exhaleMask#_932;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  640.2: Method might lock/unlock more than allowed."} (forall lk#_935: ref :: {Heap[lk#_935, held]} {Heap[lk#_935, rdheld]} (((0 < Heap[lk#_935, held]) == (0 < old(Heap)[lk#_935, held])) && (Heap[lk#_935, rdheld] == old(Heap)[lk#_935, rdheld])) || false);
  assert {:msg "  640.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#55: ref where (r#55 == null) || (dtype(r#55) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_936: HeapType;
  var k#89#360: int where true;
  var k#90#362: int where true;
  var inhaleHeap#_937: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_936;
  assume IsGoodInhaleState(inhaleHeap#_936, Heap, Mask);
  assert {:msg "  698.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  698.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_936[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  700.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  700.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_936[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  701.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  701.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_936[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  703.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  703.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_936[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  706.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  706.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  707.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  707.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_936[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_936[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  709.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  709.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  709.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  709.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_936[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  711.12: Receiver might be null."} true && (0 <= k#89#360) ==> (this != null);
  assert {:msg "  711.12: Location might not be readable."} true && (0 <= k#89#360) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  711.12: Receiver might be null."} true && (0 <= k#89#360) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  711.12: Location might not be readable."} true && (0 <= k#89#360) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  711.12: Receiver might be null."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  711.12: Location might not be readable."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  711.12: Receiver might be null."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  711.12: Location might not be readable."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  711.37: Sequence index might be negative."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#89#360);
  assert {:msg "  711.37: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
  assert {:msg "  711.41: Receiver might be null."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  711.41: Location might not be readable."} true && (0 <= k#89#360) && (k#89#360 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assume (forall k#89#359: int :: (0 <= k#89#359) && (k#89#359 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#89#359) < Heap[this, AVLTreeNode.key]));
  assert {:msg "  713.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  713.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  713.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  713.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_936[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_936[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_936[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_936, Mask);
  } else {
  }
  assert {:msg "  715.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  715.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  715.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  715.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  715.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  715.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_936[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_936[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_936, Mask);
  } else {
  }
  assert {:msg "  717.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  717.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  717.12: Receiver might be null."} true && (0 <= k#90#362) ==> (this != null);
    assert {:msg "  717.12: Location might not be readable."} true && (0 <= k#90#362) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  717.12: Receiver might be null."} true && (0 <= k#90#362) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  717.12: Location might not be readable."} true && (0 <= k#90#362) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  717.54: Receiver might be null."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  717.54: Location might not be readable."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assert {:msg "  717.12: Receiver might be null."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  717.12: Location might not be readable."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  717.12: Receiver might be null."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  717.12: Location might not be readable."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  717.60: Sequence index might be negative."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#90#362);
    assert {:msg "  717.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#90#362) && (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#90#362 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assume (forall k#90#361: int :: (0 <= k#90#361) && (k#90#361 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#90#361)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_937;
  assume IsGoodInhaleState(inhaleHeap#_937, Heap, Mask);
  assume r#55 != null;
  Heap[r#55, AVLTreeNode.valid] := inhaleHeap#_937[r#55, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_937[r#55, AVLTreeNode.valid] == Heap;
  Mask[r#55, AVLTreeNode.valid] := Mask[r#55, AVLTreeNode.valid][perm$R := Mask[r#55, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_937[r#55, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_937, Mask);
  assert {:msg "  725.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  725.31: Fraction might exceed 100."} 50 <= 100;
  assume r#55 != null;
  Heap[r#55, AVLTreeNode.keys] := inhaleHeap#_937[r#55, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#55, AVLTreeNode.keys] := Mask[r#55, AVLTreeNode.keys][perm$R := Mask[r#55, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_937[r#55, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_937, Mask);
  assert {:msg "  729.11: Receiver might be null."} true ==> (r#55 != null);
  assert {:msg "  729.11: Location might not be readable."} true ==> CanRead(Mask, r#55, AVLTreeNode.keys);
  assert {:msg "  729.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  729.25: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  729.25: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  729.25: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  assert {:msg "  729.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  729.44: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  729.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  729.59: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  729.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  729.89: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  729.89: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  729.89: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  }
  assume Seq#Equal(Heap[r#55, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#55: ref where (r#55 == null) || (dtype(r#55) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_938: HeapType;
  var exhaleMask#_939: MaskType;
  var fraction#_940: int;
  var inhaleHeap#_941: HeapType;
  var this#367: ref where (this#367 == null) || (dtype(this#367) == AVLTreeNode#t);
  var callHeap#_942: HeapType;
  var callMask#_943: MaskType;
  var callCredits#_944: CreditsType;
  var exhaleMask#_945: MaskType;
  var fraction#_946: int;
  var fraction#_947: int;
  var fraction#_948: int;
  var fraction#_949: int;
  var fraction#_950: int;
  var fraction#_951: int;
  var fraction#_952: int;
  var fraction#_953: int;
  var isHeld#_954: int;
  var isRdHeld#_955: bool;
  var inhaleHeap#_956: HeapType;
  var this#370: ref where (this#370 == null) || (dtype(this#370) == AVLTreeNode#t);
  var callHeap#_957: HeapType;
  var callMask#_958: MaskType;
  var callCredits#_959: CreditsType;
  var exhaleMask#_960: MaskType;
  var fraction#_961: int;
  var fraction#_962: int;
  var fraction#_963: int;
  var fraction#_964: int;
  var fraction#_965: int;
  var fraction#_966: int;
  var fraction#_967: int;
  var fraction#_968: int;
  var isHeld#_969: int;
  var isRdHeld#_970: bool;
  var inhaleHeap#_971: HeapType;
  var exhaleMask#_972: MaskType;
  var fraction#_973: int;
  var fraction#_974: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_938;
  assume IsGoodInhaleState(inhaleHeap#_938, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_938[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_938[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_938, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_938[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_938[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_938, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_938[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_938[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_938, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_938[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_938[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_938, Mask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_938[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_938[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_938[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_938, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_938[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_938[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_938, Mask);
  assume (forall k#89#363: int :: (0 <= k#89#363) && (k#89#363 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#89#363) < Heap[this, AVLTreeNode.key]));
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_938[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_938[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_938[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_938, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_938[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_938[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_938, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume (forall k#90#364: int :: (0 <= k#90#364) && (k#90#364 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#90#364)));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  731.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  731.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  731.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  exhaleMask#_939 := Mask;
  fraction#_940 := 100;
  assert {:msg "  731.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_940 <= exhaleMask#_939[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_940 == exhaleMask#_939[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_939[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  exhaleMask#_939[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_939[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_939[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_940];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_939);
  Mask := exhaleMask#_939;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_941 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_941, Heap, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_941, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_941, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_941, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_941[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_941, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_941, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_941, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume (forall lk#67#365: int :: (0 <= lk#67#365) && (lk#67#365 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], lk#67#365) < Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_941, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_941[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_941, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume (forall rk#68#366: int :: (0 <= rk#68#366) && (rk#68#366 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], rk#68#366)));
  } else {
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], kk#69) <==> ((((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  732.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  732.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  r#55 := Heap[this, AVLTreeNode.left];
  // update field left
  assert {:msg "  733.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  733.14: Receiver might be null."} true ==> (r#55 != null);
  assert {:msg "  733.14: Location might not be readable."} true ==> CanRead(Mask, r#55, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#55, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // call close
  callHeap#_942 := Heap;
  callMask#_943 := Mask;
  callCredits#_944 := Credits;
  assert {:msg "  734.3: The target of the method call might be null."} this != null;
  this#367 := this;
  // begin exhale (precondition)
  exhaleMask#_945 := Mask;
  fraction#_946 := 100;
  assert {:msg "  734.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_946 <= exhaleMask#_945[this#367, AVLTreeNode.key][perm$R]) && ((fraction#_946 == exhaleMask#_945[this#367, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_945[this#367, AVLTreeNode.key][perm$N]));
  exhaleMask#_945[this#367, AVLTreeNode.key] := exhaleMask#_945[this#367, AVLTreeNode.key][perm$R := exhaleMask#_945[this#367, AVLTreeNode.key][perm$R] - fraction#_946];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_945);
  fraction#_947 := 100;
  assert {:msg "  734.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_947 <= exhaleMask#_945[this#367, AVLTreeNode.left][perm$R]) && ((fraction#_947 == exhaleMask#_945[this#367, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_945[this#367, AVLTreeNode.left][perm$N]));
  exhaleMask#_945[this#367, AVLTreeNode.left] := exhaleMask#_945[this#367, AVLTreeNode.left][perm$R := exhaleMask#_945[this#367, AVLTreeNode.left][perm$R] - fraction#_947];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_945);
  fraction#_948 := 100;
  assert {:msg "  734.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_948 <= exhaleMask#_945[this#367, AVLTreeNode.right][perm$R]) && ((fraction#_948 == exhaleMask#_945[this#367, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_945[this#367, AVLTreeNode.right][perm$N]));
  exhaleMask#_945[this#367, AVLTreeNode.right] := exhaleMask#_945[this#367, AVLTreeNode.right][perm$R := exhaleMask#_945[this#367, AVLTreeNode.right][perm$R] - fraction#_948];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_945);
  fraction#_949 := 100;
  assert {:msg "  734.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_949 <= exhaleMask#_945[this#367, AVLTreeNode.keys][perm$R]) && ((fraction#_949 == exhaleMask#_945[this#367, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_945[this#367, AVLTreeNode.keys][perm$N]));
  exhaleMask#_945[this#367, AVLTreeNode.keys] := exhaleMask#_945[this#367, AVLTreeNode.keys][perm$R := exhaleMask#_945[this#367, AVLTreeNode.keys][perm$R] - fraction#_949];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_945);
  if (!(Heap[this#367, AVLTreeNode.left] == null)) {
    fraction#_950 := 100;
    assert {:msg "  734.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_950 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_950 == exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_950];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_945);
  } else {
  }
  if (!(Heap[this#367, AVLTreeNode.left] == null)) {
    fraction#_951 := 50;
    assert {:msg "  734.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_951 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_951 == exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_945[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_951];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_945);
  } else {
  }
  if (!(Heap[this#367, AVLTreeNode.left] == null)) {
    assert {:msg "  734.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#368: int :: (0 <= k#79#368) && (k#79#368 < Seq#Length(Heap[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#367, AVLTreeNode.left], AVLTreeNode.keys], k#79#368) < Heap[this#367, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#367, AVLTreeNode.right] == null)) {
    fraction#_952 := 100;
    assert {:msg "  734.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_952 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_952 == exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_952];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_945);
  } else {
  }
  if (!(Heap[this#367, AVLTreeNode.right] == null)) {
    fraction#_953 := 50;
    assert {:msg "  734.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_953 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_953 == exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_945[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_953];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_945);
  } else {
  }
  if (!(Heap[this#367, AVLTreeNode.right] == null)) {
    assert {:msg "  734.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#369: int :: (0 <= k#80#369) && (k#80#369 < Seq#Length(Heap[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#367, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#367, AVLTreeNode.right], AVLTreeNode.keys], k#80#369)));
  } else {
  }
  Mask := exhaleMask#_945;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_956;
  assume IsGoodInhaleState(inhaleHeap#_956, Heap, Mask);
  assume this#367 != null;
  Heap[this#367, AVLTreeNode.valid] := inhaleHeap#_956[this#367, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_956[this#367, AVLTreeNode.valid] == Heap;
  Mask[this#367, AVLTreeNode.valid] := Mask[this#367, AVLTreeNode.valid][perm$R := Mask[this#367, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_956[this#367, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_956, Mask);
  assume this#367 != null;
  Heap[this#367, AVLTreeNode.keys] := inhaleHeap#_956[this#367, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#367, AVLTreeNode.keys] := Mask[this#367, AVLTreeNode.keys][perm$R := Mask[this#367, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_956[this#367, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_956, Mask);
  assume Seq#Equal(Heap[this#367, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_942[this#367, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_942[callHeap#_942[this#367, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_942[this#367, AVLTreeNode.key])), ite(callHeap#_942[this#367, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_942[callHeap#_942[this#367, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  735.3: Location might not be writable"} CanWrite(Mask, r#55, AVLTreeNode.right);
  Heap[r#55, AVLTreeNode.right] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_957 := Heap;
  callMask#_958 := Mask;
  callCredits#_959 := Credits;
  assert {:msg "  736.3: The target of the method call might be null."} r#55 != null;
  this#370 := r#55;
  // begin exhale (precondition)
  exhaleMask#_960 := Mask;
  fraction#_961 := 100;
  assert {:msg "  736.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_961 <= exhaleMask#_960[this#370, AVLTreeNode.key][perm$R]) && ((fraction#_961 == exhaleMask#_960[this#370, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_960[this#370, AVLTreeNode.key][perm$N]));
  exhaleMask#_960[this#370, AVLTreeNode.key] := exhaleMask#_960[this#370, AVLTreeNode.key][perm$R := exhaleMask#_960[this#370, AVLTreeNode.key][perm$R] - fraction#_961];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_960);
  fraction#_962 := 100;
  assert {:msg "  736.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_962 <= exhaleMask#_960[this#370, AVLTreeNode.left][perm$R]) && ((fraction#_962 == exhaleMask#_960[this#370, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_960[this#370, AVLTreeNode.left][perm$N]));
  exhaleMask#_960[this#370, AVLTreeNode.left] := exhaleMask#_960[this#370, AVLTreeNode.left][perm$R := exhaleMask#_960[this#370, AVLTreeNode.left][perm$R] - fraction#_962];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_960);
  fraction#_963 := 100;
  assert {:msg "  736.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_963 <= exhaleMask#_960[this#370, AVLTreeNode.right][perm$R]) && ((fraction#_963 == exhaleMask#_960[this#370, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_960[this#370, AVLTreeNode.right][perm$N]));
  exhaleMask#_960[this#370, AVLTreeNode.right] := exhaleMask#_960[this#370, AVLTreeNode.right][perm$R := exhaleMask#_960[this#370, AVLTreeNode.right][perm$R] - fraction#_963];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_960);
  fraction#_964 := 100;
  assert {:msg "  736.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_964 <= exhaleMask#_960[this#370, AVLTreeNode.keys][perm$R]) && ((fraction#_964 == exhaleMask#_960[this#370, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_960[this#370, AVLTreeNode.keys][perm$N]));
  exhaleMask#_960[this#370, AVLTreeNode.keys] := exhaleMask#_960[this#370, AVLTreeNode.keys][perm$R := exhaleMask#_960[this#370, AVLTreeNode.keys][perm$R] - fraction#_964];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_960);
  if (!(Heap[this#370, AVLTreeNode.left] == null)) {
    fraction#_965 := 100;
    assert {:msg "  736.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_965 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_965 == exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_965];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_960);
  } else {
  }
  if (!(Heap[this#370, AVLTreeNode.left] == null)) {
    fraction#_966 := 50;
    assert {:msg "  736.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_966 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_966 == exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_960[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_966];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_960);
  } else {
  }
  if (!(Heap[this#370, AVLTreeNode.left] == null)) {
    assert {:msg "  736.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#371: int :: (0 <= k#79#371) && (k#79#371 < Seq#Length(Heap[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#370, AVLTreeNode.left], AVLTreeNode.keys], k#79#371) < Heap[this#370, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#370, AVLTreeNode.right] == null)) {
    fraction#_967 := 100;
    assert {:msg "  736.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_967 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_967 == exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_967];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_960);
  } else {
  }
  if (!(Heap[this#370, AVLTreeNode.right] == null)) {
    fraction#_968 := 50;
    assert {:msg "  736.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_968 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_968 == exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_960[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_968];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_960);
  } else {
  }
  if (!(Heap[this#370, AVLTreeNode.right] == null)) {
    assert {:msg "  736.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#372: int :: (0 <= k#80#372) && (k#80#372 < Seq#Length(Heap[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#370, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#370, AVLTreeNode.right], AVLTreeNode.keys], k#80#372)));
  } else {
  }
  Mask := exhaleMask#_960;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_971;
  assume IsGoodInhaleState(inhaleHeap#_971, Heap, Mask);
  assume this#370 != null;
  Heap[this#370, AVLTreeNode.valid] := inhaleHeap#_971[this#370, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_971[this#370, AVLTreeNode.valid] == Heap;
  Mask[this#370, AVLTreeNode.valid] := Mask[this#370, AVLTreeNode.valid][perm$R := Mask[this#370, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_971[this#370, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_971, Mask);
  assume this#370 != null;
  Heap[this#370, AVLTreeNode.keys] := inhaleHeap#_971[this#370, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#370, AVLTreeNode.keys] := Mask[this#370, AVLTreeNode.keys][perm$R := Mask[this#370, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_971[this#370, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_971, Mask);
  assume Seq#Equal(Heap[this#370, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_957[this#370, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_957[callHeap#_957[this#370, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_957[this#370, AVLTreeNode.key])), ite(callHeap#_957[this#370, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_957[callHeap#_957[this#370, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_972 := Mask;
  fraction#_973 := 100;
  assert {:msg "  697.2: The postcondition at 723.11 might not hold. Insufficient fraction at 723.11 for AVLTreeNode.valid."} (fraction#_973 <= exhaleMask#_972[r#55, AVLTreeNode.valid][perm$R]) && ((fraction#_973 == exhaleMask#_972[r#55, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_972[r#55, AVLTreeNode.valid][perm$N]));
  exhaleMask#_972[r#55, AVLTreeNode.valid] := exhaleMask#_972[r#55, AVLTreeNode.valid][perm$R := exhaleMask#_972[r#55, AVLTreeNode.valid][perm$R] - fraction#_973];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_972);
  fraction#_974 := 50;
  assert {:msg "  697.2: The postcondition at 725.11 might not hold. Insufficient fraction at 725.11 for AVLTreeNode.keys."} (fraction#_974 <= exhaleMask#_972[r#55, AVLTreeNode.keys][perm$R]) && ((fraction#_974 == exhaleMask#_972[r#55, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_972[r#55, AVLTreeNode.keys][perm$N]));
  exhaleMask#_972[r#55, AVLTreeNode.keys] := exhaleMask#_972[r#55, AVLTreeNode.keys][perm$R := exhaleMask#_972[r#55, AVLTreeNode.keys][perm$R] - fraction#_974];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_972);
  assert {:msg "  697.2: The postcondition at 729.11 might not hold. The expression at 729.11 might not evaluate to true."} Seq#Equal(Heap[r#55, AVLTreeNode.keys], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys], Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), ite(old(Heap)[this, AVLTreeNode.right] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys])));
  Mask := exhaleMask#_972;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  697.2: Method might lock/unlock more than allowed."} (forall lk#_975: ref :: {Heap[lk#_975, held]} {Heap[lk#_975, rdheld]} (((0 < Heap[lk#_975, held]) == (0 < old(Heap)[lk#_975, held])) && (Heap[lk#_975, rdheld] == old(Heap)[lk#_975, rdheld])) || false);
  assert {:msg "  697.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRight$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#56: ref where (r#56 == null) || (dtype(r#56) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_976: HeapType;
  var k#91#374: int where true;
  var k#92#376: int where true;
  var inhaleHeap#_977: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_976;
  assume IsGoodInhaleState(inhaleHeap#_976, Heap, Mask);
  assert {:msg "  741.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  741.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_976[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_976[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_976, Mask);
  assert {:msg "  743.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  743.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_976[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_976[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_976, Mask);
  assert {:msg "  744.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  744.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_976[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_976[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_976, Mask);
  assert {:msg "  746.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  746.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_976[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_976[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_976, Mask);
  assert {:msg "  749.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  749.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  749.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  749.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_976[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_976[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_976[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_976, Mask);
  } else {
  }
  assert {:msg "  751.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  751.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  751.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  751.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  751.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  751.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_976[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_976[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_976, Mask);
  } else {
  }
  assert {:msg "  753.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  753.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  753.12: Receiver might be null."} true && (0 <= k#91#374) ==> (this != null);
    assert {:msg "  753.12: Location might not be readable."} true && (0 <= k#91#374) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  753.12: Receiver might be null."} true && (0 <= k#91#374) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  753.12: Location might not be readable."} true && (0 <= k#91#374) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  753.12: Receiver might be null."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  753.12: Location might not be readable."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  753.12: Receiver might be null."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  753.12: Location might not be readable."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  753.50: Sequence index might be negative."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#91#374);
    assert {:msg "  753.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  753.54: Receiver might be null."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  753.54: Location might not be readable."} true && (0 <= k#91#374) && (k#91#374 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#91#373: int :: (0 <= k#91#373) && (k#91#373 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#91#373) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assert {:msg "  755.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  755.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  756.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  756.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_976[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_976[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_976[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_976, Mask);
  assert {:msg "  758.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  758.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  758.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  758.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_976[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_976[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_976, Mask);
  assert {:msg "  760.12: Receiver might be null."} true && (0 <= k#92#376) ==> (this != null);
  assert {:msg "  760.12: Location might not be readable."} true && (0 <= k#92#376) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  760.12: Receiver might be null."} true && (0 <= k#92#376) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  760.12: Location might not be readable."} true && (0 <= k#92#376) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  760.38: Receiver might be null."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  760.38: Location might not be readable."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  760.12: Receiver might be null."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  760.12: Location might not be readable."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  760.12: Receiver might be null."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  760.12: Location might not be readable."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  760.44: Sequence index might be negative."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#92#376);
  assert {:msg "  760.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#92#376) && (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#92#376 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#92#375: int :: (0 <= k#92#375) && (k#92#375 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#92#375)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_977;
  assume IsGoodInhaleState(inhaleHeap#_977, Heap, Mask);
  assume r#56 != null;
  Heap[r#56, AVLTreeNode.valid] := inhaleHeap#_977[r#56, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_977[r#56, AVLTreeNode.valid] == Heap;
  Mask[r#56, AVLTreeNode.valid] := Mask[r#56, AVLTreeNode.valid][perm$R := Mask[r#56, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_977[r#56, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_977, Mask);
  assert {:msg "  767.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  767.31: Fraction might exceed 100."} 50 <= 100;
  assume r#56 != null;
  Heap[r#56, AVLTreeNode.keys] := inhaleHeap#_977[r#56, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#56, AVLTreeNode.keys] := Mask[r#56, AVLTreeNode.keys][perm$R := Mask[r#56, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_977[r#56, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_977, Mask);
  assert {:msg "  771.11: Receiver might be null."} true ==> (r#56 != null);
  assert {:msg "  771.11: Location might not be readable."} true ==> CanRead(Mask, r#56, AVLTreeNode.keys);
  assert {:msg "  771.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  771.26: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  771.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  771.51: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  771.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  771.51: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  771.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  771.71: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  771.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  771.84: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  771.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  771.84: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#56, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRight(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#56: ref where (r#56 == null) || (dtype(r#56) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_978: HeapType;
  var rbf#58: int where true;
  var this#379: ref where (this#379 == null) || (dtype(this#379) == AVLTreeNode#t);
  var bf#380: int where true;
  var callHeap#_979: HeapType;
  var callMask#_980: MaskType;
  var callCredits#_981: CreditsType;
  var exhaleMask#_982: MaskType;
  var fraction#_983: int;
  var isHeld#_984: int;
  var isRdHeld#_985: bool;
  var inhaleHeap#_986: HeapType;
  var this#381: ref where (this#381 == null) || (dtype(this#381) == AVLTreeNode#t);
  var r#382: ref where (r#382 == null) || (dtype(r#382) == AVLTreeNode#t);
  var callHeap#_987: HeapType;
  var callMask#_988: MaskType;
  var callCredits#_989: CreditsType;
  var exhaleMask#_990: MaskType;
  var fraction#_991: int;
  var fraction#_992: int;
  var fraction#_993: int;
  var fraction#_994: int;
  var fraction#_995: int;
  var fraction#_996: int;
  var fraction#_997: int;
  var fraction#_998: int;
  var isHeld#_999: int;
  var isRdHeld#_1000: bool;
  var inhaleHeap#_1001: HeapType;
  var this#385: ref where (this#385 == null) || (dtype(this#385) == AVLTreeNode#t);
  var r#386: ref where (r#386 == null) || (dtype(r#386) == AVLTreeNode#t);
  var callHeap#_1002: HeapType;
  var callMask#_1003: MaskType;
  var callCredits#_1004: CreditsType;
  var exhaleMask#_1005: MaskType;
  var fraction#_1006: int;
  var fraction#_1007: int;
  var fraction#_1008: int;
  var fraction#_1009: int;
  var fraction#_1010: int;
  var fraction#_1011: int;
  var fraction#_1012: int;
  var fraction#_1013: int;
  var isHeld#_1014: int;
  var isRdHeld#_1015: bool;
  var inhaleHeap#_1016: HeapType;
  var exhaleMask#_1017: MaskType;
  var fraction#_1018: int;
  var fraction#_1019: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_978;
  assume IsGoodInhaleState(inhaleHeap#_978, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_978[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_978[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_978, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_978[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_978[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_978, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_978[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_978[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_978, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_978[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_978[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_978, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_978[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_978[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_978[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_978, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_978[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_978[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_978, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#91#377: int :: (0 <= k#91#377) && (k#91#377 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#91#377) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_978[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_978[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_978[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_978, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_978[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_978[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_978, Mask);
  assume (forall k#92#378: int :: (0 <= k#92#378) && (k#92#378 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#92#378)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var rbf
  // call getBalanceFactor
  callHeap#_979 := Heap;
  callMask#_980 := Mask;
  callCredits#_981 := Credits;
  assert {:msg "  774.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  774.15: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  774.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#379 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_982 := Mask;
  fraction#_983 := 100;
  assert {:msg "  774.3: The precondition at 486.12 might not hold. Insufficient fraction at 486.12 for AVLTreeNode.valid."} (fraction#_983 <= exhaleMask#_982[this#379, AVLTreeNode.valid][perm$R]) && ((fraction#_983 == exhaleMask#_982[this#379, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_982[this#379, AVLTreeNode.valid][perm$N]));
  exhaleMask#_982[this#379, AVLTreeNode.valid] := exhaleMask#_982[this#379, AVLTreeNode.valid][perm$R := exhaleMask#_982[this#379, AVLTreeNode.valid][perm$R] - fraction#_983];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_982);
  Mask := exhaleMask#_982;
  assume wf(Heap, Mask);
  // end exhale
  havoc bf#380;
  // inhale (postcondition)
  havoc inhaleHeap#_986;
  assume IsGoodInhaleState(inhaleHeap#_986, Heap, Mask);
  assume this#379 != null;
  Heap[this#379, AVLTreeNode.valid] := inhaleHeap#_986[this#379, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_986[this#379, AVLTreeNode.valid] == Heap;
  Mask[this#379, AVLTreeNode.valid] := Mask[this#379, AVLTreeNode.valid][perm$R := Mask[this#379, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_986[this#379, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_986, Mask);
  assume (bf#380 > 0) ==> (!(Heap[this#379, AVLTreeNode.left] == null));
  assume (bf#380 < 0) ==> (!(Heap[this#379, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  rbf#58 := bf#380;
  // if
  if (rbf#58 > 0) {
    // call rebalanceLR
    callHeap#_987 := Heap;
    callMask#_988 := Mask;
    callCredits#_989 := Credits;
    assert {:msg "  777.4: The target of the method call might be null."} this != null;
    this#381 := this;
    // begin exhale (precondition)
    exhaleMask#_990 := Mask;
    fraction#_991 := 100;
    assert {:msg "  777.4: The precondition at 785.12 might not hold. Insufficient fraction at 785.12 for AVLTreeNode.key."} (fraction#_991 <= exhaleMask#_990[this#381, AVLTreeNode.key][perm$R]) && ((fraction#_991 == exhaleMask#_990[this#381, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_990[this#381, AVLTreeNode.key][perm$N]));
    exhaleMask#_990[this#381, AVLTreeNode.key] := exhaleMask#_990[this#381, AVLTreeNode.key][perm$R := exhaleMask#_990[this#381, AVLTreeNode.key][perm$R] - fraction#_991];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_990);
    fraction#_992 := 100;
    assert {:msg "  777.4: The precondition at 787.12 might not hold. Insufficient fraction at 787.12 for AVLTreeNode.left."} (fraction#_992 <= exhaleMask#_990[this#381, AVLTreeNode.left][perm$R]) && ((fraction#_992 == exhaleMask#_990[this#381, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_990[this#381, AVLTreeNode.left][perm$N]));
    exhaleMask#_990[this#381, AVLTreeNode.left] := exhaleMask#_990[this#381, AVLTreeNode.left][perm$R := exhaleMask#_990[this#381, AVLTreeNode.left][perm$R] - fraction#_992];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_990);
    fraction#_993 := 100;
    assert {:msg "  777.4: The precondition at 788.12 might not hold. Insufficient fraction at 788.12 for AVLTreeNode.right."} (fraction#_993 <= exhaleMask#_990[this#381, AVLTreeNode.right][perm$R]) && ((fraction#_993 == exhaleMask#_990[this#381, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_990[this#381, AVLTreeNode.right][perm$N]));
    exhaleMask#_990[this#381, AVLTreeNode.right] := exhaleMask#_990[this#381, AVLTreeNode.right][perm$R := exhaleMask#_990[this#381, AVLTreeNode.right][perm$R] - fraction#_993];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_990);
    fraction#_994 := 100;
    assert {:msg "  777.4: The precondition at 790.12 might not hold. Insufficient fraction at 790.12 for AVLTreeNode.keys."} (fraction#_994 <= exhaleMask#_990[this#381, AVLTreeNode.keys][perm$R]) && ((fraction#_994 == exhaleMask#_990[this#381, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_990[this#381, AVLTreeNode.keys][perm$N]));
    exhaleMask#_990[this#381, AVLTreeNode.keys] := exhaleMask#_990[this#381, AVLTreeNode.keys][perm$R := exhaleMask#_990[this#381, AVLTreeNode.keys][perm$R] - fraction#_994];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_990);
    if (!(Heap[this#381, AVLTreeNode.left] == null)) {
      fraction#_995 := 100;
      assert {:msg "  777.4: The precondition at 793.12 might not hold. Insufficient fraction at 793.25 for AVLTreeNode.valid."} (fraction#_995 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_995 == exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_995];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_990);
    } else {
    }
    if (!(Heap[this#381, AVLTreeNode.left] == null)) {
      fraction#_996 := 50;
      assert {:msg "  777.4: The precondition at 795.12 might not hold. Insufficient fraction at 795.25 for AVLTreeNode.keys."} (fraction#_996 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_996 == exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_990[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_996];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_990);
    } else {
    }
    if (!(Heap[this#381, AVLTreeNode.left] == null)) {
      assert {:msg "  777.4: The precondition at 797.12 might not hold. The expression at 797.25 might not evaluate to true."} (forall k#93#383: int :: (0 <= k#93#383) && (k#93#383 < Seq#Length(Heap[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#381, AVLTreeNode.left], AVLTreeNode.keys], k#93#383) < Heap[this#381, AVLTreeNode.key]));
    } else {
    }
    assert {:msg "  777.4: The precondition at 799.12 might not hold. The expression at 799.12 might not evaluate to true."} !(Heap[this#381, AVLTreeNode.right] == null);
    fraction#_997 := 100;
    assert {:msg "  777.4: The precondition at 800.12 might not hold. Insufficient fraction at 800.12 for AVLTreeNode.valid."} (fraction#_997 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_997 == exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_997];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_990);
    fraction#_998 := 50;
    assert {:msg "  777.4: The precondition at 802.12 might not hold. Insufficient fraction at 802.12 for AVLTreeNode.keys."} (fraction#_998 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_998 == exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_990[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_998];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_990);
    assert {:msg "  777.4: The precondition at 804.12 might not hold. The expression at 804.12 might not evaluate to true."} (forall k#94#384: int :: (0 <= k#94#384) && (k#94#384 < Seq#Length(Heap[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#381, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#381, AVLTreeNode.right], AVLTreeNode.keys], k#94#384)));
    assert {:msg "  777.4: The precondition at 806.12 might not hold. The expression at 806.12 might not evaluate to true."} !(Heap[Heap[this#381, AVLTreeNode.right], AVLTreeNode.left] == null);
    Mask := exhaleMask#_990;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#382;
    // inhale (postcondition)
    havoc inhaleHeap#_1001;
    assume IsGoodInhaleState(inhaleHeap#_1001, Heap, Mask);
    assume r#382 != null;
    Heap[r#382, AVLTreeNode.valid] := inhaleHeap#_1001[r#382, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1001[r#382, AVLTreeNode.valid] == Heap;
    Mask[r#382, AVLTreeNode.valid] := Mask[r#382, AVLTreeNode.valid][perm$R := Mask[r#382, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[r#382, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
    assume r#382 != null;
    Heap[r#382, AVLTreeNode.keys] := inhaleHeap#_1001[r#382, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#382, AVLTreeNode.keys] := Mask[r#382, AVLTreeNode.keys][perm$R := Mask[r#382, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[r#382, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
    assume Seq#Equal(Heap[r#382, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_987[this#381, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_987[callHeap#_987[this#381, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_987[this#381, AVLTreeNode.key])), callHeap#_987[callHeap#_987[this#381, AVLTreeNode.right], AVLTreeNode.keys]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#56 := r#382;
  } else {
    // call rebalanceLL
    callHeap#_1002 := Heap;
    callMask#_1003 := Mask;
    callCredits#_1004 := Credits;
    assert {:msg "  779.4: The target of the method call might be null."} this != null;
    this#385 := this;
    // begin exhale (precondition)
    exhaleMask#_1005 := Mask;
    fraction#_1006 := 100;
    assert {:msg "  779.4: The precondition at 839.12 might not hold. Insufficient fraction at 839.12 for AVLTreeNode.key."} (fraction#_1006 <= exhaleMask#_1005[this#385, AVLTreeNode.key][perm$R]) && ((fraction#_1006 == exhaleMask#_1005[this#385, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1005[this#385, AVLTreeNode.key][perm$N]));
    exhaleMask#_1005[this#385, AVLTreeNode.key] := exhaleMask#_1005[this#385, AVLTreeNode.key][perm$R := exhaleMask#_1005[this#385, AVLTreeNode.key][perm$R] - fraction#_1006];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
    fraction#_1007 := 100;
    assert {:msg "  779.4: The precondition at 841.12 might not hold. Insufficient fraction at 841.12 for AVLTreeNode.left."} (fraction#_1007 <= exhaleMask#_1005[this#385, AVLTreeNode.left][perm$R]) && ((fraction#_1007 == exhaleMask#_1005[this#385, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1005[this#385, AVLTreeNode.left][perm$N]));
    exhaleMask#_1005[this#385, AVLTreeNode.left] := exhaleMask#_1005[this#385, AVLTreeNode.left][perm$R := exhaleMask#_1005[this#385, AVLTreeNode.left][perm$R] - fraction#_1007];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
    fraction#_1008 := 100;
    assert {:msg "  779.4: The precondition at 842.12 might not hold. Insufficient fraction at 842.12 for AVLTreeNode.right."} (fraction#_1008 <= exhaleMask#_1005[this#385, AVLTreeNode.right][perm$R]) && ((fraction#_1008 == exhaleMask#_1005[this#385, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1005[this#385, AVLTreeNode.right][perm$N]));
    exhaleMask#_1005[this#385, AVLTreeNode.right] := exhaleMask#_1005[this#385, AVLTreeNode.right][perm$R := exhaleMask#_1005[this#385, AVLTreeNode.right][perm$R] - fraction#_1008];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
    fraction#_1009 := 100;
    assert {:msg "  779.4: The precondition at 844.12 might not hold. Insufficient fraction at 844.12 for AVLTreeNode.keys."} (fraction#_1009 <= exhaleMask#_1005[this#385, AVLTreeNode.keys][perm$R]) && ((fraction#_1009 == exhaleMask#_1005[this#385, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1005[this#385, AVLTreeNode.keys][perm$N]));
    exhaleMask#_1005[this#385, AVLTreeNode.keys] := exhaleMask#_1005[this#385, AVLTreeNode.keys][perm$R := exhaleMask#_1005[this#385, AVLTreeNode.keys][perm$R] - fraction#_1009];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
    if (!(Heap[this#385, AVLTreeNode.left] == null)) {
      fraction#_1010 := 100;
      assert {:msg "  779.4: The precondition at 847.12 might not hold. Insufficient fraction at 847.25 for AVLTreeNode.valid."} (fraction#_1010 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1010 == exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1010];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1005);
    } else {
    }
    if (!(Heap[this#385, AVLTreeNode.left] == null)) {
      fraction#_1011 := 50;
      assert {:msg "  779.4: The precondition at 849.12 might not hold. Insufficient fraction at 849.25 for AVLTreeNode.keys."} (fraction#_1011 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_1011 == exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
      exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1005[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_1011];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1005);
    } else {
    }
    if (!(Heap[this#385, AVLTreeNode.left] == null)) {
      assert {:msg "  779.4: The precondition at 851.12 might not hold. The expression at 851.25 might not evaluate to true."} (forall k#99#387: int :: (0 <= k#99#387) && (k#99#387 < Seq#Length(Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#385, AVLTreeNode.left], AVLTreeNode.keys], k#99#387) < Heap[this#385, AVLTreeNode.key]));
    } else {
    }
    assert {:msg "  779.4: The precondition at 853.12 might not hold. The expression at 853.12 might not evaluate to true."} !(Heap[this#385, AVLTreeNode.right] == null);
    fraction#_1012 := 100;
    assert {:msg "  779.4: The precondition at 854.12 might not hold. Insufficient fraction at 854.12 for AVLTreeNode.valid."} (fraction#_1012 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1012 == exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1012];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
    fraction#_1013 := 50;
    assert {:msg "  779.4: The precondition at 856.12 might not hold. Insufficient fraction at 856.12 for AVLTreeNode.keys."} (fraction#_1013 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_1013 == exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1005[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_1013];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
    assert {:msg "  779.4: The precondition at 858.12 might not hold. The expression at 858.12 might not evaluate to true."} (forall k#100#388: int :: (0 <= k#100#388) && (k#100#388 < Seq#Length(Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#385, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#385, AVLTreeNode.right], AVLTreeNode.keys], k#100#388)));
    Mask := exhaleMask#_1005;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#386;
    // inhale (postcondition)
    havoc inhaleHeap#_1016;
    assume IsGoodInhaleState(inhaleHeap#_1016, Heap, Mask);
    assume r#386 != null;
    Heap[r#386, AVLTreeNode.valid] := inhaleHeap#_1016[r#386, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1016[r#386, AVLTreeNode.valid] == Heap;
    Mask[r#386, AVLTreeNode.valid] := Mask[r#386, AVLTreeNode.valid][perm$R := Mask[r#386, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1016[r#386, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1016, Mask);
    assume r#386 != null;
    Heap[r#386, AVLTreeNode.keys] := inhaleHeap#_1016[r#386, AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#386, AVLTreeNode.keys] := Mask[r#386, AVLTreeNode.keys][perm$R := Mask[r#386, AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1016[r#386, AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1016, Mask);
    assume Seq#Equal(Heap[r#386, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1002[this#385, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1002[callHeap#_1002[this#385, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1002[this#385, AVLTreeNode.key])), callHeap#_1002[callHeap#_1002[this#385, AVLTreeNode.right], AVLTreeNode.keys]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#56 := r#386;
  }
  // begin exhale (postcondition)
  exhaleMask#_1017 := Mask;
  fraction#_1018 := 100;
  assert {:msg "  740.2: The postcondition at 765.11 might not hold. Insufficient fraction at 765.11 for AVLTreeNode.valid."} (fraction#_1018 <= exhaleMask#_1017[r#56, AVLTreeNode.valid][perm$R]) && ((fraction#_1018 == exhaleMask#_1017[r#56, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1017[r#56, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1017[r#56, AVLTreeNode.valid] := exhaleMask#_1017[r#56, AVLTreeNode.valid][perm$R := exhaleMask#_1017[r#56, AVLTreeNode.valid][perm$R] - fraction#_1018];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1017);
  fraction#_1019 := 50;
  assert {:msg "  740.2: The postcondition at 767.11 might not hold. Insufficient fraction at 767.11 for AVLTreeNode.keys."} (fraction#_1019 <= exhaleMask#_1017[r#56, AVLTreeNode.keys][perm$R]) && ((fraction#_1019 == exhaleMask#_1017[r#56, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1017[r#56, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1017[r#56, AVLTreeNode.keys] := exhaleMask#_1017[r#56, AVLTreeNode.keys][perm$R := exhaleMask#_1017[r#56, AVLTreeNode.keys][perm$R] - fraction#_1019];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1017);
  assert {:msg "  740.2: The postcondition at 771.11 might not hold. The expression at 771.11 might not evaluate to true."} Seq#Equal(Heap[r#56, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  Mask := exhaleMask#_1017;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  740.2: Method might lock/unlock more than allowed."} (forall lk#_1020: ref :: {Heap[lk#_1020, held]} {Heap[lk#_1020, rdheld]} (((0 < Heap[lk#_1020, held]) == (0 < old(Heap)[lk#_1020, held])) && (Heap[lk#_1020, rdheld] == old(Heap)[lk#_1020, rdheld])) || false);
  assert {:msg "  740.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#59: ref where (r#59 == null) || (dtype(r#59) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1021: HeapType;
  var k#93#390: int where true;
  var k#94#392: int where true;
  var Heap#_1025: HeapType;
  var Mask#_1026: MaskType;
  var Credits#_1027: CreditsType;
  var exhaleMask#_1028: MaskType;
  var fraction#_1029: int;
  var inhaleHeap#_1030: HeapType;
  var inhaleHeap#_1031: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1021;
  assume IsGoodInhaleState(inhaleHeap#_1021, Heap, Mask);
  assert {:msg "  785.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  785.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1021[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1021[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1021, Mask);
  assert {:msg "  787.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  787.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1021[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1021[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1021, Mask);
  assert {:msg "  788.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  788.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1021[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1021[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1021, Mask);
  assert {:msg "  790.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  790.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_1021[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1021[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1021, Mask);
  assert {:msg "  793.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  793.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  793.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  793.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1021[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1021[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1021[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1021, Mask);
  } else {
  }
  assert {:msg "  795.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  795.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  795.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  795.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  795.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  795.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1021[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1021[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1021, Mask);
  } else {
  }
  assert {:msg "  797.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  797.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  797.12: Receiver might be null."} true && (0 <= k#93#390) ==> (this != null);
    assert {:msg "  797.12: Location might not be readable."} true && (0 <= k#93#390) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  797.12: Receiver might be null."} true && (0 <= k#93#390) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  797.12: Location might not be readable."} true && (0 <= k#93#390) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  797.12: Receiver might be null."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  797.12: Location might not be readable."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  797.12: Receiver might be null."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  797.12: Location might not be readable."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  797.50: Sequence index might be negative."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#93#390);
    assert {:msg "  797.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  797.54: Receiver might be null."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  797.54: Location might not be readable."} true && (0 <= k#93#390) && (k#93#390 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#93#389: int :: (0 <= k#93#389) && (k#93#389 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#93#389) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assert {:msg "  799.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  799.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  800.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  800.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1021[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1021[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1021[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1021, Mask);
  assert {:msg "  802.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  802.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  802.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  802.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1021[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1021[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1021, Mask);
  assert {:msg "  804.12: Receiver might be null."} true && (0 <= k#94#392) ==> (this != null);
  assert {:msg "  804.12: Location might not be readable."} true && (0 <= k#94#392) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  804.12: Receiver might be null."} true && (0 <= k#94#392) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  804.12: Location might not be readable."} true && (0 <= k#94#392) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  804.38: Receiver might be null."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  804.38: Location might not be readable."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  804.12: Receiver might be null."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  804.12: Location might not be readable."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  804.12: Receiver might be null."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  804.12: Location might not be readable."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  804.44: Sequence index might be negative."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#94#392);
  assert {:msg "  804.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#94#392) && (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#94#392 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#94#391: int :: (0 <= k#94#391) && (k#94#391 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#94#391)));
  // unfolding
  assert {:msg "  806.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  806.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  Heap#_1025 := Heap;
  Mask#_1026 := Mask;
  Credits#_1027 := Credits;
  // begin exhale (unfolding)
  exhaleMask#_1028 := Mask#_1026;
  fraction#_1029 := 100;
  assert {:msg "  806.12: Unfolding might fail. Insufficient fraction at 806.22 for AVLTreeNode.valid."} (fraction#_1029 <= exhaleMask#_1028[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1029 == exhaleMask#_1028[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1028[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  exhaleMask#_1028[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1028[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1028[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1029];
  assume IsGoodMask(Mask#_1026);
  assume wf(Heap#_1025, Mask#_1026);
  assume wf(Heap#_1025, exhaleMask#_1028);
  Mask#_1026 := exhaleMask#_1028;
  assume wf(Heap#_1025, Mask#_1026);
  // end exhale
  // inhale (unfolding)
  inhaleHeap#_1030 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1030, Heap#_1025, Mask#_1026);
  assume Heap#_1025[this, AVLTreeNode.right] != null;
  Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key];
  assume wf(Heap#_1025, Mask#_1026);
  assume true;
  Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key] := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask#_1026);
  assume IsGoodState(inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume wf(Heap#_1025, Mask#_1026);
  assume wf(inhaleHeap#_1030, Mask#_1026);
  assume Heap#_1025[this, AVLTreeNode.right] != null;
  Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left];
  assume wf(Heap#_1025, Mask#_1026);
  assume (Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask#_1026);
  assume IsGoodState(inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left]);
  assume wf(Heap#_1025, Mask#_1026);
  assume wf(inhaleHeap#_1030, Mask#_1026);
  assume Heap#_1025[this, AVLTreeNode.right] != null;
  Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right];
  assume wf(Heap#_1025, Mask#_1026);
  assume (Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask#_1026);
  assume IsGoodState(inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right]);
  assume wf(Heap#_1025, Mask#_1026);
  assume wf(inhaleHeap#_1030, Mask#_1026);
  assume Heap#_1025[this, AVLTreeNode.right] != null;
  Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap#_1025, Mask#_1026);
  assume true;
  Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_1026[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask#_1026);
  assume IsGoodState(inhaleHeap#_1030[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap#_1025, Mask#_1026);
  assume wf(inhaleHeap#_1030, Mask#_1026);
  if (!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap#_1025, Mask#_1026);
    assume inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_1025;
    Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_1026);
    assume IsGoodState(inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap#_1025, Mask#_1026);
    assume wf(inhaleHeap#_1030, Mask#_1026);
  } else {
  }
  if (!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap#_1025, Mask#_1026);
    assume true;
    Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_1026);
    assume IsGoodState(inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap#_1025, Mask#_1026);
    assume wf(inhaleHeap#_1030, Mask#_1026);
  } else {
  }
  if (!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#67#393: int :: (0 <= lk#67#393) && (lk#67#393 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#67#393) < Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key]));
  } else {
  }
  if (!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap#_1025, Mask#_1026);
    assume inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_1025;
    Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_1026);
    assume IsGoodState(inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap#_1025, Mask#_1026);
    assume wf(inhaleHeap#_1030, Mask#_1026);
  } else {
  }
  if (!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap#_1025, Mask#_1026);
    assume true;
    Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask#_1026[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask#_1026);
    assume IsGoodState(inhaleHeap#_1030[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap#_1025, Mask#_1026);
    assume wf(inhaleHeap#_1030, Mask#_1026);
  } else {
  }
  if (!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#68#394: int :: (0 <= rk#68#394) && (rk#68#394 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#68#394)));
  } else {
  }
  assume Seq#Equal(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys], Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69) <==> ((((!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap#_1025[Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap#_1025[Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume IsGoodMask(Mask#_1026);
  assume wf(Heap#_1025, Mask#_1026);
  // end inhale
  assert {:msg "  806.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.37: Location might not be readable."} true ==> CanRead(Mask#_1026, this, AVLTreeNode.right);
  assert {:msg "  806.37: Receiver might be null."} true ==> (Heap#_1025[this, AVLTreeNode.right] != null);
  assert {:msg "  806.37: Location might not be readable."} true ==> CanRead(Mask#_1026, Heap#_1025[this, AVLTreeNode.right], AVLTreeNode.left);
  assume !(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1031;
  assume IsGoodInhaleState(inhaleHeap#_1031, Heap, Mask);
  assume r#59 != null;
  Heap[r#59, AVLTreeNode.valid] := inhaleHeap#_1031[r#59, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1031[r#59, AVLTreeNode.valid] == Heap;
  Mask[r#59, AVLTreeNode.valid] := Mask[r#59, AVLTreeNode.valid][perm$R := Mask[r#59, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1031[r#59, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1031, Mask);
  assert {:msg "  813.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  813.31: Fraction might exceed 100."} 50 <= 100;
  assume r#59 != null;
  Heap[r#59, AVLTreeNode.keys] := inhaleHeap#_1031[r#59, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#59, AVLTreeNode.keys] := Mask[r#59, AVLTreeNode.keys][perm$R := Mask[r#59, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1031[r#59, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1031, Mask);
  assert {:msg "  817.11: Receiver might be null."} true ==> (r#59 != null);
  assert {:msg "  817.11: Location might not be readable."} true ==> CanRead(Mask, r#59, AVLTreeNode.keys);
  assert {:msg "  817.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  817.26: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  817.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  817.51: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  817.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  817.51: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  817.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  817.71: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  817.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  817.84: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  817.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  817.84: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#59, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#59: ref where (r#59 == null) || (dtype(r#59) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1032: HeapType;
  var Heap#_1036: HeapType;
  var Mask#_1037: MaskType;
  var Credits#_1038: CreditsType;
  var exhaleMask#_1039: MaskType;
  var k#95#398: int where true;
  var exhaleMask#_1040: MaskType;
  var fraction#_1041: int;
  var inhaleHeap#_1042: HeapType;
  var Heap#_1046: HeapType;
  var Mask#_1047: MaskType;
  var Credits#_1048: CreditsType;
  var exhaleMask#_1049: MaskType;
  var k#96#402: int where true;
  var exhaleMask#_1050: MaskType;
  var fraction#_1051: int;
  var inhaleHeap#_1052: HeapType;
  var Heap#_1056: HeapType;
  var Mask#_1057: MaskType;
  var Credits#_1058: CreditsType;
  var exhaleMask#_1059: MaskType;
  var k#97#406: int where true;
  var this#407: ref where (this#407 == null) || (dtype(this#407) == AVLTreeNode#t);
  var callHeap#_1060: HeapType;
  var callMask#_1061: MaskType;
  var callCredits#_1062: CreditsType;
  var exhaleMask#_1063: MaskType;
  var fraction#_1064: int;
  var fraction#_1065: int;
  var fraction#_1066: int;
  var fraction#_1067: int;
  var fraction#_1068: int;
  var fraction#_1069: int;
  var fraction#_1070: int;
  var fraction#_1071: int;
  var isHeld#_1072: int;
  var isRdHeld#_1073: bool;
  var inhaleHeap#_1074: HeapType;
  var Heap#_1078: HeapType;
  var Mask#_1079: MaskType;
  var Credits#_1080: CreditsType;
  var exhaleMask#_1081: MaskType;
  var k#98#411: int where true;
  var this#412: ref where (this#412 == null) || (dtype(this#412) == AVLTreeNode#t);
  var callHeap#_1082: HeapType;
  var callMask#_1083: MaskType;
  var callCredits#_1084: CreditsType;
  var exhaleMask#_1085: MaskType;
  var fraction#_1086: int;
  var fraction#_1087: int;
  var fraction#_1088: int;
  var fraction#_1089: int;
  var fraction#_1090: int;
  var fraction#_1091: int;
  var fraction#_1092: int;
  var fraction#_1093: int;
  var isHeld#_1094: int;
  var isRdHeld#_1095: bool;
  var inhaleHeap#_1096: HeapType;
  var this#415: ref where (this#415 == null) || (dtype(this#415) == AVLTreeNode#t);
  var callHeap#_1097: HeapType;
  var callMask#_1098: MaskType;
  var callCredits#_1099: CreditsType;
  var exhaleMask#_1100: MaskType;
  var fraction#_1101: int;
  var fraction#_1102: int;
  var fraction#_1103: int;
  var fraction#_1104: int;
  var fraction#_1105: int;
  var fraction#_1106: int;
  var fraction#_1107: int;
  var fraction#_1108: int;
  var isHeld#_1109: int;
  var isRdHeld#_1110: bool;
  var inhaleHeap#_1111: HeapType;
  var exhaleMask#_1112: MaskType;
  var fraction#_1113: int;
  var fraction#_1114: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1032;
  assume IsGoodInhaleState(inhaleHeap#_1032, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1032[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1032[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1032, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1032[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1032[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1032, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1032[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1032[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1032, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_1032[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1032[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1032, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1032[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1032[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1032[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1032, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1032[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1032[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1032, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#93#395: int :: (0 <= k#93#395) && (k#93#395 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#93#395) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1032[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1032[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1032[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1032, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1032[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1032[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1032, Mask);
  assume (forall k#94#396: int :: (0 <= k#94#396) && (k#94#396 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#94#396)));
  assume !(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_1036 := Heap;
  Mask#_1037 := Mask;
  Credits#_1038 := Credits;
  // begin exhale (assert)
  exhaleMask#_1039 := Mask#_1037;
  assert {:msg "  819.10: Receiver might be null."} true && (0 <= k#95#398) ==> (this != null);
  assert {:msg "  819.10: Location might not be readable."} true && (0 <= k#95#398) ==> CanRead(Mask#_1037, this, AVLTreeNode.right);
  assert {:msg "  819.10: Receiver might be null."} true && (0 <= k#95#398) ==> (Heap#_1036[this, AVLTreeNode.right] != null);
  assert {:msg "  819.10: Location might not be readable."} true && (0 <= k#95#398) ==> CanRead(Mask#_1037, Heap#_1036[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  819.36: Receiver might be null."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  819.36: Location might not be readable."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_1037, this, AVLTreeNode.key);
  assert {:msg "  819.10: Receiver might be null."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  819.10: Location might not be readable."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_1037, this, AVLTreeNode.right);
  assert {:msg "  819.10: Receiver might be null."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_1036[this, AVLTreeNode.right] != null);
  assert {:msg "  819.10: Location might not be readable."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_1037, Heap#_1036[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  819.42: Sequence index might be negative."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#95#398);
  assert {:msg "  819.42: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#95#398) && (k#95#398 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#95#398 < Seq#Length(Heap#_1036[Heap#_1036[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assert {:msg "  819.3: Assertion might not hold. The expression at 819.10 might not evaluate to true."} (forall k#95#397: int :: (0 <= k#95#397) && (k#95#397 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_1036[this, AVLTreeNode.key] < Seq#Index(Heap#_1036[Heap#_1036[this, AVLTreeNode.right], AVLTreeNode.keys], k#95#397)));
  Mask#_1037 := exhaleMask#_1039;
  assume wf(Heap#_1036, Mask#_1037);
  // end exhale
  // unfold
  assert {:msg "  820.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  820.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  820.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  exhaleMask#_1040 := Mask;
  fraction#_1041 := 100;
  assert {:msg "  820.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1041 <= exhaleMask#_1040[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1041 == exhaleMask#_1040[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1040[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  exhaleMask#_1040[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1040[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1040[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1041];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1040);
  Mask := exhaleMask#_1040;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1042 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1042, Heap, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1042, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1042, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1042, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1042[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1042, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1042, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1042, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#67#399: int :: (0 <= lk#67#399) && (lk#67#399 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#67#399) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1042, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1042[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1042, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#68#400: int :: (0 <= rk#68#400) && (rk#68#400 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#68#400)));
  } else {
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  821.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  821.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  821.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  821.8: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  r#59 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  // assert
  Heap#_1046 := Heap;
  Mask#_1047 := Mask;
  Credits#_1048 := Credits;
  // begin exhale (assert)
  exhaleMask#_1049 := Mask#_1047;
  assert {:msg "  822.10: Receiver might be null."} true && (0 <= k#96#402) ==> (r#59 != null);
  assert {:msg "  822.10: Location might not be readable."} true && (0 <= k#96#402) ==> CanRead(Mask#_1047, r#59, AVLTreeNode.keys);
  assert {:msg "  822.32: Receiver might be null."} true && (0 <= k#96#402) && (k#96#402 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  822.32: Location might not be readable."} true && (0 <= k#96#402) && (k#96#402 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> CanRead(Mask#_1047, this, AVLTreeNode.key);
  assert {:msg "  822.10: Receiver might be null."} true && (0 <= k#96#402) && (k#96#402 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> (r#59 != null);
  assert {:msg "  822.10: Location might not be readable."} true && (0 <= k#96#402) && (k#96#402 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> CanRead(Mask#_1047, r#59, AVLTreeNode.keys);
  assert {:msg "  822.38: Sequence index might be negative."} true && (0 <= k#96#402) && (k#96#402 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> (0 <= k#96#402);
  assert {:msg "  822.38: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#96#402) && (k#96#402 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> (k#96#402 < Seq#Length(Heap#_1046[r#59, AVLTreeNode.keys]));
  assert {:msg "  822.3: Assertion might not hold. The expression at 822.10 might not evaluate to true."} (forall k#96#401: int :: (0 <= k#96#401) && (k#96#401 < Seq#Length(Heap[r#59, AVLTreeNode.keys])) ==> (Heap#_1046[this, AVLTreeNode.key] < Seq#Index(Heap#_1046[r#59, AVLTreeNode.keys], k#96#401)));
  Mask#_1047 := exhaleMask#_1049;
  assume wf(Heap#_1046, Mask#_1047);
  // end exhale
  // unfold
  assert {:msg "  823.3: The target of the fold statement might be null."} r#59 != null;
  // begin exhale (unfold)
  exhaleMask#_1050 := Mask;
  fraction#_1051 := 100;
  assert {:msg "  823.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1051 <= exhaleMask#_1050[r#59, AVLTreeNode.valid][perm$R]) && ((fraction#_1051 == exhaleMask#_1050[r#59, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1050[r#59, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1050[r#59, AVLTreeNode.valid] := exhaleMask#_1050[r#59, AVLTreeNode.valid][perm$R := exhaleMask#_1050[r#59, AVLTreeNode.valid][perm$R] - fraction#_1051];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1050);
  Mask := exhaleMask#_1050;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1052 := Heap[r#59, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1052, Heap, Mask);
  assume r#59 != null;
  Heap[r#59, AVLTreeNode.key] := inhaleHeap#_1052[r#59, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#59, AVLTreeNode.key] := Mask[r#59, AVLTreeNode.key][perm$R := Mask[r#59, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1052[r#59, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1052, Mask);
  assume r#59 != null;
  Heap[r#59, AVLTreeNode.left] := inhaleHeap#_1052[r#59, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[r#59, AVLTreeNode.left] == null) || (dtype(Heap[r#59, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[r#59, AVLTreeNode.left] := Mask[r#59, AVLTreeNode.left][perm$R := Mask[r#59, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1052[r#59, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1052, Mask);
  assume r#59 != null;
  Heap[r#59, AVLTreeNode.right] := inhaleHeap#_1052[r#59, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[r#59, AVLTreeNode.right] == null) || (dtype(Heap[r#59, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[r#59, AVLTreeNode.right] := Mask[r#59, AVLTreeNode.right][perm$R := Mask[r#59, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1052[r#59, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1052, Mask);
  assume r#59 != null;
  Heap[r#59, AVLTreeNode.keys] := inhaleHeap#_1052[r#59, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#59, AVLTreeNode.keys] := Mask[r#59, AVLTreeNode.keys][perm$R := Mask[r#59, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1052[r#59, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1052, Mask);
  if (!(Heap[r#59, AVLTreeNode.left] == null)) {
    assume Heap[r#59, AVLTreeNode.left] != null;
    Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1052[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1052[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1052[Heap[r#59, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1052, Mask);
  } else {
  }
  if (!(Heap[r#59, AVLTreeNode.left] == null)) {
    assume Heap[r#59, AVLTreeNode.left] != null;
    Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1052[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1052[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1052, Mask);
  } else {
  }
  if (!(Heap[r#59, AVLTreeNode.left] == null)) {
    assume (forall lk#67#403: int :: (0 <= lk#67#403) && (lk#67#403 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys], lk#67#403) < Heap[r#59, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[r#59, AVLTreeNode.right] == null)) {
    assume Heap[r#59, AVLTreeNode.right] != null;
    Heap[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1052[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1052[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1052[Heap[r#59, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1052, Mask);
  } else {
  }
  if (!(Heap[r#59, AVLTreeNode.right] == null)) {
    assume Heap[r#59, AVLTreeNode.right] != null;
    Heap[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1052[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1052[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1052, Mask);
  } else {
  }
  if (!(Heap[r#59, AVLTreeNode.right] == null)) {
    assume (forall rk#68#404: int :: (0 <= rk#68#404) && (rk#68#404 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[r#59, AVLTreeNode.key] < Seq#Index(Heap[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys], rk#68#404)));
  } else {
  }
  assume Seq#Equal(Heap[r#59, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[r#59, AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[r#59, AVLTreeNode.key])), ite(Heap[r#59, AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[r#59, AVLTreeNode.keys], Heap[r#59, AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[r#59, AVLTreeNode.keys], kk#69) <==> ((((!(Heap[r#59, AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[r#59, AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[r#59, AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[r#59, AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assert
  Heap#_1056 := Heap;
  Mask#_1057 := Mask;
  Credits#_1058 := Credits;
  // begin exhale (assert)
  exhaleMask#_1059 := Mask#_1057;
  assert {:msg "  824.10: Receiver might be null."} true ==> (r#59 != null);
  assert {:msg "  824.10: Location might not be readable."} true ==> CanRead(Mask#_1057, r#59, AVLTreeNode.left);
  if (!(Heap#_1056[r#59, AVLTreeNode.left] == null)) {
    assert {:msg "  824.10: Receiver might be null."} true && (0 <= k#97#406) ==> (r#59 != null);
    assert {:msg "  824.10: Location might not be readable."} true && (0 <= k#97#406) ==> CanRead(Mask#_1057, r#59, AVLTreeNode.left);
    assert {:msg "  824.10: Receiver might be null."} true && (0 <= k#97#406) ==> (Heap#_1056[r#59, AVLTreeNode.left] != null);
    assert {:msg "  824.10: Location might not be readable."} true && (0 <= k#97#406) ==> CanRead(Mask#_1057, Heap#_1056[r#59, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  824.54: Receiver might be null."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  824.54: Location might not be readable."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_1057, this, AVLTreeNode.key);
    assert {:msg "  824.10: Receiver might be null."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (r#59 != null);
    assert {:msg "  824.10: Location might not be readable."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_1057, r#59, AVLTreeNode.left);
    assert {:msg "  824.10: Receiver might be null."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap#_1056[r#59, AVLTreeNode.left] != null);
    assert {:msg "  824.10: Location might not be readable."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask#_1057, Heap#_1056[r#59, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  824.60: Sequence index might be negative."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#97#406);
    assert {:msg "  824.60: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#97#406) && (k#97#406 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#97#406 < Seq#Length(Heap#_1056[Heap#_1056[r#59, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  824.3: Assertion might not hold. The expression at 824.27 might not evaluate to true."} (forall k#97#405: int :: (0 <= k#97#405) && (k#97#405 < Seq#Length(Heap[Heap[r#59, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap#_1056[this, AVLTreeNode.key] < Seq#Index(Heap#_1056[Heap#_1056[r#59, AVLTreeNode.left], AVLTreeNode.keys], k#97#405)));
  } else {
  }
  Mask#_1057 := exhaleMask#_1059;
  assume wf(Heap#_1056, Mask#_1057);
  // end exhale
  // update field left
  assert {:msg "  825.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.3: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  825.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  assert {:msg "  825.17: Receiver might be null."} true ==> (r#59 != null);
  assert {:msg "  825.17: Location might not be readable."} true ==> CanRead(Mask, r#59, AVLTreeNode.right);
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Heap[r#59, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1060 := Heap;
  callMask#_1061 := Mask;
  callCredits#_1062 := Credits;
  assert {:msg "  826.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  826.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  826.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#407 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_1063 := Mask;
  fraction#_1064 := 100;
  assert {:msg "  826.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1064 <= exhaleMask#_1063[this#407, AVLTreeNode.key][perm$R]) && ((fraction#_1064 == exhaleMask#_1063[this#407, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1063[this#407, AVLTreeNode.key][perm$N]));
  exhaleMask#_1063[this#407, AVLTreeNode.key] := exhaleMask#_1063[this#407, AVLTreeNode.key][perm$R := exhaleMask#_1063[this#407, AVLTreeNode.key][perm$R] - fraction#_1064];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1063);
  fraction#_1065 := 100;
  assert {:msg "  826.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1065 <= exhaleMask#_1063[this#407, AVLTreeNode.left][perm$R]) && ((fraction#_1065 == exhaleMask#_1063[this#407, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1063[this#407, AVLTreeNode.left][perm$N]));
  exhaleMask#_1063[this#407, AVLTreeNode.left] := exhaleMask#_1063[this#407, AVLTreeNode.left][perm$R := exhaleMask#_1063[this#407, AVLTreeNode.left][perm$R] - fraction#_1065];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1063);
  fraction#_1066 := 100;
  assert {:msg "  826.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1066 <= exhaleMask#_1063[this#407, AVLTreeNode.right][perm$R]) && ((fraction#_1066 == exhaleMask#_1063[this#407, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1063[this#407, AVLTreeNode.right][perm$N]));
  exhaleMask#_1063[this#407, AVLTreeNode.right] := exhaleMask#_1063[this#407, AVLTreeNode.right][perm$R := exhaleMask#_1063[this#407, AVLTreeNode.right][perm$R] - fraction#_1066];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1063);
  fraction#_1067 := 100;
  assert {:msg "  826.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_1067 <= exhaleMask#_1063[this#407, AVLTreeNode.keys][perm$R]) && ((fraction#_1067 == exhaleMask#_1063[this#407, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1063[this#407, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1063[this#407, AVLTreeNode.keys] := exhaleMask#_1063[this#407, AVLTreeNode.keys][perm$R := exhaleMask#_1063[this#407, AVLTreeNode.keys][perm$R] - fraction#_1067];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1063);
  if (!(Heap[this#407, AVLTreeNode.left] == null)) {
    fraction#_1068 := 100;
    assert {:msg "  826.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1068 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1068 == exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1068];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1063);
  } else {
  }
  if (!(Heap[this#407, AVLTreeNode.left] == null)) {
    fraction#_1069 := 50;
    assert {:msg "  826.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_1069 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_1069 == exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1063[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_1069];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1063);
  } else {
  }
  if (!(Heap[this#407, AVLTreeNode.left] == null)) {
    assert {:msg "  826.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#408: int :: (0 <= k#79#408) && (k#79#408 < Seq#Length(Heap[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#407, AVLTreeNode.left], AVLTreeNode.keys], k#79#408) < Heap[this#407, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#407, AVLTreeNode.right] == null)) {
    fraction#_1070 := 100;
    assert {:msg "  826.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1070 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1070 == exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1070];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1063);
  } else {
  }
  if (!(Heap[this#407, AVLTreeNode.right] == null)) {
    fraction#_1071 := 50;
    assert {:msg "  826.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_1071 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_1071 == exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1063[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_1071];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1063);
  } else {
  }
  if (!(Heap[this#407, AVLTreeNode.right] == null)) {
    assert {:msg "  826.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#409: int :: (0 <= k#80#409) && (k#80#409 < Seq#Length(Heap[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#407, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#407, AVLTreeNode.right], AVLTreeNode.keys], k#80#409)));
  } else {
  }
  Mask := exhaleMask#_1063;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1074;
  assume IsGoodInhaleState(inhaleHeap#_1074, Heap, Mask);
  assume this#407 != null;
  Heap[this#407, AVLTreeNode.valid] := inhaleHeap#_1074[this#407, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1074[this#407, AVLTreeNode.valid] == Heap;
  Mask[this#407, AVLTreeNode.valid] := Mask[this#407, AVLTreeNode.valid][perm$R := Mask[this#407, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this#407, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume this#407 != null;
  Heap[this#407, AVLTreeNode.keys] := inhaleHeap#_1074[this#407, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#407, AVLTreeNode.keys] := Mask[this#407, AVLTreeNode.keys][perm$R := Mask[this#407, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this#407, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume Seq#Equal(Heap[this#407, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1060[this#407, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1060[callHeap#_1060[this#407, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1060[this#407, AVLTreeNode.key])), ite(callHeap#_1060[this#407, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1060[callHeap#_1060[this#407, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  827.3: Location might not be writable"} CanWrite(Mask, r#59, AVLTreeNode.right);
  assert {:msg "  827.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  827.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  Heap[r#59, AVLTreeNode.right] := Heap[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // update field right
  assert {:msg "  828.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  828.17: Receiver might be null."} true ==> (r#59 != null);
  assert {:msg "  828.17: Location might not be readable."} true ==> CanRead(Mask, r#59, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#59, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // assert
  Heap#_1078 := Heap;
  Mask#_1079 := Mask;
  Credits#_1080 := Credits;
  // begin exhale (assert)
  exhaleMask#_1081 := Mask#_1079;
  assert {:msg "  829.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  829.10: Location might not be readable."} true ==> CanRead(Mask#_1079, this, AVLTreeNode.right);
  if (!(Heap#_1078[this, AVLTreeNode.right] == null)) {
    assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#98#411) ==> (this != null);
    assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#98#411) ==> CanRead(Mask#_1079, this, AVLTreeNode.right);
    assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#98#411) ==> (Heap#_1078[this, AVLTreeNode.right] != null);
    assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#98#411) ==> CanRead(Mask#_1079, Heap#_1078[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  829.52: Receiver might be null."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  829.52: Location might not be readable."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_1079, this, AVLTreeNode.key);
    assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_1079, this, AVLTreeNode.right);
    assert {:msg "  829.10: Receiver might be null."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_1078[this, AVLTreeNode.right] != null);
    assert {:msg "  829.10: Location might not be readable."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask#_1079, Heap#_1078[this, AVLTreeNode.right], AVLTreeNode.keys);
    assert {:msg "  829.58: Sequence index might be negative."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#98#411);
    assert {:msg "  829.58: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#98#411) && (k#98#411 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#98#411 < Seq#Length(Heap#_1078[Heap#_1078[this, AVLTreeNode.right], AVLTreeNode.keys]));
    assert {:msg "  829.3: Assertion might not hold. The expression at 829.26 might not evaluate to true."} (forall k#98#410: int :: (0 <= k#98#410) && (k#98#410 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap#_1078[this, AVLTreeNode.key] < Seq#Index(Heap#_1078[Heap#_1078[this, AVLTreeNode.right], AVLTreeNode.keys], k#98#410)));
  } else {
  }
  Mask#_1079 := exhaleMask#_1081;
  assume wf(Heap#_1078, Mask#_1079);
  // end exhale
  // call close
  callHeap#_1082 := Heap;
  callMask#_1083 := Mask;
  callCredits#_1084 := Credits;
  assert {:msg "  830.3: The target of the method call might be null."} this != null;
  this#412 := this;
  // begin exhale (precondition)
  exhaleMask#_1085 := Mask;
  fraction#_1086 := 100;
  assert {:msg "  830.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1086 <= exhaleMask#_1085[this#412, AVLTreeNode.key][perm$R]) && ((fraction#_1086 == exhaleMask#_1085[this#412, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1085[this#412, AVLTreeNode.key][perm$N]));
  exhaleMask#_1085[this#412, AVLTreeNode.key] := exhaleMask#_1085[this#412, AVLTreeNode.key][perm$R := exhaleMask#_1085[this#412, AVLTreeNode.key][perm$R] - fraction#_1086];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1085);
  fraction#_1087 := 100;
  assert {:msg "  830.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1087 <= exhaleMask#_1085[this#412, AVLTreeNode.left][perm$R]) && ((fraction#_1087 == exhaleMask#_1085[this#412, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1085[this#412, AVLTreeNode.left][perm$N]));
  exhaleMask#_1085[this#412, AVLTreeNode.left] := exhaleMask#_1085[this#412, AVLTreeNode.left][perm$R := exhaleMask#_1085[this#412, AVLTreeNode.left][perm$R] - fraction#_1087];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1085);
  fraction#_1088 := 100;
  assert {:msg "  830.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1088 <= exhaleMask#_1085[this#412, AVLTreeNode.right][perm$R]) && ((fraction#_1088 == exhaleMask#_1085[this#412, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1085[this#412, AVLTreeNode.right][perm$N]));
  exhaleMask#_1085[this#412, AVLTreeNode.right] := exhaleMask#_1085[this#412, AVLTreeNode.right][perm$R := exhaleMask#_1085[this#412, AVLTreeNode.right][perm$R] - fraction#_1088];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1085);
  fraction#_1089 := 100;
  assert {:msg "  830.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_1089 <= exhaleMask#_1085[this#412, AVLTreeNode.keys][perm$R]) && ((fraction#_1089 == exhaleMask#_1085[this#412, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1085[this#412, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1085[this#412, AVLTreeNode.keys] := exhaleMask#_1085[this#412, AVLTreeNode.keys][perm$R := exhaleMask#_1085[this#412, AVLTreeNode.keys][perm$R] - fraction#_1089];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1085);
  if (!(Heap[this#412, AVLTreeNode.left] == null)) {
    fraction#_1090 := 100;
    assert {:msg "  830.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1090 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1090 == exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1090];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1085);
  } else {
  }
  if (!(Heap[this#412, AVLTreeNode.left] == null)) {
    fraction#_1091 := 50;
    assert {:msg "  830.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_1091 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_1091 == exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1085[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_1091];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1085);
  } else {
  }
  if (!(Heap[this#412, AVLTreeNode.left] == null)) {
    assert {:msg "  830.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#413: int :: (0 <= k#79#413) && (k#79#413 < Seq#Length(Heap[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#412, AVLTreeNode.left], AVLTreeNode.keys], k#79#413) < Heap[this#412, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#412, AVLTreeNode.right] == null)) {
    fraction#_1092 := 100;
    assert {:msg "  830.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1092 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1092 == exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1092];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1085);
  } else {
  }
  if (!(Heap[this#412, AVLTreeNode.right] == null)) {
    fraction#_1093 := 50;
    assert {:msg "  830.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_1093 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_1093 == exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1085[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_1093];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1085);
  } else {
  }
  if (!(Heap[this#412, AVLTreeNode.right] == null)) {
    assert {:msg "  830.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#414: int :: (0 <= k#80#414) && (k#80#414 < Seq#Length(Heap[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#412, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#412, AVLTreeNode.right], AVLTreeNode.keys], k#80#414)));
  } else {
  }
  Mask := exhaleMask#_1085;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1096;
  assume IsGoodInhaleState(inhaleHeap#_1096, Heap, Mask);
  assume this#412 != null;
  Heap[this#412, AVLTreeNode.valid] := inhaleHeap#_1096[this#412, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1096[this#412, AVLTreeNode.valid] == Heap;
  Mask[this#412, AVLTreeNode.valid] := Mask[this#412, AVLTreeNode.valid][perm$R := Mask[this#412, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1096[this#412, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1096, Mask);
  assume this#412 != null;
  Heap[this#412, AVLTreeNode.keys] := inhaleHeap#_1096[this#412, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#412, AVLTreeNode.keys] := Mask[this#412, AVLTreeNode.keys][perm$R := Mask[this#412, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1096[this#412, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1096, Mask);
  assume Seq#Equal(Heap[this#412, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1082[this#412, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1082[callHeap#_1082[this#412, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1082[this#412, AVLTreeNode.key])), ite(callHeap#_1082[this#412, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1082[callHeap#_1082[this#412, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  831.3: Location might not be writable"} CanWrite(Mask, r#59, AVLTreeNode.left);
  Heap[r#59, AVLTreeNode.left] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_1097 := Heap;
  callMask#_1098 := Mask;
  callCredits#_1099 := Credits;
  assert {:msg "  832.3: The target of the method call might be null."} r#59 != null;
  this#415 := r#59;
  // begin exhale (precondition)
  exhaleMask#_1100 := Mask;
  fraction#_1101 := 100;
  assert {:msg "  832.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1101 <= exhaleMask#_1100[this#415, AVLTreeNode.key][perm$R]) && ((fraction#_1101 == exhaleMask#_1100[this#415, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1100[this#415, AVLTreeNode.key][perm$N]));
  exhaleMask#_1100[this#415, AVLTreeNode.key] := exhaleMask#_1100[this#415, AVLTreeNode.key][perm$R := exhaleMask#_1100[this#415, AVLTreeNode.key][perm$R] - fraction#_1101];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1100);
  fraction#_1102 := 100;
  assert {:msg "  832.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1102 <= exhaleMask#_1100[this#415, AVLTreeNode.left][perm$R]) && ((fraction#_1102 == exhaleMask#_1100[this#415, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1100[this#415, AVLTreeNode.left][perm$N]));
  exhaleMask#_1100[this#415, AVLTreeNode.left] := exhaleMask#_1100[this#415, AVLTreeNode.left][perm$R := exhaleMask#_1100[this#415, AVLTreeNode.left][perm$R] - fraction#_1102];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1100);
  fraction#_1103 := 100;
  assert {:msg "  832.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1103 <= exhaleMask#_1100[this#415, AVLTreeNode.right][perm$R]) && ((fraction#_1103 == exhaleMask#_1100[this#415, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1100[this#415, AVLTreeNode.right][perm$N]));
  exhaleMask#_1100[this#415, AVLTreeNode.right] := exhaleMask#_1100[this#415, AVLTreeNode.right][perm$R := exhaleMask#_1100[this#415, AVLTreeNode.right][perm$R] - fraction#_1103];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1100);
  fraction#_1104 := 100;
  assert {:msg "  832.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_1104 <= exhaleMask#_1100[this#415, AVLTreeNode.keys][perm$R]) && ((fraction#_1104 == exhaleMask#_1100[this#415, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1100[this#415, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1100[this#415, AVLTreeNode.keys] := exhaleMask#_1100[this#415, AVLTreeNode.keys][perm$R := exhaleMask#_1100[this#415, AVLTreeNode.keys][perm$R] - fraction#_1104];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1100);
  if (!(Heap[this#415, AVLTreeNode.left] == null)) {
    fraction#_1105 := 100;
    assert {:msg "  832.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1105 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1105 == exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1105];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1100);
  } else {
  }
  if (!(Heap[this#415, AVLTreeNode.left] == null)) {
    fraction#_1106 := 50;
    assert {:msg "  832.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_1106 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_1106 == exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1100[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_1106];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1100);
  } else {
  }
  if (!(Heap[this#415, AVLTreeNode.left] == null)) {
    assert {:msg "  832.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#416: int :: (0 <= k#79#416) && (k#79#416 < Seq#Length(Heap[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#415, AVLTreeNode.left], AVLTreeNode.keys], k#79#416) < Heap[this#415, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#415, AVLTreeNode.right] == null)) {
    fraction#_1107 := 100;
    assert {:msg "  832.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1107 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1107 == exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1107];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1100);
  } else {
  }
  if (!(Heap[this#415, AVLTreeNode.right] == null)) {
    fraction#_1108 := 50;
    assert {:msg "  832.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_1108 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_1108 == exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1100[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_1108];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1100);
  } else {
  }
  if (!(Heap[this#415, AVLTreeNode.right] == null)) {
    assert {:msg "  832.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#417: int :: (0 <= k#80#417) && (k#80#417 < Seq#Length(Heap[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#415, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#415, AVLTreeNode.right], AVLTreeNode.keys], k#80#417)));
  } else {
  }
  Mask := exhaleMask#_1100;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1111;
  assume IsGoodInhaleState(inhaleHeap#_1111, Heap, Mask);
  assume this#415 != null;
  Heap[this#415, AVLTreeNode.valid] := inhaleHeap#_1111[this#415, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1111[this#415, AVLTreeNode.valid] == Heap;
  Mask[this#415, AVLTreeNode.valid] := Mask[this#415, AVLTreeNode.valid][perm$R := Mask[this#415, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1111[this#415, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1111, Mask);
  assume this#415 != null;
  Heap[this#415, AVLTreeNode.keys] := inhaleHeap#_1111[this#415, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#415, AVLTreeNode.keys] := Mask[this#415, AVLTreeNode.keys][perm$R := Mask[this#415, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1111[this#415, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1111, Mask);
  assume Seq#Equal(Heap[this#415, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1097[this#415, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1097[callHeap#_1097[this#415, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1097[this#415, AVLTreeNode.key])), ite(callHeap#_1097[this#415, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1097[callHeap#_1097[this#415, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1112 := Mask;
  fraction#_1113 := 100;
  assert {:msg "  784.2: The postcondition at 811.11 might not hold. Insufficient fraction at 811.11 for AVLTreeNode.valid."} (fraction#_1113 <= exhaleMask#_1112[r#59, AVLTreeNode.valid][perm$R]) && ((fraction#_1113 == exhaleMask#_1112[r#59, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1112[r#59, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1112[r#59, AVLTreeNode.valid] := exhaleMask#_1112[r#59, AVLTreeNode.valid][perm$R := exhaleMask#_1112[r#59, AVLTreeNode.valid][perm$R] - fraction#_1113];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1112);
  fraction#_1114 := 50;
  assert {:msg "  784.2: The postcondition at 813.11 might not hold. Insufficient fraction at 813.11 for AVLTreeNode.keys."} (fraction#_1114 <= exhaleMask#_1112[r#59, AVLTreeNode.keys][perm$R]) && ((fraction#_1114 == exhaleMask#_1112[r#59, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1112[r#59, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1112[r#59, AVLTreeNode.keys] := exhaleMask#_1112[r#59, AVLTreeNode.keys][perm$R := exhaleMask#_1112[r#59, AVLTreeNode.keys][perm$R] - fraction#_1114];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1112);
  assert {:msg "  784.2: The postcondition at 817.11 might not hold. The expression at 817.11 might not evaluate to true."} Seq#Equal(Heap[r#59, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  Mask := exhaleMask#_1112;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  784.2: Method might lock/unlock more than allowed."} (forall lk#_1115: ref :: {Heap[lk#_1115, held]} {Heap[lk#_1115, rdheld]} (((0 < Heap[lk#_1115, held]) == (0 < old(Heap)[lk#_1115, held])) && (Heap[lk#_1115, rdheld] == old(Heap)[lk#_1115, rdheld])) || false);
  assert {:msg "  784.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#60: ref where (r#60 == null) || (dtype(r#60) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1116: HeapType;
  var k#99#419: int where true;
  var k#100#421: int where true;
  var inhaleHeap#_1117: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1116;
  assume IsGoodInhaleState(inhaleHeap#_1116, Heap, Mask);
  assert {:msg "  839.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  839.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1116[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1116[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1116, Mask);
  assert {:msg "  841.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  841.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1116[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1116[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1116, Mask);
  assert {:msg "  842.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  842.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1116[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1116[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1116, Mask);
  assert {:msg "  844.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  844.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_1116[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1116[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1116, Mask);
  assert {:msg "  847.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  847.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  847.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  847.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1116[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1116[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1116[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1116, Mask);
  } else {
  }
  assert {:msg "  849.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  849.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  849.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  849.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  849.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  849.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1116[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1116[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1116, Mask);
  } else {
  }
  assert {:msg "  851.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  851.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  851.12: Receiver might be null."} true && (0 <= k#99#419) ==> (this != null);
    assert {:msg "  851.12: Location might not be readable."} true && (0 <= k#99#419) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  851.12: Receiver might be null."} true && (0 <= k#99#419) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  851.12: Location might not be readable."} true && (0 <= k#99#419) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  851.12: Receiver might be null."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  851.12: Location might not be readable."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  851.12: Receiver might be null."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  851.12: Location might not be readable."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.keys);
    assert {:msg "  851.50: Sequence index might be negative."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (0 <= k#99#419);
    assert {:msg "  851.50: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]));
    assert {:msg "  851.54: Receiver might be null."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (this != null);
    assert {:msg "  851.54: Location might not be readable."} true && (0 <= k#99#419) && (k#99#419 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
    assume (forall k#99#418: int :: (0 <= k#99#418) && (k#99#418 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#99#418) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assert {:msg "  853.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  853.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  854.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  854.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1116[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1116[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1116[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1116, Mask);
  assert {:msg "  856.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  856.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  856.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  856.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1116[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1116[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1116, Mask);
  assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#100#421) ==> (this != null);
  assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#100#421) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#100#421) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#100#421) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  858.38: Receiver might be null."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  858.38: Location might not be readable."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.key);
  assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (this != null);
  assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  858.12: Receiver might be null."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  858.12: Location might not be readable."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.keys);
  assert {:msg "  858.44: Sequence index might be negative."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (0 <= k#100#421);
  assert {:msg "  858.44: Sequence index might be larger than or equal to the length of the sequence."} true && (0 <= k#100#421) && (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (k#100#421 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume (forall k#100#420: int :: (0 <= k#100#420) && (k#100#420 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#100#420)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1117;
  assume IsGoodInhaleState(inhaleHeap#_1117, Heap, Mask);
  assume r#60 != null;
  Heap[r#60, AVLTreeNode.valid] := inhaleHeap#_1117[r#60, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1117[r#60, AVLTreeNode.valid] == Heap;
  Mask[r#60, AVLTreeNode.valid] := Mask[r#60, AVLTreeNode.valid][perm$R := Mask[r#60, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1117[r#60, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1117, Mask);
  assert {:msg "  865.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  865.31: Fraction might exceed 100."} 50 <= 100;
  assume r#60 != null;
  Heap[r#60, AVLTreeNode.keys] := inhaleHeap#_1117[r#60, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#60, AVLTreeNode.keys] := Mask[r#60, AVLTreeNode.keys][perm$R := Mask[r#60, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1117[r#60, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1117, Mask);
  assert {:msg "  869.11: Receiver might be null."} true ==> (r#60 != null);
  assert {:msg "  869.11: Location might not be readable."} true ==> CanRead(Mask, r#60, AVLTreeNode.keys);
  assert {:msg "  869.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  869.26: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  869.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  869.51: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  869.51: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  869.51: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys);
  }
  assert {:msg "  869.71: Receiver might be null."} true ==> (this != null);
  assert {:msg "  869.71: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.key);
  assert {:msg "  869.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  869.84: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  869.84: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  869.84: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys);
  assume Seq#Equal(Heap[r#60, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#60: ref where (r#60 == null) || (dtype(r#60) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1118: HeapType;
  var exhaleMask#_1119: MaskType;
  var fraction#_1120: int;
  var inhaleHeap#_1121: HeapType;
  var this#426: ref where (this#426 == null) || (dtype(this#426) == AVLTreeNode#t);
  var callHeap#_1122: HeapType;
  var callMask#_1123: MaskType;
  var callCredits#_1124: CreditsType;
  var exhaleMask#_1125: MaskType;
  var fraction#_1126: int;
  var fraction#_1127: int;
  var fraction#_1128: int;
  var fraction#_1129: int;
  var fraction#_1130: int;
  var fraction#_1131: int;
  var fraction#_1132: int;
  var fraction#_1133: int;
  var isHeld#_1134: int;
  var isRdHeld#_1135: bool;
  var inhaleHeap#_1136: HeapType;
  var this#429: ref where (this#429 == null) || (dtype(this#429) == AVLTreeNode#t);
  var callHeap#_1137: HeapType;
  var callMask#_1138: MaskType;
  var callCredits#_1139: CreditsType;
  var exhaleMask#_1140: MaskType;
  var fraction#_1141: int;
  var fraction#_1142: int;
  var fraction#_1143: int;
  var fraction#_1144: int;
  var fraction#_1145: int;
  var fraction#_1146: int;
  var fraction#_1147: int;
  var fraction#_1148: int;
  var isHeld#_1149: int;
  var isRdHeld#_1150: bool;
  var inhaleHeap#_1151: HeapType;
  var exhaleMask#_1152: MaskType;
  var fraction#_1153: int;
  var fraction#_1154: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1118;
  assume IsGoodInhaleState(inhaleHeap#_1118, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1118[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1118[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1118[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.keys] := inhaleHeap#_1118[this, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.keys] := Mask[this, AVLTreeNode.keys][perm$R := Mask[this, AVLTreeNode.keys][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[this, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1118[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1118[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1118[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1118, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1118[Heap[this, AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1118[Heap[this, AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1118, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume (forall k#99#422: int :: (0 <= k#99#422) && (k#99#422 < Seq#Length(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.keys], k#99#422) < Heap[this, AVLTreeNode.key]));
  } else {
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1118[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1118[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1118[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  assume (forall k#100#423: int :: (0 <= k#100#423) && (k#100#423 < Seq#Length(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this, AVLTreeNode.key] < Seq#Index(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], k#100#423)));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  871.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  871.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  871.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  exhaleMask#_1119 := Mask;
  fraction#_1120 := 100;
  assert {:msg "  871.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1120 <= exhaleMask#_1119[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1120 == exhaleMask#_1119[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1119[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  exhaleMask#_1119[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1119[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1119[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1120];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1119);
  Mask := exhaleMask#_1119;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1121 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1121, Heap, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1121, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1121, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1121, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1121[Heap[this, AVLTreeNode.right], AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1121, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1121, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1121, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume (forall lk#67#424: int :: (0 <= lk#67#424) && (lk#67#424 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], lk#67#424) < Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1121, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1121[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1121, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume (forall rk#68#425: int :: (0 <= rk#68#425) && (rk#68#425 < Seq#Length(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] < Seq#Index(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], rk#68#425)));
  } else {
  }
  assume Seq#Equal(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Seq#Append(Seq#Append(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, Seq#Empty(), Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys])));
  assume Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume (forall kk#69: int :: Seq#Contains(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.keys], kk#69) <==> ((((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.keys], kk#69)) || ((!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) && Seq#Contains(Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.keys], kk#69))) || (kk#69 == Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  872.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  872.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  r#60 := Heap[this, AVLTreeNode.right];
  // update field right
  assert {:msg "  873.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  873.15: Receiver might be null."} true ==> (r#60 != null);
  assert {:msg "  873.15: Location might not be readable."} true ==> CanRead(Mask, r#60, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#60, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1122 := Heap;
  callMask#_1123 := Mask;
  callCredits#_1124 := Credits;
  assert {:msg "  874.3: The target of the method call might be null."} this != null;
  this#426 := this;
  // begin exhale (precondition)
  exhaleMask#_1125 := Mask;
  fraction#_1126 := 100;
  assert {:msg "  874.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1126 <= exhaleMask#_1125[this#426, AVLTreeNode.key][perm$R]) && ((fraction#_1126 == exhaleMask#_1125[this#426, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1125[this#426, AVLTreeNode.key][perm$N]));
  exhaleMask#_1125[this#426, AVLTreeNode.key] := exhaleMask#_1125[this#426, AVLTreeNode.key][perm$R := exhaleMask#_1125[this#426, AVLTreeNode.key][perm$R] - fraction#_1126];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1125);
  fraction#_1127 := 100;
  assert {:msg "  874.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1127 <= exhaleMask#_1125[this#426, AVLTreeNode.left][perm$R]) && ((fraction#_1127 == exhaleMask#_1125[this#426, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1125[this#426, AVLTreeNode.left][perm$N]));
  exhaleMask#_1125[this#426, AVLTreeNode.left] := exhaleMask#_1125[this#426, AVLTreeNode.left][perm$R := exhaleMask#_1125[this#426, AVLTreeNode.left][perm$R] - fraction#_1127];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1125);
  fraction#_1128 := 100;
  assert {:msg "  874.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1128 <= exhaleMask#_1125[this#426, AVLTreeNode.right][perm$R]) && ((fraction#_1128 == exhaleMask#_1125[this#426, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1125[this#426, AVLTreeNode.right][perm$N]));
  exhaleMask#_1125[this#426, AVLTreeNode.right] := exhaleMask#_1125[this#426, AVLTreeNode.right][perm$R := exhaleMask#_1125[this#426, AVLTreeNode.right][perm$R] - fraction#_1128];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1125);
  fraction#_1129 := 100;
  assert {:msg "  874.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_1129 <= exhaleMask#_1125[this#426, AVLTreeNode.keys][perm$R]) && ((fraction#_1129 == exhaleMask#_1125[this#426, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1125[this#426, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1125[this#426, AVLTreeNode.keys] := exhaleMask#_1125[this#426, AVLTreeNode.keys][perm$R := exhaleMask#_1125[this#426, AVLTreeNode.keys][perm$R] - fraction#_1129];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1125);
  if (!(Heap[this#426, AVLTreeNode.left] == null)) {
    fraction#_1130 := 100;
    assert {:msg "  874.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1130 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1130 == exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1130];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1125);
  } else {
  }
  if (!(Heap[this#426, AVLTreeNode.left] == null)) {
    fraction#_1131 := 50;
    assert {:msg "  874.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_1131 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_1131 == exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1125[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_1131];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1125);
  } else {
  }
  if (!(Heap[this#426, AVLTreeNode.left] == null)) {
    assert {:msg "  874.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#427: int :: (0 <= k#79#427) && (k#79#427 < Seq#Length(Heap[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#426, AVLTreeNode.left], AVLTreeNode.keys], k#79#427) < Heap[this#426, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#426, AVLTreeNode.right] == null)) {
    fraction#_1132 := 100;
    assert {:msg "  874.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1132 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1132 == exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1132];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1125);
  } else {
  }
  if (!(Heap[this#426, AVLTreeNode.right] == null)) {
    fraction#_1133 := 50;
    assert {:msg "  874.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_1133 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_1133 == exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1125[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_1133];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1125);
  } else {
  }
  if (!(Heap[this#426, AVLTreeNode.right] == null)) {
    assert {:msg "  874.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#428: int :: (0 <= k#80#428) && (k#80#428 < Seq#Length(Heap[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#426, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#426, AVLTreeNode.right], AVLTreeNode.keys], k#80#428)));
  } else {
  }
  Mask := exhaleMask#_1125;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1136;
  assume IsGoodInhaleState(inhaleHeap#_1136, Heap, Mask);
  assume this#426 != null;
  Heap[this#426, AVLTreeNode.valid] := inhaleHeap#_1136[this#426, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1136[this#426, AVLTreeNode.valid] == Heap;
  Mask[this#426, AVLTreeNode.valid] := Mask[this#426, AVLTreeNode.valid][perm$R := Mask[this#426, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1136[this#426, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1136, Mask);
  assume this#426 != null;
  Heap[this#426, AVLTreeNode.keys] := inhaleHeap#_1136[this#426, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#426, AVLTreeNode.keys] := Mask[this#426, AVLTreeNode.keys][perm$R := Mask[this#426, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1136[this#426, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1136, Mask);
  assume Seq#Equal(Heap[this#426, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1122[this#426, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1122[callHeap#_1122[this#426, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1122[this#426, AVLTreeNode.key])), ite(callHeap#_1122[this#426, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1122[callHeap#_1122[this#426, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  875.3: Location might not be writable"} CanWrite(Mask, r#60, AVLTreeNode.left);
  Heap[r#60, AVLTreeNode.left] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_1137 := Heap;
  callMask#_1138 := Mask;
  callCredits#_1139 := Credits;
  assert {:msg "  876.3: The target of the method call might be null."} r#60 != null;
  this#429 := r#60;
  // begin exhale (precondition)
  exhaleMask#_1140 := Mask;
  fraction#_1141 := 100;
  assert {:msg "  876.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1141 <= exhaleMask#_1140[this#429, AVLTreeNode.key][perm$R]) && ((fraction#_1141 == exhaleMask#_1140[this#429, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1140[this#429, AVLTreeNode.key][perm$N]));
  exhaleMask#_1140[this#429, AVLTreeNode.key] := exhaleMask#_1140[this#429, AVLTreeNode.key][perm$R := exhaleMask#_1140[this#429, AVLTreeNode.key][perm$R] - fraction#_1141];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  fraction#_1142 := 100;
  assert {:msg "  876.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1142 <= exhaleMask#_1140[this#429, AVLTreeNode.left][perm$R]) && ((fraction#_1142 == exhaleMask#_1140[this#429, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1140[this#429, AVLTreeNode.left][perm$N]));
  exhaleMask#_1140[this#429, AVLTreeNode.left] := exhaleMask#_1140[this#429, AVLTreeNode.left][perm$R := exhaleMask#_1140[this#429, AVLTreeNode.left][perm$R] - fraction#_1142];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  fraction#_1143 := 100;
  assert {:msg "  876.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1143 <= exhaleMask#_1140[this#429, AVLTreeNode.right][perm$R]) && ((fraction#_1143 == exhaleMask#_1140[this#429, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1140[this#429, AVLTreeNode.right][perm$N]));
  exhaleMask#_1140[this#429, AVLTreeNode.right] := exhaleMask#_1140[this#429, AVLTreeNode.right][perm$R := exhaleMask#_1140[this#429, AVLTreeNode.right][perm$R] - fraction#_1143];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  fraction#_1144 := 100;
  assert {:msg "  876.3: The precondition at 547.12 might not hold. Insufficient fraction at 547.12 for AVLTreeNode.keys."} (fraction#_1144 <= exhaleMask#_1140[this#429, AVLTreeNode.keys][perm$R]) && ((fraction#_1144 == exhaleMask#_1140[this#429, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1140[this#429, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1140[this#429, AVLTreeNode.keys] := exhaleMask#_1140[this#429, AVLTreeNode.keys][perm$R := exhaleMask#_1140[this#429, AVLTreeNode.keys][perm$R] - fraction#_1144];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  if (!(Heap[this#429, AVLTreeNode.left] == null)) {
    fraction#_1145 := 100;
    assert {:msg "  876.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1145 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1145 == exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1145];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1140);
  } else {
  }
  if (!(Heap[this#429, AVLTreeNode.left] == null)) {
    fraction#_1146 := 50;
    assert {:msg "  876.3: The precondition at 552.12 might not hold. Insufficient fraction at 552.27 for AVLTreeNode.keys."} (fraction#_1146 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) && ((fraction#_1146 == exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys] := exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys][perm$R := exhaleMask#_1140[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys][perm$R] - fraction#_1146];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1140);
  } else {
  }
  if (!(Heap[this#429, AVLTreeNode.left] == null)) {
    assert {:msg "  876.3: The precondition at 554.12 might not hold. The expression at 554.27 might not evaluate to true."} (forall k#79#430: int :: (0 <= k#79#430) && (k#79#430 < Seq#Length(Heap[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys])) ==> (Seq#Index(Heap[Heap[this#429, AVLTreeNode.left], AVLTreeNode.keys], k#79#430) < Heap[this#429, AVLTreeNode.key]));
  } else {
  }
  if (!(Heap[this#429, AVLTreeNode.right] == null)) {
    fraction#_1147 := 100;
    assert {:msg "  876.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1147 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1147 == exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1147];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1140);
  } else {
  }
  if (!(Heap[this#429, AVLTreeNode.right] == null)) {
    fraction#_1148 := 50;
    assert {:msg "  876.3: The precondition at 558.12 might not hold. Insufficient fraction at 558.28 for AVLTreeNode.keys."} (fraction#_1148 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) && ((fraction#_1148 == exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys][perm$N]));
    exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys] := exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys][perm$R := exhaleMask#_1140[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys][perm$R] - fraction#_1148];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1140);
  } else {
  }
  if (!(Heap[this#429, AVLTreeNode.right] == null)) {
    assert {:msg "  876.3: The precondition at 560.12 might not hold. The expression at 560.28 might not evaluate to true."} (forall k#80#431: int :: (0 <= k#80#431) && (k#80#431 < Seq#Length(Heap[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys])) ==> (Heap[this#429, AVLTreeNode.key] < Seq#Index(Heap[Heap[this#429, AVLTreeNode.right], AVLTreeNode.keys], k#80#431)));
  } else {
  }
  Mask := exhaleMask#_1140;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1151;
  assume IsGoodInhaleState(inhaleHeap#_1151, Heap, Mask);
  assume this#429 != null;
  Heap[this#429, AVLTreeNode.valid] := inhaleHeap#_1151[this#429, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1151[this#429, AVLTreeNode.valid] == Heap;
  Mask[this#429, AVLTreeNode.valid] := Mask[this#429, AVLTreeNode.valid][perm$R := Mask[this#429, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1151[this#429, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1151, Mask);
  assume this#429 != null;
  Heap[this#429, AVLTreeNode.keys] := inhaleHeap#_1151[this#429, AVLTreeNode.keys];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#429, AVLTreeNode.keys] := Mask[this#429, AVLTreeNode.keys][perm$R := Mask[this#429, AVLTreeNode.keys][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1151[this#429, AVLTreeNode.keys]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1151, Mask);
  assume Seq#Equal(Heap[this#429, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(callHeap#_1137[this#429, AVLTreeNode.left] == null, Seq#Empty(), callHeap#_1137[callHeap#_1137[this#429, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(callHeap#_1137[this#429, AVLTreeNode.key])), ite(callHeap#_1137[this#429, AVLTreeNode.right] == null, Seq#Empty(), callHeap#_1137[callHeap#_1137[this#429, AVLTreeNode.right], AVLTreeNode.keys])));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1152 := Mask;
  fraction#_1153 := 100;
  assert {:msg "  838.2: The postcondition at 863.11 might not hold. Insufficient fraction at 863.11 for AVLTreeNode.valid."} (fraction#_1153 <= exhaleMask#_1152[r#60, AVLTreeNode.valid][perm$R]) && ((fraction#_1153 == exhaleMask#_1152[r#60, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1152[r#60, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1152[r#60, AVLTreeNode.valid] := exhaleMask#_1152[r#60, AVLTreeNode.valid][perm$R := exhaleMask#_1152[r#60, AVLTreeNode.valid][perm$R] - fraction#_1153];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1152);
  fraction#_1154 := 50;
  assert {:msg "  838.2: The postcondition at 865.11 might not hold. Insufficient fraction at 865.11 for AVLTreeNode.keys."} (fraction#_1154 <= exhaleMask#_1152[r#60, AVLTreeNode.keys][perm$R]) && ((fraction#_1154 == exhaleMask#_1152[r#60, AVLTreeNode.keys][perm$R]) ==> (0 <= exhaleMask#_1152[r#60, AVLTreeNode.keys][perm$N]));
  exhaleMask#_1152[r#60, AVLTreeNode.keys] := exhaleMask#_1152[r#60, AVLTreeNode.keys][perm$R := exhaleMask#_1152[r#60, AVLTreeNode.keys][perm$R] - fraction#_1154];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1152);
  assert {:msg "  838.2: The postcondition at 869.11 might not hold. The expression at 869.11 might not evaluate to true."} Seq#Equal(Heap[r#60, AVLTreeNode.keys], Seq#Append(Seq#Append(ite(old(Heap)[this, AVLTreeNode.left] == null, Seq#Empty(), old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.keys]), Seq#Singleton(old(Heap)[this, AVLTreeNode.key])), old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.keys]));
  Mask := exhaleMask#_1152;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  838.2: Method might lock/unlock more than allowed."} (forall lk#_1155: ref :: {Heap[lk#_1155, held]} {Heap[lk#_1155, rdheld]} (((0 < Heap[lk#_1155, held]) == (0 < old(Heap)[lk#_1155, held])) && (Heap[lk#_1155, rdheld] == old(Heap)[lk#_1155, rdheld])) || false);
  assert {:msg "  838.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
