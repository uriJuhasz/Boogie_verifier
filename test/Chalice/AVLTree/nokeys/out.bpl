// Copyright (c) 2008, Microsoft
type Field a;
type HeapType = <a>[ref,Field a]a;
type MaskType = <a>[ref,Field a][PermissionComponent]int;
type CreditsType = [ref]int;
type ref;
const null: ref;

var Heap: HeapType;

type PermissionComponent;
const unique perm$R: PermissionComponent;
const unique perm$N: PermissionComponent;
const Permission$MinusInfinity: int;
axiom Permission$MinusInfinity < -10000;
const Permission$PlusInfinity: int;
axiom 10000 < Permission$PlusInfinity;
var Mask: MaskType where IsGoodMask(Mask);
const Permission$Zero: [PermissionComponent]int;
axiom Permission$Zero[perm$R] == 0 && Permission$Zero[perm$N] == 0;
const Permission$Full: [PermissionComponent]int;
axiom Permission$Full[perm$R] == 100 && Permission$Full[perm$N] == 0;
const ZeroMask: MaskType;
axiom (forall<T> o: ref, f: Field T, pc: PermissionComponent :: ZeroMask[o,f][pc] == 0);
axiom IsGoodMask(ZeroMask);
function {:expand false} CanRead<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  0 < m[obj,f][perm$R] || 0 < m[obj,f][perm$N]
}
function {:expand false} CanWrite<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  m[obj,f][perm$R] == 100 && m[obj,f][perm$N] == 0
}
function {:expand true} IsGoodMask(m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T ::
      0 <= m[o,f][perm$R] && 
      (NonPredicateField(f) ==> 
        (m[o,f][perm$R]<=100 &&
        (0 < m[o,f][perm$N] ==> m[o,f][perm$R] < 100))) &&
      (m[o,f][perm$N] < 0 ==> 0 < m[o,f][perm$R]))
}

var Credits: CreditsType;

function IsGoodState<T>(T) returns (bool);
function combine<T,U>(T, U) returns (T);
const nostate: HeapType;

axiom (forall<T,U> a: T, b: U :: {IsGoodState(combine(a, b))} IsGoodState(combine(a, b)) <==> IsGoodState(a) && IsGoodState(b));
axiom IsGoodState(nostate);

type ModuleName;
const CurrentModule: ModuleName;
type TypeName;
function dtype(ref) returns (TypeName);
const CanAssumeFunctionDefs: bool;

type Mu;
const unique mu: Field Mu;
axiom NonPredicateField(mu);
function MuBelow(Mu, Mu) returns (bool);  // strict partial order
axiom (forall m: Mu, n: Mu ::
  { MuBelow(m,n), MuBelow(n,m) }
  !(MuBelow(m,n) && MuBelow(n,m)));
axiom (forall m: Mu, n: Mu, o: Mu ::
  { MuBelow(m,n), MuBelow(n,o) }
  MuBelow(m,n) && MuBelow(n,o) ==> MuBelow(m,o));
const $LockBottom: Mu;
axiom (forall m, n: Mu :: MuBelow(m, n) ==> n != $LockBottom);

const unique held: Field int;
function Acquire$Heap(int) returns (HeapType);
function Acquire$Mask(int) returns (MaskType);
function Acquire$Credits(int) returns (CreditsType);
axiom NonPredicateField(held);

function LastSeen$Heap(Mu, int) returns (HeapType);
function LastSeen$Mask(Mu, int) returns (MaskType);
function LastSeen$Credits(Mu, int) returns (CreditsType);

const unique rdheld: Field bool;
axiom NonPredicateField(rdheld);
function wf(h: HeapType, m: MaskType) returns (bool);

function IsGoodInhaleState(ih: HeapType, h: HeapType,
                           m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { ih[o, f] }  CanRead(m, o, f) ==> ih[o, f] == h[o, f]) &&
  (forall o: ref :: { ih[o, held] }  (0<ih[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { ih[o, rdheld] }  ih[o, rdheld] == h[o, rdheld]) &&
  (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> ih[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, rdheld] }  h[o, rdheld] ==> ih[o, mu] == h[o, mu])
}

// ---------------------------------------------------------------
// -- If then else -----------------------------------------------
// ---------------------------------------------------------------

function ite<T>(bool, T, T) returns (T);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} con ==> ite(con, a, b) == a);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} ! con ==> ite(con, a, b) == b);

// ---------------------------------------------------------------
// -- Axiomatization of sequences --------------------------------
// ---------------------------------------------------------------

type Seq T;

function Seq#Length<T>(Seq T) returns (int);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } 0 <= Seq#Length(s));

function Seq#Empty<T>() returns (Seq T);
axiom (forall<T> :: Seq#Length(Seq#Empty(): Seq T) == 0);
axiom (forall<T> s: Seq T :: { Seq#Length(s) } Seq#Length(s) == 0 ==> s == Seq#Empty());

function Seq#Singleton<T>(T) returns (Seq T);
axiom (forall<T> t: T :: { Seq#Length(Seq#Singleton(t)) } Seq#Length(Seq#Singleton(t)) == 1);

function Seq#Build<T>(s: Seq T, index: int, val: T, newLength: int) returns (Seq T);
axiom (forall<T> s: Seq T, i: int, v: T, len: int :: { Seq#Length(Seq#Build(s,i,v,len)) }
  0 <= len ==> Seq#Length(Seq#Build(s,i,v,len)) == len);

function Seq#Append<T>(Seq T, Seq T) returns (Seq T);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Length(Seq#Append(s0,s1)) }
  Seq#Length(Seq#Append(s0,s1)) == Seq#Length(s0) + Seq#Length(s1));

function Seq#Index<T>(Seq T, int) returns (T);
axiom (forall<T> t: T :: { Seq#Index(Seq#Singleton(t), 0) } Seq#Index(Seq#Singleton(t), 0) == t);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#Index(Seq#Append(s0,s1), n) }
  (n < Seq#Length(s0) ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s0, n)) &&
  (Seq#Length(s0) <= n ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s1, n - Seq#Length(s0))));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, n: int :: { Seq#Index(Seq#Build(s,i,v,len),n) }
  0 <= n && n < len ==>
    (i == n ==> Seq#Index(Seq#Build(s,i,v,len),n) == v) &&
    (i != n ==> Seq#Index(Seq#Build(s,i,v,len),n) == Seq#Index(s,n)));

function Seq#Contains<T>(Seq T, T) returns (bool);
axiom (forall<T> s: Seq T, x: T :: { Seq#Contains(s,x) }
  Seq#Contains(s,x) <==>
    (exists i: int :: { Seq#Index(s,i) } 0 <= i && i < Seq#Length(s) && Seq#Index(s,i) == x));
axiom (forall x: ref ::
  { Seq#Contains(Seq#Empty(), x) }
  !Seq#Contains(Seq#Empty(), x));
axiom (forall<T> s0: Seq T, s1: Seq T, x: T ::
  { Seq#Contains(Seq#Append(s0, s1), x) }
  Seq#Contains(Seq#Append(s0, s1), x) <==>
    Seq#Contains(s0, x) || Seq#Contains(s1, x));
axiom (forall<T> s: Seq T, i: int, v: T, len: int, x: T ::
  { Seq#Contains(Seq#Build(s, i, v, len), x) }
  Seq#Contains(Seq#Build(s, i, v, len), x) <==>
    (0 <= i && i < len && x == v)  ||  
    (exists j: int :: { Seq#Index(s,j) } 0 <= j && j < Seq#Length(s) && j < len && j!=i && Seq#Index(s,j) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Take(s, n), x) }
  Seq#Contains(Seq#Take(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= i && i < n && i < Seq#Length(s) && Seq#Index(s, i) == x));
axiom (forall<T> s: Seq T, n: int, x: T ::
  { Seq#Contains(Seq#Drop(s, n), x) }
  Seq#Contains(Seq#Drop(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= n && n <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

function Seq#Equal<T>(Seq T, Seq T) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Equal(s0,s1) }
  Seq#Equal(s0,s1) <==>
    Seq#Length(s0) == Seq#Length(s1) &&
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < Seq#Length(s0) ==> Seq#Index(s0,j) == Seq#Index(s1,j)));
axiom(forall<T> a: Seq T, b: Seq T :: { Seq#Equal(a,b) }  // extensionality axiom for sequences
  Seq#Equal(a,b) ==> a == b);

function Seq#SameUntil<T>(Seq T, Seq T, int) returns (bool);
axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#SameUntil(s0,s1,n) }
  Seq#SameUntil(s0,s1,n) <==>
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < n ==> Seq#Index(s0,j) == Seq#Index(s1,j)));

function Seq#Take<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Take(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Take(s,n)) == n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Take(s,n)) == Seq#Length(s)));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Take(s,n), j) } {:weight 25}
  0 <= j && j < n && j < Seq#Length(s) ==>
    Seq#Index(Seq#Take(s,n), j) == Seq#Index(s, j));

function Seq#Drop<T>(s: Seq T, howMany: int) returns (Seq T);
axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Drop(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Drop(s,n)) == Seq#Length(s) - n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Drop(s,n)) == 0));
axiom (forall<T> s: Seq T, n: int, j: int :: { Seq#Index(Seq#Drop(s,n), j) } {:weight 25}
  0 <= n && 0 <= j && j < Seq#Length(s)-n ==>
    Seq#Index(Seq#Drop(s,n), j) == Seq#Index(s, j+n));

axiom (forall<T> s, t: Seq T ::
  { Seq#Append(s, t) }
  Seq#Take(Seq#Append(s, t), Seq#Length(s)) == s &&
  Seq#Drop(Seq#Append(s, t), Seq#Length(s)) == t);

function Seq#Range(min: int, max: int) returns (Seq int);

axiom (forall min: int, max: int :: { Seq#Length(Seq#Range(min, max)) } (min < max ==> Seq#Length(Seq#Range(min, max)) == max-min) && (max <= min ==> Seq#Length(Seq#Range(min, max)) == 0));
axiom (forall min: int, max: int, j: int :: { Seq#Index(Seq#Range(min, max), j) } 0<=j && j<max-min ==> Seq#Index(Seq#Range(min, max), j) == min + j);

//urij

axiom (forall<T> x, y: T ::
  { Seq#Contains(Seq#Singleton(x),y) }
    Seq#Contains(Seq#Singleton(x),y) ==> x==y
);

axiom (forall<T> x: T ::
  { Seq#Contains(Seq#Singleton(x),x) }
    Seq#Contains(Seq#Singleton(x),x)
);

//-urij

// ---------------------------------------------------------------
// -- Permissions ------------------------------------------------
// ---------------------------------------------------------------

axiom (forall h: HeapType, m: MaskType, o: ref, q: ref :: {wf(h, m), h[o, mu], h[q, mu]} wf(h, m) && o!=q && (0 < h[o, held] || h[o, rdheld]) && (0 < h[q, held] || h[q, rdheld]) ==> h[o, mu] != h[q, mu]);

function DecPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$R]}
      DecPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] - howMuch, m[q, g][perm$R])
);

function DecEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$N]}
         DecEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] - howMuch, m[q, g][perm$N])
);

function IncPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$R]}
         IncPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] + howMuch, m[q, g][perm$R])
);

function IncEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$N]}
         IncEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] + howMuch, m[q, g][perm$N])
);

function Havocing<T,U>(h: HeapType, o: ref, f: Field T, newValue: U) returns (HeapType);

axiom (forall<T,U> h: HeapType, o: ref, f: Field T, newValue: U, q: ref, g: Field U :: {Havocing(h, o, f, newValue)[q, g]}
         Havocing(h, o, f, newValue)[q, g] == ite(o==q && f ==g, newValue, h[q, g])
);

const unique joinable: Field int;
axiom NonPredicateField(joinable);
const unique token#t: TypeName;

function Call$Heap(int) returns (HeapType);
function Call$Mask(int) returns (MaskType);
function Call$Credits(int) returns (CreditsType);
function Call$Args(int) returns (ArgSeq);
type ArgSeq = <T>[int]T;

function EmptyMask(m: MaskType) returns (bool);
axiom (forall m: MaskType :: {EmptyMask(m)} EmptyMask(m) <==> (forall<T> o: ref, f: Field T :: NonPredicateField(f) ==> m[o, f][perm$R]<=0 && m[o, f][perm$N]<=0));

const ZeroCredits: CreditsType;
axiom (forall o: ref :: ZeroCredits[o] == 0);
function EmptyCredits(c: CreditsType) returns (bool);
axiom (forall c: CreditsType :: {EmptyCredits(c)} EmptyCredits(c) <==> (forall o: ref :: o != null ==> c[o] == 0));

function NonPredicateField<T>(f: Field T) returns (bool);
function PredicateField<T>(f: Field T) returns (bool);
axiom (forall<T> f: Field T :: NonPredicateField(f) ==> ! PredicateField(f));
axiom (forall<T> f: Field T :: PredicateField(f) ==> ! NonPredicateField(f));

function submask(m1: MaskType, m2: MaskType) returns (bool);

axiom (forall m1: MaskType, m2: MaskType :: {submask(m1, m2)}
  submask(m1, m2) <==> (forall<T> o: ref, f: Field T :: (m1[o, f][perm$R] < m2[o, f][perm$R]) || (m1[o, f][perm$R] == m2[o, f][perm$R] && m1[o, f][perm$N] <= m2[o, f][perm$N]))
);

// ---------------------------------------------------------------
// -- Arithmetic -------------------------------------------------
// ---------------------------------------------------------------

// the connection between % and /
axiom (forall x:int, y:int :: {x % y} {x / y}  x % y == x - x / y * y);

// sign of denominator determines sign of remainder
axiom (forall x:int, y:int :: {x % y}  0 < y  ==>  0 <= x % y  &&  x % y < y);
axiom (forall x:int, y:int :: {x % y}  y < 0  ==>  y < x % y  &&  x % y <= 0);

// the following axiom has some unfortunate matching, but it does state a property about % that
// is sometime useful
axiom (forall a: int, b: int, d: int :: { a % d, b % d } 2 <= d && a % d == b % d && a < b  ==>  a + d <= b);

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------
const unique AVLTree#t: TypeName;
const unique module#default: ModuleName;
procedure AVLTree$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var h0#_0: HeapType;
  var m0#_1: MaskType;
  var c0#_2: CreditsType;
  var h1#_3: HeapType;
  var m1#_4: MaskType;
  var c1#_5: CreditsType;
  var lk#_6: ref;
  assume wf(h0#_0, m0#_1);
  assume wf(h1#_3, m1#_4);
  m1#_4 := ZeroMask;
  c1#_5 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  3.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTree.root: Field (ref);
axiom NonPredicateField(AVLTree.root);
const unique AVLTree.valid: Field (HeapType);
axiom PredicateField(AVLTree.valid);
procedure AVLTree.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_7: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_7;
  assume IsGoodInhaleState(inhaleHeap#_7, Heap, Mask);
  assert {:msg "  10.15: Fraction might be negative."} 0 <= 100;
  assert {:msg "  10.15: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_7[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_7[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_7, Mask);
  assert {:msg "  12.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  12.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  12.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  12.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_7, Mask);
  } else {
  }
  assert {:msg "  13.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  13.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  13.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  13.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  13.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  13.45: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.height] := inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_7, Mask);
  } else {
  }
  assert {:msg "  15.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  15.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (!(Heap[this, AVLTree.root] == null)) {
    assert {:msg "  15.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  15.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  15.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  15.45: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_7[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_7, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_8: HeapType;
  var inhaleHeap#_9: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_8;
  assume IsGoodInhaleState(inhaleHeap#_8, Heap, Mask);
  assert {:msg "  22.21: Fraction might be negative."} 0 <= 100;
  assert {:msg "  22.21: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_8[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_8[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_8, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_9;
  assume IsGoodInhaleState(inhaleHeap#_9, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_9[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_9[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_9[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_9, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.init(this: ref where (this == null) || (dtype(this) == AVLTree#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_10: HeapType;
  var exhaleMask#_11: MaskType;
  var fraction#_12: int;
  var fraction#_13: int;
  var fraction#_14: int;
  var fraction#_15: int;
  var inhaleHeap#_16: HeapType;
  var exhaleMask#_17: MaskType;
  var fraction#_18: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_10;
  assume IsGoodInhaleState(inhaleHeap#_10, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_10[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_10[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_10, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field root
  assert {:msg "  29.3: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
  Heap[this, AVLTree.root] := null;
  assume wf(Heap, Mask);
  // fold
  assert {:msg "  31.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_11 := Mask;
  fraction#_12 := 100;
  assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_12 <= exhaleMask#_11[this, AVLTree.root][perm$R]) && ((fraction#_12 == exhaleMask#_11[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_11[this, AVLTree.root][perm$N]));
  exhaleMask#_11[this, AVLTree.root] := exhaleMask#_11[this, AVLTree.root][perm$R := exhaleMask#_11[this, AVLTree.root][perm$R] - fraction#_12];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_11);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_13 := 100;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_13 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_13 == exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_13];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_11);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_14 := 50;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (fraction#_14 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((fraction#_14 == exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - fraction#_14];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_11);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_15 := 50;
    assert {:msg "  31.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (fraction#_15 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_15 == exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_11[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - fraction#_15];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_11);
  } else {
  }
  Mask := exhaleMask#_11;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_16;
  assume IsGoodInhaleState(inhaleHeap#_16, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_16[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_16[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_16[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_16, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_17 := Mask;
  fraction#_18 := 100;
  assert {:msg "  21.2: The postcondition at 25.11 might not hold. Insufficient fraction at 25.11 for AVLTree.valid."} (fraction#_18 <= exhaleMask#_17[this, AVLTree.valid][perm$R]) && ((fraction#_18 == exhaleMask#_17[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_17[this, AVLTree.valid][perm$N]));
  exhaleMask#_17[this, AVLTree.valid] := exhaleMask#_17[this, AVLTree.valid][perm$R := exhaleMask#_17[this, AVLTree.valid][perm$R] - fraction#_18];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_17);
  Mask := exhaleMask#_17;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  21.2: Method might lock/unlock more than allowed."} (forall lk#_19: ref :: {Heap[lk#_19, held]} {Heap[lk#_19, rdheld]} (((0 < Heap[lk#_19, held]) == (0 < old(Heap)[lk#_19, held])) && (Heap[lk#_19, rdheld] == old(Heap)[lk#_19, rdheld])) || false);
  assert {:msg "  21.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_20: HeapType;
  var inhaleHeap#_21: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_20;
  assume IsGoodInhaleState(inhaleHeap#_20, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_20[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_20[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_20[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_20, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_21;
  assume IsGoodInhaleState(inhaleHeap#_21, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_21[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_21[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_21[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_21, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.insert(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#0: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_22: HeapType;
  var exhaleMask#_23: MaskType;
  var fraction#_24: int;
  var inhaleHeap#_25: HeapType;
  var n#2: ref where (n#2 == null) || (dtype(n#2) == AVLTreeNode#t);
  var nw#_26: ref;
  var this#75: ref where (this#75 == null) || (dtype(this#75) == AVLTreeNode#t);
  var k#76: int where true;
  var callHeap#_27: HeapType;
  var callMask#_28: MaskType;
  var callCredits#_29: CreditsType;
  var exhaleMask#_30: MaskType;
  var fraction#_31: int;
  var fraction#_32: int;
  var fraction#_33: int;
  var fraction#_34: int;
  var fraction#_35: int;
  var isHeld#_36: int;
  var isRdHeld#_37: bool;
  var inhaleHeap#_38: HeapType;
  var this#77: ref where (this#77 == null) || (dtype(this#77) == AVLTreeNode#t);
  var k#78: int where true;
  var r#79: ref where (r#79 == null) || (dtype(r#79) == AVLTreeNode#t);
  var callHeap#_39: HeapType;
  var callMask#_40: MaskType;
  var callCredits#_41: CreditsType;
  var exhaleMask#_42: MaskType;
  var fraction#_43: int;
  var fraction#_44: int;
  var fraction#_45: int;
  var isHeld#_46: int;
  var isRdHeld#_47: bool;
  var inhaleHeap#_48: HeapType;
  var r#73: ref where (r#73 == null) || (dtype(r#73) == AVLTreeNode#t);
  var exhaleMask#_49: MaskType;
  var fraction#_50: int;
  var fraction#_51: int;
  var fraction#_52: int;
  var fraction#_53: int;
  var inhaleHeap#_54: HeapType;
  var exhaleMask#_55: MaskType;
  var fraction#_56: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_22;
  assume IsGoodInhaleState(inhaleHeap#_22, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_22[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_22[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_22[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_22, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  46.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_23 := Mask;
  fraction#_24 := 100;
  assert {:msg "  46.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (fraction#_24 <= exhaleMask#_23[this, AVLTree.valid][perm$R]) && ((fraction#_24 == exhaleMask#_23[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_23[this, AVLTree.valid][perm$N]));
  exhaleMask#_23[this, AVLTree.valid] := exhaleMask#_23[this, AVLTree.valid][perm$R := exhaleMask#_23[this, AVLTree.valid][perm$R] - fraction#_24];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_23);
  Mask := exhaleMask#_23;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_25 := Heap[this, AVLTree.valid];
  assume IsGoodInhaleState(inhaleHeap#_25, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_25[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_25[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_25, Mask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_25, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.height] := inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_25, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_25[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_25, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  47.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  47.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    // local var n
    // assigment to n
    // new
    havoc nw#_26;
    assume (nw#_26 != null) && (dtype(nw#_26) == AVLTreeNode#t);
    assume (forall<T#_0> f: Field (T#_0) :: (Mask[nw#_26, f][perm$R] == 0) && (Mask[nw#_26, f][perm$N] == 0));
    assume Heap[nw#_26, mu] == $LockBottom;
    assume Heap[nw#_26, held] <= 0;
    assume Heap[nw#_26, rdheld] == false;
    Mask[nw#_26, AVLTreeNode.key] := Mask[nw#_26, AVLTreeNode.key][perm$R := Mask[nw#_26, AVLTreeNode.key][perm$R] + 100];
    Mask[nw#_26, AVLTreeNode.height] := Mask[nw#_26, AVLTreeNode.height][perm$R := Mask[nw#_26, AVLTreeNode.height][perm$R] + 100];
    Mask[nw#_26, AVLTreeNode.left] := Mask[nw#_26, AVLTreeNode.left][perm$R := Mask[nw#_26, AVLTreeNode.left][perm$R] + 100];
    Mask[nw#_26, AVLTreeNode.right] := Mask[nw#_26, AVLTreeNode.right][perm$R := Mask[nw#_26, AVLTreeNode.right][perm$R] + 100];
    Mask[nw#_26, AVLTreeNode.balanceFactor] := Mask[nw#_26, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_26, AVLTreeNode.balanceFactor][perm$R] + 100];
    Mask[nw#_26, mu] := Mask[nw#_26, mu][perm$R := Mask[nw#_26, mu][perm$R] + 100];
    n#2 := nw#_26;
    // call init
    callHeap#_27 := Heap;
    callMask#_28 := Mask;
    callCredits#_29 := Credits;
    assert {:msg "  49.4: The target of the method call might be null."} n#2 != null;
    this#75 := n#2;
    k#76 := k#0;
    // begin exhale (precondition)
    exhaleMask#_30 := Mask;
    fraction#_31 := 100;
    assert {:msg "  49.4: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (fraction#_31 <= exhaleMask#_30[this#75, AVLTreeNode.key][perm$R]) && ((fraction#_31 == exhaleMask#_30[this#75, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_30[this#75, AVLTreeNode.key][perm$N]));
    exhaleMask#_30[this#75, AVLTreeNode.key] := exhaleMask#_30[this#75, AVLTreeNode.key][perm$R := exhaleMask#_30[this#75, AVLTreeNode.key][perm$R] - fraction#_31];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_30);
    fraction#_32 := 100;
    assert {:msg "  49.4: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} (fraction#_32 <= exhaleMask#_30[this#75, AVLTreeNode.height][perm$R]) && ((fraction#_32 == exhaleMask#_30[this#75, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_30[this#75, AVLTreeNode.height][perm$N]));
    exhaleMask#_30[this#75, AVLTreeNode.height] := exhaleMask#_30[this#75, AVLTreeNode.height][perm$R := exhaleMask#_30[this#75, AVLTreeNode.height][perm$R] - fraction#_32];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_30);
    fraction#_33 := 100;
    assert {:msg "  49.4: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (fraction#_33 <= exhaleMask#_30[this#75, AVLTreeNode.left][perm$R]) && ((fraction#_33 == exhaleMask#_30[this#75, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_30[this#75, AVLTreeNode.left][perm$N]));
    exhaleMask#_30[this#75, AVLTreeNode.left] := exhaleMask#_30[this#75, AVLTreeNode.left][perm$R := exhaleMask#_30[this#75, AVLTreeNode.left][perm$R] - fraction#_33];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_30);
    fraction#_34 := 100;
    assert {:msg "  49.4: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (fraction#_34 <= exhaleMask#_30[this#75, AVLTreeNode.right][perm$R]) && ((fraction#_34 == exhaleMask#_30[this#75, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_30[this#75, AVLTreeNode.right][perm$N]));
    exhaleMask#_30[this#75, AVLTreeNode.right] := exhaleMask#_30[this#75, AVLTreeNode.right][perm$R := exhaleMask#_30[this#75, AVLTreeNode.right][perm$R] - fraction#_34];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_30);
    fraction#_35 := 100;
    assert {:msg "  49.4: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} (fraction#_35 <= exhaleMask#_30[this#75, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_35 == exhaleMask#_30[this#75, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_30[this#75, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_30[this#75, AVLTreeNode.balanceFactor] := exhaleMask#_30[this#75, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_30[this#75, AVLTreeNode.balanceFactor][perm$R] - fraction#_35];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_30);
    Mask := exhaleMask#_30;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_38;
    assume IsGoodInhaleState(inhaleHeap#_38, Heap, Mask);
    assume this#75 != null;
    Heap[this#75, AVLTreeNode.valid] := inhaleHeap#_38[this#75, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_38[this#75, AVLTreeNode.valid] == Heap;
    Mask[this#75, AVLTreeNode.valid] := Mask[this#75, AVLTreeNode.valid][perm$R := Mask[this#75, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_38[this#75, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_38, Mask);
    assume this#75 != null;
    Heap[this#75, AVLTreeNode.height] := inhaleHeap#_38[this#75, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#75, AVLTreeNode.height] := Mask[this#75, AVLTreeNode.height][perm$R := Mask[this#75, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_38[this#75, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_38, Mask);
    assume this#75 != null;
    Heap[this#75, AVLTreeNode.balanceFactor] := inhaleHeap#_38[this#75, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#75, AVLTreeNode.balanceFactor] := Mask[this#75, AVLTreeNode.balanceFactor][perm$R := Mask[this#75, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_38[this#75, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_38, Mask);
    assume Heap[this#75, AVLTreeNode.height] == 1;
    assume Heap[this#75, AVLTreeNode.balanceFactor] == 0;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // update field root
    assert {:msg "  50.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := n#2;
    assume wf(Heap, Mask);
  } else {
    // call insert
    callHeap#_39 := Heap;
    callMask#_40 := Mask;
    callCredits#_41 := Credits;
    assert {:msg "  52.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  52.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  52.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#77 := Heap[this, AVLTree.root];
    k#78 := k#0;
    // begin exhale (precondition)
    exhaleMask#_42 := Mask;
    fraction#_43 := 100;
    assert {:msg "  52.4: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (fraction#_43 <= exhaleMask#_42[this#77, AVLTreeNode.valid][perm$R]) && ((fraction#_43 == exhaleMask#_42[this#77, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_42[this#77, AVLTreeNode.valid][perm$N]));
    exhaleMask#_42[this#77, AVLTreeNode.valid] := exhaleMask#_42[this#77, AVLTreeNode.valid][perm$R := exhaleMask#_42[this#77, AVLTreeNode.valid][perm$R] - fraction#_43];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_42);
    fraction#_44 := 50;
    assert {:msg "  52.4: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} (fraction#_44 <= exhaleMask#_42[this#77, AVLTreeNode.height][perm$R]) && ((fraction#_44 == exhaleMask#_42[this#77, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_42[this#77, AVLTreeNode.height][perm$N]));
    exhaleMask#_42[this#77, AVLTreeNode.height] := exhaleMask#_42[this#77, AVLTreeNode.height][perm$R := exhaleMask#_42[this#77, AVLTreeNode.height][perm$R] - fraction#_44];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_42);
    fraction#_45 := 50;
    assert {:msg "  52.4: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} (fraction#_45 <= exhaleMask#_42[this#77, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_45 == exhaleMask#_42[this#77, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_42[this#77, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_42[this#77, AVLTreeNode.balanceFactor] := exhaleMask#_42[this#77, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_42[this#77, AVLTreeNode.balanceFactor][perm$R] - fraction#_45];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_42);
    Mask := exhaleMask#_42;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#79;
    // inhale (postcondition)
    havoc inhaleHeap#_48;
    assume IsGoodInhaleState(inhaleHeap#_48, Heap, Mask);
    assume !(r#79 == null);
    assume r#79 != null;
    Heap[r#79, AVLTreeNode.valid] := inhaleHeap#_48[r#79, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_48[r#79, AVLTreeNode.valid] == Heap;
    Mask[r#79, AVLTreeNode.valid] := Mask[r#79, AVLTreeNode.valid][perm$R := Mask[r#79, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_48[r#79, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_48, Mask);
    assume r#79 != null;
    Heap[r#79, AVLTreeNode.height] := inhaleHeap#_48[r#79, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#79, AVLTreeNode.height] := Mask[r#79, AVLTreeNode.height][perm$R := Mask[r#79, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_48[r#79, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_48, Mask);
    assume r#79 != null;
    Heap[r#79, AVLTreeNode.balanceFactor] := inhaleHeap#_48[r#79, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#79, AVLTreeNode.balanceFactor] := Mask[r#79, AVLTreeNode.balanceFactor][perm$R := Mask[r#79, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_48[r#79, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_48, Mask);
    assume (Heap[r#79, AVLTreeNode.height] == callHeap#_39[this#77, AVLTreeNode.height]) || (Heap[r#79, AVLTreeNode.height] == (callHeap#_39[this#77, AVLTreeNode.height] + 1));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#73 := r#79;
    // update field root
    assert {:msg "  53.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#73;
    assume wf(Heap, Mask);
  }
  // fold
  assert {:msg "  56.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_49 := Mask;
  fraction#_50 := 100;
  assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_50 <= exhaleMask#_49[this, AVLTree.root][perm$R]) && ((fraction#_50 == exhaleMask#_49[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_49[this, AVLTree.root][perm$N]));
  exhaleMask#_49[this, AVLTree.root] := exhaleMask#_49[this, AVLTree.root][perm$R := exhaleMask#_49[this, AVLTree.root][perm$R] - fraction#_50];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_49);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_51 := 100;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_51 <= exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_51 == exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_51];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_49);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_52 := 50;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (fraction#_52 <= exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((fraction#_52 == exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - fraction#_52];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_49);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_53 := 50;
    assert {:msg "  56.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (fraction#_53 <= exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_53 == exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_49[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - fraction#_53];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_49);
  } else {
  }
  Mask := exhaleMask#_49;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_54;
  assume IsGoodInhaleState(inhaleHeap#_54, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_54[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_54[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_54[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_54, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_55 := Mask;
  fraction#_56 := 100;
  assert {:msg "  35.2: The postcondition at 39.11 might not hold. Insufficient fraction at 39.11 for AVLTree.valid."} (fraction#_56 <= exhaleMask#_55[this, AVLTree.valid][perm$R]) && ((fraction#_56 == exhaleMask#_55[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_55[this, AVLTree.valid][perm$N]));
  exhaleMask#_55[this, AVLTree.valid] := exhaleMask#_55[this, AVLTree.valid][perm$R := exhaleMask#_55[this, AVLTree.valid][perm$R] - fraction#_56];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_55);
  Mask := exhaleMask#_55;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  35.2: Method might lock/unlock more than allowed."} (forall lk#_57: ref :: {Heap[lk#_57, held]} {Heap[lk#_57, rdheld]} (((0 < Heap[lk#_57, held]) == (0 < old(Heap)[lk#_57, held])) && (Heap[lk#_57, rdheld] == old(Heap)[lk#_57, rdheld])) || false);
  assert {:msg "  35.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_58: HeapType;
  var inhaleHeap#_59: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_58;
  assume IsGoodInhaleState(inhaleHeap#_58, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_58[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_58[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_58[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_58, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_59;
  assume IsGoodInhaleState(inhaleHeap#_59, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_59[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_59[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_59[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_59, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.remove(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#3: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_60: HeapType;
  var exhaleMask#_61: MaskType;
  var fraction#_62: int;
  var inhaleHeap#_63: HeapType;
  var this#80: ref where (this#80 == null) || (dtype(this#80) == AVLTreeNode#t);
  var k#81: int where true;
  var r#82: ref where (r#82 == null) || (dtype(r#82) == AVLTreeNode#t);
  var callHeap#_64: HeapType;
  var callMask#_65: MaskType;
  var callCredits#_66: CreditsType;
  var exhaleMask#_67: MaskType;
  var fraction#_68: int;
  var fraction#_69: int;
  var fraction#_70: int;
  var isHeld#_71: int;
  var isRdHeld#_72: bool;
  var inhaleHeap#_73: HeapType;
  var r#74: ref where (r#74 == null) || (dtype(r#74) == AVLTreeNode#t);
  var exhaleMask#_74: MaskType;
  var fraction#_75: int;
  var fraction#_76: int;
  var fraction#_77: int;
  var fraction#_78: int;
  var inhaleHeap#_79: HeapType;
  var exhaleMask#_80: MaskType;
  var fraction#_81: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_60;
  assume IsGoodInhaleState(inhaleHeap#_60, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_60[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_60[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_60[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_60, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  71.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_61 := Mask;
  fraction#_62 := 100;
  assert {:msg "  71.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (fraction#_62 <= exhaleMask#_61[this, AVLTree.valid][perm$R]) && ((fraction#_62 == exhaleMask#_61[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_61[this, AVLTree.valid][perm$N]));
  exhaleMask#_61[this, AVLTree.valid] := exhaleMask#_61[this, AVLTree.valid][perm$R := exhaleMask#_61[this, AVLTree.valid][perm$R] - fraction#_62];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_61);
  Mask := exhaleMask#_61;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_63 := Heap[this, AVLTree.valid];
  assume IsGoodInhaleState(inhaleHeap#_63, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_63[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_63[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_63, Mask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_63, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.height] := inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_63, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_63[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_63, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  72.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  72.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
  } else {
    // call remove
    callHeap#_64 := Heap;
    callMask#_65 := Mask;
    callCredits#_66 := Credits;
    assert {:msg "  74.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  74.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  74.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#80 := Heap[this, AVLTree.root];
    k#81 := k#3;
    // begin exhale (precondition)
    exhaleMask#_67 := Mask;
    fraction#_68 := 100;
    assert {:msg "  74.4: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (fraction#_68 <= exhaleMask#_67[this#80, AVLTreeNode.valid][perm$R]) && ((fraction#_68 == exhaleMask#_67[this#80, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_67[this#80, AVLTreeNode.valid][perm$N]));
    exhaleMask#_67[this#80, AVLTreeNode.valid] := exhaleMask#_67[this#80, AVLTreeNode.valid][perm$R := exhaleMask#_67[this#80, AVLTreeNode.valid][perm$R] - fraction#_68];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_67);
    fraction#_69 := 50;
    assert {:msg "  74.4: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} (fraction#_69 <= exhaleMask#_67[this#80, AVLTreeNode.height][perm$R]) && ((fraction#_69 == exhaleMask#_67[this#80, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_67[this#80, AVLTreeNode.height][perm$N]));
    exhaleMask#_67[this#80, AVLTreeNode.height] := exhaleMask#_67[this#80, AVLTreeNode.height][perm$R := exhaleMask#_67[this#80, AVLTreeNode.height][perm$R] - fraction#_69];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_67);
    fraction#_70 := 50;
    assert {:msg "  74.4: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} (fraction#_70 <= exhaleMask#_67[this#80, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_70 == exhaleMask#_67[this#80, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_67[this#80, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_67[this#80, AVLTreeNode.balanceFactor] := exhaleMask#_67[this#80, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_67[this#80, AVLTreeNode.balanceFactor][perm$R] - fraction#_70];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_67);
    Mask := exhaleMask#_67;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#82;
    // inhale (postcondition)
    havoc inhaleHeap#_73;
    assume IsGoodInhaleState(inhaleHeap#_73, Heap, Mask);
    if (!(r#82 == null)) {
      assume r#82 != null;
      Heap[r#82, AVLTreeNode.valid] := inhaleHeap#_73[r#82, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_73[r#82, AVLTreeNode.valid] == Heap;
      Mask[r#82, AVLTreeNode.valid] := Mask[r#82, AVLTreeNode.valid][perm$R := Mask[r#82, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_73[r#82, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_73, Mask);
    } else {
    }
    if (!(r#82 == null)) {
      assume r#82 != null;
      Heap[r#82, AVLTreeNode.height] := inhaleHeap#_73[r#82, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#82, AVLTreeNode.height] := Mask[r#82, AVLTreeNode.height][perm$R := Mask[r#82, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_73[r#82, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_73, Mask);
    } else {
    }
    if (!(r#82 == null)) {
      assume r#82 != null;
      Heap[r#82, AVLTreeNode.balanceFactor] := inhaleHeap#_73[r#82, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#82, AVLTreeNode.balanceFactor] := Mask[r#82, AVLTreeNode.balanceFactor][perm$R := Mask[r#82, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_73[r#82, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_73, Mask);
    } else {
    }
    if (callHeap#_64[this#80, AVLTreeNode.height] > 1) {
      assume !(r#82 == null);
    } else {
    }
    if (!(r#82 == null)) {
      assume (Heap[r#82, AVLTreeNode.height] == callHeap#_64[this#80, AVLTreeNode.height]) || ((Heap[r#82, AVLTreeNode.height] + 1) == callHeap#_64[this#80, AVLTreeNode.height]);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#74 := r#82;
    // update field root
    assert {:msg "  75.4: Location might not be writable"} CanWrite(Mask, this, AVLTree.root);
    Heap[this, AVLTree.root] := r#74;
    assume wf(Heap, Mask);
  }
  // fold
  assert {:msg "  78.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_74 := Mask;
  fraction#_75 := 100;
  assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_75 <= exhaleMask#_74[this, AVLTree.root][perm$R]) && ((fraction#_75 == exhaleMask#_74[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_74[this, AVLTree.root][perm$N]));
  exhaleMask#_74[this, AVLTree.root] := exhaleMask#_74[this, AVLTree.root][perm$R := exhaleMask#_74[this, AVLTree.root][perm$R] - fraction#_75];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_74);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_76 := 100;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_76 <= exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_76 == exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_76];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_74);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_77 := 50;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (fraction#_77 <= exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((fraction#_77 == exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - fraction#_77];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_74);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_78 := 50;
    assert {:msg "  78.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (fraction#_78 <= exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_78 == exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_74[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - fraction#_78];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_74);
  } else {
  }
  Mask := exhaleMask#_74;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_79;
  assume IsGoodInhaleState(inhaleHeap#_79, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_79[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_79[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_79[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_79, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_80 := Mask;
  fraction#_81 := 100;
  assert {:msg "  60.2: The postcondition at 64.11 might not hold. Insufficient fraction at 64.11 for AVLTree.valid."} (fraction#_81 <= exhaleMask#_80[this, AVLTree.valid][perm$R]) && ((fraction#_81 == exhaleMask#_80[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_80[this, AVLTree.valid][perm$N]));
  exhaleMask#_80[this, AVLTree.valid] := exhaleMask#_80[this, AVLTree.valid][perm$R := exhaleMask#_80[this, AVLTree.valid][perm$R] - fraction#_81];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_80);
  Mask := exhaleMask#_80;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  60.2: Method might lock/unlock more than allowed."} (forall lk#_82: ref :: {Heap[lk#_82, held]} {Heap[lk#_82, rdheld]} (((0 < Heap[lk#_82, held]) == (0 < old(Heap)[lk#_82, held])) && (Heap[lk#_82, rdheld] == old(Heap)[lk#_82, rdheld])) || false);
  assert {:msg "  60.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTree.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_83: HeapType;
  var inhaleHeap#_84: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_83;
  assume IsGoodInhaleState(inhaleHeap#_83, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_83[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_83[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_84;
  assume IsGoodInhaleState(inhaleHeap#_84, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_84[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_84[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_84[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_84, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTree.has(this: ref where (this == null) || (dtype(this) == AVLTree#t), k#4: int where true) returns (b#5: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_85: HeapType;
  var exhaleMask#_86: MaskType;
  var fraction#_87: int;
  var inhaleHeap#_88: HeapType;
  var bb#7: bool where true;
  var this#83: ref where (this#83 == null) || (dtype(this#83) == AVLTreeNode#t);
  var k#84: int where true;
  var b#85: bool where true;
  var callHeap#_89: HeapType;
  var callMask#_90: MaskType;
  var callCredits#_91: CreditsType;
  var exhaleMask#_92: MaskType;
  var fraction#_93: int;
  var isHeld#_94: int;
  var isRdHeld#_95: bool;
  var inhaleHeap#_96: HeapType;
  var exhaleMask#_97: MaskType;
  var fraction#_98: int;
  var fraction#_99: int;
  var fraction#_100: int;
  var fraction#_101: int;
  var inhaleHeap#_102: HeapType;
  var exhaleMask#_103: MaskType;
  var fraction#_104: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_85;
  assume IsGoodInhaleState(inhaleHeap#_85, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_85[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_85[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  90.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_86 := Mask;
  fraction#_87 := 100;
  assert {:msg "  90.3: unfold might fail because the predicate AVLTree.valid does not hold. Insufficient fraction at <undefined position> for AVLTree.valid."} (fraction#_87 <= exhaleMask#_86[this, AVLTree.valid][perm$R]) && ((fraction#_87 == exhaleMask#_86[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_86[this, AVLTree.valid][perm$N]));
  exhaleMask#_86[this, AVLTree.valid] := exhaleMask#_86[this, AVLTree.valid][perm$R := exhaleMask#_86[this, AVLTree.valid][perm$R] - fraction#_87];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_86);
  Mask := exhaleMask#_86;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_88 := Heap[this, AVLTree.valid];
  assume IsGoodInhaleState(inhaleHeap#_88, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.root] := inhaleHeap#_88[this, AVLTree.root];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTree.root] == null) || (dtype(Heap[this, AVLTree.root]) == AVLTreeNode#t);
  Mask[this, AVLTree.root] := Mask[this, AVLTree.root][perm$R := Mask[this, AVLTree.root][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_88[this, AVLTree.root]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_88, Mask);
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.valid] := inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.valid] := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_88, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.height] := inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.height] := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_88, Mask);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    assume Heap[this, AVLTree.root] != null;
    Heap[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_88[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_88, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  91.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  91.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
  if (Heap[this, AVLTree.root] == null) {
    // assigment to b
    b#5 := false;
  } else {
    // local var bb
    // call has
    callHeap#_89 := Heap;
    callMask#_90 := Mask;
    callCredits#_91 := Credits;
    assert {:msg "  95.14: Receiver might be null."} true ==> (this != null);
    assert {:msg "  95.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTree.root);
    assert {:msg "  95.4: The target of the method call might be null."} Heap[this, AVLTree.root] != null;
    this#83 := Heap[this, AVLTree.root];
    k#84 := k#4;
    // begin exhale (precondition)
    exhaleMask#_92 := Mask;
    fraction#_93 := 100;
    assert {:msg "  95.4: The precondition at 455.12 might not hold. Insufficient fraction at 455.12 for AVLTreeNode.valid."} (fraction#_93 <= exhaleMask#_92[this#83, AVLTreeNode.valid][perm$R]) && ((fraction#_93 == exhaleMask#_92[this#83, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_92[this#83, AVLTreeNode.valid][perm$N]));
    exhaleMask#_92[this#83, AVLTreeNode.valid] := exhaleMask#_92[this#83, AVLTreeNode.valid][perm$R := exhaleMask#_92[this#83, AVLTreeNode.valid][perm$R] - fraction#_93];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_92);
    Mask := exhaleMask#_92;
    assume wf(Heap, Mask);
    // end exhale
    havoc b#85;
    // inhale (postcondition)
    havoc inhaleHeap#_96;
    assume IsGoodInhaleState(inhaleHeap#_96, Heap, Mask);
    assume this#83 != null;
    Heap[this#83, AVLTreeNode.valid] := inhaleHeap#_96[this#83, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_96[this#83, AVLTreeNode.valid] == Heap;
    Mask[this#83, AVLTreeNode.valid] := Mask[this#83, AVLTreeNode.valid][perm$R := Mask[this#83, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_96[this#83, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_96, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    bb#7 := b#85;
    // assigment to b
    b#5 := bb#7;
  }
  // fold
  assert {:msg "  98.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_97 := Mask;
  fraction#_98 := 100;
  assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 10.6 for AVLTree.root."} (fraction#_98 <= exhaleMask#_97[this, AVLTree.root][perm$R]) && ((fraction#_98 == exhaleMask#_97[this, AVLTree.root][perm$R]) ==> (0 <= exhaleMask#_97[this, AVLTree.root][perm$N]));
  exhaleMask#_97[this, AVLTree.root] := exhaleMask#_97[this, AVLTree.root][perm$R := exhaleMask#_97[this, AVLTree.root][perm$R] - fraction#_98];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_97);
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_99 := 100;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 12.22 for AVLTreeNode.valid."} (fraction#_99 <= exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) && ((fraction#_99 == exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$N]));
    exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.valid] := exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R := exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.valid][perm$R] - fraction#_99];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_97);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_100 := 50;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 13.22 for AVLTreeNode.height."} (fraction#_100 <= exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) && ((fraction#_100 == exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.height][perm$N]));
    exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.height] := exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R := exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.height][perm$R] - fraction#_100];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_97);
  } else {
  }
  if (!(Heap[this, AVLTree.root] == null)) {
    fraction#_101 := 50;
    assert {:msg "  98.3: Fold might fail because the definition of AVLTree.valid does not hold. Insufficient fraction at 15.22 for AVLTreeNode.balanceFactor."} (fraction#_101 <= exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_101 == exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor] := exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_97[Heap[this, AVLTree.root], AVLTreeNode.balanceFactor][perm$R] - fraction#_101];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_97);
  } else {
  }
  Mask := exhaleMask#_97;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_102;
  assume IsGoodInhaleState(inhaleHeap#_102, Heap, Mask);
  assume this != null;
  Heap[this, AVLTree.valid] := inhaleHeap#_102[this, AVLTree.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_102[this, AVLTree.valid] == Heap;
  Mask[this, AVLTree.valid] := Mask[this, AVLTree.valid][perm$R := Mask[this, AVLTree.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_102[this, AVLTree.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_102, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTree.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_103 := Mask;
  fraction#_104 := 100;
  assert {:msg "  82.2: The postcondition at 86.11 might not hold. Insufficient fraction at 86.11 for AVLTree.valid."} (fraction#_104 <= exhaleMask#_103[this, AVLTree.valid][perm$R]) && ((fraction#_104 == exhaleMask#_103[this, AVLTree.valid][perm$R]) ==> (0 <= exhaleMask#_103[this, AVLTree.valid][perm$N]));
  exhaleMask#_103[this, AVLTree.valid] := exhaleMask#_103[this, AVLTree.valid][perm$R := exhaleMask#_103[this, AVLTree.valid][perm$R] - fraction#_104];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_103);
  Mask := exhaleMask#_103;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  82.2: Method might lock/unlock more than allowed."} (forall lk#_105: ref :: {Heap[lk#_105, held]} {Heap[lk#_105, rdheld]} (((0 < Heap[lk#_105, held]) == (0 < old(Heap)[lk#_105, held])) && (Heap[lk#_105, rdheld] == old(Heap)[lk#_105, rdheld])) || false);
  assert {:msg "  82.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTreeNode#t: TypeName;
procedure AVLTreeNode$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var h0#_106: HeapType;
  var m0#_107: MaskType;
  var c0#_108: CreditsType;
  var h1#_109: HeapType;
  var m1#_110: MaskType;
  var c1#_111: CreditsType;
  var lk#_112: ref;
  assume wf(h0#_106, m0#_107);
  assume wf(h1#_109, m1#_110);
  m1#_110 := ZeroMask;
  c1#_111 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  104.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique AVLTreeNode.key: Field (int);
axiom NonPredicateField(AVLTreeNode.key);
const unique AVLTreeNode.height: Field (int);
axiom NonPredicateField(AVLTreeNode.height);
const unique AVLTreeNode.left: Field (ref);
axiom NonPredicateField(AVLTreeNode.left);
const unique AVLTreeNode.right: Field (ref);
axiom NonPredicateField(AVLTreeNode.right);
const unique AVLTreeNode.balanceFactor: Field (int);
axiom NonPredicateField(AVLTreeNode.balanceFactor);
const unique AVLTreeNode.valid: Field (HeapType);
axiom PredicateField(AVLTreeNode.valid);
procedure AVLTreeNode.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_113: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_113;
  assume IsGoodInhaleState(inhaleHeap#_113, Heap, Mask);
  assert {:msg "  117.17: Fraction might be negative."} 0 <= 100;
  assert {:msg "  117.17: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_113[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_113[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_113, Mask);
  assert {:msg "  118.17: Fraction might be negative."} 0 <= 50;
  assert {:msg "  118.17: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_113[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_113[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_113, Mask);
  assert {:msg "  119.17: Fraction might be negative."} 0 <= 100;
  assert {:msg "  119.17: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_113[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_113[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_113, Mask);
  assert {:msg "  120.17: Fraction might be negative."} 0 <= 100;
  assert {:msg "  120.17: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_113[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_113[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_113, Mask);
  assert {:msg "  123.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  123.24: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_113[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_113[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_113, Mask);
  assert {:msg "  125.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  125.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  125.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  125.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_113, Mask);
  } else {
  }
  assert {:msg "  126.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  126.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  126.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  126.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  126.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  126.45: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_113, Mask);
  } else {
  }
  assert {:msg "  128.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  128.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  128.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  128.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  128.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  128.45: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_113[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_113, Mask);
  } else {
  }
  assert {:msg "  130.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  130.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  130.22: Receiver might be null."} true ==> (this != null);
    assert {:msg "  130.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  130.22: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  130.22: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  assert {:msg "  132.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  132.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  132.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  132.23: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_113, Mask);
  } else {
  }
  assert {:msg "  133.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  133.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  133.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  133.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  133.47: Fraction might be negative."} 0 <= 50;
    assert {:msg "  133.47: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_113, Mask);
  } else {
  }
  assert {:msg "  135.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  135.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  135.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  135.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  135.47: Fraction might be negative."} 0 <= 50;
    assert {:msg "  135.47: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_113[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_113, Mask);
  } else {
  }
  assert {:msg "  137.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  137.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  137.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  137.23: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  137.23: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  137.23: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assert {:msg "  146.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assert {:msg "  146.26: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  146.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  146.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  146.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  146.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.53: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  146.67: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.67: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  146.67: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  146.67: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  146.84: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.84: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    if (Heap[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  146.97: Receiver might be null."} true ==> (this != null);
      assert {:msg "  146.97: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      assert {:msg "  146.97: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
      assert {:msg "  146.97: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  146.115: Receiver might be null."} true ==> (this != null);
    assert {:msg "  146.115: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    if (Heap[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  146.129: Receiver might be null."} true ==> (this != null);
      assert {:msg "  146.129: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      assert {:msg "  146.129: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
      assert {:msg "  146.129: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  147.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  147.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.24: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  147.37: Receiver might be null."} true ==> (this != null);
    assert {:msg "  147.37: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  147.37: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  147.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  147.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.53: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  147.67: Receiver might be null."} true ==> (this != null);
    assert {:msg "  147.67: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  147.67: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  147.67: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  148.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  148.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  149.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  149.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  150.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  150.6: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_114: HeapType;
  var inhaleHeap#_115: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_114;
  assume IsGoodInhaleState(inhaleHeap#_114, Heap, Mask);
  assert {:msg "  155.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  155.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_114[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_114[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_114, Mask);
  assert {:msg "  156.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  156.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_114[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_114[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_114, Mask);
  assert {:msg "  157.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  157.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_114[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_114[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_114, Mask);
  assert {:msg "  158.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  158.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_114[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_114[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_114, Mask);
  assert {:msg "  161.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  161.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_114[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_114[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_114, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_115;
  assume IsGoodInhaleState(inhaleHeap#_115, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_115[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_115[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  165.22: Fraction might be negative."} 0 <= 50;
  assert {:msg "  165.22: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_115[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  166.29: Fraction might be negative."} 0 <= 50;
  assert {:msg "  166.29: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_115[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_115[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_115, Mask);
  assert {:msg "  168.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  168.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assume Heap[this, AVLTreeNode.height] == 1;
  assert {:msg "  170.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  170.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume Heap[this, AVLTreeNode.balanceFactor] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.init(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#8: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_116: HeapType;
  var this#86: ref where (this#86 == null) || (dtype(this#86) == AVLTreeNode#t);
  var callHeap#_117: HeapType;
  var callMask#_118: MaskType;
  var callCredits#_119: CreditsType;
  var exhaleMask#_120: MaskType;
  var fraction#_121: int;
  var fraction#_122: int;
  var fraction#_123: int;
  var fraction#_124: int;
  var fraction#_125: int;
  var fraction#_126: int;
  var fraction#_127: int;
  var fraction#_128: int;
  var fraction#_129: int;
  var fraction#_130: int;
  var fraction#_131: int;
  var isHeld#_132: int;
  var isRdHeld#_133: bool;
  var inhaleHeap#_134: HeapType;
  var exhaleMask#_135: MaskType;
  var fraction#_136: int;
  var fraction#_137: int;
  var fraction#_138: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_116;
  assume IsGoodInhaleState(inhaleHeap#_116, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_116[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_116[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_116[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_116[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_116[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_116[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_116, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field left
  assert {:msg "  174.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  Heap[this, AVLTreeNode.left] := null;
  assume wf(Heap, Mask);
  // update field right
  assert {:msg "  175.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  Heap[this, AVLTreeNode.right] := null;
  assume wf(Heap, Mask);
  // update field key
  assert {:msg "  176.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.key);
  Heap[this, AVLTreeNode.key] := k#8;
  assume wf(Heap, Mask);
  // call close
  callHeap#_117 := Heap;
  callMask#_118 := Mask;
  callCredits#_119 := Credits;
  assert {:msg "  179.3: The target of the method call might be null."} this != null;
  this#86 := this;
  // begin exhale (precondition)
  exhaleMask#_120 := Mask;
  fraction#_121 := 100;
  assert {:msg "  179.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_121 <= exhaleMask#_120[this#86, AVLTreeNode.key][perm$R]) && ((fraction#_121 == exhaleMask#_120[this#86, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_120[this#86, AVLTreeNode.key][perm$N]));
  exhaleMask#_120[this#86, AVLTreeNode.key] := exhaleMask#_120[this#86, AVLTreeNode.key][perm$R := exhaleMask#_120[this#86, AVLTreeNode.key][perm$R] - fraction#_121];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_120);
  fraction#_122 := 100;
  assert {:msg "  179.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_122 <= exhaleMask#_120[this#86, AVLTreeNode.height][perm$R]) && ((fraction#_122 == exhaleMask#_120[this#86, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_120[this#86, AVLTreeNode.height][perm$N]));
  exhaleMask#_120[this#86, AVLTreeNode.height] := exhaleMask#_120[this#86, AVLTreeNode.height][perm$R := exhaleMask#_120[this#86, AVLTreeNode.height][perm$R] - fraction#_122];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_120);
  fraction#_123 := 100;
  assert {:msg "  179.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_123 <= exhaleMask#_120[this#86, AVLTreeNode.left][perm$R]) && ((fraction#_123 == exhaleMask#_120[this#86, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_120[this#86, AVLTreeNode.left][perm$N]));
  exhaleMask#_120[this#86, AVLTreeNode.left] := exhaleMask#_120[this#86, AVLTreeNode.left][perm$R := exhaleMask#_120[this#86, AVLTreeNode.left][perm$R] - fraction#_123];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_120);
  fraction#_124 := 100;
  assert {:msg "  179.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_124 <= exhaleMask#_120[this#86, AVLTreeNode.right][perm$R]) && ((fraction#_124 == exhaleMask#_120[this#86, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_120[this#86, AVLTreeNode.right][perm$N]));
  exhaleMask#_120[this#86, AVLTreeNode.right] := exhaleMask#_120[this#86, AVLTreeNode.right][perm$R := exhaleMask#_120[this#86, AVLTreeNode.right][perm$R] - fraction#_124];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_120);
  fraction#_125 := 100;
  assert {:msg "  179.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_125 <= exhaleMask#_120[this#86, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_125 == exhaleMask#_120[this#86, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_120[this#86, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_120[this#86, AVLTreeNode.balanceFactor] := exhaleMask#_120[this#86, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_120[this#86, AVLTreeNode.balanceFactor][perm$R] - fraction#_125];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_120);
  if (!(Heap[this#86, AVLTreeNode.left] == null)) {
    fraction#_126 := 100;
    assert {:msg "  179.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_126 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_126 == exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_126];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_120);
  } else {
  }
  if (!(Heap[this#86, AVLTreeNode.left] == null)) {
    fraction#_127 := 50;
    assert {:msg "  179.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_127 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_127 == exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_127];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_120);
  } else {
  }
  if (!(Heap[this#86, AVLTreeNode.left] == null)) {
    fraction#_128 := 50;
    assert {:msg "  179.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_128 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_128 == exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_120[Heap[this#86, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_128];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_120);
  } else {
  }
  if (!(Heap[this#86, AVLTreeNode.right] == null)) {
    fraction#_129 := 100;
    assert {:msg "  179.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_129 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_129 == exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_129];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_120);
  } else {
  }
  if (!(Heap[this#86, AVLTreeNode.right] == null)) {
    fraction#_130 := 50;
    assert {:msg "  179.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_130 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_130 == exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_130];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_120);
  } else {
  }
  if (!(Heap[this#86, AVLTreeNode.right] == null)) {
    fraction#_131 := 50;
    assert {:msg "  179.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_131 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_131 == exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_120[Heap[this#86, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_131];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_120);
  } else {
  }
  assert {:msg "  179.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#86, AVLTreeNode.left] == null, 0, Heap[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#86, AVLTreeNode.right] == null, 0, Heap[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  179.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#86, AVLTreeNode.left] == null, 0, Heap[Heap[this#86, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#86, AVLTreeNode.right] == null, 0, Heap[Heap[this#86, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_120;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_134;
  assume IsGoodInhaleState(inhaleHeap#_134, Heap, Mask);
  assume this#86 != null;
  Heap[this#86, AVLTreeNode.valid] := inhaleHeap#_134[this#86, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_134[this#86, AVLTreeNode.valid] == Heap;
  Mask[this#86, AVLTreeNode.valid] := Mask[this#86, AVLTreeNode.valid][perm$R := Mask[this#86, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_134[this#86, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_134, Mask);
  assume this#86 != null;
  Heap[this#86, AVLTreeNode.height] := inhaleHeap#_134[this#86, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#86, AVLTreeNode.height] := Mask[this#86, AVLTreeNode.height][perm$R := Mask[this#86, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_134[this#86, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_134, Mask);
  assume this#86 != null;
  Heap[this#86, AVLTreeNode.balanceFactor] := inhaleHeap#_134[this#86, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#86, AVLTreeNode.balanceFactor] := Mask[this#86, AVLTreeNode.balanceFactor][perm$R := Mask[this#86, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_134[this#86, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_134, Mask);
  assume Heap[this#86, AVLTreeNode.height] == ite(ite(callHeap#_117[this#86, AVLTreeNode.left] == null, 0, callHeap#_117[callHeap#_117[this#86, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_117[this#86, AVLTreeNode.right] == null, 0, callHeap#_117[callHeap#_117[this#86, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_117[this#86, AVLTreeNode.left] == null, 0, callHeap#_117[callHeap#_117[this#86, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_117[this#86, AVLTreeNode.right] == null, 0, callHeap#_117[callHeap#_117[this#86, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#86, AVLTreeNode.balanceFactor] == (ite(callHeap#_117[this#86, AVLTreeNode.left] == null, 0, callHeap#_117[callHeap#_117[this#86, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_117[this#86, AVLTreeNode.right] == null, 0, callHeap#_117[callHeap#_117[this#86, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_135 := Mask;
  fraction#_136 := 100;
  assert {:msg "  154.2: The postcondition at 163.11 might not hold. Insufficient fraction at 163.11 for AVLTreeNode.valid."} (fraction#_136 <= exhaleMask#_135[this, AVLTreeNode.valid][perm$R]) && ((fraction#_136 == exhaleMask#_135[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_135[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_135[this, AVLTreeNode.valid] := exhaleMask#_135[this, AVLTreeNode.valid][perm$R := exhaleMask#_135[this, AVLTreeNode.valid][perm$R] - fraction#_136];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_135);
  fraction#_137 := 50;
  assert {:msg "  154.2: The postcondition at 165.11 might not hold. Insufficient fraction at 165.11 for AVLTreeNode.height."} (fraction#_137 <= exhaleMask#_135[this, AVLTreeNode.height][perm$R]) && ((fraction#_137 == exhaleMask#_135[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_135[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_135[this, AVLTreeNode.height] := exhaleMask#_135[this, AVLTreeNode.height][perm$R := exhaleMask#_135[this, AVLTreeNode.height][perm$R] - fraction#_137];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_135);
  fraction#_138 := 50;
  assert {:msg "  154.2: The postcondition at 166.11 might not hold. Insufficient fraction at 166.11 for AVLTreeNode.balanceFactor."} (fraction#_138 <= exhaleMask#_135[this, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_138 == exhaleMask#_135[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_135[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_135[this, AVLTreeNode.balanceFactor] := exhaleMask#_135[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_135[this, AVLTreeNode.balanceFactor][perm$R] - fraction#_138];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_135);
  assert {:msg "  154.2: The postcondition at 168.11 might not hold. The expression at 168.11 might not evaluate to true."} Heap[this, AVLTreeNode.height] == 1;
  assert {:msg "  154.2: The postcondition at 170.11 might not hold. The expression at 170.11 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == 0;
  Mask := exhaleMask#_135;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  154.2: Method might lock/unlock more than allowed."} (forall lk#_139: ref :: {Heap[lk#_139, held]} {Heap[lk#_139, rdheld]} (((0 < Heap[lk#_139, held]) == (0 < old(Heap)[lk#_139, held])) && (Heap[lk#_139, rdheld] == old(Heap)[lk#_139, rdheld])) || false);
  assert {:msg "  154.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.insert$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_140: HeapType;
  var inhaleHeap#_141: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_140;
  assume IsGoodInhaleState(inhaleHeap#_140, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_140[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_140[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_140[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_140, Mask);
  assert {:msg "  187.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  187.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_140[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_140[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_140, Mask);
  assert {:msg "  188.30: Fraction might be negative."} 0 <= 50;
  assert {:msg "  188.30: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_140[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_140[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_140, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_141;
  assume IsGoodInhaleState(inhaleHeap#_141, Heap, Mask);
  assume !(r#10 == null);
  assume r#10 != null;
  Heap[r#10, AVLTreeNode.valid] := inhaleHeap#_141[r#10, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_141[r#10, AVLTreeNode.valid] == Heap;
  Mask[r#10, AVLTreeNode.valid] := Mask[r#10, AVLTreeNode.valid][perm$R := Mask[r#10, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_141[r#10, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_141, Mask);
  assert {:msg "  193.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  193.24: Fraction might exceed 100."} 50 <= 100;
  assume r#10 != null;
  Heap[r#10, AVLTreeNode.height] := inhaleHeap#_141[r#10, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#10, AVLTreeNode.height] := Mask[r#10, AVLTreeNode.height][perm$R := Mask[r#10, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_141[r#10, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_141, Mask);
  assert {:msg "  194.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  194.31: Fraction might exceed 100."} 50 <= 100;
  assume r#10 != null;
  Heap[r#10, AVLTreeNode.balanceFactor] := inhaleHeap#_141[r#10, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#10, AVLTreeNode.balanceFactor] := Mask[r#10, AVLTreeNode.balanceFactor][perm$R := Mask[r#10, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_141[r#10, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_141, Mask);
  assert {:msg "  202.13: Receiver might be null."} true ==> (r#10 != null);
  assert {:msg "  202.13: Location might not be readable."} true ==> CanRead(Mask, r#10, AVLTreeNode.height);
  assert {:msg "  202.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  202.29: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  assert {:msg "  202.44: Receiver might be null."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#10 != null);
  assert {:msg "  202.44: Location might not be readable."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#10, AVLTreeNode.height);
  assert {:msg "  202.60: Receiver might be null."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  202.60: Location might not be readable."} true && (!(Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
  assume (Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#10, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] + 1));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.insert(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#9: int where true) returns (r#10: ref where (r#10 == null) || (dtype(r#10) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_142: HeapType;
  var exhaleMask#_143: MaskType;
  var fraction#_144: int;
  var inhaleHeap#_145: HeapType;
  var this#87: ref where (this#87 == null) || (dtype(this#87) == AVLTreeNode#t);
  var callHeap#_146: HeapType;
  var callMask#_147: MaskType;
  var callCredits#_148: CreditsType;
  var exhaleMask#_149: MaskType;
  var fraction#_150: int;
  var fraction#_151: int;
  var fraction#_152: int;
  var fraction#_153: int;
  var fraction#_154: int;
  var fraction#_155: int;
  var fraction#_156: int;
  var fraction#_157: int;
  var fraction#_158: int;
  var fraction#_159: int;
  var fraction#_160: int;
  var isHeld#_161: int;
  var isRdHeld#_162: bool;
  var inhaleHeap#_163: HeapType;
  var nl#12: ref where (nl#12 == null) || (dtype(nl#12) == AVLTreeNode#t);
  var nw#_164: ref;
  var this#88: ref where (this#88 == null) || (dtype(this#88) == AVLTreeNode#t);
  var k#89: int where true;
  var callHeap#_165: HeapType;
  var callMask#_166: MaskType;
  var callCredits#_167: CreditsType;
  var exhaleMask#_168: MaskType;
  var fraction#_169: int;
  var fraction#_170: int;
  var fraction#_171: int;
  var fraction#_172: int;
  var fraction#_173: int;
  var isHeld#_174: int;
  var isRdHeld#_175: bool;
  var inhaleHeap#_176: HeapType;
  var this#90: ref where (this#90 == null) || (dtype(this#90) == AVLTreeNode#t);
  var k#91: int where true;
  var r#92: ref where (r#92 == null) || (dtype(r#92) == AVLTreeNode#t);
  var callHeap#_177: HeapType;
  var callMask#_178: MaskType;
  var callCredits#_179: CreditsType;
  var exhaleMask#_180: MaskType;
  var fraction#_181: int;
  var fraction#_182: int;
  var fraction#_183: int;
  var isHeld#_184: int;
  var isRdHeld#_185: bool;
  var inhaleHeap#_186: HeapType;
  var bf#14: int where true;
  var this#93: ref where (this#93 == null) || (dtype(this#93) == AVLTreeNode#t);
  var bf#94: int where true;
  var callHeap#_187: HeapType;
  var callMask#_188: MaskType;
  var callCredits#_189: CreditsType;
  var exhaleMask#_190: MaskType;
  var epsilons#_191: int;
  var fraction#_192: int;
  var epsilons#_193: int;
  var epsilons#_194: int;
  var fraction#_195: int;
  var epsilons#_196: int;
  var isHeld#_197: int;
  var isRdHeld#_198: bool;
  var inhaleHeap#_199: HeapType;
  var this#95: ref where (this#95 == null) || (dtype(this#95) == AVLTreeNode#t);
  var r#96: ref where (r#96 == null) || (dtype(r#96) == AVLTreeNode#t);
  var callHeap#_200: HeapType;
  var callMask#_201: MaskType;
  var callCredits#_202: CreditsType;
  var exhaleMask#_203: MaskType;
  var fraction#_204: int;
  var fraction#_205: int;
  var fraction#_206: int;
  var fraction#_207: int;
  var fraction#_208: int;
  var fraction#_209: int;
  var fraction#_210: int;
  var fraction#_211: int;
  var fraction#_212: int;
  var fraction#_213: int;
  var fraction#_214: int;
  var isHeld#_215: int;
  var isRdHeld#_216: bool;
  var inhaleHeap#_217: HeapType;
  var this#97: ref where (this#97 == null) || (dtype(this#97) == AVLTreeNode#t);
  var callHeap#_218: HeapType;
  var callMask#_219: MaskType;
  var callCredits#_220: CreditsType;
  var exhaleMask#_221: MaskType;
  var fraction#_222: int;
  var fraction#_223: int;
  var fraction#_224: int;
  var fraction#_225: int;
  var fraction#_226: int;
  var fraction#_227: int;
  var fraction#_228: int;
  var fraction#_229: int;
  var fraction#_230: int;
  var fraction#_231: int;
  var fraction#_232: int;
  var isHeld#_233: int;
  var isRdHeld#_234: bool;
  var inhaleHeap#_235: HeapType;
  var nr#16: ref where (nr#16 == null) || (dtype(nr#16) == AVLTreeNode#t);
  var nw#_236: ref;
  var this#98: ref where (this#98 == null) || (dtype(this#98) == AVLTreeNode#t);
  var k#99: int where true;
  var callHeap#_237: HeapType;
  var callMask#_238: MaskType;
  var callCredits#_239: CreditsType;
  var exhaleMask#_240: MaskType;
  var fraction#_241: int;
  var fraction#_242: int;
  var fraction#_243: int;
  var fraction#_244: int;
  var fraction#_245: int;
  var isHeld#_246: int;
  var isRdHeld#_247: bool;
  var inhaleHeap#_248: HeapType;
  var this#100: ref where (this#100 == null) || (dtype(this#100) == AVLTreeNode#t);
  var k#101: int where true;
  var r#102: ref where (r#102 == null) || (dtype(r#102) == AVLTreeNode#t);
  var callHeap#_249: HeapType;
  var callMask#_250: MaskType;
  var callCredits#_251: CreditsType;
  var exhaleMask#_252: MaskType;
  var fraction#_253: int;
  var fraction#_254: int;
  var fraction#_255: int;
  var isHeld#_256: int;
  var isRdHeld#_257: bool;
  var inhaleHeap#_258: HeapType;
  var bf#18: int where true;
  var this#103: ref where (this#103 == null) || (dtype(this#103) == AVLTreeNode#t);
  var bf#104: int where true;
  var callHeap#_259: HeapType;
  var callMask#_260: MaskType;
  var callCredits#_261: CreditsType;
  var exhaleMask#_262: MaskType;
  var epsilons#_263: int;
  var fraction#_264: int;
  var epsilons#_265: int;
  var epsilons#_266: int;
  var fraction#_267: int;
  var epsilons#_268: int;
  var isHeld#_269: int;
  var isRdHeld#_270: bool;
  var inhaleHeap#_271: HeapType;
  var this#105: ref where (this#105 == null) || (dtype(this#105) == AVLTreeNode#t);
  var r#106: ref where (r#106 == null) || (dtype(r#106) == AVLTreeNode#t);
  var callHeap#_272: HeapType;
  var callMask#_273: MaskType;
  var callCredits#_274: CreditsType;
  var exhaleMask#_275: MaskType;
  var fraction#_276: int;
  var fraction#_277: int;
  var fraction#_278: int;
  var fraction#_279: int;
  var fraction#_280: int;
  var fraction#_281: int;
  var fraction#_282: int;
  var fraction#_283: int;
  var fraction#_284: int;
  var fraction#_285: int;
  var fraction#_286: int;
  var isHeld#_287: int;
  var isRdHeld#_288: bool;
  var inhaleHeap#_289: HeapType;
  var this#107: ref where (this#107 == null) || (dtype(this#107) == AVLTreeNode#t);
  var callHeap#_290: HeapType;
  var callMask#_291: MaskType;
  var callCredits#_292: CreditsType;
  var exhaleMask#_293: MaskType;
  var fraction#_294: int;
  var fraction#_295: int;
  var fraction#_296: int;
  var fraction#_297: int;
  var fraction#_298: int;
  var fraction#_299: int;
  var fraction#_300: int;
  var fraction#_301: int;
  var fraction#_302: int;
  var fraction#_303: int;
  var fraction#_304: int;
  var isHeld#_305: int;
  var isRdHeld#_306: bool;
  var inhaleHeap#_307: HeapType;
  var exhaleMask#_308: MaskType;
  var fraction#_309: int;
  var fraction#_310: int;
  var fraction#_311: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_142;
  assume IsGoodInhaleState(inhaleHeap#_142, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_142[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_142[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_142[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_142, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_142[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_142[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_142, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_142[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_142[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_142, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  205.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_143 := Mask;
  fraction#_144 := 100;
  assert {:msg "  205.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_144 <= exhaleMask#_143[this, AVLTreeNode.valid][perm$R]) && ((fraction#_144 == exhaleMask#_143[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_143[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_143[this, AVLTreeNode.valid] := exhaleMask#_143[this, AVLTreeNode.valid][perm$R := exhaleMask#_143[this, AVLTreeNode.valid][perm$R] - fraction#_144];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_143);
  Mask := exhaleMask#_143;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_145 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_145, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_145[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_145[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_145[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_145[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_145[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_145, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_145, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_145[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_145, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_145, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_145, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_145[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_145, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  206.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  206.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (Heap[this, AVLTreeNode.key] == k#9) {
    // assigment to r
    r#10 := this;
    // call close
    callHeap#_146 := Heap;
    callMask#_147 := Mask;
    callCredits#_148 := Credits;
    assert {:msg "  209.4: The target of the method call might be null."} r#10 != null;
    this#87 := r#10;
    // begin exhale (precondition)
    exhaleMask#_149 := Mask;
    fraction#_150 := 100;
    assert {:msg "  209.4: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_150 <= exhaleMask#_149[this#87, AVLTreeNode.key][perm$R]) && ((fraction#_150 == exhaleMask#_149[this#87, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_149[this#87, AVLTreeNode.key][perm$N]));
    exhaleMask#_149[this#87, AVLTreeNode.key] := exhaleMask#_149[this#87, AVLTreeNode.key][perm$R := exhaleMask#_149[this#87, AVLTreeNode.key][perm$R] - fraction#_150];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_149);
    fraction#_151 := 100;
    assert {:msg "  209.4: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_151 <= exhaleMask#_149[this#87, AVLTreeNode.height][perm$R]) && ((fraction#_151 == exhaleMask#_149[this#87, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_149[this#87, AVLTreeNode.height][perm$N]));
    exhaleMask#_149[this#87, AVLTreeNode.height] := exhaleMask#_149[this#87, AVLTreeNode.height][perm$R := exhaleMask#_149[this#87, AVLTreeNode.height][perm$R] - fraction#_151];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_149);
    fraction#_152 := 100;
    assert {:msg "  209.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_152 <= exhaleMask#_149[this#87, AVLTreeNode.left][perm$R]) && ((fraction#_152 == exhaleMask#_149[this#87, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_149[this#87, AVLTreeNode.left][perm$N]));
    exhaleMask#_149[this#87, AVLTreeNode.left] := exhaleMask#_149[this#87, AVLTreeNode.left][perm$R := exhaleMask#_149[this#87, AVLTreeNode.left][perm$R] - fraction#_152];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_149);
    fraction#_153 := 100;
    assert {:msg "  209.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_153 <= exhaleMask#_149[this#87, AVLTreeNode.right][perm$R]) && ((fraction#_153 == exhaleMask#_149[this#87, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_149[this#87, AVLTreeNode.right][perm$N]));
    exhaleMask#_149[this#87, AVLTreeNode.right] := exhaleMask#_149[this#87, AVLTreeNode.right][perm$R := exhaleMask#_149[this#87, AVLTreeNode.right][perm$R] - fraction#_153];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_149);
    fraction#_154 := 100;
    assert {:msg "  209.4: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_154 <= exhaleMask#_149[this#87, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_154 == exhaleMask#_149[this#87, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_149[this#87, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_149[this#87, AVLTreeNode.balanceFactor] := exhaleMask#_149[this#87, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_149[this#87, AVLTreeNode.balanceFactor][perm$R] - fraction#_154];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_149);
    if (!(Heap[this#87, AVLTreeNode.left] == null)) {
      fraction#_155 := 100;
      assert {:msg "  209.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_155 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_155 == exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_155];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_149);
    } else {
    }
    if (!(Heap[this#87, AVLTreeNode.left] == null)) {
      fraction#_156 := 50;
      assert {:msg "  209.4: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_156 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_156 == exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_156];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_149);
    } else {
    }
    if (!(Heap[this#87, AVLTreeNode.left] == null)) {
      fraction#_157 := 50;
      assert {:msg "  209.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_157 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_157 == exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_149[Heap[this#87, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_157];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_149);
    } else {
    }
    if (!(Heap[this#87, AVLTreeNode.right] == null)) {
      fraction#_158 := 100;
      assert {:msg "  209.4: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_158 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_158 == exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_158];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_149);
    } else {
    }
    if (!(Heap[this#87, AVLTreeNode.right] == null)) {
      fraction#_159 := 50;
      assert {:msg "  209.4: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_159 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_159 == exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_159];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_149);
    } else {
    }
    if (!(Heap[this#87, AVLTreeNode.right] == null)) {
      fraction#_160 := 50;
      assert {:msg "  209.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_160 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_160 == exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_149[Heap[this#87, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_160];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_149);
    } else {
    }
    assert {:msg "  209.4: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#87, AVLTreeNode.left] == null, 0, Heap[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#87, AVLTreeNode.right] == null, 0, Heap[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  209.4: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#87, AVLTreeNode.left] == null, 0, Heap[Heap[this#87, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#87, AVLTreeNode.right] == null, 0, Heap[Heap[this#87, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    Mask := exhaleMask#_149;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_163;
    assume IsGoodInhaleState(inhaleHeap#_163, Heap, Mask);
    assume this#87 != null;
    Heap[this#87, AVLTreeNode.valid] := inhaleHeap#_163[this#87, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_163[this#87, AVLTreeNode.valid] == Heap;
    Mask[this#87, AVLTreeNode.valid] := Mask[this#87, AVLTreeNode.valid][perm$R := Mask[this#87, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_163[this#87, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_163, Mask);
    assume this#87 != null;
    Heap[this#87, AVLTreeNode.height] := inhaleHeap#_163[this#87, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#87, AVLTreeNode.height] := Mask[this#87, AVLTreeNode.height][perm$R := Mask[this#87, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_163[this#87, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_163, Mask);
    assume this#87 != null;
    Heap[this#87, AVLTreeNode.balanceFactor] := inhaleHeap#_163[this#87, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#87, AVLTreeNode.balanceFactor] := Mask[this#87, AVLTreeNode.balanceFactor][perm$R := Mask[this#87, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_163[this#87, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_163, Mask);
    assume Heap[this#87, AVLTreeNode.height] == ite(ite(callHeap#_146[this#87, AVLTreeNode.left] == null, 0, callHeap#_146[callHeap#_146[this#87, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_146[this#87, AVLTreeNode.right] == null, 0, callHeap#_146[callHeap#_146[this#87, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_146[this#87, AVLTreeNode.left] == null, 0, callHeap#_146[callHeap#_146[this#87, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_146[this#87, AVLTreeNode.right] == null, 0, callHeap#_146[callHeap#_146[this#87, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#87, AVLTreeNode.balanceFactor] == (ite(callHeap#_146[this#87, AVLTreeNode.left] == null, 0, callHeap#_146[callHeap#_146[this#87, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_146[this#87, AVLTreeNode.right] == null, 0, callHeap#_146[callHeap#_146[this#87, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
  } else {
    // if
    assert {:msg "  211.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  211.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (k#9 < Heap[this, AVLTreeNode.key]) {
      // local var nl
      // if
      assert {:msg "  213.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  213.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (Heap[this, AVLTreeNode.left] == null) {
        // assigment to nl
        // new
        havoc nw#_164;
        assume (nw#_164 != null) && (dtype(nw#_164) == AVLTreeNode#t);
        assume (forall<T#_1> f: Field (T#_1) :: (Mask[nw#_164, f][perm$R] == 0) && (Mask[nw#_164, f][perm$N] == 0));
        assume Heap[nw#_164, mu] == $LockBottom;
        assume Heap[nw#_164, held] <= 0;
        assume Heap[nw#_164, rdheld] == false;
        Mask[nw#_164, AVLTreeNode.key] := Mask[nw#_164, AVLTreeNode.key][perm$R := Mask[nw#_164, AVLTreeNode.key][perm$R] + 100];
        Mask[nw#_164, AVLTreeNode.height] := Mask[nw#_164, AVLTreeNode.height][perm$R := Mask[nw#_164, AVLTreeNode.height][perm$R] + 100];
        Mask[nw#_164, AVLTreeNode.left] := Mask[nw#_164, AVLTreeNode.left][perm$R := Mask[nw#_164, AVLTreeNode.left][perm$R] + 100];
        Mask[nw#_164, AVLTreeNode.right] := Mask[nw#_164, AVLTreeNode.right][perm$R := Mask[nw#_164, AVLTreeNode.right][perm$R] + 100];
        Mask[nw#_164, AVLTreeNode.balanceFactor] := Mask[nw#_164, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_164, AVLTreeNode.balanceFactor][perm$R] + 100];
        Mask[nw#_164, mu] := Mask[nw#_164, mu][perm$R := Mask[nw#_164, mu][perm$R] + 100];
        nl#12 := nw#_164;
        // call init
        callHeap#_165 := Heap;
        callMask#_166 := Mask;
        callCredits#_167 := Credits;
        assert {:msg "  215.6: The target of the method call might be null."} nl#12 != null;
        this#88 := nl#12;
        k#89 := k#9;
        // begin exhale (precondition)
        exhaleMask#_168 := Mask;
        fraction#_169 := 100;
        assert {:msg "  215.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (fraction#_169 <= exhaleMask#_168[this#88, AVLTreeNode.key][perm$R]) && ((fraction#_169 == exhaleMask#_168[this#88, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_168[this#88, AVLTreeNode.key][perm$N]));
        exhaleMask#_168[this#88, AVLTreeNode.key] := exhaleMask#_168[this#88, AVLTreeNode.key][perm$R := exhaleMask#_168[this#88, AVLTreeNode.key][perm$R] - fraction#_169];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_168);
        fraction#_170 := 100;
        assert {:msg "  215.6: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} (fraction#_170 <= exhaleMask#_168[this#88, AVLTreeNode.height][perm$R]) && ((fraction#_170 == exhaleMask#_168[this#88, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_168[this#88, AVLTreeNode.height][perm$N]));
        exhaleMask#_168[this#88, AVLTreeNode.height] := exhaleMask#_168[this#88, AVLTreeNode.height][perm$R := exhaleMask#_168[this#88, AVLTreeNode.height][perm$R] - fraction#_170];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_168);
        fraction#_171 := 100;
        assert {:msg "  215.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (fraction#_171 <= exhaleMask#_168[this#88, AVLTreeNode.left][perm$R]) && ((fraction#_171 == exhaleMask#_168[this#88, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_168[this#88, AVLTreeNode.left][perm$N]));
        exhaleMask#_168[this#88, AVLTreeNode.left] := exhaleMask#_168[this#88, AVLTreeNode.left][perm$R := exhaleMask#_168[this#88, AVLTreeNode.left][perm$R] - fraction#_171];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_168);
        fraction#_172 := 100;
        assert {:msg "  215.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (fraction#_172 <= exhaleMask#_168[this#88, AVLTreeNode.right][perm$R]) && ((fraction#_172 == exhaleMask#_168[this#88, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_168[this#88, AVLTreeNode.right][perm$N]));
        exhaleMask#_168[this#88, AVLTreeNode.right] := exhaleMask#_168[this#88, AVLTreeNode.right][perm$R := exhaleMask#_168[this#88, AVLTreeNode.right][perm$R] - fraction#_172];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_168);
        fraction#_173 := 100;
        assert {:msg "  215.6: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} (fraction#_173 <= exhaleMask#_168[this#88, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_173 == exhaleMask#_168[this#88, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_168[this#88, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_168[this#88, AVLTreeNode.balanceFactor] := exhaleMask#_168[this#88, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_168[this#88, AVLTreeNode.balanceFactor][perm$R] - fraction#_173];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_168);
        Mask := exhaleMask#_168;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_176;
        assume IsGoodInhaleState(inhaleHeap#_176, Heap, Mask);
        assume this#88 != null;
        Heap[this#88, AVLTreeNode.valid] := inhaleHeap#_176[this#88, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_176[this#88, AVLTreeNode.valid] == Heap;
        Mask[this#88, AVLTreeNode.valid] := Mask[this#88, AVLTreeNode.valid][perm$R := Mask[this#88, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_176[this#88, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_176, Mask);
        assume this#88 != null;
        Heap[this#88, AVLTreeNode.height] := inhaleHeap#_176[this#88, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#88, AVLTreeNode.height] := Mask[this#88, AVLTreeNode.height][perm$R := Mask[this#88, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_176[this#88, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_176, Mask);
        assume this#88 != null;
        Heap[this#88, AVLTreeNode.balanceFactor] := inhaleHeap#_176[this#88, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#88, AVLTreeNode.balanceFactor] := Mask[this#88, AVLTreeNode.balanceFactor][perm$R := Mask[this#88, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_176[this#88, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_176, Mask);
        assume Heap[this#88, AVLTreeNode.height] == 1;
        assume Heap[this#88, AVLTreeNode.balanceFactor] == 0;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      } else {
        // call insert
        callHeap#_177 := Heap;
        callMask#_178 := Mask;
        callCredits#_179 := Credits;
        assert {:msg "  217.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  217.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  217.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#90 := Heap[this, AVLTreeNode.left];
        k#91 := k#9;
        // begin exhale (precondition)
        exhaleMask#_180 := Mask;
        fraction#_181 := 100;
        assert {:msg "  217.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (fraction#_181 <= exhaleMask#_180[this#90, AVLTreeNode.valid][perm$R]) && ((fraction#_181 == exhaleMask#_180[this#90, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_180[this#90, AVLTreeNode.valid][perm$N]));
        exhaleMask#_180[this#90, AVLTreeNode.valid] := exhaleMask#_180[this#90, AVLTreeNode.valid][perm$R := exhaleMask#_180[this#90, AVLTreeNode.valid][perm$R] - fraction#_181];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_180);
        fraction#_182 := 50;
        assert {:msg "  217.6: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} (fraction#_182 <= exhaleMask#_180[this#90, AVLTreeNode.height][perm$R]) && ((fraction#_182 == exhaleMask#_180[this#90, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_180[this#90, AVLTreeNode.height][perm$N]));
        exhaleMask#_180[this#90, AVLTreeNode.height] := exhaleMask#_180[this#90, AVLTreeNode.height][perm$R := exhaleMask#_180[this#90, AVLTreeNode.height][perm$R] - fraction#_182];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_180);
        fraction#_183 := 50;
        assert {:msg "  217.6: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} (fraction#_183 <= exhaleMask#_180[this#90, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_183 == exhaleMask#_180[this#90, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_180[this#90, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_180[this#90, AVLTreeNode.balanceFactor] := exhaleMask#_180[this#90, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_180[this#90, AVLTreeNode.balanceFactor][perm$R] - fraction#_183];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_180);
        Mask := exhaleMask#_180;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#92;
        // inhale (postcondition)
        havoc inhaleHeap#_186;
        assume IsGoodInhaleState(inhaleHeap#_186, Heap, Mask);
        assume !(r#92 == null);
        assume r#92 != null;
        Heap[r#92, AVLTreeNode.valid] := inhaleHeap#_186[r#92, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_186[r#92, AVLTreeNode.valid] == Heap;
        Mask[r#92, AVLTreeNode.valid] := Mask[r#92, AVLTreeNode.valid][perm$R := Mask[r#92, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_186[r#92, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_186, Mask);
        assume r#92 != null;
        Heap[r#92, AVLTreeNode.height] := inhaleHeap#_186[r#92, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#92, AVLTreeNode.height] := Mask[r#92, AVLTreeNode.height][perm$R := Mask[r#92, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_186[r#92, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_186, Mask);
        assume r#92 != null;
        Heap[r#92, AVLTreeNode.balanceFactor] := inhaleHeap#_186[r#92, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#92, AVLTreeNode.balanceFactor] := Mask[r#92, AVLTreeNode.balanceFactor][perm$R := Mask[r#92, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_186[r#92, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_186, Mask);
        assume (Heap[r#92, AVLTreeNode.height] == callHeap#_177[this#90, AVLTreeNode.height]) || (Heap[r#92, AVLTreeNode.height] == (callHeap#_177[this#90, AVLTreeNode.height] + 1));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nl#12 := r#92;
      }
      // update field left
      assert {:msg "  219.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
      Heap[this, AVLTreeNode.left] := nl#12;
      assume wf(Heap, Mask);
      // local var bf
      // call getBalanceFactorI
      callHeap#_187 := Heap;
      callMask#_188 := Mask;
      callCredits#_189 := Credits;
      assert {:msg "  221.5: The target of the method call might be null."} this != null;
      this#93 := this;
      // begin exhale (precondition)
      exhaleMask#_190 := Mask;
      epsilons#_191 := 1;
      assert {:msg "  221.5: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_190[this#93, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_191 <= exhaleMask#_190[this#93, AVLTreeNode.left][perm$N]);
      if ((exhaleMask#_190[this#93, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_190[this#93, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_190[this#93, AVLTreeNode.left] := exhaleMask#_190[this#93, AVLTreeNode.left][perm$N := exhaleMask#_190[this#93, AVLTreeNode.left][perm$N] - epsilons#_191];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_190);
      if (!(Heap[this#93, AVLTreeNode.left] == null)) {
        fraction#_192 := 100;
        assert {:msg "  221.5: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_192 <= exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_192 == exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_192];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_190);
      } else {
      }
      if (!(Heap[this#93, AVLTreeNode.left] == null)) {
        epsilons#_193 := 1;
        assert {:msg "  221.5: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_193 <= exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
        if ((exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_190[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_193];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_190);
      } else {
      }
      epsilons#_194 := 1;
      assert {:msg "  221.5: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_190[this#93, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_194 <= exhaleMask#_190[this#93, AVLTreeNode.right][perm$N]);
      if ((exhaleMask#_190[this#93, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_190[this#93, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_190[this#93, AVLTreeNode.right] := exhaleMask#_190[this#93, AVLTreeNode.right][perm$N := exhaleMask#_190[this#93, AVLTreeNode.right][perm$N] - epsilons#_194];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_190);
      if (!(Heap[this#93, AVLTreeNode.right] == null)) {
        fraction#_195 := 100;
        assert {:msg "  221.5: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_195 <= exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_195 == exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_195];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_190);
      } else {
      }
      if (!(Heap[this#93, AVLTreeNode.right] == null)) {
        epsilons#_196 := 1;
        assert {:msg "  221.5: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_196 <= exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
        if ((exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_190[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_196];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_190);
      } else {
      }
      Mask := exhaleMask#_190;
      assume wf(Heap, Mask);
      // end exhale
      havoc bf#94;
      // inhale (postcondition)
      havoc inhaleHeap#_199;
      assume IsGoodInhaleState(inhaleHeap#_199, Heap, Mask);
      assume this#93 != null;
      Heap[this#93, AVLTreeNode.left] := inhaleHeap#_199[this#93, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[this#93, AVLTreeNode.left] == null) || (dtype(Heap[this#93, AVLTreeNode.left]) == AVLTreeNode#t);
      if ((Mask[this#93, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#93, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        Mask[this#93, AVLTreeNode.left] := Mask[this#93, AVLTreeNode.left][perm$N := Mask[this#93, AVLTreeNode.left][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_199[this#93, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_199, Mask);
      if (!(Heap[this#93, AVLTreeNode.left] == null)) {
        assume Heap[this#93, AVLTreeNode.left] != null;
        Heap[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_199[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_199[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_199[Heap[this#93, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_199, Mask);
      } else {
      }
      if (!(Heap[this#93, AVLTreeNode.left] == null)) {
        assume Heap[this#93, AVLTreeNode.left] != null;
        Heap[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_199[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_199[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_199, Mask);
      } else {
      }
      assume this#93 != null;
      Heap[this#93, AVLTreeNode.right] := inhaleHeap#_199[this#93, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[this#93, AVLTreeNode.right] == null) || (dtype(Heap[this#93, AVLTreeNode.right]) == AVLTreeNode#t);
      if ((Mask[this#93, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#93, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        Mask[this#93, AVLTreeNode.right] := Mask[this#93, AVLTreeNode.right][perm$N := Mask[this#93, AVLTreeNode.right][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_199[this#93, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_199, Mask);
      if (!(Heap[this#93, AVLTreeNode.right] == null)) {
        assume Heap[this#93, AVLTreeNode.right] != null;
        Heap[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_199[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_199[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_199[Heap[this#93, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_199, Mask);
      } else {
      }
      if (!(Heap[this#93, AVLTreeNode.right] == null)) {
        assume Heap[this#93, AVLTreeNode.right] != null;
        Heap[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_199[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_199[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_199, Mask);
      } else {
      }
      assume bf#94 == (ite(Heap[this#93, AVLTreeNode.left] == null, 0, Heap[Heap[this#93, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#93, AVLTreeNode.right] == null, 0, Heap[Heap[this#93, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#94 > 0) {
        assume !(Heap[this#93, AVLTreeNode.left] == null);
      } else {
      }
      if (bf#94 < 0) {
        assume !(Heap[this#93, AVLTreeNode.right] == null);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      bf#14 := bf#94;
      // if
      if (bf#14 == 2) {
        // call rebalanceLeft
        callHeap#_200 := Heap;
        callMask#_201 := Mask;
        callCredits#_202 := Credits;
        assert {:msg "  224.6: The target of the method call might be null."} this != null;
        this#95 := this;
        // begin exhale (precondition)
        exhaleMask#_203 := Mask;
        fraction#_204 := 100;
        assert {:msg "  224.6: The precondition at 598.12 might not hold. Insufficient fraction at 598.12 for AVLTreeNode.key."} (fraction#_204 <= exhaleMask#_203[this#95, AVLTreeNode.key][perm$R]) && ((fraction#_204 == exhaleMask#_203[this#95, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_203[this#95, AVLTreeNode.key][perm$N]));
        exhaleMask#_203[this#95, AVLTreeNode.key] := exhaleMask#_203[this#95, AVLTreeNode.key][perm$R := exhaleMask#_203[this#95, AVLTreeNode.key][perm$R] - fraction#_204];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        fraction#_205 := 100;
        assert {:msg "  224.6: The precondition at 599.12 might not hold. Insufficient fraction at 599.12 for AVLTreeNode.height."} (fraction#_205 <= exhaleMask#_203[this#95, AVLTreeNode.height][perm$R]) && ((fraction#_205 == exhaleMask#_203[this#95, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_203[this#95, AVLTreeNode.height][perm$N]));
        exhaleMask#_203[this#95, AVLTreeNode.height] := exhaleMask#_203[this#95, AVLTreeNode.height][perm$R := exhaleMask#_203[this#95, AVLTreeNode.height][perm$R] - fraction#_205];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        fraction#_206 := 100;
        assert {:msg "  224.6: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.left."} (fraction#_206 <= exhaleMask#_203[this#95, AVLTreeNode.left][perm$R]) && ((fraction#_206 == exhaleMask#_203[this#95, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_203[this#95, AVLTreeNode.left][perm$N]));
        exhaleMask#_203[this#95, AVLTreeNode.left] := exhaleMask#_203[this#95, AVLTreeNode.left][perm$R := exhaleMask#_203[this#95, AVLTreeNode.left][perm$R] - fraction#_206];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        fraction#_207 := 100;
        assert {:msg "  224.6: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.right."} (fraction#_207 <= exhaleMask#_203[this#95, AVLTreeNode.right][perm$R]) && ((fraction#_207 == exhaleMask#_203[this#95, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_203[this#95, AVLTreeNode.right][perm$N]));
        exhaleMask#_203[this#95, AVLTreeNode.right] := exhaleMask#_203[this#95, AVLTreeNode.right][perm$R := exhaleMask#_203[this#95, AVLTreeNode.right][perm$R] - fraction#_207];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        fraction#_208 := 100;
        assert {:msg "  224.6: The precondition at 604.12 might not hold. Insufficient fraction at 604.12 for AVLTreeNode.balanceFactor."} (fraction#_208 <= exhaleMask#_203[this#95, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_208 == exhaleMask#_203[this#95, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_203[this#95, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_203[this#95, AVLTreeNode.balanceFactor] := exhaleMask#_203[this#95, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_203[this#95, AVLTreeNode.balanceFactor][perm$R] - fraction#_208];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        assert {:msg "  224.6: The precondition at 606.12 might not hold. The expression at 606.12 might not evaluate to true."} !(Heap[this#95, AVLTreeNode.left] == null);
        fraction#_209 := 100;
        assert {:msg "  224.6: The precondition at 607.12 might not hold. Insufficient fraction at 607.12 for AVLTreeNode.valid."} (fraction#_209 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_209 == exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_209];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        fraction#_210 := 50;
        assert {:msg "  224.6: The precondition at 608.12 might not hold. Insufficient fraction at 608.12 for AVLTreeNode.height."} (fraction#_210 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_210 == exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_210];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        fraction#_211 := 50;
        assert {:msg "  224.6: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.balanceFactor."} (fraction#_211 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_211 == exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_203[Heap[this#95, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_211];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_203);
        if (!(Heap[this#95, AVLTreeNode.right] == null)) {
          fraction#_212 := 100;
          assert {:msg "  224.6: The precondition at 613.12 might not hold. Insufficient fraction at 613.28 for AVLTreeNode.valid."} (fraction#_212 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_212 == exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_212];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_203);
        } else {
        }
        if (!(Heap[this#95, AVLTreeNode.right] == null)) {
          fraction#_213 := 50;
          assert {:msg "  224.6: The precondition at 614.12 might not hold. Insufficient fraction at 614.28 for AVLTreeNode.height."} (fraction#_213 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_213 == exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_213];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_203);
        } else {
        }
        if (!(Heap[this#95, AVLTreeNode.right] == null)) {
          fraction#_214 := 50;
          assert {:msg "  224.6: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.balanceFactor."} (fraction#_214 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_214 == exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_203[Heap[this#95, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_214];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_203);
        } else {
        }
        assert {:msg "  224.6: The precondition at 619.12 might not hold. The expression at 619.12 might not evaluate to true."} (Heap[Heap[this#95, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#95, AVLTreeNode.right] == null, 0, Heap[Heap[this#95, AVLTreeNode.right], AVLTreeNode.height])) == 2;
        Mask := exhaleMask#_203;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#96;
        // inhale (postcondition)
        havoc inhaleHeap#_217;
        assume IsGoodInhaleState(inhaleHeap#_217, Heap, Mask);
        assume r#96 != null;
        Heap[r#96, AVLTreeNode.valid] := inhaleHeap#_217[r#96, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_217[r#96, AVLTreeNode.valid] == Heap;
        Mask[r#96, AVLTreeNode.valid] := Mask[r#96, AVLTreeNode.valid][perm$R := Mask[r#96, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_217[r#96, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_217, Mask);
        assume r#96 != null;
        Heap[r#96, AVLTreeNode.height] := inhaleHeap#_217[r#96, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#96, AVLTreeNode.height] := Mask[r#96, AVLTreeNode.height][perm$R := Mask[r#96, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_217[r#96, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_217, Mask);
        assume r#96 != null;
        Heap[r#96, AVLTreeNode.balanceFactor] := inhaleHeap#_217[r#96, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#96, AVLTreeNode.balanceFactor] := Mask[r#96, AVLTreeNode.balanceFactor][perm$R := Mask[r#96, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_217[r#96, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_217, Mask);
        assume (Heap[r#96, AVLTreeNode.height] == callHeap#_200[callHeap#_200[this#95, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#96, AVLTreeNode.height] == (callHeap#_200[callHeap#_200[this#95, AVLTreeNode.left], AVLTreeNode.height] + 1));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        r#10 := r#96;
      } else {
        // assigment to r
        r#10 := this;
        // call close
        callHeap#_218 := Heap;
        callMask#_219 := Mask;
        callCredits#_220 := Credits;
        assert {:msg "  227.6: The target of the method call might be null."} r#10 != null;
        this#97 := r#10;
        // begin exhale (precondition)
        exhaleMask#_221 := Mask;
        fraction#_222 := 100;
        assert {:msg "  227.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_222 <= exhaleMask#_221[this#97, AVLTreeNode.key][perm$R]) && ((fraction#_222 == exhaleMask#_221[this#97, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_221[this#97, AVLTreeNode.key][perm$N]));
        exhaleMask#_221[this#97, AVLTreeNode.key] := exhaleMask#_221[this#97, AVLTreeNode.key][perm$R := exhaleMask#_221[this#97, AVLTreeNode.key][perm$R] - fraction#_222];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_221);
        fraction#_223 := 100;
        assert {:msg "  227.6: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_223 <= exhaleMask#_221[this#97, AVLTreeNode.height][perm$R]) && ((fraction#_223 == exhaleMask#_221[this#97, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_221[this#97, AVLTreeNode.height][perm$N]));
        exhaleMask#_221[this#97, AVLTreeNode.height] := exhaleMask#_221[this#97, AVLTreeNode.height][perm$R := exhaleMask#_221[this#97, AVLTreeNode.height][perm$R] - fraction#_223];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_221);
        fraction#_224 := 100;
        assert {:msg "  227.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_224 <= exhaleMask#_221[this#97, AVLTreeNode.left][perm$R]) && ((fraction#_224 == exhaleMask#_221[this#97, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_221[this#97, AVLTreeNode.left][perm$N]));
        exhaleMask#_221[this#97, AVLTreeNode.left] := exhaleMask#_221[this#97, AVLTreeNode.left][perm$R := exhaleMask#_221[this#97, AVLTreeNode.left][perm$R] - fraction#_224];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_221);
        fraction#_225 := 100;
        assert {:msg "  227.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_225 <= exhaleMask#_221[this#97, AVLTreeNode.right][perm$R]) && ((fraction#_225 == exhaleMask#_221[this#97, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_221[this#97, AVLTreeNode.right][perm$N]));
        exhaleMask#_221[this#97, AVLTreeNode.right] := exhaleMask#_221[this#97, AVLTreeNode.right][perm$R := exhaleMask#_221[this#97, AVLTreeNode.right][perm$R] - fraction#_225];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_221);
        fraction#_226 := 100;
        assert {:msg "  227.6: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_226 <= exhaleMask#_221[this#97, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_226 == exhaleMask#_221[this#97, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_221[this#97, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_221[this#97, AVLTreeNode.balanceFactor] := exhaleMask#_221[this#97, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_221[this#97, AVLTreeNode.balanceFactor][perm$R] - fraction#_226];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_221);
        if (!(Heap[this#97, AVLTreeNode.left] == null)) {
          fraction#_227 := 100;
          assert {:msg "  227.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_227 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_227 == exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_227];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_221);
        } else {
        }
        if (!(Heap[this#97, AVLTreeNode.left] == null)) {
          fraction#_228 := 50;
          assert {:msg "  227.6: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_228 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_228 == exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_228];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_221);
        } else {
        }
        if (!(Heap[this#97, AVLTreeNode.left] == null)) {
          fraction#_229 := 50;
          assert {:msg "  227.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_229 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_229 == exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_221[Heap[this#97, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_229];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_221);
        } else {
        }
        if (!(Heap[this#97, AVLTreeNode.right] == null)) {
          fraction#_230 := 100;
          assert {:msg "  227.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_230 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_230 == exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_230];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_221);
        } else {
        }
        if (!(Heap[this#97, AVLTreeNode.right] == null)) {
          fraction#_231 := 50;
          assert {:msg "  227.6: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_231 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_231 == exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_231];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_221);
        } else {
        }
        if (!(Heap[this#97, AVLTreeNode.right] == null)) {
          fraction#_232 := 50;
          assert {:msg "  227.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_232 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_232 == exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_221[Heap[this#97, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_232];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_221);
        } else {
        }
        assert {:msg "  227.6: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#97, AVLTreeNode.left] == null, 0, Heap[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#97, AVLTreeNode.right] == null, 0, Heap[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  227.6: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#97, AVLTreeNode.left] == null, 0, Heap[Heap[this#97, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#97, AVLTreeNode.right] == null, 0, Heap[Heap[this#97, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        Mask := exhaleMask#_221;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_235;
        assume IsGoodInhaleState(inhaleHeap#_235, Heap, Mask);
        assume this#97 != null;
        Heap[this#97, AVLTreeNode.valid] := inhaleHeap#_235[this#97, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_235[this#97, AVLTreeNode.valid] == Heap;
        Mask[this#97, AVLTreeNode.valid] := Mask[this#97, AVLTreeNode.valid][perm$R := Mask[this#97, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_235[this#97, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_235, Mask);
        assume this#97 != null;
        Heap[this#97, AVLTreeNode.height] := inhaleHeap#_235[this#97, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#97, AVLTreeNode.height] := Mask[this#97, AVLTreeNode.height][perm$R := Mask[this#97, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_235[this#97, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_235, Mask);
        assume this#97 != null;
        Heap[this#97, AVLTreeNode.balanceFactor] := inhaleHeap#_235[this#97, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#97, AVLTreeNode.balanceFactor] := Mask[this#97, AVLTreeNode.balanceFactor][perm$R := Mask[this#97, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_235[this#97, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_235, Mask);
        assume Heap[this#97, AVLTreeNode.height] == ite(ite(callHeap#_218[this#97, AVLTreeNode.left] == null, 0, callHeap#_218[callHeap#_218[this#97, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_218[this#97, AVLTreeNode.right] == null, 0, callHeap#_218[callHeap#_218[this#97, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_218[this#97, AVLTreeNode.left] == null, 0, callHeap#_218[callHeap#_218[this#97, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_218[this#97, AVLTreeNode.right] == null, 0, callHeap#_218[callHeap#_218[this#97, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#97, AVLTreeNode.balanceFactor] == (ite(callHeap#_218[this#97, AVLTreeNode.left] == null, 0, callHeap#_218[callHeap#_218[this#97, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_218[this#97, AVLTreeNode.right] == null, 0, callHeap#_218[callHeap#_218[this#97, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    } else {
      // local var nr
      // if
      assert {:msg "  231.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  231.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (Heap[this, AVLTreeNode.right] == null) {
        // assigment to nr
        // new
        havoc nw#_236;
        assume (nw#_236 != null) && (dtype(nw#_236) == AVLTreeNode#t);
        assume (forall<T#_2> f: Field (T#_2) :: (Mask[nw#_236, f][perm$R] == 0) && (Mask[nw#_236, f][perm$N] == 0));
        assume Heap[nw#_236, mu] == $LockBottom;
        assume Heap[nw#_236, held] <= 0;
        assume Heap[nw#_236, rdheld] == false;
        Mask[nw#_236, AVLTreeNode.key] := Mask[nw#_236, AVLTreeNode.key][perm$R := Mask[nw#_236, AVLTreeNode.key][perm$R] + 100];
        Mask[nw#_236, AVLTreeNode.height] := Mask[nw#_236, AVLTreeNode.height][perm$R := Mask[nw#_236, AVLTreeNode.height][perm$R] + 100];
        Mask[nw#_236, AVLTreeNode.left] := Mask[nw#_236, AVLTreeNode.left][perm$R := Mask[nw#_236, AVLTreeNode.left][perm$R] + 100];
        Mask[nw#_236, AVLTreeNode.right] := Mask[nw#_236, AVLTreeNode.right][perm$R := Mask[nw#_236, AVLTreeNode.right][perm$R] + 100];
        Mask[nw#_236, AVLTreeNode.balanceFactor] := Mask[nw#_236, AVLTreeNode.balanceFactor][perm$R := Mask[nw#_236, AVLTreeNode.balanceFactor][perm$R] + 100];
        Mask[nw#_236, mu] := Mask[nw#_236, mu][perm$R := Mask[nw#_236, mu][perm$R] + 100];
        nr#16 := nw#_236;
        // call init
        callHeap#_237 := Heap;
        callMask#_238 := Mask;
        callCredits#_239 := Credits;
        assert {:msg "  233.6: The target of the method call might be null."} nr#16 != null;
        this#98 := nr#16;
        k#99 := k#9;
        // begin exhale (precondition)
        exhaleMask#_240 := Mask;
        fraction#_241 := 100;
        assert {:msg "  233.6: The precondition at 155.12 might not hold. Insufficient fraction at 155.12 for AVLTreeNode.key."} (fraction#_241 <= exhaleMask#_240[this#98, AVLTreeNode.key][perm$R]) && ((fraction#_241 == exhaleMask#_240[this#98, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_240[this#98, AVLTreeNode.key][perm$N]));
        exhaleMask#_240[this#98, AVLTreeNode.key] := exhaleMask#_240[this#98, AVLTreeNode.key][perm$R := exhaleMask#_240[this#98, AVLTreeNode.key][perm$R] - fraction#_241];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_240);
        fraction#_242 := 100;
        assert {:msg "  233.6: The precondition at 156.12 might not hold. Insufficient fraction at 156.12 for AVLTreeNode.height."} (fraction#_242 <= exhaleMask#_240[this#98, AVLTreeNode.height][perm$R]) && ((fraction#_242 == exhaleMask#_240[this#98, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_240[this#98, AVLTreeNode.height][perm$N]));
        exhaleMask#_240[this#98, AVLTreeNode.height] := exhaleMask#_240[this#98, AVLTreeNode.height][perm$R := exhaleMask#_240[this#98, AVLTreeNode.height][perm$R] - fraction#_242];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_240);
        fraction#_243 := 100;
        assert {:msg "  233.6: The precondition at 157.12 might not hold. Insufficient fraction at 157.12 for AVLTreeNode.left."} (fraction#_243 <= exhaleMask#_240[this#98, AVLTreeNode.left][perm$R]) && ((fraction#_243 == exhaleMask#_240[this#98, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_240[this#98, AVLTreeNode.left][perm$N]));
        exhaleMask#_240[this#98, AVLTreeNode.left] := exhaleMask#_240[this#98, AVLTreeNode.left][perm$R := exhaleMask#_240[this#98, AVLTreeNode.left][perm$R] - fraction#_243];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_240);
        fraction#_244 := 100;
        assert {:msg "  233.6: The precondition at 158.12 might not hold. Insufficient fraction at 158.12 for AVLTreeNode.right."} (fraction#_244 <= exhaleMask#_240[this#98, AVLTreeNode.right][perm$R]) && ((fraction#_244 == exhaleMask#_240[this#98, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_240[this#98, AVLTreeNode.right][perm$N]));
        exhaleMask#_240[this#98, AVLTreeNode.right] := exhaleMask#_240[this#98, AVLTreeNode.right][perm$R := exhaleMask#_240[this#98, AVLTreeNode.right][perm$R] - fraction#_244];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_240);
        fraction#_245 := 100;
        assert {:msg "  233.6: The precondition at 161.12 might not hold. Insufficient fraction at 161.12 for AVLTreeNode.balanceFactor."} (fraction#_245 <= exhaleMask#_240[this#98, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_245 == exhaleMask#_240[this#98, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_240[this#98, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_240[this#98, AVLTreeNode.balanceFactor] := exhaleMask#_240[this#98, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_240[this#98, AVLTreeNode.balanceFactor][perm$R] - fraction#_245];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_240);
        Mask := exhaleMask#_240;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_248;
        assume IsGoodInhaleState(inhaleHeap#_248, Heap, Mask);
        assume this#98 != null;
        Heap[this#98, AVLTreeNode.valid] := inhaleHeap#_248[this#98, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_248[this#98, AVLTreeNode.valid] == Heap;
        Mask[this#98, AVLTreeNode.valid] := Mask[this#98, AVLTreeNode.valid][perm$R := Mask[this#98, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_248[this#98, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_248, Mask);
        assume this#98 != null;
        Heap[this#98, AVLTreeNode.height] := inhaleHeap#_248[this#98, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#98, AVLTreeNode.height] := Mask[this#98, AVLTreeNode.height][perm$R := Mask[this#98, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_248[this#98, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_248, Mask);
        assume this#98 != null;
        Heap[this#98, AVLTreeNode.balanceFactor] := inhaleHeap#_248[this#98, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#98, AVLTreeNode.balanceFactor] := Mask[this#98, AVLTreeNode.balanceFactor][perm$R := Mask[this#98, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_248[this#98, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_248, Mask);
        assume Heap[this#98, AVLTreeNode.height] == 1;
        assume Heap[this#98, AVLTreeNode.balanceFactor] == 0;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      } else {
        // call insert
        callHeap#_249 := Heap;
        callMask#_250 := Mask;
        callCredits#_251 := Credits;
        assert {:msg "  235.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  235.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  235.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#100 := Heap[this, AVLTreeNode.right];
        k#101 := k#9;
        // begin exhale (precondition)
        exhaleMask#_252 := Mask;
        fraction#_253 := 100;
        assert {:msg "  235.6: The precondition at 185.12 might not hold. Insufficient fraction at 185.12 for AVLTreeNode.valid."} (fraction#_253 <= exhaleMask#_252[this#100, AVLTreeNode.valid][perm$R]) && ((fraction#_253 == exhaleMask#_252[this#100, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_252[this#100, AVLTreeNode.valid][perm$N]));
        exhaleMask#_252[this#100, AVLTreeNode.valid] := exhaleMask#_252[this#100, AVLTreeNode.valid][perm$R := exhaleMask#_252[this#100, AVLTreeNode.valid][perm$R] - fraction#_253];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_252);
        fraction#_254 := 50;
        assert {:msg "  235.6: The precondition at 187.12 might not hold. Insufficient fraction at 187.12 for AVLTreeNode.height."} (fraction#_254 <= exhaleMask#_252[this#100, AVLTreeNode.height][perm$R]) && ((fraction#_254 == exhaleMask#_252[this#100, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_252[this#100, AVLTreeNode.height][perm$N]));
        exhaleMask#_252[this#100, AVLTreeNode.height] := exhaleMask#_252[this#100, AVLTreeNode.height][perm$R := exhaleMask#_252[this#100, AVLTreeNode.height][perm$R] - fraction#_254];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_252);
        fraction#_255 := 50;
        assert {:msg "  235.6: The precondition at 188.12 might not hold. Insufficient fraction at 188.12 for AVLTreeNode.balanceFactor."} (fraction#_255 <= exhaleMask#_252[this#100, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_255 == exhaleMask#_252[this#100, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_252[this#100, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_252[this#100, AVLTreeNode.balanceFactor] := exhaleMask#_252[this#100, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_252[this#100, AVLTreeNode.balanceFactor][perm$R] - fraction#_255];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_252);
        Mask := exhaleMask#_252;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#102;
        // inhale (postcondition)
        havoc inhaleHeap#_258;
        assume IsGoodInhaleState(inhaleHeap#_258, Heap, Mask);
        assume !(r#102 == null);
        assume r#102 != null;
        Heap[r#102, AVLTreeNode.valid] := inhaleHeap#_258[r#102, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_258[r#102, AVLTreeNode.valid] == Heap;
        Mask[r#102, AVLTreeNode.valid] := Mask[r#102, AVLTreeNode.valid][perm$R := Mask[r#102, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_258[r#102, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_258, Mask);
        assume r#102 != null;
        Heap[r#102, AVLTreeNode.height] := inhaleHeap#_258[r#102, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#102, AVLTreeNode.height] := Mask[r#102, AVLTreeNode.height][perm$R := Mask[r#102, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_258[r#102, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_258, Mask);
        assume r#102 != null;
        Heap[r#102, AVLTreeNode.balanceFactor] := inhaleHeap#_258[r#102, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#102, AVLTreeNode.balanceFactor] := Mask[r#102, AVLTreeNode.balanceFactor][perm$R := Mask[r#102, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_258[r#102, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_258, Mask);
        assume (Heap[r#102, AVLTreeNode.height] == callHeap#_249[this#100, AVLTreeNode.height]) || (Heap[r#102, AVLTreeNode.height] == (callHeap#_249[this#100, AVLTreeNode.height] + 1));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nr#16 := r#102;
      }
      // update field right
      assert {:msg "  237.5: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
      Heap[this, AVLTreeNode.right] := nr#16;
      assume wf(Heap, Mask);
      // local var bf
      // call getBalanceFactorI
      callHeap#_259 := Heap;
      callMask#_260 := Mask;
      callCredits#_261 := Credits;
      assert {:msg "  240.5: The target of the method call might be null."} this != null;
      this#103 := this;
      // begin exhale (precondition)
      exhaleMask#_262 := Mask;
      epsilons#_263 := 1;
      assert {:msg "  240.5: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_262[this#103, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_263 <= exhaleMask#_262[this#103, AVLTreeNode.left][perm$N]);
      if ((exhaleMask#_262[this#103, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_262[this#103, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_262[this#103, AVLTreeNode.left] := exhaleMask#_262[this#103, AVLTreeNode.left][perm$N := exhaleMask#_262[this#103, AVLTreeNode.left][perm$N] - epsilons#_263];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_262);
      if (!(Heap[this#103, AVLTreeNode.left] == null)) {
        fraction#_264 := 100;
        assert {:msg "  240.5: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_264 <= exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_264 == exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_264];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_262);
      } else {
      }
      if (!(Heap[this#103, AVLTreeNode.left] == null)) {
        epsilons#_265 := 1;
        assert {:msg "  240.5: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_265 <= exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
        if ((exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_262[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_265];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_262);
      } else {
      }
      epsilons#_266 := 1;
      assert {:msg "  240.5: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_262[this#103, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_266 <= exhaleMask#_262[this#103, AVLTreeNode.right][perm$N]);
      if ((exhaleMask#_262[this#103, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_262[this#103, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_262[this#103, AVLTreeNode.right] := exhaleMask#_262[this#103, AVLTreeNode.right][perm$N := exhaleMask#_262[this#103, AVLTreeNode.right][perm$N] - epsilons#_266];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_262);
      if (!(Heap[this#103, AVLTreeNode.right] == null)) {
        fraction#_267 := 100;
        assert {:msg "  240.5: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_267 <= exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_267 == exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_267];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_262);
      } else {
      }
      if (!(Heap[this#103, AVLTreeNode.right] == null)) {
        epsilons#_268 := 1;
        assert {:msg "  240.5: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_268 <= exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
        if ((exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_262[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_268];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_262);
      } else {
      }
      Mask := exhaleMask#_262;
      assume wf(Heap, Mask);
      // end exhale
      havoc bf#104;
      // inhale (postcondition)
      havoc inhaleHeap#_271;
      assume IsGoodInhaleState(inhaleHeap#_271, Heap, Mask);
      assume this#103 != null;
      Heap[this#103, AVLTreeNode.left] := inhaleHeap#_271[this#103, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[this#103, AVLTreeNode.left] == null) || (dtype(Heap[this#103, AVLTreeNode.left]) == AVLTreeNode#t);
      if ((Mask[this#103, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#103, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        Mask[this#103, AVLTreeNode.left] := Mask[this#103, AVLTreeNode.left][perm$N := Mask[this#103, AVLTreeNode.left][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_271[this#103, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_271, Mask);
      if (!(Heap[this#103, AVLTreeNode.left] == null)) {
        assume Heap[this#103, AVLTreeNode.left] != null;
        Heap[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_271[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_271[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_271[Heap[this#103, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_271, Mask);
      } else {
      }
      if (!(Heap[this#103, AVLTreeNode.left] == null)) {
        assume Heap[this#103, AVLTreeNode.left] != null;
        Heap[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_271[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_271[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_271, Mask);
      } else {
      }
      assume this#103 != null;
      Heap[this#103, AVLTreeNode.right] := inhaleHeap#_271[this#103, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[this#103, AVLTreeNode.right] == null) || (dtype(Heap[this#103, AVLTreeNode.right]) == AVLTreeNode#t);
      if ((Mask[this#103, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#103, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        Mask[this#103, AVLTreeNode.right] := Mask[this#103, AVLTreeNode.right][perm$N := Mask[this#103, AVLTreeNode.right][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_271[this#103, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_271, Mask);
      if (!(Heap[this#103, AVLTreeNode.right] == null)) {
        assume Heap[this#103, AVLTreeNode.right] != null;
        Heap[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_271[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_271[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_271[Heap[this#103, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_271, Mask);
      } else {
      }
      if (!(Heap[this#103, AVLTreeNode.right] == null)) {
        assume Heap[this#103, AVLTreeNode.right] != null;
        Heap[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_271[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_271[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_271, Mask);
      } else {
      }
      assume bf#104 == (ite(Heap[this#103, AVLTreeNode.left] == null, 0, Heap[Heap[this#103, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#103, AVLTreeNode.right] == null, 0, Heap[Heap[this#103, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#104 > 0) {
        assume !(Heap[this#103, AVLTreeNode.left] == null);
      } else {
      }
      if (bf#104 < 0) {
        assume !(Heap[this#103, AVLTreeNode.right] == null);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      bf#18 := bf#104;
      // if
      if (bf#18 == (0 - 2)) {
        // call rebalanceRight
        callHeap#_272 := Heap;
        callMask#_273 := Mask;
        callCredits#_274 := Credits;
        assert {:msg "  242.6: The target of the method call might be null."} this != null;
        this#105 := this;
        // begin exhale (precondition)
        exhaleMask#_275 := Mask;
        fraction#_276 := 100;
        assert {:msg "  242.6: The precondition at 741.12 might not hold. Insufficient fraction at 741.12 for AVLTreeNode.key."} (fraction#_276 <= exhaleMask#_275[this#105, AVLTreeNode.key][perm$R]) && ((fraction#_276 == exhaleMask#_275[this#105, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_275[this#105, AVLTreeNode.key][perm$N]));
        exhaleMask#_275[this#105, AVLTreeNode.key] := exhaleMask#_275[this#105, AVLTreeNode.key][perm$R := exhaleMask#_275[this#105, AVLTreeNode.key][perm$R] - fraction#_276];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        fraction#_277 := 100;
        assert {:msg "  242.6: The precondition at 742.12 might not hold. Insufficient fraction at 742.12 for AVLTreeNode.height."} (fraction#_277 <= exhaleMask#_275[this#105, AVLTreeNode.height][perm$R]) && ((fraction#_277 == exhaleMask#_275[this#105, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_275[this#105, AVLTreeNode.height][perm$N]));
        exhaleMask#_275[this#105, AVLTreeNode.height] := exhaleMask#_275[this#105, AVLTreeNode.height][perm$R := exhaleMask#_275[this#105, AVLTreeNode.height][perm$R] - fraction#_277];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        fraction#_278 := 100;
        assert {:msg "  242.6: The precondition at 743.12 might not hold. Insufficient fraction at 743.12 for AVLTreeNode.left."} (fraction#_278 <= exhaleMask#_275[this#105, AVLTreeNode.left][perm$R]) && ((fraction#_278 == exhaleMask#_275[this#105, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_275[this#105, AVLTreeNode.left][perm$N]));
        exhaleMask#_275[this#105, AVLTreeNode.left] := exhaleMask#_275[this#105, AVLTreeNode.left][perm$R := exhaleMask#_275[this#105, AVLTreeNode.left][perm$R] - fraction#_278];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        fraction#_279 := 100;
        assert {:msg "  242.6: The precondition at 744.12 might not hold. Insufficient fraction at 744.12 for AVLTreeNode.right."} (fraction#_279 <= exhaleMask#_275[this#105, AVLTreeNode.right][perm$R]) && ((fraction#_279 == exhaleMask#_275[this#105, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_275[this#105, AVLTreeNode.right][perm$N]));
        exhaleMask#_275[this#105, AVLTreeNode.right] := exhaleMask#_275[this#105, AVLTreeNode.right][perm$R := exhaleMask#_275[this#105, AVLTreeNode.right][perm$R] - fraction#_279];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        fraction#_280 := 100;
        assert {:msg "  242.6: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.balanceFactor."} (fraction#_280 <= exhaleMask#_275[this#105, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_280 == exhaleMask#_275[this#105, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_275[this#105, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_275[this#105, AVLTreeNode.balanceFactor] := exhaleMask#_275[this#105, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_275[this#105, AVLTreeNode.balanceFactor][perm$R] - fraction#_280];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        if (!(Heap[this#105, AVLTreeNode.left] == null)) {
          fraction#_281 := 100;
          assert {:msg "  242.6: The precondition at 749.12 might not hold. Insufficient fraction at 749.25 for AVLTreeNode.valid."} (fraction#_281 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_281 == exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_281];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_275);
        } else {
        }
        if (!(Heap[this#105, AVLTreeNode.left] == null)) {
          fraction#_282 := 50;
          assert {:msg "  242.6: The precondition at 750.12 might not hold. Insufficient fraction at 750.25 for AVLTreeNode.height."} (fraction#_282 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_282 == exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_282];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_275);
        } else {
        }
        if (!(Heap[this#105, AVLTreeNode.left] == null)) {
          fraction#_283 := 50;
          assert {:msg "  242.6: The precondition at 752.12 might not hold. Insufficient fraction at 752.25 for AVLTreeNode.balanceFactor."} (fraction#_283 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_283 == exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_275[Heap[this#105, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_283];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_275);
        } else {
        }
        assert {:msg "  242.6: The precondition at 755.12 might not hold. The expression at 755.12 might not evaluate to true."} !(Heap[this#105, AVLTreeNode.right] == null);
        fraction#_284 := 100;
        assert {:msg "  242.6: The precondition at 756.12 might not hold. Insufficient fraction at 756.12 for AVLTreeNode.valid."} (fraction#_284 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_284 == exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_284];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        fraction#_285 := 50;
        assert {:msg "  242.6: The precondition at 757.12 might not hold. Insufficient fraction at 757.12 for AVLTreeNode.height."} (fraction#_285 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_285 == exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_285];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        fraction#_286 := 50;
        assert {:msg "  242.6: The precondition at 759.12 might not hold. Insufficient fraction at 759.12 for AVLTreeNode.balanceFactor."} (fraction#_286 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_286 == exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_275[Heap[this#105, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_286];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_275);
        assert {:msg "  242.6: The precondition at 763.12 might not hold. The expression at 763.12 might not evaluate to true."} (ite(Heap[this#105, AVLTreeNode.left] == null, 0, Heap[Heap[this#105, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#105, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
        Mask := exhaleMask#_275;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#106;
        // inhale (postcondition)
        havoc inhaleHeap#_289;
        assume IsGoodInhaleState(inhaleHeap#_289, Heap, Mask);
        assume r#106 != null;
        Heap[r#106, AVLTreeNode.valid] := inhaleHeap#_289[r#106, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_289[r#106, AVLTreeNode.valid] == Heap;
        Mask[r#106, AVLTreeNode.valid] := Mask[r#106, AVLTreeNode.valid][perm$R := Mask[r#106, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_289[r#106, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_289, Mask);
        assume r#106 != null;
        Heap[r#106, AVLTreeNode.height] := inhaleHeap#_289[r#106, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#106, AVLTreeNode.height] := Mask[r#106, AVLTreeNode.height][perm$R := Mask[r#106, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_289[r#106, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_289, Mask);
        assume r#106 != null;
        Heap[r#106, AVLTreeNode.balanceFactor] := inhaleHeap#_289[r#106, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[r#106, AVLTreeNode.balanceFactor] := Mask[r#106, AVLTreeNode.balanceFactor][perm$R := Mask[r#106, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_289[r#106, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_289, Mask);
        assume (Heap[r#106, AVLTreeNode.height] == callHeap#_272[callHeap#_272[this#105, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#106, AVLTreeNode.height] == (callHeap#_272[callHeap#_272[this#105, AVLTreeNode.right], AVLTreeNode.height] + 1));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        r#10 := r#106;
      } else {
        // assigment to r
        r#10 := this;
        // call close
        callHeap#_290 := Heap;
        callMask#_291 := Mask;
        callCredits#_292 := Credits;
        assert {:msg "  245.6: The target of the method call might be null."} r#10 != null;
        this#107 := r#10;
        // begin exhale (precondition)
        exhaleMask#_293 := Mask;
        fraction#_294 := 100;
        assert {:msg "  245.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_294 <= exhaleMask#_293[this#107, AVLTreeNode.key][perm$R]) && ((fraction#_294 == exhaleMask#_293[this#107, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_293[this#107, AVLTreeNode.key][perm$N]));
        exhaleMask#_293[this#107, AVLTreeNode.key] := exhaleMask#_293[this#107, AVLTreeNode.key][perm$R := exhaleMask#_293[this#107, AVLTreeNode.key][perm$R] - fraction#_294];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_293);
        fraction#_295 := 100;
        assert {:msg "  245.6: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_295 <= exhaleMask#_293[this#107, AVLTreeNode.height][perm$R]) && ((fraction#_295 == exhaleMask#_293[this#107, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_293[this#107, AVLTreeNode.height][perm$N]));
        exhaleMask#_293[this#107, AVLTreeNode.height] := exhaleMask#_293[this#107, AVLTreeNode.height][perm$R := exhaleMask#_293[this#107, AVLTreeNode.height][perm$R] - fraction#_295];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_293);
        fraction#_296 := 100;
        assert {:msg "  245.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_296 <= exhaleMask#_293[this#107, AVLTreeNode.left][perm$R]) && ((fraction#_296 == exhaleMask#_293[this#107, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_293[this#107, AVLTreeNode.left][perm$N]));
        exhaleMask#_293[this#107, AVLTreeNode.left] := exhaleMask#_293[this#107, AVLTreeNode.left][perm$R := exhaleMask#_293[this#107, AVLTreeNode.left][perm$R] - fraction#_296];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_293);
        fraction#_297 := 100;
        assert {:msg "  245.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_297 <= exhaleMask#_293[this#107, AVLTreeNode.right][perm$R]) && ((fraction#_297 == exhaleMask#_293[this#107, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_293[this#107, AVLTreeNode.right][perm$N]));
        exhaleMask#_293[this#107, AVLTreeNode.right] := exhaleMask#_293[this#107, AVLTreeNode.right][perm$R := exhaleMask#_293[this#107, AVLTreeNode.right][perm$R] - fraction#_297];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_293);
        fraction#_298 := 100;
        assert {:msg "  245.6: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_298 <= exhaleMask#_293[this#107, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_298 == exhaleMask#_293[this#107, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_293[this#107, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_293[this#107, AVLTreeNode.balanceFactor] := exhaleMask#_293[this#107, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_293[this#107, AVLTreeNode.balanceFactor][perm$R] - fraction#_298];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_293);
        if (!(Heap[this#107, AVLTreeNode.left] == null)) {
          fraction#_299 := 100;
          assert {:msg "  245.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_299 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_299 == exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_299];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_293);
        } else {
        }
        if (!(Heap[this#107, AVLTreeNode.left] == null)) {
          fraction#_300 := 50;
          assert {:msg "  245.6: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_300 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_300 == exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_300];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_293);
        } else {
        }
        if (!(Heap[this#107, AVLTreeNode.left] == null)) {
          fraction#_301 := 50;
          assert {:msg "  245.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_301 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_301 == exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_293[Heap[this#107, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_301];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_293);
        } else {
        }
        if (!(Heap[this#107, AVLTreeNode.right] == null)) {
          fraction#_302 := 100;
          assert {:msg "  245.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_302 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_302 == exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_302];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_293);
        } else {
        }
        if (!(Heap[this#107, AVLTreeNode.right] == null)) {
          fraction#_303 := 50;
          assert {:msg "  245.6: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_303 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_303 == exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_303];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_293);
        } else {
        }
        if (!(Heap[this#107, AVLTreeNode.right] == null)) {
          fraction#_304 := 50;
          assert {:msg "  245.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_304 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_304 == exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_293[Heap[this#107, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_304];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_293);
        } else {
        }
        assert {:msg "  245.6: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#107, AVLTreeNode.left] == null, 0, Heap[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#107, AVLTreeNode.right] == null, 0, Heap[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  245.6: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#107, AVLTreeNode.left] == null, 0, Heap[Heap[this#107, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#107, AVLTreeNode.right] == null, 0, Heap[Heap[this#107, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        Mask := exhaleMask#_293;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_307;
        assume IsGoodInhaleState(inhaleHeap#_307, Heap, Mask);
        assume this#107 != null;
        Heap[this#107, AVLTreeNode.valid] := inhaleHeap#_307[this#107, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_307[this#107, AVLTreeNode.valid] == Heap;
        Mask[this#107, AVLTreeNode.valid] := Mask[this#107, AVLTreeNode.valid][perm$R := Mask[this#107, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_307[this#107, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_307, Mask);
        assume this#107 != null;
        Heap[this#107, AVLTreeNode.height] := inhaleHeap#_307[this#107, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#107, AVLTreeNode.height] := Mask[this#107, AVLTreeNode.height][perm$R := Mask[this#107, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_307[this#107, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_307, Mask);
        assume this#107 != null;
        Heap[this#107, AVLTreeNode.balanceFactor] := inhaleHeap#_307[this#107, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#107, AVLTreeNode.balanceFactor] := Mask[this#107, AVLTreeNode.balanceFactor][perm$R := Mask[this#107, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_307[this#107, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_307, Mask);
        assume Heap[this#107, AVLTreeNode.height] == ite(ite(callHeap#_290[this#107, AVLTreeNode.left] == null, 0, callHeap#_290[callHeap#_290[this#107, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_290[this#107, AVLTreeNode.right] == null, 0, callHeap#_290[callHeap#_290[this#107, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_290[this#107, AVLTreeNode.left] == null, 0, callHeap#_290[callHeap#_290[this#107, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_290[this#107, AVLTreeNode.right] == null, 0, callHeap#_290[callHeap#_290[this#107, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#107, AVLTreeNode.balanceFactor] == (ite(callHeap#_290[this#107, AVLTreeNode.left] == null, 0, callHeap#_290[callHeap#_290[this#107, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_290[this#107, AVLTreeNode.right] == null, 0, callHeap#_290[callHeap#_290[this#107, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_308 := Mask;
  assert {:msg "  184.2: The postcondition at 190.11 might not hold. The expression at 190.11 might not evaluate to true."} !(r#10 == null);
  fraction#_309 := 100;
  assert {:msg "  184.2: The postcondition at 191.11 might not hold. Insufficient fraction at 191.11 for AVLTreeNode.valid."} (fraction#_309 <= exhaleMask#_308[r#10, AVLTreeNode.valid][perm$R]) && ((fraction#_309 == exhaleMask#_308[r#10, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_308[r#10, AVLTreeNode.valid][perm$N]));
  exhaleMask#_308[r#10, AVLTreeNode.valid] := exhaleMask#_308[r#10, AVLTreeNode.valid][perm$R := exhaleMask#_308[r#10, AVLTreeNode.valid][perm$R] - fraction#_309];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_308);
  fraction#_310 := 50;
  assert {:msg "  184.2: The postcondition at 193.11 might not hold. Insufficient fraction at 193.11 for AVLTreeNode.height."} (fraction#_310 <= exhaleMask#_308[r#10, AVLTreeNode.height][perm$R]) && ((fraction#_310 == exhaleMask#_308[r#10, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_308[r#10, AVLTreeNode.height][perm$N]));
  exhaleMask#_308[r#10, AVLTreeNode.height] := exhaleMask#_308[r#10, AVLTreeNode.height][perm$R := exhaleMask#_308[r#10, AVLTreeNode.height][perm$R] - fraction#_310];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_308);
  fraction#_311 := 50;
  assert {:msg "  184.2: The postcondition at 194.11 might not hold. Insufficient fraction at 194.11 for AVLTreeNode.balanceFactor."} (fraction#_311 <= exhaleMask#_308[r#10, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_311 == exhaleMask#_308[r#10, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_308[r#10, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_308[r#10, AVLTreeNode.balanceFactor] := exhaleMask#_308[r#10, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_308[r#10, AVLTreeNode.balanceFactor][perm$R] - fraction#_311];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_308);
  assert {:msg "  184.2: The postcondition at 202.11 might not hold. The expression at 202.11 might not evaluate to true."} (Heap[r#10, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#10, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] + 1));
  Mask := exhaleMask#_308;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  184.2: Method might lock/unlock more than allowed."} (forall lk#_312: ref :: {Heap[lk#_312, held]} {Heap[lk#_312, rdheld]} (((0 < Heap[lk#_312, held]) == (0 < old(Heap)[lk#_312, held])) && (Heap[lk#_312, rdheld] == old(Heap)[lk#_312, rdheld])) || false);
  assert {:msg "  184.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.remove$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_313: HeapType;
  var inhaleHeap#_314: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_313;
  assume IsGoodInhaleState(inhaleHeap#_313, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_313[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_313[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_313[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_313, Mask);
  assert {:msg "  256.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  256.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_313[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_313[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_313, Mask);
  assert {:msg "  257.30: Fraction might be negative."} 0 <= 50;
  assert {:msg "  257.30: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_313[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_313[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_313, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_314;
  assume IsGoodInhaleState(inhaleHeap#_314, Heap, Mask);
  if (!(r#20 == null)) {
    assume r#20 != null;
    Heap[r#20, AVLTreeNode.valid] := inhaleHeap#_314[r#20, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_314[r#20, AVLTreeNode.valid] == Heap;
    Mask[r#20, AVLTreeNode.valid] := Mask[r#20, AVLTreeNode.valid][perm$R := Mask[r#20, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_314[r#20, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_314, Mask);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  264.38: Fraction might be negative."} 0 <= 50;
    assert {:msg "  264.38: Fraction might exceed 100."} 50 <= 100;
    assume r#20 != null;
    Heap[r#20, AVLTreeNode.height] := inhaleHeap#_314[r#20, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#20, AVLTreeNode.height] := Mask[r#20, AVLTreeNode.height][perm$R := Mask[r#20, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_314[r#20, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_314, Mask);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  265.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  265.45: Fraction might exceed 100."} 50 <= 100;
    assume r#20 != null;
    Heap[r#20, AVLTreeNode.balanceFactor] := inhaleHeap#_314[r#20, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#20, AVLTreeNode.balanceFactor] := Mask[r#20, AVLTreeNode.balanceFactor][perm$R := Mask[r#20, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_314[r#20, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_314, Mask);
  } else {
  }
  assert {:msg "  273.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  273.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#20 == null);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  274.25: Receiver might be null."} true ==> (r#20 != null);
    assert {:msg "  274.25: Location might not be readable."} true ==> CanRead(Mask, r#20, AVLTreeNode.height);
    assert {:msg "  274.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  274.39: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assert {:msg "  274.50: Receiver might be null."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#20 != null);
    assert {:msg "  274.50: Location might not be readable."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#20, AVLTreeNode.height);
    assert {:msg "  274.66: Receiver might be null."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  274.66: Location might not be readable."} true && (!(Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume (Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#20, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.remove(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#19: int where true) returns (r#20: ref where (r#20 == null) || (dtype(r#20) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_315: HeapType;
  var exhaleMask#_316: MaskType;
  var fraction#_317: int;
  var inhaleHeap#_318: HeapType;
  var bf#22: int where true;
  var nl#24: ref where (nl#24 == null) || (dtype(nl#24) == AVLTreeNode#t);
  var nr#26: ref where (nr#26 == null) || (dtype(nr#26) == AVLTreeNode#t);
  var this#108: ref where (this#108 == null) || (dtype(this#108) == AVLTreeNode#t);
  var bf#109: int where true;
  var callHeap#_319: HeapType;
  var callMask#_320: MaskType;
  var callCredits#_321: CreditsType;
  var exhaleMask#_322: MaskType;
  var epsilons#_323: int;
  var fraction#_324: int;
  var epsilons#_325: int;
  var epsilons#_326: int;
  var fraction#_327: int;
  var epsilons#_328: int;
  var isHeld#_329: int;
  var isRdHeld#_330: bool;
  var inhaleHeap#_331: HeapType;
  var this#110: ref where (this#110 == null) || (dtype(this#110) == AVLTreeNode#t);
  var r#111: ref where (r#111 == null) || (dtype(r#111) == AVLTreeNode#t);
  var m#112: ref where (m#112 == null) || (dtype(m#112) == AVLTreeNode#t);
  var callHeap#_332: HeapType;
  var callMask#_333: MaskType;
  var callCredits#_334: CreditsType;
  var exhaleMask#_335: MaskType;
  var fraction#_336: int;
  var fraction#_337: int;
  var fraction#_338: int;
  var isHeld#_339: int;
  var isRdHeld#_340: bool;
  var inhaleHeap#_341: HeapType;
  var this#113: ref where (this#113 == null) || (dtype(this#113) == AVLTreeNode#t);
  var r#114: ref where (r#114 == null) || (dtype(r#114) == AVLTreeNode#t);
  var m#115: ref where (m#115 == null) || (dtype(m#115) == AVLTreeNode#t);
  var callHeap#_342: HeapType;
  var callMask#_343: MaskType;
  var callCredits#_344: CreditsType;
  var exhaleMask#_345: MaskType;
  var fraction#_346: int;
  var fraction#_347: int;
  var fraction#_348: int;
  var isHeld#_349: int;
  var isRdHeld#_350: bool;
  var inhaleHeap#_351: HeapType;
  var exhaleMask#_352: MaskType;
  var fraction#_353: int;
  var inhaleHeap#_354: HeapType;
  var this#116: ref where (this#116 == null) || (dtype(this#116) == AVLTreeNode#t);
  var callHeap#_355: HeapType;
  var callMask#_356: MaskType;
  var callCredits#_357: CreditsType;
  var exhaleMask#_358: MaskType;
  var fraction#_359: int;
  var fraction#_360: int;
  var fraction#_361: int;
  var fraction#_362: int;
  var fraction#_363: int;
  var fraction#_364: int;
  var fraction#_365: int;
  var fraction#_366: int;
  var fraction#_367: int;
  var fraction#_368: int;
  var fraction#_369: int;
  var isHeld#_370: int;
  var isRdHeld#_371: bool;
  var inhaleHeap#_372: HeapType;
  var nl#28: ref where (nl#28 == null) || (dtype(nl#28) == AVLTreeNode#t);
  var this#117: ref where (this#117 == null) || (dtype(this#117) == AVLTreeNode#t);
  var k#118: int where true;
  var r#119: ref where (r#119 == null) || (dtype(r#119) == AVLTreeNode#t);
  var callHeap#_373: HeapType;
  var callMask#_374: MaskType;
  var callCredits#_375: CreditsType;
  var exhaleMask#_376: MaskType;
  var fraction#_377: int;
  var fraction#_378: int;
  var fraction#_379: int;
  var isHeld#_380: int;
  var isRdHeld#_381: bool;
  var inhaleHeap#_382: HeapType;
  var bf#30: int where true;
  var this#120: ref where (this#120 == null) || (dtype(this#120) == AVLTreeNode#t);
  var bf#121: int where true;
  var callHeap#_383: HeapType;
  var callMask#_384: MaskType;
  var callCredits#_385: CreditsType;
  var exhaleMask#_386: MaskType;
  var epsilons#_387: int;
  var fraction#_388: int;
  var epsilons#_389: int;
  var epsilons#_390: int;
  var fraction#_391: int;
  var epsilons#_392: int;
  var isHeld#_393: int;
  var isRdHeld#_394: bool;
  var inhaleHeap#_395: HeapType;
  var this#122: ref where (this#122 == null) || (dtype(this#122) == AVLTreeNode#t);
  var r#123: ref where (r#123 == null) || (dtype(r#123) == AVLTreeNode#t);
  var callHeap#_396: HeapType;
  var callMask#_397: MaskType;
  var callCredits#_398: CreditsType;
  var exhaleMask#_399: MaskType;
  var fraction#_400: int;
  var fraction#_401: int;
  var fraction#_402: int;
  var fraction#_403: int;
  var fraction#_404: int;
  var fraction#_405: int;
  var fraction#_406: int;
  var fraction#_407: int;
  var fraction#_408: int;
  var fraction#_409: int;
  var fraction#_410: int;
  var isHeld#_411: int;
  var isRdHeld#_412: bool;
  var inhaleHeap#_413: HeapType;
  var this#124: ref where (this#124 == null) || (dtype(this#124) == AVLTreeNode#t);
  var callHeap#_414: HeapType;
  var callMask#_415: MaskType;
  var callCredits#_416: CreditsType;
  var exhaleMask#_417: MaskType;
  var fraction#_418: int;
  var fraction#_419: int;
  var fraction#_420: int;
  var fraction#_421: int;
  var fraction#_422: int;
  var fraction#_423: int;
  var fraction#_424: int;
  var fraction#_425: int;
  var fraction#_426: int;
  var fraction#_427: int;
  var fraction#_428: int;
  var isHeld#_429: int;
  var isRdHeld#_430: bool;
  var inhaleHeap#_431: HeapType;
  var this#125: ref where (this#125 == null) || (dtype(this#125) == AVLTreeNode#t);
  var callHeap#_432: HeapType;
  var callMask#_433: MaskType;
  var callCredits#_434: CreditsType;
  var exhaleMask#_435: MaskType;
  var fraction#_436: int;
  var fraction#_437: int;
  var fraction#_438: int;
  var fraction#_439: int;
  var fraction#_440: int;
  var fraction#_441: int;
  var fraction#_442: int;
  var fraction#_443: int;
  var fraction#_444: int;
  var fraction#_445: int;
  var fraction#_446: int;
  var isHeld#_447: int;
  var isRdHeld#_448: bool;
  var inhaleHeap#_449: HeapType;
  var nr#32: ref where (nr#32 == null) || (dtype(nr#32) == AVLTreeNode#t);
  var this#126: ref where (this#126 == null) || (dtype(this#126) == AVLTreeNode#t);
  var k#127: int where true;
  var r#128: ref where (r#128 == null) || (dtype(r#128) == AVLTreeNode#t);
  var callHeap#_450: HeapType;
  var callMask#_451: MaskType;
  var callCredits#_452: CreditsType;
  var exhaleMask#_453: MaskType;
  var fraction#_454: int;
  var fraction#_455: int;
  var fraction#_456: int;
  var isHeld#_457: int;
  var isRdHeld#_458: bool;
  var inhaleHeap#_459: HeapType;
  var bf#34: int where true;
  var this#129: ref where (this#129 == null) || (dtype(this#129) == AVLTreeNode#t);
  var bf#130: int where true;
  var callHeap#_460: HeapType;
  var callMask#_461: MaskType;
  var callCredits#_462: CreditsType;
  var exhaleMask#_463: MaskType;
  var epsilons#_464: int;
  var fraction#_465: int;
  var epsilons#_466: int;
  var epsilons#_467: int;
  var fraction#_468: int;
  var epsilons#_469: int;
  var isHeld#_470: int;
  var isRdHeld#_471: bool;
  var inhaleHeap#_472: HeapType;
  var this#131: ref where (this#131 == null) || (dtype(this#131) == AVLTreeNode#t);
  var r#132: ref where (r#132 == null) || (dtype(r#132) == AVLTreeNode#t);
  var callHeap#_473: HeapType;
  var callMask#_474: MaskType;
  var callCredits#_475: CreditsType;
  var exhaleMask#_476: MaskType;
  var fraction#_477: int;
  var fraction#_478: int;
  var fraction#_479: int;
  var fraction#_480: int;
  var fraction#_481: int;
  var fraction#_482: int;
  var fraction#_483: int;
  var fraction#_484: int;
  var fraction#_485: int;
  var fraction#_486: int;
  var fraction#_487: int;
  var isHeld#_488: int;
  var isRdHeld#_489: bool;
  var inhaleHeap#_490: HeapType;
  var this#133: ref where (this#133 == null) || (dtype(this#133) == AVLTreeNode#t);
  var callHeap#_491: HeapType;
  var callMask#_492: MaskType;
  var callCredits#_493: CreditsType;
  var exhaleMask#_494: MaskType;
  var fraction#_495: int;
  var fraction#_496: int;
  var fraction#_497: int;
  var fraction#_498: int;
  var fraction#_499: int;
  var fraction#_500: int;
  var fraction#_501: int;
  var fraction#_502: int;
  var fraction#_503: int;
  var fraction#_504: int;
  var fraction#_505: int;
  var isHeld#_506: int;
  var isRdHeld#_507: bool;
  var inhaleHeap#_508: HeapType;
  var this#134: ref where (this#134 == null) || (dtype(this#134) == AVLTreeNode#t);
  var callHeap#_509: HeapType;
  var callMask#_510: MaskType;
  var callCredits#_511: CreditsType;
  var exhaleMask#_512: MaskType;
  var fraction#_513: int;
  var fraction#_514: int;
  var fraction#_515: int;
  var fraction#_516: int;
  var fraction#_517: int;
  var fraction#_518: int;
  var fraction#_519: int;
  var fraction#_520: int;
  var fraction#_521: int;
  var fraction#_522: int;
  var fraction#_523: int;
  var isHeld#_524: int;
  var isRdHeld#_525: bool;
  var inhaleHeap#_526: HeapType;
  var exhaleMask#_527: MaskType;
  var fraction#_528: int;
  var fraction#_529: int;
  var fraction#_530: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_315;
  assume IsGoodInhaleState(inhaleHeap#_315, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_315[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_315[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_315[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_315[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  277.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_316 := Mask;
  fraction#_317 := 100;
  assert {:msg "  277.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_317 <= exhaleMask#_316[this, AVLTreeNode.valid][perm$R]) && ((fraction#_317 == exhaleMask#_316[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_316[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_316[this, AVLTreeNode.valid] := exhaleMask#_316[this, AVLTreeNode.valid][perm$R := exhaleMask#_316[this, AVLTreeNode.valid][perm$R] - fraction#_317];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_316);
  Mask := exhaleMask#_316;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_318 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_318, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_318[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_318[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_318, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_318[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_318[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_318, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_318[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_318[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_318, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_318[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_318[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_318, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_318[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_318[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_318, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_318, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_318, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_318[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_318, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_318, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_318, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_318[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_318, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  278.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  278.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (Heap[this, AVLTreeNode.key] == k#19) {
    // if
    assert {:msg "  279.8: Receiver might be null."} true ==> (this != null);
    assert {:msg "  279.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  279.22: Receiver might be null."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> (this != null);
    assert {:msg "  279.22: Location might not be readable."} true && (!(Heap[this, AVLTreeNode.left] == null)) ==> CanRead(Mask, this, AVLTreeNode.right);
    if ((Heap[this, AVLTreeNode.left] == null) || (Heap[this, AVLTreeNode.right] == null)) {
      // if
      assert {:msg "  282.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  282.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (Heap[this, AVLTreeNode.left] == null) {
        // assigment to r
        assert {:msg "  283.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  283.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        r#20 := Heap[this, AVLTreeNode.right];
      } else {
        // assigment to r
        assert {:msg "  285.11: Receiver might be null."} true ==> (this != null);
        assert {:msg "  285.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        r#20 := Heap[this, AVLTreeNode.left];
      }
    } else {
      // local var bf
      // local var nl
      // assigment to nl
      assert {:msg "  289.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  289.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      nl#24 := Heap[this, AVLTreeNode.left];
      // local var nr
      // assigment to nr
      assert {:msg "  290.29: Receiver might be null."} true ==> (this != null);
      assert {:msg "  290.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      nr#26 := Heap[this, AVLTreeNode.right];
      // call getBalanceFactorI
      callHeap#_319 := Heap;
      callMask#_320 := Mask;
      callCredits#_321 := Credits;
      assert {:msg "  292.5: The target of the method call might be null."} this != null;
      this#108 := this;
      // begin exhale (precondition)
      exhaleMask#_322 := Mask;
      epsilons#_323 := 1;
      assert {:msg "  292.5: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_322[this#108, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_323 <= exhaleMask#_322[this#108, AVLTreeNode.left][perm$N]);
      if ((exhaleMask#_322[this#108, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_322[this#108, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_322[this#108, AVLTreeNode.left] := exhaleMask#_322[this#108, AVLTreeNode.left][perm$N := exhaleMask#_322[this#108, AVLTreeNode.left][perm$N] - epsilons#_323];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_322);
      if (!(Heap[this#108, AVLTreeNode.left] == null)) {
        fraction#_324 := 100;
        assert {:msg "  292.5: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_324 <= exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_324 == exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_324];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_322);
      } else {
      }
      if (!(Heap[this#108, AVLTreeNode.left] == null)) {
        epsilons#_325 := 1;
        assert {:msg "  292.5: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_325 <= exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
        if ((exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_322[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_325];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_322);
      } else {
      }
      epsilons#_326 := 1;
      assert {:msg "  292.5: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_322[this#108, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_326 <= exhaleMask#_322[this#108, AVLTreeNode.right][perm$N]);
      if ((exhaleMask#_322[this#108, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_322[this#108, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_322[this#108, AVLTreeNode.right] := exhaleMask#_322[this#108, AVLTreeNode.right][perm$N := exhaleMask#_322[this#108, AVLTreeNode.right][perm$N] - epsilons#_326];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_322);
      if (!(Heap[this#108, AVLTreeNode.right] == null)) {
        fraction#_327 := 100;
        assert {:msg "  292.5: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_327 <= exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_327 == exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_327];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_322);
      } else {
      }
      if (!(Heap[this#108, AVLTreeNode.right] == null)) {
        epsilons#_328 := 1;
        assert {:msg "  292.5: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_328 <= exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
        if ((exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_322[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_328];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_322);
      } else {
      }
      Mask := exhaleMask#_322;
      assume wf(Heap, Mask);
      // end exhale
      havoc bf#109;
      // inhale (postcondition)
      havoc inhaleHeap#_331;
      assume IsGoodInhaleState(inhaleHeap#_331, Heap, Mask);
      assume this#108 != null;
      Heap[this#108, AVLTreeNode.left] := inhaleHeap#_331[this#108, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[this#108, AVLTreeNode.left] == null) || (dtype(Heap[this#108, AVLTreeNode.left]) == AVLTreeNode#t);
      if ((Mask[this#108, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#108, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
        Mask[this#108, AVLTreeNode.left] := Mask[this#108, AVLTreeNode.left][perm$N := Mask[this#108, AVLTreeNode.left][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_331[this#108, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_331, Mask);
      if (!(Heap[this#108, AVLTreeNode.left] == null)) {
        assume Heap[this#108, AVLTreeNode.left] != null;
        Heap[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_331[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_331[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_331[Heap[this#108, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_331, Mask);
      } else {
      }
      if (!(Heap[this#108, AVLTreeNode.left] == null)) {
        assume Heap[this#108, AVLTreeNode.left] != null;
        Heap[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_331[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_331[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_331, Mask);
      } else {
      }
      assume this#108 != null;
      Heap[this#108, AVLTreeNode.right] := inhaleHeap#_331[this#108, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[this#108, AVLTreeNode.right] == null) || (dtype(Heap[this#108, AVLTreeNode.right]) == AVLTreeNode#t);
      if ((Mask[this#108, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#108, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
        Mask[this#108, AVLTreeNode.right] := Mask[this#108, AVLTreeNode.right][perm$N := Mask[this#108, AVLTreeNode.right][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_331[this#108, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_331, Mask);
      if (!(Heap[this#108, AVLTreeNode.right] == null)) {
        assume Heap[this#108, AVLTreeNode.right] != null;
        Heap[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_331[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_331[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_331[Heap[this#108, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_331, Mask);
      } else {
      }
      if (!(Heap[this#108, AVLTreeNode.right] == null)) {
        assume Heap[this#108, AVLTreeNode.right] != null;
        Heap[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_331[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        if ((Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
          Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_331[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_331, Mask);
      } else {
      }
      assume bf#109 == (ite(Heap[this#108, AVLTreeNode.left] == null, 0, Heap[Heap[this#108, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#108, AVLTreeNode.right] == null, 0, Heap[Heap[this#108, AVLTreeNode.right], AVLTreeNode.height]));
      if (bf#109 > 0) {
        assume !(Heap[this#108, AVLTreeNode.left] == null);
      } else {
      }
      if (bf#109 < 0) {
        assume !(Heap[this#108, AVLTreeNode.right] == null);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      bf#22 := bf#109;
      // if
      if (bf#22 > 0) {
        // call pruneMax
        callHeap#_332 := Heap;
        callMask#_333 := Mask;
        callCredits#_334 := Credits;
        assert {:msg "  294.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  294.19: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  294.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#110 := Heap[this, AVLTreeNode.left];
        // begin exhale (precondition)
        exhaleMask#_335 := Mask;
        fraction#_336 := 100;
        assert {:msg "  294.6: The precondition at 348.12 might not hold. Insufficient fraction at 348.12 for AVLTreeNode.valid."} (fraction#_336 <= exhaleMask#_335[this#110, AVLTreeNode.valid][perm$R]) && ((fraction#_336 == exhaleMask#_335[this#110, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_335[this#110, AVLTreeNode.valid][perm$N]));
        exhaleMask#_335[this#110, AVLTreeNode.valid] := exhaleMask#_335[this#110, AVLTreeNode.valid][perm$R := exhaleMask#_335[this#110, AVLTreeNode.valid][perm$R] - fraction#_336];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_335);
        fraction#_337 := 50;
        assert {:msg "  294.6: The precondition at 350.12 might not hold. Insufficient fraction at 350.12 for AVLTreeNode.height."} (fraction#_337 <= exhaleMask#_335[this#110, AVLTreeNode.height][perm$R]) && ((fraction#_337 == exhaleMask#_335[this#110, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_335[this#110, AVLTreeNode.height][perm$N]));
        exhaleMask#_335[this#110, AVLTreeNode.height] := exhaleMask#_335[this#110, AVLTreeNode.height][perm$R := exhaleMask#_335[this#110, AVLTreeNode.height][perm$R] - fraction#_337];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_335);
        fraction#_338 := 50;
        assert {:msg "  294.6: The precondition at 351.12 might not hold. Insufficient fraction at 351.12 for AVLTreeNode.balanceFactor."} (fraction#_338 <= exhaleMask#_335[this#110, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_338 == exhaleMask#_335[this#110, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_335[this#110, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_335[this#110, AVLTreeNode.balanceFactor] := exhaleMask#_335[this#110, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_335[this#110, AVLTreeNode.balanceFactor][perm$R] - fraction#_338];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_335);
        Mask := exhaleMask#_335;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#111;
        havoc m#112;
        // inhale (postcondition)
        havoc inhaleHeap#_341;
        assume IsGoodInhaleState(inhaleHeap#_341, Heap, Mask);
        if (!(r#111 == null)) {
          assume r#111 != null;
          Heap[r#111, AVLTreeNode.valid] := inhaleHeap#_341[r#111, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_341[r#111, AVLTreeNode.valid] == Heap;
          Mask[r#111, AVLTreeNode.valid] := Mask[r#111, AVLTreeNode.valid][perm$R := Mask[r#111, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_341[r#111, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_341, Mask);
        } else {
        }
        if (!(r#111 == null)) {
          assume r#111 != null;
          Heap[r#111, AVLTreeNode.height] := inhaleHeap#_341[r#111, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#111, AVLTreeNode.height] := Mask[r#111, AVLTreeNode.height][perm$R := Mask[r#111, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_341[r#111, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_341, Mask);
        } else {
        }
        if (!(r#111 == null)) {
          assume r#111 != null;
          Heap[r#111, AVLTreeNode.balanceFactor] := inhaleHeap#_341[r#111, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#111, AVLTreeNode.balanceFactor] := Mask[r#111, AVLTreeNode.balanceFactor][perm$R := Mask[r#111, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_341[r#111, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_341, Mask);
        } else {
        }
        if (!(r#111 == null)) {
          assume (Heap[r#111, AVLTreeNode.height] == callHeap#_332[this#110, AVLTreeNode.height]) || ((Heap[r#111, AVLTreeNode.height] + 1) == callHeap#_332[this#110, AVLTreeNode.height]);
        } else {
        }
        if (callHeap#_332[this#110, AVLTreeNode.height] > 1) {
          assume !(r#111 == null);
        } else {
        }
        if (callHeap#_332[this#110, AVLTreeNode.height] == 1) {
          assume r#111 == null;
        } else {
        }
        assume (callHeap#_332[this#110, AVLTreeNode.height] == ite(r#111 == null, 0, Heap[r#111, AVLTreeNode.height])) || (callHeap#_332[this#110, AVLTreeNode.height] == (ite(r#111 == null, 0, Heap[r#111, AVLTreeNode.height]) + 1));
        assume !(m#112 == null);
        assume m#112 != null;
        Heap[m#112, AVLTreeNode.valid] := inhaleHeap#_341[m#112, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_341[m#112, AVLTreeNode.valid] == Heap;
        Mask[m#112, AVLTreeNode.valid] := Mask[m#112, AVLTreeNode.valid][perm$R := Mask[m#112, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_341[m#112, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_341, Mask);
        assume m#112 != null;
        Heap[m#112, AVLTreeNode.height] := inhaleHeap#_341[m#112, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[m#112, AVLTreeNode.height] := Mask[m#112, AVLTreeNode.height][perm$R := Mask[m#112, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_341[m#112, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_341, Mask);
        assume m#112 != null;
        Heap[m#112, AVLTreeNode.balanceFactor] := inhaleHeap#_341[m#112, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[m#112, AVLTreeNode.balanceFactor] := Mask[m#112, AVLTreeNode.balanceFactor][perm$R := Mask[m#112, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_341[m#112, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_341, Mask);
        assume Heap[m#112, AVLTreeNode.height] == 1;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nl#24 := r#111;
        r#20 := m#112;
      } else {
        // call pruneMin
        callHeap#_342 := Heap;
        callMask#_343 := Mask;
        callCredits#_344 := Credits;
        assert {:msg "  296.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  296.19: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  296.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#113 := Heap[this, AVLTreeNode.right];
        // begin exhale (precondition)
        exhaleMask#_345 := Mask;
        fraction#_346 := 100;
        assert {:msg "  296.6: The precondition at 402.12 might not hold. Insufficient fraction at 402.12 for AVLTreeNode.valid."} (fraction#_346 <= exhaleMask#_345[this#113, AVLTreeNode.valid][perm$R]) && ((fraction#_346 == exhaleMask#_345[this#113, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_345[this#113, AVLTreeNode.valid][perm$N]));
        exhaleMask#_345[this#113, AVLTreeNode.valid] := exhaleMask#_345[this#113, AVLTreeNode.valid][perm$R := exhaleMask#_345[this#113, AVLTreeNode.valid][perm$R] - fraction#_346];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_345);
        fraction#_347 := 50;
        assert {:msg "  296.6: The precondition at 404.12 might not hold. Insufficient fraction at 404.12 for AVLTreeNode.height."} (fraction#_347 <= exhaleMask#_345[this#113, AVLTreeNode.height][perm$R]) && ((fraction#_347 == exhaleMask#_345[this#113, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_345[this#113, AVLTreeNode.height][perm$N]));
        exhaleMask#_345[this#113, AVLTreeNode.height] := exhaleMask#_345[this#113, AVLTreeNode.height][perm$R := exhaleMask#_345[this#113, AVLTreeNode.height][perm$R] - fraction#_347];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_345);
        fraction#_348 := 50;
        assert {:msg "  296.6: The precondition at 405.12 might not hold. Insufficient fraction at 405.12 for AVLTreeNode.balanceFactor."} (fraction#_348 <= exhaleMask#_345[this#113, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_348 == exhaleMask#_345[this#113, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_345[this#113, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_345[this#113, AVLTreeNode.balanceFactor] := exhaleMask#_345[this#113, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_345[this#113, AVLTreeNode.balanceFactor][perm$R] - fraction#_348];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_345);
        Mask := exhaleMask#_345;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#114;
        havoc m#115;
        // inhale (postcondition)
        havoc inhaleHeap#_351;
        assume IsGoodInhaleState(inhaleHeap#_351, Heap, Mask);
        if (!(r#114 == null)) {
          assume r#114 != null;
          Heap[r#114, AVLTreeNode.valid] := inhaleHeap#_351[r#114, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_351[r#114, AVLTreeNode.valid] == Heap;
          Mask[r#114, AVLTreeNode.valid] := Mask[r#114, AVLTreeNode.valid][perm$R := Mask[r#114, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_351[r#114, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_351, Mask);
        } else {
        }
        if (!(r#114 == null)) {
          assume r#114 != null;
          Heap[r#114, AVLTreeNode.height] := inhaleHeap#_351[r#114, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#114, AVLTreeNode.height] := Mask[r#114, AVLTreeNode.height][perm$R := Mask[r#114, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_351[r#114, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_351, Mask);
        } else {
        }
        if (!(r#114 == null)) {
          assume r#114 != null;
          Heap[r#114, AVLTreeNode.balanceFactor] := inhaleHeap#_351[r#114, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#114, AVLTreeNode.balanceFactor] := Mask[r#114, AVLTreeNode.balanceFactor][perm$R := Mask[r#114, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_351[r#114, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_351, Mask);
        } else {
        }
        if (!(r#114 == null)) {
          assume (Heap[r#114, AVLTreeNode.height] == callHeap#_342[this#113, AVLTreeNode.height]) || (Heap[r#114, AVLTreeNode.height] == (callHeap#_342[this#113, AVLTreeNode.height] - 1));
        } else {
        }
        if (callHeap#_342[this#113, AVLTreeNode.height] > 1) {
          assume !(r#114 == null);
        } else {
        }
        if (callHeap#_342[this#113, AVLTreeNode.height] == 1) {
          assume r#114 == null;
        } else {
        }
        assume (callHeap#_342[this#113, AVLTreeNode.height] == ite(r#114 == null, 0, Heap[r#114, AVLTreeNode.height])) || (callHeap#_342[this#113, AVLTreeNode.height] == (ite(r#114 == null, 0, Heap[r#114, AVLTreeNode.height]) + 1));
        assume !(m#115 == null);
        assume m#115 != null;
        Heap[m#115, AVLTreeNode.valid] := inhaleHeap#_351[m#115, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_351[m#115, AVLTreeNode.valid] == Heap;
        Mask[m#115, AVLTreeNode.valid] := Mask[m#115, AVLTreeNode.valid][perm$R := Mask[m#115, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_351[m#115, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_351, Mask);
        assume m#115 != null;
        Heap[m#115, AVLTreeNode.height] := inhaleHeap#_351[m#115, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[m#115, AVLTreeNode.height] := Mask[m#115, AVLTreeNode.height][perm$R := Mask[m#115, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_351[m#115, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_351, Mask);
        assume m#115 != null;
        Heap[m#115, AVLTreeNode.balanceFactor] := inhaleHeap#_351[m#115, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[m#115, AVLTreeNode.balanceFactor] := Mask[m#115, AVLTreeNode.balanceFactor][perm$R := Mask[m#115, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_351[m#115, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_351, Mask);
        assume Heap[m#115, AVLTreeNode.height] == 1;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nr#26 := r#114;
        r#20 := m#115;
      }
      // unfold
      assert {:msg "  298.5: The target of the fold statement might be null."} r#20 != null;
      // begin exhale (unfold)
      exhaleMask#_352 := Mask;
      fraction#_353 := 100;
      assert {:msg "  298.5: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_353 <= exhaleMask#_352[r#20, AVLTreeNode.valid][perm$R]) && ((fraction#_353 == exhaleMask#_352[r#20, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_352[r#20, AVLTreeNode.valid][perm$N]));
      exhaleMask#_352[r#20, AVLTreeNode.valid] := exhaleMask#_352[r#20, AVLTreeNode.valid][perm$R := exhaleMask#_352[r#20, AVLTreeNode.valid][perm$R] - fraction#_353];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_352);
      Mask := exhaleMask#_352;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (unfold)
      inhaleHeap#_354 := Heap[r#20, AVLTreeNode.valid];
      assume IsGoodInhaleState(inhaleHeap#_354, Heap, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.key] := inhaleHeap#_354[r#20, AVLTreeNode.key];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#20, AVLTreeNode.key] := Mask[r#20, AVLTreeNode.key][perm$R := Mask[r#20, AVLTreeNode.key][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_354[r#20, AVLTreeNode.key]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_354, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.height] := inhaleHeap#_354[r#20, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#20, AVLTreeNode.height] := Mask[r#20, AVLTreeNode.height][perm$R := Mask[r#20, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_354[r#20, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_354, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.left] := inhaleHeap#_354[r#20, AVLTreeNode.left];
      assume wf(Heap, Mask);
      assume (Heap[r#20, AVLTreeNode.left] == null) || (dtype(Heap[r#20, AVLTreeNode.left]) == AVLTreeNode#t);
      Mask[r#20, AVLTreeNode.left] := Mask[r#20, AVLTreeNode.left][perm$R := Mask[r#20, AVLTreeNode.left][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_354[r#20, AVLTreeNode.left]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_354, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.right] := inhaleHeap#_354[r#20, AVLTreeNode.right];
      assume wf(Heap, Mask);
      assume (Heap[r#20, AVLTreeNode.right] == null) || (dtype(Heap[r#20, AVLTreeNode.right]) == AVLTreeNode#t);
      Mask[r#20, AVLTreeNode.right] := Mask[r#20, AVLTreeNode.right][perm$R := Mask[r#20, AVLTreeNode.right][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_354[r#20, AVLTreeNode.right]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_354, Mask);
      assume r#20 != null;
      Heap[r#20, AVLTreeNode.balanceFactor] := inhaleHeap#_354[r#20, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#20, AVLTreeNode.balanceFactor] := Mask[r#20, AVLTreeNode.balanceFactor][perm$R := Mask[r#20, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_354[r#20, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_354, Mask);
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_354, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_354, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[r#20, AVLTreeNode.left] != null;
        Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_354[Heap[r#20, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_354, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.left] == null)) {
        assume Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height] > 0;
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_354, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_354, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[r#20, AVLTreeNode.right] != null;
        Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_354[Heap[r#20, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_354, Mask);
      } else {
      }
      if (!(Heap[r#20, AVLTreeNode.right] == null)) {
        assume Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height] > 0;
      } else {
      }
      assume Heap[r#20, AVLTreeNode.height] == ite(ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[r#20, AVLTreeNode.balanceFactor] == (ite(Heap[r#20, AVLTreeNode.left] == null, 0, Heap[Heap[r#20, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#20, AVLTreeNode.right] == null, 0, Heap[Heap[r#20, AVLTreeNode.right], AVLTreeNode.height]));
      assume Heap[r#20, AVLTreeNode.balanceFactor] <= 1;
      assume Heap[r#20, AVLTreeNode.balanceFactor] >= (0 - 1);
      assume Heap[r#20, AVLTreeNode.height] > 0;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // update field left
      assert {:msg "  299.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.left);
      Heap[r#20, AVLTreeNode.left] := nl#24;
      assume wf(Heap, Mask);
      // update field right
      assert {:msg "  300.5: Location might not be writable"} CanWrite(Mask, r#20, AVLTreeNode.right);
      Heap[r#20, AVLTreeNode.right] := nr#26;
      assume wf(Heap, Mask);
      // call close
      callHeap#_355 := Heap;
      callMask#_356 := Mask;
      callCredits#_357 := Credits;
      assert {:msg "  301.5: The target of the method call might be null."} r#20 != null;
      this#116 := r#20;
      // begin exhale (precondition)
      exhaleMask#_358 := Mask;
      fraction#_359 := 100;
      assert {:msg "  301.5: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_359 <= exhaleMask#_358[this#116, AVLTreeNode.key][perm$R]) && ((fraction#_359 == exhaleMask#_358[this#116, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_358[this#116, AVLTreeNode.key][perm$N]));
      exhaleMask#_358[this#116, AVLTreeNode.key] := exhaleMask#_358[this#116, AVLTreeNode.key][perm$R := exhaleMask#_358[this#116, AVLTreeNode.key][perm$R] - fraction#_359];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_358);
      fraction#_360 := 100;
      assert {:msg "  301.5: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_360 <= exhaleMask#_358[this#116, AVLTreeNode.height][perm$R]) && ((fraction#_360 == exhaleMask#_358[this#116, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_358[this#116, AVLTreeNode.height][perm$N]));
      exhaleMask#_358[this#116, AVLTreeNode.height] := exhaleMask#_358[this#116, AVLTreeNode.height][perm$R := exhaleMask#_358[this#116, AVLTreeNode.height][perm$R] - fraction#_360];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_358);
      fraction#_361 := 100;
      assert {:msg "  301.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_361 <= exhaleMask#_358[this#116, AVLTreeNode.left][perm$R]) && ((fraction#_361 == exhaleMask#_358[this#116, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_358[this#116, AVLTreeNode.left][perm$N]));
      exhaleMask#_358[this#116, AVLTreeNode.left] := exhaleMask#_358[this#116, AVLTreeNode.left][perm$R := exhaleMask#_358[this#116, AVLTreeNode.left][perm$R] - fraction#_361];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_358);
      fraction#_362 := 100;
      assert {:msg "  301.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_362 <= exhaleMask#_358[this#116, AVLTreeNode.right][perm$R]) && ((fraction#_362 == exhaleMask#_358[this#116, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_358[this#116, AVLTreeNode.right][perm$N]));
      exhaleMask#_358[this#116, AVLTreeNode.right] := exhaleMask#_358[this#116, AVLTreeNode.right][perm$R := exhaleMask#_358[this#116, AVLTreeNode.right][perm$R] - fraction#_362];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_358);
      fraction#_363 := 100;
      assert {:msg "  301.5: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_363 <= exhaleMask#_358[this#116, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_363 == exhaleMask#_358[this#116, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_358[this#116, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_358[this#116, AVLTreeNode.balanceFactor] := exhaleMask#_358[this#116, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_358[this#116, AVLTreeNode.balanceFactor][perm$R] - fraction#_363];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_358);
      if (!(Heap[this#116, AVLTreeNode.left] == null)) {
        fraction#_364 := 100;
        assert {:msg "  301.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_364 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_364 == exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_364];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_358);
      } else {
      }
      if (!(Heap[this#116, AVLTreeNode.left] == null)) {
        fraction#_365 := 50;
        assert {:msg "  301.5: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_365 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_365 == exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_365];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_358);
      } else {
      }
      if (!(Heap[this#116, AVLTreeNode.left] == null)) {
        fraction#_366 := 50;
        assert {:msg "  301.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_366 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_366 == exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_358[Heap[this#116, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_366];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_358);
      } else {
      }
      if (!(Heap[this#116, AVLTreeNode.right] == null)) {
        fraction#_367 := 100;
        assert {:msg "  301.5: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_367 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_367 == exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_367];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_358);
      } else {
      }
      if (!(Heap[this#116, AVLTreeNode.right] == null)) {
        fraction#_368 := 50;
        assert {:msg "  301.5: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_368 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_368 == exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_368];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_358);
      } else {
      }
      if (!(Heap[this#116, AVLTreeNode.right] == null)) {
        fraction#_369 := 50;
        assert {:msg "  301.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_369 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_369 == exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_358[Heap[this#116, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_369];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_358);
      } else {
      }
      assert {:msg "  301.5: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#116, AVLTreeNode.left] == null, 0, Heap[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#116, AVLTreeNode.right] == null, 0, Heap[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  301.5: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#116, AVLTreeNode.left] == null, 0, Heap[Heap[this#116, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#116, AVLTreeNode.right] == null, 0, Heap[Heap[this#116, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      Mask := exhaleMask#_358;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_372;
      assume IsGoodInhaleState(inhaleHeap#_372, Heap, Mask);
      assume this#116 != null;
      Heap[this#116, AVLTreeNode.valid] := inhaleHeap#_372[this#116, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_372[this#116, AVLTreeNode.valid] == Heap;
      Mask[this#116, AVLTreeNode.valid] := Mask[this#116, AVLTreeNode.valid][perm$R := Mask[this#116, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_372[this#116, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_372, Mask);
      assume this#116 != null;
      Heap[this#116, AVLTreeNode.height] := inhaleHeap#_372[this#116, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#116, AVLTreeNode.height] := Mask[this#116, AVLTreeNode.height][perm$R := Mask[this#116, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_372[this#116, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_372, Mask);
      assume this#116 != null;
      Heap[this#116, AVLTreeNode.balanceFactor] := inhaleHeap#_372[this#116, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#116, AVLTreeNode.balanceFactor] := Mask[this#116, AVLTreeNode.balanceFactor][perm$R := Mask[this#116, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_372[this#116, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_372, Mask);
      assume Heap[this#116, AVLTreeNode.height] == ite(ite(callHeap#_355[this#116, AVLTreeNode.left] == null, 0, callHeap#_355[callHeap#_355[this#116, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_355[this#116, AVLTreeNode.right] == null, 0, callHeap#_355[callHeap#_355[this#116, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_355[this#116, AVLTreeNode.left] == null, 0, callHeap#_355[callHeap#_355[this#116, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_355[this#116, AVLTreeNode.right] == null, 0, callHeap#_355[callHeap#_355[this#116, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#116, AVLTreeNode.balanceFactor] == (ite(callHeap#_355[this#116, AVLTreeNode.left] == null, 0, callHeap#_355[callHeap#_355[this#116, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_355[this#116, AVLTreeNode.right] == null, 0, callHeap#_355[callHeap#_355[this#116, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
    }
  } else {
    // if
    assert {:msg "  304.10: Receiver might be null."} true ==> (this != null);
    assert {:msg "  304.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (k#19 < Heap[this, AVLTreeNode.key]) {
      // if
      assert {:msg "  305.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  305.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (!(Heap[this, AVLTreeNode.left] == null)) {
        // local var nl
        // call remove
        callHeap#_373 := Heap;
        callMask#_374 := Mask;
        callCredits#_375 := Credits;
        assert {:msg "  307.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  307.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  307.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#117 := Heap[this, AVLTreeNode.left];
        k#118 := k#19;
        // begin exhale (precondition)
        exhaleMask#_376 := Mask;
        fraction#_377 := 100;
        assert {:msg "  307.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (fraction#_377 <= exhaleMask#_376[this#117, AVLTreeNode.valid][perm$R]) && ((fraction#_377 == exhaleMask#_376[this#117, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_376[this#117, AVLTreeNode.valid][perm$N]));
        exhaleMask#_376[this#117, AVLTreeNode.valid] := exhaleMask#_376[this#117, AVLTreeNode.valid][perm$R := exhaleMask#_376[this#117, AVLTreeNode.valid][perm$R] - fraction#_377];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_376);
        fraction#_378 := 50;
        assert {:msg "  307.6: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} (fraction#_378 <= exhaleMask#_376[this#117, AVLTreeNode.height][perm$R]) && ((fraction#_378 == exhaleMask#_376[this#117, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_376[this#117, AVLTreeNode.height][perm$N]));
        exhaleMask#_376[this#117, AVLTreeNode.height] := exhaleMask#_376[this#117, AVLTreeNode.height][perm$R := exhaleMask#_376[this#117, AVLTreeNode.height][perm$R] - fraction#_378];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_376);
        fraction#_379 := 50;
        assert {:msg "  307.6: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} (fraction#_379 <= exhaleMask#_376[this#117, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_379 == exhaleMask#_376[this#117, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_376[this#117, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_376[this#117, AVLTreeNode.balanceFactor] := exhaleMask#_376[this#117, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_376[this#117, AVLTreeNode.balanceFactor][perm$R] - fraction#_379];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_376);
        Mask := exhaleMask#_376;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#119;
        // inhale (postcondition)
        havoc inhaleHeap#_382;
        assume IsGoodInhaleState(inhaleHeap#_382, Heap, Mask);
        if (!(r#119 == null)) {
          assume r#119 != null;
          Heap[r#119, AVLTreeNode.valid] := inhaleHeap#_382[r#119, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_382[r#119, AVLTreeNode.valid] == Heap;
          Mask[r#119, AVLTreeNode.valid] := Mask[r#119, AVLTreeNode.valid][perm$R := Mask[r#119, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_382[r#119, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_382, Mask);
        } else {
        }
        if (!(r#119 == null)) {
          assume r#119 != null;
          Heap[r#119, AVLTreeNode.height] := inhaleHeap#_382[r#119, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#119, AVLTreeNode.height] := Mask[r#119, AVLTreeNode.height][perm$R := Mask[r#119, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_382[r#119, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_382, Mask);
        } else {
        }
        if (!(r#119 == null)) {
          assume r#119 != null;
          Heap[r#119, AVLTreeNode.balanceFactor] := inhaleHeap#_382[r#119, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#119, AVLTreeNode.balanceFactor] := Mask[r#119, AVLTreeNode.balanceFactor][perm$R := Mask[r#119, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_382[r#119, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_382, Mask);
        } else {
        }
        if (callHeap#_373[this#117, AVLTreeNode.height] > 1) {
          assume !(r#119 == null);
        } else {
        }
        if (!(r#119 == null)) {
          assume (Heap[r#119, AVLTreeNode.height] == callHeap#_373[this#117, AVLTreeNode.height]) || ((Heap[r#119, AVLTreeNode.height] + 1) == callHeap#_373[this#117, AVLTreeNode.height]);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nl#28 := r#119;
        // update field left
        assert {:msg "  308.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
        Heap[this, AVLTreeNode.left] := nl#28;
        assume wf(Heap, Mask);
        // local var bf
        // call getBalanceFactorI
        callHeap#_383 := Heap;
        callMask#_384 := Mask;
        callCredits#_385 := Credits;
        assert {:msg "  311.6: The target of the method call might be null."} this != null;
        this#120 := this;
        // begin exhale (precondition)
        exhaleMask#_386 := Mask;
        epsilons#_387 := 1;
        assert {:msg "  311.6: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_386[this#120, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_387 <= exhaleMask#_386[this#120, AVLTreeNode.left][perm$N]);
        if ((exhaleMask#_386[this#120, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_386[this#120, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_386[this#120, AVLTreeNode.left] := exhaleMask#_386[this#120, AVLTreeNode.left][perm$N := exhaleMask#_386[this#120, AVLTreeNode.left][perm$N] - epsilons#_387];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_386);
        if (!(Heap[this#120, AVLTreeNode.left] == null)) {
          fraction#_388 := 100;
          assert {:msg "  311.6: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_388 <= exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_388 == exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_388];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_386);
        } else {
        }
        if (!(Heap[this#120, AVLTreeNode.left] == null)) {
          epsilons#_389 := 1;
          assert {:msg "  311.6: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_389 <= exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
          if ((exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_386[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_389];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_386);
        } else {
        }
        epsilons#_390 := 1;
        assert {:msg "  311.6: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_386[this#120, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_390 <= exhaleMask#_386[this#120, AVLTreeNode.right][perm$N]);
        if ((exhaleMask#_386[this#120, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_386[this#120, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_386[this#120, AVLTreeNode.right] := exhaleMask#_386[this#120, AVLTreeNode.right][perm$N := exhaleMask#_386[this#120, AVLTreeNode.right][perm$N] - epsilons#_390];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_386);
        if (!(Heap[this#120, AVLTreeNode.right] == null)) {
          fraction#_391 := 100;
          assert {:msg "  311.6: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_391 <= exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_391 == exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_391];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_386);
        } else {
        }
        if (!(Heap[this#120, AVLTreeNode.right] == null)) {
          epsilons#_392 := 1;
          assert {:msg "  311.6: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_392 <= exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
          if ((exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_386[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_392];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_386);
        } else {
        }
        Mask := exhaleMask#_386;
        assume wf(Heap, Mask);
        // end exhale
        havoc bf#121;
        // inhale (postcondition)
        havoc inhaleHeap#_395;
        assume IsGoodInhaleState(inhaleHeap#_395, Heap, Mask);
        assume this#120 != null;
        Heap[this#120, AVLTreeNode.left] := inhaleHeap#_395[this#120, AVLTreeNode.left];
        assume wf(Heap, Mask);
        assume (Heap[this#120, AVLTreeNode.left] == null) || (dtype(Heap[this#120, AVLTreeNode.left]) == AVLTreeNode#t);
        if ((Mask[this#120, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#120, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          Mask[this#120, AVLTreeNode.left] := Mask[this#120, AVLTreeNode.left][perm$N := Mask[this#120, AVLTreeNode.left][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_395[this#120, AVLTreeNode.left]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_395, Mask);
        if (!(Heap[this#120, AVLTreeNode.left] == null)) {
          assume Heap[this#120, AVLTreeNode.left] != null;
          Heap[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_395[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_395[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_395[Heap[this#120, AVLTreeNode.left], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_395, Mask);
        } else {
        }
        if (!(Heap[this#120, AVLTreeNode.left] == null)) {
          assume Heap[this#120, AVLTreeNode.left] != null;
          Heap[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_395[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          if ((Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_395[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_395, Mask);
        } else {
        }
        assume this#120 != null;
        Heap[this#120, AVLTreeNode.right] := inhaleHeap#_395[this#120, AVLTreeNode.right];
        assume wf(Heap, Mask);
        assume (Heap[this#120, AVLTreeNode.right] == null) || (dtype(Heap[this#120, AVLTreeNode.right]) == AVLTreeNode#t);
        if ((Mask[this#120, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#120, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          Mask[this#120, AVLTreeNode.right] := Mask[this#120, AVLTreeNode.right][perm$N := Mask[this#120, AVLTreeNode.right][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_395[this#120, AVLTreeNode.right]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_395, Mask);
        if (!(Heap[this#120, AVLTreeNode.right] == null)) {
          assume Heap[this#120, AVLTreeNode.right] != null;
          Heap[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_395[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_395[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_395[Heap[this#120, AVLTreeNode.right], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_395, Mask);
        } else {
        }
        if (!(Heap[this#120, AVLTreeNode.right] == null)) {
          assume Heap[this#120, AVLTreeNode.right] != null;
          Heap[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_395[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          if ((Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_395[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_395, Mask);
        } else {
        }
        assume bf#121 == (ite(Heap[this#120, AVLTreeNode.left] == null, 0, Heap[Heap[this#120, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#120, AVLTreeNode.right] == null, 0, Heap[Heap[this#120, AVLTreeNode.right], AVLTreeNode.height]));
        if (bf#121 > 0) {
          assume !(Heap[this#120, AVLTreeNode.left] == null);
        } else {
        }
        if (bf#121 < 0) {
          assume !(Heap[this#120, AVLTreeNode.right] == null);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        bf#30 := bf#121;
        // if
        if (bf#30 == (0 - 2)) {
          // call rebalanceRight
          callHeap#_396 := Heap;
          callMask#_397 := Mask;
          callCredits#_398 := Credits;
          assert {:msg "  314.7: The target of the method call might be null."} this != null;
          this#122 := this;
          // begin exhale (precondition)
          exhaleMask#_399 := Mask;
          fraction#_400 := 100;
          assert {:msg "  314.7: The precondition at 741.12 might not hold. Insufficient fraction at 741.12 for AVLTreeNode.key."} (fraction#_400 <= exhaleMask#_399[this#122, AVLTreeNode.key][perm$R]) && ((fraction#_400 == exhaleMask#_399[this#122, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_399[this#122, AVLTreeNode.key][perm$N]));
          exhaleMask#_399[this#122, AVLTreeNode.key] := exhaleMask#_399[this#122, AVLTreeNode.key][perm$R := exhaleMask#_399[this#122, AVLTreeNode.key][perm$R] - fraction#_400];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          fraction#_401 := 100;
          assert {:msg "  314.7: The precondition at 742.12 might not hold. Insufficient fraction at 742.12 for AVLTreeNode.height."} (fraction#_401 <= exhaleMask#_399[this#122, AVLTreeNode.height][perm$R]) && ((fraction#_401 == exhaleMask#_399[this#122, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_399[this#122, AVLTreeNode.height][perm$N]));
          exhaleMask#_399[this#122, AVLTreeNode.height] := exhaleMask#_399[this#122, AVLTreeNode.height][perm$R := exhaleMask#_399[this#122, AVLTreeNode.height][perm$R] - fraction#_401];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          fraction#_402 := 100;
          assert {:msg "  314.7: The precondition at 743.12 might not hold. Insufficient fraction at 743.12 for AVLTreeNode.left."} (fraction#_402 <= exhaleMask#_399[this#122, AVLTreeNode.left][perm$R]) && ((fraction#_402 == exhaleMask#_399[this#122, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_399[this#122, AVLTreeNode.left][perm$N]));
          exhaleMask#_399[this#122, AVLTreeNode.left] := exhaleMask#_399[this#122, AVLTreeNode.left][perm$R := exhaleMask#_399[this#122, AVLTreeNode.left][perm$R] - fraction#_402];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          fraction#_403 := 100;
          assert {:msg "  314.7: The precondition at 744.12 might not hold. Insufficient fraction at 744.12 for AVLTreeNode.right."} (fraction#_403 <= exhaleMask#_399[this#122, AVLTreeNode.right][perm$R]) && ((fraction#_403 == exhaleMask#_399[this#122, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_399[this#122, AVLTreeNode.right][perm$N]));
          exhaleMask#_399[this#122, AVLTreeNode.right] := exhaleMask#_399[this#122, AVLTreeNode.right][perm$R := exhaleMask#_399[this#122, AVLTreeNode.right][perm$R] - fraction#_403];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          fraction#_404 := 100;
          assert {:msg "  314.7: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.balanceFactor."} (fraction#_404 <= exhaleMask#_399[this#122, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_404 == exhaleMask#_399[this#122, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_399[this#122, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_399[this#122, AVLTreeNode.balanceFactor] := exhaleMask#_399[this#122, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_399[this#122, AVLTreeNode.balanceFactor][perm$R] - fraction#_404];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          if (!(Heap[this#122, AVLTreeNode.left] == null)) {
            fraction#_405 := 100;
            assert {:msg "  314.7: The precondition at 749.12 might not hold. Insufficient fraction at 749.25 for AVLTreeNode.valid."} (fraction#_405 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_405 == exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_405];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_399);
          } else {
          }
          if (!(Heap[this#122, AVLTreeNode.left] == null)) {
            fraction#_406 := 50;
            assert {:msg "  314.7: The precondition at 750.12 might not hold. Insufficient fraction at 750.25 for AVLTreeNode.height."} (fraction#_406 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_406 == exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_406];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_399);
          } else {
          }
          if (!(Heap[this#122, AVLTreeNode.left] == null)) {
            fraction#_407 := 50;
            assert {:msg "  314.7: The precondition at 752.12 might not hold. Insufficient fraction at 752.25 for AVLTreeNode.balanceFactor."} (fraction#_407 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_407 == exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_399[Heap[this#122, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_407];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_399);
          } else {
          }
          assert {:msg "  314.7: The precondition at 755.12 might not hold. The expression at 755.12 might not evaluate to true."} !(Heap[this#122, AVLTreeNode.right] == null);
          fraction#_408 := 100;
          assert {:msg "  314.7: The precondition at 756.12 might not hold. Insufficient fraction at 756.12 for AVLTreeNode.valid."} (fraction#_408 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_408 == exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_408];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          fraction#_409 := 50;
          assert {:msg "  314.7: The precondition at 757.12 might not hold. Insufficient fraction at 757.12 for AVLTreeNode.height."} (fraction#_409 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_409 == exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_409];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          fraction#_410 := 50;
          assert {:msg "  314.7: The precondition at 759.12 might not hold. Insufficient fraction at 759.12 for AVLTreeNode.balanceFactor."} (fraction#_410 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_410 == exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_399[Heap[this#122, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_410];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_399);
          assert {:msg "  314.7: The precondition at 763.12 might not hold. The expression at 763.12 might not evaluate to true."} (ite(Heap[this#122, AVLTreeNode.left] == null, 0, Heap[Heap[this#122, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#122, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
          Mask := exhaleMask#_399;
          assume wf(Heap, Mask);
          // end exhale
          havoc r#123;
          // inhale (postcondition)
          havoc inhaleHeap#_413;
          assume IsGoodInhaleState(inhaleHeap#_413, Heap, Mask);
          assume r#123 != null;
          Heap[r#123, AVLTreeNode.valid] := inhaleHeap#_413[r#123, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_413[r#123, AVLTreeNode.valid] == Heap;
          Mask[r#123, AVLTreeNode.valid] := Mask[r#123, AVLTreeNode.valid][perm$R := Mask[r#123, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_413[r#123, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_413, Mask);
          assume r#123 != null;
          Heap[r#123, AVLTreeNode.height] := inhaleHeap#_413[r#123, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#123, AVLTreeNode.height] := Mask[r#123, AVLTreeNode.height][perm$R := Mask[r#123, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_413[r#123, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_413, Mask);
          assume r#123 != null;
          Heap[r#123, AVLTreeNode.balanceFactor] := inhaleHeap#_413[r#123, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#123, AVLTreeNode.balanceFactor] := Mask[r#123, AVLTreeNode.balanceFactor][perm$R := Mask[r#123, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_413[r#123, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_413, Mask);
          assume (Heap[r#123, AVLTreeNode.height] == callHeap#_396[callHeap#_396[this#122, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#123, AVLTreeNode.height] == (callHeap#_396[callHeap#_396[this#122, AVLTreeNode.right], AVLTreeNode.height] + 1));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          r#20 := r#123;
        } else {
          // call close
          callHeap#_414 := Heap;
          callMask#_415 := Mask;
          callCredits#_416 := Credits;
          assert {:msg "  316.7: The target of the method call might be null."} this != null;
          this#124 := this;
          // begin exhale (precondition)
          exhaleMask#_417 := Mask;
          fraction#_418 := 100;
          assert {:msg "  316.7: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_418 <= exhaleMask#_417[this#124, AVLTreeNode.key][perm$R]) && ((fraction#_418 == exhaleMask#_417[this#124, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_417[this#124, AVLTreeNode.key][perm$N]));
          exhaleMask#_417[this#124, AVLTreeNode.key] := exhaleMask#_417[this#124, AVLTreeNode.key][perm$R := exhaleMask#_417[this#124, AVLTreeNode.key][perm$R] - fraction#_418];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_419 := 100;
          assert {:msg "  316.7: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_419 <= exhaleMask#_417[this#124, AVLTreeNode.height][perm$R]) && ((fraction#_419 == exhaleMask#_417[this#124, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_417[this#124, AVLTreeNode.height][perm$N]));
          exhaleMask#_417[this#124, AVLTreeNode.height] := exhaleMask#_417[this#124, AVLTreeNode.height][perm$R := exhaleMask#_417[this#124, AVLTreeNode.height][perm$R] - fraction#_419];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_420 := 100;
          assert {:msg "  316.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_420 <= exhaleMask#_417[this#124, AVLTreeNode.left][perm$R]) && ((fraction#_420 == exhaleMask#_417[this#124, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_417[this#124, AVLTreeNode.left][perm$N]));
          exhaleMask#_417[this#124, AVLTreeNode.left] := exhaleMask#_417[this#124, AVLTreeNode.left][perm$R := exhaleMask#_417[this#124, AVLTreeNode.left][perm$R] - fraction#_420];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_421 := 100;
          assert {:msg "  316.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_421 <= exhaleMask#_417[this#124, AVLTreeNode.right][perm$R]) && ((fraction#_421 == exhaleMask#_417[this#124, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_417[this#124, AVLTreeNode.right][perm$N]));
          exhaleMask#_417[this#124, AVLTreeNode.right] := exhaleMask#_417[this#124, AVLTreeNode.right][perm$R := exhaleMask#_417[this#124, AVLTreeNode.right][perm$R] - fraction#_421];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          fraction#_422 := 100;
          assert {:msg "  316.7: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_422 <= exhaleMask#_417[this#124, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_422 == exhaleMask#_417[this#124, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_417[this#124, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_417[this#124, AVLTreeNode.balanceFactor] := exhaleMask#_417[this#124, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_417[this#124, AVLTreeNode.balanceFactor][perm$R] - fraction#_422];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_417);
          if (!(Heap[this#124, AVLTreeNode.left] == null)) {
            fraction#_423 := 100;
            assert {:msg "  316.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_423 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_423 == exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_423];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#124, AVLTreeNode.left] == null)) {
            fraction#_424 := 50;
            assert {:msg "  316.7: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_424 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_424 == exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_424];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#124, AVLTreeNode.left] == null)) {
            fraction#_425 := 50;
            assert {:msg "  316.7: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_425 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_425 == exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_417[Heap[this#124, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_425];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#124, AVLTreeNode.right] == null)) {
            fraction#_426 := 100;
            assert {:msg "  316.7: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_426 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_426 == exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_426];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#124, AVLTreeNode.right] == null)) {
            fraction#_427 := 50;
            assert {:msg "  316.7: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_427 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_427 == exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_427];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          if (!(Heap[this#124, AVLTreeNode.right] == null)) {
            fraction#_428 := 50;
            assert {:msg "  316.7: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_428 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_428 == exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_417[Heap[this#124, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_428];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_417);
          } else {
          }
          assert {:msg "  316.7: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#124, AVLTreeNode.left] == null, 0, Heap[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#124, AVLTreeNode.right] == null, 0, Heap[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
          assert {:msg "  316.7: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#124, AVLTreeNode.left] == null, 0, Heap[Heap[this#124, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#124, AVLTreeNode.right] == null, 0, Heap[Heap[this#124, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
          Mask := exhaleMask#_417;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_431;
          assume IsGoodInhaleState(inhaleHeap#_431, Heap, Mask);
          assume this#124 != null;
          Heap[this#124, AVLTreeNode.valid] := inhaleHeap#_431[this#124, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_431[this#124, AVLTreeNode.valid] == Heap;
          Mask[this#124, AVLTreeNode.valid] := Mask[this#124, AVLTreeNode.valid][perm$R := Mask[this#124, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_431[this#124, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_431, Mask);
          assume this#124 != null;
          Heap[this#124, AVLTreeNode.height] := inhaleHeap#_431[this#124, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[this#124, AVLTreeNode.height] := Mask[this#124, AVLTreeNode.height][perm$R := Mask[this#124, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_431[this#124, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_431, Mask);
          assume this#124 != null;
          Heap[this#124, AVLTreeNode.balanceFactor] := inhaleHeap#_431[this#124, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[this#124, AVLTreeNode.balanceFactor] := Mask[this#124, AVLTreeNode.balanceFactor][perm$R := Mask[this#124, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_431[this#124, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_431, Mask);
          assume Heap[this#124, AVLTreeNode.height] == ite(ite(callHeap#_414[this#124, AVLTreeNode.left] == null, 0, callHeap#_414[callHeap#_414[this#124, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_414[this#124, AVLTreeNode.right] == null, 0, callHeap#_414[callHeap#_414[this#124, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_414[this#124, AVLTreeNode.left] == null, 0, callHeap#_414[callHeap#_414[this#124, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_414[this#124, AVLTreeNode.right] == null, 0, callHeap#_414[callHeap#_414[this#124, AVLTreeNode.right], AVLTreeNode.height]) + 1);
          assume Heap[this#124, AVLTreeNode.balanceFactor] == (ite(callHeap#_414[this#124, AVLTreeNode.left] == null, 0, callHeap#_414[callHeap#_414[this#124, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_414[this#124, AVLTreeNode.right] == null, 0, callHeap#_414[callHeap#_414[this#124, AVLTreeNode.right], AVLTreeNode.height]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          // assigment to r
          r#20 := this;
        }
      } else {
        // assigment to r
        r#20 := this;
        // call close
        callHeap#_432 := Heap;
        callMask#_433 := Mask;
        callCredits#_434 := Credits;
        assert {:msg "  321.6: The target of the method call might be null."} r#20 != null;
        this#125 := r#20;
        // begin exhale (precondition)
        exhaleMask#_435 := Mask;
        fraction#_436 := 100;
        assert {:msg "  321.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_436 <= exhaleMask#_435[this#125, AVLTreeNode.key][perm$R]) && ((fraction#_436 == exhaleMask#_435[this#125, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_435[this#125, AVLTreeNode.key][perm$N]));
        exhaleMask#_435[this#125, AVLTreeNode.key] := exhaleMask#_435[this#125, AVLTreeNode.key][perm$R := exhaleMask#_435[this#125, AVLTreeNode.key][perm$R] - fraction#_436];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_435);
        fraction#_437 := 100;
        assert {:msg "  321.6: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_437 <= exhaleMask#_435[this#125, AVLTreeNode.height][perm$R]) && ((fraction#_437 == exhaleMask#_435[this#125, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_435[this#125, AVLTreeNode.height][perm$N]));
        exhaleMask#_435[this#125, AVLTreeNode.height] := exhaleMask#_435[this#125, AVLTreeNode.height][perm$R := exhaleMask#_435[this#125, AVLTreeNode.height][perm$R] - fraction#_437];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_435);
        fraction#_438 := 100;
        assert {:msg "  321.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_438 <= exhaleMask#_435[this#125, AVLTreeNode.left][perm$R]) && ((fraction#_438 == exhaleMask#_435[this#125, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_435[this#125, AVLTreeNode.left][perm$N]));
        exhaleMask#_435[this#125, AVLTreeNode.left] := exhaleMask#_435[this#125, AVLTreeNode.left][perm$R := exhaleMask#_435[this#125, AVLTreeNode.left][perm$R] - fraction#_438];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_435);
        fraction#_439 := 100;
        assert {:msg "  321.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_439 <= exhaleMask#_435[this#125, AVLTreeNode.right][perm$R]) && ((fraction#_439 == exhaleMask#_435[this#125, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_435[this#125, AVLTreeNode.right][perm$N]));
        exhaleMask#_435[this#125, AVLTreeNode.right] := exhaleMask#_435[this#125, AVLTreeNode.right][perm$R := exhaleMask#_435[this#125, AVLTreeNode.right][perm$R] - fraction#_439];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_435);
        fraction#_440 := 100;
        assert {:msg "  321.6: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_440 <= exhaleMask#_435[this#125, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_440 == exhaleMask#_435[this#125, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_435[this#125, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_435[this#125, AVLTreeNode.balanceFactor] := exhaleMask#_435[this#125, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_435[this#125, AVLTreeNode.balanceFactor][perm$R] - fraction#_440];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_435);
        if (!(Heap[this#125, AVLTreeNode.left] == null)) {
          fraction#_441 := 100;
          assert {:msg "  321.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_441 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_441 == exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_441];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_435);
        } else {
        }
        if (!(Heap[this#125, AVLTreeNode.left] == null)) {
          fraction#_442 := 50;
          assert {:msg "  321.6: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_442 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_442 == exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_442];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_435);
        } else {
        }
        if (!(Heap[this#125, AVLTreeNode.left] == null)) {
          fraction#_443 := 50;
          assert {:msg "  321.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_443 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_443 == exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_435[Heap[this#125, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_443];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_435);
        } else {
        }
        if (!(Heap[this#125, AVLTreeNode.right] == null)) {
          fraction#_444 := 100;
          assert {:msg "  321.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_444 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_444 == exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_444];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_435);
        } else {
        }
        if (!(Heap[this#125, AVLTreeNode.right] == null)) {
          fraction#_445 := 50;
          assert {:msg "  321.6: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_445 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_445 == exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_445];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_435);
        } else {
        }
        if (!(Heap[this#125, AVLTreeNode.right] == null)) {
          fraction#_446 := 50;
          assert {:msg "  321.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_446 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_446 == exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_435[Heap[this#125, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_446];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_435);
        } else {
        }
        assert {:msg "  321.6: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#125, AVLTreeNode.left] == null, 0, Heap[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#125, AVLTreeNode.right] == null, 0, Heap[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  321.6: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#125, AVLTreeNode.left] == null, 0, Heap[Heap[this#125, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#125, AVLTreeNode.right] == null, 0, Heap[Heap[this#125, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        Mask := exhaleMask#_435;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_449;
        assume IsGoodInhaleState(inhaleHeap#_449, Heap, Mask);
        assume this#125 != null;
        Heap[this#125, AVLTreeNode.valid] := inhaleHeap#_449[this#125, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_449[this#125, AVLTreeNode.valid] == Heap;
        Mask[this#125, AVLTreeNode.valid] := Mask[this#125, AVLTreeNode.valid][perm$R := Mask[this#125, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_449[this#125, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_449, Mask);
        assume this#125 != null;
        Heap[this#125, AVLTreeNode.height] := inhaleHeap#_449[this#125, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#125, AVLTreeNode.height] := Mask[this#125, AVLTreeNode.height][perm$R := Mask[this#125, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_449[this#125, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_449, Mask);
        assume this#125 != null;
        Heap[this#125, AVLTreeNode.balanceFactor] := inhaleHeap#_449[this#125, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#125, AVLTreeNode.balanceFactor] := Mask[this#125, AVLTreeNode.balanceFactor][perm$R := Mask[this#125, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_449[this#125, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_449, Mask);
        assume Heap[this#125, AVLTreeNode.height] == ite(ite(callHeap#_432[this#125, AVLTreeNode.left] == null, 0, callHeap#_432[callHeap#_432[this#125, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_432[this#125, AVLTreeNode.right] == null, 0, callHeap#_432[callHeap#_432[this#125, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_432[this#125, AVLTreeNode.left] == null, 0, callHeap#_432[callHeap#_432[this#125, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_432[this#125, AVLTreeNode.right] == null, 0, callHeap#_432[callHeap#_432[this#125, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#125, AVLTreeNode.balanceFactor] == (ite(callHeap#_432[this#125, AVLTreeNode.left] == null, 0, callHeap#_432[callHeap#_432[this#125, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_432[this#125, AVLTreeNode.right] == null, 0, callHeap#_432[callHeap#_432[this#125, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    } else {
      // if
      assert {:msg "  324.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  324.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (!(Heap[this, AVLTreeNode.right] == null)) {
        // local var nr
        // call remove
        callHeap#_450 := Heap;
        callMask#_451 := Mask;
        callCredits#_452 := Credits;
        assert {:msg "  326.17: Receiver might be null."} true ==> (this != null);
        assert {:msg "  326.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  326.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#126 := Heap[this, AVLTreeNode.right];
        k#127 := k#19;
        // begin exhale (precondition)
        exhaleMask#_453 := Mask;
        fraction#_454 := 100;
        assert {:msg "  326.6: The precondition at 254.12 might not hold. Insufficient fraction at 254.12 for AVLTreeNode.valid."} (fraction#_454 <= exhaleMask#_453[this#126, AVLTreeNode.valid][perm$R]) && ((fraction#_454 == exhaleMask#_453[this#126, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_453[this#126, AVLTreeNode.valid][perm$N]));
        exhaleMask#_453[this#126, AVLTreeNode.valid] := exhaleMask#_453[this#126, AVLTreeNode.valid][perm$R := exhaleMask#_453[this#126, AVLTreeNode.valid][perm$R] - fraction#_454];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_453);
        fraction#_455 := 50;
        assert {:msg "  326.6: The precondition at 256.12 might not hold. Insufficient fraction at 256.12 for AVLTreeNode.height."} (fraction#_455 <= exhaleMask#_453[this#126, AVLTreeNode.height][perm$R]) && ((fraction#_455 == exhaleMask#_453[this#126, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_453[this#126, AVLTreeNode.height][perm$N]));
        exhaleMask#_453[this#126, AVLTreeNode.height] := exhaleMask#_453[this#126, AVLTreeNode.height][perm$R := exhaleMask#_453[this#126, AVLTreeNode.height][perm$R] - fraction#_455];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_453);
        fraction#_456 := 50;
        assert {:msg "  326.6: The precondition at 257.12 might not hold. Insufficient fraction at 257.12 for AVLTreeNode.balanceFactor."} (fraction#_456 <= exhaleMask#_453[this#126, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_456 == exhaleMask#_453[this#126, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_453[this#126, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_453[this#126, AVLTreeNode.balanceFactor] := exhaleMask#_453[this#126, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_453[this#126, AVLTreeNode.balanceFactor][perm$R] - fraction#_456];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_453);
        Mask := exhaleMask#_453;
        assume wf(Heap, Mask);
        // end exhale
        havoc r#128;
        // inhale (postcondition)
        havoc inhaleHeap#_459;
        assume IsGoodInhaleState(inhaleHeap#_459, Heap, Mask);
        if (!(r#128 == null)) {
          assume r#128 != null;
          Heap[r#128, AVLTreeNode.valid] := inhaleHeap#_459[r#128, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_459[r#128, AVLTreeNode.valid] == Heap;
          Mask[r#128, AVLTreeNode.valid] := Mask[r#128, AVLTreeNode.valid][perm$R := Mask[r#128, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_459[r#128, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_459, Mask);
        } else {
        }
        if (!(r#128 == null)) {
          assume r#128 != null;
          Heap[r#128, AVLTreeNode.height] := inhaleHeap#_459[r#128, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#128, AVLTreeNode.height] := Mask[r#128, AVLTreeNode.height][perm$R := Mask[r#128, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_459[r#128, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_459, Mask);
        } else {
        }
        if (!(r#128 == null)) {
          assume r#128 != null;
          Heap[r#128, AVLTreeNode.balanceFactor] := inhaleHeap#_459[r#128, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#128, AVLTreeNode.balanceFactor] := Mask[r#128, AVLTreeNode.balanceFactor][perm$R := Mask[r#128, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_459[r#128, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_459, Mask);
        } else {
        }
        if (callHeap#_450[this#126, AVLTreeNode.height] > 1) {
          assume !(r#128 == null);
        } else {
        }
        if (!(r#128 == null)) {
          assume (Heap[r#128, AVLTreeNode.height] == callHeap#_450[this#126, AVLTreeNode.height]) || ((Heap[r#128, AVLTreeNode.height] + 1) == callHeap#_450[this#126, AVLTreeNode.height]);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        nr#32 := r#128;
        // update field right
        assert {:msg "  327.6: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
        Heap[this, AVLTreeNode.right] := nr#32;
        assume wf(Heap, Mask);
        // local var bf
        // call getBalanceFactorI
        callHeap#_460 := Heap;
        callMask#_461 := Mask;
        callCredits#_462 := Credits;
        assert {:msg "  330.6: The target of the method call might be null."} this != null;
        this#129 := this;
        // begin exhale (precondition)
        exhaleMask#_463 := Mask;
        epsilons#_464 := 1;
        assert {:msg "  330.6: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_463[this#129, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_464 <= exhaleMask#_463[this#129, AVLTreeNode.left][perm$N]);
        if ((exhaleMask#_463[this#129, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_463[this#129, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_463[this#129, AVLTreeNode.left] := exhaleMask#_463[this#129, AVLTreeNode.left][perm$N := exhaleMask#_463[this#129, AVLTreeNode.left][perm$N] - epsilons#_464];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_463);
        if (!(Heap[this#129, AVLTreeNode.left] == null)) {
          fraction#_465 := 100;
          assert {:msg "  330.6: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_465 <= exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_465 == exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_465];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_463);
        } else {
        }
        if (!(Heap[this#129, AVLTreeNode.left] == null)) {
          epsilons#_466 := 1;
          assert {:msg "  330.6: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_466 <= exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
          if ((exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_463[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_466];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_463);
        } else {
        }
        epsilons#_467 := 1;
        assert {:msg "  330.6: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_463[this#129, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_467 <= exhaleMask#_463[this#129, AVLTreeNode.right][perm$N]);
        if ((exhaleMask#_463[this#129, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_463[this#129, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          exhaleMask#_463[this#129, AVLTreeNode.right] := exhaleMask#_463[this#129, AVLTreeNode.right][perm$N := exhaleMask#_463[this#129, AVLTreeNode.right][perm$N] - epsilons#_467];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_463);
        if (!(Heap[this#129, AVLTreeNode.right] == null)) {
          fraction#_468 := 100;
          assert {:msg "  330.6: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_468 <= exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_468 == exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_468];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_463);
        } else {
        }
        if (!(Heap[this#129, AVLTreeNode.right] == null)) {
          epsilons#_469 := 1;
          assert {:msg "  330.6: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_469 <= exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
          if ((exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_463[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_469];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_463);
        } else {
        }
        Mask := exhaleMask#_463;
        assume wf(Heap, Mask);
        // end exhale
        havoc bf#130;
        // inhale (postcondition)
        havoc inhaleHeap#_472;
        assume IsGoodInhaleState(inhaleHeap#_472, Heap, Mask);
        assume this#129 != null;
        Heap[this#129, AVLTreeNode.left] := inhaleHeap#_472[this#129, AVLTreeNode.left];
        assume wf(Heap, Mask);
        assume (Heap[this#129, AVLTreeNode.left] == null) || (dtype(Heap[this#129, AVLTreeNode.left]) == AVLTreeNode#t);
        if ((Mask[this#129, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#129, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
          Mask[this#129, AVLTreeNode.left] := Mask[this#129, AVLTreeNode.left][perm$N := Mask[this#129, AVLTreeNode.left][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_472[this#129, AVLTreeNode.left]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_472, Mask);
        if (!(Heap[this#129, AVLTreeNode.left] == null)) {
          assume Heap[this#129, AVLTreeNode.left] != null;
          Heap[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_472[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_472[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_472[Heap[this#129, AVLTreeNode.left], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_472, Mask);
        } else {
        }
        if (!(Heap[this#129, AVLTreeNode.left] == null)) {
          assume Heap[this#129, AVLTreeNode.left] != null;
          Heap[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_472[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          if ((Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_472[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_472, Mask);
        } else {
        }
        assume this#129 != null;
        Heap[this#129, AVLTreeNode.right] := inhaleHeap#_472[this#129, AVLTreeNode.right];
        assume wf(Heap, Mask);
        assume (Heap[this#129, AVLTreeNode.right] == null) || (dtype(Heap[this#129, AVLTreeNode.right]) == AVLTreeNode#t);
        if ((Mask[this#129, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#129, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
          Mask[this#129, AVLTreeNode.right] := Mask[this#129, AVLTreeNode.right][perm$N := Mask[this#129, AVLTreeNode.right][perm$N] + 1];
          assume wf(Heap, Mask);
        } else {
        }
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_472[this#129, AVLTreeNode.right]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_472, Mask);
        if (!(Heap[this#129, AVLTreeNode.right] == null)) {
          assume Heap[this#129, AVLTreeNode.right] != null;
          Heap[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_472[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_472[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
          Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_472[Heap[this#129, AVLTreeNode.right], AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_472, Mask);
        } else {
        }
        if (!(Heap[this#129, AVLTreeNode.right] == null)) {
          assume Heap[this#129, AVLTreeNode.right] != null;
          Heap[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_472[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          if ((Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
            Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
            assume wf(Heap, Mask);
          } else {
          }
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_472[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_472, Mask);
        } else {
        }
        assume bf#130 == (ite(Heap[this#129, AVLTreeNode.left] == null, 0, Heap[Heap[this#129, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#129, AVLTreeNode.right] == null, 0, Heap[Heap[this#129, AVLTreeNode.right], AVLTreeNode.height]));
        if (bf#130 > 0) {
          assume !(Heap[this#129, AVLTreeNode.left] == null);
        } else {
        }
        if (bf#130 < 0) {
          assume !(Heap[this#129, AVLTreeNode.right] == null);
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        bf#34 := bf#130;
        // if
        if (bf#34 == 2) {
          // call rebalanceLeft
          callHeap#_473 := Heap;
          callMask#_474 := Mask;
          callCredits#_475 := Credits;
          assert {:msg "  332.7: The target of the method call might be null."} this != null;
          this#131 := this;
          // begin exhale (precondition)
          exhaleMask#_476 := Mask;
          fraction#_477 := 100;
          assert {:msg "  332.7: The precondition at 598.12 might not hold. Insufficient fraction at 598.12 for AVLTreeNode.key."} (fraction#_477 <= exhaleMask#_476[this#131, AVLTreeNode.key][perm$R]) && ((fraction#_477 == exhaleMask#_476[this#131, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_476[this#131, AVLTreeNode.key][perm$N]));
          exhaleMask#_476[this#131, AVLTreeNode.key] := exhaleMask#_476[this#131, AVLTreeNode.key][perm$R := exhaleMask#_476[this#131, AVLTreeNode.key][perm$R] - fraction#_477];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          fraction#_478 := 100;
          assert {:msg "  332.7: The precondition at 599.12 might not hold. Insufficient fraction at 599.12 for AVLTreeNode.height."} (fraction#_478 <= exhaleMask#_476[this#131, AVLTreeNode.height][perm$R]) && ((fraction#_478 == exhaleMask#_476[this#131, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_476[this#131, AVLTreeNode.height][perm$N]));
          exhaleMask#_476[this#131, AVLTreeNode.height] := exhaleMask#_476[this#131, AVLTreeNode.height][perm$R := exhaleMask#_476[this#131, AVLTreeNode.height][perm$R] - fraction#_478];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          fraction#_479 := 100;
          assert {:msg "  332.7: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.left."} (fraction#_479 <= exhaleMask#_476[this#131, AVLTreeNode.left][perm$R]) && ((fraction#_479 == exhaleMask#_476[this#131, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_476[this#131, AVLTreeNode.left][perm$N]));
          exhaleMask#_476[this#131, AVLTreeNode.left] := exhaleMask#_476[this#131, AVLTreeNode.left][perm$R := exhaleMask#_476[this#131, AVLTreeNode.left][perm$R] - fraction#_479];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          fraction#_480 := 100;
          assert {:msg "  332.7: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.right."} (fraction#_480 <= exhaleMask#_476[this#131, AVLTreeNode.right][perm$R]) && ((fraction#_480 == exhaleMask#_476[this#131, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_476[this#131, AVLTreeNode.right][perm$N]));
          exhaleMask#_476[this#131, AVLTreeNode.right] := exhaleMask#_476[this#131, AVLTreeNode.right][perm$R := exhaleMask#_476[this#131, AVLTreeNode.right][perm$R] - fraction#_480];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          fraction#_481 := 100;
          assert {:msg "  332.7: The precondition at 604.12 might not hold. Insufficient fraction at 604.12 for AVLTreeNode.balanceFactor."} (fraction#_481 <= exhaleMask#_476[this#131, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_481 == exhaleMask#_476[this#131, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_476[this#131, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_476[this#131, AVLTreeNode.balanceFactor] := exhaleMask#_476[this#131, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_476[this#131, AVLTreeNode.balanceFactor][perm$R] - fraction#_481];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          assert {:msg "  332.7: The precondition at 606.12 might not hold. The expression at 606.12 might not evaluate to true."} !(Heap[this#131, AVLTreeNode.left] == null);
          fraction#_482 := 100;
          assert {:msg "  332.7: The precondition at 607.12 might not hold. Insufficient fraction at 607.12 for AVLTreeNode.valid."} (fraction#_482 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_482 == exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_482];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          fraction#_483 := 50;
          assert {:msg "  332.7: The precondition at 608.12 might not hold. Insufficient fraction at 608.12 for AVLTreeNode.height."} (fraction#_483 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_483 == exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_483];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          fraction#_484 := 50;
          assert {:msg "  332.7: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.balanceFactor."} (fraction#_484 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_484 == exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_476[Heap[this#131, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_484];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_476);
          if (!(Heap[this#131, AVLTreeNode.right] == null)) {
            fraction#_485 := 100;
            assert {:msg "  332.7: The precondition at 613.12 might not hold. Insufficient fraction at 613.28 for AVLTreeNode.valid."} (fraction#_485 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_485 == exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_485];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_476);
          } else {
          }
          if (!(Heap[this#131, AVLTreeNode.right] == null)) {
            fraction#_486 := 50;
            assert {:msg "  332.7: The precondition at 614.12 might not hold. Insufficient fraction at 614.28 for AVLTreeNode.height."} (fraction#_486 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_486 == exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_486];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_476);
          } else {
          }
          if (!(Heap[this#131, AVLTreeNode.right] == null)) {
            fraction#_487 := 50;
            assert {:msg "  332.7: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.balanceFactor."} (fraction#_487 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_487 == exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_476[Heap[this#131, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_487];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_476);
          } else {
          }
          assert {:msg "  332.7: The precondition at 619.12 might not hold. The expression at 619.12 might not evaluate to true."} (Heap[Heap[this#131, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#131, AVLTreeNode.right] == null, 0, Heap[Heap[this#131, AVLTreeNode.right], AVLTreeNode.height])) == 2;
          Mask := exhaleMask#_476;
          assume wf(Heap, Mask);
          // end exhale
          havoc r#132;
          // inhale (postcondition)
          havoc inhaleHeap#_490;
          assume IsGoodInhaleState(inhaleHeap#_490, Heap, Mask);
          assume r#132 != null;
          Heap[r#132, AVLTreeNode.valid] := inhaleHeap#_490[r#132, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_490[r#132, AVLTreeNode.valid] == Heap;
          Mask[r#132, AVLTreeNode.valid] := Mask[r#132, AVLTreeNode.valid][perm$R := Mask[r#132, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_490[r#132, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_490, Mask);
          assume r#132 != null;
          Heap[r#132, AVLTreeNode.height] := inhaleHeap#_490[r#132, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#132, AVLTreeNode.height] := Mask[r#132, AVLTreeNode.height][perm$R := Mask[r#132, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_490[r#132, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_490, Mask);
          assume r#132 != null;
          Heap[r#132, AVLTreeNode.balanceFactor] := inhaleHeap#_490[r#132, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[r#132, AVLTreeNode.balanceFactor] := Mask[r#132, AVLTreeNode.balanceFactor][perm$R := Mask[r#132, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_490[r#132, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_490, Mask);
          assume (Heap[r#132, AVLTreeNode.height] == callHeap#_473[callHeap#_473[this#131, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#132, AVLTreeNode.height] == (callHeap#_473[callHeap#_473[this#131, AVLTreeNode.left], AVLTreeNode.height] + 1));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          r#20 := r#132;
        } else {
          // assigment to r
          r#20 := this;
          // call close
          callHeap#_491 := Heap;
          callMask#_492 := Mask;
          callCredits#_493 := Credits;
          assert {:msg "  335.7: The target of the method call might be null."} r#20 != null;
          this#133 := r#20;
          // begin exhale (precondition)
          exhaleMask#_494 := Mask;
          fraction#_495 := 100;
          assert {:msg "  335.7: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_495 <= exhaleMask#_494[this#133, AVLTreeNode.key][perm$R]) && ((fraction#_495 == exhaleMask#_494[this#133, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_494[this#133, AVLTreeNode.key][perm$N]));
          exhaleMask#_494[this#133, AVLTreeNode.key] := exhaleMask#_494[this#133, AVLTreeNode.key][perm$R := exhaleMask#_494[this#133, AVLTreeNode.key][perm$R] - fraction#_495];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_494);
          fraction#_496 := 100;
          assert {:msg "  335.7: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_496 <= exhaleMask#_494[this#133, AVLTreeNode.height][perm$R]) && ((fraction#_496 == exhaleMask#_494[this#133, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_494[this#133, AVLTreeNode.height][perm$N]));
          exhaleMask#_494[this#133, AVLTreeNode.height] := exhaleMask#_494[this#133, AVLTreeNode.height][perm$R := exhaleMask#_494[this#133, AVLTreeNode.height][perm$R] - fraction#_496];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_494);
          fraction#_497 := 100;
          assert {:msg "  335.7: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_497 <= exhaleMask#_494[this#133, AVLTreeNode.left][perm$R]) && ((fraction#_497 == exhaleMask#_494[this#133, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_494[this#133, AVLTreeNode.left][perm$N]));
          exhaleMask#_494[this#133, AVLTreeNode.left] := exhaleMask#_494[this#133, AVLTreeNode.left][perm$R := exhaleMask#_494[this#133, AVLTreeNode.left][perm$R] - fraction#_497];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_494);
          fraction#_498 := 100;
          assert {:msg "  335.7: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_498 <= exhaleMask#_494[this#133, AVLTreeNode.right][perm$R]) && ((fraction#_498 == exhaleMask#_494[this#133, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_494[this#133, AVLTreeNode.right][perm$N]));
          exhaleMask#_494[this#133, AVLTreeNode.right] := exhaleMask#_494[this#133, AVLTreeNode.right][perm$R := exhaleMask#_494[this#133, AVLTreeNode.right][perm$R] - fraction#_498];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_494);
          fraction#_499 := 100;
          assert {:msg "  335.7: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_499 <= exhaleMask#_494[this#133, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_499 == exhaleMask#_494[this#133, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_494[this#133, AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_494[this#133, AVLTreeNode.balanceFactor] := exhaleMask#_494[this#133, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_494[this#133, AVLTreeNode.balanceFactor][perm$R] - fraction#_499];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_494);
          if (!(Heap[this#133, AVLTreeNode.left] == null)) {
            fraction#_500 := 100;
            assert {:msg "  335.7: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_500 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_500 == exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
            exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_500];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_494);
          } else {
          }
          if (!(Heap[this#133, AVLTreeNode.left] == null)) {
            fraction#_501 := 50;
            assert {:msg "  335.7: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_501 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_501 == exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
            exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_501];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_494);
          } else {
          }
          if (!(Heap[this#133, AVLTreeNode.left] == null)) {
            fraction#_502 := 50;
            assert {:msg "  335.7: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_502 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_502 == exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_494[Heap[this#133, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_502];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_494);
          } else {
          }
          if (!(Heap[this#133, AVLTreeNode.right] == null)) {
            fraction#_503 := 100;
            assert {:msg "  335.7: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_503 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_503 == exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
            exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_503];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_494);
          } else {
          }
          if (!(Heap[this#133, AVLTreeNode.right] == null)) {
            fraction#_504 := 50;
            assert {:msg "  335.7: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_504 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_504 == exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
            exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_504];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_494);
          } else {
          }
          if (!(Heap[this#133, AVLTreeNode.right] == null)) {
            fraction#_505 := 50;
            assert {:msg "  335.7: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_505 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_505 == exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
            exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_494[Heap[this#133, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_505];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_494);
          } else {
          }
          assert {:msg "  335.7: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#133, AVLTreeNode.left] == null, 0, Heap[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#133, AVLTreeNode.right] == null, 0, Heap[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
          assert {:msg "  335.7: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#133, AVLTreeNode.left] == null, 0, Heap[Heap[this#133, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#133, AVLTreeNode.right] == null, 0, Heap[Heap[this#133, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
          Mask := exhaleMask#_494;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_508;
          assume IsGoodInhaleState(inhaleHeap#_508, Heap, Mask);
          assume this#133 != null;
          Heap[this#133, AVLTreeNode.valid] := inhaleHeap#_508[this#133, AVLTreeNode.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_508[this#133, AVLTreeNode.valid] == Heap;
          Mask[this#133, AVLTreeNode.valid] := Mask[this#133, AVLTreeNode.valid][perm$R := Mask[this#133, AVLTreeNode.valid][perm$R] + 100];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_508[this#133, AVLTreeNode.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_508, Mask);
          assume this#133 != null;
          Heap[this#133, AVLTreeNode.height] := inhaleHeap#_508[this#133, AVLTreeNode.height];
          assume wf(Heap, Mask);
          assume true;
          Mask[this#133, AVLTreeNode.height] := Mask[this#133, AVLTreeNode.height][perm$R := Mask[this#133, AVLTreeNode.height][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_508[this#133, AVLTreeNode.height]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_508, Mask);
          assume this#133 != null;
          Heap[this#133, AVLTreeNode.balanceFactor] := inhaleHeap#_508[this#133, AVLTreeNode.balanceFactor];
          assume wf(Heap, Mask);
          assume true;
          Mask[this#133, AVLTreeNode.balanceFactor] := Mask[this#133, AVLTreeNode.balanceFactor][perm$R := Mask[this#133, AVLTreeNode.balanceFactor][perm$R] + 50];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_508[this#133, AVLTreeNode.balanceFactor]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_508, Mask);
          assume Heap[this#133, AVLTreeNode.height] == ite(ite(callHeap#_491[this#133, AVLTreeNode.left] == null, 0, callHeap#_491[callHeap#_491[this#133, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_491[this#133, AVLTreeNode.right] == null, 0, callHeap#_491[callHeap#_491[this#133, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_491[this#133, AVLTreeNode.left] == null, 0, callHeap#_491[callHeap#_491[this#133, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_491[this#133, AVLTreeNode.right] == null, 0, callHeap#_491[callHeap#_491[this#133, AVLTreeNode.right], AVLTreeNode.height]) + 1);
          assume Heap[this#133, AVLTreeNode.balanceFactor] == (ite(callHeap#_491[this#133, AVLTreeNode.left] == null, 0, callHeap#_491[callHeap#_491[this#133, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_491[this#133, AVLTreeNode.right] == null, 0, callHeap#_491[callHeap#_491[this#133, AVLTreeNode.right], AVLTreeNode.height]));
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
        }
      } else {
        // assigment to r
        r#20 := this;
        // call close
        callHeap#_509 := Heap;
        callMask#_510 := Mask;
        callCredits#_511 := Credits;
        assert {:msg "  339.6: The target of the method call might be null."} r#20 != null;
        this#134 := r#20;
        // begin exhale (precondition)
        exhaleMask#_512 := Mask;
        fraction#_513 := 100;
        assert {:msg "  339.6: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_513 <= exhaleMask#_512[this#134, AVLTreeNode.key][perm$R]) && ((fraction#_513 == exhaleMask#_512[this#134, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_512[this#134, AVLTreeNode.key][perm$N]));
        exhaleMask#_512[this#134, AVLTreeNode.key] := exhaleMask#_512[this#134, AVLTreeNode.key][perm$R := exhaleMask#_512[this#134, AVLTreeNode.key][perm$R] - fraction#_513];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_512);
        fraction#_514 := 100;
        assert {:msg "  339.6: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_514 <= exhaleMask#_512[this#134, AVLTreeNode.height][perm$R]) && ((fraction#_514 == exhaleMask#_512[this#134, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_512[this#134, AVLTreeNode.height][perm$N]));
        exhaleMask#_512[this#134, AVLTreeNode.height] := exhaleMask#_512[this#134, AVLTreeNode.height][perm$R := exhaleMask#_512[this#134, AVLTreeNode.height][perm$R] - fraction#_514];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_512);
        fraction#_515 := 100;
        assert {:msg "  339.6: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_515 <= exhaleMask#_512[this#134, AVLTreeNode.left][perm$R]) && ((fraction#_515 == exhaleMask#_512[this#134, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_512[this#134, AVLTreeNode.left][perm$N]));
        exhaleMask#_512[this#134, AVLTreeNode.left] := exhaleMask#_512[this#134, AVLTreeNode.left][perm$R := exhaleMask#_512[this#134, AVLTreeNode.left][perm$R] - fraction#_515];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_512);
        fraction#_516 := 100;
        assert {:msg "  339.6: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_516 <= exhaleMask#_512[this#134, AVLTreeNode.right][perm$R]) && ((fraction#_516 == exhaleMask#_512[this#134, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_512[this#134, AVLTreeNode.right][perm$N]));
        exhaleMask#_512[this#134, AVLTreeNode.right] := exhaleMask#_512[this#134, AVLTreeNode.right][perm$R := exhaleMask#_512[this#134, AVLTreeNode.right][perm$R] - fraction#_516];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_512);
        fraction#_517 := 100;
        assert {:msg "  339.6: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_517 <= exhaleMask#_512[this#134, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_517 == exhaleMask#_512[this#134, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_512[this#134, AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_512[this#134, AVLTreeNode.balanceFactor] := exhaleMask#_512[this#134, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_512[this#134, AVLTreeNode.balanceFactor][perm$R] - fraction#_517];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_512);
        if (!(Heap[this#134, AVLTreeNode.left] == null)) {
          fraction#_518 := 100;
          assert {:msg "  339.6: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_518 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_518 == exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
          exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_518];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_512);
        } else {
        }
        if (!(Heap[this#134, AVLTreeNode.left] == null)) {
          fraction#_519 := 50;
          assert {:msg "  339.6: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_519 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_519 == exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
          exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_519];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_512);
        } else {
        }
        if (!(Heap[this#134, AVLTreeNode.left] == null)) {
          fraction#_520 := 50;
          assert {:msg "  339.6: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_520 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_520 == exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_512[Heap[this#134, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_520];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_512);
        } else {
        }
        if (!(Heap[this#134, AVLTreeNode.right] == null)) {
          fraction#_521 := 100;
          assert {:msg "  339.6: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_521 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_521 == exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
          exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_521];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_512);
        } else {
        }
        if (!(Heap[this#134, AVLTreeNode.right] == null)) {
          fraction#_522 := 50;
          assert {:msg "  339.6: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_522 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_522 == exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
          exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_522];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_512);
        } else {
        }
        if (!(Heap[this#134, AVLTreeNode.right] == null)) {
          fraction#_523 := 50;
          assert {:msg "  339.6: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_523 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_523 == exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
          exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_512[Heap[this#134, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_523];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_512);
        } else {
        }
        assert {:msg "  339.6: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#134, AVLTreeNode.left] == null, 0, Heap[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#134, AVLTreeNode.right] == null, 0, Heap[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
        assert {:msg "  339.6: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#134, AVLTreeNode.left] == null, 0, Heap[Heap[this#134, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#134, AVLTreeNode.right] == null, 0, Heap[Heap[this#134, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
        Mask := exhaleMask#_512;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_526;
        assume IsGoodInhaleState(inhaleHeap#_526, Heap, Mask);
        assume this#134 != null;
        Heap[this#134, AVLTreeNode.valid] := inhaleHeap#_526[this#134, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_526[this#134, AVLTreeNode.valid] == Heap;
        Mask[this#134, AVLTreeNode.valid] := Mask[this#134, AVLTreeNode.valid][perm$R := Mask[this#134, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_526[this#134, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_526, Mask);
        assume this#134 != null;
        Heap[this#134, AVLTreeNode.height] := inhaleHeap#_526[this#134, AVLTreeNode.height];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#134, AVLTreeNode.height] := Mask[this#134, AVLTreeNode.height][perm$R := Mask[this#134, AVLTreeNode.height][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_526[this#134, AVLTreeNode.height]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_526, Mask);
        assume this#134 != null;
        Heap[this#134, AVLTreeNode.balanceFactor] := inhaleHeap#_526[this#134, AVLTreeNode.balanceFactor];
        assume wf(Heap, Mask);
        assume true;
        Mask[this#134, AVLTreeNode.balanceFactor] := Mask[this#134, AVLTreeNode.balanceFactor][perm$R := Mask[this#134, AVLTreeNode.balanceFactor][perm$R] + 50];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_526[this#134, AVLTreeNode.balanceFactor]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_526, Mask);
        assume Heap[this#134, AVLTreeNode.height] == ite(ite(callHeap#_509[this#134, AVLTreeNode.left] == null, 0, callHeap#_509[callHeap#_509[this#134, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_509[this#134, AVLTreeNode.right] == null, 0, callHeap#_509[callHeap#_509[this#134, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_509[this#134, AVLTreeNode.left] == null, 0, callHeap#_509[callHeap#_509[this#134, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_509[this#134, AVLTreeNode.right] == null, 0, callHeap#_509[callHeap#_509[this#134, AVLTreeNode.right], AVLTreeNode.height]) + 1);
        assume Heap[this#134, AVLTreeNode.balanceFactor] == (ite(callHeap#_509[this#134, AVLTreeNode.left] == null, 0, callHeap#_509[callHeap#_509[this#134, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_509[this#134, AVLTreeNode.right] == null, 0, callHeap#_509[callHeap#_509[this#134, AVLTreeNode.right], AVLTreeNode.height]));
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      }
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_527 := Mask;
  if (!(r#20 == null)) {
    fraction#_528 := 100;
    assert {:msg "  253.2: The postcondition at 262.11 might not hold. Insufficient fraction at 262.25 for AVLTreeNode.valid."} (fraction#_528 <= exhaleMask#_527[r#20, AVLTreeNode.valid][perm$R]) && ((fraction#_528 == exhaleMask#_527[r#20, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_527[r#20, AVLTreeNode.valid][perm$N]));
    exhaleMask#_527[r#20, AVLTreeNode.valid] := exhaleMask#_527[r#20, AVLTreeNode.valid][perm$R := exhaleMask#_527[r#20, AVLTreeNode.valid][perm$R] - fraction#_528];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_527);
  } else {
  }
  if (!(r#20 == null)) {
    fraction#_529 := 50;
    assert {:msg "  253.2: The postcondition at 264.11 might not hold. Insufficient fraction at 264.25 for AVLTreeNode.height."} (fraction#_529 <= exhaleMask#_527[r#20, AVLTreeNode.height][perm$R]) && ((fraction#_529 == exhaleMask#_527[r#20, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_527[r#20, AVLTreeNode.height][perm$N]));
    exhaleMask#_527[r#20, AVLTreeNode.height] := exhaleMask#_527[r#20, AVLTreeNode.height][perm$R := exhaleMask#_527[r#20, AVLTreeNode.height][perm$R] - fraction#_529];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_527);
  } else {
  }
  if (!(r#20 == null)) {
    fraction#_530 := 50;
    assert {:msg "  253.2: The postcondition at 265.11 might not hold. Insufficient fraction at 265.25 for AVLTreeNode.balanceFactor."} (fraction#_530 <= exhaleMask#_527[r#20, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_530 == exhaleMask#_527[r#20, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_527[r#20, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_527[r#20, AVLTreeNode.balanceFactor] := exhaleMask#_527[r#20, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_527[r#20, AVLTreeNode.balanceFactor][perm$R] - fraction#_530];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_527);
  } else {
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  253.2: The postcondition at 273.11 might not hold. The expression at 273.29 might not evaluate to true."} !(r#20 == null);
  } else {
  }
  if (!(r#20 == null)) {
    assert {:msg "  253.2: The postcondition at 274.11 might not hold. The expression at 274.25 might not evaluate to true."} (Heap[r#20, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#20, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  } else {
  }
  Mask := exhaleMask#_527;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  253.2: Method might lock/unlock more than allowed."} (forall lk#_531: ref :: {Heap[lk#_531, held]} {Heap[lk#_531, rdheld]} (((0 < Heap[lk#_531, held]) == (0 < old(Heap)[lk#_531, held])) && (Heap[lk#_531, rdheld] == old(Heap)[lk#_531, rdheld])) || false);
  assert {:msg "  253.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.pruneMax$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_532: HeapType;
  var inhaleHeap#_533: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_532;
  assume IsGoodInhaleState(inhaleHeap#_532, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_532[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_532[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_532[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_532, Mask);
  assert {:msg "  350.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  350.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_532[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_532[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_532, Mask);
  assert {:msg "  351.30: Fraction might be negative."} 0 <= 50;
  assert {:msg "  351.30: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_532[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_532[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_532, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_533;
  assume IsGoodInhaleState(inhaleHeap#_533, Heap, Mask);
  if (!(r#35 == null)) {
    assume r#35 != null;
    Heap[r#35, AVLTreeNode.valid] := inhaleHeap#_533[r#35, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_533[r#35, AVLTreeNode.valid] == Heap;
    Mask[r#35, AVLTreeNode.valid] := Mask[r#35, AVLTreeNode.valid][perm$R := Mask[r#35, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_533[r#35, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_533, Mask);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  355.38: Fraction might be negative."} 0 <= 50;
    assert {:msg "  355.38: Fraction might exceed 100."} 50 <= 100;
    assume r#35 != null;
    Heap[r#35, AVLTreeNode.height] := inhaleHeap#_533[r#35, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#35, AVLTreeNode.height] := Mask[r#35, AVLTreeNode.height][perm$R := Mask[r#35, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_533[r#35, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_533, Mask);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  356.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  356.45: Fraction might exceed 100."} 50 <= 100;
    assume r#35 != null;
    Heap[r#35, AVLTreeNode.balanceFactor] := inhaleHeap#_533[r#35, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#35, AVLTreeNode.balanceFactor] := Mask[r#35, AVLTreeNode.balanceFactor][perm$R := Mask[r#35, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_533[r#35, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_533, Mask);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  357.26: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  357.26: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.height);
    assert {:msg "  357.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  357.42: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assert {:msg "  357.53: Receiver might be null."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#35 != null);
    assert {:msg "  357.53: Location might not be readable."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#35, AVLTreeNode.height);
    assert {:msg "  357.71: Receiver might be null."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  357.71: Location might not be readable."} true && (!(Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume (Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#35, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  } else {
  }
  assert {:msg "  359.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  359.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#35 == null);
  } else {
  }
  assert {:msg "  360.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  360.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assume r#35 == null;
  } else {
  }
  assert {:msg "  361.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  361.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#35 == null) {
  } else {
    assert {:msg "  361.35: Receiver might be null."} true ==> (r#35 != null);
    assert {:msg "  361.35: Location might not be readable."} true ==> CanRead(Mask, r#35, AVLTreeNode.height);
  }
  assert {:msg "  361.52: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> (this != null);
  assert {:msg "  361.52: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#35 == null) {
  } else {
    assert {:msg "  361.72: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> (r#35 != null);
    assert {:msg "  361.72: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]))) ==> CanRead(Mask, r#35, AVLTreeNode.height);
  }
  assume (old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]) + 1));
  assume !(m#36 == null);
  assume m#36 != null;
  Heap[m#36, AVLTreeNode.valid] := inhaleHeap#_533[m#36, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_533[m#36, AVLTreeNode.valid] == Heap;
  Mask[m#36, AVLTreeNode.valid] := Mask[m#36, AVLTreeNode.valid][perm$R := Mask[m#36, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_533[m#36, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_533, Mask);
  assert {:msg "  366.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  366.24: Fraction might exceed 100."} 50 <= 100;
  assume m#36 != null;
  Heap[m#36, AVLTreeNode.height] := inhaleHeap#_533[m#36, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[m#36, AVLTreeNode.height] := Mask[m#36, AVLTreeNode.height][perm$R := Mask[m#36, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_533[m#36, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_533, Mask);
  assert {:msg "  367.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  367.31: Fraction might exceed 100."} 50 <= 100;
  assume m#36 != null;
  Heap[m#36, AVLTreeNode.balanceFactor] := inhaleHeap#_533[m#36, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[m#36, AVLTreeNode.balanceFactor] := Mask[m#36, AVLTreeNode.balanceFactor][perm$R := Mask[m#36, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_533[m#36, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_533, Mask);
  assert {:msg "  368.11: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  368.11: Location might not be readable."} true ==> CanRead(Mask, m#36, AVLTreeNode.height);
  assume Heap[m#36, AVLTreeNode.height] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.pruneMax(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#35: ref where (r#35 == null) || (dtype(r#35) == AVLTreeNode#t), m#36: ref where (m#36 == null) || (dtype(m#36) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_534: HeapType;
  var exhaleMask#_535: MaskType;
  var fraction#_536: int;
  var inhaleHeap#_537: HeapType;
  var this#135: ref where (this#135 == null) || (dtype(this#135) == AVLTreeNode#t);
  var callHeap#_538: HeapType;
  var callMask#_539: MaskType;
  var callCredits#_540: CreditsType;
  var exhaleMask#_541: MaskType;
  var fraction#_542: int;
  var fraction#_543: int;
  var fraction#_544: int;
  var fraction#_545: int;
  var fraction#_546: int;
  var fraction#_547: int;
  var fraction#_548: int;
  var fraction#_549: int;
  var fraction#_550: int;
  var fraction#_551: int;
  var fraction#_552: int;
  var isHeld#_553: int;
  var isRdHeld#_554: bool;
  var inhaleHeap#_555: HeapType;
  var nr#38: ref where (nr#38 == null) || (dtype(nr#38) == AVLTreeNode#t);
  var this#136: ref where (this#136 == null) || (dtype(this#136) == AVLTreeNode#t);
  var r#137: ref where (r#137 == null) || (dtype(r#137) == AVLTreeNode#t);
  var m#138: ref where (m#138 == null) || (dtype(m#138) == AVLTreeNode#t);
  var callHeap#_556: HeapType;
  var callMask#_557: MaskType;
  var callCredits#_558: CreditsType;
  var exhaleMask#_559: MaskType;
  var fraction#_560: int;
  var fraction#_561: int;
  var fraction#_562: int;
  var isHeld#_563: int;
  var isRdHeld#_564: bool;
  var inhaleHeap#_565: HeapType;
  var bf#40: int where true;
  var this#139: ref where (this#139 == null) || (dtype(this#139) == AVLTreeNode#t);
  var bf#140: int where true;
  var callHeap#_566: HeapType;
  var callMask#_567: MaskType;
  var callCredits#_568: CreditsType;
  var exhaleMask#_569: MaskType;
  var epsilons#_570: int;
  var fraction#_571: int;
  var epsilons#_572: int;
  var epsilons#_573: int;
  var fraction#_574: int;
  var epsilons#_575: int;
  var isHeld#_576: int;
  var isRdHeld#_577: bool;
  var inhaleHeap#_578: HeapType;
  var this#141: ref where (this#141 == null) || (dtype(this#141) == AVLTreeNode#t);
  var r#142: ref where (r#142 == null) || (dtype(r#142) == AVLTreeNode#t);
  var callHeap#_579: HeapType;
  var callMask#_580: MaskType;
  var callCredits#_581: CreditsType;
  var exhaleMask#_582: MaskType;
  var fraction#_583: int;
  var fraction#_584: int;
  var fraction#_585: int;
  var fraction#_586: int;
  var fraction#_587: int;
  var fraction#_588: int;
  var fraction#_589: int;
  var fraction#_590: int;
  var fraction#_591: int;
  var fraction#_592: int;
  var fraction#_593: int;
  var isHeld#_594: int;
  var isRdHeld#_595: bool;
  var inhaleHeap#_596: HeapType;
  var this#143: ref where (this#143 == null) || (dtype(this#143) == AVLTreeNode#t);
  var callHeap#_597: HeapType;
  var callMask#_598: MaskType;
  var callCredits#_599: CreditsType;
  var exhaleMask#_600: MaskType;
  var fraction#_601: int;
  var fraction#_602: int;
  var fraction#_603: int;
  var fraction#_604: int;
  var fraction#_605: int;
  var fraction#_606: int;
  var fraction#_607: int;
  var fraction#_608: int;
  var fraction#_609: int;
  var fraction#_610: int;
  var fraction#_611: int;
  var isHeld#_612: int;
  var isRdHeld#_613: bool;
  var inhaleHeap#_614: HeapType;
  var exhaleMask#_615: MaskType;
  var fraction#_616: int;
  var fraction#_617: int;
  var fraction#_618: int;
  var fraction#_619: int;
  var fraction#_620: int;
  var fraction#_621: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_534;
  assume IsGoodInhaleState(inhaleHeap#_534, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_534[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_534[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_534[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_534, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_534[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_534[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_534, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_534[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_534[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_534, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  374.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_535 := Mask;
  fraction#_536 := 100;
  assert {:msg "  374.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_536 <= exhaleMask#_535[this, AVLTreeNode.valid][perm$R]) && ((fraction#_536 == exhaleMask#_535[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_535[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_535[this, AVLTreeNode.valid] := exhaleMask#_535[this, AVLTreeNode.valid][perm$R := exhaleMask#_535[this, AVLTreeNode.valid][perm$R] - fraction#_536];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_535);
  Mask := exhaleMask#_535;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_537 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_537, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_537[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_537[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_537, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_537[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_537[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_537, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_537[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_537[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_537, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_537[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_537[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_537, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_537[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_537[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_537, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_537, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_537, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_537[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_537, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_537, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_537, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_537[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_537, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  376.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  376.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
    // assigment to r
    assert {:msg "  377.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  377.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    r#35 := Heap[this, AVLTreeNode.left];
    // update field left
    assert {:msg "  378.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := null;
    assume wf(Heap, Mask);
    // call close
    callHeap#_538 := Heap;
    callMask#_539 := Mask;
    callCredits#_540 := Credits;
    assert {:msg "  379.4: The target of the method call might be null."} this != null;
    this#135 := this;
    // begin exhale (precondition)
    exhaleMask#_541 := Mask;
    fraction#_542 := 100;
    assert {:msg "  379.4: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_542 <= exhaleMask#_541[this#135, AVLTreeNode.key][perm$R]) && ((fraction#_542 == exhaleMask#_541[this#135, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_541[this#135, AVLTreeNode.key][perm$N]));
    exhaleMask#_541[this#135, AVLTreeNode.key] := exhaleMask#_541[this#135, AVLTreeNode.key][perm$R := exhaleMask#_541[this#135, AVLTreeNode.key][perm$R] - fraction#_542];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_541);
    fraction#_543 := 100;
    assert {:msg "  379.4: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_543 <= exhaleMask#_541[this#135, AVLTreeNode.height][perm$R]) && ((fraction#_543 == exhaleMask#_541[this#135, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_541[this#135, AVLTreeNode.height][perm$N]));
    exhaleMask#_541[this#135, AVLTreeNode.height] := exhaleMask#_541[this#135, AVLTreeNode.height][perm$R := exhaleMask#_541[this#135, AVLTreeNode.height][perm$R] - fraction#_543];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_541);
    fraction#_544 := 100;
    assert {:msg "  379.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_544 <= exhaleMask#_541[this#135, AVLTreeNode.left][perm$R]) && ((fraction#_544 == exhaleMask#_541[this#135, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_541[this#135, AVLTreeNode.left][perm$N]));
    exhaleMask#_541[this#135, AVLTreeNode.left] := exhaleMask#_541[this#135, AVLTreeNode.left][perm$R := exhaleMask#_541[this#135, AVLTreeNode.left][perm$R] - fraction#_544];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_541);
    fraction#_545 := 100;
    assert {:msg "  379.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_545 <= exhaleMask#_541[this#135, AVLTreeNode.right][perm$R]) && ((fraction#_545 == exhaleMask#_541[this#135, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_541[this#135, AVLTreeNode.right][perm$N]));
    exhaleMask#_541[this#135, AVLTreeNode.right] := exhaleMask#_541[this#135, AVLTreeNode.right][perm$R := exhaleMask#_541[this#135, AVLTreeNode.right][perm$R] - fraction#_545];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_541);
    fraction#_546 := 100;
    assert {:msg "  379.4: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_546 <= exhaleMask#_541[this#135, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_546 == exhaleMask#_541[this#135, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_541[this#135, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_541[this#135, AVLTreeNode.balanceFactor] := exhaleMask#_541[this#135, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_541[this#135, AVLTreeNode.balanceFactor][perm$R] - fraction#_546];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_541);
    if (!(Heap[this#135, AVLTreeNode.left] == null)) {
      fraction#_547 := 100;
      assert {:msg "  379.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_547 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_547 == exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_547];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_541);
    } else {
    }
    if (!(Heap[this#135, AVLTreeNode.left] == null)) {
      fraction#_548 := 50;
      assert {:msg "  379.4: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_548 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_548 == exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_548];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_541);
    } else {
    }
    if (!(Heap[this#135, AVLTreeNode.left] == null)) {
      fraction#_549 := 50;
      assert {:msg "  379.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_549 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_549 == exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_541[Heap[this#135, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_549];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_541);
    } else {
    }
    if (!(Heap[this#135, AVLTreeNode.right] == null)) {
      fraction#_550 := 100;
      assert {:msg "  379.4: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_550 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_550 == exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_550];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_541);
    } else {
    }
    if (!(Heap[this#135, AVLTreeNode.right] == null)) {
      fraction#_551 := 50;
      assert {:msg "  379.4: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_551 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_551 == exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_551];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_541);
    } else {
    }
    if (!(Heap[this#135, AVLTreeNode.right] == null)) {
      fraction#_552 := 50;
      assert {:msg "  379.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_552 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_552 == exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_541[Heap[this#135, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_552];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_541);
    } else {
    }
    assert {:msg "  379.4: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#135, AVLTreeNode.left] == null, 0, Heap[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#135, AVLTreeNode.right] == null, 0, Heap[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  379.4: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#135, AVLTreeNode.left] == null, 0, Heap[Heap[this#135, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#135, AVLTreeNode.right] == null, 0, Heap[Heap[this#135, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    Mask := exhaleMask#_541;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_555;
    assume IsGoodInhaleState(inhaleHeap#_555, Heap, Mask);
    assume this#135 != null;
    Heap[this#135, AVLTreeNode.valid] := inhaleHeap#_555[this#135, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_555[this#135, AVLTreeNode.valid] == Heap;
    Mask[this#135, AVLTreeNode.valid] := Mask[this#135, AVLTreeNode.valid][perm$R := Mask[this#135, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_555[this#135, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_555, Mask);
    assume this#135 != null;
    Heap[this#135, AVLTreeNode.height] := inhaleHeap#_555[this#135, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#135, AVLTreeNode.height] := Mask[this#135, AVLTreeNode.height][perm$R := Mask[this#135, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_555[this#135, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_555, Mask);
    assume this#135 != null;
    Heap[this#135, AVLTreeNode.balanceFactor] := inhaleHeap#_555[this#135, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#135, AVLTreeNode.balanceFactor] := Mask[this#135, AVLTreeNode.balanceFactor][perm$R := Mask[this#135, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_555[this#135, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_555, Mask);
    assume Heap[this#135, AVLTreeNode.height] == ite(ite(callHeap#_538[this#135, AVLTreeNode.left] == null, 0, callHeap#_538[callHeap#_538[this#135, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_538[this#135, AVLTreeNode.right] == null, 0, callHeap#_538[callHeap#_538[this#135, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_538[this#135, AVLTreeNode.left] == null, 0, callHeap#_538[callHeap#_538[this#135, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_538[this#135, AVLTreeNode.right] == null, 0, callHeap#_538[callHeap#_538[this#135, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#135, AVLTreeNode.balanceFactor] == (ite(callHeap#_538[this#135, AVLTreeNode.left] == null, 0, callHeap#_538[callHeap#_538[this#135, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_538[this#135, AVLTreeNode.right] == null, 0, callHeap#_538[callHeap#_538[this#135, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // assigment to m
    m#36 := this;
  } else {
    // local var nr
    // call pruneMax
    callHeap#_556 := Heap;
    callMask#_557 := Mask;
    callCredits#_558 := Credits;
    assert {:msg "  385.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  385.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  385.4: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
    this#136 := Heap[this, AVLTreeNode.right];
    // begin exhale (precondition)
    exhaleMask#_559 := Mask;
    fraction#_560 := 100;
    assert {:msg "  385.4: The precondition at 348.12 might not hold. Insufficient fraction at 348.12 for AVLTreeNode.valid."} (fraction#_560 <= exhaleMask#_559[this#136, AVLTreeNode.valid][perm$R]) && ((fraction#_560 == exhaleMask#_559[this#136, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_559[this#136, AVLTreeNode.valid][perm$N]));
    exhaleMask#_559[this#136, AVLTreeNode.valid] := exhaleMask#_559[this#136, AVLTreeNode.valid][perm$R := exhaleMask#_559[this#136, AVLTreeNode.valid][perm$R] - fraction#_560];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_559);
    fraction#_561 := 50;
    assert {:msg "  385.4: The precondition at 350.12 might not hold. Insufficient fraction at 350.12 for AVLTreeNode.height."} (fraction#_561 <= exhaleMask#_559[this#136, AVLTreeNode.height][perm$R]) && ((fraction#_561 == exhaleMask#_559[this#136, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_559[this#136, AVLTreeNode.height][perm$N]));
    exhaleMask#_559[this#136, AVLTreeNode.height] := exhaleMask#_559[this#136, AVLTreeNode.height][perm$R := exhaleMask#_559[this#136, AVLTreeNode.height][perm$R] - fraction#_561];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_559);
    fraction#_562 := 50;
    assert {:msg "  385.4: The precondition at 351.12 might not hold. Insufficient fraction at 351.12 for AVLTreeNode.balanceFactor."} (fraction#_562 <= exhaleMask#_559[this#136, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_562 == exhaleMask#_559[this#136, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_559[this#136, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_559[this#136, AVLTreeNode.balanceFactor] := exhaleMask#_559[this#136, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_559[this#136, AVLTreeNode.balanceFactor][perm$R] - fraction#_562];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_559);
    Mask := exhaleMask#_559;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#137;
    havoc m#138;
    // inhale (postcondition)
    havoc inhaleHeap#_565;
    assume IsGoodInhaleState(inhaleHeap#_565, Heap, Mask);
    if (!(r#137 == null)) {
      assume r#137 != null;
      Heap[r#137, AVLTreeNode.valid] := inhaleHeap#_565[r#137, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_565[r#137, AVLTreeNode.valid] == Heap;
      Mask[r#137, AVLTreeNode.valid] := Mask[r#137, AVLTreeNode.valid][perm$R := Mask[r#137, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_565[r#137, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_565, Mask);
    } else {
    }
    if (!(r#137 == null)) {
      assume r#137 != null;
      Heap[r#137, AVLTreeNode.height] := inhaleHeap#_565[r#137, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#137, AVLTreeNode.height] := Mask[r#137, AVLTreeNode.height][perm$R := Mask[r#137, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_565[r#137, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_565, Mask);
    } else {
    }
    if (!(r#137 == null)) {
      assume r#137 != null;
      Heap[r#137, AVLTreeNode.balanceFactor] := inhaleHeap#_565[r#137, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#137, AVLTreeNode.balanceFactor] := Mask[r#137, AVLTreeNode.balanceFactor][perm$R := Mask[r#137, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_565[r#137, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_565, Mask);
    } else {
    }
    if (!(r#137 == null)) {
      assume (Heap[r#137, AVLTreeNode.height] == callHeap#_556[this#136, AVLTreeNode.height]) || ((Heap[r#137, AVLTreeNode.height] + 1) == callHeap#_556[this#136, AVLTreeNode.height]);
    } else {
    }
    if (callHeap#_556[this#136, AVLTreeNode.height] > 1) {
      assume !(r#137 == null);
    } else {
    }
    if (callHeap#_556[this#136, AVLTreeNode.height] == 1) {
      assume r#137 == null;
    } else {
    }
    assume (callHeap#_556[this#136, AVLTreeNode.height] == ite(r#137 == null, 0, Heap[r#137, AVLTreeNode.height])) || (callHeap#_556[this#136, AVLTreeNode.height] == (ite(r#137 == null, 0, Heap[r#137, AVLTreeNode.height]) + 1));
    assume !(m#138 == null);
    assume m#138 != null;
    Heap[m#138, AVLTreeNode.valid] := inhaleHeap#_565[m#138, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_565[m#138, AVLTreeNode.valid] == Heap;
    Mask[m#138, AVLTreeNode.valid] := Mask[m#138, AVLTreeNode.valid][perm$R := Mask[m#138, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_565[m#138, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_565, Mask);
    assume m#138 != null;
    Heap[m#138, AVLTreeNode.height] := inhaleHeap#_565[m#138, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[m#138, AVLTreeNode.height] := Mask[m#138, AVLTreeNode.height][perm$R := Mask[m#138, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_565[m#138, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_565, Mask);
    assume m#138 != null;
    Heap[m#138, AVLTreeNode.balanceFactor] := inhaleHeap#_565[m#138, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[m#138, AVLTreeNode.balanceFactor] := Mask[m#138, AVLTreeNode.balanceFactor][perm$R := Mask[m#138, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_565[m#138, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_565, Mask);
    assume Heap[m#138, AVLTreeNode.height] == 1;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    nr#38 := r#137;
    m#36 := m#138;
    // update field right
    assert {:msg "  386.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := nr#38;
    assume wf(Heap, Mask);
    // local var bf
    // call getBalanceFactorI
    callHeap#_566 := Heap;
    callMask#_567 := Mask;
    callCredits#_568 := Credits;
    assert {:msg "  388.4: The target of the method call might be null."} this != null;
    this#139 := this;
    // begin exhale (precondition)
    exhaleMask#_569 := Mask;
    epsilons#_570 := 1;
    assert {:msg "  388.4: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_569[this#139, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_570 <= exhaleMask#_569[this#139, AVLTreeNode.left][perm$N]);
    if ((exhaleMask#_569[this#139, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_569[this#139, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_569[this#139, AVLTreeNode.left] := exhaleMask#_569[this#139, AVLTreeNode.left][perm$N := exhaleMask#_569[this#139, AVLTreeNode.left][perm$N] - epsilons#_570];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_569);
    if (!(Heap[this#139, AVLTreeNode.left] == null)) {
      fraction#_571 := 100;
      assert {:msg "  388.4: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_571 <= exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_571 == exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_571];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_569);
    } else {
    }
    if (!(Heap[this#139, AVLTreeNode.left] == null)) {
      epsilons#_572 := 1;
      assert {:msg "  388.4: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_572 <= exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
      if ((exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_569[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_572];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_569);
    } else {
    }
    epsilons#_573 := 1;
    assert {:msg "  388.4: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_569[this#139, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_573 <= exhaleMask#_569[this#139, AVLTreeNode.right][perm$N]);
    if ((exhaleMask#_569[this#139, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_569[this#139, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_569[this#139, AVLTreeNode.right] := exhaleMask#_569[this#139, AVLTreeNode.right][perm$N := exhaleMask#_569[this#139, AVLTreeNode.right][perm$N] - epsilons#_573];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_569);
    if (!(Heap[this#139, AVLTreeNode.right] == null)) {
      fraction#_574 := 100;
      assert {:msg "  388.4: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_574 <= exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_574 == exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_574];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_569);
    } else {
    }
    if (!(Heap[this#139, AVLTreeNode.right] == null)) {
      epsilons#_575 := 1;
      assert {:msg "  388.4: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_575 <= exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
      if ((exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_569[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_575];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_569);
    } else {
    }
    Mask := exhaleMask#_569;
    assume wf(Heap, Mask);
    // end exhale
    havoc bf#140;
    // inhale (postcondition)
    havoc inhaleHeap#_578;
    assume IsGoodInhaleState(inhaleHeap#_578, Heap, Mask);
    assume this#139 != null;
    Heap[this#139, AVLTreeNode.left] := inhaleHeap#_578[this#139, AVLTreeNode.left];
    assume wf(Heap, Mask);
    assume (Heap[this#139, AVLTreeNode.left] == null) || (dtype(Heap[this#139, AVLTreeNode.left]) == AVLTreeNode#t);
    if ((Mask[this#139, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#139, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      Mask[this#139, AVLTreeNode.left] := Mask[this#139, AVLTreeNode.left][perm$N := Mask[this#139, AVLTreeNode.left][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_578[this#139, AVLTreeNode.left]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_578, Mask);
    if (!(Heap[this#139, AVLTreeNode.left] == null)) {
      assume Heap[this#139, AVLTreeNode.left] != null;
      Heap[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_578[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_578[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_578[Heap[this#139, AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_578, Mask);
    } else {
    }
    if (!(Heap[this#139, AVLTreeNode.left] == null)) {
      assume Heap[this#139, AVLTreeNode.left] != null;
      Heap[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_578[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      if ((Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_578[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_578, Mask);
    } else {
    }
    assume this#139 != null;
    Heap[this#139, AVLTreeNode.right] := inhaleHeap#_578[this#139, AVLTreeNode.right];
    assume wf(Heap, Mask);
    assume (Heap[this#139, AVLTreeNode.right] == null) || (dtype(Heap[this#139, AVLTreeNode.right]) == AVLTreeNode#t);
    if ((Mask[this#139, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#139, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      Mask[this#139, AVLTreeNode.right] := Mask[this#139, AVLTreeNode.right][perm$N := Mask[this#139, AVLTreeNode.right][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_578[this#139, AVLTreeNode.right]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_578, Mask);
    if (!(Heap[this#139, AVLTreeNode.right] == null)) {
      assume Heap[this#139, AVLTreeNode.right] != null;
      Heap[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_578[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_578[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_578[Heap[this#139, AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_578, Mask);
    } else {
    }
    if (!(Heap[this#139, AVLTreeNode.right] == null)) {
      assume Heap[this#139, AVLTreeNode.right] != null;
      Heap[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_578[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      if ((Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_578[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_578, Mask);
    } else {
    }
    assume bf#140 == (ite(Heap[this#139, AVLTreeNode.left] == null, 0, Heap[Heap[this#139, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#139, AVLTreeNode.right] == null, 0, Heap[Heap[this#139, AVLTreeNode.right], AVLTreeNode.height]));
    if (bf#140 > 0) {
      assume !(Heap[this#139, AVLTreeNode.left] == null);
    } else {
    }
    if (bf#140 < 0) {
      assume !(Heap[this#139, AVLTreeNode.right] == null);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    bf#40 := bf#140;
    // if
    if (bf#40 == 2) {
      // call rebalanceLeft
      callHeap#_579 := Heap;
      callMask#_580 := Mask;
      callCredits#_581 := Credits;
      assert {:msg "  390.5: The target of the method call might be null."} this != null;
      this#141 := this;
      // begin exhale (precondition)
      exhaleMask#_582 := Mask;
      fraction#_583 := 100;
      assert {:msg "  390.5: The precondition at 598.12 might not hold. Insufficient fraction at 598.12 for AVLTreeNode.key."} (fraction#_583 <= exhaleMask#_582[this#141, AVLTreeNode.key][perm$R]) && ((fraction#_583 == exhaleMask#_582[this#141, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_582[this#141, AVLTreeNode.key][perm$N]));
      exhaleMask#_582[this#141, AVLTreeNode.key] := exhaleMask#_582[this#141, AVLTreeNode.key][perm$R := exhaleMask#_582[this#141, AVLTreeNode.key][perm$R] - fraction#_583];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      fraction#_584 := 100;
      assert {:msg "  390.5: The precondition at 599.12 might not hold. Insufficient fraction at 599.12 for AVLTreeNode.height."} (fraction#_584 <= exhaleMask#_582[this#141, AVLTreeNode.height][perm$R]) && ((fraction#_584 == exhaleMask#_582[this#141, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_582[this#141, AVLTreeNode.height][perm$N]));
      exhaleMask#_582[this#141, AVLTreeNode.height] := exhaleMask#_582[this#141, AVLTreeNode.height][perm$R := exhaleMask#_582[this#141, AVLTreeNode.height][perm$R] - fraction#_584];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      fraction#_585 := 100;
      assert {:msg "  390.5: The precondition at 600.12 might not hold. Insufficient fraction at 600.12 for AVLTreeNode.left."} (fraction#_585 <= exhaleMask#_582[this#141, AVLTreeNode.left][perm$R]) && ((fraction#_585 == exhaleMask#_582[this#141, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_582[this#141, AVLTreeNode.left][perm$N]));
      exhaleMask#_582[this#141, AVLTreeNode.left] := exhaleMask#_582[this#141, AVLTreeNode.left][perm$R := exhaleMask#_582[this#141, AVLTreeNode.left][perm$R] - fraction#_585];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      fraction#_586 := 100;
      assert {:msg "  390.5: The precondition at 601.12 might not hold. Insufficient fraction at 601.12 for AVLTreeNode.right."} (fraction#_586 <= exhaleMask#_582[this#141, AVLTreeNode.right][perm$R]) && ((fraction#_586 == exhaleMask#_582[this#141, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_582[this#141, AVLTreeNode.right][perm$N]));
      exhaleMask#_582[this#141, AVLTreeNode.right] := exhaleMask#_582[this#141, AVLTreeNode.right][perm$R := exhaleMask#_582[this#141, AVLTreeNode.right][perm$R] - fraction#_586];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      fraction#_587 := 100;
      assert {:msg "  390.5: The precondition at 604.12 might not hold. Insufficient fraction at 604.12 for AVLTreeNode.balanceFactor."} (fraction#_587 <= exhaleMask#_582[this#141, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_587 == exhaleMask#_582[this#141, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_582[this#141, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_582[this#141, AVLTreeNode.balanceFactor] := exhaleMask#_582[this#141, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_582[this#141, AVLTreeNode.balanceFactor][perm$R] - fraction#_587];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      assert {:msg "  390.5: The precondition at 606.12 might not hold. The expression at 606.12 might not evaluate to true."} !(Heap[this#141, AVLTreeNode.left] == null);
      fraction#_588 := 100;
      assert {:msg "  390.5: The precondition at 607.12 might not hold. Insufficient fraction at 607.12 for AVLTreeNode.valid."} (fraction#_588 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_588 == exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_588];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      fraction#_589 := 50;
      assert {:msg "  390.5: The precondition at 608.12 might not hold. Insufficient fraction at 608.12 for AVLTreeNode.height."} (fraction#_589 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_589 == exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_589];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      fraction#_590 := 50;
      assert {:msg "  390.5: The precondition at 610.12 might not hold. Insufficient fraction at 610.12 for AVLTreeNode.balanceFactor."} (fraction#_590 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_590 == exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_582[Heap[this#141, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_590];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_582);
      if (!(Heap[this#141, AVLTreeNode.right] == null)) {
        fraction#_591 := 100;
        assert {:msg "  390.5: The precondition at 613.12 might not hold. Insufficient fraction at 613.28 for AVLTreeNode.valid."} (fraction#_591 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_591 == exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_591];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_582);
      } else {
      }
      if (!(Heap[this#141, AVLTreeNode.right] == null)) {
        fraction#_592 := 50;
        assert {:msg "  390.5: The precondition at 614.12 might not hold. Insufficient fraction at 614.28 for AVLTreeNode.height."} (fraction#_592 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_592 == exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_592];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_582);
      } else {
      }
      if (!(Heap[this#141, AVLTreeNode.right] == null)) {
        fraction#_593 := 50;
        assert {:msg "  390.5: The precondition at 616.12 might not hold. Insufficient fraction at 616.28 for AVLTreeNode.balanceFactor."} (fraction#_593 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_593 == exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_582[Heap[this#141, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_593];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_582);
      } else {
      }
      assert {:msg "  390.5: The precondition at 619.12 might not hold. The expression at 619.12 might not evaluate to true."} (Heap[Heap[this#141, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#141, AVLTreeNode.right] == null, 0, Heap[Heap[this#141, AVLTreeNode.right], AVLTreeNode.height])) == 2;
      Mask := exhaleMask#_582;
      assume wf(Heap, Mask);
      // end exhale
      havoc r#142;
      // inhale (postcondition)
      havoc inhaleHeap#_596;
      assume IsGoodInhaleState(inhaleHeap#_596, Heap, Mask);
      assume r#142 != null;
      Heap[r#142, AVLTreeNode.valid] := inhaleHeap#_596[r#142, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_596[r#142, AVLTreeNode.valid] == Heap;
      Mask[r#142, AVLTreeNode.valid] := Mask[r#142, AVLTreeNode.valid][perm$R := Mask[r#142, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_596[r#142, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_596, Mask);
      assume r#142 != null;
      Heap[r#142, AVLTreeNode.height] := inhaleHeap#_596[r#142, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#142, AVLTreeNode.height] := Mask[r#142, AVLTreeNode.height][perm$R := Mask[r#142, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_596[r#142, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_596, Mask);
      assume r#142 != null;
      Heap[r#142, AVLTreeNode.balanceFactor] := inhaleHeap#_596[r#142, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#142, AVLTreeNode.balanceFactor] := Mask[r#142, AVLTreeNode.balanceFactor][perm$R := Mask[r#142, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_596[r#142, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_596, Mask);
      assume (Heap[r#142, AVLTreeNode.height] == callHeap#_579[callHeap#_579[this#141, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#142, AVLTreeNode.height] == (callHeap#_579[callHeap#_579[this#141, AVLTreeNode.left], AVLTreeNode.height] + 1));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      r#35 := r#142;
    } else {
      // call close
      callHeap#_597 := Heap;
      callMask#_598 := Mask;
      callCredits#_599 := Credits;
      assert {:msg "  392.5: The target of the method call might be null."} this != null;
      this#143 := this;
      // begin exhale (precondition)
      exhaleMask#_600 := Mask;
      fraction#_601 := 100;
      assert {:msg "  392.5: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_601 <= exhaleMask#_600[this#143, AVLTreeNode.key][perm$R]) && ((fraction#_601 == exhaleMask#_600[this#143, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_600[this#143, AVLTreeNode.key][perm$N]));
      exhaleMask#_600[this#143, AVLTreeNode.key] := exhaleMask#_600[this#143, AVLTreeNode.key][perm$R := exhaleMask#_600[this#143, AVLTreeNode.key][perm$R] - fraction#_601];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_600);
      fraction#_602 := 100;
      assert {:msg "  392.5: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_602 <= exhaleMask#_600[this#143, AVLTreeNode.height][perm$R]) && ((fraction#_602 == exhaleMask#_600[this#143, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_600[this#143, AVLTreeNode.height][perm$N]));
      exhaleMask#_600[this#143, AVLTreeNode.height] := exhaleMask#_600[this#143, AVLTreeNode.height][perm$R := exhaleMask#_600[this#143, AVLTreeNode.height][perm$R] - fraction#_602];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_600);
      fraction#_603 := 100;
      assert {:msg "  392.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_603 <= exhaleMask#_600[this#143, AVLTreeNode.left][perm$R]) && ((fraction#_603 == exhaleMask#_600[this#143, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_600[this#143, AVLTreeNode.left][perm$N]));
      exhaleMask#_600[this#143, AVLTreeNode.left] := exhaleMask#_600[this#143, AVLTreeNode.left][perm$R := exhaleMask#_600[this#143, AVLTreeNode.left][perm$R] - fraction#_603];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_600);
      fraction#_604 := 100;
      assert {:msg "  392.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_604 <= exhaleMask#_600[this#143, AVLTreeNode.right][perm$R]) && ((fraction#_604 == exhaleMask#_600[this#143, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_600[this#143, AVLTreeNode.right][perm$N]));
      exhaleMask#_600[this#143, AVLTreeNode.right] := exhaleMask#_600[this#143, AVLTreeNode.right][perm$R := exhaleMask#_600[this#143, AVLTreeNode.right][perm$R] - fraction#_604];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_600);
      fraction#_605 := 100;
      assert {:msg "  392.5: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_605 <= exhaleMask#_600[this#143, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_605 == exhaleMask#_600[this#143, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_600[this#143, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_600[this#143, AVLTreeNode.balanceFactor] := exhaleMask#_600[this#143, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_600[this#143, AVLTreeNode.balanceFactor][perm$R] - fraction#_605];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_600);
      if (!(Heap[this#143, AVLTreeNode.left] == null)) {
        fraction#_606 := 100;
        assert {:msg "  392.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_606 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_606 == exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_606];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_600);
      } else {
      }
      if (!(Heap[this#143, AVLTreeNode.left] == null)) {
        fraction#_607 := 50;
        assert {:msg "  392.5: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_607 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_607 == exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_607];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_600);
      } else {
      }
      if (!(Heap[this#143, AVLTreeNode.left] == null)) {
        fraction#_608 := 50;
        assert {:msg "  392.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_608 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_608 == exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_600[Heap[this#143, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_608];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_600);
      } else {
      }
      if (!(Heap[this#143, AVLTreeNode.right] == null)) {
        fraction#_609 := 100;
        assert {:msg "  392.5: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_609 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_609 == exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_609];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_600);
      } else {
      }
      if (!(Heap[this#143, AVLTreeNode.right] == null)) {
        fraction#_610 := 50;
        assert {:msg "  392.5: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_610 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_610 == exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_610];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_600);
      } else {
      }
      if (!(Heap[this#143, AVLTreeNode.right] == null)) {
        fraction#_611 := 50;
        assert {:msg "  392.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_611 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_611 == exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_600[Heap[this#143, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_611];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_600);
      } else {
      }
      assert {:msg "  392.5: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#143, AVLTreeNode.left] == null, 0, Heap[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#143, AVLTreeNode.right] == null, 0, Heap[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  392.5: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#143, AVLTreeNode.left] == null, 0, Heap[Heap[this#143, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#143, AVLTreeNode.right] == null, 0, Heap[Heap[this#143, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      Mask := exhaleMask#_600;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_614;
      assume IsGoodInhaleState(inhaleHeap#_614, Heap, Mask);
      assume this#143 != null;
      Heap[this#143, AVLTreeNode.valid] := inhaleHeap#_614[this#143, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_614[this#143, AVLTreeNode.valid] == Heap;
      Mask[this#143, AVLTreeNode.valid] := Mask[this#143, AVLTreeNode.valid][perm$R := Mask[this#143, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_614[this#143, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_614, Mask);
      assume this#143 != null;
      Heap[this#143, AVLTreeNode.height] := inhaleHeap#_614[this#143, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#143, AVLTreeNode.height] := Mask[this#143, AVLTreeNode.height][perm$R := Mask[this#143, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_614[this#143, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_614, Mask);
      assume this#143 != null;
      Heap[this#143, AVLTreeNode.balanceFactor] := inhaleHeap#_614[this#143, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#143, AVLTreeNode.balanceFactor] := Mask[this#143, AVLTreeNode.balanceFactor][perm$R := Mask[this#143, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_614[this#143, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_614, Mask);
      assume Heap[this#143, AVLTreeNode.height] == ite(ite(callHeap#_597[this#143, AVLTreeNode.left] == null, 0, callHeap#_597[callHeap#_597[this#143, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_597[this#143, AVLTreeNode.right] == null, 0, callHeap#_597[callHeap#_597[this#143, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_597[this#143, AVLTreeNode.left] == null, 0, callHeap#_597[callHeap#_597[this#143, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_597[this#143, AVLTreeNode.right] == null, 0, callHeap#_597[callHeap#_597[this#143, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#143, AVLTreeNode.balanceFactor] == (ite(callHeap#_597[this#143, AVLTreeNode.left] == null, 0, callHeap#_597[callHeap#_597[this#143, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_597[this#143, AVLTreeNode.right] == null, 0, callHeap#_597[callHeap#_597[this#143, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // assigment to r
      r#35 := this;
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_615 := Mask;
  if (!(r#35 == null)) {
    fraction#_616 := 100;
    assert {:msg "  347.2: The postcondition at 353.11 might not hold. Insufficient fraction at 353.25 for AVLTreeNode.valid."} (fraction#_616 <= exhaleMask#_615[r#35, AVLTreeNode.valid][perm$R]) && ((fraction#_616 == exhaleMask#_615[r#35, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_615[r#35, AVLTreeNode.valid][perm$N]));
    exhaleMask#_615[r#35, AVLTreeNode.valid] := exhaleMask#_615[r#35, AVLTreeNode.valid][perm$R := exhaleMask#_615[r#35, AVLTreeNode.valid][perm$R] - fraction#_616];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_615);
  } else {
  }
  if (!(r#35 == null)) {
    fraction#_617 := 50;
    assert {:msg "  347.2: The postcondition at 355.11 might not hold. Insufficient fraction at 355.25 for AVLTreeNode.height."} (fraction#_617 <= exhaleMask#_615[r#35, AVLTreeNode.height][perm$R]) && ((fraction#_617 == exhaleMask#_615[r#35, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_615[r#35, AVLTreeNode.height][perm$N]));
    exhaleMask#_615[r#35, AVLTreeNode.height] := exhaleMask#_615[r#35, AVLTreeNode.height][perm$R := exhaleMask#_615[r#35, AVLTreeNode.height][perm$R] - fraction#_617];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_615);
  } else {
  }
  if (!(r#35 == null)) {
    fraction#_618 := 50;
    assert {:msg "  347.2: The postcondition at 356.11 might not hold. Insufficient fraction at 356.25 for AVLTreeNode.balanceFactor."} (fraction#_618 <= exhaleMask#_615[r#35, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_618 == exhaleMask#_615[r#35, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_615[r#35, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_615[r#35, AVLTreeNode.balanceFactor] := exhaleMask#_615[r#35, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_615[r#35, AVLTreeNode.balanceFactor][perm$R] - fraction#_618];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_615);
  } else {
  }
  if (!(r#35 == null)) {
    assert {:msg "  347.2: The postcondition at 357.11 might not hold. The expression at 357.26 might not evaluate to true."} (Heap[r#35, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || ((Heap[r#35, AVLTreeNode.height] + 1) == old(Heap)[this, AVLTreeNode.height]);
  } else {
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  347.2: The postcondition at 359.11 might not hold. The expression at 359.30 might not evaluate to true."} !(r#35 == null);
  } else {
  }
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assert {:msg "  347.2: The postcondition at 360.11 might not hold. The expression at 360.30 might not evaluate to true."} r#35 == null;
  } else {
  }
  assert {:msg "  347.2: The postcondition at 361.11 might not hold. The expression at 361.11 might not evaluate to true."} (old(Heap)[this, AVLTreeNode.height] == ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#35 == null, 0, Heap[r#35, AVLTreeNode.height]) + 1));
  assert {:msg "  347.2: The postcondition at 363.11 might not hold. The expression at 363.11 might not evaluate to true."} !(m#36 == null);
  fraction#_619 := 100;
  assert {:msg "  347.2: The postcondition at 364.11 might not hold. Insufficient fraction at 364.11 for AVLTreeNode.valid."} (fraction#_619 <= exhaleMask#_615[m#36, AVLTreeNode.valid][perm$R]) && ((fraction#_619 == exhaleMask#_615[m#36, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_615[m#36, AVLTreeNode.valid][perm$N]));
  exhaleMask#_615[m#36, AVLTreeNode.valid] := exhaleMask#_615[m#36, AVLTreeNode.valid][perm$R := exhaleMask#_615[m#36, AVLTreeNode.valid][perm$R] - fraction#_619];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_615);
  fraction#_620 := 50;
  assert {:msg "  347.2: The postcondition at 366.11 might not hold. Insufficient fraction at 366.11 for AVLTreeNode.height."} (fraction#_620 <= exhaleMask#_615[m#36, AVLTreeNode.height][perm$R]) && ((fraction#_620 == exhaleMask#_615[m#36, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_615[m#36, AVLTreeNode.height][perm$N]));
  exhaleMask#_615[m#36, AVLTreeNode.height] := exhaleMask#_615[m#36, AVLTreeNode.height][perm$R := exhaleMask#_615[m#36, AVLTreeNode.height][perm$R] - fraction#_620];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_615);
  fraction#_621 := 50;
  assert {:msg "  347.2: The postcondition at 367.11 might not hold. Insufficient fraction at 367.11 for AVLTreeNode.balanceFactor."} (fraction#_621 <= exhaleMask#_615[m#36, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_621 == exhaleMask#_615[m#36, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_615[m#36, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_615[m#36, AVLTreeNode.balanceFactor] := exhaleMask#_615[m#36, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_615[m#36, AVLTreeNode.balanceFactor][perm$R] - fraction#_621];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_615);
  assert {:msg "  347.2: The postcondition at 368.11 might not hold. The expression at 368.11 might not evaluate to true."} Heap[m#36, AVLTreeNode.height] == 1;
  Mask := exhaleMask#_615;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  347.2: Method might lock/unlock more than allowed."} (forall lk#_622: ref :: {Heap[lk#_622, held]} {Heap[lk#_622, rdheld]} (((0 < Heap[lk#_622, held]) == (0 < old(Heap)[lk#_622, held])) && (Heap[lk#_622, rdheld] == old(Heap)[lk#_622, rdheld])) || false);
  assert {:msg "  347.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.pruneMin$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_623: HeapType;
  var inhaleHeap#_624: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_623;
  assume IsGoodInhaleState(inhaleHeap#_623, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_623[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_623[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_623[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_623, Mask);
  assert {:msg "  404.23: Fraction might be negative."} 0 <= 50;
  assert {:msg "  404.23: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_623[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_623[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_623, Mask);
  assert {:msg "  405.30: Fraction might be negative."} 0 <= 50;
  assert {:msg "  405.30: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_623[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_623[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_623, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_624;
  assume IsGoodInhaleState(inhaleHeap#_624, Heap, Mask);
  if (!(r#41 == null)) {
    assume r#41 != null;
    Heap[r#41, AVLTreeNode.valid] := inhaleHeap#_624[r#41, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_624[r#41, AVLTreeNode.valid] == Heap;
    Mask[r#41, AVLTreeNode.valid] := Mask[r#41, AVLTreeNode.valid][perm$R := Mask[r#41, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_624[r#41, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_624, Mask);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  409.38: Fraction might be negative."} 0 <= 50;
    assert {:msg "  409.38: Fraction might exceed 100."} 50 <= 100;
    assume r#41 != null;
    Heap[r#41, AVLTreeNode.height] := inhaleHeap#_624[r#41, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#41, AVLTreeNode.height] := Mask[r#41, AVLTreeNode.height][perm$R := Mask[r#41, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_624[r#41, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_624, Mask);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  410.45: Fraction might be negative."} 0 <= 50;
    assert {:msg "  410.45: Fraction might exceed 100."} 50 <= 100;
    assume r#41 != null;
    Heap[r#41, AVLTreeNode.balanceFactor] := inhaleHeap#_624[r#41, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#41, AVLTreeNode.balanceFactor] := Mask[r#41, AVLTreeNode.balanceFactor][perm$R := Mask[r#41, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_624[r#41, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_624, Mask);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  411.26: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  411.26: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.height);
    assert {:msg "  411.42: Receiver might be null."} true ==> (this != null);
    assert {:msg "  411.42: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assert {:msg "  411.53: Receiver might be null."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
    assert {:msg "  411.53: Location might not be readable."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask, r#41, AVLTreeNode.height);
    assert {:msg "  411.69: Receiver might be null."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
    assert {:msg "  411.69: Location might not be readable."} true && (!(Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
    assume (Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
  } else {
  }
  assert {:msg "  413.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  413.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assume !(r#41 == null);
  } else {
  }
  assert {:msg "  414.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  414.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assume r#41 == null;
  } else {
  }
  assert {:msg "  415.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  415.15: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#41 == null) {
  } else {
    assert {:msg "  415.35: Receiver might be null."} true ==> (r#41 != null);
    assert {:msg "  415.35: Location might not be readable."} true ==> CanRead(Mask, r#41, AVLTreeNode.height);
  }
  assert {:msg "  415.52: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> (this != null);
  assert {:msg "  415.52: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> CanRead(old(Mask), this, AVLTreeNode.height);
  if (r#41 == null) {
  } else {
    assert {:msg "  415.72: Receiver might be null."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> (r#41 != null);
    assert {:msg "  415.72: Location might not be readable."} true && (!(old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]))) ==> CanRead(Mask, r#41, AVLTreeNode.height);
  }
  assume (old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]) + 1));
  assume !(m#42 == null);
  assume m#42 != null;
  Heap[m#42, AVLTreeNode.valid] := inhaleHeap#_624[m#42, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_624[m#42, AVLTreeNode.valid] == Heap;
  Mask[m#42, AVLTreeNode.valid] := Mask[m#42, AVLTreeNode.valid][perm$R := Mask[m#42, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_624[m#42, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_624, Mask);
  assert {:msg "  420.24: Fraction might be negative."} 0 <= 50;
  assert {:msg "  420.24: Fraction might exceed 100."} 50 <= 100;
  assume m#42 != null;
  Heap[m#42, AVLTreeNode.height] := inhaleHeap#_624[m#42, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[m#42, AVLTreeNode.height] := Mask[m#42, AVLTreeNode.height][perm$R := Mask[m#42, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_624[m#42, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_624, Mask);
  assert {:msg "  421.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  421.31: Fraction might exceed 100."} 50 <= 100;
  assume m#42 != null;
  Heap[m#42, AVLTreeNode.balanceFactor] := inhaleHeap#_624[m#42, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[m#42, AVLTreeNode.balanceFactor] := Mask[m#42, AVLTreeNode.balanceFactor][perm$R := Mask[m#42, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_624[m#42, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_624, Mask);
  assert {:msg "  422.11: Receiver might be null."} true ==> (m#42 != null);
  assert {:msg "  422.11: Location might not be readable."} true ==> CanRead(Mask, m#42, AVLTreeNode.height);
  assume Heap[m#42, AVLTreeNode.height] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.pruneMin(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#41: ref where (r#41 == null) || (dtype(r#41) == AVLTreeNode#t), m#42: ref where (m#42 == null) || (dtype(m#42) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_625: HeapType;
  var exhaleMask#_626: MaskType;
  var fraction#_627: int;
  var inhaleHeap#_628: HeapType;
  var this#144: ref where (this#144 == null) || (dtype(this#144) == AVLTreeNode#t);
  var callHeap#_629: HeapType;
  var callMask#_630: MaskType;
  var callCredits#_631: CreditsType;
  var exhaleMask#_632: MaskType;
  var fraction#_633: int;
  var fraction#_634: int;
  var fraction#_635: int;
  var fraction#_636: int;
  var fraction#_637: int;
  var fraction#_638: int;
  var fraction#_639: int;
  var fraction#_640: int;
  var fraction#_641: int;
  var fraction#_642: int;
  var fraction#_643: int;
  var isHeld#_644: int;
  var isRdHeld#_645: bool;
  var inhaleHeap#_646: HeapType;
  var Heap#_650: HeapType;
  var Mask#_651: MaskType;
  var Credits#_652: CreditsType;
  var exhaleMask#_653: MaskType;
  var nl#44: ref where (nl#44 == null) || (dtype(nl#44) == AVLTreeNode#t);
  var this#145: ref where (this#145 == null) || (dtype(this#145) == AVLTreeNode#t);
  var r#146: ref where (r#146 == null) || (dtype(r#146) == AVLTreeNode#t);
  var m#147: ref where (m#147 == null) || (dtype(m#147) == AVLTreeNode#t);
  var callHeap#_654: HeapType;
  var callMask#_655: MaskType;
  var callCredits#_656: CreditsType;
  var exhaleMask#_657: MaskType;
  var fraction#_658: int;
  var fraction#_659: int;
  var fraction#_660: int;
  var isHeld#_661: int;
  var isRdHeld#_662: bool;
  var inhaleHeap#_663: HeapType;
  var bf#46: int where true;
  var this#148: ref where (this#148 == null) || (dtype(this#148) == AVLTreeNode#t);
  var bf#149: int where true;
  var callHeap#_664: HeapType;
  var callMask#_665: MaskType;
  var callCredits#_666: CreditsType;
  var exhaleMask#_667: MaskType;
  var epsilons#_668: int;
  var fraction#_669: int;
  var epsilons#_670: int;
  var epsilons#_671: int;
  var fraction#_672: int;
  var epsilons#_673: int;
  var isHeld#_674: int;
  var isRdHeld#_675: bool;
  var inhaleHeap#_676: HeapType;
  var this#150: ref where (this#150 == null) || (dtype(this#150) == AVLTreeNode#t);
  var r#151: ref where (r#151 == null) || (dtype(r#151) == AVLTreeNode#t);
  var callHeap#_677: HeapType;
  var callMask#_678: MaskType;
  var callCredits#_679: CreditsType;
  var exhaleMask#_680: MaskType;
  var fraction#_681: int;
  var fraction#_682: int;
  var fraction#_683: int;
  var fraction#_684: int;
  var fraction#_685: int;
  var fraction#_686: int;
  var fraction#_687: int;
  var fraction#_688: int;
  var fraction#_689: int;
  var fraction#_690: int;
  var fraction#_691: int;
  var isHeld#_692: int;
  var isRdHeld#_693: bool;
  var inhaleHeap#_694: HeapType;
  var Heap#_698: HeapType;
  var Mask#_699: MaskType;
  var Credits#_700: CreditsType;
  var exhaleMask#_701: MaskType;
  var this#152: ref where (this#152 == null) || (dtype(this#152) == AVLTreeNode#t);
  var callHeap#_702: HeapType;
  var callMask#_703: MaskType;
  var callCredits#_704: CreditsType;
  var exhaleMask#_705: MaskType;
  var fraction#_706: int;
  var fraction#_707: int;
  var fraction#_708: int;
  var fraction#_709: int;
  var fraction#_710: int;
  var fraction#_711: int;
  var fraction#_712: int;
  var fraction#_713: int;
  var fraction#_714: int;
  var fraction#_715: int;
  var fraction#_716: int;
  var isHeld#_717: int;
  var isRdHeld#_718: bool;
  var inhaleHeap#_719: HeapType;
  var Heap#_723: HeapType;
  var Mask#_724: MaskType;
  var Credits#_725: CreditsType;
  var exhaleMask#_726: MaskType;
  var exhaleMask#_727: MaskType;
  var fraction#_728: int;
  var fraction#_729: int;
  var fraction#_730: int;
  var fraction#_731: int;
  var fraction#_732: int;
  var fraction#_733: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_625;
  assume IsGoodInhaleState(inhaleHeap#_625, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_625[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_625[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_625[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_625, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_625[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_625[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_625, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_625[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_625[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_625, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  428.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_626 := Mask;
  fraction#_627 := 100;
  assert {:msg "  428.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_627 <= exhaleMask#_626[this, AVLTreeNode.valid][perm$R]) && ((fraction#_627 == exhaleMask#_626[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_626[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_626[this, AVLTreeNode.valid] := exhaleMask#_626[this, AVLTreeNode.valid][perm$R := exhaleMask#_626[this, AVLTreeNode.valid][perm$R] - fraction#_627];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_626);
  Mask := exhaleMask#_626;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_628 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_628, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_628[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_628[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_628, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_628[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_628[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_628, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_628[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_628[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_628, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_628[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_628[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_628, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_628[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_628[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_628, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_628, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_628, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_628[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_628, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_628, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_628, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_628[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_628, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  429.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  429.7: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
    // assigment to r
    assert {:msg "  430.9: Receiver might be null."} true ==> (this != null);
    assert {:msg "  430.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    r#41 := Heap[this, AVLTreeNode.right];
    // update field right
    assert {:msg "  431.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
    Heap[this, AVLTreeNode.right] := null;
    assume wf(Heap, Mask);
    // call close
    callHeap#_629 := Heap;
    callMask#_630 := Mask;
    callCredits#_631 := Credits;
    assert {:msg "  432.4: The target of the method call might be null."} this != null;
    this#144 := this;
    // begin exhale (precondition)
    exhaleMask#_632 := Mask;
    fraction#_633 := 100;
    assert {:msg "  432.4: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_633 <= exhaleMask#_632[this#144, AVLTreeNode.key][perm$R]) && ((fraction#_633 == exhaleMask#_632[this#144, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_632[this#144, AVLTreeNode.key][perm$N]));
    exhaleMask#_632[this#144, AVLTreeNode.key] := exhaleMask#_632[this#144, AVLTreeNode.key][perm$R := exhaleMask#_632[this#144, AVLTreeNode.key][perm$R] - fraction#_633];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_632);
    fraction#_634 := 100;
    assert {:msg "  432.4: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_634 <= exhaleMask#_632[this#144, AVLTreeNode.height][perm$R]) && ((fraction#_634 == exhaleMask#_632[this#144, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_632[this#144, AVLTreeNode.height][perm$N]));
    exhaleMask#_632[this#144, AVLTreeNode.height] := exhaleMask#_632[this#144, AVLTreeNode.height][perm$R := exhaleMask#_632[this#144, AVLTreeNode.height][perm$R] - fraction#_634];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_632);
    fraction#_635 := 100;
    assert {:msg "  432.4: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_635 <= exhaleMask#_632[this#144, AVLTreeNode.left][perm$R]) && ((fraction#_635 == exhaleMask#_632[this#144, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_632[this#144, AVLTreeNode.left][perm$N]));
    exhaleMask#_632[this#144, AVLTreeNode.left] := exhaleMask#_632[this#144, AVLTreeNode.left][perm$R := exhaleMask#_632[this#144, AVLTreeNode.left][perm$R] - fraction#_635];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_632);
    fraction#_636 := 100;
    assert {:msg "  432.4: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_636 <= exhaleMask#_632[this#144, AVLTreeNode.right][perm$R]) && ((fraction#_636 == exhaleMask#_632[this#144, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_632[this#144, AVLTreeNode.right][perm$N]));
    exhaleMask#_632[this#144, AVLTreeNode.right] := exhaleMask#_632[this#144, AVLTreeNode.right][perm$R := exhaleMask#_632[this#144, AVLTreeNode.right][perm$R] - fraction#_636];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_632);
    fraction#_637 := 100;
    assert {:msg "  432.4: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_637 <= exhaleMask#_632[this#144, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_637 == exhaleMask#_632[this#144, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_632[this#144, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_632[this#144, AVLTreeNode.balanceFactor] := exhaleMask#_632[this#144, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_632[this#144, AVLTreeNode.balanceFactor][perm$R] - fraction#_637];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_632);
    if (!(Heap[this#144, AVLTreeNode.left] == null)) {
      fraction#_638 := 100;
      assert {:msg "  432.4: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_638 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_638 == exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_638];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_632);
    } else {
    }
    if (!(Heap[this#144, AVLTreeNode.left] == null)) {
      fraction#_639 := 50;
      assert {:msg "  432.4: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_639 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_639 == exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_639];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_632);
    } else {
    }
    if (!(Heap[this#144, AVLTreeNode.left] == null)) {
      fraction#_640 := 50;
      assert {:msg "  432.4: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_640 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_640 == exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_632[Heap[this#144, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_640];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_632);
    } else {
    }
    if (!(Heap[this#144, AVLTreeNode.right] == null)) {
      fraction#_641 := 100;
      assert {:msg "  432.4: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_641 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_641 == exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_641];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_632);
    } else {
    }
    if (!(Heap[this#144, AVLTreeNode.right] == null)) {
      fraction#_642 := 50;
      assert {:msg "  432.4: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_642 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_642 == exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_642];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_632);
    } else {
    }
    if (!(Heap[this#144, AVLTreeNode.right] == null)) {
      fraction#_643 := 50;
      assert {:msg "  432.4: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_643 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_643 == exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_632[Heap[this#144, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_643];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_632);
    } else {
    }
    assert {:msg "  432.4: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#144, AVLTreeNode.left] == null, 0, Heap[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#144, AVLTreeNode.right] == null, 0, Heap[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
    assert {:msg "  432.4: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#144, AVLTreeNode.left] == null, 0, Heap[Heap[this#144, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#144, AVLTreeNode.right] == null, 0, Heap[Heap[this#144, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
    Mask := exhaleMask#_632;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (postcondition)
    havoc inhaleHeap#_646;
    assume IsGoodInhaleState(inhaleHeap#_646, Heap, Mask);
    assume this#144 != null;
    Heap[this#144, AVLTreeNode.valid] := inhaleHeap#_646[this#144, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_646[this#144, AVLTreeNode.valid] == Heap;
    Mask[this#144, AVLTreeNode.valid] := Mask[this#144, AVLTreeNode.valid][perm$R := Mask[this#144, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_646[this#144, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_646, Mask);
    assume this#144 != null;
    Heap[this#144, AVLTreeNode.height] := inhaleHeap#_646[this#144, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#144, AVLTreeNode.height] := Mask[this#144, AVLTreeNode.height][perm$R := Mask[this#144, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_646[this#144, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_646, Mask);
    assume this#144 != null;
    Heap[this#144, AVLTreeNode.balanceFactor] := inhaleHeap#_646[this#144, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[this#144, AVLTreeNode.balanceFactor] := Mask[this#144, AVLTreeNode.balanceFactor][perm$R := Mask[this#144, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_646[this#144, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_646, Mask);
    assume Heap[this#144, AVLTreeNode.height] == ite(ite(callHeap#_629[this#144, AVLTreeNode.left] == null, 0, callHeap#_629[callHeap#_629[this#144, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_629[this#144, AVLTreeNode.right] == null, 0, callHeap#_629[callHeap#_629[this#144, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_629[this#144, AVLTreeNode.left] == null, 0, callHeap#_629[callHeap#_629[this#144, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_629[this#144, AVLTreeNode.right] == null, 0, callHeap#_629[callHeap#_629[this#144, AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap[this#144, AVLTreeNode.balanceFactor] == (ite(callHeap#_629[this#144, AVLTreeNode.left] == null, 0, callHeap#_629[callHeap#_629[this#144, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_629[this#144, AVLTreeNode.right] == null, 0, callHeap#_629[callHeap#_629[this#144, AVLTreeNode.right], AVLTreeNode.height]));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // assigment to m
    m#42 := this;
    // assert
    Heap#_650 := Heap;
    Mask#_651 := Mask;
    Credits#_652 := Credits;
    // begin exhale (assert)
    exhaleMask#_653 := Mask#_651;
    if (!(r#41 == null)) {
      assert {:msg "  434.24: Receiver might be null."} true ==> (r#41 != null);
      assert {:msg "  434.24: Location might not be readable."} true ==> CanRead(Mask#_651, r#41, AVLTreeNode.height);
      assert {:msg "  434.40: Receiver might be null."} true ==> (this != null);
      assert {:msg "  434.40: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
      assert {:msg "  434.51: Receiver might be null."} true && (!(Heap#_650[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
      assert {:msg "  434.51: Location might not be readable."} true && (!(Heap#_650[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask#_651, r#41, AVLTreeNode.height);
      assert {:msg "  434.67: Receiver might be null."} true && (!(Heap#_650[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
      assert {:msg "  434.67: Location might not be readable."} true && (!(Heap#_650[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
      assert {:msg "  434.4: Assertion might not hold. The expression at 434.24 might not evaluate to true."} (Heap#_650[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap#_650[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
    } else {
    }
    Mask#_651 := exhaleMask#_653;
    assume wf(Heap#_650, Mask#_651);
    // end exhale
  } else {
    // local var nl
    // call pruneMin
    callHeap#_654 := Heap;
    callMask#_655 := Mask;
    callCredits#_656 := Credits;
    assert {:msg "  438.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  438.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  438.4: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
    this#145 := Heap[this, AVLTreeNode.left];
    // begin exhale (precondition)
    exhaleMask#_657 := Mask;
    fraction#_658 := 100;
    assert {:msg "  438.4: The precondition at 402.12 might not hold. Insufficient fraction at 402.12 for AVLTreeNode.valid."} (fraction#_658 <= exhaleMask#_657[this#145, AVLTreeNode.valid][perm$R]) && ((fraction#_658 == exhaleMask#_657[this#145, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_657[this#145, AVLTreeNode.valid][perm$N]));
    exhaleMask#_657[this#145, AVLTreeNode.valid] := exhaleMask#_657[this#145, AVLTreeNode.valid][perm$R := exhaleMask#_657[this#145, AVLTreeNode.valid][perm$R] - fraction#_658];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_657);
    fraction#_659 := 50;
    assert {:msg "  438.4: The precondition at 404.12 might not hold. Insufficient fraction at 404.12 for AVLTreeNode.height."} (fraction#_659 <= exhaleMask#_657[this#145, AVLTreeNode.height][perm$R]) && ((fraction#_659 == exhaleMask#_657[this#145, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_657[this#145, AVLTreeNode.height][perm$N]));
    exhaleMask#_657[this#145, AVLTreeNode.height] := exhaleMask#_657[this#145, AVLTreeNode.height][perm$R := exhaleMask#_657[this#145, AVLTreeNode.height][perm$R] - fraction#_659];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_657);
    fraction#_660 := 50;
    assert {:msg "  438.4: The precondition at 405.12 might not hold. Insufficient fraction at 405.12 for AVLTreeNode.balanceFactor."} (fraction#_660 <= exhaleMask#_657[this#145, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_660 == exhaleMask#_657[this#145, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_657[this#145, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_657[this#145, AVLTreeNode.balanceFactor] := exhaleMask#_657[this#145, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_657[this#145, AVLTreeNode.balanceFactor][perm$R] - fraction#_660];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_657);
    Mask := exhaleMask#_657;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#146;
    havoc m#147;
    // inhale (postcondition)
    havoc inhaleHeap#_663;
    assume IsGoodInhaleState(inhaleHeap#_663, Heap, Mask);
    if (!(r#146 == null)) {
      assume r#146 != null;
      Heap[r#146, AVLTreeNode.valid] := inhaleHeap#_663[r#146, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_663[r#146, AVLTreeNode.valid] == Heap;
      Mask[r#146, AVLTreeNode.valid] := Mask[r#146, AVLTreeNode.valid][perm$R := Mask[r#146, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_663[r#146, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_663, Mask);
    } else {
    }
    if (!(r#146 == null)) {
      assume r#146 != null;
      Heap[r#146, AVLTreeNode.height] := inhaleHeap#_663[r#146, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#146, AVLTreeNode.height] := Mask[r#146, AVLTreeNode.height][perm$R := Mask[r#146, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_663[r#146, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_663, Mask);
    } else {
    }
    if (!(r#146 == null)) {
      assume r#146 != null;
      Heap[r#146, AVLTreeNode.balanceFactor] := inhaleHeap#_663[r#146, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#146, AVLTreeNode.balanceFactor] := Mask[r#146, AVLTreeNode.balanceFactor][perm$R := Mask[r#146, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_663[r#146, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_663, Mask);
    } else {
    }
    if (!(r#146 == null)) {
      assume (Heap[r#146, AVLTreeNode.height] == callHeap#_654[this#145, AVLTreeNode.height]) || (Heap[r#146, AVLTreeNode.height] == (callHeap#_654[this#145, AVLTreeNode.height] - 1));
    } else {
    }
    if (callHeap#_654[this#145, AVLTreeNode.height] > 1) {
      assume !(r#146 == null);
    } else {
    }
    if (callHeap#_654[this#145, AVLTreeNode.height] == 1) {
      assume r#146 == null;
    } else {
    }
    assume (callHeap#_654[this#145, AVLTreeNode.height] == ite(r#146 == null, 0, Heap[r#146, AVLTreeNode.height])) || (callHeap#_654[this#145, AVLTreeNode.height] == (ite(r#146 == null, 0, Heap[r#146, AVLTreeNode.height]) + 1));
    assume !(m#147 == null);
    assume m#147 != null;
    Heap[m#147, AVLTreeNode.valid] := inhaleHeap#_663[m#147, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_663[m#147, AVLTreeNode.valid] == Heap;
    Mask[m#147, AVLTreeNode.valid] := Mask[m#147, AVLTreeNode.valid][perm$R := Mask[m#147, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_663[m#147, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_663, Mask);
    assume m#147 != null;
    Heap[m#147, AVLTreeNode.height] := inhaleHeap#_663[m#147, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[m#147, AVLTreeNode.height] := Mask[m#147, AVLTreeNode.height][perm$R := Mask[m#147, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_663[m#147, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_663, Mask);
    assume m#147 != null;
    Heap[m#147, AVLTreeNode.balanceFactor] := inhaleHeap#_663[m#147, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[m#147, AVLTreeNode.balanceFactor] := Mask[m#147, AVLTreeNode.balanceFactor][perm$R := Mask[m#147, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_663[m#147, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_663, Mask);
    assume Heap[m#147, AVLTreeNode.height] == 1;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    nl#44 := r#146;
    m#42 := m#147;
    // update field left
    assert {:msg "  439.4: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
    Heap[this, AVLTreeNode.left] := nl#44;
    assume wf(Heap, Mask);
    // local var bf
    // call getBalanceFactorI
    callHeap#_664 := Heap;
    callMask#_665 := Mask;
    callCredits#_666 := Credits;
    assert {:msg "  441.4: The target of the method call might be null."} this != null;
    this#148 := this;
    // begin exhale (precondition)
    exhaleMask#_667 := Mask;
    epsilons#_668 := 1;
    assert {:msg "  441.4: The precondition at 509.12 might not hold. Insufficient epsilons at 509.12  for AVLTreeNode.left."} (exhaleMask#_667[this#148, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_668 <= exhaleMask#_667[this#148, AVLTreeNode.left][perm$N]);
    if ((exhaleMask#_667[this#148, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_667[this#148, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_667[this#148, AVLTreeNode.left] := exhaleMask#_667[this#148, AVLTreeNode.left][perm$N := exhaleMask#_667[this#148, AVLTreeNode.left][perm$N] - epsilons#_668];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_667);
    if (!(Heap[this#148, AVLTreeNode.left] == null)) {
      fraction#_669 := 100;
      assert {:msg "  441.4: The precondition at 510.12 might not hold. Insufficient fraction at 510.27 for AVLTreeNode.valid."} (fraction#_669 <= exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_669 == exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_669];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_667);
    } else {
    }
    if (!(Heap[this#148, AVLTreeNode.left] == null)) {
      epsilons#_670 := 1;
      assert {:msg "  441.4: The precondition at 511.12 might not hold. Insufficient epsilons at 511.27  for AVLTreeNode.height."} (exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_670 <= exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
      if ((exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_667[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_670];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_667);
    } else {
    }
    epsilons#_671 := 1;
    assert {:msg "  441.4: The precondition at 513.12 might not hold. Insufficient epsilons at 513.12  for AVLTreeNode.right."} (exhaleMask#_667[this#148, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_671 <= exhaleMask#_667[this#148, AVLTreeNode.right][perm$N]);
    if ((exhaleMask#_667[this#148, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_667[this#148, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_667[this#148, AVLTreeNode.right] := exhaleMask#_667[this#148, AVLTreeNode.right][perm$N := exhaleMask#_667[this#148, AVLTreeNode.right][perm$N] - epsilons#_671];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_667);
    if (!(Heap[this#148, AVLTreeNode.right] == null)) {
      fraction#_672 := 100;
      assert {:msg "  441.4: The precondition at 514.12 might not hold. Insufficient fraction at 514.28 for AVLTreeNode.valid."} (fraction#_672 <= exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_672 == exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_672];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_667);
    } else {
    }
    if (!(Heap[this#148, AVLTreeNode.right] == null)) {
      epsilons#_673 := 1;
      assert {:msg "  441.4: The precondition at 515.12 might not hold. Insufficient epsilons at 515.28  for AVLTreeNode.height."} (exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_673 <= exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
      if ((exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_667[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_673];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_667);
    } else {
    }
    Mask := exhaleMask#_667;
    assume wf(Heap, Mask);
    // end exhale
    havoc bf#149;
    // inhale (postcondition)
    havoc inhaleHeap#_676;
    assume IsGoodInhaleState(inhaleHeap#_676, Heap, Mask);
    assume this#148 != null;
    Heap[this#148, AVLTreeNode.left] := inhaleHeap#_676[this#148, AVLTreeNode.left];
    assume wf(Heap, Mask);
    assume (Heap[this#148, AVLTreeNode.left] == null) || (dtype(Heap[this#148, AVLTreeNode.left]) == AVLTreeNode#t);
    if ((Mask[this#148, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this#148, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
      Mask[this#148, AVLTreeNode.left] := Mask[this#148, AVLTreeNode.left][perm$N := Mask[this#148, AVLTreeNode.left][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_676[this#148, AVLTreeNode.left]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_676, Mask);
    if (!(Heap[this#148, AVLTreeNode.left] == null)) {
      assume Heap[this#148, AVLTreeNode.left] != null;
      Heap[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_676[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_676[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_676[Heap[this#148, AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_676, Mask);
    } else {
    }
    if (!(Heap[this#148, AVLTreeNode.left] == null)) {
      assume Heap[this#148, AVLTreeNode.left] != null;
      Heap[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_676[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      if ((Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_676[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_676, Mask);
    } else {
    }
    assume this#148 != null;
    Heap[this#148, AVLTreeNode.right] := inhaleHeap#_676[this#148, AVLTreeNode.right];
    assume wf(Heap, Mask);
    assume (Heap[this#148, AVLTreeNode.right] == null) || (dtype(Heap[this#148, AVLTreeNode.right]) == AVLTreeNode#t);
    if ((Mask[this#148, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this#148, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
      Mask[this#148, AVLTreeNode.right] := Mask[this#148, AVLTreeNode.right][perm$N := Mask[this#148, AVLTreeNode.right][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_676[this#148, AVLTreeNode.right]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_676, Mask);
    if (!(Heap[this#148, AVLTreeNode.right] == null)) {
      assume Heap[this#148, AVLTreeNode.right] != null;
      Heap[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_676[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_676[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
      Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_676[Heap[this#148, AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_676, Mask);
    } else {
    }
    if (!(Heap[this#148, AVLTreeNode.right] == null)) {
      assume Heap[this#148, AVLTreeNode.right] != null;
      Heap[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_676[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      if ((Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
        Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
        assume wf(Heap, Mask);
      } else {
      }
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_676[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_676, Mask);
    } else {
    }
    assume bf#149 == (ite(Heap[this#148, AVLTreeNode.left] == null, 0, Heap[Heap[this#148, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#148, AVLTreeNode.right] == null, 0, Heap[Heap[this#148, AVLTreeNode.right], AVLTreeNode.height]));
    if (bf#149 > 0) {
      assume !(Heap[this#148, AVLTreeNode.left] == null);
    } else {
    }
    if (bf#149 < 0) {
      assume !(Heap[this#148, AVLTreeNode.right] == null);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    bf#46 := bf#149;
    // if
    if (bf#46 == (0 - 2)) {
      // call rebalanceRight
      callHeap#_677 := Heap;
      callMask#_678 := Mask;
      callCredits#_679 := Credits;
      assert {:msg "  443.5: The target of the method call might be null."} this != null;
      this#150 := this;
      // begin exhale (precondition)
      exhaleMask#_680 := Mask;
      fraction#_681 := 100;
      assert {:msg "  443.5: The precondition at 741.12 might not hold. Insufficient fraction at 741.12 for AVLTreeNode.key."} (fraction#_681 <= exhaleMask#_680[this#150, AVLTreeNode.key][perm$R]) && ((fraction#_681 == exhaleMask#_680[this#150, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_680[this#150, AVLTreeNode.key][perm$N]));
      exhaleMask#_680[this#150, AVLTreeNode.key] := exhaleMask#_680[this#150, AVLTreeNode.key][perm$R := exhaleMask#_680[this#150, AVLTreeNode.key][perm$R] - fraction#_681];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      fraction#_682 := 100;
      assert {:msg "  443.5: The precondition at 742.12 might not hold. Insufficient fraction at 742.12 for AVLTreeNode.height."} (fraction#_682 <= exhaleMask#_680[this#150, AVLTreeNode.height][perm$R]) && ((fraction#_682 == exhaleMask#_680[this#150, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_680[this#150, AVLTreeNode.height][perm$N]));
      exhaleMask#_680[this#150, AVLTreeNode.height] := exhaleMask#_680[this#150, AVLTreeNode.height][perm$R := exhaleMask#_680[this#150, AVLTreeNode.height][perm$R] - fraction#_682];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      fraction#_683 := 100;
      assert {:msg "  443.5: The precondition at 743.12 might not hold. Insufficient fraction at 743.12 for AVLTreeNode.left."} (fraction#_683 <= exhaleMask#_680[this#150, AVLTreeNode.left][perm$R]) && ((fraction#_683 == exhaleMask#_680[this#150, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_680[this#150, AVLTreeNode.left][perm$N]));
      exhaleMask#_680[this#150, AVLTreeNode.left] := exhaleMask#_680[this#150, AVLTreeNode.left][perm$R := exhaleMask#_680[this#150, AVLTreeNode.left][perm$R] - fraction#_683];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      fraction#_684 := 100;
      assert {:msg "  443.5: The precondition at 744.12 might not hold. Insufficient fraction at 744.12 for AVLTreeNode.right."} (fraction#_684 <= exhaleMask#_680[this#150, AVLTreeNode.right][perm$R]) && ((fraction#_684 == exhaleMask#_680[this#150, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_680[this#150, AVLTreeNode.right][perm$N]));
      exhaleMask#_680[this#150, AVLTreeNode.right] := exhaleMask#_680[this#150, AVLTreeNode.right][perm$R := exhaleMask#_680[this#150, AVLTreeNode.right][perm$R] - fraction#_684];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      fraction#_685 := 100;
      assert {:msg "  443.5: The precondition at 747.12 might not hold. Insufficient fraction at 747.12 for AVLTreeNode.balanceFactor."} (fraction#_685 <= exhaleMask#_680[this#150, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_685 == exhaleMask#_680[this#150, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_680[this#150, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_680[this#150, AVLTreeNode.balanceFactor] := exhaleMask#_680[this#150, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_680[this#150, AVLTreeNode.balanceFactor][perm$R] - fraction#_685];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      if (!(Heap[this#150, AVLTreeNode.left] == null)) {
        fraction#_686 := 100;
        assert {:msg "  443.5: The precondition at 749.12 might not hold. Insufficient fraction at 749.25 for AVLTreeNode.valid."} (fraction#_686 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_686 == exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_686];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_680);
      } else {
      }
      if (!(Heap[this#150, AVLTreeNode.left] == null)) {
        fraction#_687 := 50;
        assert {:msg "  443.5: The precondition at 750.12 might not hold. Insufficient fraction at 750.25 for AVLTreeNode.height."} (fraction#_687 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_687 == exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_687];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_680);
      } else {
      }
      if (!(Heap[this#150, AVLTreeNode.left] == null)) {
        fraction#_688 := 50;
        assert {:msg "  443.5: The precondition at 752.12 might not hold. Insufficient fraction at 752.25 for AVLTreeNode.balanceFactor."} (fraction#_688 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_688 == exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_680[Heap[this#150, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_688];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_680);
      } else {
      }
      assert {:msg "  443.5: The precondition at 755.12 might not hold. The expression at 755.12 might not evaluate to true."} !(Heap[this#150, AVLTreeNode.right] == null);
      fraction#_689 := 100;
      assert {:msg "  443.5: The precondition at 756.12 might not hold. Insufficient fraction at 756.12 for AVLTreeNode.valid."} (fraction#_689 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_689 == exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_689];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      fraction#_690 := 50;
      assert {:msg "  443.5: The precondition at 757.12 might not hold. Insufficient fraction at 757.12 for AVLTreeNode.height."} (fraction#_690 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_690 == exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_690];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      fraction#_691 := 50;
      assert {:msg "  443.5: The precondition at 759.12 might not hold. Insufficient fraction at 759.12 for AVLTreeNode.balanceFactor."} (fraction#_691 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_691 == exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_680[Heap[this#150, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_691];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_680);
      assert {:msg "  443.5: The precondition at 763.12 might not hold. The expression at 763.12 might not evaluate to true."} (ite(Heap[this#150, AVLTreeNode.left] == null, 0, Heap[Heap[this#150, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#150, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
      Mask := exhaleMask#_680;
      assume wf(Heap, Mask);
      // end exhale
      havoc r#151;
      // inhale (postcondition)
      havoc inhaleHeap#_694;
      assume IsGoodInhaleState(inhaleHeap#_694, Heap, Mask);
      assume r#151 != null;
      Heap[r#151, AVLTreeNode.valid] := inhaleHeap#_694[r#151, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_694[r#151, AVLTreeNode.valid] == Heap;
      Mask[r#151, AVLTreeNode.valid] := Mask[r#151, AVLTreeNode.valid][perm$R := Mask[r#151, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_694[r#151, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_694, Mask);
      assume r#151 != null;
      Heap[r#151, AVLTreeNode.height] := inhaleHeap#_694[r#151, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#151, AVLTreeNode.height] := Mask[r#151, AVLTreeNode.height][perm$R := Mask[r#151, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_694[r#151, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_694, Mask);
      assume r#151 != null;
      Heap[r#151, AVLTreeNode.balanceFactor] := inhaleHeap#_694[r#151, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[r#151, AVLTreeNode.balanceFactor] := Mask[r#151, AVLTreeNode.balanceFactor][perm$R := Mask[r#151, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_694[r#151, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_694, Mask);
      assume (Heap[r#151, AVLTreeNode.height] == callHeap#_677[callHeap#_677[this#150, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#151, AVLTreeNode.height] == (callHeap#_677[callHeap#_677[this#150, AVLTreeNode.right], AVLTreeNode.height] + 1));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      r#41 := r#151;
      // assert
      Heap#_698 := Heap;
      Mask#_699 := Mask;
      Credits#_700 := Credits;
      // begin exhale (assert)
      exhaleMask#_701 := Mask#_699;
      if (!(r#41 == null)) {
        assert {:msg "  444.27: Receiver might be null."} true ==> (r#41 != null);
        assert {:msg "  444.27: Location might not be readable."} true ==> CanRead(Mask#_699, r#41, AVLTreeNode.height);
        assert {:msg "  444.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  444.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  444.54: Receiver might be null."} true && (!(Heap#_698[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
        assert {:msg "  444.54: Location might not be readable."} true && (!(Heap#_698[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask#_699, r#41, AVLTreeNode.height);
        assert {:msg "  444.70: Receiver might be null."} true && (!(Heap#_698[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
        assert {:msg "  444.70: Location might not be readable."} true && (!(Heap#_698[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  444.5: Assertion might not hold. The expression at 444.27 might not evaluate to true."} (Heap#_698[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap#_698[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
      } else {
      }
      Mask#_699 := exhaleMask#_701;
      assume wf(Heap#_698, Mask#_699);
      // end exhale
    } else {
      // call close
      callHeap#_702 := Heap;
      callMask#_703 := Mask;
      callCredits#_704 := Credits;
      assert {:msg "  446.5: The target of the method call might be null."} this != null;
      this#152 := this;
      // begin exhale (precondition)
      exhaleMask#_705 := Mask;
      fraction#_706 := 100;
      assert {:msg "  446.5: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_706 <= exhaleMask#_705[this#152, AVLTreeNode.key][perm$R]) && ((fraction#_706 == exhaleMask#_705[this#152, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_705[this#152, AVLTreeNode.key][perm$N]));
      exhaleMask#_705[this#152, AVLTreeNode.key] := exhaleMask#_705[this#152, AVLTreeNode.key][perm$R := exhaleMask#_705[this#152, AVLTreeNode.key][perm$R] - fraction#_706];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_705);
      fraction#_707 := 100;
      assert {:msg "  446.5: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_707 <= exhaleMask#_705[this#152, AVLTreeNode.height][perm$R]) && ((fraction#_707 == exhaleMask#_705[this#152, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_705[this#152, AVLTreeNode.height][perm$N]));
      exhaleMask#_705[this#152, AVLTreeNode.height] := exhaleMask#_705[this#152, AVLTreeNode.height][perm$R := exhaleMask#_705[this#152, AVLTreeNode.height][perm$R] - fraction#_707];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_705);
      fraction#_708 := 100;
      assert {:msg "  446.5: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_708 <= exhaleMask#_705[this#152, AVLTreeNode.left][perm$R]) && ((fraction#_708 == exhaleMask#_705[this#152, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_705[this#152, AVLTreeNode.left][perm$N]));
      exhaleMask#_705[this#152, AVLTreeNode.left] := exhaleMask#_705[this#152, AVLTreeNode.left][perm$R := exhaleMask#_705[this#152, AVLTreeNode.left][perm$R] - fraction#_708];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_705);
      fraction#_709 := 100;
      assert {:msg "  446.5: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_709 <= exhaleMask#_705[this#152, AVLTreeNode.right][perm$R]) && ((fraction#_709 == exhaleMask#_705[this#152, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_705[this#152, AVLTreeNode.right][perm$N]));
      exhaleMask#_705[this#152, AVLTreeNode.right] := exhaleMask#_705[this#152, AVLTreeNode.right][perm$R := exhaleMask#_705[this#152, AVLTreeNode.right][perm$R] - fraction#_709];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_705);
      fraction#_710 := 100;
      assert {:msg "  446.5: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_710 <= exhaleMask#_705[this#152, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_710 == exhaleMask#_705[this#152, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_705[this#152, AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_705[this#152, AVLTreeNode.balanceFactor] := exhaleMask#_705[this#152, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_705[this#152, AVLTreeNode.balanceFactor][perm$R] - fraction#_710];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_705);
      if (!(Heap[this#152, AVLTreeNode.left] == null)) {
        fraction#_711 := 100;
        assert {:msg "  446.5: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_711 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_711 == exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
        exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_711];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_705);
      } else {
      }
      if (!(Heap[this#152, AVLTreeNode.left] == null)) {
        fraction#_712 := 50;
        assert {:msg "  446.5: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_712 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_712 == exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
        exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_712];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_705);
      } else {
      }
      if (!(Heap[this#152, AVLTreeNode.left] == null)) {
        fraction#_713 := 50;
        assert {:msg "  446.5: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_713 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_713 == exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_705[Heap[this#152, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_713];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_705);
      } else {
      }
      if (!(Heap[this#152, AVLTreeNode.right] == null)) {
        fraction#_714 := 100;
        assert {:msg "  446.5: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_714 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_714 == exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
        exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_714];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_705);
      } else {
      }
      if (!(Heap[this#152, AVLTreeNode.right] == null)) {
        fraction#_715 := 50;
        assert {:msg "  446.5: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_715 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_715 == exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
        exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_715];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_705);
      } else {
      }
      if (!(Heap[this#152, AVLTreeNode.right] == null)) {
        fraction#_716 := 50;
        assert {:msg "  446.5: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_716 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_716 == exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
        exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_705[Heap[this#152, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_716];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_705);
      } else {
      }
      assert {:msg "  446.5: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#152, AVLTreeNode.left] == null, 0, Heap[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#152, AVLTreeNode.right] == null, 0, Heap[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
      assert {:msg "  446.5: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#152, AVLTreeNode.left] == null, 0, Heap[Heap[this#152, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#152, AVLTreeNode.right] == null, 0, Heap[Heap[this#152, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
      Mask := exhaleMask#_705;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_719;
      assume IsGoodInhaleState(inhaleHeap#_719, Heap, Mask);
      assume this#152 != null;
      Heap[this#152, AVLTreeNode.valid] := inhaleHeap#_719[this#152, AVLTreeNode.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_719[this#152, AVLTreeNode.valid] == Heap;
      Mask[this#152, AVLTreeNode.valid] := Mask[this#152, AVLTreeNode.valid][perm$R := Mask[this#152, AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_719[this#152, AVLTreeNode.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_719, Mask);
      assume this#152 != null;
      Heap[this#152, AVLTreeNode.height] := inhaleHeap#_719[this#152, AVLTreeNode.height];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#152, AVLTreeNode.height] := Mask[this#152, AVLTreeNode.height][perm$R := Mask[this#152, AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_719[this#152, AVLTreeNode.height]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_719, Mask);
      assume this#152 != null;
      Heap[this#152, AVLTreeNode.balanceFactor] := inhaleHeap#_719[this#152, AVLTreeNode.balanceFactor];
      assume wf(Heap, Mask);
      assume true;
      Mask[this#152, AVLTreeNode.balanceFactor] := Mask[this#152, AVLTreeNode.balanceFactor][perm$R := Mask[this#152, AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_719[this#152, AVLTreeNode.balanceFactor]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_719, Mask);
      assume Heap[this#152, AVLTreeNode.height] == ite(ite(callHeap#_702[this#152, AVLTreeNode.left] == null, 0, callHeap#_702[callHeap#_702[this#152, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_702[this#152, AVLTreeNode.right] == null, 0, callHeap#_702[callHeap#_702[this#152, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_702[this#152, AVLTreeNode.left] == null, 0, callHeap#_702[callHeap#_702[this#152, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_702[this#152, AVLTreeNode.right] == null, 0, callHeap#_702[callHeap#_702[this#152, AVLTreeNode.right], AVLTreeNode.height]) + 1);
      assume Heap[this#152, AVLTreeNode.balanceFactor] == (ite(callHeap#_702[this#152, AVLTreeNode.left] == null, 0, callHeap#_702[callHeap#_702[this#152, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_702[this#152, AVLTreeNode.right] == null, 0, callHeap#_702[callHeap#_702[this#152, AVLTreeNode.right], AVLTreeNode.height]));
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // assigment to r
      r#41 := this;
      // assert
      Heap#_723 := Heap;
      Mask#_724 := Mask;
      Credits#_725 := Credits;
      // begin exhale (assert)
      exhaleMask#_726 := Mask#_724;
      if (!(r#41 == null)) {
        assert {:msg "  448.27: Receiver might be null."} true ==> (r#41 != null);
        assert {:msg "  448.27: Location might not be readable."} true ==> CanRead(Mask#_724, r#41, AVLTreeNode.height);
        assert {:msg "  448.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  448.43: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  448.54: Receiver might be null."} true && (!(Heap#_723[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (r#41 != null);
        assert {:msg "  448.54: Location might not be readable."} true && (!(Heap#_723[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(Mask#_724, r#41, AVLTreeNode.height);
        assert {:msg "  448.70: Receiver might be null."} true && (!(Heap#_723[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> (this != null);
        assert {:msg "  448.70: Location might not be readable."} true && (!(Heap#_723[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.height);
        assert {:msg "  448.5: Assertion might not hold. The expression at 448.27 might not evaluate to true."} (Heap#_723[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap#_723[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
      } else {
      }
      Mask#_724 := exhaleMask#_726;
      assume wf(Heap#_723, Mask#_724);
      // end exhale
    }
  }
  // begin exhale (postcondition)
  exhaleMask#_727 := Mask;
  if (!(r#41 == null)) {
    fraction#_728 := 100;
    assert {:msg "  401.2: The postcondition at 407.11 might not hold. Insufficient fraction at 407.25 for AVLTreeNode.valid."} (fraction#_728 <= exhaleMask#_727[r#41, AVLTreeNode.valid][perm$R]) && ((fraction#_728 == exhaleMask#_727[r#41, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_727[r#41, AVLTreeNode.valid][perm$N]));
    exhaleMask#_727[r#41, AVLTreeNode.valid] := exhaleMask#_727[r#41, AVLTreeNode.valid][perm$R := exhaleMask#_727[r#41, AVLTreeNode.valid][perm$R] - fraction#_728];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_727);
  } else {
  }
  if (!(r#41 == null)) {
    fraction#_729 := 50;
    assert {:msg "  401.2: The postcondition at 409.11 might not hold. Insufficient fraction at 409.25 for AVLTreeNode.height."} (fraction#_729 <= exhaleMask#_727[r#41, AVLTreeNode.height][perm$R]) && ((fraction#_729 == exhaleMask#_727[r#41, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_727[r#41, AVLTreeNode.height][perm$N]));
    exhaleMask#_727[r#41, AVLTreeNode.height] := exhaleMask#_727[r#41, AVLTreeNode.height][perm$R := exhaleMask#_727[r#41, AVLTreeNode.height][perm$R] - fraction#_729];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_727);
  } else {
  }
  if (!(r#41 == null)) {
    fraction#_730 := 50;
    assert {:msg "  401.2: The postcondition at 410.11 might not hold. Insufficient fraction at 410.25 for AVLTreeNode.balanceFactor."} (fraction#_730 <= exhaleMask#_727[r#41, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_730 == exhaleMask#_727[r#41, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_727[r#41, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_727[r#41, AVLTreeNode.balanceFactor] := exhaleMask#_727[r#41, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_727[r#41, AVLTreeNode.balanceFactor][perm$R] - fraction#_730];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_727);
  } else {
  }
  if (!(r#41 == null)) {
    assert {:msg "  401.2: The postcondition at 411.11 might not hold. The expression at 411.26 might not evaluate to true."} (Heap[r#41, AVLTreeNode.height] == old(Heap)[this, AVLTreeNode.height]) || (Heap[r#41, AVLTreeNode.height] == (old(Heap)[this, AVLTreeNode.height] - 1));
  } else {
  }
  if (old(Heap)[this, AVLTreeNode.height] > 1) {
    assert {:msg "  401.2: The postcondition at 413.11 might not hold. The expression at 413.30 might not evaluate to true."} !(r#41 == null);
  } else {
  }
  if (old(Heap)[this, AVLTreeNode.height] == 1) {
    assert {:msg "  401.2: The postcondition at 414.11 might not hold. The expression at 414.30 might not evaluate to true."} r#41 == null;
  } else {
  }
  assert {:msg "  401.2: The postcondition at 415.11 might not hold. The expression at 415.11 might not evaluate to true."} (old(Heap)[this, AVLTreeNode.height] == ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height])) || (old(Heap)[this, AVLTreeNode.height] == (ite(r#41 == null, 0, Heap[r#41, AVLTreeNode.height]) + 1));
  assert {:msg "  401.2: The postcondition at 417.11 might not hold. The expression at 417.11 might not evaluate to true."} !(m#42 == null);
  fraction#_731 := 100;
  assert {:msg "  401.2: The postcondition at 418.11 might not hold. Insufficient fraction at 418.11 for AVLTreeNode.valid."} (fraction#_731 <= exhaleMask#_727[m#42, AVLTreeNode.valid][perm$R]) && ((fraction#_731 == exhaleMask#_727[m#42, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_727[m#42, AVLTreeNode.valid][perm$N]));
  exhaleMask#_727[m#42, AVLTreeNode.valid] := exhaleMask#_727[m#42, AVLTreeNode.valid][perm$R := exhaleMask#_727[m#42, AVLTreeNode.valid][perm$R] - fraction#_731];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_727);
  fraction#_732 := 50;
  assert {:msg "  401.2: The postcondition at 420.11 might not hold. Insufficient fraction at 420.11 for AVLTreeNode.height."} (fraction#_732 <= exhaleMask#_727[m#42, AVLTreeNode.height][perm$R]) && ((fraction#_732 == exhaleMask#_727[m#42, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_727[m#42, AVLTreeNode.height][perm$N]));
  exhaleMask#_727[m#42, AVLTreeNode.height] := exhaleMask#_727[m#42, AVLTreeNode.height][perm$R := exhaleMask#_727[m#42, AVLTreeNode.height][perm$R] - fraction#_732];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_727);
  fraction#_733 := 50;
  assert {:msg "  401.2: The postcondition at 421.11 might not hold. Insufficient fraction at 421.11 for AVLTreeNode.balanceFactor."} (fraction#_733 <= exhaleMask#_727[m#42, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_733 == exhaleMask#_727[m#42, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_727[m#42, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_727[m#42, AVLTreeNode.balanceFactor] := exhaleMask#_727[m#42, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_727[m#42, AVLTreeNode.balanceFactor][perm$R] - fraction#_733];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_727);
  assert {:msg "  401.2: The postcondition at 422.11 might not hold. The expression at 422.11 might not evaluate to true."} Heap[m#42, AVLTreeNode.height] == 1;
  Mask := exhaleMask#_727;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  401.2: Method might lock/unlock more than allowed."} (forall lk#_734: ref :: {Heap[lk#_734, held]} {Heap[lk#_734, rdheld]} (((0 < Heap[lk#_734, held]) == (0 < old(Heap)[lk#_734, held])) && (Heap[lk#_734, rdheld] == old(Heap)[lk#_734, rdheld])) || false);
  assert {:msg "  401.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.has$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_735: HeapType;
  var inhaleHeap#_736: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_735;
  assume IsGoodInhaleState(inhaleHeap#_735, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_735[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_735[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_735[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_735, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_736;
  assume IsGoodInhaleState(inhaleHeap#_736, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_736[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_736[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_736[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_736, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.has(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t), k#47: int where true) returns (b#48: bool where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_737: HeapType;
  var exhaleMask#_738: MaskType;
  var fraction#_739: int;
  var inhaleHeap#_740: HeapType;
  var this#153: ref where (this#153 == null) || (dtype(this#153) == AVLTreeNode#t);
  var k#154: int where true;
  var b#155: bool where true;
  var callHeap#_741: HeapType;
  var callMask#_742: MaskType;
  var callCredits#_743: CreditsType;
  var exhaleMask#_744: MaskType;
  var fraction#_745: int;
  var isHeld#_746: int;
  var isRdHeld#_747: bool;
  var inhaleHeap#_748: HeapType;
  var this#156: ref where (this#156 == null) || (dtype(this#156) == AVLTreeNode#t);
  var k#157: int where true;
  var b#158: bool where true;
  var callHeap#_749: HeapType;
  var callMask#_750: MaskType;
  var callCredits#_751: CreditsType;
  var exhaleMask#_752: MaskType;
  var fraction#_753: int;
  var isHeld#_754: int;
  var isRdHeld#_755: bool;
  var inhaleHeap#_756: HeapType;
  var exhaleMask#_757: MaskType;
  var fraction#_758: int;
  var fraction#_759: int;
  var fraction#_760: int;
  var fraction#_761: int;
  var fraction#_762: int;
  var fraction#_763: int;
  var fraction#_764: int;
  var fraction#_765: int;
  var fraction#_766: int;
  var fraction#_767: int;
  var fraction#_768: int;
  var inhaleHeap#_769: HeapType;
  var exhaleMask#_770: MaskType;
  var fraction#_771: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_737;
  assume IsGoodInhaleState(inhaleHeap#_737, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_737[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_737[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_737[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_737, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  462.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_738 := Mask;
  fraction#_739 := 100;
  assert {:msg "  462.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_739 <= exhaleMask#_738[this, AVLTreeNode.valid][perm$R]) && ((fraction#_739 == exhaleMask#_738[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_738[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_738[this, AVLTreeNode.valid] := exhaleMask#_738[this, AVLTreeNode.valid][perm$R := exhaleMask#_738[this, AVLTreeNode.valid][perm$R] - fraction#_739];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_738);
  Mask := exhaleMask#_738;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_740 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_740, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_740[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_740[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_740, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_740[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_740[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_740, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_740[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_740[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_740, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_740[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_740[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_740, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_740[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_740[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_740, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_740, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_740, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_740[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_740, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_740, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_740, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_740[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_740, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  463.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  463.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
  if (k#47 == Heap[this, AVLTreeNode.key]) {
    // assigment to b
    b#48 := true;
  } else {
    // if
    assert {:msg "  467.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  467.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.key);
    if (k#47 < Heap[this, AVLTreeNode.key]) {
      // if
      assert {:msg "  468.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  468.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      if (!(Heap[this, AVLTreeNode.left] == null)) {
        // call has
        callHeap#_741 := Heap;
        callMask#_742 := Mask;
        callCredits#_743 := Credits;
        assert {:msg "  469.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  469.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
        assert {:msg "  469.6: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
        this#153 := Heap[this, AVLTreeNode.left];
        k#154 := k#47;
        // begin exhale (precondition)
        exhaleMask#_744 := Mask;
        fraction#_745 := 100;
        assert {:msg "  469.6: The precondition at 455.12 might not hold. Insufficient fraction at 455.12 for AVLTreeNode.valid."} (fraction#_745 <= exhaleMask#_744[this#153, AVLTreeNode.valid][perm$R]) && ((fraction#_745 == exhaleMask#_744[this#153, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_744[this#153, AVLTreeNode.valid][perm$N]));
        exhaleMask#_744[this#153, AVLTreeNode.valid] := exhaleMask#_744[this#153, AVLTreeNode.valid][perm$R := exhaleMask#_744[this#153, AVLTreeNode.valid][perm$R] - fraction#_745];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_744);
        Mask := exhaleMask#_744;
        assume wf(Heap, Mask);
        // end exhale
        havoc b#155;
        // inhale (postcondition)
        havoc inhaleHeap#_748;
        assume IsGoodInhaleState(inhaleHeap#_748, Heap, Mask);
        assume this#153 != null;
        Heap[this#153, AVLTreeNode.valid] := inhaleHeap#_748[this#153, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_748[this#153, AVLTreeNode.valid] == Heap;
        Mask[this#153, AVLTreeNode.valid] := Mask[this#153, AVLTreeNode.valid][perm$R := Mask[this#153, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_748[this#153, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_748, Mask);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        b#48 := b#155;
      } else {
        // assigment to b
        b#48 := false;
      }
    } else {
      // if
      assert {:msg "  474.9: Receiver might be null."} true ==> (this != null);
      assert {:msg "  474.9: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      if (!(Heap[this, AVLTreeNode.right] == null)) {
        // call has
        callHeap#_749 := Heap;
        callMask#_750 := Mask;
        callCredits#_751 := Credits;
        assert {:msg "  475.16: Receiver might be null."} true ==> (this != null);
        assert {:msg "  475.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
        assert {:msg "  475.6: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
        this#156 := Heap[this, AVLTreeNode.right];
        k#157 := k#47;
        // begin exhale (precondition)
        exhaleMask#_752 := Mask;
        fraction#_753 := 100;
        assert {:msg "  475.6: The precondition at 455.12 might not hold. Insufficient fraction at 455.12 for AVLTreeNode.valid."} (fraction#_753 <= exhaleMask#_752[this#156, AVLTreeNode.valid][perm$R]) && ((fraction#_753 == exhaleMask#_752[this#156, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_752[this#156, AVLTreeNode.valid][perm$N]));
        exhaleMask#_752[this#156, AVLTreeNode.valid] := exhaleMask#_752[this#156, AVLTreeNode.valid][perm$R := exhaleMask#_752[this#156, AVLTreeNode.valid][perm$R] - fraction#_753];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_752);
        Mask := exhaleMask#_752;
        assume wf(Heap, Mask);
        // end exhale
        havoc b#158;
        // inhale (postcondition)
        havoc inhaleHeap#_756;
        assume IsGoodInhaleState(inhaleHeap#_756, Heap, Mask);
        assume this#156 != null;
        Heap[this#156, AVLTreeNode.valid] := inhaleHeap#_756[this#156, AVLTreeNode.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_756[this#156, AVLTreeNode.valid] == Heap;
        Mask[this#156, AVLTreeNode.valid] := Mask[this#156, AVLTreeNode.valid][perm$R := Mask[this#156, AVLTreeNode.valid][perm$R] + 100];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_756[this#156, AVLTreeNode.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_756, Mask);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        b#48 := b#158;
      } else {
        // assigment to b
        b#48 := false;
      }
    }
  }
  // fold
  assert {:msg "  481.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_757 := Mask;
  fraction#_758 := 100;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (fraction#_758 <= exhaleMask#_757[this, AVLTreeNode.key][perm$R]) && ((fraction#_758 == exhaleMask#_757[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.key] := exhaleMask#_757[this, AVLTreeNode.key][perm$R := exhaleMask#_757[this, AVLTreeNode.key][perm$R] - fraction#_758];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_759 := 50;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} (fraction#_759 <= exhaleMask#_757[this, AVLTreeNode.height][perm$R]) && ((fraction#_759 == exhaleMask#_757[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.height] := exhaleMask#_757[this, AVLTreeNode.height][perm$R := exhaleMask#_757[this, AVLTreeNode.height][perm$R] - fraction#_759];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_760 := 100;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (fraction#_760 <= exhaleMask#_757[this, AVLTreeNode.left][perm$R]) && ((fraction#_760 == exhaleMask#_757[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.left] := exhaleMask#_757[this, AVLTreeNode.left][perm$R := exhaleMask#_757[this, AVLTreeNode.left][perm$R] - fraction#_760];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_761 := 100;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (fraction#_761 <= exhaleMask#_757[this, AVLTreeNode.right][perm$R]) && ((fraction#_761 == exhaleMask#_757[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.right] := exhaleMask#_757[this, AVLTreeNode.right][perm$R := exhaleMask#_757[this, AVLTreeNode.right][perm$R] - fraction#_761];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  fraction#_762 := 50;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} (fraction#_762 <= exhaleMask#_757[this, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_762 == exhaleMask#_757[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_757[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_757[this, AVLTreeNode.balanceFactor] := exhaleMask#_757[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_757[this, AVLTreeNode.balanceFactor][perm$R] - fraction#_762];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_757);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_763 := 100;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (fraction#_763 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_763 == exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_763];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_764 := 50;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} (fraction#_764 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_764 == exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_764];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_765 := 50;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} (fraction#_765 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_765 == exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_765];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_766 := 100;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (fraction#_766 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_766 == exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_766];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_767 := 50;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} (fraction#_767 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_767 == exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_767];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_768 := 50;
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} (fraction#_768 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_768 == exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_757[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_768];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_757);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  481.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  Mask := exhaleMask#_757;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_769;
  assume IsGoodInhaleState(inhaleHeap#_769, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_769[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_769[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_769[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_769, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTreeNode.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_770 := Mask;
  fraction#_771 := 100;
  assert {:msg "  454.2: The postcondition at 458.11 might not hold. Insufficient fraction at 458.11 for AVLTreeNode.valid."} (fraction#_771 <= exhaleMask#_770[this, AVLTreeNode.valid][perm$R]) && ((fraction#_771 == exhaleMask#_770[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_770[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_770[this, AVLTreeNode.valid] := exhaleMask#_770[this, AVLTreeNode.valid][perm$R := exhaleMask#_770[this, AVLTreeNode.valid][perm$R] - fraction#_771];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  Mask := exhaleMask#_770;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  454.2: Method might lock/unlock more than allowed."} (forall lk#_772: ref :: {Heap[lk#_772, held]} {Heap[lk#_772, rdheld]} (((0 < Heap[lk#_772, held]) == (0 < old(Heap)[lk#_772, held])) && (Heap[lk#_772, rdheld] == old(Heap)[lk#_772, rdheld])) || false);
  assert {:msg "  454.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.getBalanceFactor$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_773: HeapType;
  var inhaleHeap#_774: HeapType;
  var Heap#_778: HeapType;
  var Mask#_779: MaskType;
  var Credits#_780: CreditsType;
  var exhaleMask#_781: MaskType;
  var fraction#_782: int;
  var inhaleHeap#_783: HeapType;
  var Heap#_787: HeapType;
  var Mask#_788: MaskType;
  var Credits#_789: CreditsType;
  var exhaleMask#_790: MaskType;
  var fraction#_791: int;
  var inhaleHeap#_792: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_773;
  assume IsGoodInhaleState(inhaleHeap#_773, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_773[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_773[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_773[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_773, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_773[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$N := Mask[this, AVLTreeNode.balanceFactor][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_773[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_773, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_774;
  assume IsGoodInhaleState(inhaleHeap#_774, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_774[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_774[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_774[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_774, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_774[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$N := Mask[this, AVLTreeNode.balanceFactor][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_774[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_774, Mask);
  assert {:msg "  491.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  491.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assume bf#49 == Heap[this, AVLTreeNode.balanceFactor];
  // unfolding
  assert {:msg "  493.21: Receiver might be null."} true ==> (this != null);
  Heap#_778 := Heap;
  Mask#_779 := Mask;
  Credits#_780 := Credits;
  // begin exhale (unfolding)
  exhaleMask#_781 := Mask#_779;
  fraction#_782 := 100;
  assert {:msg "  493.11: Unfolding might fail. Insufficient fraction at 493.21 for AVLTreeNode.valid."} (fraction#_782 <= exhaleMask#_781[this, AVLTreeNode.valid][perm$R]) && ((fraction#_782 == exhaleMask#_781[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_781[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_781[this, AVLTreeNode.valid] := exhaleMask#_781[this, AVLTreeNode.valid][perm$R := exhaleMask#_781[this, AVLTreeNode.valid][perm$R] - fraction#_782];
  assume IsGoodMask(Mask#_779);
  assume wf(Heap#_778, Mask#_779);
  assume wf(Heap#_778, exhaleMask#_781);
  Mask#_779 := exhaleMask#_781;
  assume wf(Heap#_778, Mask#_779);
  // end exhale
  // inhale (unfolding)
  inhaleHeap#_783 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_783, Heap#_778, Mask#_779);
  assume this != null;
  Heap#_778[this, AVLTreeNode.key] := inhaleHeap#_783[this, AVLTreeNode.key];
  assume wf(Heap#_778, Mask#_779);
  assume true;
  Mask#_779[this, AVLTreeNode.key] := Mask#_779[this, AVLTreeNode.key][perm$R := Mask#_779[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask#_779);
  assume IsGoodState(inhaleHeap#_783[this, AVLTreeNode.key]);
  assume wf(Heap#_778, Mask#_779);
  assume wf(inhaleHeap#_783, Mask#_779);
  assume this != null;
  Heap#_778[this, AVLTreeNode.height] := inhaleHeap#_783[this, AVLTreeNode.height];
  assume wf(Heap#_778, Mask#_779);
  assume true;
  Mask#_779[this, AVLTreeNode.height] := Mask#_779[this, AVLTreeNode.height][perm$R := Mask#_779[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask#_779);
  assume IsGoodState(inhaleHeap#_783[this, AVLTreeNode.height]);
  assume wf(Heap#_778, Mask#_779);
  assume wf(inhaleHeap#_783, Mask#_779);
  assume this != null;
  Heap#_778[this, AVLTreeNode.left] := inhaleHeap#_783[this, AVLTreeNode.left];
  assume wf(Heap#_778, Mask#_779);
  assume (Heap#_778[this, AVLTreeNode.left] == null) || (dtype(Heap#_778[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask#_779[this, AVLTreeNode.left] := Mask#_779[this, AVLTreeNode.left][perm$R := Mask#_779[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask#_779);
  assume IsGoodState(inhaleHeap#_783[this, AVLTreeNode.left]);
  assume wf(Heap#_778, Mask#_779);
  assume wf(inhaleHeap#_783, Mask#_779);
  assume this != null;
  Heap#_778[this, AVLTreeNode.right] := inhaleHeap#_783[this, AVLTreeNode.right];
  assume wf(Heap#_778, Mask#_779);
  assume (Heap#_778[this, AVLTreeNode.right] == null) || (dtype(Heap#_778[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask#_779[this, AVLTreeNode.right] := Mask#_779[this, AVLTreeNode.right][perm$R := Mask#_779[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask#_779);
  assume IsGoodState(inhaleHeap#_783[this, AVLTreeNode.right]);
  assume wf(Heap#_778, Mask#_779);
  assume wf(inhaleHeap#_783, Mask#_779);
  assume this != null;
  Heap#_778[this, AVLTreeNode.balanceFactor] := inhaleHeap#_783[this, AVLTreeNode.balanceFactor];
  assume wf(Heap#_778, Mask#_779);
  assume true;
  Mask#_779[this, AVLTreeNode.balanceFactor] := Mask#_779[this, AVLTreeNode.balanceFactor][perm$R := Mask#_779[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask#_779);
  assume IsGoodState(inhaleHeap#_783[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap#_778, Mask#_779);
  assume wf(inhaleHeap#_783, Mask#_779);
  if (!(Heap#_778[this, AVLTreeNode.left] == null)) {
    assume Heap#_778[this, AVLTreeNode.left] != null;
    Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap#_778, Mask#_779);
    assume inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap#_778;
    Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_779);
    assume IsGoodState(inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap#_778, Mask#_779);
    assume wf(inhaleHeap#_783, Mask#_779);
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.left] == null)) {
    assume Heap#_778[this, AVLTreeNode.left] != null;
    Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap#_778, Mask#_779);
    assume true;
    Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height] := Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_779);
    assume IsGoodState(inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap#_778, Mask#_779);
    assume wf(inhaleHeap#_783, Mask#_779);
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.left] == null)) {
    assume Heap#_778[this, AVLTreeNode.left] != null;
    Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap#_778, Mask#_779);
    assume true;
    Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_779[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_779);
    assume IsGoodState(inhaleHeap#_783[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_778, Mask#_779);
    assume wf(inhaleHeap#_783, Mask#_779);
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.left] == null)) {
    assume Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.right] == null)) {
    assume Heap#_778[this, AVLTreeNode.right] != null;
    Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap#_778, Mask#_779);
    assume inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap#_778;
    Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_779);
    assume IsGoodState(inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap#_778, Mask#_779);
    assume wf(inhaleHeap#_783, Mask#_779);
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.right] == null)) {
    assume Heap#_778[this, AVLTreeNode.right] != null;
    Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap#_778, Mask#_779);
    assume true;
    Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height] := Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_779);
    assume IsGoodState(inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap#_778, Mask#_779);
    assume wf(inhaleHeap#_783, Mask#_779);
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.right] == null)) {
    assume Heap#_778[this, AVLTreeNode.right] != null;
    Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap#_778, Mask#_779);
    assume true;
    Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_779[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_779);
    assume IsGoodState(inhaleHeap#_783[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_778, Mask#_779);
    assume wf(inhaleHeap#_783, Mask#_779);
  } else {
  }
  if (!(Heap#_778[this, AVLTreeNode.right] == null)) {
    assume Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap#_778[this, AVLTreeNode.height] == ite(ite(Heap#_778[this, AVLTreeNode.left] == null, 0, Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_778[this, AVLTreeNode.right] == null, 0, Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_778[this, AVLTreeNode.left] == null, 0, Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_778[this, AVLTreeNode.right] == null, 0, Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap#_778[this, AVLTreeNode.balanceFactor] == (ite(Heap#_778[this, AVLTreeNode.left] == null, 0, Heap#_778[Heap#_778[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_778[this, AVLTreeNode.right] == null, 0, Heap#_778[Heap#_778[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap#_778[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap#_778[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap#_778[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask#_779);
  assume wf(Heap#_778, Mask#_779);
  // end inhale
  assert {:msg "  493.39: Receiver might be null."} true && (bf#49 > 0) ==> (this != null);
  assert {:msg "  493.39: Location might not be readable."} true && (bf#49 > 0) ==> CanRead(Mask#_779, this, AVLTreeNode.left);
  assume (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  // unfolding
  assert {:msg "  494.21: Receiver might be null."} true ==> (this != null);
  Heap#_787 := Heap;
  Mask#_788 := Mask;
  Credits#_789 := Credits;
  // begin exhale (unfolding)
  exhaleMask#_790 := Mask#_788;
  fraction#_791 := 100;
  assert {:msg "  494.11: Unfolding might fail. Insufficient fraction at 494.21 for AVLTreeNode.valid."} (fraction#_791 <= exhaleMask#_790[this, AVLTreeNode.valid][perm$R]) && ((fraction#_791 == exhaleMask#_790[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_790[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_790[this, AVLTreeNode.valid] := exhaleMask#_790[this, AVLTreeNode.valid][perm$R := exhaleMask#_790[this, AVLTreeNode.valid][perm$R] - fraction#_791];
  assume IsGoodMask(Mask#_788);
  assume wf(Heap#_787, Mask#_788);
  assume wf(Heap#_787, exhaleMask#_790);
  Mask#_788 := exhaleMask#_790;
  assume wf(Heap#_787, Mask#_788);
  // end exhale
  // inhale (unfolding)
  inhaleHeap#_792 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_792, Heap#_787, Mask#_788);
  assume this != null;
  Heap#_787[this, AVLTreeNode.key] := inhaleHeap#_792[this, AVLTreeNode.key];
  assume wf(Heap#_787, Mask#_788);
  assume true;
  Mask#_788[this, AVLTreeNode.key] := Mask#_788[this, AVLTreeNode.key][perm$R := Mask#_788[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask#_788);
  assume IsGoodState(inhaleHeap#_792[this, AVLTreeNode.key]);
  assume wf(Heap#_787, Mask#_788);
  assume wf(inhaleHeap#_792, Mask#_788);
  assume this != null;
  Heap#_787[this, AVLTreeNode.height] := inhaleHeap#_792[this, AVLTreeNode.height];
  assume wf(Heap#_787, Mask#_788);
  assume true;
  Mask#_788[this, AVLTreeNode.height] := Mask#_788[this, AVLTreeNode.height][perm$R := Mask#_788[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask#_788);
  assume IsGoodState(inhaleHeap#_792[this, AVLTreeNode.height]);
  assume wf(Heap#_787, Mask#_788);
  assume wf(inhaleHeap#_792, Mask#_788);
  assume this != null;
  Heap#_787[this, AVLTreeNode.left] := inhaleHeap#_792[this, AVLTreeNode.left];
  assume wf(Heap#_787, Mask#_788);
  assume (Heap#_787[this, AVLTreeNode.left] == null) || (dtype(Heap#_787[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask#_788[this, AVLTreeNode.left] := Mask#_788[this, AVLTreeNode.left][perm$R := Mask#_788[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask#_788);
  assume IsGoodState(inhaleHeap#_792[this, AVLTreeNode.left]);
  assume wf(Heap#_787, Mask#_788);
  assume wf(inhaleHeap#_792, Mask#_788);
  assume this != null;
  Heap#_787[this, AVLTreeNode.right] := inhaleHeap#_792[this, AVLTreeNode.right];
  assume wf(Heap#_787, Mask#_788);
  assume (Heap#_787[this, AVLTreeNode.right] == null) || (dtype(Heap#_787[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask#_788[this, AVLTreeNode.right] := Mask#_788[this, AVLTreeNode.right][perm$R := Mask#_788[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask#_788);
  assume IsGoodState(inhaleHeap#_792[this, AVLTreeNode.right]);
  assume wf(Heap#_787, Mask#_788);
  assume wf(inhaleHeap#_792, Mask#_788);
  assume this != null;
  Heap#_787[this, AVLTreeNode.balanceFactor] := inhaleHeap#_792[this, AVLTreeNode.balanceFactor];
  assume wf(Heap#_787, Mask#_788);
  assume true;
  Mask#_788[this, AVLTreeNode.balanceFactor] := Mask#_788[this, AVLTreeNode.balanceFactor][perm$R := Mask#_788[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask#_788);
  assume IsGoodState(inhaleHeap#_792[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap#_787, Mask#_788);
  assume wf(inhaleHeap#_792, Mask#_788);
  if (!(Heap#_787[this, AVLTreeNode.left] == null)) {
    assume Heap#_787[this, AVLTreeNode.left] != null;
    Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap#_787, Mask#_788);
    assume inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap#_787;
    Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_788);
    assume IsGoodState(inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap#_787, Mask#_788);
    assume wf(inhaleHeap#_792, Mask#_788);
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.left] == null)) {
    assume Heap#_787[this, AVLTreeNode.left] != null;
    Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap#_787, Mask#_788);
    assume true;
    Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height] := Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_788);
    assume IsGoodState(inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap#_787, Mask#_788);
    assume wf(inhaleHeap#_792, Mask#_788);
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.left] == null)) {
    assume Heap#_787[this, AVLTreeNode.left] != null;
    Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap#_787, Mask#_788);
    assume true;
    Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_788[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_788);
    assume IsGoodState(inhaleHeap#_792[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_787, Mask#_788);
    assume wf(inhaleHeap#_792, Mask#_788);
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.left] == null)) {
    assume Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.right] == null)) {
    assume Heap#_787[this, AVLTreeNode.right] != null;
    Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap#_787, Mask#_788);
    assume inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap#_787;
    Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask#_788);
    assume IsGoodState(inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap#_787, Mask#_788);
    assume wf(inhaleHeap#_792, Mask#_788);
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.right] == null)) {
    assume Heap#_787[this, AVLTreeNode.right] != null;
    Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap#_787, Mask#_788);
    assume true;
    Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height] := Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_788);
    assume IsGoodState(inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap#_787, Mask#_788);
    assume wf(inhaleHeap#_792, Mask#_788);
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.right] == null)) {
    assume Heap#_787[this, AVLTreeNode.right] != null;
    Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap#_787, Mask#_788);
    assume true;
    Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_788[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_788);
    assume IsGoodState(inhaleHeap#_792[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_787, Mask#_788);
    assume wf(inhaleHeap#_792, Mask#_788);
  } else {
  }
  if (!(Heap#_787[this, AVLTreeNode.right] == null)) {
    assume Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap#_787[this, AVLTreeNode.height] == ite(ite(Heap#_787[this, AVLTreeNode.left] == null, 0, Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_787[this, AVLTreeNode.right] == null, 0, Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_787[this, AVLTreeNode.left] == null, 0, Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_787[this, AVLTreeNode.right] == null, 0, Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap#_787[this, AVLTreeNode.balanceFactor] == (ite(Heap#_787[this, AVLTreeNode.left] == null, 0, Heap#_787[Heap#_787[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_787[this, AVLTreeNode.right] == null, 0, Heap#_787[Heap#_787[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap#_787[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap#_787[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap#_787[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask#_788);
  assume wf(Heap#_787, Mask#_788);
  // end inhale
  assert {:msg "  494.39: Receiver might be null."} true && (bf#49 < 0) ==> (this != null);
  assert {:msg "  494.39: Location might not be readable."} true && (bf#49 < 0) ==> CanRead(Mask#_788, this, AVLTreeNode.right);
  assume (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.getBalanceFactor(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#49: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_793: HeapType;
  var exhaleMask#_794: MaskType;
  var fraction#_795: int;
  var inhaleHeap#_796: HeapType;
  var lh#51: int where true;
  var rh#53: int where true;
  var exhaleMask#_797: MaskType;
  var fraction#_798: int;
  var fraction#_799: int;
  var fraction#_800: int;
  var fraction#_801: int;
  var fraction#_802: int;
  var fraction#_803: int;
  var fraction#_804: int;
  var fraction#_805: int;
  var fraction#_806: int;
  var fraction#_807: int;
  var fraction#_808: int;
  var inhaleHeap#_809: HeapType;
  var exhaleMask#_810: MaskType;
  var fraction#_811: int;
  var epsilons#_812: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_793;
  assume IsGoodInhaleState(inhaleHeap#_793, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_793[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_793[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_793[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_793, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_793[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$N := Mask[this, AVLTreeNode.balanceFactor][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_793[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_793, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  496.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_794 := Mask;
  fraction#_795 := 100;
  assert {:msg "  496.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_795 <= exhaleMask#_794[this, AVLTreeNode.valid][perm$R]) && ((fraction#_795 == exhaleMask#_794[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_794[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_794[this, AVLTreeNode.valid] := exhaleMask#_794[this, AVLTreeNode.valid][perm$R := exhaleMask#_794[this, AVLTreeNode.valid][perm$R] - fraction#_795];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_794);
  Mask := exhaleMask#_794;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_796 := Heap[this, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_796, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_796[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_796[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_796[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_796[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_796[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_796[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_796, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_796[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_796, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[this, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // local var lh
  // assigment to lh
  assert {:msg "  497.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  497.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  497.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  497.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  497.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  497.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#51 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  498.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  498.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  498.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  498.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  498.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  498.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#53 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assigment to bf
  bf#49 := lh#51 - rh#53;
  // fold
  assert {:msg "  504.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_797 := Mask;
  fraction#_798 := 100;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (fraction#_798 <= exhaleMask#_797[this, AVLTreeNode.key][perm$R]) && ((fraction#_798 == exhaleMask#_797[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_797[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_797[this, AVLTreeNode.key] := exhaleMask#_797[this, AVLTreeNode.key][perm$R := exhaleMask#_797[this, AVLTreeNode.key][perm$R] - fraction#_798];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_797);
  fraction#_799 := 50;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} (fraction#_799 <= exhaleMask#_797[this, AVLTreeNode.height][perm$R]) && ((fraction#_799 == exhaleMask#_797[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_797[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_797[this, AVLTreeNode.height] := exhaleMask#_797[this, AVLTreeNode.height][perm$R := exhaleMask#_797[this, AVLTreeNode.height][perm$R] - fraction#_799];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_797);
  fraction#_800 := 100;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (fraction#_800 <= exhaleMask#_797[this, AVLTreeNode.left][perm$R]) && ((fraction#_800 == exhaleMask#_797[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_797[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_797[this, AVLTreeNode.left] := exhaleMask#_797[this, AVLTreeNode.left][perm$R := exhaleMask#_797[this, AVLTreeNode.left][perm$R] - fraction#_800];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_797);
  fraction#_801 := 100;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (fraction#_801 <= exhaleMask#_797[this, AVLTreeNode.right][perm$R]) && ((fraction#_801 == exhaleMask#_797[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_797[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_797[this, AVLTreeNode.right] := exhaleMask#_797[this, AVLTreeNode.right][perm$R := exhaleMask#_797[this, AVLTreeNode.right][perm$R] - fraction#_801];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_797);
  fraction#_802 := 50;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} (fraction#_802 <= exhaleMask#_797[this, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_802 == exhaleMask#_797[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_797[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_797[this, AVLTreeNode.balanceFactor] := exhaleMask#_797[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_797[this, AVLTreeNode.balanceFactor][perm$R] - fraction#_802];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_797);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_803 := 100;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (fraction#_803 <= exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_803 == exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_803];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_797);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_804 := 50;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} (fraction#_804 <= exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_804 == exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_804];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_797);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_805 := 50;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} (fraction#_805 <= exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_805 == exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_797[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_805];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_797);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_806 := 100;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (fraction#_806 <= exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_806 == exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_806];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_797);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_807 := 50;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} (fraction#_807 <= exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_807 == exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_807];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_797);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_808 := 50;
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} (fraction#_808 <= exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_808 == exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_797[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_808];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_797);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  504.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  Mask := exhaleMask#_797;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_809;
  assume IsGoodInhaleState(inhaleHeap#_809, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_809[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_809[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_809[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_809, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTreeNode.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_810 := Mask;
  fraction#_811 := 100;
  assert {:msg "  485.2: The postcondition at 489.11 might not hold. Insufficient fraction at 489.11 for AVLTreeNode.valid."} (fraction#_811 <= exhaleMask#_810[this, AVLTreeNode.valid][perm$R]) && ((fraction#_811 == exhaleMask#_810[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_810[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_810[this, AVLTreeNode.valid] := exhaleMask#_810[this, AVLTreeNode.valid][perm$R := exhaleMask#_810[this, AVLTreeNode.valid][perm$R] - fraction#_811];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_810);
  epsilons#_812 := 1;
  assert {:msg "  485.2: The postcondition at 490.11 might not hold. Insufficient epsilons at 490.11  for AVLTreeNode.balanceFactor."} (exhaleMask#_810[this, AVLTreeNode.balanceFactor][perm$R] == 0) ==> (epsilons#_812 <= exhaleMask#_810[this, AVLTreeNode.balanceFactor][perm$N]);
  if ((exhaleMask#_810[this, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (exhaleMask#_810[this, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_810[this, AVLTreeNode.balanceFactor] := exhaleMask#_810[this, AVLTreeNode.balanceFactor][perm$N := exhaleMask#_810[this, AVLTreeNode.balanceFactor][perm$N] - epsilons#_812];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_810);
  assert {:msg "  485.2: The postcondition at 491.11 might not hold. The expression at 491.11 might not evaluate to true."} bf#49 == Heap[this, AVLTreeNode.balanceFactor];
  assert {:msg "  485.2: The postcondition at 493.11 might not hold. The expression at 493.11 might not evaluate to true."} (bf#49 > 0) ==> (!(Heap[this, AVLTreeNode.left] == null));
  assert {:msg "  485.2: The postcondition at 494.11 might not hold. The expression at 494.11 might not evaluate to true."} (bf#49 < 0) ==> (!(Heap[this, AVLTreeNode.right] == null));
  Mask := exhaleMask#_810;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  485.2: Method might lock/unlock more than allowed."} (forall lk#_813: ref :: {Heap[lk#_813, held]} {Heap[lk#_813, rdheld]} (((0 < Heap[lk#_813, held]) == (0 < old(Heap)[lk#_813, held])) && (Heap[lk#_813, rdheld] == old(Heap)[lk#_813, rdheld])) || false);
  assert {:msg "  485.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.getBalanceFactorI$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#54: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_814: HeapType;
  var inhaleHeap#_815: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_814;
  assume IsGoodInhaleState(inhaleHeap#_814, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_814[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$N := Mask[this, AVLTreeNode.left][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_814[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_814, Mask);
  assert {:msg "  510.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  510.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  510.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  510.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_814[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_814[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_814[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_814, Mask);
  } else {
  }
  assert {:msg "  511.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  511.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  511.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  511.30: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_814[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_814[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_814, Mask);
  } else {
  }
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_814[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$N := Mask[this, AVLTreeNode.right][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_814[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_814, Mask);
  assert {:msg "  514.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  514.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  514.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  514.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_814[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_814[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_814[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_814, Mask);
  } else {
  }
  assert {:msg "  515.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  515.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  515.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  515.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_814[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_814[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_814, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_815;
  assume IsGoodInhaleState(inhaleHeap#_815, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_815[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$N := Mask[this, AVLTreeNode.left][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_815[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_815, Mask);
  assert {:msg "  518.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  518.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  518.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  518.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_815[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_815[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_815[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_815, Mask);
  } else {
  }
  assert {:msg "  519.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  519.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  519.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  519.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_815[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_815[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_815, Mask);
  } else {
  }
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_815[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$N := Mask[this, AVLTreeNode.right][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_815[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_815, Mask);
  assert {:msg "  522.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  522.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  522.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  522.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_815[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_815[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_815[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_815, Mask);
  } else {
  }
  assert {:msg "  523.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  523.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  523.30: Receiver might be null."} true ==> (this != null);
    assert {:msg "  523.30: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_815[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_815[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_815, Mask);
  } else {
  }
  assert {:msg "  525.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  525.18: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  525.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  525.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  525.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  525.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  525.45: Receiver might be null."} true ==> (this != null);
  assert {:msg "  525.45: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  525.59: Receiver might be null."} true ==> (this != null);
    assert {:msg "  525.59: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  525.59: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  525.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume bf#54 == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  if (bf#54 > 0) {
    assert {:msg "  526.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  526.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume !(Heap[this, AVLTreeNode.left] == null);
  } else {
  }
  if (bf#54 < 0) {
    assert {:msg "  527.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  527.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume !(Heap[this, AVLTreeNode.right] == null);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.getBalanceFactorI(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (bf#54: int where true)
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_816: HeapType;
  var lh#56: int where true;
  var rh#58: int where true;
  var Heap#_820: HeapType;
  var Mask#_821: MaskType;
  var Credits#_822: CreditsType;
  var exhaleMask#_823: MaskType;
  var Heap#_827: HeapType;
  var Mask#_828: MaskType;
  var Credits#_829: CreditsType;
  var exhaleMask#_830: MaskType;
  var fraction#_831: int;
  var inhaleHeap#_832: HeapType;
  var Heap#_836: HeapType;
  var Mask#_837: MaskType;
  var Credits#_838: CreditsType;
  var exhaleMask#_839: MaskType;
  var Heap#_843: HeapType;
  var Mask#_844: MaskType;
  var Credits#_845: CreditsType;
  var exhaleMask#_846: MaskType;
  var fraction#_847: int;
  var inhaleHeap#_848: HeapType;
  var Heap#_852: HeapType;
  var Mask#_853: MaskType;
  var Credits#_854: CreditsType;
  var exhaleMask#_855: MaskType;
  var Heap#_859: HeapType;
  var Mask#_860: MaskType;
  var Credits#_861: CreditsType;
  var exhaleMask#_862: MaskType;
  var exhaleMask#_863: MaskType;
  var epsilons#_864: int;
  var fraction#_865: int;
  var epsilons#_866: int;
  var epsilons#_867: int;
  var fraction#_868: int;
  var epsilons#_869: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_816;
  assume IsGoodInhaleState(inhaleHeap#_816, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_816[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$N := Mask[this, AVLTreeNode.left][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_816[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_816, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_816[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_816[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_816[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_816, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_816[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_816[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_816, Mask);
  } else {
  }
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_816[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  if ((Mask[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (Mask[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$N := Mask[this, AVLTreeNode.right][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_816[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_816, Mask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_816[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_816[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_816[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_816, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_816[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    if ((Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] + 1];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_816[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_816, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var lh
  // assigment to lh
  assert {:msg "  529.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  529.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  529.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  529.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  529.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  529.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#56 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  530.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  530.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  530.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  530.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  530.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  530.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#58 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assigment to bf
  bf#54 := lh#56 - rh#58;
  // assert
  Heap#_820 := Heap;
  Mask#_821 := Mask;
  Credits#_822 := Credits;
  // begin exhale (assert)
  exhaleMask#_823 := Mask#_821;
  assert {:msg "  532.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  532.10: Location might not be readable."} true ==> CanRead(Mask#_821, this, AVLTreeNode.right);
  if (!(Heap#_820[this, AVLTreeNode.right] == null)) {
    // unfolding
    assert {:msg "  532.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  532.36: Location might not be readable."} true ==> CanRead(Mask#_821, this, AVLTreeNode.right);
    assert {:msg "  532.36: Receiver might be null."} true ==> (Heap#_820[this, AVLTreeNode.right] != null);
    Heap#_827 := Heap#_820;
    Mask#_828 := Mask#_821;
    Credits#_829 := Credits#_822;
    // begin exhale (unfolding)
    exhaleMask#_830 := Mask#_828;
    fraction#_831 := 100;
    assert {:msg "  532.26: Unfolding might fail. Insufficient fraction at 532.36 for AVLTreeNode.valid."} (fraction#_831 <= exhaleMask#_830[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_831 == exhaleMask#_830[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_830[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_830[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_830[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_830[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_831];
    assume IsGoodMask(Mask#_828);
    assume wf(Heap#_827, Mask#_828);
    assume wf(Heap#_827, exhaleMask#_830);
    Mask#_828 := exhaleMask#_830;
    assume wf(Heap#_827, Mask#_828);
    // end exhale
    // inhale (unfolding)
    inhaleHeap#_832 := Heap#_820[Heap#_820[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume IsGoodInhaleState(inhaleHeap#_832, Heap#_827, Mask#_828);
    assume Heap#_827[this, AVLTreeNode.right] != null;
    Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.key];
    assume wf(Heap#_827, Mask#_828);
    assume true;
    Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.key] := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
    assume IsGoodMask(Mask#_828);
    assume IsGoodState(inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume wf(Heap#_827, Mask#_828);
    assume wf(inhaleHeap#_832, Mask#_828);
    assume Heap#_827[this, AVLTreeNode.right] != null;
    Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap#_827, Mask#_828);
    assume true;
    Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height] := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_828);
    assume IsGoodState(inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap#_827, Mask#_828);
    assume wf(inhaleHeap#_832, Mask#_828);
    assume Heap#_827[this, AVLTreeNode.right] != null;
    Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left];
    assume wf(Heap#_827, Mask#_828);
    assume (Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
    assume IsGoodMask(Mask#_828);
    assume IsGoodState(inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left]);
    assume wf(Heap#_827, Mask#_828);
    assume wf(inhaleHeap#_832, Mask#_828);
    assume Heap#_827[this, AVLTreeNode.right] != null;
    Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right];
    assume wf(Heap#_827, Mask#_828);
    assume (Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
    assume IsGoodMask(Mask#_828);
    assume IsGoodState(inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right]);
    assume wf(Heap#_827, Mask#_828);
    assume wf(inhaleHeap#_832, Mask#_828);
    assume Heap#_827[this, AVLTreeNode.right] != null;
    Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap#_827, Mask#_828);
    assume true;
    Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_828[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_828);
    assume IsGoodState(inhaleHeap#_832[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_827, Mask#_828);
    assume wf(inhaleHeap#_832, Mask#_828);
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap#_827, Mask#_828);
      assume inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_827;
      Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_828);
      assume IsGoodState(inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap#_827, Mask#_828);
      assume wf(inhaleHeap#_832, Mask#_828);
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap#_827, Mask#_828);
      assume true;
      Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_828);
      assume IsGoodState(inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap#_827, Mask#_828);
      assume wf(inhaleHeap#_832, Mask#_828);
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor];
      assume wf(Heap#_827, Mask#_828);
      assume true;
      Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_828);
      assume IsGoodState(inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_827, Mask#_828);
      assume wf(inhaleHeap#_832, Mask#_828);
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap#_827, Mask#_828);
      assume inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_827;
      Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_828);
      assume IsGoodState(inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap#_827, Mask#_828);
      assume wf(inhaleHeap#_832, Mask#_828);
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap#_827, Mask#_828);
      assume true;
      Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_828);
      assume IsGoodState(inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap#_827, Mask#_828);
      assume wf(inhaleHeap#_832, Mask#_828);
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor];
      assume wf(Heap#_827, Mask#_828);
      assume true;
      Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_828[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_828);
      assume IsGoodState(inhaleHeap#_832[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_827, Mask#_828);
      assume wf(inhaleHeap#_832, Mask#_828);
    } else {
    }
    if (!(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    } else {
    }
    assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_827[Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap#_827[Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(Mask#_828);
    assume wf(Heap#_827, Mask#_828);
    // end inhale
    assert {:msg "  532.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  532.51: Location might not be readable."} true ==> CanRead(Mask#_828, this, AVLTreeNode.right);
    assert {:msg "  532.51: Receiver might be null."} true ==> (Heap#_827[this, AVLTreeNode.right] != null);
    assert {:msg "  532.51: Location might not be readable."} true ==> CanRead(Mask#_828, Heap#_827[this, AVLTreeNode.right], AVLTreeNode.height);
    assert {:msg "  532.3: Assertion might not hold. The expression at 532.26 might not evaluate to true."} Heap#_820[Heap#_820[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  Mask#_821 := exhaleMask#_823;
  assume wf(Heap#_820, Mask#_821);
  // end exhale
  // assert
  Heap#_836 := Heap;
  Mask#_837 := Mask;
  Credits#_838 := Credits;
  // begin exhale (assert)
  exhaleMask#_839 := Mask#_837;
  assert {:msg "  533.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  533.10: Location might not be readable."} true ==> CanRead(Mask#_837, this, AVLTreeNode.left);
  if (!(Heap#_836[this, AVLTreeNode.left] == null)) {
    // unfolding
    assert {:msg "  533.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  533.36: Location might not be readable."} true ==> CanRead(Mask#_837, this, AVLTreeNode.left);
    assert {:msg "  533.36: Receiver might be null."} true ==> (Heap#_836[this, AVLTreeNode.left] != null);
    Heap#_843 := Heap#_836;
    Mask#_844 := Mask#_837;
    Credits#_845 := Credits#_838;
    // begin exhale (unfolding)
    exhaleMask#_846 := Mask#_844;
    fraction#_847 := 100;
    assert {:msg "  533.26: Unfolding might fail. Insufficient fraction at 533.36 for AVLTreeNode.valid."} (fraction#_847 <= exhaleMask#_846[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_847 == exhaleMask#_846[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_846[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_846[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_846[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_846[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_847];
    assume IsGoodMask(Mask#_844);
    assume wf(Heap#_843, Mask#_844);
    assume wf(Heap#_843, exhaleMask#_846);
    Mask#_844 := exhaleMask#_846;
    assume wf(Heap#_843, Mask#_844);
    // end exhale
    // inhale (unfolding)
    inhaleHeap#_848 := Heap#_836[Heap#_836[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume IsGoodInhaleState(inhaleHeap#_848, Heap#_843, Mask#_844);
    assume Heap#_843[this, AVLTreeNode.left] != null;
    Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.key];
    assume wf(Heap#_843, Mask#_844);
    assume true;
    Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.key] := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
    assume IsGoodMask(Mask#_844);
    assume IsGoodState(inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume wf(Heap#_843, Mask#_844);
    assume wf(inhaleHeap#_848, Mask#_844);
    assume Heap#_843[this, AVLTreeNode.left] != null;
    Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap#_843, Mask#_844);
    assume true;
    Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height] := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_844);
    assume IsGoodState(inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap#_843, Mask#_844);
    assume wf(inhaleHeap#_848, Mask#_844);
    assume Heap#_843[this, AVLTreeNode.left] != null;
    Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left];
    assume wf(Heap#_843, Mask#_844);
    assume (Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
    assume IsGoodMask(Mask#_844);
    assume IsGoodState(inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left]);
    assume wf(Heap#_843, Mask#_844);
    assume wf(inhaleHeap#_848, Mask#_844);
    assume Heap#_843[this, AVLTreeNode.left] != null;
    Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right];
    assume wf(Heap#_843, Mask#_844);
    assume (Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
    assume IsGoodMask(Mask#_844);
    assume IsGoodState(inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right]);
    assume wf(Heap#_843, Mask#_844);
    assume wf(inhaleHeap#_848, Mask#_844);
    assume Heap#_843[this, AVLTreeNode.left] != null;
    Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap#_843, Mask#_844);
    assume true;
    Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_844[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_844);
    assume IsGoodState(inhaleHeap#_848[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_843, Mask#_844);
    assume wf(inhaleHeap#_848, Mask#_844);
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap#_843, Mask#_844);
      assume inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_843;
      Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_844);
      assume IsGoodState(inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap#_843, Mask#_844);
      assume wf(inhaleHeap#_848, Mask#_844);
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap#_843, Mask#_844);
      assume true;
      Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_844);
      assume IsGoodState(inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap#_843, Mask#_844);
      assume wf(inhaleHeap#_848, Mask#_844);
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor];
      assume wf(Heap#_843, Mask#_844);
      assume true;
      Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_844);
      assume IsGoodState(inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_843, Mask#_844);
      assume wf(inhaleHeap#_848, Mask#_844);
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap#_843, Mask#_844);
      assume inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_843;
      Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_844);
      assume IsGoodState(inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap#_843, Mask#_844);
      assume wf(inhaleHeap#_848, Mask#_844);
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap#_843, Mask#_844);
      assume true;
      Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_844);
      assume IsGoodState(inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap#_843, Mask#_844);
      assume wf(inhaleHeap#_848, Mask#_844);
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor];
      assume wf(Heap#_843, Mask#_844);
      assume true;
      Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_844[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_844);
      assume IsGoodState(inhaleHeap#_848[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_843, Mask#_844);
      assume wf(inhaleHeap#_848, Mask#_844);
    } else {
    }
    if (!(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    } else {
    }
    assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_843[Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap#_843[Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(Mask#_844);
    assume wf(Heap#_843, Mask#_844);
    // end inhale
    assert {:msg "  533.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  533.51: Location might not be readable."} true ==> CanRead(Mask#_844, this, AVLTreeNode.left);
    assert {:msg "  533.51: Receiver might be null."} true ==> (Heap#_843[this, AVLTreeNode.left] != null);
    assert {:msg "  533.51: Location might not be readable."} true ==> CanRead(Mask#_844, Heap#_843[this, AVLTreeNode.left], AVLTreeNode.height);
    assert {:msg "  533.3: Assertion might not hold. The expression at 533.26 might not evaluate to true."} Heap#_836[Heap#_836[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  Mask#_837 := exhaleMask#_839;
  assume wf(Heap#_836, Mask#_837);
  // end exhale
  // assert
  Heap#_852 := Heap;
  Mask#_853 := Mask;
  Credits#_854 := Credits;
  // begin exhale (assert)
  exhaleMask#_855 := Mask#_853;
  assert {:msg "  534.3: Assertion might not hold. The expression at 534.10 might not evaluate to true."} lh#56 >= 0;
  Mask#_853 := exhaleMask#_855;
  assume wf(Heap#_852, Mask#_853);
  // end exhale
  // assert
  Heap#_859 := Heap;
  Mask#_860 := Mask;
  Credits#_861 := Credits;
  // begin exhale (assert)
  exhaleMask#_862 := Mask#_860;
  assert {:msg "  535.3: Assertion might not hold. The expression at 535.10 might not evaluate to true."} rh#58 >= 0;
  Mask#_860 := exhaleMask#_862;
  assume wf(Heap#_859, Mask#_860);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_863 := Mask;
  epsilons#_864 := 1;
  assert {:msg "  508.2: The postcondition at 517.11 might not hold. Insufficient epsilons at 517.11  for AVLTreeNode.left."} (exhaleMask#_863[this, AVLTreeNode.left][perm$R] == 0) ==> (epsilons#_864 <= exhaleMask#_863[this, AVLTreeNode.left][perm$N]);
  if ((exhaleMask#_863[this, AVLTreeNode.left][perm$N] != Permission$MinusInfinity) && (exhaleMask#_863[this, AVLTreeNode.left][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_863[this, AVLTreeNode.left] := exhaleMask#_863[this, AVLTreeNode.left][perm$N := exhaleMask#_863[this, AVLTreeNode.left][perm$N] - epsilons#_864];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_865 := 100;
    assert {:msg "  508.2: The postcondition at 518.11 might not hold. Insufficient fraction at 518.26 for AVLTreeNode.valid."} (fraction#_865 <= exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_865 == exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_865];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_863);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    epsilons#_866 := 1;
    assert {:msg "  508.2: The postcondition at 519.11 might not hold. Insufficient epsilons at 519.26  for AVLTreeNode.height."} (exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_866 <= exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]);
    if ((exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N := exhaleMask#_863[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N] - epsilons#_866];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_863);
  } else {
  }
  epsilons#_867 := 1;
  assert {:msg "  508.2: The postcondition at 521.11 might not hold. Insufficient epsilons at 521.11  for AVLTreeNode.right."} (exhaleMask#_863[this, AVLTreeNode.right][perm$R] == 0) ==> (epsilons#_867 <= exhaleMask#_863[this, AVLTreeNode.right][perm$N]);
  if ((exhaleMask#_863[this, AVLTreeNode.right][perm$N] != Permission$MinusInfinity) && (exhaleMask#_863[this, AVLTreeNode.right][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_863[this, AVLTreeNode.right] := exhaleMask#_863[this, AVLTreeNode.right][perm$N := exhaleMask#_863[this, AVLTreeNode.right][perm$N] - epsilons#_867];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_868 := 100;
    assert {:msg "  508.2: The postcondition at 522.11 might not hold. Insufficient fraction at 522.27 for AVLTreeNode.valid."} (fraction#_868 <= exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_868 == exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_868];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_863);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    epsilons#_869 := 1;
    assert {:msg "  508.2: The postcondition at 523.11 might not hold. Insufficient epsilons at 523.27  for AVLTreeNode.height."} (exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] == 0) ==> (epsilons#_869 <= exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]);
    if ((exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$MinusInfinity) && (exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] != Permission$PlusInfinity)) {
      exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N := exhaleMask#_863[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N] - epsilons#_869];
      assume wf(Heap, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_863);
  } else {
  }
  assert {:msg "  508.2: The postcondition at 525.11 might not hold. The expression at 525.11 might not evaluate to true."} bf#54 == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  if (bf#54 > 0) {
    assert {:msg "  508.2: The postcondition at 526.11 might not hold. The expression at 526.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.left] == null);
  } else {
  }
  if (bf#54 < 0) {
    assert {:msg "  508.2: The postcondition at 527.11 might not hold. The expression at 527.20 might not evaluate to true."} !(Heap[this, AVLTreeNode.right] == null);
  } else {
  }
  Mask := exhaleMask#_863;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  508.2: Method might lock/unlock more than allowed."} (forall lk#_870: ref :: {Heap[lk#_870, held]} {Heap[lk#_870, rdheld]} (((0 < Heap[lk#_870, held]) == (0 < old(Heap)[lk#_870, held])) && (Heap[lk#_870, rdheld] == old(Heap)[lk#_870, rdheld])) || false);
  assert {:msg "  508.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.close$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_871: HeapType;
  var inhaleHeap#_872: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_871;
  assume IsGoodInhaleState(inhaleHeap#_871, Heap, Mask);
  assert {:msg "  542.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  542.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_871[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_871[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_871, Mask);
  assert {:msg "  543.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  543.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_871[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_871[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_871, Mask);
  assert {:msg "  544.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  544.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_871[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_871[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_871, Mask);
  assert {:msg "  545.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  545.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_871[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_871[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_871, Mask);
  assert {:msg "  548.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  548.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_871[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_871[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_871, Mask);
  assert {:msg "  550.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  550.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  550.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  550.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_871, Mask);
  } else {
  }
  assert {:msg "  551.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  551.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  551.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  551.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  551.50: Fraction might be negative."} 0 <= 50;
    assert {:msg "  551.50: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_871, Mask);
  } else {
  }
  assert {:msg "  553.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  553.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  553.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  553.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  553.50: Fraction might be negative."} 0 <= 50;
    assert {:msg "  553.50: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_871[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_871, Mask);
  } else {
  }
  assert {:msg "  556.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  556.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  556.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  556.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_871, Mask);
  } else {
  }
  assert {:msg "  557.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  557.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  557.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  557.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  557.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  557.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_871, Mask);
  } else {
  }
  assert {:msg "  559.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  559.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  559.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  559.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  559.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  559.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_871[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_871, Mask);
  } else {
  }
  assert {:msg "  562.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  562.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  562.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  562.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  562.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  562.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  562.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  562.47: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  562.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  562.65: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  562.65: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  562.65: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  563.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  563.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  563.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  563.31: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  563.31: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  563.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  563.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  563.47: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  563.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  563.65: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  563.65: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  563.65: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_872;
  assume IsGoodInhaleState(inhaleHeap#_872, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_872[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_872[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  assert {:msg "  566.29: Fraction might be negative."} 0 <= 50;
  assert {:msg "  566.29: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_872[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  assert {:msg "  568.29: Fraction might be negative."} 0 <= 50;
  assert {:msg "  568.29: Fraction might exceed 100."} 50 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_872[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_872[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_872, Mask);
  assert {:msg "  573.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  573.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.height);
  assert {:msg "  574.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  574.12: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  574.34: Receiver might be null."} true ==> (this != null);
    assert {:msg "  574.34: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  574.34: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  574.34: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  574.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  574.55: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  574.78: Receiver might be null."} true ==> (this != null);
    assert {:msg "  574.78: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  574.78: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  574.78: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  576.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  576.12: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    if (old(Heap)[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  576.34: Receiver might be null."} true ==> (this != null);
      assert {:msg "  576.34: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
      assert {:msg "  576.34: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
      assert {:msg "  576.34: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  578.12: Receiver might be null."} true ==> (this != null);
    assert {:msg "  578.12: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    if (old(Heap)[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  578.35: Receiver might be null."} true ==> (this != null);
      assert {:msg "  578.35: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
      assert {:msg "  578.35: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
      assert {:msg "  578.35: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  assume Heap[this, AVLTreeNode.height] == ite(ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]), ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  580.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  580.11: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  581.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  581.10: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  if (old(Heap)[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  581.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  581.32: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
    assert {:msg "  581.32: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
    assert {:msg "  581.32: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  581.53: Receiver might be null."} true ==> (this != null);
  assert {:msg "  581.53: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  if (old(Heap)[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  581.76: Receiver might be null."} true ==> (this != null);
    assert {:msg "  581.76: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
    assert {:msg "  581.76: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
    assert {:msg "  581.76: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume Heap[this, AVLTreeNode.balanceFactor] == (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.close(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_873: HeapType;
  var lh#60: int where true;
  var rh#62: int where true;
  var Heap#_877: HeapType;
  var Mask#_878: MaskType;
  var Credits#_879: CreditsType;
  var exhaleMask#_880: MaskType;
  var Heap#_884: HeapType;
  var Mask#_885: MaskType;
  var Credits#_886: CreditsType;
  var exhaleMask#_887: MaskType;
  var fraction#_888: int;
  var inhaleHeap#_889: HeapType;
  var Heap#_893: HeapType;
  var Mask#_894: MaskType;
  var Credits#_895: CreditsType;
  var exhaleMask#_896: MaskType;
  var Heap#_900: HeapType;
  var Mask#_901: MaskType;
  var Credits#_902: CreditsType;
  var exhaleMask#_903: MaskType;
  var fraction#_904: int;
  var inhaleHeap#_905: HeapType;
  var exhaleMask#_906: MaskType;
  var fraction#_907: int;
  var fraction#_908: int;
  var fraction#_909: int;
  var fraction#_910: int;
  var fraction#_911: int;
  var fraction#_912: int;
  var fraction#_913: int;
  var fraction#_914: int;
  var fraction#_915: int;
  var fraction#_916: int;
  var fraction#_917: int;
  var inhaleHeap#_918: HeapType;
  var exhaleMask#_919: MaskType;
  var fraction#_920: int;
  var fraction#_921: int;
  var fraction#_922: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_873;
  assume IsGoodInhaleState(inhaleHeap#_873, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_873[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_873[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_873, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_873[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_873[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_873, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_873[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_873[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_873, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_873[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_873[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_873, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_873[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_873[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_873, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_873, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_873, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_873[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_873, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_873, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_873, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_873[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_873, Mask);
  } else {
  }
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var lh
  // assigment to lh
  assert {:msg "  583.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  583.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  583.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  583.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  583.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  583.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  lh#60 := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  // local var rh
  // assigment to rh
  assert {:msg "  584.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  584.20: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  584.38: Receiver might be null."} true ==> (this != null);
    assert {:msg "  584.38: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  584.38: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  584.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  rh#62 := ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  // assert
  Heap#_877 := Heap;
  Mask#_878 := Mask;
  Credits#_879 := Credits;
  // begin exhale (assert)
  exhaleMask#_880 := Mask#_878;
  assert {:msg "  586.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  586.10: Location might not be readable."} true ==> CanRead(Mask#_878, this, AVLTreeNode.left);
  if (!(Heap#_877[this, AVLTreeNode.left] == null)) {
    // unfolding
    assert {:msg "  586.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  586.36: Location might not be readable."} true ==> CanRead(Mask#_878, this, AVLTreeNode.left);
    assert {:msg "  586.36: Receiver might be null."} true ==> (Heap#_877[this, AVLTreeNode.left] != null);
    Heap#_884 := Heap#_877;
    Mask#_885 := Mask#_878;
    Credits#_886 := Credits#_879;
    // begin exhale (unfolding)
    exhaleMask#_887 := Mask#_885;
    fraction#_888 := 100;
    assert {:msg "  586.26: Unfolding might fail. Insufficient fraction at 586.36 for AVLTreeNode.valid."} (fraction#_888 <= exhaleMask#_887[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_888 == exhaleMask#_887[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_887[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_887[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_887[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_887[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_888];
    assume IsGoodMask(Mask#_885);
    assume wf(Heap#_884, Mask#_885);
    assume wf(Heap#_884, exhaleMask#_887);
    Mask#_885 := exhaleMask#_887;
    assume wf(Heap#_884, Mask#_885);
    // end exhale
    // inhale (unfolding)
    inhaleHeap#_889 := Heap#_877[Heap#_877[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume IsGoodInhaleState(inhaleHeap#_889, Heap#_884, Mask#_885);
    assume Heap#_884[this, AVLTreeNode.left] != null;
    Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.key];
    assume wf(Heap#_884, Mask#_885);
    assume true;
    Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.key] := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
    assume IsGoodMask(Mask#_885);
    assume IsGoodState(inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume wf(Heap#_884, Mask#_885);
    assume wf(inhaleHeap#_889, Mask#_885);
    assume Heap#_884[this, AVLTreeNode.left] != null;
    Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap#_884, Mask#_885);
    assume true;
    Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height] := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_885);
    assume IsGoodState(inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap#_884, Mask#_885);
    assume wf(inhaleHeap#_889, Mask#_885);
    assume Heap#_884[this, AVLTreeNode.left] != null;
    Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left];
    assume wf(Heap#_884, Mask#_885);
    assume (Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
    assume IsGoodMask(Mask#_885);
    assume IsGoodState(inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left]);
    assume wf(Heap#_884, Mask#_885);
    assume wf(inhaleHeap#_889, Mask#_885);
    assume Heap#_884[this, AVLTreeNode.left] != null;
    Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right];
    assume wf(Heap#_884, Mask#_885);
    assume (Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
    assume IsGoodMask(Mask#_885);
    assume IsGoodState(inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right]);
    assume wf(Heap#_884, Mask#_885);
    assume wf(inhaleHeap#_889, Mask#_885);
    assume Heap#_884[this, AVLTreeNode.left] != null;
    Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap#_884, Mask#_885);
    assume true;
    Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_885[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_885);
    assume IsGoodState(inhaleHeap#_889[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_884, Mask#_885);
    assume wf(inhaleHeap#_889, Mask#_885);
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap#_884, Mask#_885);
      assume inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_884;
      Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_885);
      assume IsGoodState(inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap#_884, Mask#_885);
      assume wf(inhaleHeap#_889, Mask#_885);
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap#_884, Mask#_885);
      assume true;
      Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_885);
      assume IsGoodState(inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap#_884, Mask#_885);
      assume wf(inhaleHeap#_889, Mask#_885);
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor];
      assume wf(Heap#_884, Mask#_885);
      assume true;
      Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_885);
      assume IsGoodState(inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_884, Mask#_885);
      assume wf(inhaleHeap#_889, Mask#_885);
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap#_884, Mask#_885);
      assume inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_884;
      Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_885);
      assume IsGoodState(inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap#_884, Mask#_885);
      assume wf(inhaleHeap#_889, Mask#_885);
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap#_884, Mask#_885);
      assume true;
      Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_885);
      assume IsGoodState(inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap#_884, Mask#_885);
      assume wf(inhaleHeap#_889, Mask#_885);
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor];
      assume wf(Heap#_884, Mask#_885);
      assume true;
      Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_885[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_885);
      assume IsGoodState(inhaleHeap#_889[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_884, Mask#_885);
      assume wf(inhaleHeap#_889, Mask#_885);
    } else {
    }
    if (!(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    } else {
    }
    assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_884[Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap#_884[Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(Mask#_885);
    assume wf(Heap#_884, Mask#_885);
    // end inhale
    assert {:msg "  586.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  586.51: Location might not be readable."} true ==> CanRead(Mask#_885, this, AVLTreeNode.left);
    assert {:msg "  586.51: Receiver might be null."} true ==> (Heap#_884[this, AVLTreeNode.left] != null);
    assert {:msg "  586.51: Location might not be readable."} true ==> CanRead(Mask#_885, Heap#_884[this, AVLTreeNode.left], AVLTreeNode.height);
    assert {:msg "  586.3: Assertion might not hold. The expression at 586.26 might not evaluate to true."} Heap#_877[Heap#_877[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  Mask#_878 := exhaleMask#_880;
  assume wf(Heap#_877, Mask#_878);
  // end exhale
  // assert
  Heap#_893 := Heap;
  Mask#_894 := Mask;
  Credits#_895 := Credits;
  // begin exhale (assert)
  exhaleMask#_896 := Mask#_894;
  assert {:msg "  587.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  587.10: Location might not be readable."} true ==> CanRead(Mask#_894, this, AVLTreeNode.right);
  if (!(Heap#_893[this, AVLTreeNode.right] == null)) {
    // unfolding
    assert {:msg "  587.36: Receiver might be null."} true ==> (this != null);
    assert {:msg "  587.36: Location might not be readable."} true ==> CanRead(Mask#_894, this, AVLTreeNode.right);
    assert {:msg "  587.36: Receiver might be null."} true ==> (Heap#_893[this, AVLTreeNode.right] != null);
    Heap#_900 := Heap#_893;
    Mask#_901 := Mask#_894;
    Credits#_902 := Credits#_895;
    // begin exhale (unfolding)
    exhaleMask#_903 := Mask#_901;
    fraction#_904 := 100;
    assert {:msg "  587.26: Unfolding might fail. Insufficient fraction at 587.36 for AVLTreeNode.valid."} (fraction#_904 <= exhaleMask#_903[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_904 == exhaleMask#_903[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_903[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_903[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_903[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_903[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_904];
    assume IsGoodMask(Mask#_901);
    assume wf(Heap#_900, Mask#_901);
    assume wf(Heap#_900, exhaleMask#_903);
    Mask#_901 := exhaleMask#_903;
    assume wf(Heap#_900, Mask#_901);
    // end exhale
    // inhale (unfolding)
    inhaleHeap#_905 := Heap#_893[Heap#_893[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume IsGoodInhaleState(inhaleHeap#_905, Heap#_900, Mask#_901);
    assume Heap#_900[this, AVLTreeNode.right] != null;
    Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.key];
    assume wf(Heap#_900, Mask#_901);
    assume true;
    Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.key] := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
    assume IsGoodMask(Mask#_901);
    assume IsGoodState(inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume wf(Heap#_900, Mask#_901);
    assume wf(inhaleHeap#_905, Mask#_901);
    assume Heap#_900[this, AVLTreeNode.right] != null;
    Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap#_900, Mask#_901);
    assume true;
    Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height] := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_901);
    assume IsGoodState(inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap#_900, Mask#_901);
    assume wf(inhaleHeap#_905, Mask#_901);
    assume Heap#_900[this, AVLTreeNode.right] != null;
    Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left];
    assume wf(Heap#_900, Mask#_901);
    assume (Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
    assume IsGoodMask(Mask#_901);
    assume IsGoodState(inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left]);
    assume wf(Heap#_900, Mask#_901);
    assume wf(inhaleHeap#_905, Mask#_901);
    assume Heap#_900[this, AVLTreeNode.right] != null;
    Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right];
    assume wf(Heap#_900, Mask#_901);
    assume (Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
    assume IsGoodMask(Mask#_901);
    assume IsGoodState(inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right]);
    assume wf(Heap#_900, Mask#_901);
    assume wf(inhaleHeap#_905, Mask#_901);
    assume Heap#_900[this, AVLTreeNode.right] != null;
    Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap#_900, Mask#_901);
    assume true;
    Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_901[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_901);
    assume IsGoodState(inhaleHeap#_905[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_900, Mask#_901);
    assume wf(inhaleHeap#_905, Mask#_901);
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap#_900, Mask#_901);
      assume inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_900;
      Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_901);
      assume IsGoodState(inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap#_900, Mask#_901);
      assume wf(inhaleHeap#_905, Mask#_901);
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap#_900, Mask#_901);
      assume true;
      Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_901);
      assume IsGoodState(inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap#_900, Mask#_901);
      assume wf(inhaleHeap#_905, Mask#_901);
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor];
      assume wf(Heap#_900, Mask#_901);
      assume true;
      Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_901);
      assume IsGoodState(inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_900, Mask#_901);
      assume wf(inhaleHeap#_905, Mask#_901);
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap#_900, Mask#_901);
      assume inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_900;
      Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_901);
      assume IsGoodState(inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap#_900, Mask#_901);
      assume wf(inhaleHeap#_905, Mask#_901);
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap#_900, Mask#_901);
      assume true;
      Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_901);
      assume IsGoodState(inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap#_900, Mask#_901);
      assume wf(inhaleHeap#_905, Mask#_901);
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor];
      assume wf(Heap#_900, Mask#_901);
      assume true;
      Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_901[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_901);
      assume IsGoodState(inhaleHeap#_905[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_900, Mask#_901);
      assume wf(inhaleHeap#_905, Mask#_901);
    } else {
    }
    if (!(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    } else {
    }
    assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_900[Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap#_900[Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(Mask#_901);
    assume wf(Heap#_900, Mask#_901);
    // end inhale
    assert {:msg "  587.51: Receiver might be null."} true ==> (this != null);
    assert {:msg "  587.51: Location might not be readable."} true ==> CanRead(Mask#_901, this, AVLTreeNode.right);
    assert {:msg "  587.51: Receiver might be null."} true ==> (Heap#_900[this, AVLTreeNode.right] != null);
    assert {:msg "  587.51: Location might not be readable."} true ==> CanRead(Mask#_901, Heap#_900[this, AVLTreeNode.right], AVLTreeNode.height);
    assert {:msg "  587.3: Assertion might not hold. The expression at 587.26 might not evaluate to true."} Heap#_893[Heap#_893[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  Mask#_894 := exhaleMask#_896;
  assume wf(Heap#_893, Mask#_894);
  // end exhale
  // update field height
  assert {:msg "  588.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.height);
  assert {:msg "  588.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  588.18: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  588.35: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.35: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  588.35: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  588.35: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  588.51: Receiver might be null."} true ==> (this != null);
  assert {:msg "  588.51: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  588.69: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.69: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  588.69: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  588.69: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  if (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) {
    assert {:msg "  588.89: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.89: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    if (Heap[this, AVLTreeNode.left] == null) {
    } else {
      assert {:msg "  588.106: Receiver might be null."} true ==> (this != null);
      assert {:msg "  588.106: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
      assert {:msg "  588.106: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
      assert {:msg "  588.106: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
    }
  } else {
    assert {:msg "  588.126: Receiver might be null."} true ==> (this != null);
    assert {:msg "  588.126: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    if (Heap[this, AVLTreeNode.right] == null) {
    } else {
      assert {:msg "  588.144: Receiver might be null."} true ==> (this != null);
      assert {:msg "  588.144: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
      assert {:msg "  588.144: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
      assert {:msg "  588.144: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
    }
  }
  Heap[this, AVLTreeNode.height] := ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume wf(Heap, Mask);
  // update field balanceFactor
  assert {:msg "  590.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.balanceFactor);
  assert {:msg "  590.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  590.22: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  590.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  590.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  590.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  590.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  590.55: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  590.73: Receiver might be null."} true ==> (this != null);
    assert {:msg "  590.73: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  590.73: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  590.73: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  Heap[this, AVLTreeNode.balanceFactor] := ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  // fold
  assert {:msg "  593.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_906 := Mask;
  fraction#_907 := 100;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 117.6 for AVLTreeNode.key."} (fraction#_907 <= exhaleMask#_906[this, AVLTreeNode.key][perm$R]) && ((fraction#_907 == exhaleMask#_906[this, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_906[this, AVLTreeNode.key][perm$N]));
  exhaleMask#_906[this, AVLTreeNode.key] := exhaleMask#_906[this, AVLTreeNode.key][perm$R := exhaleMask#_906[this, AVLTreeNode.key][perm$R] - fraction#_907];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_906);
  fraction#_908 := 50;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 118.6 for AVLTreeNode.height."} (fraction#_908 <= exhaleMask#_906[this, AVLTreeNode.height][perm$R]) && ((fraction#_908 == exhaleMask#_906[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_906[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_906[this, AVLTreeNode.height] := exhaleMask#_906[this, AVLTreeNode.height][perm$R := exhaleMask#_906[this, AVLTreeNode.height][perm$R] - fraction#_908];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_906);
  fraction#_909 := 100;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 119.6 for AVLTreeNode.left."} (fraction#_909 <= exhaleMask#_906[this, AVLTreeNode.left][perm$R]) && ((fraction#_909 == exhaleMask#_906[this, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_906[this, AVLTreeNode.left][perm$N]));
  exhaleMask#_906[this, AVLTreeNode.left] := exhaleMask#_906[this, AVLTreeNode.left][perm$R := exhaleMask#_906[this, AVLTreeNode.left][perm$R] - fraction#_909];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_906);
  fraction#_910 := 100;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 120.6 for AVLTreeNode.right."} (fraction#_910 <= exhaleMask#_906[this, AVLTreeNode.right][perm$R]) && ((fraction#_910 == exhaleMask#_906[this, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_906[this, AVLTreeNode.right][perm$N]));
  exhaleMask#_906[this, AVLTreeNode.right] := exhaleMask#_906[this, AVLTreeNode.right][perm$R := exhaleMask#_906[this, AVLTreeNode.right][perm$R] - fraction#_910];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_906);
  fraction#_911 := 50;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 123.6 for AVLTreeNode.balanceFactor."} (fraction#_911 <= exhaleMask#_906[this, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_911 == exhaleMask#_906[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_906[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_906[this, AVLTreeNode.balanceFactor] := exhaleMask#_906[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_906[this, AVLTreeNode.balanceFactor][perm$R] - fraction#_911];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_906);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_912 := 100;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 125.22 for AVLTreeNode.valid."} (fraction#_912 <= exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_912 == exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_912];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_906);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_913 := 50;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 126.22 for AVLTreeNode.height."} (fraction#_913 <= exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_913 == exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_913];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_906);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    fraction#_914 := 50;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 128.22 for AVLTreeNode.balanceFactor."} (fraction#_914 <= exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_914 == exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_906[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_914];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_906);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 130.22 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_915 := 100;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 132.23 for AVLTreeNode.valid."} (fraction#_915 <= exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_915 == exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_915];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_906);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_916 := 50;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 133.23 for AVLTreeNode.height."} (fraction#_916 <= exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_916 == exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_916];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_906);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    fraction#_917 := 50;
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. Insufficient fraction at 135.23 for AVLTreeNode.balanceFactor."} (fraction#_917 <= exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_917 == exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_906[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_917];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_906);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 137.23 might not evaluate to true."} Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 146.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 147.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]));
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 148.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] <= 1;
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 149.6 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] >= (0 - 1);
  assert {:msg "  593.3: Fold might fail because the definition of AVLTreeNode.valid does not hold. The expression at 150.6 might not evaluate to true."} Heap[this, AVLTreeNode.height] > 0;
  Mask := exhaleMask#_906;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_918;
  assume IsGoodInhaleState(inhaleHeap#_918, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.valid] := inhaleHeap#_918[this, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_918[this, AVLTreeNode.valid] == Heap;
  Mask[this, AVLTreeNode.valid] := Mask[this, AVLTreeNode.valid][perm$R := Mask[this, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_918[this, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_918, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, AVLTreeNode.valid] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_919 := Mask;
  fraction#_920 := 100;
  assert {:msg "  541.2: The postcondition at 565.11 might not hold. Insufficient fraction at 565.11 for AVLTreeNode.valid."} (fraction#_920 <= exhaleMask#_919[this, AVLTreeNode.valid][perm$R]) && ((fraction#_920 == exhaleMask#_919[this, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_919[this, AVLTreeNode.valid][perm$N]));
  exhaleMask#_919[this, AVLTreeNode.valid] := exhaleMask#_919[this, AVLTreeNode.valid][perm$R := exhaleMask#_919[this, AVLTreeNode.valid][perm$R] - fraction#_920];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_919);
  fraction#_921 := 50;
  assert {:msg "  541.2: The postcondition at 566.11 might not hold. Insufficient fraction at 566.11 for AVLTreeNode.height."} (fraction#_921 <= exhaleMask#_919[this, AVLTreeNode.height][perm$R]) && ((fraction#_921 == exhaleMask#_919[this, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_919[this, AVLTreeNode.height][perm$N]));
  exhaleMask#_919[this, AVLTreeNode.height] := exhaleMask#_919[this, AVLTreeNode.height][perm$R := exhaleMask#_919[this, AVLTreeNode.height][perm$R] - fraction#_921];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_919);
  fraction#_922 := 50;
  assert {:msg "  541.2: The postcondition at 568.11 might not hold. Insufficient fraction at 568.11 for AVLTreeNode.balanceFactor."} (fraction#_922 <= exhaleMask#_919[this, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_922 == exhaleMask#_919[this, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_919[this, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_919[this, AVLTreeNode.balanceFactor] := exhaleMask#_919[this, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_919[this, AVLTreeNode.balanceFactor][perm$R] - fraction#_922];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_919);
  assert {:msg "  541.2: The postcondition at 573.11 might not hold. The expression at 573.11 might not evaluate to true."} Heap[this, AVLTreeNode.height] == ite(ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) > ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]), ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assert {:msg "  541.2: The postcondition at 580.11 might not hold. The expression at 580.11 might not evaluate to true."} Heap[this, AVLTreeNode.balanceFactor] == (ite(old(Heap)[this, AVLTreeNode.left] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) - ite(old(Heap)[this, AVLTreeNode.right] == null, 0, old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]));
  Mask := exhaleMask#_919;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  541.2: Method might lock/unlock more than allowed."} (forall lk#_923: ref :: {Heap[lk#_923, held]} {Heap[lk#_923, rdheld]} (((0 < Heap[lk#_923, held]) == (0 < old(Heap)[lk#_923, held])) && (Heap[lk#_923, rdheld] == old(Heap)[lk#_923, rdheld])) || false);
  assert {:msg "  541.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLeft$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_924: HeapType;
  var inhaleHeap#_925: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_924;
  assume IsGoodInhaleState(inhaleHeap#_924, Heap, Mask);
  assert {:msg "  598.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  598.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_924[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  599.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  599.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_924[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  600.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  600.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_924[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  601.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  601.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_924[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  604.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  604.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_924[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  606.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  606.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  607.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  607.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  608.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  608.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  608.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  608.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  610.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  610.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  610.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  610.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_924[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_924, Mask);
  assert {:msg "  613.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  613.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  613.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  613.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_924, Mask);
  } else {
  }
  assert {:msg "  614.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  614.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  614.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  614.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  614.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  614.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_924, Mask);
  } else {
  }
  assert {:msg "  616.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  616.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  616.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  616.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  616.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  616.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_924[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_924, Mask);
  } else {
  }
  assert {:msg "  619.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  619.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  619.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  619.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  619.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  619.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  619.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  619.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  619.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  619.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_925;
  assume IsGoodInhaleState(inhaleHeap#_925, Heap, Mask);
  assume r#63 != null;
  Heap[r#63, AVLTreeNode.valid] := inhaleHeap#_925[r#63, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_925[r#63, AVLTreeNode.valid] == Heap;
  Mask[r#63, AVLTreeNode.valid] := Mask[r#63, AVLTreeNode.valid][perm$R := Mask[r#63, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_925[r#63, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_925, Mask);
  assert {:msg "  622.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  622.31: Fraction might exceed 100."} 50 <= 100;
  assume r#63 != null;
  Heap[r#63, AVLTreeNode.height] := inhaleHeap#_925[r#63, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#63, AVLTreeNode.height] := Mask[r#63, AVLTreeNode.height][perm$R := Mask[r#63, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_925[r#63, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_925, Mask);
  assert {:msg "  624.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  624.31: Fraction might exceed 100."} 50 <= 100;
  assume r#63 != null;
  Heap[r#63, AVLTreeNode.balanceFactor] := inhaleHeap#_925[r#63, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#63, AVLTreeNode.balanceFactor] := Mask[r#63, AVLTreeNode.balanceFactor][perm$R := Mask[r#63, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_925[r#63, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_925, Mask);
  assert {:msg "  626.11: Receiver might be null."} true ==> (r#63 != null);
  assert {:msg "  626.11: Location might not be readable."} true ==> CanRead(Mask, r#63, AVLTreeNode.height);
  assert {:msg "  626.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  626.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  626.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  626.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  626.43: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (r#63 != null);
  assert {:msg "  626.43: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(Mask, r#63, AVLTreeNode.height);
  assert {:msg "  626.59: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  626.59: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  626.59: Receiver might be null."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  626.59: Location might not be readable."} true && (!(Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume (Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#63, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLeft(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#63: ref where (r#63 == null) || (dtype(r#63) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_926: HeapType;
  var lbf#65: int where true;
  var this#159: ref where (this#159 == null) || (dtype(this#159) == AVLTreeNode#t);
  var bf#160: int where true;
  var callHeap#_927: HeapType;
  var callMask#_928: MaskType;
  var callCredits#_929: CreditsType;
  var exhaleMask#_930: MaskType;
  var fraction#_931: int;
  var epsilons#_932: int;
  var isHeld#_933: int;
  var isRdHeld#_934: bool;
  var inhaleHeap#_935: HeapType;
  var Heap#_939: HeapType;
  var Mask#_940: MaskType;
  var Credits#_941: CreditsType;
  var exhaleMask#_942: MaskType;
  var Heap#_946: HeapType;
  var Mask#_947: MaskType;
  var Credits#_948: CreditsType;
  var exhaleMask#_949: MaskType;
  var fraction#_950: int;
  var inhaleHeap#_951: HeapType;
  var this#161: ref where (this#161 == null) || (dtype(this#161) == AVLTreeNode#t);
  var r#162: ref where (r#162 == null) || (dtype(r#162) == AVLTreeNode#t);
  var callHeap#_952: HeapType;
  var callMask#_953: MaskType;
  var callCredits#_954: CreditsType;
  var exhaleMask#_955: MaskType;
  var fraction#_956: int;
  var fraction#_957: int;
  var fraction#_958: int;
  var fraction#_959: int;
  var fraction#_960: int;
  var fraction#_961: int;
  var fraction#_962: int;
  var fraction#_963: int;
  var fraction#_964: int;
  var fraction#_965: int;
  var fraction#_966: int;
  var isHeld#_967: int;
  var isRdHeld#_968: bool;
  var inhaleHeap#_969: HeapType;
  var this#163: ref where (this#163 == null) || (dtype(this#163) == AVLTreeNode#t);
  var r#164: ref where (r#164 == null) || (dtype(r#164) == AVLTreeNode#t);
  var callHeap#_970: HeapType;
  var callMask#_971: MaskType;
  var callCredits#_972: CreditsType;
  var exhaleMask#_973: MaskType;
  var fraction#_974: int;
  var fraction#_975: int;
  var fraction#_976: int;
  var fraction#_977: int;
  var fraction#_978: int;
  var fraction#_979: int;
  var fraction#_980: int;
  var fraction#_981: int;
  var fraction#_982: int;
  var fraction#_983: int;
  var fraction#_984: int;
  var isHeld#_985: int;
  var isRdHeld#_986: bool;
  var inhaleHeap#_987: HeapType;
  var exhaleMask#_988: MaskType;
  var fraction#_989: int;
  var fraction#_990: int;
  var fraction#_991: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_926;
  assume IsGoodInhaleState(inhaleHeap#_926, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_926[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_926[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_926[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_926[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_926[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_926[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_926, Mask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_926, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_926, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_926[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_926, Mask);
  } else {
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var lbf
  // call getBalanceFactor
  callHeap#_927 := Heap;
  callMask#_928 := Mask;
  callCredits#_929 := Credits;
  assert {:msg "  630.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  630.15: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  630.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#159 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
	assert (Mask[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (Mask[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity);
  exhaleMask#_930 := Mask;
	assert (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity);
	
  fraction#_931 := 100;
  assert {:msg "  630.3: The precondition at 486.12 might not hold. Insufficient fraction at 486.12 for AVLTreeNode.valid."} (fraction#_931 <= exhaleMask#_930[this#159, AVLTreeNode.valid][perm$R]) && ((fraction#_931 == exhaleMask#_930[this#159, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_930[this#159, AVLTreeNode.valid][perm$N]));
  exhaleMask#_930[this#159, AVLTreeNode.valid] := exhaleMask#_930[this#159, AVLTreeNode.valid][perm$R := exhaleMask#_930[this#159, AVLTreeNode.valid][perm$R] - fraction#_931];
	assert (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_930);
  epsilons#_932 := 1;
  assert {:msg "  630.3: The precondition at 487.12 might not hold. Insufficient epsilons at 487.12  for AVLTreeNode.balanceFactor."} (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$R] == 0) ==> (epsilons#_932 <= exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N]);
	assert (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity);
  if ((exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_930[this#159, AVLTreeNode.balanceFactor] := exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N := exhaleMask#_930[this#159, AVLTreeNode.balanceFactor][perm$N] - epsilons#_932];
    assume wf(Heap, Mask);
  } else {
	assert false;
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_930);
  Mask := exhaleMask#_930;
  assume wf(Heap, Mask);
  // end exhale
  havoc bf#160;
  // inhale (postcondition)
  havoc inhaleHeap#_935;
  assume IsGoodInhaleState(inhaleHeap#_935, Heap, Mask);
  assume this#159 != null;
  Heap[this#159, AVLTreeNode.valid] := inhaleHeap#_935[this#159, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_935[this#159, AVLTreeNode.valid] == Heap;
  Mask[this#159, AVLTreeNode.valid] := Mask[this#159, AVLTreeNode.valid][perm$R := Mask[this#159, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_935[this#159, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_935, Mask);
  assume this#159 != null;
  Heap[this#159, AVLTreeNode.balanceFactor] := inhaleHeap#_935[this#159, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (Mask[this#159, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    Mask[this#159, AVLTreeNode.balanceFactor] := Mask[this#159, AVLTreeNode.balanceFactor][perm$N := Mask[this#159, AVLTreeNode.balanceFactor][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
	assert false;
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_935[this#159, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_935, Mask);
  assume bf#160 == Heap[this#159, AVLTreeNode.balanceFactor];
  assume (bf#160 > 0) ==> (!(Heap[this#159, AVLTreeNode.left] == null));
  assume (bf#160 < 0) ==> (!(Heap[this#159, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  lbf#65 := bf#160;
  // if
  if (lbf#65 < 0) {
    // assert
    Heap#_939 := Heap;
    Mask#_940 := Mask;
    Credits#_941 := Credits;
    // begin exhale (assert)
    exhaleMask#_942 := Mask#_940;
    // unfolding
    assert {:msg "  632.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  632.21: Location might not be readable."} true ==> CanRead(Mask#_940, this, AVLTreeNode.left);
    assert {:msg "  632.21: Receiver might be null."} true ==> (Heap#_939[this, AVLTreeNode.left] != null);
    Heap#_946 := Heap#_939;
    Mask#_947 := Mask#_940;
    Credits#_948 := Credits#_941;
    // begin exhale (unfolding)
    exhaleMask#_949 := Mask#_947;
    fraction#_950 := 100;
    assert {:msg "  632.11: Unfolding might fail. Insufficient fraction at 632.21 for AVLTreeNode.valid."} (fraction#_950 <= exhaleMask#_949[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_950 == exhaleMask#_949[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_949[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_949[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_949[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_949[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_950];
    assume IsGoodMask(Mask#_947);
    assume wf(Heap#_946, Mask#_947);
    assume wf(Heap#_946, exhaleMask#_949);
    Mask#_947 := exhaleMask#_949;
    assume wf(Heap#_946, Mask#_947);
    // end exhale
    // inhale (unfolding)
    inhaleHeap#_951 := Heap#_939[Heap#_939[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume IsGoodInhaleState(inhaleHeap#_951, Heap#_946, Mask#_947);
    assume Heap#_946[this, AVLTreeNode.left] != null;
    Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.key];
    assume wf(Heap#_946, Mask#_947);
    assume true;
    Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.key] := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
    assume IsGoodMask(Mask#_947);
    assume IsGoodState(inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.key]);
    assume wf(Heap#_946, Mask#_947);
    assume wf(inhaleHeap#_951, Mask#_947);
    assume Heap#_946[this, AVLTreeNode.left] != null;
    Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap#_946, Mask#_947);
    assume true;
    Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height] := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_947);
    assume IsGoodState(inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap#_946, Mask#_947);
    assume wf(inhaleHeap#_951, Mask#_947);
    assume Heap#_946[this, AVLTreeNode.left] != null;
    Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left];
    assume wf(Heap#_946, Mask#_947);
    assume (Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
    Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
    assume IsGoodMask(Mask#_947);
    assume IsGoodState(inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left]);
    assume wf(Heap#_946, Mask#_947);
    assume wf(inhaleHeap#_951, Mask#_947);
    assume Heap#_946[this, AVLTreeNode.left] != null;
    Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right];
    assume wf(Heap#_946, Mask#_947);
    assume (Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
    Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
    assume IsGoodMask(Mask#_947);
    assume IsGoodState(inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right]);
    assume wf(Heap#_946, Mask#_947);
    assume wf(inhaleHeap#_951, Mask#_947);
    assume Heap#_946[this, AVLTreeNode.left] != null;
    Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap#_946, Mask#_947);
    assume true;
    Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_947[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_947);
    assume IsGoodState(inhaleHeap#_951[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_946, Mask#_947);
    assume wf(inhaleHeap#_951, Mask#_947);
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap#_946, Mask#_947);
      assume inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_946;
      Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_947);
      assume IsGoodState(inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap#_946, Mask#_947);
      assume wf(inhaleHeap#_951, Mask#_947);
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap#_946, Mask#_947);
      assume true;
      Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_947);
      assume IsGoodState(inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap#_946, Mask#_947);
      assume wf(inhaleHeap#_951, Mask#_947);
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] != null;
      Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor];
      assume wf(Heap#_946, Mask#_947);
      assume true;
      Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_947);
      assume IsGoodState(inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_946, Mask#_947);
      assume wf(inhaleHeap#_951, Mask#_947);
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
      assume Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap#_946, Mask#_947);
      assume inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_946;
      Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_947);
      assume IsGoodState(inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap#_946, Mask#_947);
      assume wf(inhaleHeap#_951, Mask#_947);
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap#_946, Mask#_947);
      assume true;
      Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_947);
      assume IsGoodState(inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap#_946, Mask#_947);
      assume wf(inhaleHeap#_951, Mask#_947);
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] != null;
      Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor];
      assume wf(Heap#_946, Mask#_947);
      assume true;
      Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_947[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_947);
      assume IsGoodState(inhaleHeap#_951[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_946, Mask#_947);
      assume wf(inhaleHeap#_951, Mask#_947);
    } else {
    }
    if (!(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
      assume Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
    } else {
    }
    assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap#_946[Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
    assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap#_946[Heap#_946[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
    assume IsGoodMask(Mask#_947);
    assume wf(Heap#_946, Mask#_947);
    // end inhale
    assert {:msg "  632.4: Assertion might not hold. The expression at 632.11 might not evaluate to true."} lbf#65 == (0 - 1);
    Mask#_940 := exhaleMask#_942;
    assume wf(Heap#_939, Mask#_940);
    // end exhale
    // call rebalanceRL
    callHeap#_952 := Heap;
    callMask#_953 := Mask;
    callCredits#_954 := Credits;
    assert {:msg "  633.4: The target of the method call might be null."} this != null;
    this#161 := this;
    // begin exhale (precondition)
    exhaleMask#_955 := Mask;
    fraction#_956 := 100;
    assert {:msg "  633.4: The precondition at 641.12 might not hold. Insufficient fraction at 641.12 for AVLTreeNode.key."} (fraction#_956 <= exhaleMask#_955[this#161, AVLTreeNode.key][perm$R]) && ((fraction#_956 == exhaleMask#_955[this#161, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_955[this#161, AVLTreeNode.key][perm$N]));
    exhaleMask#_955[this#161, AVLTreeNode.key] := exhaleMask#_955[this#161, AVLTreeNode.key][perm$R := exhaleMask#_955[this#161, AVLTreeNode.key][perm$R] - fraction#_956];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    fraction#_957 := 100;
    assert {:msg "  633.4: The precondition at 642.12 might not hold. Insufficient fraction at 642.12 for AVLTreeNode.height."} (fraction#_957 <= exhaleMask#_955[this#161, AVLTreeNode.height][perm$R]) && ((fraction#_957 == exhaleMask#_955[this#161, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_955[this#161, AVLTreeNode.height][perm$N]));
    exhaleMask#_955[this#161, AVLTreeNode.height] := exhaleMask#_955[this#161, AVLTreeNode.height][perm$R := exhaleMask#_955[this#161, AVLTreeNode.height][perm$R] - fraction#_957];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    fraction#_958 := 100;
    assert {:msg "  633.4: The precondition at 643.12 might not hold. Insufficient fraction at 643.12 for AVLTreeNode.left."} (fraction#_958 <= exhaleMask#_955[this#161, AVLTreeNode.left][perm$R]) && ((fraction#_958 == exhaleMask#_955[this#161, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_955[this#161, AVLTreeNode.left][perm$N]));
    exhaleMask#_955[this#161, AVLTreeNode.left] := exhaleMask#_955[this#161, AVLTreeNode.left][perm$R := exhaleMask#_955[this#161, AVLTreeNode.left][perm$R] - fraction#_958];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    fraction#_959 := 100;
    assert {:msg "  633.4: The precondition at 644.12 might not hold. Insufficient fraction at 644.12 for AVLTreeNode.right."} (fraction#_959 <= exhaleMask#_955[this#161, AVLTreeNode.right][perm$R]) && ((fraction#_959 == exhaleMask#_955[this#161, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_955[this#161, AVLTreeNode.right][perm$N]));
    exhaleMask#_955[this#161, AVLTreeNode.right] := exhaleMask#_955[this#161, AVLTreeNode.right][perm$R := exhaleMask#_955[this#161, AVLTreeNode.right][perm$R] - fraction#_959];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    fraction#_960 := 100;
    assert {:msg "  633.4: The precondition at 647.12 might not hold. Insufficient fraction at 647.12 for AVLTreeNode.balanceFactor."} (fraction#_960 <= exhaleMask#_955[this#161, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_960 == exhaleMask#_955[this#161, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_955[this#161, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_955[this#161, AVLTreeNode.balanceFactor] := exhaleMask#_955[this#161, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_955[this#161, AVLTreeNode.balanceFactor][perm$R] - fraction#_960];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    assert {:msg "  633.4: The precondition at 649.12 might not hold. The expression at 649.12 might not evaluate to true."} !(Heap[this#161, AVLTreeNode.left] == null);
    fraction#_961 := 100;
    assert {:msg "  633.4: The precondition at 650.12 might not hold. Insufficient fraction at 650.12 for AVLTreeNode.valid."} (fraction#_961 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_961 == exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_961];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    fraction#_962 := 50;
    assert {:msg "  633.4: The precondition at 651.12 might not hold. Insufficient fraction at 651.12 for AVLTreeNode.height."} (fraction#_962 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_962 == exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_962];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    fraction#_963 := 50;
    assert {:msg "  633.4: The precondition at 653.12 might not hold. Insufficient fraction at 653.12 for AVLTreeNode.balanceFactor."} (fraction#_963 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_963 == exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_955[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_963];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_955);
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      fraction#_964 := 100;
      assert {:msg "  633.4: The precondition at 656.12 might not hold. Insufficient fraction at 656.28 for AVLTreeNode.valid."} (fraction#_964 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_964 == exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_964];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_955);
    } else {
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      fraction#_965 := 50;
      assert {:msg "  633.4: The precondition at 657.12 might not hold. Insufficient fraction at 657.28 for AVLTreeNode.height."} (fraction#_965 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_965 == exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_965];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_955);
    } else {
    }
    if (!(Heap[this#161, AVLTreeNode.right] == null)) {
      fraction#_966 := 50;
      assert {:msg "  633.4: The precondition at 659.12 might not hold. Insufficient fraction at 659.28 for AVLTreeNode.balanceFactor."} (fraction#_966 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_966 == exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_955[Heap[this#161, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_966];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_955);
    } else {
    }
    assert {:msg "  633.4: The precondition at 664.12 might not hold. The expression at 664.12 might not evaluate to true."} (Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#161, AVLTreeNode.right] == null, 0, Heap[Heap[this#161, AVLTreeNode.right], AVLTreeNode.height])) == 2;
    assert {:msg "  633.4: The precondition at 665.12 might not hold. The expression at 665.12 might not evaluate to true."} Heap[Heap[this#161, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
    Mask := exhaleMask#_955;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#162;
    // inhale (postcondition)
    havoc inhaleHeap#_969;
    assume IsGoodInhaleState(inhaleHeap#_969, Heap, Mask);
    assume r#162 != null;
    Heap[r#162, AVLTreeNode.valid] := inhaleHeap#_969[r#162, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_969[r#162, AVLTreeNode.valid] == Heap;
    Mask[r#162, AVLTreeNode.valid] := Mask[r#162, AVLTreeNode.valid][perm$R := Mask[r#162, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_969[r#162, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_969, Mask);
    assume r#162 != null;
    Heap[r#162, AVLTreeNode.height] := inhaleHeap#_969[r#162, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#162, AVLTreeNode.height] := Mask[r#162, AVLTreeNode.height][perm$R := Mask[r#162, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_969[r#162, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_969, Mask);
    assume r#162 != null;
    Heap[r#162, AVLTreeNode.balanceFactor] := inhaleHeap#_969[r#162, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#162, AVLTreeNode.balanceFactor] := Mask[r#162, AVLTreeNode.balanceFactor][perm$R := Mask[r#162, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_969[r#162, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_969, Mask);
    assume Heap[r#162, AVLTreeNode.height] == callHeap#_952[callHeap#_952[this#161, AVLTreeNode.left], AVLTreeNode.height];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#63 := r#162;
  } else {
    // call rebalanceRR
    callHeap#_970 := Heap;
    callMask#_971 := Mask;
    callCredits#_972 := Credits;
    assert {:msg "  635.4: The target of the method call might be null."} this != null;
    this#163 := this;
    // begin exhale (precondition)
    exhaleMask#_973 := Mask;
    fraction#_974 := 100;
    assert {:msg "  635.4: The precondition at 698.12 might not hold. Insufficient fraction at 698.12 for AVLTreeNode.key."} (fraction#_974 <= exhaleMask#_973[this#163, AVLTreeNode.key][perm$R]) && ((fraction#_974 == exhaleMask#_973[this#163, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_973[this#163, AVLTreeNode.key][perm$N]));
    exhaleMask#_973[this#163, AVLTreeNode.key] := exhaleMask#_973[this#163, AVLTreeNode.key][perm$R := exhaleMask#_973[this#163, AVLTreeNode.key][perm$R] - fraction#_974];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    fraction#_975 := 100;
    assert {:msg "  635.4: The precondition at 699.12 might not hold. Insufficient fraction at 699.12 for AVLTreeNode.height."} (fraction#_975 <= exhaleMask#_973[this#163, AVLTreeNode.height][perm$R]) && ((fraction#_975 == exhaleMask#_973[this#163, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_973[this#163, AVLTreeNode.height][perm$N]));
    exhaleMask#_973[this#163, AVLTreeNode.height] := exhaleMask#_973[this#163, AVLTreeNode.height][perm$R := exhaleMask#_973[this#163, AVLTreeNode.height][perm$R] - fraction#_975];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    fraction#_976 := 100;
    assert {:msg "  635.4: The precondition at 700.12 might not hold. Insufficient fraction at 700.12 for AVLTreeNode.left."} (fraction#_976 <= exhaleMask#_973[this#163, AVLTreeNode.left][perm$R]) && ((fraction#_976 == exhaleMask#_973[this#163, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_973[this#163, AVLTreeNode.left][perm$N]));
    exhaleMask#_973[this#163, AVLTreeNode.left] := exhaleMask#_973[this#163, AVLTreeNode.left][perm$R := exhaleMask#_973[this#163, AVLTreeNode.left][perm$R] - fraction#_976];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    fraction#_977 := 100;
    assert {:msg "  635.4: The precondition at 701.12 might not hold. Insufficient fraction at 701.12 for AVLTreeNode.right."} (fraction#_977 <= exhaleMask#_973[this#163, AVLTreeNode.right][perm$R]) && ((fraction#_977 == exhaleMask#_973[this#163, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_973[this#163, AVLTreeNode.right][perm$N]));
    exhaleMask#_973[this#163, AVLTreeNode.right] := exhaleMask#_973[this#163, AVLTreeNode.right][perm$R := exhaleMask#_973[this#163, AVLTreeNode.right][perm$R] - fraction#_977];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    fraction#_978 := 100;
    assert {:msg "  635.4: The precondition at 704.12 might not hold. Insufficient fraction at 704.12 for AVLTreeNode.balanceFactor."} (fraction#_978 <= exhaleMask#_973[this#163, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_978 == exhaleMask#_973[this#163, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_973[this#163, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_973[this#163, AVLTreeNode.balanceFactor] := exhaleMask#_973[this#163, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_973[this#163, AVLTreeNode.balanceFactor][perm$R] - fraction#_978];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    assert {:msg "  635.4: The precondition at 706.12 might not hold. The expression at 706.12 might not evaluate to true."} !(Heap[this#163, AVLTreeNode.left] == null);
    fraction#_979 := 100;
    assert {:msg "  635.4: The precondition at 707.12 might not hold. Insufficient fraction at 707.12 for AVLTreeNode.valid."} (fraction#_979 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_979 == exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_979];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    fraction#_980 := 50;
    assert {:msg "  635.4: The precondition at 708.12 might not hold. Insufficient fraction at 708.12 for AVLTreeNode.height."} (fraction#_980 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_980 == exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_980];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    fraction#_981 := 50;
    assert {:msg "  635.4: The precondition at 710.12 might not hold. Insufficient fraction at 710.12 for AVLTreeNode.balanceFactor."} (fraction#_981 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_981 == exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_973[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_981];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_973);
    if (!(Heap[this#163, AVLTreeNode.right] == null)) {
      fraction#_982 := 100;
      assert {:msg "  635.4: The precondition at 713.12 might not hold. Insufficient fraction at 713.28 for AVLTreeNode.valid."} (fraction#_982 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_982 == exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
      exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_982];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_973);
    } else {
    }
    if (!(Heap[this#163, AVLTreeNode.right] == null)) {
      fraction#_983 := 50;
      assert {:msg "  635.4: The precondition at 714.12 might not hold. Insufficient fraction at 714.28 for AVLTreeNode.height."} (fraction#_983 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_983 == exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
      exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_983];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_973);
    } else {
    }
    if (!(Heap[this#163, AVLTreeNode.right] == null)) {
      fraction#_984 := 50;
      assert {:msg "  635.4: The precondition at 716.12 might not hold. Insufficient fraction at 716.28 for AVLTreeNode.balanceFactor."} (fraction#_984 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_984 == exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_973[Heap[this#163, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_984];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_973);
    } else {
    }
    assert {:msg "  635.4: The precondition at 719.12 might not hold. The expression at 719.12 might not evaluate to true."} (Heap[Heap[this#163, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this#163, AVLTreeNode.right] == null, 0, Heap[Heap[this#163, AVLTreeNode.right], AVLTreeNode.height])) == 2;
    assert {:msg "  635.4: The precondition at 720.12 might not hold. The expression at 720.12 might not evaluate to true."} Heap[Heap[this#163, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
    Mask := exhaleMask#_973;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#164;
    // inhale (postcondition)
    havoc inhaleHeap#_987;
    assume IsGoodInhaleState(inhaleHeap#_987, Heap, Mask);
    assume r#164 != null;
    Heap[r#164, AVLTreeNode.valid] := inhaleHeap#_987[r#164, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_987[r#164, AVLTreeNode.valid] == Heap;
    Mask[r#164, AVLTreeNode.valid] := Mask[r#164, AVLTreeNode.valid][perm$R := Mask[r#164, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_987[r#164, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_987, Mask);
    assume r#164 != null;
    Heap[r#164, AVLTreeNode.height] := inhaleHeap#_987[r#164, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#164, AVLTreeNode.height] := Mask[r#164, AVLTreeNode.height][perm$R := Mask[r#164, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_987[r#164, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_987, Mask);
    assume r#164 != null;
    Heap[r#164, AVLTreeNode.balanceFactor] := inhaleHeap#_987[r#164, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#164, AVLTreeNode.balanceFactor] := Mask[r#164, AVLTreeNode.balanceFactor][perm$R := Mask[r#164, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_987[r#164, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_987, Mask);
    assume (Heap[r#164, AVLTreeNode.height] == callHeap#_970[callHeap#_970[this#163, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#164, AVLTreeNode.height] == (callHeap#_970[callHeap#_970[this#163, AVLTreeNode.left], AVLTreeNode.height] + 1));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#63 := r#164;
  }
  // begin exhale (postcondition)
  exhaleMask#_988 := Mask;
  fraction#_989 := 100;
  assert {:msg "  597.2: The postcondition at 621.11 might not hold. Insufficient fraction at 621.11 for AVLTreeNode.valid."} (fraction#_989 <= exhaleMask#_988[r#63, AVLTreeNode.valid][perm$R]) && ((fraction#_989 == exhaleMask#_988[r#63, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_988[r#63, AVLTreeNode.valid][perm$N]));
  exhaleMask#_988[r#63, AVLTreeNode.valid] := exhaleMask#_988[r#63, AVLTreeNode.valid][perm$R := exhaleMask#_988[r#63, AVLTreeNode.valid][perm$R] - fraction#_989];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_988);
  fraction#_990 := 50;
  assert {:msg "  597.2: The postcondition at 622.11 might not hold. Insufficient fraction at 622.11 for AVLTreeNode.height."} (fraction#_990 <= exhaleMask#_988[r#63, AVLTreeNode.height][perm$R]) && ((fraction#_990 == exhaleMask#_988[r#63, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_988[r#63, AVLTreeNode.height][perm$N]));
  exhaleMask#_988[r#63, AVLTreeNode.height] := exhaleMask#_988[r#63, AVLTreeNode.height][perm$R := exhaleMask#_988[r#63, AVLTreeNode.height][perm$R] - fraction#_990];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_988);
  fraction#_991 := 50;
  assert {:msg "  597.2: The postcondition at 624.11 might not hold. Insufficient fraction at 624.11 for AVLTreeNode.balanceFactor."} (fraction#_991 <= exhaleMask#_988[r#63, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_991 == exhaleMask#_988[r#63, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_988[r#63, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_988[r#63, AVLTreeNode.balanceFactor] := exhaleMask#_988[r#63, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_988[r#63, AVLTreeNode.balanceFactor][perm$R] - fraction#_991];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_988);
  assert {:msg "  597.2: The postcondition at 626.11 might not hold. The expression at 626.11 might not evaluate to true."} (Heap[r#63, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#63, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  Mask := exhaleMask#_988;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  597.2: Method might lock/unlock more than allowed."} (forall lk#_992: ref :: {Heap[lk#_992, held]} {Heap[lk#_992, rdheld]} (((0 < Heap[lk#_992, held]) == (0 < old(Heap)[lk#_992, held])) && (Heap[lk#_992, rdheld] == old(Heap)[lk#_992, rdheld])) || false);
  assert {:msg "  597.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_993: HeapType;
  var inhaleHeap#_994: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_993;
  assume IsGoodInhaleState(inhaleHeap#_993, Heap, Mask);
  assert {:msg "  641.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  641.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_993[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  642.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  642.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_993[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  643.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  643.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_993[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  644.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  644.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_993[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  647.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  647.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_993[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  649.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  649.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  650.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  650.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  651.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  651.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  651.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  651.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  653.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  653.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  653.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  653.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  656.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  656.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  656.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  656.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_993, Mask);
  } else {
  }
  assert {:msg "  657.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  657.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  657.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  657.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  657.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  657.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_993, Mask);
  } else {
  }
  assert {:msg "  659.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  659.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  659.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  659.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  659.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  659.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_993[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_993, Mask);
  } else {
  }
  assert {:msg "  664.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  664.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  664.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  664.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  664.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  664.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  664.39: Receiver might be null."} true ==> (this != null);
    assert {:msg "  664.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  664.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  664.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assert {:msg "  665.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  665.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  665.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  665.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_994;
  assume IsGoodInhaleState(inhaleHeap#_994, Heap, Mask);
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.valid] := inhaleHeap#_994[r#66, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_994[r#66, AVLTreeNode.valid] == Heap;
  Mask[r#66, AVLTreeNode.valid] := Mask[r#66, AVLTreeNode.valid][perm$R := Mask[r#66, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_994[r#66, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_994, Mask);
  assert {:msg "  668.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  668.31: Fraction might exceed 100."} 50 <= 100;
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.height] := inhaleHeap#_994[r#66, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#66, AVLTreeNode.height] := Mask[r#66, AVLTreeNode.height][perm$R := Mask[r#66, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_994[r#66, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_994, Mask);
  assert {:msg "  670.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  670.31: Fraction might exceed 100."} 50 <= 100;
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.balanceFactor] := inhaleHeap#_994[r#66, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#66, AVLTreeNode.balanceFactor] := Mask[r#66, AVLTreeNode.balanceFactor][perm$R := Mask[r#66, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_994[r#66, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_994, Mask);
  assert {:msg "  672.11: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  672.11: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.height);
  assert {:msg "  672.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  672.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  672.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  672.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume Heap[r#66, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#66: ref where (r#66 == null) || (dtype(r#66) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_995: HeapType;
  var exhaleMask#_996: MaskType;
  var fraction#_997: int;
  var inhaleHeap#_998: HeapType;
  var exhaleMask#_999: MaskType;
  var fraction#_1000: int;
  var inhaleHeap#_1001: HeapType;
  var this#165: ref where (this#165 == null) || (dtype(this#165) == AVLTreeNode#t);
  var callHeap#_1002: HeapType;
  var callMask#_1003: MaskType;
  var callCredits#_1004: CreditsType;
  var exhaleMask#_1005: MaskType;
  var fraction#_1006: int;
  var fraction#_1007: int;
  var fraction#_1008: int;
  var fraction#_1009: int;
  var fraction#_1010: int;
  var fraction#_1011: int;
  var fraction#_1012: int;
  var fraction#_1013: int;
  var fraction#_1014: int;
  var fraction#_1015: int;
  var fraction#_1016: int;
  var isHeld#_1017: int;
  var isRdHeld#_1018: bool;
  var inhaleHeap#_1019: HeapType;
  var this#166: ref where (this#166 == null) || (dtype(this#166) == AVLTreeNode#t);
  var callHeap#_1020: HeapType;
  var callMask#_1021: MaskType;
  var callCredits#_1022: CreditsType;
  var exhaleMask#_1023: MaskType;
  var fraction#_1024: int;
  var fraction#_1025: int;
  var fraction#_1026: int;
  var fraction#_1027: int;
  var fraction#_1028: int;
  var fraction#_1029: int;
  var fraction#_1030: int;
  var fraction#_1031: int;
  var fraction#_1032: int;
  var fraction#_1033: int;
  var fraction#_1034: int;
  var isHeld#_1035: int;
  var isRdHeld#_1036: bool;
  var inhaleHeap#_1037: HeapType;
  var this#167: ref where (this#167 == null) || (dtype(this#167) == AVLTreeNode#t);
  var callHeap#_1038: HeapType;
  var callMask#_1039: MaskType;
  var callCredits#_1040: CreditsType;
  var exhaleMask#_1041: MaskType;
  var fraction#_1042: int;
  var fraction#_1043: int;
  var fraction#_1044: int;
  var fraction#_1045: int;
  var fraction#_1046: int;
  var fraction#_1047: int;
  var fraction#_1048: int;
  var fraction#_1049: int;
  var fraction#_1050: int;
  var fraction#_1051: int;
  var fraction#_1052: int;
  var isHeld#_1053: int;
  var isRdHeld#_1054: bool;
  var inhaleHeap#_1055: HeapType;
  var exhaleMask#_1056: MaskType;
  var fraction#_1057: int;
  var fraction#_1058: int;
  var fraction#_1059: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_995;
  assume IsGoodInhaleState(inhaleHeap#_995, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_995[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_995[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_995[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_995[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_995[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_995[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_995, Mask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_995, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_995, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_995[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_995, Mask);
  } else {
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (0 - 1);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  676.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  676.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  676.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  exhaleMask#_996 := Mask;
  fraction#_997 := 100;
  assert {:msg "  676.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_997 <= exhaleMask#_996[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_997 == exhaleMask#_996[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_996[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  exhaleMask#_996[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_996[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_996[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_997];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_996);
  Mask := exhaleMask#_996;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_998 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_998, Heap, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_998, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_998, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_998, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_998, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_998[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_998, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_998, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_998, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_998, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_998, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_998, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_998[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_998, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  677.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  677.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  677.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  677.8: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  r#66 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  // unfold
  assert {:msg "  679.3: The target of the fold statement might be null."} r#66 != null;
  // begin exhale (unfold)
  exhaleMask#_999 := Mask;
  fraction#_1000 := 100;
  assert {:msg "  679.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1000 <= exhaleMask#_999[r#66, AVLTreeNode.valid][perm$R]) && ((fraction#_1000 == exhaleMask#_999[r#66, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_999[r#66, AVLTreeNode.valid][perm$N]));
  exhaleMask#_999[r#66, AVLTreeNode.valid] := exhaleMask#_999[r#66, AVLTreeNode.valid][perm$R := exhaleMask#_999[r#66, AVLTreeNode.valid][perm$R] - fraction#_1000];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_999);
  Mask := exhaleMask#_999;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1001 := Heap[r#66, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1001, Heap, Mask);
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.key] := inhaleHeap#_1001[r#66, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#66, AVLTreeNode.key] := Mask[r#66, AVLTreeNode.key][perm$R := Mask[r#66, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1001[r#66, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1001, Mask);
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.height] := inhaleHeap#_1001[r#66, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#66, AVLTreeNode.height] := Mask[r#66, AVLTreeNode.height][perm$R := Mask[r#66, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1001[r#66, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1001, Mask);
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.left] := inhaleHeap#_1001[r#66, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[r#66, AVLTreeNode.left] == null) || (dtype(Heap[r#66, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[r#66, AVLTreeNode.left] := Mask[r#66, AVLTreeNode.left][perm$R := Mask[r#66, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1001[r#66, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1001, Mask);
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.right] := inhaleHeap#_1001[r#66, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[r#66, AVLTreeNode.right] == null) || (dtype(Heap[r#66, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[r#66, AVLTreeNode.right] := Mask[r#66, AVLTreeNode.right][perm$R := Mask[r#66, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1001[r#66, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1001, Mask);
  assume r#66 != null;
  Heap[r#66, AVLTreeNode.balanceFactor] := inhaleHeap#_1001[r#66, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#66, AVLTreeNode.balanceFactor] := Mask[r#66, AVLTreeNode.balanceFactor][perm$R := Mask[r#66, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1001[r#66, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1001, Mask);
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[r#66, AVLTreeNode.left] != null;
    Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[Heap[r#66, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.left] == null)) {
    assume Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[r#66, AVLTreeNode.right] != null;
    Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1001[Heap[r#66, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1001, Mask);
  } else {
  }
  if (!(Heap[r#66, AVLTreeNode.right] == null)) {
    assume Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[r#66, AVLTreeNode.height] == ite(ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[r#66, AVLTreeNode.balanceFactor] == (ite(Heap[r#66, AVLTreeNode.left] == null, 0, Heap[Heap[r#66, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#66, AVLTreeNode.right] == null, 0, Heap[Heap[r#66, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[r#66, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[r#66, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[r#66, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  683.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  683.3: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  683.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.right);
  assert {:msg "  683.17: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  683.17: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.left);
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Heap[r#66, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1002 := Heap;
  callMask#_1003 := Mask;
  callCredits#_1004 := Credits;
  assert {:msg "  684.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  684.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  684.3: The target of the method call might be null."} Heap[this, AVLTreeNode.left] != null;
  this#165 := Heap[this, AVLTreeNode.left];
  // begin exhale (precondition)
  exhaleMask#_1005 := Mask;
  fraction#_1006 := 100;
  assert {:msg "  684.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1006 <= exhaleMask#_1005[this#165, AVLTreeNode.key][perm$R]) && ((fraction#_1006 == exhaleMask#_1005[this#165, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1005[this#165, AVLTreeNode.key][perm$N]));
  exhaleMask#_1005[this#165, AVLTreeNode.key] := exhaleMask#_1005[this#165, AVLTreeNode.key][perm$R := exhaleMask#_1005[this#165, AVLTreeNode.key][perm$R] - fraction#_1006];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1005);
  fraction#_1007 := 100;
  assert {:msg "  684.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1007 <= exhaleMask#_1005[this#165, AVLTreeNode.height][perm$R]) && ((fraction#_1007 == exhaleMask#_1005[this#165, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1005[this#165, AVLTreeNode.height][perm$N]));
  exhaleMask#_1005[this#165, AVLTreeNode.height] := exhaleMask#_1005[this#165, AVLTreeNode.height][perm$R := exhaleMask#_1005[this#165, AVLTreeNode.height][perm$R] - fraction#_1007];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1005);
  fraction#_1008 := 100;
  assert {:msg "  684.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1008 <= exhaleMask#_1005[this#165, AVLTreeNode.left][perm$R]) && ((fraction#_1008 == exhaleMask#_1005[this#165, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1005[this#165, AVLTreeNode.left][perm$N]));
  exhaleMask#_1005[this#165, AVLTreeNode.left] := exhaleMask#_1005[this#165, AVLTreeNode.left][perm$R := exhaleMask#_1005[this#165, AVLTreeNode.left][perm$R] - fraction#_1008];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1005);
  fraction#_1009 := 100;
  assert {:msg "  684.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1009 <= exhaleMask#_1005[this#165, AVLTreeNode.right][perm$R]) && ((fraction#_1009 == exhaleMask#_1005[this#165, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1005[this#165, AVLTreeNode.right][perm$N]));
  exhaleMask#_1005[this#165, AVLTreeNode.right] := exhaleMask#_1005[this#165, AVLTreeNode.right][perm$R := exhaleMask#_1005[this#165, AVLTreeNode.right][perm$R] - fraction#_1009];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1005);
  fraction#_1010 := 100;
  assert {:msg "  684.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1010 <= exhaleMask#_1005[this#165, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1010 == exhaleMask#_1005[this#165, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1005[this#165, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1005[this#165, AVLTreeNode.balanceFactor] := exhaleMask#_1005[this#165, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1005[this#165, AVLTreeNode.balanceFactor][perm$R] - fraction#_1010];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1005);
  if (!(Heap[this#165, AVLTreeNode.left] == null)) {
    fraction#_1011 := 100;
    assert {:msg "  684.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1011 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1011 == exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1011];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
  } else {
  }
  if (!(Heap[this#165, AVLTreeNode.left] == null)) {
    fraction#_1012 := 50;
    assert {:msg "  684.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1012 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1012 == exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1012];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
  } else {
  }
  if (!(Heap[this#165, AVLTreeNode.left] == null)) {
    fraction#_1013 := 50;
    assert {:msg "  684.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1013 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1013 == exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1005[Heap[this#165, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1013];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
  } else {
  }
  if (!(Heap[this#165, AVLTreeNode.right] == null)) {
    fraction#_1014 := 100;
    assert {:msg "  684.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1014 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1014 == exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1014];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
  } else {
  }
  if (!(Heap[this#165, AVLTreeNode.right] == null)) {
    fraction#_1015 := 50;
    assert {:msg "  684.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1015 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1015 == exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1015];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
  } else {
  }
  if (!(Heap[this#165, AVLTreeNode.right] == null)) {
    fraction#_1016 := 50;
    assert {:msg "  684.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1016 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1016 == exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1005[Heap[this#165, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1016];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1005);
  } else {
  }
  assert {:msg "  684.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#165, AVLTreeNode.left] == null, 0, Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#165, AVLTreeNode.right] == null, 0, Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  684.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#165, AVLTreeNode.left] == null, 0, Heap[Heap[this#165, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#165, AVLTreeNode.right] == null, 0, Heap[Heap[this#165, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1005;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1019;
  assume IsGoodInhaleState(inhaleHeap#_1019, Heap, Mask);
  assume this#165 != null;
  Heap[this#165, AVLTreeNode.valid] := inhaleHeap#_1019[this#165, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1019[this#165, AVLTreeNode.valid] == Heap;
  Mask[this#165, AVLTreeNode.valid] := Mask[this#165, AVLTreeNode.valid][perm$R := Mask[this#165, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1019[this#165, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1019, Mask);
  assume this#165 != null;
  Heap[this#165, AVLTreeNode.height] := inhaleHeap#_1019[this#165, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#165, AVLTreeNode.height] := Mask[this#165, AVLTreeNode.height][perm$R := Mask[this#165, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1019[this#165, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1019, Mask);
  assume this#165 != null;
  Heap[this#165, AVLTreeNode.balanceFactor] := inhaleHeap#_1019[this#165, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#165, AVLTreeNode.balanceFactor] := Mask[this#165, AVLTreeNode.balanceFactor][perm$R := Mask[this#165, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1019[this#165, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1019, Mask);
  assume Heap[this#165, AVLTreeNode.height] == ite(ite(callHeap#_1002[this#165, AVLTreeNode.left] == null, 0, callHeap#_1002[callHeap#_1002[this#165, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1002[this#165, AVLTreeNode.right] == null, 0, callHeap#_1002[callHeap#_1002[this#165, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1002[this#165, AVLTreeNode.left] == null, 0, callHeap#_1002[callHeap#_1002[this#165, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1002[this#165, AVLTreeNode.right] == null, 0, callHeap#_1002[callHeap#_1002[this#165, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#165, AVLTreeNode.balanceFactor] == (ite(callHeap#_1002[this#165, AVLTreeNode.left] == null, 0, callHeap#_1002[callHeap#_1002[this#165, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1002[this#165, AVLTreeNode.right] == null, 0, callHeap#_1002[callHeap#_1002[this#165, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  685.3: Location might not be writable"} CanWrite(Mask, r#66, AVLTreeNode.left);
  assert {:msg "  685.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  685.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  Heap[r#66, AVLTreeNode.left] := Heap[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // update field left
  assert {:msg "  686.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  686.17: Receiver might be null."} true ==> (r#66 != null);
  assert {:msg "  686.17: Location might not be readable."} true ==> CanRead(Mask, r#66, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#66, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1020 := Heap;
  callMask#_1021 := Mask;
  callCredits#_1022 := Credits;
  assert {:msg "  689.3: The target of the method call might be null."} this != null;
  this#166 := this;
  // begin exhale (precondition)
  exhaleMask#_1023 := Mask;
  fraction#_1024 := 100;
  assert {:msg "  689.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1024 <= exhaleMask#_1023[this#166, AVLTreeNode.key][perm$R]) && ((fraction#_1024 == exhaleMask#_1023[this#166, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1023[this#166, AVLTreeNode.key][perm$N]));
  exhaleMask#_1023[this#166, AVLTreeNode.key] := exhaleMask#_1023[this#166, AVLTreeNode.key][perm$R := exhaleMask#_1023[this#166, AVLTreeNode.key][perm$R] - fraction#_1024];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1023);
  fraction#_1025 := 100;
  assert {:msg "  689.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1025 <= exhaleMask#_1023[this#166, AVLTreeNode.height][perm$R]) && ((fraction#_1025 == exhaleMask#_1023[this#166, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1023[this#166, AVLTreeNode.height][perm$N]));
  exhaleMask#_1023[this#166, AVLTreeNode.height] := exhaleMask#_1023[this#166, AVLTreeNode.height][perm$R := exhaleMask#_1023[this#166, AVLTreeNode.height][perm$R] - fraction#_1025];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1023);
  fraction#_1026 := 100;
  assert {:msg "  689.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1026 <= exhaleMask#_1023[this#166, AVLTreeNode.left][perm$R]) && ((fraction#_1026 == exhaleMask#_1023[this#166, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1023[this#166, AVLTreeNode.left][perm$N]));
  exhaleMask#_1023[this#166, AVLTreeNode.left] := exhaleMask#_1023[this#166, AVLTreeNode.left][perm$R := exhaleMask#_1023[this#166, AVLTreeNode.left][perm$R] - fraction#_1026];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1023);
  fraction#_1027 := 100;
  assert {:msg "  689.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1027 <= exhaleMask#_1023[this#166, AVLTreeNode.right][perm$R]) && ((fraction#_1027 == exhaleMask#_1023[this#166, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1023[this#166, AVLTreeNode.right][perm$N]));
  exhaleMask#_1023[this#166, AVLTreeNode.right] := exhaleMask#_1023[this#166, AVLTreeNode.right][perm$R := exhaleMask#_1023[this#166, AVLTreeNode.right][perm$R] - fraction#_1027];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1023);
  fraction#_1028 := 100;
  assert {:msg "  689.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1028 <= exhaleMask#_1023[this#166, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1028 == exhaleMask#_1023[this#166, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1023[this#166, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1023[this#166, AVLTreeNode.balanceFactor] := exhaleMask#_1023[this#166, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1023[this#166, AVLTreeNode.balanceFactor][perm$R] - fraction#_1028];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1023);
  if (!(Heap[this#166, AVLTreeNode.left] == null)) {
    fraction#_1029 := 100;
    assert {:msg "  689.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1029 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1029 == exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1029];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1023);
  } else {
  }
  if (!(Heap[this#166, AVLTreeNode.left] == null)) {
    fraction#_1030 := 50;
    assert {:msg "  689.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1030 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1030 == exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1030];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1023);
  } else {
  }
  if (!(Heap[this#166, AVLTreeNode.left] == null)) {
    fraction#_1031 := 50;
    assert {:msg "  689.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1031 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1031 == exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1023[Heap[this#166, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1031];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1023);
  } else {
  }
  if (!(Heap[this#166, AVLTreeNode.right] == null)) {
    fraction#_1032 := 100;
    assert {:msg "  689.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1032 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1032 == exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1032];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1023);
  } else {
  }
  if (!(Heap[this#166, AVLTreeNode.right] == null)) {
    fraction#_1033 := 50;
    assert {:msg "  689.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1033 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1033 == exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1033];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1023);
  } else {
  }
  if (!(Heap[this#166, AVLTreeNode.right] == null)) {
    fraction#_1034 := 50;
    assert {:msg "  689.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1034 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1034 == exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1023[Heap[this#166, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1034];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1023);
  } else {
  }
  assert {:msg "  689.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#166, AVLTreeNode.left] == null, 0, Heap[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#166, AVLTreeNode.right] == null, 0, Heap[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  689.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#166, AVLTreeNode.left] == null, 0, Heap[Heap[this#166, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#166, AVLTreeNode.right] == null, 0, Heap[Heap[this#166, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1023;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1037;
  assume IsGoodInhaleState(inhaleHeap#_1037, Heap, Mask);
  assume this#166 != null;
  Heap[this#166, AVLTreeNode.valid] := inhaleHeap#_1037[this#166, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1037[this#166, AVLTreeNode.valid] == Heap;
  Mask[this#166, AVLTreeNode.valid] := Mask[this#166, AVLTreeNode.valid][perm$R := Mask[this#166, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1037[this#166, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1037, Mask);
  assume this#166 != null;
  Heap[this#166, AVLTreeNode.height] := inhaleHeap#_1037[this#166, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#166, AVLTreeNode.height] := Mask[this#166, AVLTreeNode.height][perm$R := Mask[this#166, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1037[this#166, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1037, Mask);
  assume this#166 != null;
  Heap[this#166, AVLTreeNode.balanceFactor] := inhaleHeap#_1037[this#166, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#166, AVLTreeNode.balanceFactor] := Mask[this#166, AVLTreeNode.balanceFactor][perm$R := Mask[this#166, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1037[this#166, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1037, Mask);
  assume Heap[this#166, AVLTreeNode.height] == ite(ite(callHeap#_1020[this#166, AVLTreeNode.left] == null, 0, callHeap#_1020[callHeap#_1020[this#166, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1020[this#166, AVLTreeNode.right] == null, 0, callHeap#_1020[callHeap#_1020[this#166, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1020[this#166, AVLTreeNode.left] == null, 0, callHeap#_1020[callHeap#_1020[this#166, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1020[this#166, AVLTreeNode.right] == null, 0, callHeap#_1020[callHeap#_1020[this#166, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#166, AVLTreeNode.balanceFactor] == (ite(callHeap#_1020[this#166, AVLTreeNode.left] == null, 0, callHeap#_1020[callHeap#_1020[this#166, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1020[this#166, AVLTreeNode.right] == null, 0, callHeap#_1020[callHeap#_1020[this#166, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  690.3: Location might not be writable"} CanWrite(Mask, r#66, AVLTreeNode.right);
  Heap[r#66, AVLTreeNode.right] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_1038 := Heap;
  callMask#_1039 := Mask;
  callCredits#_1040 := Credits;
  assert {:msg "  691.3: The target of the method call might be null."} r#66 != null;
  this#167 := r#66;
  // begin exhale (precondition)
  exhaleMask#_1041 := Mask;
  fraction#_1042 := 100;
  assert {:msg "  691.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1042 <= exhaleMask#_1041[this#167, AVLTreeNode.key][perm$R]) && ((fraction#_1042 == exhaleMask#_1041[this#167, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1041[this#167, AVLTreeNode.key][perm$N]));
  exhaleMask#_1041[this#167, AVLTreeNode.key] := exhaleMask#_1041[this#167, AVLTreeNode.key][perm$R := exhaleMask#_1041[this#167, AVLTreeNode.key][perm$R] - fraction#_1042];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1041);
  fraction#_1043 := 100;
  assert {:msg "  691.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1043 <= exhaleMask#_1041[this#167, AVLTreeNode.height][perm$R]) && ((fraction#_1043 == exhaleMask#_1041[this#167, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1041[this#167, AVLTreeNode.height][perm$N]));
  exhaleMask#_1041[this#167, AVLTreeNode.height] := exhaleMask#_1041[this#167, AVLTreeNode.height][perm$R := exhaleMask#_1041[this#167, AVLTreeNode.height][perm$R] - fraction#_1043];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1041);
  fraction#_1044 := 100;
  assert {:msg "  691.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1044 <= exhaleMask#_1041[this#167, AVLTreeNode.left][perm$R]) && ((fraction#_1044 == exhaleMask#_1041[this#167, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1041[this#167, AVLTreeNode.left][perm$N]));
  exhaleMask#_1041[this#167, AVLTreeNode.left] := exhaleMask#_1041[this#167, AVLTreeNode.left][perm$R := exhaleMask#_1041[this#167, AVLTreeNode.left][perm$R] - fraction#_1044];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1041);
  fraction#_1045 := 100;
  assert {:msg "  691.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1045 <= exhaleMask#_1041[this#167, AVLTreeNode.right][perm$R]) && ((fraction#_1045 == exhaleMask#_1041[this#167, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1041[this#167, AVLTreeNode.right][perm$N]));
  exhaleMask#_1041[this#167, AVLTreeNode.right] := exhaleMask#_1041[this#167, AVLTreeNode.right][perm$R := exhaleMask#_1041[this#167, AVLTreeNode.right][perm$R] - fraction#_1045];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1041);
  fraction#_1046 := 100;
  assert {:msg "  691.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1046 <= exhaleMask#_1041[this#167, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1046 == exhaleMask#_1041[this#167, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1041[this#167, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1041[this#167, AVLTreeNode.balanceFactor] := exhaleMask#_1041[this#167, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1041[this#167, AVLTreeNode.balanceFactor][perm$R] - fraction#_1046];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1041);
  if (!(Heap[this#167, AVLTreeNode.left] == null)) {
    fraction#_1047 := 100;
    assert {:msg "  691.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1047 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1047 == exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1047];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1041);
  } else {
  }
  if (!(Heap[this#167, AVLTreeNode.left] == null)) {
    fraction#_1048 := 50;
    assert {:msg "  691.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1048 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1048 == exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1048];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1041);
  } else {
  }
  if (!(Heap[this#167, AVLTreeNode.left] == null)) {
    fraction#_1049 := 50;
    assert {:msg "  691.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1049 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1049 == exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1041[Heap[this#167, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1049];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1041);
  } else {
  }
  if (!(Heap[this#167, AVLTreeNode.right] == null)) {
    fraction#_1050 := 100;
    assert {:msg "  691.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1050 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1050 == exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1050];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1041);
  } else {
  }
  if (!(Heap[this#167, AVLTreeNode.right] == null)) {
    fraction#_1051 := 50;
    assert {:msg "  691.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1051 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1051 == exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1051];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1041);
  } else {
  }
  if (!(Heap[this#167, AVLTreeNode.right] == null)) {
    fraction#_1052 := 50;
    assert {:msg "  691.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1052 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1052 == exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1041[Heap[this#167, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1052];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1041);
  } else {
  }
  assert {:msg "  691.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#167, AVLTreeNode.left] == null, 0, Heap[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#167, AVLTreeNode.right] == null, 0, Heap[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  691.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#167, AVLTreeNode.left] == null, 0, Heap[Heap[this#167, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#167, AVLTreeNode.right] == null, 0, Heap[Heap[this#167, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1041;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1055;
  assume IsGoodInhaleState(inhaleHeap#_1055, Heap, Mask);
  assume this#167 != null;
  Heap[this#167, AVLTreeNode.valid] := inhaleHeap#_1055[this#167, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1055[this#167, AVLTreeNode.valid] == Heap;
  Mask[this#167, AVLTreeNode.valid] := Mask[this#167, AVLTreeNode.valid][perm$R := Mask[this#167, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1055[this#167, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1055, Mask);
  assume this#167 != null;
  Heap[this#167, AVLTreeNode.height] := inhaleHeap#_1055[this#167, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#167, AVLTreeNode.height] := Mask[this#167, AVLTreeNode.height][perm$R := Mask[this#167, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1055[this#167, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1055, Mask);
  assume this#167 != null;
  Heap[this#167, AVLTreeNode.balanceFactor] := inhaleHeap#_1055[this#167, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#167, AVLTreeNode.balanceFactor] := Mask[this#167, AVLTreeNode.balanceFactor][perm$R := Mask[this#167, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1055[this#167, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1055, Mask);
  assume Heap[this#167, AVLTreeNode.height] == ite(ite(callHeap#_1038[this#167, AVLTreeNode.left] == null, 0, callHeap#_1038[callHeap#_1038[this#167, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1038[this#167, AVLTreeNode.right] == null, 0, callHeap#_1038[callHeap#_1038[this#167, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1038[this#167, AVLTreeNode.left] == null, 0, callHeap#_1038[callHeap#_1038[this#167, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1038[this#167, AVLTreeNode.right] == null, 0, callHeap#_1038[callHeap#_1038[this#167, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#167, AVLTreeNode.balanceFactor] == (ite(callHeap#_1038[this#167, AVLTreeNode.left] == null, 0, callHeap#_1038[callHeap#_1038[this#167, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1038[this#167, AVLTreeNode.right] == null, 0, callHeap#_1038[callHeap#_1038[this#167, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1056 := Mask;
  fraction#_1057 := 100;
  assert {:msg "  640.2: The postcondition at 667.11 might not hold. Insufficient fraction at 667.11 for AVLTreeNode.valid."} (fraction#_1057 <= exhaleMask#_1056[r#66, AVLTreeNode.valid][perm$R]) && ((fraction#_1057 == exhaleMask#_1056[r#66, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1056[r#66, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1056[r#66, AVLTreeNode.valid] := exhaleMask#_1056[r#66, AVLTreeNode.valid][perm$R := exhaleMask#_1056[r#66, AVLTreeNode.valid][perm$R] - fraction#_1057];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1056);
  fraction#_1058 := 50;
  assert {:msg "  640.2: The postcondition at 668.11 might not hold. Insufficient fraction at 668.11 for AVLTreeNode.height."} (fraction#_1058 <= exhaleMask#_1056[r#66, AVLTreeNode.height][perm$R]) && ((fraction#_1058 == exhaleMask#_1056[r#66, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1056[r#66, AVLTreeNode.height][perm$N]));
  exhaleMask#_1056[r#66, AVLTreeNode.height] := exhaleMask#_1056[r#66, AVLTreeNode.height][perm$R := exhaleMask#_1056[r#66, AVLTreeNode.height][perm$R] - fraction#_1058];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1056);
  fraction#_1059 := 50;
  assert {:msg "  640.2: The postcondition at 670.11 might not hold. Insufficient fraction at 670.11 for AVLTreeNode.balanceFactor."} (fraction#_1059 <= exhaleMask#_1056[r#66, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1059 == exhaleMask#_1056[r#66, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1056[r#66, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1056[r#66, AVLTreeNode.balanceFactor] := exhaleMask#_1056[r#66, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1056[r#66, AVLTreeNode.balanceFactor][perm$R] - fraction#_1059];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1056);
  assert {:msg "  640.2: The postcondition at 672.11 might not hold. The expression at 672.11 might not evaluate to true."} Heap[r#66, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height];
  Mask := exhaleMask#_1056;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  640.2: Method might lock/unlock more than allowed."} (forall lk#_1060: ref :: {Heap[lk#_1060, held]} {Heap[lk#_1060, rdheld]} (((0 < Heap[lk#_1060, held]) == (0 < old(Heap)[lk#_1060, held])) && (Heap[lk#_1060, rdheld] == old(Heap)[lk#_1060, rdheld])) || false);
  assert {:msg "  640.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#67: ref where (r#67 == null) || (dtype(r#67) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1061: HeapType;
  var inhaleHeap#_1062: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1061;
  assume IsGoodInhaleState(inhaleHeap#_1061, Heap, Mask);
  assert {:msg "  698.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  698.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1061[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  699.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  699.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1061[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  700.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  700.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1061[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  701.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  701.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1061[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  704.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  704.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1061[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  706.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  706.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assert {:msg "  707.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  707.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  708.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  708.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  708.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  708.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  710.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  710.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  710.35: Fraction might be negative."} 0 <= 50;
  assert {:msg "  710.35: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1061[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1061, Mask);
  assert {:msg "  713.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  713.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  713.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  713.28: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1061, Mask);
  } else {
  }
  assert {:msg "  714.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  714.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  714.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  714.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  714.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  714.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1061, Mask);
  } else {
  }
  assert {:msg "  716.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  716.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assert {:msg "  716.32: Receiver might be null."} true ==> (this != null);
    assert {:msg "  716.32: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  716.52: Fraction might be negative."} 0 <= 50;
    assert {:msg "  716.52: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1061[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1061, Mask);
  } else {
  }
  assert {:msg "  719.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  719.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  719.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  719.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  719.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  719.27: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  if (Heap[this, AVLTreeNode.right] == null) {
  } else {
    assert {:msg "  719.41: Receiver might be null."} true ==> (this != null);
    assert {:msg "  719.41: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
    assert {:msg "  719.41: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
    assert {:msg "  719.41: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assert {:msg "  720.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  720.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  720.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
  assert {:msg "  720.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1062;
  assume IsGoodInhaleState(inhaleHeap#_1062, Heap, Mask);
  assume r#67 != null;
  Heap[r#67, AVLTreeNode.valid] := inhaleHeap#_1062[r#67, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1062[r#67, AVLTreeNode.valid] == Heap;
  Mask[r#67, AVLTreeNode.valid] := Mask[r#67, AVLTreeNode.valid][perm$R := Mask[r#67, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1062[r#67, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1062, Mask);
  assert {:msg "  724.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  724.31: Fraction might exceed 100."} 50 <= 100;
  assume r#67 != null;
  Heap[r#67, AVLTreeNode.height] := inhaleHeap#_1062[r#67, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#67, AVLTreeNode.height] := Mask[r#67, AVLTreeNode.height][perm$R := Mask[r#67, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1062[r#67, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1062, Mask);
  assert {:msg "  726.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  726.31: Fraction might exceed 100."} 50 <= 100;
  assume r#67 != null;
  Heap[r#67, AVLTreeNode.balanceFactor] := inhaleHeap#_1062[r#67, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#67, AVLTreeNode.balanceFactor] := Mask[r#67, AVLTreeNode.balanceFactor][perm$R := Mask[r#67, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1062[r#67, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1062, Mask);
  assert {:msg "  728.11: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  728.11: Location might not be readable."} true ==> CanRead(Mask, r#67, AVLTreeNode.height);
  assert {:msg "  728.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  728.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  728.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  728.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assert {:msg "  728.43: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (r#67 != null);
  assert {:msg "  728.43: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(Mask, r#67, AVLTreeNode.height);
  assert {:msg "  728.59: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  728.59: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.left);
  assert {:msg "  728.59: Receiver might be null."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.left] != null);
  assert {:msg "  728.59: Location might not be readable."} true && (!(Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height);
  assume (Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#67, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#67: ref where (r#67 == null) || (dtype(r#67) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1063: HeapType;
  var exhaleMask#_1064: MaskType;
  var fraction#_1065: int;
  var inhaleHeap#_1066: HeapType;
  var this#168: ref where (this#168 == null) || (dtype(this#168) == AVLTreeNode#t);
  var callHeap#_1067: HeapType;
  var callMask#_1068: MaskType;
  var callCredits#_1069: CreditsType;
  var exhaleMask#_1070: MaskType;
  var fraction#_1071: int;
  var fraction#_1072: int;
  var fraction#_1073: int;
  var fraction#_1074: int;
  var fraction#_1075: int;
  var fraction#_1076: int;
  var fraction#_1077: int;
  var fraction#_1078: int;
  var fraction#_1079: int;
  var fraction#_1080: int;
  var fraction#_1081: int;
  var isHeld#_1082: int;
  var isRdHeld#_1083: bool;
  var inhaleHeap#_1084: HeapType;
  var this#169: ref where (this#169 == null) || (dtype(this#169) == AVLTreeNode#t);
  var callHeap#_1085: HeapType;
  var callMask#_1086: MaskType;
  var callCredits#_1087: CreditsType;
  var exhaleMask#_1088: MaskType;
  var fraction#_1089: int;
  var fraction#_1090: int;
  var fraction#_1091: int;
  var fraction#_1092: int;
  var fraction#_1093: int;
  var fraction#_1094: int;
  var fraction#_1095: int;
  var fraction#_1096: int;
  var fraction#_1097: int;
  var fraction#_1098: int;
  var fraction#_1099: int;
  var isHeld#_1100: int;
  var isRdHeld#_1101: bool;
  var inhaleHeap#_1102: HeapType;
  var exhaleMask#_1103: MaskType;
  var fraction#_1104: int;
  var fraction#_1105: int;
  var fraction#_1106: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1063;
  assume IsGoodInhaleState(inhaleHeap#_1063, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1063[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1063[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1063[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1063[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1063[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume !(Heap[this, AVLTreeNode.left] == null);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1063[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1063, Mask);
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1063, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1063, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.right] == null)) {
    assume Heap[this, AVLTreeNode.right] != null;
    Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1063[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1063, Mask);
  } else {
  }
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] - ite(Heap[this, AVLTreeNode.right] == null, 0, Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height])) == 2;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  731.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  731.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  assert {:msg "  731.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.left] != null;
  // begin exhale (unfold)
  exhaleMask#_1064 := Mask;
  fraction#_1065 := 100;
  assert {:msg "  731.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1065 <= exhaleMask#_1064[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1065 == exhaleMask#_1064[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1064[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
  exhaleMask#_1064[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1064[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1064[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1065];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1064);
  Mask := exhaleMask#_1064;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1066 := Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1066, Heap, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1066, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1066, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1066, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1066, Mask);
  assume Heap[this, AVLTreeNode.left] != null;
  Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1066[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1066, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1066, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1066, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1066, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1066, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1066, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1066[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1066, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  732.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  732.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  r#67 := Heap[this, AVLTreeNode.left];
  // update field left
  assert {:msg "  733.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.left);
  assert {:msg "  733.14: Receiver might be null."} true ==> (r#67 != null);
  assert {:msg "  733.14: Location might not be readable."} true ==> CanRead(Mask, r#67, AVLTreeNode.right);
  Heap[this, AVLTreeNode.left] := Heap[r#67, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1067 := Heap;
  callMask#_1068 := Mask;
  callCredits#_1069 := Credits;
  assert {:msg "  734.3: The target of the method call might be null."} this != null;
  this#168 := this;
  // begin exhale (precondition)
  exhaleMask#_1070 := Mask;
  fraction#_1071 := 100;
  assert {:msg "  734.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1071 <= exhaleMask#_1070[this#168, AVLTreeNode.key][perm$R]) && ((fraction#_1071 == exhaleMask#_1070[this#168, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1070[this#168, AVLTreeNode.key][perm$N]));
  exhaleMask#_1070[this#168, AVLTreeNode.key] := exhaleMask#_1070[this#168, AVLTreeNode.key][perm$R := exhaleMask#_1070[this#168, AVLTreeNode.key][perm$R] - fraction#_1071];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1070);
  fraction#_1072 := 100;
  assert {:msg "  734.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1072 <= exhaleMask#_1070[this#168, AVLTreeNode.height][perm$R]) && ((fraction#_1072 == exhaleMask#_1070[this#168, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1070[this#168, AVLTreeNode.height][perm$N]));
  exhaleMask#_1070[this#168, AVLTreeNode.height] := exhaleMask#_1070[this#168, AVLTreeNode.height][perm$R := exhaleMask#_1070[this#168, AVLTreeNode.height][perm$R] - fraction#_1072];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1070);
  fraction#_1073 := 100;
  assert {:msg "  734.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1073 <= exhaleMask#_1070[this#168, AVLTreeNode.left][perm$R]) && ((fraction#_1073 == exhaleMask#_1070[this#168, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1070[this#168, AVLTreeNode.left][perm$N]));
  exhaleMask#_1070[this#168, AVLTreeNode.left] := exhaleMask#_1070[this#168, AVLTreeNode.left][perm$R := exhaleMask#_1070[this#168, AVLTreeNode.left][perm$R] - fraction#_1073];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1070);
  fraction#_1074 := 100;
  assert {:msg "  734.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1074 <= exhaleMask#_1070[this#168, AVLTreeNode.right][perm$R]) && ((fraction#_1074 == exhaleMask#_1070[this#168, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1070[this#168, AVLTreeNode.right][perm$N]));
  exhaleMask#_1070[this#168, AVLTreeNode.right] := exhaleMask#_1070[this#168, AVLTreeNode.right][perm$R := exhaleMask#_1070[this#168, AVLTreeNode.right][perm$R] - fraction#_1074];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1070);
  fraction#_1075 := 100;
  assert {:msg "  734.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1075 <= exhaleMask#_1070[this#168, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1075 == exhaleMask#_1070[this#168, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1070[this#168, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1070[this#168, AVLTreeNode.balanceFactor] := exhaleMask#_1070[this#168, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1070[this#168, AVLTreeNode.balanceFactor][perm$R] - fraction#_1075];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1070);
  if (!(Heap[this#168, AVLTreeNode.left] == null)) {
    fraction#_1076 := 100;
    assert {:msg "  734.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1076 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1076 == exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1076];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1070);
  } else {
  }
  if (!(Heap[this#168, AVLTreeNode.left] == null)) {
    fraction#_1077 := 50;
    assert {:msg "  734.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1077 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1077 == exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1077];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1070);
  } else {
  }
  if (!(Heap[this#168, AVLTreeNode.left] == null)) {
    fraction#_1078 := 50;
    assert {:msg "  734.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1078 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1078 == exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1070[Heap[this#168, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1078];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1070);
  } else {
  }
  if (!(Heap[this#168, AVLTreeNode.right] == null)) {
    fraction#_1079 := 100;
    assert {:msg "  734.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1079 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1079 == exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1079];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1070);
  } else {
  }
  if (!(Heap[this#168, AVLTreeNode.right] == null)) {
    fraction#_1080 := 50;
    assert {:msg "  734.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1080 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1080 == exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1080];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1070);
  } else {
  }
  if (!(Heap[this#168, AVLTreeNode.right] == null)) {
    fraction#_1081 := 50;
    assert {:msg "  734.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1081 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1081 == exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1070[Heap[this#168, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1081];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1070);
  } else {
  }
  assert {:msg "  734.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#168, AVLTreeNode.left] == null, 0, Heap[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#168, AVLTreeNode.right] == null, 0, Heap[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  734.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#168, AVLTreeNode.left] == null, 0, Heap[Heap[this#168, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#168, AVLTreeNode.right] == null, 0, Heap[Heap[this#168, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1070;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1084;
  assume IsGoodInhaleState(inhaleHeap#_1084, Heap, Mask);
  assume this#168 != null;
  Heap[this#168, AVLTreeNode.valid] := inhaleHeap#_1084[this#168, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1084[this#168, AVLTreeNode.valid] == Heap;
  Mask[this#168, AVLTreeNode.valid] := Mask[this#168, AVLTreeNode.valid][perm$R := Mask[this#168, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1084[this#168, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1084, Mask);
  assume this#168 != null;
  Heap[this#168, AVLTreeNode.height] := inhaleHeap#_1084[this#168, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#168, AVLTreeNode.height] := Mask[this#168, AVLTreeNode.height][perm$R := Mask[this#168, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1084[this#168, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1084, Mask);
  assume this#168 != null;
  Heap[this#168, AVLTreeNode.balanceFactor] := inhaleHeap#_1084[this#168, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#168, AVLTreeNode.balanceFactor] := Mask[this#168, AVLTreeNode.balanceFactor][perm$R := Mask[this#168, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1084[this#168, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1084, Mask);
  assume Heap[this#168, AVLTreeNode.height] == ite(ite(callHeap#_1067[this#168, AVLTreeNode.left] == null, 0, callHeap#_1067[callHeap#_1067[this#168, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1067[this#168, AVLTreeNode.right] == null, 0, callHeap#_1067[callHeap#_1067[this#168, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1067[this#168, AVLTreeNode.left] == null, 0, callHeap#_1067[callHeap#_1067[this#168, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1067[this#168, AVLTreeNode.right] == null, 0, callHeap#_1067[callHeap#_1067[this#168, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#168, AVLTreeNode.balanceFactor] == (ite(callHeap#_1067[this#168, AVLTreeNode.left] == null, 0, callHeap#_1067[callHeap#_1067[this#168, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1067[this#168, AVLTreeNode.right] == null, 0, callHeap#_1067[callHeap#_1067[this#168, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  735.3: Location might not be writable"} CanWrite(Mask, r#67, AVLTreeNode.right);
  Heap[r#67, AVLTreeNode.right] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_1085 := Heap;
  callMask#_1086 := Mask;
  callCredits#_1087 := Credits;
  assert {:msg "  736.3: The target of the method call might be null."} r#67 != null;
  this#169 := r#67;
  // begin exhale (precondition)
  exhaleMask#_1088 := Mask;
  fraction#_1089 := 100;
  assert {:msg "  736.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1089 <= exhaleMask#_1088[this#169, AVLTreeNode.key][perm$R]) && ((fraction#_1089 == exhaleMask#_1088[this#169, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1088[this#169, AVLTreeNode.key][perm$N]));
  exhaleMask#_1088[this#169, AVLTreeNode.key] := exhaleMask#_1088[this#169, AVLTreeNode.key][perm$R := exhaleMask#_1088[this#169, AVLTreeNode.key][perm$R] - fraction#_1089];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  fraction#_1090 := 100;
  assert {:msg "  736.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1090 <= exhaleMask#_1088[this#169, AVLTreeNode.height][perm$R]) && ((fraction#_1090 == exhaleMask#_1088[this#169, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1088[this#169, AVLTreeNode.height][perm$N]));
  exhaleMask#_1088[this#169, AVLTreeNode.height] := exhaleMask#_1088[this#169, AVLTreeNode.height][perm$R := exhaleMask#_1088[this#169, AVLTreeNode.height][perm$R] - fraction#_1090];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  fraction#_1091 := 100;
  assert {:msg "  736.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1091 <= exhaleMask#_1088[this#169, AVLTreeNode.left][perm$R]) && ((fraction#_1091 == exhaleMask#_1088[this#169, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1088[this#169, AVLTreeNode.left][perm$N]));
  exhaleMask#_1088[this#169, AVLTreeNode.left] := exhaleMask#_1088[this#169, AVLTreeNode.left][perm$R := exhaleMask#_1088[this#169, AVLTreeNode.left][perm$R] - fraction#_1091];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  fraction#_1092 := 100;
  assert {:msg "  736.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1092 <= exhaleMask#_1088[this#169, AVLTreeNode.right][perm$R]) && ((fraction#_1092 == exhaleMask#_1088[this#169, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1088[this#169, AVLTreeNode.right][perm$N]));
  exhaleMask#_1088[this#169, AVLTreeNode.right] := exhaleMask#_1088[this#169, AVLTreeNode.right][perm$R := exhaleMask#_1088[this#169, AVLTreeNode.right][perm$R] - fraction#_1092];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  fraction#_1093 := 100;
  assert {:msg "  736.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1093 <= exhaleMask#_1088[this#169, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1093 == exhaleMask#_1088[this#169, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1088[this#169, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1088[this#169, AVLTreeNode.balanceFactor] := exhaleMask#_1088[this#169, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1088[this#169, AVLTreeNode.balanceFactor][perm$R] - fraction#_1093];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  if (!(Heap[this#169, AVLTreeNode.left] == null)) {
    fraction#_1094 := 100;
    assert {:msg "  736.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1094 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1094 == exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1094];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1088);
  } else {
  }
  if (!(Heap[this#169, AVLTreeNode.left] == null)) {
    fraction#_1095 := 50;
    assert {:msg "  736.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1095 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1095 == exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1095];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1088);
  } else {
  }
  if (!(Heap[this#169, AVLTreeNode.left] == null)) {
    fraction#_1096 := 50;
    assert {:msg "  736.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1096 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1096 == exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1088[Heap[this#169, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1096];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1088);
  } else {
  }
  if (!(Heap[this#169, AVLTreeNode.right] == null)) {
    fraction#_1097 := 100;
    assert {:msg "  736.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1097 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1097 == exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1097];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1088);
  } else {
  }
  if (!(Heap[this#169, AVLTreeNode.right] == null)) {
    fraction#_1098 := 50;
    assert {:msg "  736.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1098 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1098 == exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1098];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1088);
  } else {
  }
  if (!(Heap[this#169, AVLTreeNode.right] == null)) {
    fraction#_1099 := 50;
    assert {:msg "  736.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1099 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1099 == exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1088[Heap[this#169, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1099];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1088);
  } else {
  }
  assert {:msg "  736.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#169, AVLTreeNode.left] == null, 0, Heap[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#169, AVLTreeNode.right] == null, 0, Heap[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  736.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#169, AVLTreeNode.left] == null, 0, Heap[Heap[this#169, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#169, AVLTreeNode.right] == null, 0, Heap[Heap[this#169, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1088;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1102;
  assume IsGoodInhaleState(inhaleHeap#_1102, Heap, Mask);
  assume this#169 != null;
  Heap[this#169, AVLTreeNode.valid] := inhaleHeap#_1102[this#169, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1102[this#169, AVLTreeNode.valid] == Heap;
  Mask[this#169, AVLTreeNode.valid] := Mask[this#169, AVLTreeNode.valid][perm$R := Mask[this#169, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1102[this#169, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1102, Mask);
  assume this#169 != null;
  Heap[this#169, AVLTreeNode.height] := inhaleHeap#_1102[this#169, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#169, AVLTreeNode.height] := Mask[this#169, AVLTreeNode.height][perm$R := Mask[this#169, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1102[this#169, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1102, Mask);
  assume this#169 != null;
  Heap[this#169, AVLTreeNode.balanceFactor] := inhaleHeap#_1102[this#169, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#169, AVLTreeNode.balanceFactor] := Mask[this#169, AVLTreeNode.balanceFactor][perm$R := Mask[this#169, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1102[this#169, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1102, Mask);
  assume Heap[this#169, AVLTreeNode.height] == ite(ite(callHeap#_1085[this#169, AVLTreeNode.left] == null, 0, callHeap#_1085[callHeap#_1085[this#169, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1085[this#169, AVLTreeNode.right] == null, 0, callHeap#_1085[callHeap#_1085[this#169, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1085[this#169, AVLTreeNode.left] == null, 0, callHeap#_1085[callHeap#_1085[this#169, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1085[this#169, AVLTreeNode.right] == null, 0, callHeap#_1085[callHeap#_1085[this#169, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#169, AVLTreeNode.balanceFactor] == (ite(callHeap#_1085[this#169, AVLTreeNode.left] == null, 0, callHeap#_1085[callHeap#_1085[this#169, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1085[this#169, AVLTreeNode.right] == null, 0, callHeap#_1085[callHeap#_1085[this#169, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1103 := Mask;
  fraction#_1104 := 100;
  assert {:msg "  697.2: The postcondition at 723.11 might not hold. Insufficient fraction at 723.11 for AVLTreeNode.valid."} (fraction#_1104 <= exhaleMask#_1103[r#67, AVLTreeNode.valid][perm$R]) && ((fraction#_1104 == exhaleMask#_1103[r#67, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1103[r#67, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1103[r#67, AVLTreeNode.valid] := exhaleMask#_1103[r#67, AVLTreeNode.valid][perm$R := exhaleMask#_1103[r#67, AVLTreeNode.valid][perm$R] - fraction#_1104];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  fraction#_1105 := 50;
  assert {:msg "  697.2: The postcondition at 724.11 might not hold. Insufficient fraction at 724.11 for AVLTreeNode.height."} (fraction#_1105 <= exhaleMask#_1103[r#67, AVLTreeNode.height][perm$R]) && ((fraction#_1105 == exhaleMask#_1103[r#67, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1103[r#67, AVLTreeNode.height][perm$N]));
  exhaleMask#_1103[r#67, AVLTreeNode.height] := exhaleMask#_1103[r#67, AVLTreeNode.height][perm$R := exhaleMask#_1103[r#67, AVLTreeNode.height][perm$R] - fraction#_1105];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  fraction#_1106 := 50;
  assert {:msg "  697.2: The postcondition at 726.11 might not hold. Insufficient fraction at 726.11 for AVLTreeNode.balanceFactor."} (fraction#_1106 <= exhaleMask#_1103[r#67, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1106 == exhaleMask#_1103[r#67, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1103[r#67, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1103[r#67, AVLTreeNode.balanceFactor] := exhaleMask#_1103[r#67, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1103[r#67, AVLTreeNode.balanceFactor][perm$R] - fraction#_1106];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  assert {:msg "  697.2: The postcondition at 728.11 might not hold. The expression at 728.11 might not evaluate to true."} (Heap[r#67, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height]) || (Heap[r#67, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.left], AVLTreeNode.height] + 1));
  Mask := exhaleMask#_1103;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  697.2: Method might lock/unlock more than allowed."} (forall lk#_1107: ref :: {Heap[lk#_1107, held]} {Heap[lk#_1107, rdheld]} (((0 < Heap[lk#_1107, held]) == (0 < old(Heap)[lk#_1107, held])) && (Heap[lk#_1107, rdheld] == old(Heap)[lk#_1107, rdheld])) || false);
  assert {:msg "  697.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceRight$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#68: ref where (r#68 == null) || (dtype(r#68) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1108: HeapType;
  var inhaleHeap#_1109: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1108;
  assume IsGoodInhaleState(inhaleHeap#_1108, Heap, Mask);
  assert {:msg "  741.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  741.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1108[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  742.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  742.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1108[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  743.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  743.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1108[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  744.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  744.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1108[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  747.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  747.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1108[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  749.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  749.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  749.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  749.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1108, Mask);
  } else {
  }
  assert {:msg "  750.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  750.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  750.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  750.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  750.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  750.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1108, Mask);
  } else {
  }
  assert {:msg "  752.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  752.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  752.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  752.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  752.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  752.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1108[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1108, Mask);
  } else {
  }
  assert {:msg "  755.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  755.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  756.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  756.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  757.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  757.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  757.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  757.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  759.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  759.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  759.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  759.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1108[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1108, Mask);
  assert {:msg "  763.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  763.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  763.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  763.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  763.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  763.26: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  763.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  763.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  763.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  763.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1109;
  assume IsGoodInhaleState(inhaleHeap#_1109, Heap, Mask);
  assume r#68 != null;
  Heap[r#68, AVLTreeNode.valid] := inhaleHeap#_1109[r#68, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1109[r#68, AVLTreeNode.valid] == Heap;
  Mask[r#68, AVLTreeNode.valid] := Mask[r#68, AVLTreeNode.valid][perm$R := Mask[r#68, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1109[r#68, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1109, Mask);
  assert {:msg "  766.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  766.31: Fraction might exceed 100."} 50 <= 100;
  assume r#68 != null;
  Heap[r#68, AVLTreeNode.height] := inhaleHeap#_1109[r#68, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#68, AVLTreeNode.height] := Mask[r#68, AVLTreeNode.height][perm$R := Mask[r#68, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1109[r#68, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1109, Mask);
  assert {:msg "  768.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  768.31: Fraction might exceed 100."} 50 <= 100;
  assume r#68 != null;
  Heap[r#68, AVLTreeNode.balanceFactor] := inhaleHeap#_1109[r#68, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#68, AVLTreeNode.balanceFactor] := Mask[r#68, AVLTreeNode.balanceFactor][perm$R := Mask[r#68, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1109[r#68, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1109, Mask);
  assert {:msg "  770.11: Receiver might be null."} true ==> (r#68 != null);
  assert {:msg "  770.11: Location might not be readable."} true ==> CanRead(Mask, r#68, AVLTreeNode.height);
  assert {:msg "  770.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  770.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  770.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  770.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assert {:msg "  770.44: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (r#68 != null);
  assert {:msg "  770.44: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(Mask, r#68, AVLTreeNode.height);
  assert {:msg "  770.60: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  770.60: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  770.60: Receiver might be null."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  770.60: Location might not be readable."} true && (!(Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#68, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceRight(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#68: ref where (r#68 == null) || (dtype(r#68) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1110: HeapType;
  var rbf#70: int where true;
  var this#170: ref where (this#170 == null) || (dtype(this#170) == AVLTreeNode#t);
  var bf#171: int where true;
  var callHeap#_1111: HeapType;
  var callMask#_1112: MaskType;
  var callCredits#_1113: CreditsType;
  var exhaleMask#_1114: MaskType;
  var fraction#_1115: int;
  var epsilons#_1116: int;
  var isHeld#_1117: int;
  var isRdHeld#_1118: bool;
  var inhaleHeap#_1119: HeapType;
  var Heap#_1123: HeapType;
  var Mask#_1124: MaskType;
  var Credits#_1125: CreditsType;
  var exhaleMask#_1126: MaskType;
  var Heap#_1130: HeapType;
  var Mask#_1131: MaskType;
  var Credits#_1132: CreditsType;
  var exhaleMask#_1133: MaskType;
  var fraction#_1134: int;
  var inhaleHeap#_1135: HeapType;
  var this#172: ref where (this#172 == null) || (dtype(this#172) == AVLTreeNode#t);
  var r#173: ref where (r#173 == null) || (dtype(r#173) == AVLTreeNode#t);
  var callHeap#_1136: HeapType;
  var callMask#_1137: MaskType;
  var callCredits#_1138: CreditsType;
  var exhaleMask#_1139: MaskType;
  var fraction#_1140: int;
  var fraction#_1141: int;
  var fraction#_1142: int;
  var fraction#_1143: int;
  var fraction#_1144: int;
  var fraction#_1145: int;
  var fraction#_1146: int;
  var fraction#_1147: int;
  var fraction#_1148: int;
  var fraction#_1149: int;
  var fraction#_1150: int;
  var isHeld#_1151: int;
  var isRdHeld#_1152: bool;
  var inhaleHeap#_1153: HeapType;
  var this#174: ref where (this#174 == null) || (dtype(this#174) == AVLTreeNode#t);
  var r#175: ref where (r#175 == null) || (dtype(r#175) == AVLTreeNode#t);
  var callHeap#_1154: HeapType;
  var callMask#_1155: MaskType;
  var callCredits#_1156: CreditsType;
  var exhaleMask#_1157: MaskType;
  var fraction#_1158: int;
  var fraction#_1159: int;
  var fraction#_1160: int;
  var fraction#_1161: int;
  var fraction#_1162: int;
  var fraction#_1163: int;
  var fraction#_1164: int;
  var fraction#_1165: int;
  var fraction#_1166: int;
  var fraction#_1167: int;
  var fraction#_1168: int;
  var isHeld#_1169: int;
  var isRdHeld#_1170: bool;
  var inhaleHeap#_1171: HeapType;
  var exhaleMask#_1172: MaskType;
  var fraction#_1173: int;
  var fraction#_1174: int;
  var fraction#_1175: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1110;
  assume IsGoodInhaleState(inhaleHeap#_1110, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1110[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1110[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1110[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1110[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1110[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1110, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1110, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1110[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1110, Mask);
  } else {
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1110[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1110, Mask);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var rbf
  // call getBalanceFactor
  callHeap#_1111 := Heap;
  callMask#_1112 := Mask;
  callCredits#_1113 := Credits;
  assert {:msg "  774.15: Receiver might be null."} true ==> (this != null);
  assert {:msg "  774.15: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  774.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#170 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_1114 := Mask;
  fraction#_1115 := 100;
  assert {:msg "  774.3: The precondition at 486.12 might not hold. Insufficient fraction at 486.12 for AVLTreeNode.valid."} (fraction#_1115 <= exhaleMask#_1114[this#170, AVLTreeNode.valid][perm$R]) && ((fraction#_1115 == exhaleMask#_1114[this#170, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1114[this#170, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1114[this#170, AVLTreeNode.valid] := exhaleMask#_1114[this#170, AVLTreeNode.valid][perm$R := exhaleMask#_1114[this#170, AVLTreeNode.valid][perm$R] - fraction#_1115];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1114);
  epsilons#_1116 := 1;
  assert {:msg "  774.3: The precondition at 487.12 might not hold. Insufficient epsilons at 487.12  for AVLTreeNode.balanceFactor."} (exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor][perm$R] == 0) ==> (epsilons#_1116 <= exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor][perm$N]);
  if ((exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor] := exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor][perm$N := exhaleMask#_1114[this#170, AVLTreeNode.balanceFactor][perm$N] - epsilons#_1116];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1114);
  Mask := exhaleMask#_1114;
  assume wf(Heap, Mask);
  // end exhale
  havoc bf#171;
  // inhale (postcondition)
  havoc inhaleHeap#_1119;
  assume IsGoodInhaleState(inhaleHeap#_1119, Heap, Mask);
  assume this#170 != null;
  Heap[this#170, AVLTreeNode.valid] := inhaleHeap#_1119[this#170, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1119[this#170, AVLTreeNode.valid] == Heap;
  Mask[this#170, AVLTreeNode.valid] := Mask[this#170, AVLTreeNode.valid][perm$R := Mask[this#170, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[this#170, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assume this#170 != null;
  Heap[this#170, AVLTreeNode.balanceFactor] := inhaleHeap#_1119[this#170, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  if ((Mask[this#170, AVLTreeNode.balanceFactor][perm$N] != Permission$MinusInfinity) && (Mask[this#170, AVLTreeNode.balanceFactor][perm$N] != Permission$PlusInfinity)) {
    Mask[this#170, AVLTreeNode.balanceFactor] := Mask[this#170, AVLTreeNode.balanceFactor][perm$N := Mask[this#170, AVLTreeNode.balanceFactor][perm$N] + 1];
    assume wf(Heap, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[this#170, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assume bf#171 == Heap[this#170, AVLTreeNode.balanceFactor];
  assume (bf#171 > 0) ==> (!(Heap[this#170, AVLTreeNode.left] == null));
  assume (bf#171 < 0) ==> (!(Heap[this#170, AVLTreeNode.right] == null));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  rbf#70 := bf#171;
  // if
  if (rbf#70 > 0) {
    // assert
    Heap#_1123 := Heap;
    Mask#_1124 := Mask;
    Credits#_1125 := Credits;
    // begin exhale (assert)
    exhaleMask#_1126 := Mask#_1124;
    // unfolding
    assert {:msg "  776.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  776.21: Location might not be readable."} true ==> CanRead(Mask#_1124, this, AVLTreeNode.right);
    assert {:msg "  776.21: Receiver might be null."} true ==> (Heap#_1123[this, AVLTreeNode.right] != null);
    Heap#_1130 := Heap#_1123;
    Mask#_1131 := Mask#_1124;
    Credits#_1132 := Credits#_1125;
    // begin exhale (unfolding)
    exhaleMask#_1133 := Mask#_1131;
    fraction#_1134 := 100;
    assert {:msg "  776.11: Unfolding might fail. Insufficient fraction at 776.21 for AVLTreeNode.valid."} (fraction#_1134 <= exhaleMask#_1133[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1134 == exhaleMask#_1133[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1133[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1133[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1133[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1133[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1134];
    assume IsGoodMask(Mask#_1131);
    assume wf(Heap#_1130, Mask#_1131);
    assume wf(Heap#_1130, exhaleMask#_1133);
    Mask#_1131 := exhaleMask#_1133;
    assume wf(Heap#_1130, Mask#_1131);
    // end exhale
    // inhale (unfolding)
    inhaleHeap#_1135 := Heap#_1123[Heap#_1123[this, AVLTreeNode.right], AVLTreeNode.valid];
    assume IsGoodInhaleState(inhaleHeap#_1135, Heap#_1130, Mask#_1131);
    assume Heap#_1130[this, AVLTreeNode.right] != null;
    Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.key];
    assume wf(Heap#_1130, Mask#_1131);
    assume true;
    Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.key] := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
    assume IsGoodMask(Mask#_1131);
    assume IsGoodState(inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.key]);
    assume wf(Heap#_1130, Mask#_1131);
    assume wf(inhaleHeap#_1135, Mask#_1131);
    assume Heap#_1130[this, AVLTreeNode.right] != null;
    Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap#_1130, Mask#_1131);
    assume true;
    Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height] := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask#_1131);
    assume IsGoodState(inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap#_1130, Mask#_1131);
    assume wf(inhaleHeap#_1135, Mask#_1131);
    assume Heap#_1130[this, AVLTreeNode.right] != null;
    Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left];
    assume wf(Heap#_1130, Mask#_1131);
    assume (Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
    Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
    assume IsGoodMask(Mask#_1131);
    assume IsGoodState(inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left]);
    assume wf(Heap#_1130, Mask#_1131);
    assume wf(inhaleHeap#_1135, Mask#_1131);
    assume Heap#_1130[this, AVLTreeNode.right] != null;
    Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right];
    assume wf(Heap#_1130, Mask#_1131);
    assume (Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
    Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
    assume IsGoodMask(Mask#_1131);
    assume IsGoodState(inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right]);
    assume wf(Heap#_1130, Mask#_1131);
    assume wf(inhaleHeap#_1135, Mask#_1131);
    assume Heap#_1130[this, AVLTreeNode.right] != null;
    Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap#_1130, Mask#_1131);
    assume true;
    Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_1131[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask#_1131);
    assume IsGoodState(inhaleHeap#_1135[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap#_1130, Mask#_1131);
    assume wf(inhaleHeap#_1135, Mask#_1131);
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
      assume wf(Heap#_1130, Mask#_1131);
      assume inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap#_1130;
      Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_1131);
      assume IsGoodState(inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
      assume wf(Heap#_1130, Mask#_1131);
      assume wf(inhaleHeap#_1135, Mask#_1131);
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height];
      assume wf(Heap#_1130, Mask#_1131);
      assume true;
      Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_1131);
      assume IsGoodState(inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]);
      assume wf(Heap#_1130, Mask#_1131);
      assume wf(inhaleHeap#_1135, Mask#_1131);
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] != null;
      Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor];
      assume wf(Heap#_1130, Mask#_1131);
      assume true;
      Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_1131);
      assume IsGoodState(inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_1130, Mask#_1131);
      assume wf(inhaleHeap#_1135, Mask#_1131);
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
      assume Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
      assume wf(Heap#_1130, Mask#_1131);
      assume inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap#_1130;
      Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
      assume IsGoodMask(Mask#_1131);
      assume IsGoodState(inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
      assume wf(Heap#_1130, Mask#_1131);
      assume wf(inhaleHeap#_1135, Mask#_1131);
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height];
      assume wf(Heap#_1130, Mask#_1131);
      assume true;
      Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
      assume IsGoodMask(Mask#_1131);
      assume IsGoodState(inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]);
      assume wf(Heap#_1130, Mask#_1131);
      assume wf(inhaleHeap#_1135, Mask#_1131);
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] != null;
      Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor];
      assume wf(Heap#_1130, Mask#_1131);
      assume true;
      Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask#_1131[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
      assume IsGoodMask(Mask#_1131);
      assume IsGoodState(inhaleHeap#_1135[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
      assume wf(Heap#_1130, Mask#_1131);
      assume wf(inhaleHeap#_1135, Mask#_1131);
    } else {
    }
    if (!(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
      assume Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
    } else {
    }
    assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
    assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap#_1130[Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
    assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
    assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
    assume Heap#_1130[Heap#_1130[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
    assume IsGoodMask(Mask#_1131);
    assume wf(Heap#_1130, Mask#_1131);
    // end inhale
    assert {:msg "  776.4: Assertion might not hold. The expression at 776.11 might not evaluate to true."} rbf#70 == 1;
    Mask#_1124 := exhaleMask#_1126;
    assume wf(Heap#_1123, Mask#_1124);
    // end exhale
    // call rebalanceLR
    callHeap#_1136 := Heap;
    callMask#_1137 := Mask;
    callCredits#_1138 := Credits;
    assert {:msg "  777.4: The target of the method call might be null."} this != null;
    this#172 := this;
    // begin exhale (precondition)
    exhaleMask#_1139 := Mask;
    fraction#_1140 := 100;
    assert {:msg "  777.4: The precondition at 785.12 might not hold. Insufficient fraction at 785.12 for AVLTreeNode.key."} (fraction#_1140 <= exhaleMask#_1139[this#172, AVLTreeNode.key][perm$R]) && ((fraction#_1140 == exhaleMask#_1139[this#172, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1139[this#172, AVLTreeNode.key][perm$N]));
    exhaleMask#_1139[this#172, AVLTreeNode.key] := exhaleMask#_1139[this#172, AVLTreeNode.key][perm$R := exhaleMask#_1139[this#172, AVLTreeNode.key][perm$R] - fraction#_1140];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    fraction#_1141 := 100;
    assert {:msg "  777.4: The precondition at 786.12 might not hold. Insufficient fraction at 786.12 for AVLTreeNode.height."} (fraction#_1141 <= exhaleMask#_1139[this#172, AVLTreeNode.height][perm$R]) && ((fraction#_1141 == exhaleMask#_1139[this#172, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1139[this#172, AVLTreeNode.height][perm$N]));
    exhaleMask#_1139[this#172, AVLTreeNode.height] := exhaleMask#_1139[this#172, AVLTreeNode.height][perm$R := exhaleMask#_1139[this#172, AVLTreeNode.height][perm$R] - fraction#_1141];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    fraction#_1142 := 100;
    assert {:msg "  777.4: The precondition at 787.12 might not hold. Insufficient fraction at 787.12 for AVLTreeNode.left."} (fraction#_1142 <= exhaleMask#_1139[this#172, AVLTreeNode.left][perm$R]) && ((fraction#_1142 == exhaleMask#_1139[this#172, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1139[this#172, AVLTreeNode.left][perm$N]));
    exhaleMask#_1139[this#172, AVLTreeNode.left] := exhaleMask#_1139[this#172, AVLTreeNode.left][perm$R := exhaleMask#_1139[this#172, AVLTreeNode.left][perm$R] - fraction#_1142];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    fraction#_1143 := 100;
    assert {:msg "  777.4: The precondition at 788.12 might not hold. Insufficient fraction at 788.12 for AVLTreeNode.right."} (fraction#_1143 <= exhaleMask#_1139[this#172, AVLTreeNode.right][perm$R]) && ((fraction#_1143 == exhaleMask#_1139[this#172, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1139[this#172, AVLTreeNode.right][perm$N]));
    exhaleMask#_1139[this#172, AVLTreeNode.right] := exhaleMask#_1139[this#172, AVLTreeNode.right][perm$R := exhaleMask#_1139[this#172, AVLTreeNode.right][perm$R] - fraction#_1143];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    fraction#_1144 := 100;
    assert {:msg "  777.4: The precondition at 791.12 might not hold. Insufficient fraction at 791.12 for AVLTreeNode.balanceFactor."} (fraction#_1144 <= exhaleMask#_1139[this#172, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1144 == exhaleMask#_1139[this#172, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1139[this#172, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1139[this#172, AVLTreeNode.balanceFactor] := exhaleMask#_1139[this#172, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1139[this#172, AVLTreeNode.balanceFactor][perm$R] - fraction#_1144];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    if (!(Heap[this#172, AVLTreeNode.left] == null)) {
      fraction#_1145 := 100;
      assert {:msg "  777.4: The precondition at 793.12 might not hold. Insufficient fraction at 793.25 for AVLTreeNode.valid."} (fraction#_1145 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1145 == exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1145];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1139);
    } else {
    }
    if (!(Heap[this#172, AVLTreeNode.left] == null)) {
      fraction#_1146 := 50;
      assert {:msg "  777.4: The precondition at 794.12 might not hold. Insufficient fraction at 794.25 for AVLTreeNode.height."} (fraction#_1146 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1146 == exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1146];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1139);
    } else {
    }
    if (!(Heap[this#172, AVLTreeNode.left] == null)) {
      fraction#_1147 := 50;
      assert {:msg "  777.4: The precondition at 796.12 might not hold. Insufficient fraction at 796.25 for AVLTreeNode.balanceFactor."} (fraction#_1147 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1147 == exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1139[Heap[this#172, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1147];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1139);
    } else {
    }
    assert {:msg "  777.4: The precondition at 799.12 might not hold. The expression at 799.12 might not evaluate to true."} !(Heap[this#172, AVLTreeNode.right] == null);
    fraction#_1148 := 100;
    assert {:msg "  777.4: The precondition at 800.12 might not hold. Insufficient fraction at 800.12 for AVLTreeNode.valid."} (fraction#_1148 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1148 == exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1148];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    fraction#_1149 := 50;
    assert {:msg "  777.4: The precondition at 801.12 might not hold. Insufficient fraction at 801.12 for AVLTreeNode.height."} (fraction#_1149 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1149 == exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1149];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    fraction#_1150 := 50;
    assert {:msg "  777.4: The precondition at 803.12 might not hold. Insufficient fraction at 803.12 for AVLTreeNode.balanceFactor."} (fraction#_1150 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1150 == exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1139[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1150];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1139);
    assert {:msg "  777.4: The precondition at 808.12 might not hold. The expression at 808.12 might not evaluate to true."} (ite(Heap[this#172, AVLTreeNode.left] == null, 0, Heap[Heap[this#172, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#172, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
    assert {:msg "  777.4: The precondition at 809.12 might not hold. The expression at 809.12 might not evaluate to true."} Heap[Heap[this#172, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
    Mask := exhaleMask#_1139;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#173;
    // inhale (postcondition)
    havoc inhaleHeap#_1153;
    assume IsGoodInhaleState(inhaleHeap#_1153, Heap, Mask);
    assume r#173 != null;
    Heap[r#173, AVLTreeNode.valid] := inhaleHeap#_1153[r#173, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1153[r#173, AVLTreeNode.valid] == Heap;
    Mask[r#173, AVLTreeNode.valid] := Mask[r#173, AVLTreeNode.valid][perm$R := Mask[r#173, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1153[r#173, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1153, Mask);
    assume r#173 != null;
    Heap[r#173, AVLTreeNode.height] := inhaleHeap#_1153[r#173, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#173, AVLTreeNode.height] := Mask[r#173, AVLTreeNode.height][perm$R := Mask[r#173, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1153[r#173, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1153, Mask);
    assume r#173 != null;
    Heap[r#173, AVLTreeNode.balanceFactor] := inhaleHeap#_1153[r#173, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#173, AVLTreeNode.balanceFactor] := Mask[r#173, AVLTreeNode.balanceFactor][perm$R := Mask[r#173, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1153[r#173, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1153, Mask);
    assume Heap[r#173, AVLTreeNode.height] == callHeap#_1136[callHeap#_1136[this#172, AVLTreeNode.right], AVLTreeNode.height];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#68 := r#173;
  } else {
    // call rebalanceLL
    callHeap#_1154 := Heap;
    callMask#_1155 := Mask;
    callCredits#_1156 := Credits;
    assert {:msg "  779.4: The target of the method call might be null."} this != null;
    this#174 := this;
    // begin exhale (precondition)
    exhaleMask#_1157 := Mask;
    fraction#_1158 := 100;
    assert {:msg "  779.4: The precondition at 839.12 might not hold. Insufficient fraction at 839.12 for AVLTreeNode.key."} (fraction#_1158 <= exhaleMask#_1157[this#174, AVLTreeNode.key][perm$R]) && ((fraction#_1158 == exhaleMask#_1157[this#174, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1157[this#174, AVLTreeNode.key][perm$N]));
    exhaleMask#_1157[this#174, AVLTreeNode.key] := exhaleMask#_1157[this#174, AVLTreeNode.key][perm$R := exhaleMask#_1157[this#174, AVLTreeNode.key][perm$R] - fraction#_1158];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    fraction#_1159 := 100;
    assert {:msg "  779.4: The precondition at 840.12 might not hold. Insufficient fraction at 840.12 for AVLTreeNode.height."} (fraction#_1159 <= exhaleMask#_1157[this#174, AVLTreeNode.height][perm$R]) && ((fraction#_1159 == exhaleMask#_1157[this#174, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1157[this#174, AVLTreeNode.height][perm$N]));
    exhaleMask#_1157[this#174, AVLTreeNode.height] := exhaleMask#_1157[this#174, AVLTreeNode.height][perm$R := exhaleMask#_1157[this#174, AVLTreeNode.height][perm$R] - fraction#_1159];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    fraction#_1160 := 100;
    assert {:msg "  779.4: The precondition at 841.12 might not hold. Insufficient fraction at 841.12 for AVLTreeNode.left."} (fraction#_1160 <= exhaleMask#_1157[this#174, AVLTreeNode.left][perm$R]) && ((fraction#_1160 == exhaleMask#_1157[this#174, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1157[this#174, AVLTreeNode.left][perm$N]));
    exhaleMask#_1157[this#174, AVLTreeNode.left] := exhaleMask#_1157[this#174, AVLTreeNode.left][perm$R := exhaleMask#_1157[this#174, AVLTreeNode.left][perm$R] - fraction#_1160];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    fraction#_1161 := 100;
    assert {:msg "  779.4: The precondition at 842.12 might not hold. Insufficient fraction at 842.12 for AVLTreeNode.right."} (fraction#_1161 <= exhaleMask#_1157[this#174, AVLTreeNode.right][perm$R]) && ((fraction#_1161 == exhaleMask#_1157[this#174, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1157[this#174, AVLTreeNode.right][perm$N]));
    exhaleMask#_1157[this#174, AVLTreeNode.right] := exhaleMask#_1157[this#174, AVLTreeNode.right][perm$R := exhaleMask#_1157[this#174, AVLTreeNode.right][perm$R] - fraction#_1161];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    fraction#_1162 := 100;
    assert {:msg "  779.4: The precondition at 845.12 might not hold. Insufficient fraction at 845.12 for AVLTreeNode.balanceFactor."} (fraction#_1162 <= exhaleMask#_1157[this#174, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1162 == exhaleMask#_1157[this#174, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1157[this#174, AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1157[this#174, AVLTreeNode.balanceFactor] := exhaleMask#_1157[this#174, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1157[this#174, AVLTreeNode.balanceFactor][perm$R] - fraction#_1162];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    if (!(Heap[this#174, AVLTreeNode.left] == null)) {
      fraction#_1163 := 100;
      assert {:msg "  779.4: The precondition at 847.12 might not hold. Insufficient fraction at 847.25 for AVLTreeNode.valid."} (fraction#_1163 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1163 == exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
      exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1163];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1157);
    } else {
    }
    if (!(Heap[this#174, AVLTreeNode.left] == null)) {
      fraction#_1164 := 50;
      assert {:msg "  779.4: The precondition at 848.12 might not hold. Insufficient fraction at 848.25 for AVLTreeNode.height."} (fraction#_1164 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1164 == exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
      exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1164];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1157);
    } else {
    }
    if (!(Heap[this#174, AVLTreeNode.left] == null)) {
      fraction#_1165 := 50;
      assert {:msg "  779.4: The precondition at 850.12 might not hold. Insufficient fraction at 850.25 for AVLTreeNode.balanceFactor."} (fraction#_1165 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1165 == exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
      exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1157[Heap[this#174, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1165];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1157);
    } else {
    }
    assert {:msg "  779.4: The precondition at 853.12 might not hold. The expression at 853.12 might not evaluate to true."} !(Heap[this#174, AVLTreeNode.right] == null);
    fraction#_1166 := 100;
    assert {:msg "  779.4: The precondition at 854.12 might not hold. Insufficient fraction at 854.12 for AVLTreeNode.valid."} (fraction#_1166 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1166 == exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1166];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    fraction#_1167 := 50;
    assert {:msg "  779.4: The precondition at 855.12 might not hold. Insufficient fraction at 855.12 for AVLTreeNode.height."} (fraction#_1167 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1167 == exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1167];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    fraction#_1168 := 50;
    assert {:msg "  779.4: The precondition at 857.12 might not hold. Insufficient fraction at 857.12 for AVLTreeNode.balanceFactor."} (fraction#_1168 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1168 == exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1157[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1168];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1157);
    assert {:msg "  779.4: The precondition at 860.12 might not hold. The expression at 860.12 might not evaluate to true."} (ite(Heap[this#174, AVLTreeNode.left] == null, 0, Heap[Heap[this#174, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this#174, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
    assert {:msg "  779.4: The precondition at 861.12 might not hold. The expression at 861.12 might not evaluate to true."} Heap[Heap[this#174, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
    Mask := exhaleMask#_1157;
    assume wf(Heap, Mask);
    // end exhale
    havoc r#175;
    // inhale (postcondition)
    havoc inhaleHeap#_1171;
    assume IsGoodInhaleState(inhaleHeap#_1171, Heap, Mask);
    assume r#175 != null;
    Heap[r#175, AVLTreeNode.valid] := inhaleHeap#_1171[r#175, AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1171[r#175, AVLTreeNode.valid] == Heap;
    Mask[r#175, AVLTreeNode.valid] := Mask[r#175, AVLTreeNode.valid][perm$R := Mask[r#175, AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1171[r#175, AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1171, Mask);
    assume r#175 != null;
    Heap[r#175, AVLTreeNode.height] := inhaleHeap#_1171[r#175, AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#175, AVLTreeNode.height] := Mask[r#175, AVLTreeNode.height][perm$R := Mask[r#175, AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1171[r#175, AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1171, Mask);
    assume r#175 != null;
    Heap[r#175, AVLTreeNode.balanceFactor] := inhaleHeap#_1171[r#175, AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[r#175, AVLTreeNode.balanceFactor] := Mask[r#175, AVLTreeNode.balanceFactor][perm$R := Mask[r#175, AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1171[r#175, AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1171, Mask);
    assume (Heap[r#175, AVLTreeNode.height] == callHeap#_1154[callHeap#_1154[this#174, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#175, AVLTreeNode.height] == (callHeap#_1154[callHeap#_1154[this#174, AVLTreeNode.right], AVLTreeNode.height] + 1));
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    r#68 := r#175;
  }
  // begin exhale (postcondition)
  exhaleMask#_1172 := Mask;
  fraction#_1173 := 100;
  assert {:msg "  740.2: The postcondition at 765.11 might not hold. Insufficient fraction at 765.11 for AVLTreeNode.valid."} (fraction#_1173 <= exhaleMask#_1172[r#68, AVLTreeNode.valid][perm$R]) && ((fraction#_1173 == exhaleMask#_1172[r#68, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1172[r#68, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1172[r#68, AVLTreeNode.valid] := exhaleMask#_1172[r#68, AVLTreeNode.valid][perm$R := exhaleMask#_1172[r#68, AVLTreeNode.valid][perm$R] - fraction#_1173];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1172);
  fraction#_1174 := 50;
  assert {:msg "  740.2: The postcondition at 766.11 might not hold. Insufficient fraction at 766.11 for AVLTreeNode.height."} (fraction#_1174 <= exhaleMask#_1172[r#68, AVLTreeNode.height][perm$R]) && ((fraction#_1174 == exhaleMask#_1172[r#68, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1172[r#68, AVLTreeNode.height][perm$N]));
  exhaleMask#_1172[r#68, AVLTreeNode.height] := exhaleMask#_1172[r#68, AVLTreeNode.height][perm$R := exhaleMask#_1172[r#68, AVLTreeNode.height][perm$R] - fraction#_1174];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1172);
  fraction#_1175 := 50;
  assert {:msg "  740.2: The postcondition at 768.11 might not hold. Insufficient fraction at 768.11 for AVLTreeNode.balanceFactor."} (fraction#_1175 <= exhaleMask#_1172[r#68, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1175 == exhaleMask#_1172[r#68, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1172[r#68, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1172[r#68, AVLTreeNode.balanceFactor] := exhaleMask#_1172[r#68, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1172[r#68, AVLTreeNode.balanceFactor][perm$R] - fraction#_1175];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1172);
  assert {:msg "  740.2: The postcondition at 770.11 might not hold. The expression at 770.11 might not evaluate to true."} (Heap[r#68, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#68, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  Mask := exhaleMask#_1172;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  740.2: Method might lock/unlock more than allowed."} (forall lk#_1176: ref :: {Heap[lk#_1176, held]} {Heap[lk#_1176, rdheld]} (((0 < Heap[lk#_1176, held]) == (0 < old(Heap)[lk#_1176, held])) && (Heap[lk#_1176, rdheld] == old(Heap)[lk#_1176, rdheld])) || false);
  assert {:msg "  740.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLR$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#71: ref where (r#71 == null) || (dtype(r#71) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1177: HeapType;
  var inhaleHeap#_1178: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1177;
  assume IsGoodInhaleState(inhaleHeap#_1177, Heap, Mask);
  assert {:msg "  785.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  785.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1177[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  786.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  786.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1177[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  787.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  787.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1177[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  788.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  788.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1177[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  791.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  791.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1177[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  793.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  793.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  793.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  793.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1177, Mask);
  } else {
  }
  assert {:msg "  794.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  794.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  794.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  794.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  794.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  794.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1177, Mask);
  } else {
  }
  assert {:msg "  796.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  796.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  796.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  796.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  796.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  796.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1177[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1177, Mask);
  } else {
  }
  assert {:msg "  799.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  799.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  800.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  800.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  801.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  801.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  801.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  801.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  803.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  803.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  803.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  803.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1177[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1177, Mask);
  assert {:msg "  808.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  808.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  808.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  808.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  808.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  808.26: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  808.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  808.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  808.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  808.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assert {:msg "  809.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  809.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  809.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  809.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1178;
  assume IsGoodInhaleState(inhaleHeap#_1178, Heap, Mask);
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.valid] := inhaleHeap#_1178[r#71, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1178[r#71, AVLTreeNode.valid] == Heap;
  Mask[r#71, AVLTreeNode.valid] := Mask[r#71, AVLTreeNode.valid][perm$R := Mask[r#71, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1178[r#71, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1178, Mask);
  assert {:msg "  812.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  812.31: Fraction might exceed 100."} 50 <= 100;
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.height] := inhaleHeap#_1178[r#71, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#71, AVLTreeNode.height] := Mask[r#71, AVLTreeNode.height][perm$R := Mask[r#71, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1178[r#71, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1178, Mask);
  assert {:msg "  814.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  814.31: Fraction might exceed 100."} 50 <= 100;
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.balanceFactor] := inhaleHeap#_1178[r#71, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#71, AVLTreeNode.balanceFactor] := Mask[r#71, AVLTreeNode.balanceFactor][perm$R := Mask[r#71, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1178[r#71, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1178, Mask);
  assert {:msg "  816.11: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  816.11: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.height);
  assert {:msg "  816.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  816.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  816.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  816.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume Heap[r#71, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLR(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#71: ref where (r#71 == null) || (dtype(r#71) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1179: HeapType;
  var exhaleMask#_1180: MaskType;
  var fraction#_1181: int;
  var inhaleHeap#_1182: HeapType;
  var exhaleMask#_1183: MaskType;
  var fraction#_1184: int;
  var inhaleHeap#_1185: HeapType;
  var this#176: ref where (this#176 == null) || (dtype(this#176) == AVLTreeNode#t);
  var callHeap#_1186: HeapType;
  var callMask#_1187: MaskType;
  var callCredits#_1188: CreditsType;
  var exhaleMask#_1189: MaskType;
  var fraction#_1190: int;
  var fraction#_1191: int;
  var fraction#_1192: int;
  var fraction#_1193: int;
  var fraction#_1194: int;
  var fraction#_1195: int;
  var fraction#_1196: int;
  var fraction#_1197: int;
  var fraction#_1198: int;
  var fraction#_1199: int;
  var fraction#_1200: int;
  var isHeld#_1201: int;
  var isRdHeld#_1202: bool;
  var inhaleHeap#_1203: HeapType;
  var this#177: ref where (this#177 == null) || (dtype(this#177) == AVLTreeNode#t);
  var callHeap#_1204: HeapType;
  var callMask#_1205: MaskType;
  var callCredits#_1206: CreditsType;
  var exhaleMask#_1207: MaskType;
  var fraction#_1208: int;
  var fraction#_1209: int;
  var fraction#_1210: int;
  var fraction#_1211: int;
  var fraction#_1212: int;
  var fraction#_1213: int;
  var fraction#_1214: int;
  var fraction#_1215: int;
  var fraction#_1216: int;
  var fraction#_1217: int;
  var fraction#_1218: int;
  var isHeld#_1219: int;
  var isRdHeld#_1220: bool;
  var inhaleHeap#_1221: HeapType;
  var this#178: ref where (this#178 == null) || (dtype(this#178) == AVLTreeNode#t);
  var callHeap#_1222: HeapType;
  var callMask#_1223: MaskType;
  var callCredits#_1224: CreditsType;
  var exhaleMask#_1225: MaskType;
  var fraction#_1226: int;
  var fraction#_1227: int;
  var fraction#_1228: int;
  var fraction#_1229: int;
  var fraction#_1230: int;
  var fraction#_1231: int;
  var fraction#_1232: int;
  var fraction#_1233: int;
  var fraction#_1234: int;
  var fraction#_1235: int;
  var fraction#_1236: int;
  var isHeld#_1237: int;
  var isRdHeld#_1238: bool;
  var inhaleHeap#_1239: HeapType;
  var exhaleMask#_1240: MaskType;
  var fraction#_1241: int;
  var fraction#_1242: int;
  var fraction#_1243: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1179;
  assume IsGoodInhaleState(inhaleHeap#_1179, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1179[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1179[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1179[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1179[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1179[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1179, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1179, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1179[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1179, Mask);
  } else {
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1179[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1179, Mask);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  820.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  820.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  820.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  exhaleMask#_1180 := Mask;
  fraction#_1181 := 100;
  assert {:msg "  820.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1181 <= exhaleMask#_1180[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1181 == exhaleMask#_1180[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1180[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  exhaleMask#_1180[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1180[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1180[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1181];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1180);
  Mask := exhaleMask#_1180;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1182 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1182, Heap, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1182, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1182, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1182, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1182, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1182[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1182, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1182, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1182, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1182, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1182, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1182, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1182[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1182, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  821.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  821.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  821.8: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  821.8: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  r#71 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  // unfold
  assert {:msg "  823.3: The target of the fold statement might be null."} r#71 != null;
  // begin exhale (unfold)
  exhaleMask#_1183 := Mask;
  fraction#_1184 := 100;
  assert {:msg "  823.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1184 <= exhaleMask#_1183[r#71, AVLTreeNode.valid][perm$R]) && ((fraction#_1184 == exhaleMask#_1183[r#71, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1183[r#71, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1183[r#71, AVLTreeNode.valid] := exhaleMask#_1183[r#71, AVLTreeNode.valid][perm$R := exhaleMask#_1183[r#71, AVLTreeNode.valid][perm$R] - fraction#_1184];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1183);
  Mask := exhaleMask#_1183;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1185 := Heap[r#71, AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1185, Heap, Mask);
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.key] := inhaleHeap#_1185[r#71, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#71, AVLTreeNode.key] := Mask[r#71, AVLTreeNode.key][perm$R := Mask[r#71, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1185[r#71, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1185, Mask);
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.height] := inhaleHeap#_1185[r#71, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#71, AVLTreeNode.height] := Mask[r#71, AVLTreeNode.height][perm$R := Mask[r#71, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1185[r#71, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1185, Mask);
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.left] := inhaleHeap#_1185[r#71, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[r#71, AVLTreeNode.left] == null) || (dtype(Heap[r#71, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[r#71, AVLTreeNode.left] := Mask[r#71, AVLTreeNode.left][perm$R := Mask[r#71, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1185[r#71, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1185, Mask);
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.right] := inhaleHeap#_1185[r#71, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[r#71, AVLTreeNode.right] == null) || (dtype(Heap[r#71, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[r#71, AVLTreeNode.right] := Mask[r#71, AVLTreeNode.right][perm$R := Mask[r#71, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1185[r#71, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1185, Mask);
  assume r#71 != null;
  Heap[r#71, AVLTreeNode.balanceFactor] := inhaleHeap#_1185[r#71, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#71, AVLTreeNode.balanceFactor] := Mask[r#71, AVLTreeNode.balanceFactor][perm$R := Mask[r#71, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1185[r#71, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1185, Mask);
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1185, Mask);
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1185, Mask);
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[r#71, AVLTreeNode.left] != null;
    Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1185[Heap[r#71, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1185, Mask);
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.left] == null)) {
    assume Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1185, Mask);
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1185, Mask);
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[r#71, AVLTreeNode.right] != null;
    Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1185[Heap[r#71, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1185, Mask);
  } else {
  }
  if (!(Heap[r#71, AVLTreeNode.right] == null)) {
    assume Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[r#71, AVLTreeNode.height] == ite(ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[r#71, AVLTreeNode.balanceFactor] == (ite(Heap[r#71, AVLTreeNode.left] == null, 0, Heap[Heap[r#71, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[r#71, AVLTreeNode.right] == null, 0, Heap[Heap[r#71, AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[r#71, AVLTreeNode.balanceFactor] <= 1;
  assume Heap[r#71, AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[r#71, AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  825.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.3: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  825.3: Location might not be writable"} CanWrite(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.left);
  assert {:msg "  825.17: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  825.17: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.right);
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Heap[r#71, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1186 := Heap;
  callMask#_1187 := Mask;
  callCredits#_1188 := Credits;
  assert {:msg "  826.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  826.8: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  826.3: The target of the method call might be null."} Heap[this, AVLTreeNode.right] != null;
  this#176 := Heap[this, AVLTreeNode.right];
  // begin exhale (precondition)
  exhaleMask#_1189 := Mask;
  fraction#_1190 := 100;
  assert {:msg "  826.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1190 <= exhaleMask#_1189[this#176, AVLTreeNode.key][perm$R]) && ((fraction#_1190 == exhaleMask#_1189[this#176, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1189[this#176, AVLTreeNode.key][perm$N]));
  exhaleMask#_1189[this#176, AVLTreeNode.key] := exhaleMask#_1189[this#176, AVLTreeNode.key][perm$R := exhaleMask#_1189[this#176, AVLTreeNode.key][perm$R] - fraction#_1190];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1189);
  fraction#_1191 := 100;
  assert {:msg "  826.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1191 <= exhaleMask#_1189[this#176, AVLTreeNode.height][perm$R]) && ((fraction#_1191 == exhaleMask#_1189[this#176, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1189[this#176, AVLTreeNode.height][perm$N]));
  exhaleMask#_1189[this#176, AVLTreeNode.height] := exhaleMask#_1189[this#176, AVLTreeNode.height][perm$R := exhaleMask#_1189[this#176, AVLTreeNode.height][perm$R] - fraction#_1191];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1189);
  fraction#_1192 := 100;
  assert {:msg "  826.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1192 <= exhaleMask#_1189[this#176, AVLTreeNode.left][perm$R]) && ((fraction#_1192 == exhaleMask#_1189[this#176, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1189[this#176, AVLTreeNode.left][perm$N]));
  exhaleMask#_1189[this#176, AVLTreeNode.left] := exhaleMask#_1189[this#176, AVLTreeNode.left][perm$R := exhaleMask#_1189[this#176, AVLTreeNode.left][perm$R] - fraction#_1192];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1189);
  fraction#_1193 := 100;
  assert {:msg "  826.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1193 <= exhaleMask#_1189[this#176, AVLTreeNode.right][perm$R]) && ((fraction#_1193 == exhaleMask#_1189[this#176, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1189[this#176, AVLTreeNode.right][perm$N]));
  exhaleMask#_1189[this#176, AVLTreeNode.right] := exhaleMask#_1189[this#176, AVLTreeNode.right][perm$R := exhaleMask#_1189[this#176, AVLTreeNode.right][perm$R] - fraction#_1193];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1189);
  fraction#_1194 := 100;
  assert {:msg "  826.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1194 <= exhaleMask#_1189[this#176, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1194 == exhaleMask#_1189[this#176, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1189[this#176, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1189[this#176, AVLTreeNode.balanceFactor] := exhaleMask#_1189[this#176, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1189[this#176, AVLTreeNode.balanceFactor][perm$R] - fraction#_1194];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1189);
  if (!(Heap[this#176, AVLTreeNode.left] == null)) {
    fraction#_1195 := 100;
    assert {:msg "  826.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1195 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1195 == exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1195];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1189);
  } else {
  }
  if (!(Heap[this#176, AVLTreeNode.left] == null)) {
    fraction#_1196 := 50;
    assert {:msg "  826.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1196 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1196 == exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1196];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1189);
  } else {
  }
  if (!(Heap[this#176, AVLTreeNode.left] == null)) {
    fraction#_1197 := 50;
    assert {:msg "  826.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1197 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1197 == exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1189[Heap[this#176, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1197];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1189);
  } else {
  }
  if (!(Heap[this#176, AVLTreeNode.right] == null)) {
    fraction#_1198 := 100;
    assert {:msg "  826.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1198 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1198 == exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1198];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1189);
  } else {
  }
  if (!(Heap[this#176, AVLTreeNode.right] == null)) {
    fraction#_1199 := 50;
    assert {:msg "  826.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1199 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1199 == exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1199];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1189);
  } else {
  }
  if (!(Heap[this#176, AVLTreeNode.right] == null)) {
    fraction#_1200 := 50;
    assert {:msg "  826.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1200 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1200 == exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1189[Heap[this#176, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1200];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1189);
  } else {
  }
  assert {:msg "  826.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#176, AVLTreeNode.left] == null, 0, Heap[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#176, AVLTreeNode.right] == null, 0, Heap[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  826.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#176, AVLTreeNode.left] == null, 0, Heap[Heap[this#176, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#176, AVLTreeNode.right] == null, 0, Heap[Heap[this#176, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1189;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1203;
  assume IsGoodInhaleState(inhaleHeap#_1203, Heap, Mask);
  assume this#176 != null;
  Heap[this#176, AVLTreeNode.valid] := inhaleHeap#_1203[this#176, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1203[this#176, AVLTreeNode.valid] == Heap;
  Mask[this#176, AVLTreeNode.valid] := Mask[this#176, AVLTreeNode.valid][perm$R := Mask[this#176, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1203[this#176, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1203, Mask);
  assume this#176 != null;
  Heap[this#176, AVLTreeNode.height] := inhaleHeap#_1203[this#176, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#176, AVLTreeNode.height] := Mask[this#176, AVLTreeNode.height][perm$R := Mask[this#176, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1203[this#176, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1203, Mask);
  assume this#176 != null;
  Heap[this#176, AVLTreeNode.balanceFactor] := inhaleHeap#_1203[this#176, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#176, AVLTreeNode.balanceFactor] := Mask[this#176, AVLTreeNode.balanceFactor][perm$R := Mask[this#176, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1203[this#176, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1203, Mask);
  assume Heap[this#176, AVLTreeNode.height] == ite(ite(callHeap#_1186[this#176, AVLTreeNode.left] == null, 0, callHeap#_1186[callHeap#_1186[this#176, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1186[this#176, AVLTreeNode.right] == null, 0, callHeap#_1186[callHeap#_1186[this#176, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1186[this#176, AVLTreeNode.left] == null, 0, callHeap#_1186[callHeap#_1186[this#176, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1186[this#176, AVLTreeNode.right] == null, 0, callHeap#_1186[callHeap#_1186[this#176, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#176, AVLTreeNode.balanceFactor] == (ite(callHeap#_1186[this#176, AVLTreeNode.left] == null, 0, callHeap#_1186[callHeap#_1186[this#176, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1186[this#176, AVLTreeNode.right] == null, 0, callHeap#_1186[callHeap#_1186[this#176, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field right
  assert {:msg "  827.3: Location might not be writable"} CanWrite(Mask, r#71, AVLTreeNode.right);
  assert {:msg "  827.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  827.17: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  Heap[r#71, AVLTreeNode.right] := Heap[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  // update field right
  assert {:msg "  828.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  828.17: Receiver might be null."} true ==> (r#71 != null);
  assert {:msg "  828.17: Location might not be readable."} true ==> CanRead(Mask, r#71, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#71, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1204 := Heap;
  callMask#_1205 := Mask;
  callCredits#_1206 := Credits;
  assert {:msg "  830.3: The target of the method call might be null."} this != null;
  this#177 := this;
  // begin exhale (precondition)
  exhaleMask#_1207 := Mask;
  fraction#_1208 := 100;
  assert {:msg "  830.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1208 <= exhaleMask#_1207[this#177, AVLTreeNode.key][perm$R]) && ((fraction#_1208 == exhaleMask#_1207[this#177, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1207[this#177, AVLTreeNode.key][perm$N]));
  exhaleMask#_1207[this#177, AVLTreeNode.key] := exhaleMask#_1207[this#177, AVLTreeNode.key][perm$R := exhaleMask#_1207[this#177, AVLTreeNode.key][perm$R] - fraction#_1208];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1207);
  fraction#_1209 := 100;
  assert {:msg "  830.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1209 <= exhaleMask#_1207[this#177, AVLTreeNode.height][perm$R]) && ((fraction#_1209 == exhaleMask#_1207[this#177, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1207[this#177, AVLTreeNode.height][perm$N]));
  exhaleMask#_1207[this#177, AVLTreeNode.height] := exhaleMask#_1207[this#177, AVLTreeNode.height][perm$R := exhaleMask#_1207[this#177, AVLTreeNode.height][perm$R] - fraction#_1209];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1207);
  fraction#_1210 := 100;
  assert {:msg "  830.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1210 <= exhaleMask#_1207[this#177, AVLTreeNode.left][perm$R]) && ((fraction#_1210 == exhaleMask#_1207[this#177, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1207[this#177, AVLTreeNode.left][perm$N]));
  exhaleMask#_1207[this#177, AVLTreeNode.left] := exhaleMask#_1207[this#177, AVLTreeNode.left][perm$R := exhaleMask#_1207[this#177, AVLTreeNode.left][perm$R] - fraction#_1210];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1207);
  fraction#_1211 := 100;
  assert {:msg "  830.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1211 <= exhaleMask#_1207[this#177, AVLTreeNode.right][perm$R]) && ((fraction#_1211 == exhaleMask#_1207[this#177, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1207[this#177, AVLTreeNode.right][perm$N]));
  exhaleMask#_1207[this#177, AVLTreeNode.right] := exhaleMask#_1207[this#177, AVLTreeNode.right][perm$R := exhaleMask#_1207[this#177, AVLTreeNode.right][perm$R] - fraction#_1211];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1207);
  fraction#_1212 := 100;
  assert {:msg "  830.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1212 <= exhaleMask#_1207[this#177, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1212 == exhaleMask#_1207[this#177, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1207[this#177, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1207[this#177, AVLTreeNode.balanceFactor] := exhaleMask#_1207[this#177, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1207[this#177, AVLTreeNode.balanceFactor][perm$R] - fraction#_1212];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1207);
  if (!(Heap[this#177, AVLTreeNode.left] == null)) {
    fraction#_1213 := 100;
    assert {:msg "  830.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1213 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1213 == exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1213];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1207);
  } else {
  }
  if (!(Heap[this#177, AVLTreeNode.left] == null)) {
    fraction#_1214 := 50;
    assert {:msg "  830.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1214 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1214 == exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1214];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1207);
  } else {
  }
  if (!(Heap[this#177, AVLTreeNode.left] == null)) {
    fraction#_1215 := 50;
    assert {:msg "  830.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1215 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1215 == exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1207[Heap[this#177, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1215];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1207);
  } else {
  }
  if (!(Heap[this#177, AVLTreeNode.right] == null)) {
    fraction#_1216 := 100;
    assert {:msg "  830.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1216 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1216 == exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1216];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1207);
  } else {
  }
  if (!(Heap[this#177, AVLTreeNode.right] == null)) {
    fraction#_1217 := 50;
    assert {:msg "  830.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1217 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1217 == exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1217];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1207);
  } else {
  }
  if (!(Heap[this#177, AVLTreeNode.right] == null)) {
    fraction#_1218 := 50;
    assert {:msg "  830.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1218 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1218 == exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1207[Heap[this#177, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1218];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1207);
  } else {
  }
  assert {:msg "  830.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#177, AVLTreeNode.left] == null, 0, Heap[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#177, AVLTreeNode.right] == null, 0, Heap[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  830.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#177, AVLTreeNode.left] == null, 0, Heap[Heap[this#177, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#177, AVLTreeNode.right] == null, 0, Heap[Heap[this#177, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1207;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1221;
  assume IsGoodInhaleState(inhaleHeap#_1221, Heap, Mask);
  assume this#177 != null;
  Heap[this#177, AVLTreeNode.valid] := inhaleHeap#_1221[this#177, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1221[this#177, AVLTreeNode.valid] == Heap;
  Mask[this#177, AVLTreeNode.valid] := Mask[this#177, AVLTreeNode.valid][perm$R := Mask[this#177, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1221[this#177, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1221, Mask);
  assume this#177 != null;
  Heap[this#177, AVLTreeNode.height] := inhaleHeap#_1221[this#177, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#177, AVLTreeNode.height] := Mask[this#177, AVLTreeNode.height][perm$R := Mask[this#177, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1221[this#177, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1221, Mask);
  assume this#177 != null;
  Heap[this#177, AVLTreeNode.balanceFactor] := inhaleHeap#_1221[this#177, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#177, AVLTreeNode.balanceFactor] := Mask[this#177, AVLTreeNode.balanceFactor][perm$R := Mask[this#177, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1221[this#177, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1221, Mask);
  assume Heap[this#177, AVLTreeNode.height] == ite(ite(callHeap#_1204[this#177, AVLTreeNode.left] == null, 0, callHeap#_1204[callHeap#_1204[this#177, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1204[this#177, AVLTreeNode.right] == null, 0, callHeap#_1204[callHeap#_1204[this#177, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1204[this#177, AVLTreeNode.left] == null, 0, callHeap#_1204[callHeap#_1204[this#177, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1204[this#177, AVLTreeNode.right] == null, 0, callHeap#_1204[callHeap#_1204[this#177, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#177, AVLTreeNode.balanceFactor] == (ite(callHeap#_1204[this#177, AVLTreeNode.left] == null, 0, callHeap#_1204[callHeap#_1204[this#177, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1204[this#177, AVLTreeNode.right] == null, 0, callHeap#_1204[callHeap#_1204[this#177, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  831.3: Location might not be writable"} CanWrite(Mask, r#71, AVLTreeNode.left);
  Heap[r#71, AVLTreeNode.left] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_1222 := Heap;
  callMask#_1223 := Mask;
  callCredits#_1224 := Credits;
  assert {:msg "  832.3: The target of the method call might be null."} r#71 != null;
  this#178 := r#71;
  // begin exhale (precondition)
  exhaleMask#_1225 := Mask;
  fraction#_1226 := 100;
  assert {:msg "  832.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1226 <= exhaleMask#_1225[this#178, AVLTreeNode.key][perm$R]) && ((fraction#_1226 == exhaleMask#_1225[this#178, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1225[this#178, AVLTreeNode.key][perm$N]));
  exhaleMask#_1225[this#178, AVLTreeNode.key] := exhaleMask#_1225[this#178, AVLTreeNode.key][perm$R := exhaleMask#_1225[this#178, AVLTreeNode.key][perm$R] - fraction#_1226];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1225);
  fraction#_1227 := 100;
  assert {:msg "  832.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1227 <= exhaleMask#_1225[this#178, AVLTreeNode.height][perm$R]) && ((fraction#_1227 == exhaleMask#_1225[this#178, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1225[this#178, AVLTreeNode.height][perm$N]));
  exhaleMask#_1225[this#178, AVLTreeNode.height] := exhaleMask#_1225[this#178, AVLTreeNode.height][perm$R := exhaleMask#_1225[this#178, AVLTreeNode.height][perm$R] - fraction#_1227];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1225);
  fraction#_1228 := 100;
  assert {:msg "  832.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1228 <= exhaleMask#_1225[this#178, AVLTreeNode.left][perm$R]) && ((fraction#_1228 == exhaleMask#_1225[this#178, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1225[this#178, AVLTreeNode.left][perm$N]));
  exhaleMask#_1225[this#178, AVLTreeNode.left] := exhaleMask#_1225[this#178, AVLTreeNode.left][perm$R := exhaleMask#_1225[this#178, AVLTreeNode.left][perm$R] - fraction#_1228];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1225);
  fraction#_1229 := 100;
  assert {:msg "  832.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1229 <= exhaleMask#_1225[this#178, AVLTreeNode.right][perm$R]) && ((fraction#_1229 == exhaleMask#_1225[this#178, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1225[this#178, AVLTreeNode.right][perm$N]));
  exhaleMask#_1225[this#178, AVLTreeNode.right] := exhaleMask#_1225[this#178, AVLTreeNode.right][perm$R := exhaleMask#_1225[this#178, AVLTreeNode.right][perm$R] - fraction#_1229];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1225);
  fraction#_1230 := 100;
  assert {:msg "  832.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1230 <= exhaleMask#_1225[this#178, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1230 == exhaleMask#_1225[this#178, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1225[this#178, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1225[this#178, AVLTreeNode.balanceFactor] := exhaleMask#_1225[this#178, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1225[this#178, AVLTreeNode.balanceFactor][perm$R] - fraction#_1230];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1225);
  if (!(Heap[this#178, AVLTreeNode.left] == null)) {
    fraction#_1231 := 100;
    assert {:msg "  832.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1231 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1231 == exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1231];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1225);
  } else {
  }
  if (!(Heap[this#178, AVLTreeNode.left] == null)) {
    fraction#_1232 := 50;
    assert {:msg "  832.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1232 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1232 == exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1232];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1225);
  } else {
  }
  if (!(Heap[this#178, AVLTreeNode.left] == null)) {
    fraction#_1233 := 50;
    assert {:msg "  832.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1233 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1233 == exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1225[Heap[this#178, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1233];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1225);
  } else {
  }
  if (!(Heap[this#178, AVLTreeNode.right] == null)) {
    fraction#_1234 := 100;
    assert {:msg "  832.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1234 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1234 == exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1234];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1225);
  } else {
  }
  if (!(Heap[this#178, AVLTreeNode.right] == null)) {
    fraction#_1235 := 50;
    assert {:msg "  832.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1235 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1235 == exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1235];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1225);
  } else {
  }
  if (!(Heap[this#178, AVLTreeNode.right] == null)) {
    fraction#_1236 := 50;
    assert {:msg "  832.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1236 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1236 == exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1225[Heap[this#178, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1236];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1225);
  } else {
  }
  assert {:msg "  832.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#178, AVLTreeNode.left] == null, 0, Heap[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#178, AVLTreeNode.right] == null, 0, Heap[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  832.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#178, AVLTreeNode.left] == null, 0, Heap[Heap[this#178, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#178, AVLTreeNode.right] == null, 0, Heap[Heap[this#178, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1225;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1239;
  assume IsGoodInhaleState(inhaleHeap#_1239, Heap, Mask);
  assume this#178 != null;
  Heap[this#178, AVLTreeNode.valid] := inhaleHeap#_1239[this#178, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1239[this#178, AVLTreeNode.valid] == Heap;
  Mask[this#178, AVLTreeNode.valid] := Mask[this#178, AVLTreeNode.valid][perm$R := Mask[this#178, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1239[this#178, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1239, Mask);
  assume this#178 != null;
  Heap[this#178, AVLTreeNode.height] := inhaleHeap#_1239[this#178, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#178, AVLTreeNode.height] := Mask[this#178, AVLTreeNode.height][perm$R := Mask[this#178, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1239[this#178, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1239, Mask);
  assume this#178 != null;
  Heap[this#178, AVLTreeNode.balanceFactor] := inhaleHeap#_1239[this#178, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#178, AVLTreeNode.balanceFactor] := Mask[this#178, AVLTreeNode.balanceFactor][perm$R := Mask[this#178, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1239[this#178, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1239, Mask);
  assume Heap[this#178, AVLTreeNode.height] == ite(ite(callHeap#_1222[this#178, AVLTreeNode.left] == null, 0, callHeap#_1222[callHeap#_1222[this#178, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1222[this#178, AVLTreeNode.right] == null, 0, callHeap#_1222[callHeap#_1222[this#178, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1222[this#178, AVLTreeNode.left] == null, 0, callHeap#_1222[callHeap#_1222[this#178, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1222[this#178, AVLTreeNode.right] == null, 0, callHeap#_1222[callHeap#_1222[this#178, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#178, AVLTreeNode.balanceFactor] == (ite(callHeap#_1222[this#178, AVLTreeNode.left] == null, 0, callHeap#_1222[callHeap#_1222[this#178, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1222[this#178, AVLTreeNode.right] == null, 0, callHeap#_1222[callHeap#_1222[this#178, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1240 := Mask;
  fraction#_1241 := 100;
  assert {:msg "  784.2: The postcondition at 811.11 might not hold. Insufficient fraction at 811.11 for AVLTreeNode.valid."} (fraction#_1241 <= exhaleMask#_1240[r#71, AVLTreeNode.valid][perm$R]) && ((fraction#_1241 == exhaleMask#_1240[r#71, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1240[r#71, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1240[r#71, AVLTreeNode.valid] := exhaleMask#_1240[r#71, AVLTreeNode.valid][perm$R := exhaleMask#_1240[r#71, AVLTreeNode.valid][perm$R] - fraction#_1241];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1240);
  fraction#_1242 := 50;
  assert {:msg "  784.2: The postcondition at 812.11 might not hold. Insufficient fraction at 812.11 for AVLTreeNode.height."} (fraction#_1242 <= exhaleMask#_1240[r#71, AVLTreeNode.height][perm$R]) && ((fraction#_1242 == exhaleMask#_1240[r#71, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1240[r#71, AVLTreeNode.height][perm$N]));
  exhaleMask#_1240[r#71, AVLTreeNode.height] := exhaleMask#_1240[r#71, AVLTreeNode.height][perm$R := exhaleMask#_1240[r#71, AVLTreeNode.height][perm$R] - fraction#_1242];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1240);
  fraction#_1243 := 50;
  assert {:msg "  784.2: The postcondition at 814.11 might not hold. Insufficient fraction at 814.11 for AVLTreeNode.balanceFactor."} (fraction#_1243 <= exhaleMask#_1240[r#71, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1243 == exhaleMask#_1240[r#71, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1240[r#71, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1240[r#71, AVLTreeNode.balanceFactor] := exhaleMask#_1240[r#71, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1240[r#71, AVLTreeNode.balanceFactor][perm$R] - fraction#_1243];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1240);
  assert {:msg "  784.2: The postcondition at 816.11 might not hold. The expression at 816.11 might not evaluate to true."} Heap[r#71, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height];
  Mask := exhaleMask#_1240;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  784.2: Method might lock/unlock more than allowed."} (forall lk#_1244: ref :: {Heap[lk#_1244, held]} {Heap[lk#_1244, rdheld]} (((0 < Heap[lk#_1244, held]) == (0 < old(Heap)[lk#_1244, held])) && (Heap[lk#_1244, rdheld] == old(Heap)[lk#_1244, rdheld])) || false);
  assert {:msg "  784.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure AVLTreeNode.rebalanceLL$checkDefinedness(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#72: ref where (r#72 == null) || (dtype(r#72) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1245: HeapType;
  var inhaleHeap#_1246: HeapType;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1245;
  assume IsGoodInhaleState(inhaleHeap#_1245, Heap, Mask);
  assert {:msg "  839.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  839.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1245[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  840.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  840.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1245[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  841.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  841.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1245[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  842.23: Fraction might be negative."} 0 <= 100;
  assert {:msg "  842.23: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1245[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  845.30: Fraction might be negative."} 0 <= 100;
  assert {:msg "  845.30: Fraction might exceed 100."} 100 <= 100;
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1245[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  847.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  847.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  847.25: Receiver might be null."} true ==> (this != null);
    assert {:msg "  847.25: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1245, Mask);
  } else {
  }
  assert {:msg "  848.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  848.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  848.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  848.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  848.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  848.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1245, Mask);
  } else {
  }
  assert {:msg "  850.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  850.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assert {:msg "  850.29: Receiver might be null."} true ==> (this != null);
    assert {:msg "  850.29: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  850.48: Fraction might be negative."} 0 <= 50;
    assert {:msg "  850.48: Fraction might exceed 100."} 50 <= 100;
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1245[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1245, Mask);
  } else {
  }
  assert {:msg "  853.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  853.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume !(Heap[this, AVLTreeNode.right] == null);
  assert {:msg "  854.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  854.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  855.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  855.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  855.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  855.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  857.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  857.16: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  857.36: Fraction might be negative."} 0 <= 50;
  assert {:msg "  857.36: Fraction might exceed 100."} 50 <= 100;
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1245[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1245, Mask);
  assert {:msg "  860.13: Receiver might be null."} true ==> (this != null);
  assert {:msg "  860.13: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
  if (Heap[this, AVLTreeNode.left] == null) {
  } else {
    assert {:msg "  860.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  860.26: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.left);
    assert {:msg "  860.26: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.left] != null);
    assert {:msg "  860.26: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.left], AVLTreeNode.height);
  }
  assert {:msg "  860.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  860.39: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  860.39: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  860.39: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assert {:msg "  861.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  861.12: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  861.12: Receiver might be null."} true ==> (Heap[this, AVLTreeNode.right] != null);
  assert {:msg "  861.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1246;
  assume IsGoodInhaleState(inhaleHeap#_1246, Heap, Mask);
  assume r#72 != null;
  Heap[r#72, AVLTreeNode.valid] := inhaleHeap#_1246[r#72, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1246[r#72, AVLTreeNode.valid] == Heap;
  Mask[r#72, AVLTreeNode.valid] := Mask[r#72, AVLTreeNode.valid][perm$R := Mask[r#72, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1246[r#72, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1246, Mask);
  assert {:msg "  864.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  864.31: Fraction might exceed 100."} 50 <= 100;
  assume r#72 != null;
  Heap[r#72, AVLTreeNode.height] := inhaleHeap#_1246[r#72, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#72, AVLTreeNode.height] := Mask[r#72, AVLTreeNode.height][perm$R := Mask[r#72, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1246[r#72, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1246, Mask);
  assert {:msg "  866.31: Fraction might be negative."} 0 <= 50;
  assert {:msg "  866.31: Fraction might exceed 100."} 50 <= 100;
  assume r#72 != null;
  Heap[r#72, AVLTreeNode.balanceFactor] := inhaleHeap#_1246[r#72, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[r#72, AVLTreeNode.balanceFactor] := Mask[r#72, AVLTreeNode.balanceFactor][perm$R := Mask[r#72, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1246[r#72, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1246, Mask);
  assert {:msg "  868.11: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  868.11: Location might not be readable."} true ==> CanRead(Mask, r#72, AVLTreeNode.height);
  assert {:msg "  868.27: Receiver might be null."} true ==> (this != null);
  assert {:msg "  868.27: Location might not be readable."} true ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  868.27: Receiver might be null."} true ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  868.27: Location might not be readable."} true ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assert {:msg "  868.44: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (r#72 != null);
  assert {:msg "  868.44: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(Mask, r#72, AVLTreeNode.height);
  assert {:msg "  868.60: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (this != null);
  assert {:msg "  868.60: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), this, AVLTreeNode.right);
  assert {:msg "  868.60: Receiver might be null."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> (old(Heap)[this, AVLTreeNode.right] != null);
  assert {:msg "  868.60: Location might not be readable."} true && (!(Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height])) ==> CanRead(old(Mask), old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height);
  assume (Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#72, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure AVLTreeNode.rebalanceLL(this: ref where (this == null) || (dtype(this) == AVLTreeNode#t)) returns (r#72: ref where (r#72 == null) || (dtype(r#72) == AVLTreeNode#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var inhaleHeap#_1247: HeapType;
  var exhaleMask#_1248: MaskType;
  var fraction#_1249: int;
  var inhaleHeap#_1250: HeapType;
  var this#179: ref where (this#179 == null) || (dtype(this#179) == AVLTreeNode#t);
  var callHeap#_1251: HeapType;
  var callMask#_1252: MaskType;
  var callCredits#_1253: CreditsType;
  var exhaleMask#_1254: MaskType;
  var fraction#_1255: int;
  var fraction#_1256: int;
  var fraction#_1257: int;
  var fraction#_1258: int;
  var fraction#_1259: int;
  var fraction#_1260: int;
  var fraction#_1261: int;
  var fraction#_1262: int;
  var fraction#_1263: int;
  var fraction#_1264: int;
  var fraction#_1265: int;
  var isHeld#_1266: int;
  var isRdHeld#_1267: bool;
  var inhaleHeap#_1268: HeapType;
  var this#180: ref where (this#180 == null) || (dtype(this#180) == AVLTreeNode#t);
  var callHeap#_1269: HeapType;
  var callMask#_1270: MaskType;
  var callCredits#_1271: CreditsType;
  var exhaleMask#_1272: MaskType;
  var fraction#_1273: int;
  var fraction#_1274: int;
  var fraction#_1275: int;
  var fraction#_1276: int;
  var fraction#_1277: int;
  var fraction#_1278: int;
  var fraction#_1279: int;
  var fraction#_1280: int;
  var fraction#_1281: int;
  var fraction#_1282: int;
  var fraction#_1283: int;
  var isHeld#_1284: int;
  var isRdHeld#_1285: bool;
  var inhaleHeap#_1286: HeapType;
  var exhaleMask#_1287: MaskType;
  var fraction#_1288: int;
  var fraction#_1289: int;
  var fraction#_1290: int;
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1247;
  assume IsGoodInhaleState(inhaleHeap#_1247, Heap, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.key] := inhaleHeap#_1247[this, AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.key] := Mask[this, AVLTreeNode.key][perm$R := Mask[this, AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[this, AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.height] := inhaleHeap#_1247[this, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.height] := Mask[this, AVLTreeNode.height][perm$R := Mask[this, AVLTreeNode.height][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[this, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.left] := inhaleHeap#_1247[this, AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.left] == null) || (dtype(Heap[this, AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.left] := Mask[this, AVLTreeNode.left][perm$R := Mask[this, AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[this, AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.right] := inhaleHeap#_1247[this, AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[this, AVLTreeNode.right] == null) || (dtype(Heap[this, AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[this, AVLTreeNode.right] := Mask[this, AVLTreeNode.right][perm$R := Mask[this, AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[this, AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume this != null;
  Heap[this, AVLTreeNode.balanceFactor] := inhaleHeap#_1247[this, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this, AVLTreeNode.balanceFactor] := Mask[this, AVLTreeNode.balanceFactor][perm$R := Mask[this, AVLTreeNode.balanceFactor][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[this, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1247, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1247, Mask);
  } else {
  }
  if (!(Heap[this, AVLTreeNode.left] == null)) {
    assume Heap[this, AVLTreeNode.left] != null;
    Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1247[Heap[this, AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1247, Mask);
  } else {
  }
  assume !(Heap[this, AVLTreeNode.right] == null);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] == Heap;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1247[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1247, Mask);
  assume (ite(Heap[this, AVLTreeNode.left] == null, 0, Heap[Heap[this, AVLTreeNode.left], AVLTreeNode.height]) - Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height]) == (0 - 2);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assert {:msg "  871.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  871.10: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  assert {:msg "  871.3: The target of the fold statement might be null."} Heap[this, AVLTreeNode.right] != null;
  // begin exhale (unfold)
  exhaleMask#_1248 := Mask;
  fraction#_1249 := 100;
  assert {:msg "  871.3: unfold might fail because the predicate AVLTreeNode.valid does not hold. Insufficient fraction at <undefined position> for AVLTreeNode.valid."} (fraction#_1249 <= exhaleMask#_1248[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1249 == exhaleMask#_1248[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1248[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
  exhaleMask#_1248[Heap[this, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1248[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1248[Heap[this, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1249];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1248);
  Mask := exhaleMask#_1248;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1250 := Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.valid];
  assume IsGoodInhaleState(inhaleHeap#_1250, Heap, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.key];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.key][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.key]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1250, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1250, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.left];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.left][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.left]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1250, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.right];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null) || (dtype(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right]) == AVLTreeNode#t);
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.right][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.right]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1250, Mask);
  assume Heap[this, AVLTreeNode.right] != null;
  Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1250[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1250, Mask);
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1250, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1250, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1250, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height] > 0;
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] == Heap;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid][perm$R] + 100];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1250, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1250, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] != null;
    Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor];
    assume wf(Heap, Mask);
    assume true;
    Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor] := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := Mask[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] + 50];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1250[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.balanceFactor]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1250, Mask);
  } else {
  }
  if (!(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null)) {
    assume Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height] > 0;
  } else {
  }
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] == ite(ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) > ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]), ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] == (ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right] == null, 0, Heap[Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.right], AVLTreeNode.height]));
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] <= 1;
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.balanceFactor] >= (0 - 1);
  assume Heap[Heap[this, AVLTreeNode.right], AVLTreeNode.height] > 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // assigment to r
  assert {:msg "  872.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  872.14: Location might not be readable."} true ==> CanRead(Mask, this, AVLTreeNode.right);
  r#72 := Heap[this, AVLTreeNode.right];
  // update field right
  assert {:msg "  873.3: Location might not be writable"} CanWrite(Mask, this, AVLTreeNode.right);
  assert {:msg "  873.15: Receiver might be null."} true ==> (r#72 != null);
  assert {:msg "  873.15: Location might not be readable."} true ==> CanRead(Mask, r#72, AVLTreeNode.left);
  Heap[this, AVLTreeNode.right] := Heap[r#72, AVLTreeNode.left];
  assume wf(Heap, Mask);
  // call close
  callHeap#_1251 := Heap;
  callMask#_1252 := Mask;
  callCredits#_1253 := Credits;
  assert {:msg "  874.3: The target of the method call might be null."} this != null;
  this#179 := this;
  // begin exhale (precondition)
  exhaleMask#_1254 := Mask;
  fraction#_1255 := 100;
  assert {:msg "  874.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1255 <= exhaleMask#_1254[this#179, AVLTreeNode.key][perm$R]) && ((fraction#_1255 == exhaleMask#_1254[this#179, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1254[this#179, AVLTreeNode.key][perm$N]));
  exhaleMask#_1254[this#179, AVLTreeNode.key] := exhaleMask#_1254[this#179, AVLTreeNode.key][perm$R := exhaleMask#_1254[this#179, AVLTreeNode.key][perm$R] - fraction#_1255];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1254);
  fraction#_1256 := 100;
  assert {:msg "  874.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1256 <= exhaleMask#_1254[this#179, AVLTreeNode.height][perm$R]) && ((fraction#_1256 == exhaleMask#_1254[this#179, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1254[this#179, AVLTreeNode.height][perm$N]));
  exhaleMask#_1254[this#179, AVLTreeNode.height] := exhaleMask#_1254[this#179, AVLTreeNode.height][perm$R := exhaleMask#_1254[this#179, AVLTreeNode.height][perm$R] - fraction#_1256];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1254);
  fraction#_1257 := 100;
  assert {:msg "  874.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1257 <= exhaleMask#_1254[this#179, AVLTreeNode.left][perm$R]) && ((fraction#_1257 == exhaleMask#_1254[this#179, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1254[this#179, AVLTreeNode.left][perm$N]));
  exhaleMask#_1254[this#179, AVLTreeNode.left] := exhaleMask#_1254[this#179, AVLTreeNode.left][perm$R := exhaleMask#_1254[this#179, AVLTreeNode.left][perm$R] - fraction#_1257];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1254);
  fraction#_1258 := 100;
  assert {:msg "  874.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1258 <= exhaleMask#_1254[this#179, AVLTreeNode.right][perm$R]) && ((fraction#_1258 == exhaleMask#_1254[this#179, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1254[this#179, AVLTreeNode.right][perm$N]));
  exhaleMask#_1254[this#179, AVLTreeNode.right] := exhaleMask#_1254[this#179, AVLTreeNode.right][perm$R := exhaleMask#_1254[this#179, AVLTreeNode.right][perm$R] - fraction#_1258];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1254);
  fraction#_1259 := 100;
  assert {:msg "  874.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1259 <= exhaleMask#_1254[this#179, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1259 == exhaleMask#_1254[this#179, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1254[this#179, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1254[this#179, AVLTreeNode.balanceFactor] := exhaleMask#_1254[this#179, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1254[this#179, AVLTreeNode.balanceFactor][perm$R] - fraction#_1259];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1254);
  if (!(Heap[this#179, AVLTreeNode.left] == null)) {
    fraction#_1260 := 100;
    assert {:msg "  874.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1260 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1260 == exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1260];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1254);
  } else {
  }
  if (!(Heap[this#179, AVLTreeNode.left] == null)) {
    fraction#_1261 := 50;
    assert {:msg "  874.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1261 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1261 == exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1261];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1254);
  } else {
  }
  if (!(Heap[this#179, AVLTreeNode.left] == null)) {
    fraction#_1262 := 50;
    assert {:msg "  874.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1262 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1262 == exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1254[Heap[this#179, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1262];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1254);
  } else {
  }
  if (!(Heap[this#179, AVLTreeNode.right] == null)) {
    fraction#_1263 := 100;
    assert {:msg "  874.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1263 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1263 == exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1263];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1254);
  } else {
  }
  if (!(Heap[this#179, AVLTreeNode.right] == null)) {
    fraction#_1264 := 50;
    assert {:msg "  874.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1264 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1264 == exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1264];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1254);
  } else {
  }
  if (!(Heap[this#179, AVLTreeNode.right] == null)) {
    fraction#_1265 := 50;
    assert {:msg "  874.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1265 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1265 == exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1254[Heap[this#179, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1265];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1254);
  } else {
  }
  assert {:msg "  874.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#179, AVLTreeNode.left] == null, 0, Heap[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#179, AVLTreeNode.right] == null, 0, Heap[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  874.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#179, AVLTreeNode.left] == null, 0, Heap[Heap[this#179, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#179, AVLTreeNode.right] == null, 0, Heap[Heap[this#179, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1254;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1268;
  assume IsGoodInhaleState(inhaleHeap#_1268, Heap, Mask);
  assume this#179 != null;
  Heap[this#179, AVLTreeNode.valid] := inhaleHeap#_1268[this#179, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1268[this#179, AVLTreeNode.valid] == Heap;
  Mask[this#179, AVLTreeNode.valid] := Mask[this#179, AVLTreeNode.valid][perm$R := Mask[this#179, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1268[this#179, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1268, Mask);
  assume this#179 != null;
  Heap[this#179, AVLTreeNode.height] := inhaleHeap#_1268[this#179, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#179, AVLTreeNode.height] := Mask[this#179, AVLTreeNode.height][perm$R := Mask[this#179, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1268[this#179, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1268, Mask);
  assume this#179 != null;
  Heap[this#179, AVLTreeNode.balanceFactor] := inhaleHeap#_1268[this#179, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#179, AVLTreeNode.balanceFactor] := Mask[this#179, AVLTreeNode.balanceFactor][perm$R := Mask[this#179, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1268[this#179, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1268, Mask);
  assume Heap[this#179, AVLTreeNode.height] == ite(ite(callHeap#_1251[this#179, AVLTreeNode.left] == null, 0, callHeap#_1251[callHeap#_1251[this#179, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1251[this#179, AVLTreeNode.right] == null, 0, callHeap#_1251[callHeap#_1251[this#179, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1251[this#179, AVLTreeNode.left] == null, 0, callHeap#_1251[callHeap#_1251[this#179, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1251[this#179, AVLTreeNode.right] == null, 0, callHeap#_1251[callHeap#_1251[this#179, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#179, AVLTreeNode.balanceFactor] == (ite(callHeap#_1251[this#179, AVLTreeNode.left] == null, 0, callHeap#_1251[callHeap#_1251[this#179, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1251[this#179, AVLTreeNode.right] == null, 0, callHeap#_1251[callHeap#_1251[this#179, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field left
  assert {:msg "  875.3: Location might not be writable"} CanWrite(Mask, r#72, AVLTreeNode.left);
  Heap[r#72, AVLTreeNode.left] := this;
  assume wf(Heap, Mask);
  // call close
  callHeap#_1269 := Heap;
  callMask#_1270 := Mask;
  callCredits#_1271 := Credits;
  assert {:msg "  876.3: The target of the method call might be null."} r#72 != null;
  this#180 := r#72;
  // begin exhale (precondition)
  exhaleMask#_1272 := Mask;
  fraction#_1273 := 100;
  assert {:msg "  876.3: The precondition at 542.12 might not hold. Insufficient fraction at 542.12 for AVLTreeNode.key."} (fraction#_1273 <= exhaleMask#_1272[this#180, AVLTreeNode.key][perm$R]) && ((fraction#_1273 == exhaleMask#_1272[this#180, AVLTreeNode.key][perm$R]) ==> (0 <= exhaleMask#_1272[this#180, AVLTreeNode.key][perm$N]));
  exhaleMask#_1272[this#180, AVLTreeNode.key] := exhaleMask#_1272[this#180, AVLTreeNode.key][perm$R := exhaleMask#_1272[this#180, AVLTreeNode.key][perm$R] - fraction#_1273];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1272);
  fraction#_1274 := 100;
  assert {:msg "  876.3: The precondition at 543.12 might not hold. Insufficient fraction at 543.12 for AVLTreeNode.height."} (fraction#_1274 <= exhaleMask#_1272[this#180, AVLTreeNode.height][perm$R]) && ((fraction#_1274 == exhaleMask#_1272[this#180, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1272[this#180, AVLTreeNode.height][perm$N]));
  exhaleMask#_1272[this#180, AVLTreeNode.height] := exhaleMask#_1272[this#180, AVLTreeNode.height][perm$R := exhaleMask#_1272[this#180, AVLTreeNode.height][perm$R] - fraction#_1274];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1272);
  fraction#_1275 := 100;
  assert {:msg "  876.3: The precondition at 544.12 might not hold. Insufficient fraction at 544.12 for AVLTreeNode.left."} (fraction#_1275 <= exhaleMask#_1272[this#180, AVLTreeNode.left][perm$R]) && ((fraction#_1275 == exhaleMask#_1272[this#180, AVLTreeNode.left][perm$R]) ==> (0 <= exhaleMask#_1272[this#180, AVLTreeNode.left][perm$N]));
  exhaleMask#_1272[this#180, AVLTreeNode.left] := exhaleMask#_1272[this#180, AVLTreeNode.left][perm$R := exhaleMask#_1272[this#180, AVLTreeNode.left][perm$R] - fraction#_1275];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1272);
  fraction#_1276 := 100;
  assert {:msg "  876.3: The precondition at 545.12 might not hold. Insufficient fraction at 545.12 for AVLTreeNode.right."} (fraction#_1276 <= exhaleMask#_1272[this#180, AVLTreeNode.right][perm$R]) && ((fraction#_1276 == exhaleMask#_1272[this#180, AVLTreeNode.right][perm$R]) ==> (0 <= exhaleMask#_1272[this#180, AVLTreeNode.right][perm$N]));
  exhaleMask#_1272[this#180, AVLTreeNode.right] := exhaleMask#_1272[this#180, AVLTreeNode.right][perm$R := exhaleMask#_1272[this#180, AVLTreeNode.right][perm$R] - fraction#_1276];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1272);
  fraction#_1277 := 100;
  assert {:msg "  876.3: The precondition at 548.12 might not hold. Insufficient fraction at 548.12 for AVLTreeNode.balanceFactor."} (fraction#_1277 <= exhaleMask#_1272[this#180, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1277 == exhaleMask#_1272[this#180, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1272[this#180, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1272[this#180, AVLTreeNode.balanceFactor] := exhaleMask#_1272[this#180, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1272[this#180, AVLTreeNode.balanceFactor][perm$R] - fraction#_1277];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1272);
  if (!(Heap[this#180, AVLTreeNode.left] == null)) {
    fraction#_1278 := 100;
    assert {:msg "  876.3: The precondition at 550.12 might not hold. Insufficient fraction at 550.27 for AVLTreeNode.valid."} (fraction#_1278 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) && ((fraction#_1278 == exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.valid] := exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.valid][perm$R := exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.valid][perm$R] - fraction#_1278];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1272);
  } else {
  }
  if (!(Heap[this#180, AVLTreeNode.left] == null)) {
    fraction#_1279 := 50;
    assert {:msg "  876.3: The precondition at 551.12 might not hold. Insufficient fraction at 551.27 for AVLTreeNode.height."} (fraction#_1279 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height][perm$R]) && ((fraction#_1279 == exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height][perm$N]));
    exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height] := exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height][perm$R := exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height][perm$R] - fraction#_1279];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1272);
  } else {
  }
  if (!(Heap[this#180, AVLTreeNode.left] == null)) {
    fraction#_1280 := 50;
    assert {:msg "  876.3: The precondition at 553.12 might not hold. Insufficient fraction at 553.27 for AVLTreeNode.balanceFactor."} (fraction#_1280 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1280 == exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.balanceFactor] := exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1272[Heap[this#180, AVLTreeNode.left], AVLTreeNode.balanceFactor][perm$R] - fraction#_1280];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1272);
  } else {
  }
  if (!(Heap[this#180, AVLTreeNode.right] == null)) {
    fraction#_1281 := 100;
    assert {:msg "  876.3: The precondition at 556.12 might not hold. Insufficient fraction at 556.28 for AVLTreeNode.valid."} (fraction#_1281 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) && ((fraction#_1281 == exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.valid][perm$N]));
    exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.valid] := exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.valid][perm$R := exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.valid][perm$R] - fraction#_1281];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1272);
  } else {
  }
  if (!(Heap[this#180, AVLTreeNode.right] == null)) {
    fraction#_1282 := 50;
    assert {:msg "  876.3: The precondition at 557.12 might not hold. Insufficient fraction at 557.28 for AVLTreeNode.height."} (fraction#_1282 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height][perm$R]) && ((fraction#_1282 == exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height][perm$N]));
    exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height] := exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height][perm$R := exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height][perm$R] - fraction#_1282];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1272);
  } else {
  }
  if (!(Heap[this#180, AVLTreeNode.right] == null)) {
    fraction#_1283 := 50;
    assert {:msg "  876.3: The precondition at 559.12 might not hold. Insufficient fraction at 559.28 for AVLTreeNode.balanceFactor."} (fraction#_1283 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1283 == exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$N]));
    exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.balanceFactor] := exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1272[Heap[this#180, AVLTreeNode.right], AVLTreeNode.balanceFactor][perm$R] - fraction#_1283];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1272);
  } else {
  }
  assert {:msg "  876.3: The precondition at 562.12 might not hold. The expression at 562.12 might not evaluate to true."} (ite(Heap[this#180, AVLTreeNode.left] == null, 0, Heap[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#180, AVLTreeNode.right] == null, 0, Heap[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height])) <= 1;
  assert {:msg "  876.3: The precondition at 563.12 might not hold. The expression at 563.12 might not evaluate to true."} (ite(Heap[this#180, AVLTreeNode.left] == null, 0, Heap[Heap[this#180, AVLTreeNode.left], AVLTreeNode.height]) - ite(Heap[this#180, AVLTreeNode.right] == null, 0, Heap[Heap[this#180, AVLTreeNode.right], AVLTreeNode.height])) >= (0 - 1);
  Mask := exhaleMask#_1272;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1286;
  assume IsGoodInhaleState(inhaleHeap#_1286, Heap, Mask);
  assume this#180 != null;
  Heap[this#180, AVLTreeNode.valid] := inhaleHeap#_1286[this#180, AVLTreeNode.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1286[this#180, AVLTreeNode.valid] == Heap;
  Mask[this#180, AVLTreeNode.valid] := Mask[this#180, AVLTreeNode.valid][perm$R := Mask[this#180, AVLTreeNode.valid][perm$R] + 100];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1286[this#180, AVLTreeNode.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1286, Mask);
  assume this#180 != null;
  Heap[this#180, AVLTreeNode.height] := inhaleHeap#_1286[this#180, AVLTreeNode.height];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#180, AVLTreeNode.height] := Mask[this#180, AVLTreeNode.height][perm$R := Mask[this#180, AVLTreeNode.height][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1286[this#180, AVLTreeNode.height]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1286, Mask);
  assume this#180 != null;
  Heap[this#180, AVLTreeNode.balanceFactor] := inhaleHeap#_1286[this#180, AVLTreeNode.balanceFactor];
  assume wf(Heap, Mask);
  assume true;
  Mask[this#180, AVLTreeNode.balanceFactor] := Mask[this#180, AVLTreeNode.balanceFactor][perm$R := Mask[this#180, AVLTreeNode.balanceFactor][perm$R] + 50];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1286[this#180, AVLTreeNode.balanceFactor]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1286, Mask);
  assume Heap[this#180, AVLTreeNode.height] == ite(ite(callHeap#_1269[this#180, AVLTreeNode.left] == null, 0, callHeap#_1269[callHeap#_1269[this#180, AVLTreeNode.left], AVLTreeNode.height]) > ite(callHeap#_1269[this#180, AVLTreeNode.right] == null, 0, callHeap#_1269[callHeap#_1269[this#180, AVLTreeNode.right], AVLTreeNode.height]), ite(callHeap#_1269[this#180, AVLTreeNode.left] == null, 0, callHeap#_1269[callHeap#_1269[this#180, AVLTreeNode.left], AVLTreeNode.height]) + 1, ite(callHeap#_1269[this#180, AVLTreeNode.right] == null, 0, callHeap#_1269[callHeap#_1269[this#180, AVLTreeNode.right], AVLTreeNode.height]) + 1);
  assume Heap[this#180, AVLTreeNode.balanceFactor] == (ite(callHeap#_1269[this#180, AVLTreeNode.left] == null, 0, callHeap#_1269[callHeap#_1269[this#180, AVLTreeNode.left], AVLTreeNode.height]) - ite(callHeap#_1269[this#180, AVLTreeNode.right] == null, 0, callHeap#_1269[callHeap#_1269[this#180, AVLTreeNode.right], AVLTreeNode.height]));
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1287 := Mask;
  fraction#_1288 := 100;
  assert {:msg "  838.2: The postcondition at 863.11 might not hold. Insufficient fraction at 863.11 for AVLTreeNode.valid."} (fraction#_1288 <= exhaleMask#_1287[r#72, AVLTreeNode.valid][perm$R]) && ((fraction#_1288 == exhaleMask#_1287[r#72, AVLTreeNode.valid][perm$R]) ==> (0 <= exhaleMask#_1287[r#72, AVLTreeNode.valid][perm$N]));
  exhaleMask#_1287[r#72, AVLTreeNode.valid] := exhaleMask#_1287[r#72, AVLTreeNode.valid][perm$R := exhaleMask#_1287[r#72, AVLTreeNode.valid][perm$R] - fraction#_1288];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1287);
  fraction#_1289 := 50;
  assert {:msg "  838.2: The postcondition at 864.11 might not hold. Insufficient fraction at 864.11 for AVLTreeNode.height."} (fraction#_1289 <= exhaleMask#_1287[r#72, AVLTreeNode.height][perm$R]) && ((fraction#_1289 == exhaleMask#_1287[r#72, AVLTreeNode.height][perm$R]) ==> (0 <= exhaleMask#_1287[r#72, AVLTreeNode.height][perm$N]));
  exhaleMask#_1287[r#72, AVLTreeNode.height] := exhaleMask#_1287[r#72, AVLTreeNode.height][perm$R := exhaleMask#_1287[r#72, AVLTreeNode.height][perm$R] - fraction#_1289];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1287);
  fraction#_1290 := 50;
  assert {:msg "  838.2: The postcondition at 866.11 might not hold. Insufficient fraction at 866.11 for AVLTreeNode.balanceFactor."} (fraction#_1290 <= exhaleMask#_1287[r#72, AVLTreeNode.balanceFactor][perm$R]) && ((fraction#_1290 == exhaleMask#_1287[r#72, AVLTreeNode.balanceFactor][perm$R]) ==> (0 <= exhaleMask#_1287[r#72, AVLTreeNode.balanceFactor][perm$N]));
  exhaleMask#_1287[r#72, AVLTreeNode.balanceFactor] := exhaleMask#_1287[r#72, AVLTreeNode.balanceFactor][perm$R := exhaleMask#_1287[r#72, AVLTreeNode.balanceFactor][perm$R] - fraction#_1290];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1287);
  assert {:msg "  838.2: The postcondition at 868.11 might not hold. The expression at 868.11 might not evaluate to true."} (Heap[r#72, AVLTreeNode.height] == old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height]) || (Heap[r#72, AVLTreeNode.height] == (old(Heap)[old(Heap)[this, AVLTreeNode.right], AVLTreeNode.height] + 1));
  Mask := exhaleMask#_1287;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  838.2: Method might lock/unlock more than allowed."} (forall lk#_1291: ref :: {Heap[lk#_1291, held]} {Heap[lk#_1291, rdheld]} (((0 < Heap[lk#_1291, held]) == (0 < old(Heap)[lk#_1291, held])) && (Heap[lk#_1291, rdheld] == old(Heap)[lk#_1291, rdheld])) || false);
  assert {:msg "  838.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
