// 
// Translation of SIL program.
// 
// Date:         2014-05-26 16:31:40
// Tool:         carbon 1.0
// Arguments: :  ..\..\AVLTree.sil
// Dependencies:
//   Boogie 2.2.30705.1126, located at C:\boogie\Binaries\Boogie.exe.
//   Z3 4.3.1, located at C:\Users\Alex\Documents\semperproject\Z3\Z3.exe.
// 

// ==================================================
// Preamble of State module.
// ==================================================

function state(Heap: HeapType, Mask: MaskType): bool;

// ==================================================
// Preamble of Heap module.
// ==================================================

type Ref;
var Heap: HeapType;
const null: Ref;
type Field A B;
type NormalField;
type HeapType = <A, B> [Ref, Field A B]B;
const unique $allocated: Field NormalField bool;
axiom (forall o: Ref, f: (Field NormalField Ref), Heap: HeapType, Mask: MaskType ::
  { state(Heap, Mask), Heap[o, f] }
  Heap[o, f] == null || Heap[Heap[o, f], $allocated]
);
function IdenticalOnKnownLocations(Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType): bool;
function IsPredicateField<A, B>(f_1: (Field A B)): bool;
// Frame all locations with direct permissions
axiom (forall <A, B> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, o: Ref, f_2: (Field A B) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), Heap[o, f_2] } { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), ExhaleHeap[o, f_2] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, o, f_2) ==> Heap[o, f_2] == ExhaleHeap[o, f_2]
);
// Frame all predicate mask locations of predicates with direct permission
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f: (Field C int) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsPredicateField(pm_f), ExhaleHeap[null, PredicateMaskField(pm_f)] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f) && IsPredicateField(pm_f) ==> Heap[null, PredicateMaskField(pm_f)] == ExhaleHeap[null, PredicateMaskField(pm_f)]
);
// Frame all locations with known folded permissions
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f: (Field C int) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), Heap[null, PredicateMaskField(pm_f)], IsPredicateField(pm_f) } { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), ExhaleHeap[null, PredicateMaskField(pm_f)], IsPredicateField(pm_f) } { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), AVLTree$MonitorInvariant#trigger(pm_f), IsPredicateField(pm_f) } { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), AVLTreevalid$#trigger(pm_f), IsPredicateField(pm_f) } { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), AVLTreeNode$MonitorInvariant#trigger(pm_f), IsPredicateField(pm_f) } { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), AVLTreeNodevalid$#trigger(pm_f), IsPredicateField(pm_f) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f) && IsPredicateField(pm_f) ==> (forall <A, B> o2: Ref, f_2: (Field A B) ::
    { Heap[o2, f_2] } { ExhaleHeap[o2, f_2] }
    Heap[null, PredicateMaskField(pm_f)][o2, f_2] ==> Heap[o2, f_2] == ExhaleHeap[o2, f_2]
  )
);

// ==================================================
// Preamble of Permission module.
// ==================================================

type PermComponent;
type Perm = [PermComponent]real;
const unique $frac: PermComponent;
const unique $eps: PermComponent;
type MaskType = <A, B> [Ref, Field A B]Perm;
var Mask: MaskType;
const ZeroMask: MaskType;
axiom (forall <A, B> o_1: Ref, f_3: (Field A B) ::
  { ZeroMask[o_1, f_3] }
  ZeroMask[o_1, f_3][$frac] == 0.000000000 && ZeroMask[o_1, f_3][$eps] == 0.000000000
);
type PMaskType = <A, B> [Ref, Field A B]bool;
const ZeroPMask: PMaskType;
axiom (forall <A, B> o_1: Ref, f_3: (Field A B) ::
  { ZeroPMask[o_1, f_3] }
  !ZeroPMask[o_1, f_3]
);
function PredicateMaskField<A>(f_4: (Field A int)): Field A PMaskType;
const NoPerm: Perm;
axiom NoPerm[$frac] == 0.000000000 && NoPerm[$eps] == 0.000000000;
const FullPerm: Perm;
axiom FullPerm[$frac] == 1.000000000 && FullPerm[$eps] == 0.000000000;
function PermAdd(a: Perm, b: Perm): Perm;
axiom (forall a: Perm, b: Perm, permComp: PermComponent ::
  { PermAdd(a, b)[permComp] }
  PermAdd(a, b)[permComp] == a[permComp] + b[permComp]
);
function PermSub(a: Perm, b: Perm): Perm;
axiom (forall a: Perm, b: Perm, permComp: PermComponent ::
  { PermSub(a, b)[permComp] }
  PermSub(a, b)[permComp] == a[permComp] - b[permComp]
);
function Perm(a: real, b: real): Perm;
axiom (forall a: real, b: real ::
  { Perm(a, b)[$frac] }
  Perm(a, b)[$frac] == a
);
axiom (forall a: real, b: real ::
  { Perm(a, b)[$eps] }
  Perm(a, b)[$eps] == b
);
function GoodMask(Mask: MaskType): bool;
axiom (forall Heap: HeapType, Mask: MaskType ::
  { state(Heap, Mask) }
  state(Heap, Mask) ==> GoodMask(Mask)
);
axiom (forall <A, B> Mask: MaskType, o_1: Ref, f_3: (Field A B) ::
  { GoodMask(Mask), Mask[o_1, f_3] }
  (((GoodMask(Mask) ==> Mask[o_1, f_3][$frac] >= 0.000000000) && (Mask[o_1, f_3][$frac] == 0.000000000 ==> Mask[o_1, f_3][$eps] >= 0.000000000)) && Mask[o_1, f_3][$frac] <= 1.000000000) && (Mask[o_1, f_3][$eps] > 0.000000000 ==> Mask[o_1, f_3][$frac] < 1.000000000)
);
function HasDirectPerm<A, B>(Mask: MaskType, o_1: Ref, f_3: (Field A B)): bool;
axiom (forall <A, B> Mask: MaskType, o_1: Ref, f_3: (Field A B) ::
  { HasDirectPerm(Mask, o_1, f_3) }
  HasDirectPerm(Mask, o_1, f_3) <==> Mask[o_1, f_3][$frac] > 0.000000000 || (Mask[o_1, f_3][$frac] == 0.000000000 && Mask[o_1, f_3][$eps] > 0.000000000)
);

// ==================================================
// Preamble of Function and predicate module.
// ==================================================

// Declarations for function framing
type FrameType;
const EmptyFrame: FrameType;
function FrameFragment<T>(t: T): FrameType;
function CombineFrames(a_1: FrameType, b_1: FrameType): FrameType;
// Function for recording enclosure of one predicate instance in another
function InsidePredicate<A, B>(x: Ref, p: (Field A int), v: int, y: Ref, q: (Field B int), w: int): bool;
const unique special_ref: Ref;
// Transitivity of InsidePredicate
axiom (forall <A, B, C> x: Ref, p: (Field A int), v: int, y: Ref, q: (Field B int), w: int, z: Ref, r: (Field C int), u: int ::
  { InsidePredicate(x, p, v, y, q, w), InsidePredicate(y, q, w, z, r, u) }
  InsidePredicate(x, p, v, y, q, w) && InsidePredicate(y, q, w, z, r, u) ==> InsidePredicate(x, p, v, z, r, u)
);
// Knowledge that two identical instances of the same predicate cannot be inside each other
axiom (forall <A> x: Ref, p: (Field A int), v: int, y: Ref, w: int ::
  { InsidePredicate(x, p, v, y, p, w) }
  InsidePredicate(x, p, v, y, p, w) ==> x != y
);

// ==================================================
// Preamble of Sequence module.
// ==================================================

type Seq_ T;

function Seq#Length<T>(Seq_ T): int;
axiom (forall<T> s: Seq_ T :: { Seq#Length(s) } 0 <= Seq#Length(s));

function Seq#Empty<T>(): Seq_ T;
axiom (forall<T> :: Seq#Length(Seq#Empty(): Seq_ T) == 0);
axiom (forall<T> s: Seq_ T :: { Seq#Length(s) } Seq#Length(s) == 0 ==> s == Seq#Empty());

function Seq#Singleton<T>(T): Seq_ T;
axiom (forall<T> t: T :: { Seq#Length(Seq#Singleton(t)) } Seq#Length(Seq#Singleton(t)) == 1);

function Seq#Append<T>(Seq_ T, Seq_ T): Seq_ T;
axiom (forall<T> s0: Seq_ T, s1: Seq_ T :: { Seq#Length(Seq#Append(s0,s1)) }
  Seq#Length(Seq#Append(s0,s1)) == Seq#Length(s0) + Seq#Length(s1));

function Seq#Index<T>(Seq_ T, int): T;
axiom (forall<T> t: T :: { Seq#Index(Seq#Singleton(t), 0) } Seq#Index(Seq#Singleton(t), 0) == t);
axiom (forall<T> s0: Seq_ T, s1: Seq_ T, n: int :: { Seq#Index(Seq#Append(s0,s1), n) }
  (n < Seq#Length(s0) ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s0, n)) &&
  (Seq#Length(s0) <= n ==> Seq#Index(Seq#Append(s0,s1), n) == Seq#Index(s1, n - Seq#Length(s0))));

function Seq#Update<T>(Seq_ T, int, T): Seq_ T;
axiom (forall<T> s: Seq_ T, i: int, v: T :: { Seq#Length(Seq#Update(s,i,v)) }
  0 <= i && i < Seq#Length(s) ==> Seq#Length(Seq#Update(s,i,v)) == Seq#Length(s));
axiom (forall<T> s: Seq_ T, i: int, v: T, n: int :: { Seq#Index(Seq#Update(s,i,v),n) }
  0 <= n && n < Seq#Length(s) ==>
    (i == n ==> Seq#Index(Seq#Update(s,i,v),n) == v) &&
    (i != n ==> Seq#Index(Seq#Update(s,i,v),n) == Seq#Index(s,n)));

function Seq#Contains<T>(Seq_ T, T): bool;
axiom (forall<T> s: Seq_ T, x: T :: { Seq#Contains(s,x) }
  Seq#Contains(s,x) <==>
    (exists i: int :: { Seq#Index(s,i) } 0 <= i && i < Seq#Length(s) && Seq#Index(s,i) == x));
axiom (forall x: Ref ::
  { Seq#Contains(Seq#Empty(), x) }
  !Seq#Contains(Seq#Empty(), x));
axiom (forall<T> s0: Seq_ T, s1: Seq_ T, x: T ::
  { Seq#Contains(Seq#Append(s0, s1), x) }
  Seq#Contains(Seq#Append(s0, s1), x) <==>
    Seq#Contains(s0, x) || Seq#Contains(s1, x));

axiom (forall<T> s: Seq_ T, n: int, x: T ::
  { Seq#Contains(Seq#Take(s, n), x) }
  Seq#Contains(Seq#Take(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= i && i < n && i < Seq#Length(s) && Seq#Index(s, i) == x));
axiom (forall<T> s: Seq_ T, n: int, x: T ::
  { Seq#Contains(Seq#Drop(s, n), x) }
  Seq#Contains(Seq#Drop(s, n), x) <==>
    (exists i: int :: { Seq#Index(s, i) }
      0 <= n && n <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

function Seq#Equal<T>(Seq_ T, Seq_ T): bool;
axiom (forall<T> s0: Seq_ T, s1: Seq_ T :: { Seq#Equal(s0,s1) }
  Seq#Equal(s0,s1) <==>
    Seq#Length(s0) == Seq#Length(s1) &&
    (forall j: int :: { Seq#Index(s0,j) } { Seq#Index(s1,j) }
        0 <= j && j < Seq#Length(s0) ==> Seq#Index(s0,j) == Seq#Index(s1,j)));
axiom (forall<T> a: Seq_ T, b: Seq_ T :: { Seq#Equal(a,b) }  // extensionality axiom for sequences
  Seq#Equal(a,b) ==> a == b);

function Seq#Take<T>(s: Seq_ T, howMany: int): Seq_ T;
axiom (forall<T> s: Seq_ T, n: int :: { Seq#Length(Seq#Take(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Take(s,n)) == n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Take(s,n)) == Seq#Length(s)));
axiom (forall<T> s: Seq_ T, n: int, j: int :: { Seq#Index(Seq#Take(s,n), j) } {:weight 25}
  0 <= j && j < n && j < Seq#Length(s) ==>
    Seq#Index(Seq#Take(s,n), j) == Seq#Index(s, j));

function Seq#Drop<T>(s: Seq_ T, howMany: int): Seq_ T;
axiom (forall<T> s: Seq_ T, n: int :: { Seq#Length(Seq#Drop(s,n)) }
  0 <= n ==>
    (n <= Seq#Length(s) ==> Seq#Length(Seq#Drop(s,n)) == Seq#Length(s) - n) &&
    (Seq#Length(s) < n ==> Seq#Length(Seq#Drop(s,n)) == 0));
axiom (forall<T> s: Seq_ T, n: int, j: int :: { Seq#Index(Seq#Drop(s,n), j) } {:weight 25}
  0 <= n && 0 <= j && j < Seq#Length(s)-n ==>
    Seq#Index(Seq#Drop(s,n), j) == Seq#Index(s, j+n));

axiom (forall<T> s, t: Seq_ T ::
  { Seq#Append(s, t) }
  Seq#Take(Seq#Append(s, t), Seq#Length(s)) == s &&
  Seq#Drop(Seq#Append(s, t), Seq#Length(s)) == t);

// Commutability of Take and Drop with Update.
axiom (forall<T> s: Seq_ T, i: int, v: T, n: int ::
  { Seq#Take(Seq#Update(s, i, v), n) }
    0 <= i && i < n && n <= Seq#Length(s) ==> Seq#Take(Seq#Update(s, i, v), n) == Seq#Update(Seq#Take(s, n), i, v) );
axiom (forall<T> s: Seq_ T, i: int, v: T, n: int ::
  { Seq#Take(Seq#Update(s, i, v), n) }
    n <= i && i < Seq#Length(s) ==> Seq#Take(Seq#Update(s, i, v), n) == Seq#Take(s, n));
axiom (forall<T> s: Seq_ T, i: int, v: T, n: int ::
  { Seq#Drop(Seq#Update(s, i, v), n) }
    0 <= n && n <= i && i < Seq#Length(s) ==> Seq#Drop(Seq#Update(s, i, v), n) == Seq#Update(Seq#Drop(s, n), i-n, v) );
axiom (forall<T> s: Seq_ T, i: int, v: T, n: int ::
  { Seq#Drop(Seq#Update(s, i, v), n) }
    0 <= i && i < n && n < Seq#Length(s) ==> Seq#Drop(Seq#Update(s, i, v), n) == Seq#Drop(s, n));

function Seq#Range(min: int, max: int) returns (Seq_ int);

axiom (forall min: int, max: int :: { Seq#Length(Seq#Range(min, max)) } (min < max ==> Seq#Length(Seq#Range(min, max)) == max-min) && (max <= min ==> Seq#Length(Seq#Range(min, max)) == 0));
axiom (forall min: int, max: int, j: int :: { Seq#Index(Seq#Range(min, max), j) } 0<=j && j<max-min ==> Seq#Index(Seq#Range(min, max), j) == min + j);

axiom (forall<T> x, y: T ::
  { Seq#Contains(Seq#Singleton(x),y) }
    Seq#Contains(Seq#Singleton(x),y) <==> x==y);


// ==================================================
// Preamble of Set module.
// ==================================================


type Set T = [T]bool;

function Set#Card<T>(Set T): int;
axiom (forall<T> s: Set T :: { Set#Card(s) } 0 <= Set#Card(s));

function Set#Empty<T>(): Set T;
axiom (forall<T> o: T :: { Set#Empty()[o] } !Set#Empty()[o]);
axiom (forall<T> s: Set T :: { Set#Card(s) }
  (Set#Card(s) == 0 <==> s == Set#Empty()) &&
  (Set#Card(s) != 0 ==> (exists x: T :: s[x])));

function Set#Singleton<T>(T): Set T;
axiom (forall<T> r: T :: { Set#Singleton(r) } Set#Singleton(r)[r]);
axiom (forall<T> r: T, o: T :: { Set#Singleton(r)[o] } Set#Singleton(r)[o] <==> r == o);
axiom (forall<T> r: T :: { Set#Card(Set#Singleton(r)) } Set#Card(Set#Singleton(r)) == 1);

function Set#UnionOne<T>(Set T, T): Set T;
axiom (forall<T> a: Set T, x: T, o: T :: { Set#UnionOne(a,x)[o] }
  Set#UnionOne(a,x)[o] <==> o == x || a[o]);
axiom (forall<T> a: Set T, x: T :: { Set#UnionOne(a, x) }
  Set#UnionOne(a, x)[x]);
axiom (forall<T> a: Set T, x: T, y: T :: { Set#UnionOne(a, x), a[y] }
  a[y] ==> Set#UnionOne(a, x)[y]);
axiom (forall<T> a: Set T, x: T :: { Set#Card(Set#UnionOne(a, x)) }
  a[x] ==> Set#Card(Set#UnionOne(a, x)) == Set#Card(a));
axiom (forall<T> a: Set T, x: T :: { Set#Card(Set#UnionOne(a, x)) }
  !a[x] ==> Set#Card(Set#UnionOne(a, x)) == Set#Card(a) + 1);

function Set#Union<T>(Set T, Set T): Set T;
axiom (forall<T> a: Set T, b: Set T, o: T :: { Set#Union(a,b)[o] }
  Set#Union(a,b)[o] <==> a[o] || b[o]);
axiom (forall<T> a, b: Set T, y: T :: { Set#Union(a, b), a[y] }
  a[y] ==> Set#Union(a, b)[y]);
axiom (forall<T> a, b: Set T, y: T :: { Set#Union(a, b), b[y] }
  b[y] ==> Set#Union(a, b)[y]);
axiom (forall<T> a, b: Set T :: { Set#Union(a, b) }
  Set#Disjoint(a, b) ==>
    Set#Difference(Set#Union(a, b), a) == b &&
    Set#Difference(Set#Union(a, b), b) == a);
// Follows from the general union axiom, but might be still worth including, because disjoint union is a common case:
// axiom (forall<T> a, b: Set T :: { Set#Card(Set#Union(a, b)) }
  // Set#Disjoint(a, b) ==>
    // Set#Card(Set#Union(a, b)) == Set#Card(a) + Set#Card(b));

function Set#Intersection<T>(Set T, Set T): Set T;
axiom (forall<T> a: Set T, b: Set T, o: T :: { Set#Intersection(a,b)[o] }
  Set#Intersection(a,b)[o] <==> a[o] && b[o]);

axiom (forall<T> a, b: Set T :: { Set#Union(Set#Union(a, b), b) }
  Set#Union(Set#Union(a, b), b) == Set#Union(a, b));
axiom (forall<T> a, b: Set T :: { Set#Union(a, Set#Union(a, b)) }
  Set#Union(a, Set#Union(a, b)) == Set#Union(a, b));
axiom (forall<T> a, b: Set T :: { Set#Intersection(Set#Intersection(a, b), b) }
  Set#Intersection(Set#Intersection(a, b), b) == Set#Intersection(a, b));
axiom (forall<T> a, b: Set T :: { Set#Intersection(a, Set#Intersection(a, b)) }
  Set#Intersection(a, Set#Intersection(a, b)) == Set#Intersection(a, b));
axiom (forall<T> a, b: Set T :: { Set#Card(Set#Union(a, b)) }{ Set#Card(Set#Intersection(a, b)) }
  Set#Card(Set#Union(a, b)) + Set#Card(Set#Intersection(a, b)) == Set#Card(a) + Set#Card(b));

function Set#Difference<T>(Set T, Set T): Set T;
axiom (forall<T> a: Set T, b: Set T, o: T :: { Set#Difference(a,b)[o] }
  Set#Difference(a,b)[o] <==> a[o] && !b[o]);
axiom (forall<T> a, b: Set T, y: T :: { Set#Difference(a, b), b[y] }
  b[y] ==> !Set#Difference(a, b)[y] );

function Set#Subset<T>(Set T, Set T): bool;
axiom(forall<T> a: Set T, b: Set T :: { Set#Subset(a,b) }
  Set#Subset(a,b) <==> (forall o: T :: {a[o]} {b[o]} a[o] ==> b[o]));
//axiom(forall<T> a: Set T, b: Set T ::
// { Set#Subset(a,b), Set#Card(a), Set#Card(b) }  // very restrictive trigger
//  Set#Subset(a,b) ==> Set#Card(a) <= Set#Card(b));


function Set#Equal<T>(Set T, Set T): bool;
axiom(forall<T> a: Set T, b: Set T :: { Set#Equal(a,b) }
  Set#Equal(a,b) <==> (forall o: T :: {a[o]} {b[o]} a[o] <==> b[o]));
axiom(forall<T> a: Set T, b: Set T :: { Set#Equal(a,b) }  // extensionality axiom for sets
  Set#Equal(a,b) ==> a == b);

function Set#Disjoint<T>(Set T, Set T): bool;
axiom (forall<T> a: Set T, b: Set T :: { Set#Disjoint(a,b) }
  Set#Disjoint(a,b) <==> (forall o: T :: {a[o]} {b[o]} !a[o] || !b[o]));

// ---------------------------------------------------------------
// -- Axiomatization of multisets --------------------------------
// ---------------------------------------------------------------

function Math#min(a: int, b: int): int;
axiom (forall a: int, b: int :: { Math#min(a, b) } a <= b <==> Math#min(a, b) == a);
axiom (forall a: int, b: int :: { Math#min(a, b) } b <= a <==> Math#min(a, b) == b);
axiom (forall a: int, b: int :: { Math#min(a, b) } Math#min(a, b) == a || Math#min(a, b) == b);

function Math#clip(a: int): int;
axiom (forall a: int :: { Math#clip(a) } 0 <= a ==> Math#clip(a) == a);
axiom (forall a: int :: { Math#clip(a) } a < 0  ==> Math#clip(a) == 0);

type MultiSet T = [T]int;

function $IsGoodMultiSet<T>(ms: MultiSet T): bool;
// ints are non-negative, used after havocing, and for conversion from sequences to multisets.
axiom (forall<T> ms: MultiSet T :: { $IsGoodMultiSet(ms) }
  $IsGoodMultiSet(ms) <==> (forall bx: T :: { ms[bx] } 0 <= ms[bx]));

function MultiSet#Card<T>(MultiSet T): int;
axiom (forall<T> s: MultiSet T :: { MultiSet#Card(s) } 0 <= MultiSet#Card(s));
axiom (forall<T> s: MultiSet T, x: T, n: int :: { MultiSet#Card(s[x := n]) }
  0 <= n ==> MultiSet#Card(s[x := n]) == MultiSet#Card(s) - s[x] + n);

function MultiSet#Empty<T>(): MultiSet T;
axiom (forall<T> o: T :: { MultiSet#Empty()[o] } MultiSet#Empty()[o] == 0);
axiom (forall<T> s: MultiSet T :: { MultiSet#Card(s) }
  (MultiSet#Card(s) == 0 <==> s == MultiSet#Empty()) &&
  (MultiSet#Card(s) != 0 ==> (exists x: T :: 0 < s[x])));

function MultiSet#Singleton<T>(T): MultiSet T;
axiom (forall<T> r: T, o: T :: { MultiSet#Singleton(r)[o] } (MultiSet#Singleton(r)[o] == 1 <==> r == o) &&
                                                            (MultiSet#Singleton(r)[o] == 0 <==> r != o));
axiom (forall<T> r: T :: { MultiSet#Singleton(r) } MultiSet#Singleton(r) == MultiSet#UnionOne(MultiSet#Empty(), r));

function MultiSet#UnionOne<T>(MultiSet T, T): MultiSet T;
// pure containment axiom (in the original multiset or is the added element)
axiom (forall<T> a: MultiSet T, x: T, o: T :: { MultiSet#UnionOne(a,x)[o] }
  0 < MultiSet#UnionOne(a,x)[o] <==> o == x || 0 < a[o]);
// union-ing increases count by one
axiom (forall<T> a: MultiSet T, x: T :: { MultiSet#UnionOne(a, x) }
  MultiSet#UnionOne(a, x)[x] == a[x] + 1);
// non-decreasing
axiom (forall<T> a: MultiSet T, x: T, y: T :: { MultiSet#UnionOne(a, x), a[y] }
  0 < a[y] ==> 0 < MultiSet#UnionOne(a, x)[y]);
// other elements unchanged
axiom (forall<T> a: MultiSet T, x: T, y: T :: { MultiSet#UnionOne(a, x), a[y] }
  x != y ==> a[y] == MultiSet#UnionOne(a, x)[y]);
axiom (forall<T> a: MultiSet T, x: T :: { MultiSet#Card(MultiSet#UnionOne(a, x)) }
  MultiSet#Card(MultiSet#UnionOne(a, x)) == MultiSet#Card(a) + 1);


function MultiSet#Union<T>(MultiSet T, MultiSet T): MultiSet T;
// union-ing is the sum of the contents
axiom (forall<T> a: MultiSet T, b: MultiSet T, o: T :: { MultiSet#Union(a,b)[o] }
  MultiSet#Union(a,b)[o] == a[o] + b[o]);
axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Card(MultiSet#Union(a,b)) }
  MultiSet#Card(MultiSet#Union(a,b)) == MultiSet#Card(a) + MultiSet#Card(b));

// two containment axioms
axiom (forall<T> a, b: MultiSet T, y: T :: { MultiSet#Union(a, b), a[y] }
  0 < a[y] ==> 0 < MultiSet#Union(a, b)[y]);
axiom (forall<T> a, b: MultiSet T, y: T :: { MultiSet#Union(a, b), b[y] }
  0 < b[y] ==> 0 < MultiSet#Union(a, b)[y]);

// symmetry axiom
axiom (forall<T> a, b: MultiSet T :: { MultiSet#Union(a, b) }
  MultiSet#Difference(MultiSet#Union(a, b), a) == b &&
  MultiSet#Difference(MultiSet#Union(a, b), b) == a);

function MultiSet#Intersection<T>(MultiSet T, MultiSet T): MultiSet T;
axiom (forall<T> a: MultiSet T, b: MultiSet T, o: T :: { MultiSet#Intersection(a,b)[o] }
  MultiSet#Intersection(a,b)[o] == Math#min(a[o],  b[o]));

// left and right pseudo-idempotence
axiom (forall<T> a, b: MultiSet T :: { MultiSet#Intersection(MultiSet#Intersection(a, b), b) }
  MultiSet#Intersection(MultiSet#Intersection(a, b), b) == MultiSet#Intersection(a, b));
axiom (forall<T> a, b: MultiSet T :: { MultiSet#Intersection(a, MultiSet#Intersection(a, b)) }
  MultiSet#Intersection(a, MultiSet#Intersection(a, b)) == MultiSet#Intersection(a, b));

// multiset difference, a - b. clip() makes it positive.
function MultiSet#Difference<T>(MultiSet T, MultiSet T): MultiSet T;
axiom (forall<T> a: MultiSet T, b: MultiSet T, o: T :: { MultiSet#Difference(a,b)[o] }
  MultiSet#Difference(a,b)[o] == Math#clip(a[o] - b[o]));
axiom (forall<T> a, b: MultiSet T, y: T :: { MultiSet#Difference(a, b), b[y], a[y] }
  a[y] <= b[y] ==> MultiSet#Difference(a, b)[y] == 0 );

// multiset subset means a must have at most as many of each element as b
function MultiSet#Subset<T>(MultiSet T, MultiSet T): bool;
axiom(forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Subset(a,b) }
  MultiSet#Subset(a,b) <==> (forall o: T :: {a[o]} {b[o]} a[o] <= b[o]));

function MultiSet#Equal<T>(MultiSet T, MultiSet T): bool;
axiom(forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Equal(a,b) }
  MultiSet#Equal(a,b) <==> (forall o: T :: {a[o]} {b[o]} a[o] == b[o]));
// extensionality axiom for multisets
axiom(forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Equal(a,b) }
  MultiSet#Equal(a,b) ==> a == b);

function MultiSet#Disjoint<T>(MultiSet T, MultiSet T): bool;
axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Disjoint(a,b) }
  MultiSet#Disjoint(a,b) <==> (forall o: T :: {a[o]} {b[o]} a[o] == 0 || b[o] == 0));

// conversion to a multiset. each element in the original set has duplicity 1.
function MultiSet#FromSet<T>(Set T): MultiSet T;
axiom (forall<T> s: Set T, a: T :: { MultiSet#FromSet(s)[a] }
  (MultiSet#FromSet(s)[a] == 0 <==> !s[a]) &&
  (MultiSet#FromSet(s)[a] == 1 <==> s[a]));
axiom (forall<T> s: Set T :: { MultiSet#Card(MultiSet#FromSet(s)) }
  MultiSet#Card(MultiSet#FromSet(s)) == Set#Card(s));

    

// ==================================================
// Translation of domain GlobalKPermission
// ==================================================

// The type for domain GlobalKPermission
type GlobalKPermission;

// Translation of domain unique function globalK$
const unique globalK$: Perm;

// Translation of domain axiom globalKReadOnly
axiom (NoPerm[$frac] < globalK$[$frac] || (NoPerm[$frac] == globalK$[$frac] && NoPerm[$eps] < globalK$[$eps])) && (globalK$[$frac] < FullPerm[$frac] || (globalK$[$frac] == FullPerm[$frac] && globalK$[$eps] < FullPerm[$eps]));

// ==================================================
// Translation of all fields
// ==================================================

const unique old$methodPermission: Field NormalField Perm;
axiom !IsPredicateField(old$methodPermission);
const unique joinable$: Field NormalField bool;
axiom !IsPredicateField(joinable$);
const unique AVLTreeroot$: Field NormalField Ref;
axiom !IsPredicateField(AVLTreeroot$);
const unique AVLTreekeys$: Field NormalField (Seq_ int);
axiom !IsPredicateField(AVLTreekeys$);
const unique AVLTreeNodekey$: Field NormalField int;
axiom !IsPredicateField(AVLTreeNodekey$);
const unique AVLTreeNodeheight$: Field NormalField int;
axiom !IsPredicateField(AVLTreeNodeheight$);
const unique AVLTreeNodeleft$: Field NormalField Ref;
axiom !IsPredicateField(AVLTreeNodeleft$);
const unique AVLTreeNoderight$: Field NormalField Ref;
axiom !IsPredicateField(AVLTreeNoderight$);
const unique AVLTreeNodekeys$: Field NormalField (Seq_ int);
axiom !IsPredicateField(AVLTreeNodekeys$);
const unique AVLTreeNodebalanceFactor$: Field NormalField int;
axiom !IsPredicateField(AVLTreeNodebalanceFactor$);
const unique par$AVLTreeinit$this$_2: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeinit$this$_2);
const unique par$AVLTreeinit$k$: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeinit$k$);
const unique old$AVLTreeinsert$0: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeinsert$0);
const unique old$AVLTreeinsert$1: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeinsert$1);
const unique par$AVLTreeinsert$this$_3: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeinsert$this$_3);
const unique par$AVLTreeinsert$k$_1: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeinsert$k$_1);
const unique par$AVLTreeinsert$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreeinsert$k);
const unique old$AVLTreeremove$0: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeremove$0);
const unique old$AVLTreeremove$1: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeremove$1);
const unique par$AVLTreeremove$this$_4: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeremove$this$_4);
const unique par$AVLTreeremove$k$_2: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeremove$k$_2);
const unique par$AVLTreeremove$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreeremove$k);
const unique par$AVLTreehas$this$_5: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreehas$this$_5);
const unique par$AVLTreehas$k$_3: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreehas$k$_3);
const unique par$AVLTreehas$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreehas$k);
const unique par$AVLTreeNodeinit$this$_8: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodeinit$this$_8);
const unique par$AVLTreeNodeinit$k$_4: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodeinit$k$_4);
const unique par$AVLTreeNodeinit$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreeNodeinit$k);
const unique old$AVLTreeNodeinsert$0: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$0);
const unique old$AVLTreeNodeinsert$1: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$1);
const unique old$AVLTreeNodeinsert$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$2);
const unique old$AVLTreeNodeinsert$3: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$3);
const unique old$AVLTreeNodeinsert$4: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$4);
const unique old$AVLTreeNodeinsert$5: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$5);
const unique old$AVLTreeNodeinsert$6: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeinsert$6);
const unique old$AVLTreeNodeinsert$7: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeinsert$7);
const unique old$AVLTreeNodeinsert$8: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeinsert$8);
const unique old$AVLTreeNodeinsert$9: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeinsert$9);
const unique par$AVLTreeNodeinsert$this$_9: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodeinsert$this$_9);
const unique par$AVLTreeNodeinsert$k$_5: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodeinsert$k$_5);
const unique par$AVLTreeNodeinsert$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreeNodeinsert$k);
const unique old$AVLTreeNoderemove$0: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$0);
const unique old$AVLTreeNoderemove$1: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$1);
const unique old$AVLTreeNoderemove$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$2);
const unique old$AVLTreeNoderemove$3: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$3);
const unique old$AVLTreeNoderemove$4: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$4);
const unique old$AVLTreeNoderemove$5: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$5);
const unique old$AVLTreeNoderemove$6: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$6);
const unique old$AVLTreeNoderemove$7: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$7);
const unique old$AVLTreeNoderemove$8: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$8);
const unique old$AVLTreeNoderemove$9: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderemove$9);
const unique old$AVLTreeNoderemove$10: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderemove$10);
const unique old$AVLTreeNoderemove$11: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderemove$11);
const unique old$AVLTreeNoderemove$12: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderemove$12);
const unique old$AVLTreeNoderemove$13: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderemove$13);
const unique par$AVLTreeNoderemove$this$_10: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderemove$this$_10);
const unique par$AVLTreeNoderemove$k$_6: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderemove$k$_6);
const unique par$AVLTreeNoderemove$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreeNoderemove$k);
const unique old$AVLTreeNodepruneMax$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMax$0);
const unique old$AVLTreeNodepruneMax$1: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMax$1);
const unique old$AVLTreeNodepruneMax$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodepruneMax$2);
const unique old$AVLTreeNodepruneMax$3: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMax$3);
const unique old$AVLTreeNodepruneMax$4: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMax$4);
const unique old$AVLTreeNodepruneMax$5: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMax$5);
const unique old$AVLTreeNodepruneMax$6: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMax$6);
const unique old$AVLTreeNodepruneMax$7: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodepruneMax$7);
const unique par$AVLTreeNodepruneMax$this$_11: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodepruneMax$this$_11);
const unique par$AVLTreeNodepruneMax$k$_7: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodepruneMax$k$_7);
const unique old$AVLTreeNodepruneMin$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMin$0);
const unique old$AVLTreeNodepruneMin$1: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMin$1);
const unique old$AVLTreeNodepruneMin$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodepruneMin$2);
const unique old$AVLTreeNodepruneMin$3: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMin$3);
const unique old$AVLTreeNodepruneMin$4: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMin$4);
const unique old$AVLTreeNodepruneMin$5: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMin$5);
const unique old$AVLTreeNodepruneMin$6: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodepruneMin$6);
const unique old$AVLTreeNodepruneMin$7: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodepruneMin$7);
const unique par$AVLTreeNodepruneMin$this$_12: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodepruneMin$this$_12);
const unique par$AVLTreeNodepruneMin$k$_8: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodepruneMin$k$_8);
const unique par$AVLTreeNodehas$this$_13: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodehas$this$_13);
const unique par$AVLTreeNodehas$k$_9: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodehas$k$_9);
const unique par$AVLTreeNodehas$k: Field NormalField int;
axiom !IsPredicateField(par$AVLTreeNodehas$k);
const unique par$AVLTreeNodegetBalanceFactor$this$_14: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodegetBalanceFactor$this$_14);
const unique par$AVLTreeNodegetBalanceFactor$k$_10: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodegetBalanceFactor$k$_10);
const unique par$AVLTreeNodegetBalanceFactorI$this$_15: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodegetBalanceFactorI$this$_15);
const unique par$AVLTreeNodegetBalanceFactorI$k$_11: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodegetBalanceFactorI$k$_11);
const unique old$AVLTreeNodeclose$0: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$0);
const unique old$AVLTreeNodeclose$1: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeclose$1);
const unique old$AVLTreeNodeclose$2: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$2);
const unique old$AVLTreeNodeclose$3: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$3);
const unique old$AVLTreeNodeclose$4: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNodeclose$4);
const unique old$AVLTreeNodeclose$5: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$5);
const unique old$AVLTreeNodeclose$6: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$6);
const unique old$AVLTreeNodeclose$7: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$7);
const unique old$AVLTreeNodeclose$8: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$8);
const unique old$AVLTreeNodeclose$9: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$9);
const unique old$AVLTreeNodeclose$10: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$10);
const unique old$AVLTreeNodeclose$11: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$11);
const unique old$AVLTreeNodeclose$12: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$12);
const unique old$AVLTreeNodeclose$13: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$13);
const unique old$AVLTreeNodeclose$14: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$14);
const unique old$AVLTreeNodeclose$15: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNodeclose$15);
const unique old$AVLTreeNodeclose$16: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNodeclose$16);
const unique par$AVLTreeNodeclose$this$_16: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNodeclose$this$_16);
const unique par$AVLTreeNodeclose$k$_12: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNodeclose$k$_12);
const unique old$AVLTreeNoderebalanceLeft$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLeft$0);
const unique old$AVLTreeNoderebalanceLeft$1: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLeft$1);
const unique old$AVLTreeNoderebalanceLeft$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceLeft$2);
const unique old$AVLTreeNoderebalanceLeft$3: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLeft$3);
const unique old$AVLTreeNoderebalanceLeft$4: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLeft$4);
const unique old$AVLTreeNoderebalanceLeft$5: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceLeft$5);
const unique par$AVLTreeNoderebalanceLeft$this$_17: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderebalanceLeft$this$_17);
const unique par$AVLTreeNoderebalanceLeft$k$_13: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderebalanceLeft$k$_13);
const unique old$AVLTreeNoderebalanceRL$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRL$0);
const unique old$AVLTreeNoderebalanceRL$1: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceRL$1);
const unique old$AVLTreeNoderebalanceRL$2: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRL$2);
const unique old$AVLTreeNoderebalanceRL$3: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRL$3);
const unique old$AVLTreeNoderebalanceRL$4: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceRL$4);
const unique par$AVLTreeNoderebalanceRL$this$_18: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderebalanceRL$this$_18);
const unique par$AVLTreeNoderebalanceRL$k$_14: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderebalanceRL$k$_14);
const unique old$AVLTreeNoderebalanceRR$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRR$0);
const unique old$AVLTreeNoderebalanceRR$1: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRR$1);
const unique old$AVLTreeNoderebalanceRR$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceRR$2);
const unique old$AVLTreeNoderebalanceRR$3: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRR$3);
const unique old$AVLTreeNoderebalanceRR$4: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRR$4);
const unique old$AVLTreeNoderebalanceRR$5: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceRR$5);
const unique par$AVLTreeNoderebalanceRR$this$_19: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderebalanceRR$this$_19);
const unique par$AVLTreeNoderebalanceRR$k$_15: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderebalanceRR$k$_15);
const unique old$AVLTreeNoderebalanceRight$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRight$0);
const unique old$AVLTreeNoderebalanceRight$1: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRight$1);
const unique old$AVLTreeNoderebalanceRight$2: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRight$2);
const unique old$AVLTreeNoderebalanceRight$3: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceRight$3);
const unique old$AVLTreeNoderebalanceRight$4: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceRight$4);
const unique old$AVLTreeNoderebalanceRight$5: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceRight$5);
const unique par$AVLTreeNoderebalanceRight$this$_20: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderebalanceRight$this$_20);
const unique par$AVLTreeNoderebalanceRight$k$_16: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderebalanceRight$k$_16);
const unique old$AVLTreeNoderebalanceLR$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLR$0);
const unique old$AVLTreeNoderebalanceLR$1: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLR$1);
const unique old$AVLTreeNoderebalanceLR$2: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceLR$2);
const unique old$AVLTreeNoderebalanceLR$3: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLR$3);
const unique old$AVLTreeNoderebalanceLR$4: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceLR$4);
const unique par$AVLTreeNoderebalanceLR$this$_21: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderebalanceLR$this$_21);
const unique par$AVLTreeNoderebalanceLR$k$_17: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderebalanceLR$k$_17);
const unique old$AVLTreeNoderebalanceLL$0: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLL$0);
const unique old$AVLTreeNoderebalanceLL$1: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLL$1);
const unique old$AVLTreeNoderebalanceLL$2: Field NormalField Ref;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLL$2);
const unique old$AVLTreeNoderebalanceLL$3: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceLL$3);
const unique old$AVLTreeNoderebalanceLL$4: Field NormalField int;
axiom !IsPredicateField(old$AVLTreeNoderebalanceLL$4);
const unique old$AVLTreeNoderebalanceLL$5: Field NormalField (Seq_ int);
axiom !IsPredicateField(old$AVLTreeNoderebalanceLL$5);
const unique par$AVLTreeNoderebalanceLL$this$_22: Field NormalField Ref;
axiom !IsPredicateField(par$AVLTreeNoderebalanceLL$this$_22);
const unique par$AVLTreeNoderebalanceLL$k$_18: Field NormalField Perm;
axiom !IsPredicateField(par$AVLTreeNoderebalanceLL$k$_18);

// ==================================================
// Translation of predicate AVLTree$MonitorInvariant
// ==================================================

type PredicateType_AVLTree$MonitorInvariant;
function AVLTree$MonitorInvariant(this$: Ref): Field PredicateType_AVLTree$MonitorInvariant int;
function AVLTree$MonitorInvariant#sm(this$: Ref): Field PredicateType_AVLTree$MonitorInvariant PMaskType;
axiom (forall this$: Ref ::
  { PredicateMaskField(AVLTree$MonitorInvariant(this$)) }
  PredicateMaskField(AVLTree$MonitorInvariant(this$)) == AVLTree$MonitorInvariant#sm(this$)
);
axiom (forall this$: Ref ::
  { AVLTree$MonitorInvariant(this$) }
  IsPredicateField(AVLTree$MonitorInvariant(this$))
);
function AVLTree$MonitorInvariant#trigger<A>(pred: (Field A int)): bool;
axiom (forall this$: Ref, this$2: Ref ::
  { AVLTree$MonitorInvariant(this$), AVLTree$MonitorInvariant(this$2) }
  AVLTree$MonitorInvariant(this$) == AVLTree$MonitorInvariant(this$2) ==> this$ == this$2
);
axiom (forall this$: Ref, this$2: Ref ::
  { AVLTree$MonitorInvariant#sm(this$), AVLTree$MonitorInvariant#sm(this$2) }
  AVLTree$MonitorInvariant#sm(this$) == AVLTree$MonitorInvariant#sm(this$2) ==> this$ == this$2
);

// ==================================================
// Translation of predicate AVLTreevalid$
// ==================================================

type PredicateType_AVLTreevalid$;
function AVLTreevalid$(this$_1: Ref): Field PredicateType_AVLTreevalid$ int;
function AVLTreevalid$#sm(this$_1: Ref): Field PredicateType_AVLTreevalid$ PMaskType;
axiom (forall this$_1: Ref ::
  { PredicateMaskField(AVLTreevalid$(this$_1)) }
  PredicateMaskField(AVLTreevalid$(this$_1)) == AVLTreevalid$#sm(this$_1)
);
axiom (forall this$_1: Ref ::
  { AVLTreevalid$(this$_1) }
  IsPredicateField(AVLTreevalid$(this$_1))
);
function AVLTreevalid$#trigger<A>(pred: (Field A int)): bool;
axiom (forall this$_1: Ref, this$_12: Ref ::
  { AVLTreevalid$(this$_1), AVLTreevalid$(this$_12) }
  AVLTreevalid$(this$_1) == AVLTreevalid$(this$_12) ==> this$_1 == this$_12
);
axiom (forall this$_1: Ref, this$_12: Ref ::
  { AVLTreevalid$#sm(this$_1), AVLTreevalid$#sm(this$_12) }
  AVLTreevalid$#sm(this$_1) == AVLTreevalid$#sm(this$_12) ==> this$_1 == this$_12
);

// ==================================================
// Translation of predicate AVLTreeNode$MonitorInvariant
// ==================================================

type PredicateType_AVLTreeNode$MonitorInvariant;
function AVLTreeNode$MonitorInvariant(this$_6: Ref): Field PredicateType_AVLTreeNode$MonitorInvariant int;
function AVLTreeNode$MonitorInvariant#sm(this$_6: Ref): Field PredicateType_AVLTreeNode$MonitorInvariant PMaskType;
axiom (forall this$_6: Ref ::
  { PredicateMaskField(AVLTreeNode$MonitorInvariant(this$_6)) }
  PredicateMaskField(AVLTreeNode$MonitorInvariant(this$_6)) == AVLTreeNode$MonitorInvariant#sm(this$_6)
);
axiom (forall this$_6: Ref ::
  { AVLTreeNode$MonitorInvariant(this$_6) }
  IsPredicateField(AVLTreeNode$MonitorInvariant(this$_6))
);
function AVLTreeNode$MonitorInvariant#trigger<A>(pred: (Field A int)): bool;
axiom (forall this$_6: Ref, this$_62: Ref ::
  { AVLTreeNode$MonitorInvariant(this$_6), AVLTreeNode$MonitorInvariant(this$_62) }
  AVLTreeNode$MonitorInvariant(this$_6) == AVLTreeNode$MonitorInvariant(this$_62) ==> this$_6 == this$_62
);
axiom (forall this$_6: Ref, this$_62: Ref ::
  { AVLTreeNode$MonitorInvariant#sm(this$_6), AVLTreeNode$MonitorInvariant#sm(this$_62) }
  AVLTreeNode$MonitorInvariant#sm(this$_6) == AVLTreeNode$MonitorInvariant#sm(this$_62) ==> this$_6 == this$_62
);

// ==================================================
// Translation of predicate AVLTreeNodevalid$
// ==================================================

type PredicateType_AVLTreeNodevalid$;
function AVLTreeNodevalid$(this$_7: Ref): Field PredicateType_AVLTreeNodevalid$ int;
function AVLTreeNodevalid$#sm(this$_7: Ref): Field PredicateType_AVLTreeNodevalid$ PMaskType;
axiom (forall this$_7: Ref ::
  { PredicateMaskField(AVLTreeNodevalid$(this$_7)) }
  PredicateMaskField(AVLTreeNodevalid$(this$_7)) == AVLTreeNodevalid$#sm(this$_7)
);
axiom (forall this$_7: Ref ::
  { AVLTreeNodevalid$(this$_7) }
  IsPredicateField(AVLTreeNodevalid$(this$_7))
);
function AVLTreeNodevalid$#trigger<A>(pred: (Field A int)): bool;
axiom (forall this$_7: Ref, this$_72: Ref ::
  { AVLTreeNodevalid$(this$_7), AVLTreeNodevalid$(this$_72) }
  AVLTreeNodevalid$(this$_7) == AVLTreeNodevalid$(this$_72) ==> this$_7 == this$_72
);
axiom (forall this$_7: Ref, this$_72: Ref ::
  { AVLTreeNodevalid$#sm(this$_7), AVLTreeNodevalid$#sm(this$_72) }
  AVLTreeNodevalid$#sm(this$_7) == AVLTreeNodevalid$#sm(this$_72) ==> this$_7 == this$_72
);

// ==================================================
// Translation of method AVLTreeinit$
// ==================================================

procedure AVLTreeinit$(this$_2: Ref, k$: Perm) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var freshVersion: int;
  var newPMask: PMaskType;
  var ExhaleHeap: HeapType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_2 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$[$frac] || (NoPerm[$frac] == k$[$frac] && NoPerm[$eps] < k$[$eps]);
    assume state(Heap, Mask);
    assume k$[$frac] < FullPerm[$frac] || (k$[$frac] == FullPerm[$frac] && k$[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_2 != null;
    Mask[this$_2, AVLTreeroot$] := PermAdd(Mask[this$_2, AVLTreeroot$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_2 != null;
    Mask[this$_2, AVLTreekeys$] := PermAdd(Mask[this$_2, AVLTreekeys$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_2)] := PermAdd(Mask[null, AVLTreevalid$(this$_2)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_2 != null;
    Mask[this$_2, AVLTreekeys$] := PermAdd(Mask[this$_2, AVLTreekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_2.AVLTreekeys$ == Seq()
      assert {:msg "  Contract might not be well-formed. Receiver of this$_2.AVLTreekeys$ might be null. (AVLTree.sil,365:11) [10318]"}
        this$_2 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_2.AVLTreekeys$. (AVLTree.sil,365:11) [10319]"}
        HasDirectPerm(Mask, this$_2, AVLTreekeys$);
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[this$_2, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_2 == null || Heap[this$_2, $allocated];
    assume k$[$eps] == 0.000000000;
  
  // -- Translating statement: this$_2.AVLTreeroot$ := null -- AVLTree.sil,371:3
    
    // -- Check definedness of this$_2.AVLTreeroot$
      assert {:msg "  Assignment might fail. Receiver of this$_2.AVLTreeroot$ might be null. (AVLTree.sil,371:3) [10320]"}
        this$_2 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_2.AVLTreeroot$. (AVLTree.sil,371:3) [10321]"}
        HasDirectPerm(Mask, this$_2, AVLTreeroot$);
      assume state(Heap, Mask);
    Heap[this$_2, AVLTreeroot$] := null;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_2.AVLTreeroot$. (AVLTree.sil,371:3) [10322]"}
      FullPerm[$frac] == Mask[this$_2, AVLTreeroot$][$frac] && FullPerm[$eps] == Mask[this$_2, AVLTreeroot$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_2.AVLTreekeys$ := Seq() -- AVLTree.sil,372:3
    
    // -- Check definedness of this$_2.AVLTreekeys$
      assert {:msg "  Assignment might fail. Receiver of this$_2.AVLTreekeys$ might be null. (AVLTree.sil,372:3) [10323]"}
        this$_2 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_2.AVLTreekeys$. (AVLTree.sil,372:3) [10324]"}
        HasDirectPerm(Mask, this$_2, AVLTreekeys$);
      assume state(Heap, Mask);
    Heap[this$_2, AVLTreekeys$] := (Seq#Empty(): Seq_ int);
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_2.AVLTreekeys$. (AVLTree.sil,372:3) [10325]"}
      FullPerm[$frac] == Mask[this$_2, AVLTreekeys$][$frac] && FullPerm[$eps] == Mask[this$_2, AVLTreekeys$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreevalid$(this$_2), write) -- AVLTree.sil,373:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_2));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,373:3) [10326]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Receiver of this$_2.AVLTreeroot$ might be null. (AVLTree.sil,373:3) [10327]"}
      this$_2 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. There might be insufficient permission to access this$_2.AVLTreeroot$. (AVLTree.sil,373:3) [10328]"}
        (perm[$frac] < Mask[this$_2, AVLTreeroot$][$frac] || (perm[$frac] == Mask[this$_2, AVLTreeroot$][$frac] && perm[$eps] < Mask[this$_2, AVLTreeroot$][$eps])) || (perm[$frac] == Mask[this$_2, AVLTreeroot$][$frac] && perm[$eps] == Mask[this$_2, AVLTreeroot$][$eps]);
    }
    Mask[this$_2, AVLTreeroot$] := PermSub(Mask[this$_2, AVLTreeroot$], perm);
    assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,373:3) [10329]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Receiver of this$_2.AVLTreekeys$ might be null. (AVLTree.sil,373:3) [10330]"}
      this$_2 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. There might be insufficient permission to access this$_2.AVLTreekeys$. (AVLTree.sil,373:3) [10331]"}
        (perm[$frac] < Mask[this$_2, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_2, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_2, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_2, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_2, AVLTreekeys$][$eps]);
    }
    Mask[this$_2, AVLTreekeys$] := PermSub(Mask[this$_2, AVLTreekeys$], perm);
    if (Heap[this$_2, AVLTreeroot$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_2.AVLTreeroot$). (AVLTree.sil,373:3) [10334]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_2, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_2)], Heap[this$_2, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])]);
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,373:3) [10335]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Receiver of this$_2.AVLTreeroot$.AVLTreeNodeheight$ might be null. (AVLTree.sil,373:3) [10336]"}
        Heap[this$_2, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. There might be insufficient permission to access this$_2.AVLTreeroot$.AVLTreeNodeheight$. (AVLTree.sil,373:3) [10337]"}
          (perm[$frac] < Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,373:3) [10338]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Receiver of this$_2.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,373:3) [10339]"}
        Heap[this$_2, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. There might be insufficient permission to access this$_2.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,373:3) [10340]"}
          (perm[$frac] < Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,373:3) [10341]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Receiver of this$_2.AVLTreeroot$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,373:3) [10342]"}
        Heap[this$_2, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. There might be insufficient permission to access this$_2.AVLTreeroot$.AVLTreeNodebalanceFactor$. (AVLTree.sil,373:3) [10343]"}
          (perm[$frac] < Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Assertion this$_2.AVLTreekeys$ == this$_2.AVLTreeroot$.AVLTreeNodekeys$ might not hold. (AVLTree.sil,373:3) [10344]"}
        Seq#Equal(Heap[this$_2, AVLTreekeys$], Heap[Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_2, AVLTreeroot$] == null) {
      assert {:msg "  Folding AVLTreevalid$(this$_2) might fail. Assertion this$_2.AVLTreekeys$ == Seq() might not hold. (AVLTree.sil,373:3) [10345]"}
        Seq#Equal(Heap[this$_2, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_2, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_2, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_2)], Heap[this$_2, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_2, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_2, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_2)], Heap[this$_2, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_2, AVLTreeroot$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_2)] := PermAdd(Mask[null, AVLTreevalid$(this$_2)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreevalid$#sm(this$_2)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreevalid$(this$_2)] := freshVersion;
    Heap[null, AVLTreevalid$#sm(this$_2)][this$_2, AVLTreeroot$] := true;
    Heap[null, AVLTreevalid$#sm(this$_2)][this$_2, AVLTreekeys$] := true;
    if (Heap[this$_2, AVLTreeroot$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_2: Ref, f_5: (Field A B) ::
        { newPMask[o_2, f_5] }
        Heap[null, AVLTreevalid$#sm(this$_2)][o_2, f_5] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_2, AVLTreeroot$])][o_2, f_5] ==> newPMask[o_2, f_5]
      );
      Heap[null, AVLTreevalid$#sm(this$_2)] := newPMask;
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_2)][Heap[this$_2, AVLTreeroot$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_2)][Heap[this$_2, AVLTreeroot$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_2, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_2)][Heap[this$_2, AVLTreeroot$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeinit$ might not hold. There might be insufficient permission to access AVLTreevalid$(this$_2). (AVLTree.sil,363:11) [10346]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_2)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_2)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_2)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_2)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_2)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_2)] := PermSub(Mask[null, AVLTreevalid$(this$_2)], perm);
    assert {:msg "  Postcondition of AVLTreeinit$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,364:11) [10347]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeinit$ might not hold. Receiver of this$_2.AVLTreekeys$ might be null. (AVLTree.sil,364:11) [10348]"}
      this$_2 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeinit$ might not hold. There might be insufficient permission to access this$_2.AVLTreekeys$. (AVLTree.sil,364:11) [10349]"}
        (perm[$frac] < Mask[this$_2, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_2, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_2, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_2, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_2, AVLTreekeys$][$eps]);
    }
    Mask[this$_2, AVLTreekeys$] := PermSub(Mask[this$_2, AVLTreekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeinit$ might not hold. Assertion this$_2.AVLTreekeys$ == Seq() might not hold. (AVLTree.sil,365:11) [10350]"}
      Seq#Equal(Heap[this$_2, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeinsert$
// ==================================================

procedure AVLTreeinsert$(this$_3: Ref, k$_1: Perm, k: int) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var j: int;
  var j_2: int;
  var oldVersion: int;
  var newVersion: int;
  var freshObj: Ref;
  var n: Ref;
  var newK$_35: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var newK$_36: Perm;
  var arg_this$_9: Ref;
  var r_1: Ref;
  var freshVersion: int;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_3 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_1[$frac] || (NoPerm[$frac] == k$_1[$frac] && NoPerm[$eps] < k$_1[$eps]);
    assume state(Heap, Mask);
    assume k$_1[$frac] < FullPerm[$frac] || (k$_1[$frac] == FullPerm[$frac] && k$_1[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_3)] := PermAdd(Mask[null, AVLTreevalid$(this$_3)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_3 != null;
    Mask[this$_3, AVLTreekeys$] := PermAdd(Mask[this$_3, AVLTreekeys$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_3)] := PermAdd(Mask[null, AVLTreevalid$(this$_3)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_3 != null;
    Mask[this$_3, AVLTreekeys$] := PermAdd(Mask[this$_3, AVLTreekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of k in this$_3.AVLTreekeys$
      assert {:msg "  Contract might not be well-formed. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,384:11) [10351]"}
        this$_3 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,384:11) [10352]"}
        HasDirectPerm(Mask, this$_3, AVLTreekeys$);
      assume state(Heap, Mask);
    assume Seq#Contains(Heap[this$_3, AVLTreekeys$], k);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall j: Int :: true && j in old(this$_3.AVLTreekeys$) ==> j in this$_3.AVLTreekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,385:12) [10353]"}
        this$_3 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,385:12) [10354]"}
        HasDirectPerm(old(Mask), this$_3, AVLTreekeys$);
      if (Seq#Contains(old(Heap)[this$_3, AVLTreekeys$], j)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,385:12) [10355]"}
          this$_3 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,385:12) [10356]"}
          HasDirectPerm(Mask, this$_3, AVLTreekeys$);
      }
      assume state(Heap, Mask);
    assume (forall j_1: int ::
      
      Seq#Contains(old(Heap)[this$_3, AVLTreekeys$], j_1) ==> Seq#Contains(Heap[this$_3, AVLTreekeys$], j_1)
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall j: Int :: true && j in this$_3.AVLTreekeys$ ==> j in old(this$_3.AVLTreekeys$) || (j == k))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,386:12) [10357]"}
        this$_3 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,386:12) [10358]"}
        HasDirectPerm(Mask, this$_3, AVLTreekeys$);
      if (Seq#Contains(Heap[this$_3, AVLTreekeys$], j_2)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,386:12) [10359]"}
          this$_3 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,386:12) [10360]"}
          HasDirectPerm(old(Mask), this$_3, AVLTreekeys$);
      }
      assume state(Heap, Mask);
    assume (forall j_3: int ::
      
      Seq#Contains(Heap[this$_3, AVLTreekeys$], j_3) ==> Seq#Contains(old(Heap)[this$_3, AVLTreekeys$], j_3) || j_3 == k
    );
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_3 == null || Heap[this$_3, $allocated];
    assume k$_1[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreevalid$(this$_3), write) -- AVLTree.sil,396:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_3));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access AVLTreevalid$(this$_3). (AVLTree.sil,396:3) [10363]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_3)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_3)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_3)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_3)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_3)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_3)] := PermSub(Mask[null, AVLTreevalid$(this$_3)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreevalid$(this$_3))) {
        oldVersion := Heap[null, AVLTreevalid$(this$_3)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreevalid$(this$_3)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_3 != null;
    Mask[this$_3, AVLTreeroot$] := PermAdd(Mask[this$_3, AVLTreeroot$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_3 != null;
    Mask[this$_3, AVLTreekeys$] := PermAdd(Mask[this$_3, AVLTreekeys$], perm);
    if (Heap[this$_3, AVLTreeroot$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_3, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_3)], Heap[this$_3, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])]);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_3, AVLTreeroot$] != null;
      Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_3, AVLTreeroot$] != null;
      Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_3, AVLTreeroot$] != null;
      Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      assume Seq#Equal(Heap[this$_3, AVLTreekeys$], Heap[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_3, AVLTreeroot$] == null) {
      assume Seq#Equal(Heap[this$_3, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_3.AVLTreeroot$ == null) -- AVLTree.sil,397:3
    
    // -- Check definedness of this$_3.AVLTreeroot$ == null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,397:7) [10364]"}
        HasDirectPerm(Mask, this$_3, AVLTreeroot$);
      assume state(Heap, Mask);
    if (Heap[this$_3, AVLTreeroot$] == null) {
      
      // -- Translating statement: n := new(old$methodPermission, joinable$, AVLTreeroot$, AVLTreekeys$, AVLTreeNodekey$, AVLTreeNodeheight$, AVLTreeNodeleft$, AVLTreeNoderight$, AVLTreeNodekeys$, AVLTreeNodebalanceFactor$, par$AVLTreeinit$this$_2, par$AVLTreeinit$k$, old$AVLTreeinsert$0, old$AVLTreeinsert$1, par$AVLTreeinsert$this$_3, par$AVLTreeinsert$k$_1, par$AVLTreeinsert$k, old$AVLTreeremove$0, old$AVLTreeremove$1, par$AVLTreeremove$this$_4, par$AVLTreeremove$k$_2, par$AVLTreeremove$k, par$AVLTreehas$this$_5, par$AVLTreehas$k$_3, par$AVLTreehas$k, par$AVLTreeNodeinit$this$_8, par$AVLTreeNodeinit$k$_4, par$AVLTreeNodeinit$k, old$AVLTreeNodeinsert$0, old$AVLTreeNodeinsert$1, old$AVLTreeNodeinsert$2, old$AVLTreeNodeinsert$3, old$AVLTreeNodeinsert$4, old$AVLTreeNodeinsert$5, old$AVLTreeNodeinsert$6, old$AVLTreeNodeinsert$7, old$AVLTreeNodeinsert$8, old$AVLTreeNodeinsert$9, par$AVLTreeNodeinsert$this$_9, par$AVLTreeNodeinsert$k$_5, par$AVLTreeNodeinsert$k, old$AVLTreeNoderemove$0, old$AVLTreeNoderemove$1, old$AVLTreeNoderemove$2, old$AVLTreeNoderemove$3, old$AVLTreeNoderemove$4, old$AVLTreeNoderemove$5, old$AVLTreeNoderemove$6, old$AVLTreeNoderemove$7, old$AVLTreeNoderemove$8, old$AVLTreeNoderemove$9, old$AVLTreeNoderemove$10, old$AVLTreeNoderemove$11, old$AVLTreeNoderemove$12, old$AVLTreeNoderemove$13, par$AVLTreeNoderemove$this$_10, par$AVLTreeNoderemove$k$_6, par$AVLTreeNoderemove$k, old$AVLTreeNodepruneMax$0, old$AVLTreeNodepruneMax$1, old$AVLTreeNodepruneMax$2, old$AVLTreeNodepruneMax$3, old$AVLTreeNodepruneMax$4, old$AVLTreeNodepruneMax$5, old$AVLTreeNodepruneMax$6, old$AVLTreeNodepruneMax$7, par$AVLTreeNodepruneMax$this$_11, par$AVLTreeNodepruneMax$k$_7, old$AVLTreeNodepruneMin$0, old$AVLTreeNodepruneMin$1, old$AVLTreeNodepruneMin$2, old$AVLTreeNodepruneMin$3, old$AVLTreeNodepruneMin$4, old$AVLTreeNodepruneMin$5, old$AVLTreeNodepruneMin$6, old$AVLTreeNodepruneMin$7, par$AVLTreeNodepruneMin$this$_12, par$AVLTreeNodepruneMin$k$_8, par$AVLTreeNodehas$this$_13, par$AVLTreeNodehas$k$_9, par$AVLTreeNodehas$k, par$AVLTreeNodegetBalanceFactor$this$_14, par$AVLTreeNodegetBalanceFactor$k$_10, par$AVLTreeNodegetBalanceFactorI$this$_15, par$AVLTreeNodegetBalanceFactorI$k$_11, old$AVLTreeNodeclose$0, old$AVLTreeNodeclose$1, old$AVLTreeNodeclose$2, old$AVLTreeNodeclose$3, old$AVLTreeNodeclose$4, old$AVLTreeNodeclose$5, old$AVLTreeNodeclose$6, old$AVLTreeNodeclose$7, old$AVLTreeNodeclose$8, old$AVLTreeNodeclose$9, old$AVLTreeNodeclose$10, old$AVLTreeNodeclose$11, old$AVLTreeNodeclose$12, old$AVLTreeNodeclose$13, old$AVLTreeNodeclose$14, old$AVLTreeNodeclose$15, old$AVLTreeNodeclose$16, par$AVLTreeNodeclose$this$_16, par$AVLTreeNodeclose$k$_12, old$AVLTreeNoderebalanceLeft$0, old$AVLTreeNoderebalanceLeft$1, old$AVLTreeNoderebalanceLeft$2, old$AVLTreeNoderebalanceLeft$3, old$AVLTreeNoderebalanceLeft$4, old$AVLTreeNoderebalanceLeft$5, par$AVLTreeNoderebalanceLeft$this$_17, par$AVLTreeNoderebalanceLeft$k$_13, old$AVLTreeNoderebalanceRL$0, old$AVLTreeNoderebalanceRL$1, old$AVLTreeNoderebalanceRL$2, old$AVLTreeNoderebalanceRL$3, old$AVLTreeNoderebalanceRL$4, par$AVLTreeNoderebalanceRL$this$_18, par$AVLTreeNoderebalanceRL$k$_14, old$AVLTreeNoderebalanceRR$0, old$AVLTreeNoderebalanceRR$1, old$AVLTreeNoderebalanceRR$2, old$AVLTreeNoderebalanceRR$3, old$AVLTreeNoderebalanceRR$4, old$AVLTreeNoderebalanceRR$5, par$AVLTreeNoderebalanceRR$this$_19, par$AVLTreeNoderebalanceRR$k$_15, old$AVLTreeNoderebalanceRight$0, old$AVLTreeNoderebalanceRight$1, old$AVLTreeNoderebalanceRight$2, old$AVLTreeNoderebalanceRight$3, old$AVLTreeNoderebalanceRight$4, old$AVLTreeNoderebalanceRight$5, par$AVLTreeNoderebalanceRight$this$_20, par$AVLTreeNoderebalanceRight$k$_16, old$AVLTreeNoderebalanceLR$0, old$AVLTreeNoderebalanceLR$1, old$AVLTreeNoderebalanceLR$2, old$AVLTreeNoderebalanceLR$3, old$AVLTreeNoderebalanceLR$4, par$AVLTreeNoderebalanceLR$this$_21, par$AVLTreeNoderebalanceLR$k$_17, old$AVLTreeNoderebalanceLL$0, old$AVLTreeNoderebalanceLL$1, old$AVLTreeNoderebalanceLL$2, old$AVLTreeNoderebalanceLL$3, old$AVLTreeNoderebalanceLL$4, old$AVLTreeNoderebalanceLL$5, par$AVLTreeNoderebalanceLL$this$_22, par$AVLTreeNoderebalanceLL$k$_18) -- AVLTree.sil,398:5
        havoc freshObj;
        assume freshObj != null && !Heap[freshObj, $allocated];
        Heap[freshObj, $allocated] := true;
        n := freshObj;
        Mask[n, old$methodPermission] := FullPerm;
        Mask[n, joinable$] := FullPerm;
        Mask[n, AVLTreeroot$] := FullPerm;
        Mask[n, AVLTreekeys$] := FullPerm;
        Mask[n, AVLTreeNodekey$] := FullPerm;
        Mask[n, AVLTreeNodeheight$] := FullPerm;
        Mask[n, AVLTreeNodeleft$] := FullPerm;
        Mask[n, AVLTreeNoderight$] := FullPerm;
        Mask[n, AVLTreeNodekeys$] := FullPerm;
        Mask[n, AVLTreeNodebalanceFactor$] := FullPerm;
        Mask[n, par$AVLTreeinit$this$_2] := FullPerm;
        Mask[n, par$AVLTreeinit$k$] := FullPerm;
        Mask[n, old$AVLTreeinsert$0] := FullPerm;
        Mask[n, old$AVLTreeinsert$1] := FullPerm;
        Mask[n, par$AVLTreeinsert$this$_3] := FullPerm;
        Mask[n, par$AVLTreeinsert$k$_1] := FullPerm;
        Mask[n, par$AVLTreeinsert$k] := FullPerm;
        Mask[n, old$AVLTreeremove$0] := FullPerm;
        Mask[n, old$AVLTreeremove$1] := FullPerm;
        Mask[n, par$AVLTreeremove$this$_4] := FullPerm;
        Mask[n, par$AVLTreeremove$k$_2] := FullPerm;
        Mask[n, par$AVLTreeremove$k] := FullPerm;
        Mask[n, par$AVLTreehas$this$_5] := FullPerm;
        Mask[n, par$AVLTreehas$k$_3] := FullPerm;
        Mask[n, par$AVLTreehas$k] := FullPerm;
        Mask[n, par$AVLTreeNodeinit$this$_8] := FullPerm;
        Mask[n, par$AVLTreeNodeinit$k$_4] := FullPerm;
        Mask[n, par$AVLTreeNodeinit$k] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$0] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$1] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$2] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$3] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$4] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$5] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$6] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$7] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$8] := FullPerm;
        Mask[n, old$AVLTreeNodeinsert$9] := FullPerm;
        Mask[n, par$AVLTreeNodeinsert$this$_9] := FullPerm;
        Mask[n, par$AVLTreeNodeinsert$k$_5] := FullPerm;
        Mask[n, par$AVLTreeNodeinsert$k] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$0] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$1] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$2] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$3] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$4] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$5] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$6] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$7] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$8] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$9] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$10] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$11] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$12] := FullPerm;
        Mask[n, old$AVLTreeNoderemove$13] := FullPerm;
        Mask[n, par$AVLTreeNoderemove$this$_10] := FullPerm;
        Mask[n, par$AVLTreeNoderemove$k$_6] := FullPerm;
        Mask[n, par$AVLTreeNoderemove$k] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$0] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$1] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$2] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$3] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$4] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$5] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$6] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMax$7] := FullPerm;
        Mask[n, par$AVLTreeNodepruneMax$this$_11] := FullPerm;
        Mask[n, par$AVLTreeNodepruneMax$k$_7] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$0] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$1] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$2] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$3] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$4] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$5] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$6] := FullPerm;
        Mask[n, old$AVLTreeNodepruneMin$7] := FullPerm;
        Mask[n, par$AVLTreeNodepruneMin$this$_12] := FullPerm;
        Mask[n, par$AVLTreeNodepruneMin$k$_8] := FullPerm;
        Mask[n, par$AVLTreeNodehas$this$_13] := FullPerm;
        Mask[n, par$AVLTreeNodehas$k$_9] := FullPerm;
        Mask[n, par$AVLTreeNodehas$k] := FullPerm;
        Mask[n, par$AVLTreeNodegetBalanceFactor$this$_14] := FullPerm;
        Mask[n, par$AVLTreeNodegetBalanceFactor$k$_10] := FullPerm;
        Mask[n, par$AVLTreeNodegetBalanceFactorI$this$_15] := FullPerm;
        Mask[n, par$AVLTreeNodegetBalanceFactorI$k$_11] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$0] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$1] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$2] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$3] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$4] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$5] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$6] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$7] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$8] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$9] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$10] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$11] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$12] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$13] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$14] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$15] := FullPerm;
        Mask[n, old$AVLTreeNodeclose$16] := FullPerm;
        Mask[n, par$AVLTreeNodeclose$this$_16] := FullPerm;
        Mask[n, par$AVLTreeNodeclose$k$_12] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLeft$0] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLeft$1] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLeft$2] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLeft$3] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLeft$4] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLeft$5] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceLeft$this$_17] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceLeft$k$_13] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRL$0] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRL$1] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRL$2] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRL$3] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRL$4] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceRL$this$_18] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceRL$k$_14] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRR$0] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRR$1] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRR$2] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRR$3] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRR$4] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRR$5] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceRR$this$_19] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceRR$k$_15] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRight$0] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRight$1] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRight$2] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRight$3] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRight$4] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceRight$5] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceRight$this$_20] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceRight$k$_16] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLR$0] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLR$1] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLR$2] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLR$3] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLR$4] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceLR$this$_21] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceLR$k$_17] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLL$0] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLL$1] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLL$2] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLL$3] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLL$4] := FullPerm;
        Mask[n, old$AVLTreeNoderebalanceLL$5] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceLL$this$_22] := FullPerm;
        Mask[n, par$AVLTreeNoderebalanceLL$k$_18] := FullPerm;
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_35  -- AVLTree.sil,399:5
        
        // -- Translation of statement fresh newK$_35)
          havoc newK$_35;
          assume (newK$_35[$frac] > 0.000000000 && newK$_35[$frac] < 0.001000000) && newK$_35[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_35) -- AVLTree.sil,400:5
        
        // -- Translating statement: AVLTreeNodeinit$(n, newK$_35, k) -- AVLTree.sil,401:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion n != null might not hold. (AVLTree.sil,401:7) [10365]"}
              n != null;
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion newK$_35 > none might not hold. (AVLTree.sil,401:7) [10366]"}
              NoPerm[$frac] < newK$_35[$frac] || (NoPerm[$frac] == newK$_35[$frac] && NoPerm[$eps] < newK$_35[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion write > newK$_35 might not hold. (AVLTree.sil,401:7) [10367]"}
              newK$_35[$frac] < FullPerm[$frac] || (newK$_35[$frac] == FullPerm[$frac] && newK$_35[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,401:7) [10368]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of n.AVLTreeNodekey$ might be null. (AVLTree.sil,401:7) [10369]"}
              n != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access n.AVLTreeNodekey$. (AVLTree.sil,401:7) [10370]"}
                (perm[$frac] < Mask[n, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[n, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[n, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[n, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[n, AVLTreeNodekey$][$eps]);
            }
            Mask[n, AVLTreeNodekey$] := PermSub(Mask[n, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,401:7) [10371]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of n.AVLTreeNodeheight$ might be null. (AVLTree.sil,401:7) [10372]"}
              n != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access n.AVLTreeNodeheight$. (AVLTree.sil,401:7) [10373]"}
                (perm[$frac] < Mask[n, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[n, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[n, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[n, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[n, AVLTreeNodeheight$][$eps]);
            }
            Mask[n, AVLTreeNodeheight$] := PermSub(Mask[n, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,401:7) [10374]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of n.AVLTreeNodeleft$ might be null. (AVLTree.sil,401:7) [10375]"}
              n != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access n.AVLTreeNodeleft$. (AVLTree.sil,401:7) [10376]"}
                (perm[$frac] < Mask[n, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[n, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[n, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[n, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[n, AVLTreeNodeleft$][$eps]);
            }
            Mask[n, AVLTreeNodeleft$] := PermSub(Mask[n, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,401:7) [10377]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of n.AVLTreeNoderight$ might be null. (AVLTree.sil,401:7) [10378]"}
              n != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access n.AVLTreeNoderight$. (AVLTree.sil,401:7) [10379]"}
                (perm[$frac] < Mask[n, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[n, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[n, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[n, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[n, AVLTreeNoderight$][$eps]);
            }
            Mask[n, AVLTreeNoderight$] := PermSub(Mask[n, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,401:7) [10380]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of n.AVLTreeNodekeys$ might be null. (AVLTree.sil,401:7) [10381]"}
              n != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access n.AVLTreeNodekeys$. (AVLTree.sil,401:7) [10382]"}
                (perm[$frac] < Mask[n, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[n, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[n, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[n, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[n, AVLTreeNodekeys$][$eps]);
            }
            Mask[n, AVLTreeNodekeys$] := PermSub(Mask[n, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,401:7) [10383]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of n.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,401:7) [10384]"}
              n != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access n.AVLTreeNodebalanceFactor$. (AVLTree.sil,401:7) [10385]"}
                (perm[$frac] < Mask[n, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[n, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[n, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[n, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[n, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[n, AVLTreeNodebalanceFactor$] := PermSub(Mask[n, AVLTreeNodebalanceFactor$], perm);
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(n)] := PermAdd(Mask[null, AVLTreeNodevalid$(n)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume n != null;
            Mask[n, AVLTreeNodekeys$] := PermAdd(Mask[n, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume n != null;
            Mask[n, AVLTreeNodeheight$] := PermAdd(Mask[n, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume n != null;
            Mask[n, AVLTreeNodebalanceFactor$] := PermAdd(Mask[n, AVLTreeNodebalanceFactor$], perm);
            assume Heap[n, AVLTreeNodeheight$] == 1;
            assume Seq#Equal(Heap[n, AVLTreeNodekeys$], Seq#Singleton(k));
            assume Heap[n, AVLTreeNodebalanceFactor$] == 0;
            assume Seq#Contains(Heap[n, AVLTreeNodekeys$], k);
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. The parameter newK$_35 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,401:7) [10386]"}
            newK$_35[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_3.AVLTreeroot$ := n -- AVLTree.sil,403:5
        
        // -- Check definedness of this$_3.AVLTreeroot$
          assert {:msg "  Assignment might fail. Receiver of this$_3.AVLTreeroot$ might be null. (AVLTree.sil,403:5) [10387]"}
            this$_3 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,403:5) [10388]"}
            HasDirectPerm(Mask, this$_3, AVLTreeroot$);
          assume state(Heap, Mask);
        Heap[this$_3, AVLTreeroot$] := n;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,403:5) [10389]"}
          FullPerm[$frac] == Mask[this$_3, AVLTreeroot$][$frac] && FullPerm[$eps] == Mask[this$_3, AVLTreeroot$][$eps];
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: fresh newK$_36  -- AVLTree.sil,405:5
        
        // -- Translation of statement fresh newK$_36)
          havoc newK$_36;
          assume (newK$_36[$frac] > 0.000000000 && newK$_36[$frac] < 0.001000000) && newK$_36[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_36) -- AVLTree.sil,406:5
        
        // -- Translating statement: r := AVLTreeNodeinsert$(this$_3.AVLTreeroot$, newK$_36, k) -- AVLTree.sil,407:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Check definedness of this$_3.AVLTreeroot$
            assert {:msg "  Method call might fail. Receiver of this$_3.AVLTreeroot$ might be null. (AVLTree.sil,407:7) [10390]"}
              this$_3 != null;
            assert {:msg "  Method call might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,407:7) [10391]"}
              HasDirectPerm(Mask, this$_3, AVLTreeroot$);
            assume state(Heap, Mask);
          arg_this$_9 := Heap[this$_3, AVLTreeroot$];
          havoc r_1;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion this$_3.AVLTreeroot$ != null might not hold. (AVLTree.sil,407:7) [10392]"}
              Heap[this$_3, AVLTreeroot$] != null;
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion newK$_36 > none might not hold. (AVLTree.sil,407:7) [10393]"}
              NoPerm[$frac] < newK$_36[$frac] || (NoPerm[$frac] == newK$_36[$frac] && NoPerm[$eps] < newK$_36[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion write > newK$_36 might not hold. (AVLTree.sil,407:7) [10394]"}
              newK$_36[$frac] < FullPerm[$frac] || (newK$_36[$frac] == FullPerm[$frac] && newK$_36[$eps] < FullPerm[$eps]);
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_3.AVLTreeroot$). (AVLTree.sil,407:7) [10395]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,407:7) [10396]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_3.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,407:7) [10397]"}
              Heap[this$_3, AVLTreeroot$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,407:7) [10398]"}
                (perm[$frac] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,407:7) [10399]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_3.AVLTreeroot$.AVLTreeNodeheight$ might be null. (AVLTree.sil,407:7) [10400]"}
              Heap[this$_3, AVLTreeroot$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodeheight$. (AVLTree.sil,407:7) [10401]"}
                (perm[$frac] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,407:7) [10402]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_3.AVLTreeroot$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,407:7) [10403]"}
              Heap[this$_3, AVLTreeroot$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodebalanceFactor$. (AVLTree.sil,407:7) [10404]"}
                (perm[$frac] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            assume r_1 != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            assume Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k);
            assume (forall i: int ::
              
              Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], i) ==> Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i)
            );
            assume (forall i_1: int ::
              
              Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_1) ==> Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], i_1) || i_1 == k
            );
            if (Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], k)) {
              assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], PreCallHeap[arg_this$_9, AVLTreeNodekeys$]);
            }
            if (!Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], k)) {
              assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == Seq#Length(PreCallHeap[arg_this$_9, AVLTreeNodekeys$]) + 1;
            }
            assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9, AVLTreeNodeheight$] + 1;
            if (Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], k)) {
              assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9, AVLTreeNodeheight$];
            }
            assume state(Heap, Mask);
          assume r_1 == null || Heap[r_1, $allocated];
          assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. The parameter newK$_36 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,407:7) [10405]"}
            newK$_36[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_3.AVLTreeroot$ := r -- AVLTree.sil,409:5
        
        // -- Check definedness of this$_3.AVLTreeroot$
          assert {:msg "  Assignment might fail. Receiver of this$_3.AVLTreeroot$ might be null. (AVLTree.sil,409:5) [10406]"}
            this$_3 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,409:5) [10407]"}
            HasDirectPerm(Mask, this$_3, AVLTreeroot$);
          assume state(Heap, Mask);
        Heap[this$_3, AVLTreeroot$] := r_1;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,409:5) [10408]"}
          FullPerm[$frac] == Mask[this$_3, AVLTreeroot$][$frac] && FullPerm[$eps] == Mask[this$_3, AVLTreeroot$][$eps];
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_3.AVLTreekeys$ := this$_3.AVLTreeroot$.AVLTreeNodekeys$ -- AVLTree.sil,411:3
    
    // -- Check definedness of this$_3.AVLTreekeys$
      assert {:msg "  Assignment might fail. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,411:3) [10409]"}
        this$_3 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,411:3) [10410]"}
        HasDirectPerm(Mask, this$_3, AVLTreekeys$);
      assume state(Heap, Mask);
    
    // -- Check definedness of this$_3.AVLTreeroot$.AVLTreeNodekeys$
      assert {:msg "  Assignment might fail. Receiver of this$_3.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,411:3) [10411]"}
        Heap[this$_3, AVLTreeroot$] != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,411:3) [10412]"}
        HasDirectPerm(Mask, Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$);
      assert {:msg "  Assignment might fail. Receiver of this$_3.AVLTreeroot$ might be null. (AVLTree.sil,411:3) [10413]"}
        this$_3 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,411:3) [10414]"}
        HasDirectPerm(Mask, this$_3, AVLTreeroot$);
      assume state(Heap, Mask);
    Heap[this$_3, AVLTreekeys$] := Heap[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,411:3) [10415]"}
      FullPerm[$frac] == Mask[this$_3, AVLTreekeys$][$frac] && FullPerm[$eps] == Mask[this$_3, AVLTreekeys$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreevalid$(this$_3), write) -- AVLTree.sil,412:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_3));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,412:3) [10416]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Receiver of this$_3.AVLTreeroot$ might be null. (AVLTree.sil,412:3) [10417]"}
      this$_3 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access this$_3.AVLTreeroot$. (AVLTree.sil,412:3) [10418]"}
        (perm[$frac] < Mask[this$_3, AVLTreeroot$][$frac] || (perm[$frac] == Mask[this$_3, AVLTreeroot$][$frac] && perm[$eps] < Mask[this$_3, AVLTreeroot$][$eps])) || (perm[$frac] == Mask[this$_3, AVLTreeroot$][$frac] && perm[$eps] == Mask[this$_3, AVLTreeroot$][$eps]);
    }
    Mask[this$_3, AVLTreeroot$] := PermSub(Mask[this$_3, AVLTreeroot$], perm);
    assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,412:3) [10419]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,412:3) [10420]"}
      this$_3 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,412:3) [10421]"}
        (perm[$frac] < Mask[this$_3, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_3, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_3, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_3, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_3, AVLTreekeys$][$eps]);
    }
    Mask[this$_3, AVLTreekeys$] := PermSub(Mask[this$_3, AVLTreekeys$], perm);
    if (Heap[this$_3, AVLTreeroot$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_3.AVLTreeroot$). (AVLTree.sil,412:3) [10424]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_3, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_3)], Heap[this$_3, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])]);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,412:3) [10425]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Receiver of this$_3.AVLTreeroot$.AVLTreeNodeheight$ might be null. (AVLTree.sil,412:3) [10426]"}
        Heap[this$_3, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodeheight$. (AVLTree.sil,412:3) [10427]"}
          (perm[$frac] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,412:3) [10428]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Receiver of this$_3.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,412:3) [10429]"}
        Heap[this$_3, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,412:3) [10430]"}
          (perm[$frac] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,412:3) [10431]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Receiver of this$_3.AVLTreeroot$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,412:3) [10432]"}
        Heap[this$_3, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. There might be insufficient permission to access this$_3.AVLTreeroot$.AVLTreeNodebalanceFactor$. (AVLTree.sil,412:3) [10433]"}
          (perm[$frac] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Assertion this$_3.AVLTreekeys$ == this$_3.AVLTreeroot$.AVLTreeNodekeys$ might not hold. (AVLTree.sil,412:3) [10434]"}
        Seq#Equal(Heap[this$_3, AVLTreekeys$], Heap[Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_3, AVLTreeroot$] == null) {
      assert {:msg "  Folding AVLTreevalid$(this$_3) might fail. Assertion this$_3.AVLTreekeys$ == Seq() might not hold. (AVLTree.sil,412:3) [10435]"}
        Seq#Equal(Heap[this$_3, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_3, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_3, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_3)], Heap[this$_3, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_3, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_3, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_3)], Heap[this$_3, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_3, AVLTreeroot$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_3)] := PermAdd(Mask[null, AVLTreevalid$(this$_3)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreevalid$#sm(this$_3)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreevalid$(this$_3)] := freshVersion;
    Heap[null, AVLTreevalid$#sm(this$_3)][this$_3, AVLTreeroot$] := true;
    Heap[null, AVLTreevalid$#sm(this$_3)][this$_3, AVLTreekeys$] := true;
    if (Heap[this$_3, AVLTreeroot$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_3: Ref, f_6: (Field A B) ::
        { newPMask[o_3, f_6] }
        Heap[null, AVLTreevalid$#sm(this$_3)][o_3, f_6] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_3, AVLTreeroot$])][o_3, f_6] ==> newPMask[o_3, f_6]
      );
      Heap[null, AVLTreevalid$#sm(this$_3)] := newPMask;
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_3)][Heap[this$_3, AVLTreeroot$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_3)][Heap[this$_3, AVLTreeroot$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_3, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_3)][Heap[this$_3, AVLTreeroot$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. There might be insufficient permission to access AVLTreevalid$(this$_3). (AVLTree.sil,382:11) [10436]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_3)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_3)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_3)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_3)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_3)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_3)] := PermSub(Mask[null, AVLTreevalid$(this$_3)], perm);
    assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,383:11) [10437]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. Receiver of this$_3.AVLTreekeys$ might be null. (AVLTree.sil,383:11) [10438]"}
      this$_3 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. There might be insufficient permission to access this$_3.AVLTreekeys$. (AVLTree.sil,383:11) [10439]"}
        (perm[$frac] < Mask[this$_3, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_3, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_3, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_3, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_3, AVLTreekeys$][$eps]);
    }
    Mask[this$_3, AVLTreekeys$] := PermSub(Mask[this$_3, AVLTreekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. Assertion k in this$_3.AVLTreekeys$ might not hold. (AVLTree.sil,384:11) [10440]"}
      Seq#Contains(Heap[this$_3, AVLTreekeys$], k);
    assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. Assertion (forall j: Int :: true && j in old(this$_3.AVLTreekeys$) ==> j in this$_3.AVLTreekeys$) might not hold. (AVLTree.sil,385:12) [10441]"}
      (forall j_4: int ::
      
      Seq#Contains(old(Heap)[this$_3, AVLTreekeys$], j_4) ==> Seq#Contains(Heap[this$_3, AVLTreekeys$], j_4)
    );
    assert {:msg "  Postcondition of AVLTreeinsert$ might not hold. Assertion (forall j: Int :: true && j in this$_3.AVLTreekeys$ ==> j in old(this$_3.AVLTreekeys$) || (j == k)) might not hold. (AVLTree.sil,386:12) [10442]"}
      (forall j_5: int ::
      
      Seq#Contains(Heap[this$_3, AVLTreekeys$], j_5) ==> Seq#Contains(old(Heap)[this$_3, AVLTreekeys$], j_5) || j_5 == k
    );
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeremove$
// ==================================================

procedure AVLTreeremove$(this$_4: Ref, k$_2: Perm, k: int) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var j_6: int;
  var j_7: int;
  var oldVersion: int;
  var newVersion: int;
  var newK$_3: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_10: Ref;
  var r_1: Ref;
  var ExhaleHeap: HeapType;
  var freshVersion: int;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_4 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_2[$frac] || (NoPerm[$frac] == k$_2[$frac] && NoPerm[$eps] < k$_2[$eps]);
    assume state(Heap, Mask);
    assume k$_2[$frac] < FullPerm[$frac] || (k$_2[$frac] == FullPerm[$frac] && k$_2[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_4)] := PermAdd(Mask[null, AVLTreevalid$(this$_4)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_4 != null;
    Mask[this$_4, AVLTreekeys$] := PermAdd(Mask[this$_4, AVLTreekeys$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_4)] := PermAdd(Mask[null, AVLTreevalid$(this$_4)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_4 != null;
    Mask[this$_4, AVLTreekeys$] := PermAdd(Mask[this$_4, AVLTreekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of !k in this$_4.AVLTreekeys$
      assert {:msg "  Contract might not be well-formed. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,423:11) [10443]"}
        this$_4 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,423:11) [10444]"}
        HasDirectPerm(Mask, this$_4, AVLTreekeys$);
      assume state(Heap, Mask);
    assume !Seq#Contains(Heap[this$_4, AVLTreekeys$], k);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall j: Int :: true && j in old(this$_4.AVLTreekeys$) ==> j in this$_4.AVLTreekeys$ || (j == k))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,424:12) [10445]"}
        this$_4 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,424:12) [10446]"}
        HasDirectPerm(old(Mask), this$_4, AVLTreekeys$);
      if (Seq#Contains(old(Heap)[this$_4, AVLTreekeys$], j_6)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,424:12) [10447]"}
          this$_4 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,424:12) [10448]"}
          HasDirectPerm(Mask, this$_4, AVLTreekeys$);
      }
      assume state(Heap, Mask);
    assume (forall j_1: int ::
      
      Seq#Contains(old(Heap)[this$_4, AVLTreekeys$], j_1) ==> Seq#Contains(Heap[this$_4, AVLTreekeys$], j_1) || j_1 == k
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall j: Int :: true && j in this$_4.AVLTreekeys$ ==> j in old(this$_4.AVLTreekeys$) && (j != k))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,425:12) [10449]"}
        this$_4 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,425:12) [10450]"}
        HasDirectPerm(Mask, this$_4, AVLTreekeys$);
      if (Seq#Contains(Heap[this$_4, AVLTreekeys$], j_7)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,425:12) [10451]"}
          this$_4 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,425:12) [10452]"}
          HasDirectPerm(old(Mask), this$_4, AVLTreekeys$);
      }
      assume state(Heap, Mask);
    assume (forall j_3: int ::
      
      Seq#Contains(Heap[this$_4, AVLTreekeys$], j_3) ==> Seq#Contains(old(Heap)[this$_4, AVLTreekeys$], j_3) && j_3 != k
    );
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_4 == null || Heap[this$_4, $allocated];
    assume k$_2[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreevalid$(this$_4), write) -- AVLTree.sil,433:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_4));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access AVLTreevalid$(this$_4). (AVLTree.sil,433:3) [10455]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_4)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_4)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_4)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_4)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_4)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_4)] := PermSub(Mask[null, AVLTreevalid$(this$_4)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreevalid$(this$_4))) {
        oldVersion := Heap[null, AVLTreevalid$(this$_4)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreevalid$(this$_4)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_4 != null;
    Mask[this$_4, AVLTreeroot$] := PermAdd(Mask[this$_4, AVLTreeroot$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_4 != null;
    Mask[this$_4, AVLTreekeys$] := PermAdd(Mask[this$_4, AVLTreekeys$], perm);
    if (Heap[this$_4, AVLTreeroot$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_4, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_4)], Heap[this$_4, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])]);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_4, AVLTreeroot$] != null;
      Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_4, AVLTreeroot$] != null;
      Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_4, AVLTreeroot$] != null;
      Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      assume Seq#Equal(Heap[this$_4, AVLTreekeys$], Heap[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_4, AVLTreeroot$] == null) {
      assume Seq#Equal(Heap[this$_4, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_4.AVLTreeroot$ == null) -- AVLTree.sil,434:3
    
    // -- Check definedness of this$_4.AVLTreeroot$ == null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,434:7) [10456]"}
        HasDirectPerm(Mask, this$_4, AVLTreeroot$);
      assume state(Heap, Mask);
    if (Heap[this$_4, AVLTreeroot$] == null) {
    } else {
      
      // -- Translating statement: fresh newK$_3  -- AVLTree.sil,436:5
        
        // -- Translation of statement fresh newK$_3)
          havoc newK$_3;
          assume (newK$_3[$frac] > 0.000000000 && newK$_3[$frac] < 0.001000000) && newK$_3[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_3) -- AVLTree.sil,437:5
        
        // -- Translating statement: r := AVLTreeNoderemove$(this$_4.AVLTreeroot$, newK$_3, k) -- AVLTree.sil,438:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Check definedness of this$_4.AVLTreeroot$
            assert {:msg "  Method call might fail. Receiver of this$_4.AVLTreeroot$ might be null. (AVLTree.sil,438:7) [10457]"}
              this$_4 != null;
            assert {:msg "  Method call might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,438:7) [10458]"}
              HasDirectPerm(Mask, this$_4, AVLTreeroot$);
            assume state(Heap, Mask);
          arg_this$_10 := Heap[this$_4, AVLTreeroot$];
          havoc r_1;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion this$_4.AVLTreeroot$ != null might not hold. (AVLTree.sil,438:7) [10459]"}
              Heap[this$_4, AVLTreeroot$] != null;
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion newK$_3 > none might not hold. (AVLTree.sil,438:7) [10460]"}
              NoPerm[$frac] < newK$_3[$frac] || (NoPerm[$frac] == newK$_3[$frac] && NoPerm[$eps] < newK$_3[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion write > newK$_3 might not hold. (AVLTree.sil,438:7) [10461]"}
              newK$_3[$frac] < FullPerm[$frac] || (newK$_3[$frac] == FullPerm[$frac] && newK$_3[$eps] < FullPerm[$eps]);
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_4.AVLTreeroot$). (AVLTree.sil,438:7) [10462]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])], perm);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,438:7) [10463]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_4.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,438:7) [10464]"}
              Heap[this$_4, AVLTreeroot$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,438:7) [10465]"}
                (perm[$frac] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,438:7) [10466]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_4.AVLTreeroot$.AVLTreeNodeheight$ might be null. (AVLTree.sil,438:7) [10467]"}
              Heap[this$_4, AVLTreeroot$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodeheight$. (AVLTree.sil,438:7) [10468]"}
                (perm[$frac] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,438:7) [10469]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_4.AVLTreeroot$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,438:7) [10470]"}
              Heap[this$_4, AVLTreeroot$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodebalanceFactor$. (AVLTree.sil,438:7) [10471]"}
                (perm[$frac] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            if (Seq#Equal(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
              assume r_1 == null;
            }
            if (!Seq#Equal(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
              assume r_1 != null;
            }
            if (r_1 != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (r_1 != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume r_1 != null;
              Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            }
            if (r_1 != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume r_1 != null;
              Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            }
            if (r_1 != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume r_1 != null;
              Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            }
            if (r_1 != null) {
              assume !Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k);
            }
            if (r_1 != null) {
              assume (forall i: int ::
                
                Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], i) ==> Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i) || i == k
              );
            }
            if (r_1 != null) {
              assume (forall i_1: int ::
                
                Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_1) ==> Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], i_1) && i_1 != k
              );
            }
            if (!Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
              assume r_1 != null;
            }
            if (!Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
              assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], PreCallHeap[arg_this$_10, AVLTreeNodekeys$]);
            }
            if (r_1 != null) {
              if (Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
                assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == Seq#Length(PreCallHeap[arg_this$_10, AVLTreeNodekeys$]) - 1;
              }
            }
            if (PreCallHeap[arg_this$_10, AVLTreeNodeheight$] > 1) {
              assume r_1 != null;
            }
            if (r_1 != null) {
              assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[arg_this$_10, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] + 1 == PreCallHeap[arg_this$_10, AVLTreeNodeheight$];
            }
            if (!Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
              assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[arg_this$_10, AVLTreeNodeheight$];
            }
            assume state(Heap, Mask);
          assume r_1 == null || Heap[r_1, $allocated];
          assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. The parameter newK$_3 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,438:7) [10472]"}
            newK$_3[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_4.AVLTreeroot$ := r -- AVLTree.sil,440:5
        
        // -- Check definedness of this$_4.AVLTreeroot$
          assert {:msg "  Assignment might fail. Receiver of this$_4.AVLTreeroot$ might be null. (AVLTree.sil,440:5) [10473]"}
            this$_4 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,440:5) [10474]"}
            HasDirectPerm(Mask, this$_4, AVLTreeroot$);
          assume state(Heap, Mask);
        Heap[this$_4, AVLTreeroot$] := r_1;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,440:5) [10475]"}
          FullPerm[$frac] == Mask[this$_4, AVLTreeroot$][$frac] && FullPerm[$eps] == Mask[this$_4, AVLTreeroot$][$eps];
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_4.AVLTreekeys$ := (this$_4.AVLTreeroot$ == null ? Seq() : this$_4.AVLTreeroot$.AVLTreeNodekeys$) -- AVLTree.sil,441:5
        
        // -- Check definedness of this$_4.AVLTreekeys$
          assert {:msg "  Assignment might fail. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,441:5) [10476]"}
            this$_4 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,441:5) [10477]"}
            HasDirectPerm(Mask, this$_4, AVLTreekeys$);
          assume state(Heap, Mask);
        
        // -- Check definedness of (this$_4.AVLTreeroot$ == null ? Seq() : this$_4.AVLTreeroot$.AVLTreeNodekeys$)
          assert {:msg "  Assignment might fail. Receiver of this$_4.AVLTreeroot$ might be null. (AVLTree.sil,441:5) [10478]"}
            this$_4 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,441:5) [10479]"}
            HasDirectPerm(Mask, this$_4, AVLTreeroot$);
          if (Heap[this$_4, AVLTreeroot$] == null) {
          } else {
            assert {:msg "  Assignment might fail. Receiver of this$_4.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,441:5) [10480]"}
              Heap[this$_4, AVLTreeroot$] != null;
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,441:5) [10481]"}
              HasDirectPerm(Mask, Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$);
            assert {:msg "  Assignment might fail. Receiver of this$_4.AVLTreeroot$ might be null. (AVLTree.sil,441:5) [10482]"}
              this$_4 != null;
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,441:5) [10483]"}
              HasDirectPerm(Mask, this$_4, AVLTreeroot$);
          }
          assume state(Heap, Mask);
        Heap[this$_4, AVLTreekeys$] := (if Heap[this$_4, AVLTreeroot$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$]);
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,441:5) [10484]"}
          FullPerm[$frac] == Mask[this$_4, AVLTreekeys$][$frac] && FullPerm[$eps] == Mask[this$_4, AVLTreekeys$][$eps];
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreevalid$(this$_4), write) -- AVLTree.sil,443:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_4));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,443:3) [10485]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Receiver of this$_4.AVLTreeroot$ might be null. (AVLTree.sil,443:3) [10486]"}
      this$_4 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access this$_4.AVLTreeroot$. (AVLTree.sil,443:3) [10487]"}
        (perm[$frac] < Mask[this$_4, AVLTreeroot$][$frac] || (perm[$frac] == Mask[this$_4, AVLTreeroot$][$frac] && perm[$eps] < Mask[this$_4, AVLTreeroot$][$eps])) || (perm[$frac] == Mask[this$_4, AVLTreeroot$][$frac] && perm[$eps] == Mask[this$_4, AVLTreeroot$][$eps]);
    }
    Mask[this$_4, AVLTreeroot$] := PermSub(Mask[this$_4, AVLTreeroot$], perm);
    assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,443:3) [10488]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,443:3) [10489]"}
      this$_4 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,443:3) [10490]"}
        (perm[$frac] < Mask[this$_4, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_4, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_4, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_4, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_4, AVLTreekeys$][$eps]);
    }
    Mask[this$_4, AVLTreekeys$] := PermSub(Mask[this$_4, AVLTreekeys$], perm);
    if (Heap[this$_4, AVLTreeroot$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_4.AVLTreeroot$). (AVLTree.sil,443:3) [10493]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_4, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_4)], Heap[this$_4, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])]);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,443:3) [10494]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Receiver of this$_4.AVLTreeroot$.AVLTreeNodeheight$ might be null. (AVLTree.sil,443:3) [10495]"}
        Heap[this$_4, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodeheight$. (AVLTree.sil,443:3) [10496]"}
          (perm[$frac] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,443:3) [10497]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Receiver of this$_4.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,443:3) [10498]"}
        Heap[this$_4, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,443:3) [10499]"}
          (perm[$frac] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,443:3) [10500]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Receiver of this$_4.AVLTreeroot$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,443:3) [10501]"}
        Heap[this$_4, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. There might be insufficient permission to access this$_4.AVLTreeroot$.AVLTreeNodebalanceFactor$. (AVLTree.sil,443:3) [10502]"}
          (perm[$frac] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Assertion this$_4.AVLTreekeys$ == this$_4.AVLTreeroot$.AVLTreeNodekeys$ might not hold. (AVLTree.sil,443:3) [10503]"}
        Seq#Equal(Heap[this$_4, AVLTreekeys$], Heap[Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_4, AVLTreeroot$] == null) {
      assert {:msg "  Folding AVLTreevalid$(this$_4) might fail. Assertion this$_4.AVLTreekeys$ == Seq() might not hold. (AVLTree.sil,443:3) [10504]"}
        Seq#Equal(Heap[this$_4, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_4, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_4, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_4)], Heap[this$_4, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_4, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_4, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_4)], Heap[this$_4, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_4, AVLTreeroot$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_4)] := PermAdd(Mask[null, AVLTreevalid$(this$_4)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreevalid$#sm(this$_4)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreevalid$(this$_4)] := freshVersion;
    Heap[null, AVLTreevalid$#sm(this$_4)][this$_4, AVLTreeroot$] := true;
    Heap[null, AVLTreevalid$#sm(this$_4)][this$_4, AVLTreekeys$] := true;
    if (Heap[this$_4, AVLTreeroot$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_4: Ref, f_7: (Field A B) ::
        { newPMask[o_4, f_7] }
        Heap[null, AVLTreevalid$#sm(this$_4)][o_4, f_7] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_4, AVLTreeroot$])][o_4, f_7] ==> newPMask[o_4, f_7]
      );
      Heap[null, AVLTreevalid$#sm(this$_4)] := newPMask;
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_4)][Heap[this$_4, AVLTreeroot$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_4)][Heap[this$_4, AVLTreeroot$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_4, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_4)][Heap[this$_4, AVLTreeroot$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeremove$ might not hold. There might be insufficient permission to access AVLTreevalid$(this$_4). (AVLTree.sil,421:11) [10505]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_4)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_4)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_4)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_4)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_4)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_4)] := PermSub(Mask[null, AVLTreevalid$(this$_4)], perm);
    assert {:msg "  Postcondition of AVLTreeremove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,422:11) [10506]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeremove$ might not hold. Receiver of this$_4.AVLTreekeys$ might be null. (AVLTree.sil,422:11) [10507]"}
      this$_4 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeremove$ might not hold. There might be insufficient permission to access this$_4.AVLTreekeys$. (AVLTree.sil,422:11) [10508]"}
        (perm[$frac] < Mask[this$_4, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_4, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_4, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_4, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_4, AVLTreekeys$][$eps]);
    }
    Mask[this$_4, AVLTreekeys$] := PermSub(Mask[this$_4, AVLTreekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeremove$ might not hold. Assertion !k in this$_4.AVLTreekeys$ might not hold. (AVLTree.sil,423:11) [10509]"}
      !Seq#Contains(Heap[this$_4, AVLTreekeys$], k);
    assert {:msg "  Postcondition of AVLTreeremove$ might not hold. Assertion (forall j: Int :: true && j in old(this$_4.AVLTreekeys$) ==> j in this$_4.AVLTreekeys$ || (j == k)) might not hold. (AVLTree.sil,424:12) [10510]"}
      (forall j_4: int ::
      
      Seq#Contains(old(Heap)[this$_4, AVLTreekeys$], j_4) ==> Seq#Contains(Heap[this$_4, AVLTreekeys$], j_4) || j_4 == k
    );
    assert {:msg "  Postcondition of AVLTreeremove$ might not hold. Assertion (forall j: Int :: true && j in this$_4.AVLTreekeys$ ==> j in old(this$_4.AVLTreekeys$) && (j != k)) might not hold. (AVLTree.sil,425:12) [10511]"}
      (forall j_5: int ::
      
      Seq#Contains(Heap[this$_4, AVLTreekeys$], j_5) ==> Seq#Contains(old(Heap)[this$_4, AVLTreekeys$], j_5) && j_5 != k
    );
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreehas$
// ==================================================

procedure AVLTreehas$(this$_5: Ref, k$_3: Perm, k: int) returns (b_2: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var oldVersion: int;
  var newVersion: int;
  var newK$_2: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_13: Ref;
  var bb: bool;
  var ExhaleHeap: HeapType;
  var freshVersion: int;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_5 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_3[$frac] || (NoPerm[$frac] == k$_3[$frac] && NoPerm[$eps] < k$_3[$eps]);
    assume state(Heap, Mask);
    assume k$_3[$frac] < FullPerm[$frac] || (k$_3[$frac] == FullPerm[$frac] && k$_3[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_5)] := PermAdd(Mask[null, AVLTreevalid$(this$_5)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := k$_3;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_5 != null;
    Mask[this$_5, AVLTreekeys$] := PermAdd(Mask[this$_5, AVLTreekeys$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_5)] := PermAdd(Mask[null, AVLTreevalid$(this$_5)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := k$_3;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_5 != null;
    Mask[this$_5, AVLTreekeys$] := PermAdd(Mask[this$_5, AVLTreekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of b == k in this$_5.AVLTreekeys$
      assert {:msg "  Contract might not be well-formed. Receiver of this$_5.AVLTreekeys$ might be null. (AVLTree.sil,454:11) [10512]"}
        this$_5 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_5.AVLTreekeys$. (AVLTree.sil,454:11) [10513]"}
        HasDirectPerm(Mask, this$_5, AVLTreekeys$);
      assume state(Heap, Mask);
    assume b_2 == Seq#Contains(Heap[this$_5, AVLTreekeys$], k);
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_5 == null || Heap[this$_5, $allocated];
    assume k$_3[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreevalid$(this$_5), write) -- AVLTree.sil,462:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_5));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access AVLTreevalid$(this$_5). (AVLTree.sil,462:3) [10516]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_5)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_5)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_5)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_5)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_5)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_5)] := PermSub(Mask[null, AVLTreevalid$(this$_5)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreevalid$(this$_5))) {
        oldVersion := Heap[null, AVLTreevalid$(this$_5)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreevalid$(this$_5)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_5 != null;
    Mask[this$_5, AVLTreeroot$] := PermAdd(Mask[this$_5, AVLTreeroot$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_5 != null;
    Mask[this$_5, AVLTreekeys$] := PermAdd(Mask[this$_5, AVLTreekeys$], perm);
    if (Heap[this$_5, AVLTreeroot$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_5, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_5)], Heap[this$_5, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])]);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_5, AVLTreeroot$] != null;
      Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_5, AVLTreeroot$] != null;
      Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_5, AVLTreeroot$] != null;
      Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      assume Seq#Equal(Heap[this$_5, AVLTreekeys$], Heap[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_5, AVLTreeroot$] == null) {
      assume Seq#Equal(Heap[this$_5, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_5.AVLTreeroot$ == null) -- AVLTree.sil,463:3
    
    // -- Check definedness of this$_5.AVLTreeroot$ == null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_5.AVLTreeroot$. (AVLTree.sil,463:7) [10517]"}
        HasDirectPerm(Mask, this$_5, AVLTreeroot$);
      assume state(Heap, Mask);
    if (Heap[this$_5, AVLTreeroot$] == null) {
      
      // -- Translating statement: b := false -- AVLTree.sil,464:5
        b_2 := false;
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: fresh newK$_2  -- AVLTree.sil,466:5
        
        // -- Translation of statement fresh newK$_2)
          havoc newK$_2;
          assume (newK$_2[$frac] > 0.000000000 && newK$_2[$frac] < 0.001000000) && newK$_2[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_2) -- AVLTree.sil,467:5
        
        // -- Translating statement: bb := AVLTreeNodehas$(this$_5.AVLTreeroot$, newK$_2, k) -- AVLTree.sil,468:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Check definedness of this$_5.AVLTreeroot$
            assert {:msg "  Method call might fail. Receiver of this$_5.AVLTreeroot$ might be null. (AVLTree.sil,468:7) [10518]"}
              this$_5 != null;
            assert {:msg "  Method call might fail. There might be insufficient permission to access this$_5.AVLTreeroot$. (AVLTree.sil,468:7) [10519]"}
              HasDirectPerm(Mask, this$_5, AVLTreeroot$);
            assume state(Heap, Mask);
          arg_this$_13 := Heap[this$_5, AVLTreeroot$];
          havoc bb;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion this$_5.AVLTreeroot$ != null might not hold. (AVLTree.sil,468:7) [10520]"}
              Heap[this$_5, AVLTreeroot$] != null;
            assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion newK$_2 > none might not hold. (AVLTree.sil,468:7) [10521]"}
              NoPerm[$frac] < newK$_2[$frac] || (NoPerm[$frac] == newK$_2[$frac] && NoPerm[$eps] < newK$_2[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion write > newK$_2 might not hold. (AVLTree.sil,468:7) [10522]"}
              newK$_2[$frac] < FullPerm[$frac] || (newK$_2[$frac] == FullPerm[$frac] && newK$_2[$eps] < FullPerm[$eps]);
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_5.AVLTreeroot$). (AVLTree.sil,468:7) [10523]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])], perm);
            assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Fraction newK$_2 might not be positive. (AVLTree.sil,468:7) [10524]"}
              newK$_2[$frac] > 0.000000000 || (newK$_2[$frac] == 0.000000000 && newK$_2[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Receiver of this$_5.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,468:7) [10525]"}
              Heap[this$_5, AVLTreeroot$] != null;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            perm := NoPerm;
            perm := PermAdd(perm, newK$_2);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. There might be insufficient permission to access this$_5.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,468:7) [10526]"}
                Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$frac] > 0.000000000;
              assume perm[$frac] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$frac];
            }
            Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$], perm);
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(arg_this$_13)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_13)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := newK$_2;
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume arg_this$_13 != null;
            Mask[arg_this$_13, AVLTreeNodekeys$] := PermAdd(Mask[arg_this$_13, AVLTreeNodekeys$], perm);
            assume bb == Seq#Contains(Heap[arg_this$_13, AVLTreeNodekeys$], k);
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. The parameter newK$_2 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,468:7) [10527]"}
            newK$_2[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: b := bb -- AVLTree.sil,470:5
        b_2 := bb;
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreevalid$(this$_5), write) -- AVLTree.sil,472:3
    assume AVLTreevalid$#trigger(AVLTreevalid$(this$_5));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,472:3) [10528]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Receiver of this$_5.AVLTreeroot$ might be null. (AVLTree.sil,472:3) [10529]"}
      this$_5 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access this$_5.AVLTreeroot$. (AVLTree.sil,472:3) [10530]"}
        (perm[$frac] < Mask[this$_5, AVLTreeroot$][$frac] || (perm[$frac] == Mask[this$_5, AVLTreeroot$][$frac] && perm[$eps] < Mask[this$_5, AVLTreeroot$][$eps])) || (perm[$frac] == Mask[this$_5, AVLTreeroot$][$frac] && perm[$eps] == Mask[this$_5, AVLTreeroot$][$eps]);
    }
    Mask[this$_5, AVLTreeroot$] := PermSub(Mask[this$_5, AVLTreeroot$], perm);
    assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,472:3) [10531]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Receiver of this$_5.AVLTreekeys$ might be null. (AVLTree.sil,472:3) [10532]"}
      this$_5 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access this$_5.AVLTreekeys$. (AVLTree.sil,472:3) [10533]"}
        (perm[$frac] < Mask[this$_5, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_5, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_5, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_5, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_5, AVLTreekeys$][$eps]);
    }
    Mask[this$_5, AVLTreekeys$] := PermSub(Mask[this$_5, AVLTreekeys$], perm);
    if (Heap[this$_5, AVLTreeroot$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_5.AVLTreeroot$). (AVLTree.sil,472:3) [10536]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_5, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_5)], Heap[this$_5, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])]);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,472:3) [10537]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Receiver of this$_5.AVLTreeroot$.AVLTreeNodeheight$ might be null. (AVLTree.sil,472:3) [10538]"}
        Heap[this$_5, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access this$_5.AVLTreeroot$.AVLTreeNodeheight$. (AVLTree.sil,472:3) [10539]"}
          (perm[$frac] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,472:3) [10540]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Receiver of this$_5.AVLTreeroot$.AVLTreeNodekeys$ might be null. (AVLTree.sil,472:3) [10541]"}
        Heap[this$_5, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access this$_5.AVLTreeroot$.AVLTreeNodekeys$. (AVLTree.sil,472:3) [10542]"}
          (perm[$frac] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,472:3) [10543]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Receiver of this$_5.AVLTreeroot$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,472:3) [10544]"}
        Heap[this$_5, AVLTreeroot$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. There might be insufficient permission to access this$_5.AVLTreeroot$.AVLTreeNodebalanceFactor$. (AVLTree.sil,472:3) [10545]"}
          (perm[$frac] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Assertion this$_5.AVLTreekeys$ == this$_5.AVLTreeroot$.AVLTreeNodekeys$ might not hold. (AVLTree.sil,472:3) [10546]"}
        Seq#Equal(Heap[this$_5, AVLTreekeys$], Heap[Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$]);
    }
    if (Heap[this$_5, AVLTreeroot$] == null) {
      assert {:msg "  Folding AVLTreevalid$(this$_5) might fail. Assertion this$_5.AVLTreekeys$ == Seq() might not hold. (AVLTree.sil,472:3) [10547]"}
        Seq#Equal(Heap[this$_5, AVLTreekeys$], (Seq#Empty(): Seq_ int));
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_5, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_5, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_5)], Heap[this$_5, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_5, AVLTreeroot$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_5, AVLTreevalid$(special_ref), Heap[null, AVLTreevalid$(this$_5)], Heap[this$_5, AVLTreeroot$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_5, AVLTreeroot$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreevalid$(this$_5)] := PermAdd(Mask[null, AVLTreevalid$(this$_5)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreevalid$#sm(this$_5)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreevalid$(this$_5)] := freshVersion;
    Heap[null, AVLTreevalid$#sm(this$_5)][this$_5, AVLTreeroot$] := true;
    Heap[null, AVLTreevalid$#sm(this$_5)][this$_5, AVLTreekeys$] := true;
    if (Heap[this$_5, AVLTreeroot$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_5: Ref, f_8: (Field A B) ::
        { newPMask[o_5, f_8] }
        Heap[null, AVLTreevalid$#sm(this$_5)][o_5, f_8] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_5, AVLTreeroot$])][o_5, f_8] ==> newPMask[o_5, f_8]
      );
      Heap[null, AVLTreevalid$#sm(this$_5)] := newPMask;
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_5)][Heap[this$_5, AVLTreeroot$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_5)][Heap[this$_5, AVLTreeroot$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_5, AVLTreeroot$] != null) {
      Heap[null, AVLTreevalid$#sm(this$_5)][Heap[this$_5, AVLTreeroot$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreehas$ might not hold. There might be insufficient permission to access AVLTreevalid$(this$_5). (AVLTree.sil,452:11) [10548]"}
        (perm[$frac] < Mask[null, AVLTreevalid$(this$_5)][$frac] || (perm[$frac] == Mask[null, AVLTreevalid$(this$_5)][$frac] && perm[$eps] < Mask[null, AVLTreevalid$(this$_5)][$eps])) || (perm[$frac] == Mask[null, AVLTreevalid$(this$_5)][$frac] && perm[$eps] == Mask[null, AVLTreevalid$(this$_5)][$eps]);
    }
    Mask[null, AVLTreevalid$(this$_5)] := PermSub(Mask[null, AVLTreevalid$(this$_5)], perm);
    assert {:msg "  Postcondition of AVLTreehas$ might not hold. Fraction k$_3 might not be positive. (AVLTree.sil,453:11) [10549]"}
      k$_3[$frac] > 0.000000000 || (k$_3[$frac] == 0.000000000 && k$_3[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreehas$ might not hold. Receiver of this$_5.AVLTreekeys$ might be null. (AVLTree.sil,453:11) [10550]"}
      this$_5 != null;
    assert {:msg "  Postcondition of AVLTreehas$ might not hold. Assertion b == k in this$_5.AVLTreekeys$ might not hold. (AVLTree.sil,454:11) [10551]"}
      b_2 == Seq#Contains(Heap[this$_5, AVLTreekeys$], k);
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    perm := NoPerm;
    perm := PermAdd(perm, k$_3);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreehas$ might not hold. There might be insufficient permission to access this$_5.AVLTreekeys$. (AVLTree.sil,453:11) [10552]"}
        (perm[$frac] < Mask[this$_5, AVLTreekeys$][$frac] || (perm[$frac] == Mask[this$_5, AVLTreekeys$][$frac] && perm[$eps] < Mask[this$_5, AVLTreekeys$][$eps])) || (perm[$frac] == Mask[this$_5, AVLTreekeys$][$frac] && perm[$eps] == Mask[this$_5, AVLTreekeys$][$eps]);
    }
    Mask[this$_5, AVLTreekeys$] := PermSub(Mask[this$_5, AVLTreekeys$], perm);
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodeinit$
// ==================================================

procedure AVLTreeNodeinit$(this$_8: Ref, k$_4: Perm, k: int) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var newK$_21: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_8 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_4[$frac] || (NoPerm[$frac] == k$_4[$frac] && NoPerm[$eps] < k$_4[$eps]);
    assume state(Heap, Mask);
    assume k$_4[$frac] < FullPerm[$frac] || (k$_4[$frac] == FullPerm[$frac] && k$_4[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodekey$] := PermAdd(Mask[this$_8, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodeheight$] := PermAdd(Mask[this$_8, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodeleft$] := PermAdd(Mask[this$_8, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNoderight$] := PermAdd(Mask[this$_8, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodekeys$] := PermAdd(Mask[this$_8, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_8, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_8)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_8)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodekeys$] := PermAdd(Mask[this$_8, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodeheight$] := PermAdd(Mask[this$_8, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_8 != null;
    Mask[this$_8, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_8, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_8.AVLTreeNodeheight$ == 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_8.AVLTreeNodeheight$ might be null. (AVLTree.sil,489:11) [10553]"}
        this$_8 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_8.AVLTreeNodeheight$. (AVLTree.sil,489:11) [10554]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    assume Heap[this$_8, AVLTreeNodeheight$] == 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_8.AVLTreeNodekeys$ == Seq(k)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_8.AVLTreeNodekeys$ might be null. (AVLTree.sil,490:11) [10555]"}
        this$_8 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_8.AVLTreeNodekeys$. (AVLTree.sil,490:11) [10556]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[this$_8, AVLTreeNodekeys$], Seq#Singleton(k));
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_8.AVLTreeNodebalanceFactor$ == 0
      assert {:msg "  Contract might not be well-formed. Receiver of this$_8.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,491:11) [10557]"}
        this$_8 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_8.AVLTreeNodebalanceFactor$. (AVLTree.sil,491:11) [10558]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNodebalanceFactor$);
      assume state(Heap, Mask);
    assume Heap[this$_8, AVLTreeNodebalanceFactor$] == 0;
    assume state(Heap, Mask);
    
    // -- Check definedness of k in this$_8.AVLTreeNodekeys$
      assert {:msg "  Contract might not be well-formed. Receiver of this$_8.AVLTreeNodekeys$ might be null. (AVLTree.sil,492:11) [10559]"}
        this$_8 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_8.AVLTreeNodekeys$. (AVLTree.sil,492:11) [10560]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Contains(Heap[this$_8, AVLTreeNodekeys$], k);
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_8 == null || Heap[this$_8, $allocated];
    assume k$_4[$eps] == 0.000000000;
  
  // -- Translating statement: this$_8.AVLTreeNodeleft$ := null -- AVLTree.sil,499:3
    
    // -- Check definedness of this$_8.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_8.AVLTreeNodeleft$ might be null. (AVLTree.sil,499:3) [10561]"}
        this$_8 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_8.AVLTreeNodeleft$. (AVLTree.sil,499:3) [10562]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[this$_8, AVLTreeNodeleft$] := null;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_8.AVLTreeNodeleft$. (AVLTree.sil,499:3) [10563]"}
      FullPerm[$frac] == Mask[this$_8, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_8, AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_8.AVLTreeNoderight$ := null -- AVLTree.sil,500:3
    
    // -- Check definedness of this$_8.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_8.AVLTreeNoderight$ might be null. (AVLTree.sil,500:3) [10564]"}
        this$_8 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_8.AVLTreeNoderight$. (AVLTree.sil,500:3) [10565]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[this$_8, AVLTreeNoderight$] := null;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_8.AVLTreeNoderight$. (AVLTree.sil,500:3) [10566]"}
      FullPerm[$frac] == Mask[this$_8, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_8, AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_8.AVLTreeNodekey$ := k -- AVLTree.sil,501:3
    
    // -- Check definedness of this$_8.AVLTreeNodekey$
      assert {:msg "  Assignment might fail. Receiver of this$_8.AVLTreeNodekey$ might be null. (AVLTree.sil,501:3) [10567]"}
        this$_8 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_8.AVLTreeNodekey$. (AVLTree.sil,501:3) [10568]"}
        HasDirectPerm(Mask, this$_8, AVLTreeNodekey$);
      assume state(Heap, Mask);
    Heap[this$_8, AVLTreeNodekey$] := k;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_8.AVLTreeNodekey$. (AVLTree.sil,501:3) [10569]"}
      FullPerm[$frac] == Mask[this$_8, AVLTreeNodekey$][$frac] && FullPerm[$eps] == Mask[this$_8, AVLTreeNodekey$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: assert Seq(k)[0] == k -- AVLTree.sil,502:3
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion Seq(k)[0] == k might not hold. (AVLTree.sil,502:3) [10570]"}
      Seq#Index(Seq#Singleton(k), 0) == k;
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_21  -- AVLTree.sil,503:3
    
    // -- Translation of statement fresh newK$_21)
      havoc newK$_21;
      assume (newK$_21[$frac] > 0.000000000 && newK$_21[$frac] < 0.001000000) && newK$_21[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_21) -- AVLTree.sil,504:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_8, newK$_21) -- AVLTree.sil,505:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_8 != null might not hold. (AVLTree.sil,505:5) [10571]"}
          this$_8 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_21 > none might not hold. (AVLTree.sil,505:5) [10572]"}
          NoPerm[$frac] < newK$_21[$frac] || (NoPerm[$frac] == newK$_21[$frac] && NoPerm[$eps] < newK$_21[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_21 might not hold. (AVLTree.sil,505:5) [10573]"}
          newK$_21[$frac] < FullPerm[$frac] || (newK$_21[$frac] == FullPerm[$frac] && newK$_21[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,505:5) [10574]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodekey$ might be null. (AVLTree.sil,505:5) [10575]"}
          this$_8 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodekey$. (AVLTree.sil,505:5) [10576]"}
            (perm[$frac] < Mask[this$_8, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodekey$][$eps]);
        }
        Mask[this$_8, AVLTreeNodekey$] := PermSub(Mask[this$_8, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,505:5) [10577]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodeheight$ might be null. (AVLTree.sil,505:5) [10578]"}
          this$_8 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodeheight$. (AVLTree.sil,505:5) [10579]"}
            (perm[$frac] < Mask[this$_8, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodeheight$][$eps]);
        }
        Mask[this$_8, AVLTreeNodeheight$] := PermSub(Mask[this$_8, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,505:5) [10580]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodeleft$ might be null. (AVLTree.sil,505:5) [10581]"}
          this$_8 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodeleft$. (AVLTree.sil,505:5) [10582]"}
            (perm[$frac] < Mask[this$_8, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodeleft$][$eps]);
        }
        Mask[this$_8, AVLTreeNodeleft$] := PermSub(Mask[this$_8, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,505:5) [10583]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNoderight$ might be null. (AVLTree.sil,505:5) [10584]"}
          this$_8 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNoderight$. (AVLTree.sil,505:5) [10585]"}
            (perm[$frac] < Mask[this$_8, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNoderight$][$eps]);
        }
        Mask[this$_8, AVLTreeNoderight$] := PermSub(Mask[this$_8, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,505:5) [10586]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodekeys$ might be null. (AVLTree.sil,505:5) [10587]"}
          this$_8 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodekeys$. (AVLTree.sil,505:5) [10588]"}
            (perm[$frac] < Mask[this$_8, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodekeys$][$eps]);
        }
        Mask[this$_8, AVLTreeNodekeys$] := PermSub(Mask[this$_8, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,505:5) [10589]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,505:5) [10590]"}
          this$_8 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodebalanceFactor$. (AVLTree.sil,505:5) [10591]"}
            (perm[$frac] < Mask[this$_8, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[this$_8, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_8, AVLTreeNodebalanceFactor$], perm);
        if (Heap[this$_8, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_8.AVLTreeNodeleft$). (AVLTree.sil,505:5) [10592]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNodeleft$])], perm);
        }
        if (Heap[this$_8, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,505:5) [10593]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,505:5) [10594]"}
            Heap[this$_8, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,505:5) [10595]"}
              (perm[$frac] < Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_8, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,505:5) [10596]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,505:5) [10597]"}
            Heap[this$_8, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,505:5) [10598]"}
              (perm[$frac] < Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_8, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,505:5) [10599]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,505:5) [10600]"}
            Heap[this$_8, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,505:5) [10601]"}
              (perm[$frac] < Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_8, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_8.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_8.AVLTreeNodekey$)) might not hold. (AVLTree.sil,505:5) [10602]"}
            (forall k0: int ::
            
            Seq#Contains(Heap[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$], k0) ==> k0 < Heap[this$_8, AVLTreeNodekey$]
          );
        }
        if (Heap[this$_8, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_8.AVLTreeNoderight$). (AVLTree.sil,505:5) [10603]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_8, AVLTreeNoderight$])], perm);
        }
        if (Heap[this$_8, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,505:5) [10604]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,505:5) [10605]"}
            Heap[this$_8, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,505:5) [10606]"}
              (perm[$frac] < Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_8, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,505:5) [10607]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,505:5) [10608]"}
            Heap[this$_8, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,505:5) [10609]"}
              (perm[$frac] < Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_8, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,505:5) [10610]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_8.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,505:5) [10611]"}
            Heap[this$_8, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,505:5) [10612]"}
              (perm[$frac] < Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_8, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_8.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_8.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,505:5) [10613]"}
            (forall k1: int ::
            
            Seq#Contains(Heap[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$], k1) ==> Heap[this$_8, AVLTreeNodekey$] < k1
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_8.AVLTreeNodeleft$ == null ? 0 : this$_8.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_8.AVLTreeNoderight$ == null ? 0 : this$_8.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,505:5) [10614]"}
          (if Heap[this$_8, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_8, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_8.AVLTreeNodeleft$ == null ? 0 : this$_8.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_8.AVLTreeNoderight$ == null ? 0 : this$_8.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,505:5) [10615]"}
          (if Heap[this$_8, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_8, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(this$_8)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_8)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_8 != null;
        Mask[this$_8, AVLTreeNodeheight$] := PermAdd(Mask[this$_8, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_8 != null;
        Mask[this$_8, AVLTreeNodekeys$] := PermAdd(Mask[this$_8, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_8 != null;
        Mask[this$_8, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_8, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[this$_8, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_8, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_8, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_8, AVLTreeNodekey$])), (if PreCallHeap[this$_8, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_8, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[this$_8, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_8, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_8, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_8, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_8, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[this$_8, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_8, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_8, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_8, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_8, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_21 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,505:5) [10616]"}
        newK$_21[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_8). (AVLTree.sil,485:11) [10617]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_8)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_8)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_8)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_8)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_8)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_8)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_8)], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,486:11) [10618]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Receiver of this$_8.AVLTreeNodekeys$ might be null. (AVLTree.sil,486:11) [10619]"}
      this$_8 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodekeys$. (AVLTree.sil,486:11) [10620]"}
        (perm[$frac] < Mask[this$_8, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodekeys$][$eps]);
    }
    Mask[this$_8, AVLTreeNodekeys$] := PermSub(Mask[this$_8, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,487:11) [10621]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Receiver of this$_8.AVLTreeNodeheight$ might be null. (AVLTree.sil,487:11) [10622]"}
      this$_8 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodeheight$. (AVLTree.sil,487:11) [10623]"}
        (perm[$frac] < Mask[this$_8, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodeheight$][$eps]);
    }
    Mask[this$_8, AVLTreeNodeheight$] := PermSub(Mask[this$_8, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,488:11) [10624]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Receiver of this$_8.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,488:11) [10625]"}
      this$_8 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. There might be insufficient permission to access this$_8.AVLTreeNodebalanceFactor$. (AVLTree.sil,488:11) [10626]"}
        (perm[$frac] < Mask[this$_8, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_8, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_8, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_8, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_8, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[this$_8, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_8, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Assertion this$_8.AVLTreeNodeheight$ == 1 might not hold. (AVLTree.sil,489:11) [10627]"}
      Heap[this$_8, AVLTreeNodeheight$] == 1;
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Assertion this$_8.AVLTreeNodekeys$ == Seq(k) might not hold. (AVLTree.sil,490:11) [10628]"}
      Seq#Equal(Heap[this$_8, AVLTreeNodekeys$], Seq#Singleton(k));
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Assertion this$_8.AVLTreeNodebalanceFactor$ == 0 might not hold. (AVLTree.sil,491:11) [10629]"}
      Heap[this$_8, AVLTreeNodebalanceFactor$] == 0;
    assert {:msg "  Postcondition of AVLTreeNodeinit$ might not hold. Assertion k in this$_8.AVLTreeNodekeys$ might not hold. (AVLTree.sil,492:11) [10630]"}
      Seq#Contains(Heap[this$_8, AVLTreeNodekeys$], k);
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodeinsert$
// ==================================================

procedure AVLTreeNodeinsert$(this$_9: Ref, k$_5: Perm, k: int) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var i_2: int;
  var i_3: int;
  var oldVersion: int;
  var newVersion: int;
  var newK$_4: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var freshObj: Ref;
  var n$_5: Ref;
  var nl: Ref;
  var newK$_5: Perm;
  var newK$_6: Perm;
  var arg_this$_9: Ref;
  var newK$_7: Perm;
  var bf: int;
  var newK$_8: Perm;
  var newK$_9: Perm;
  var nr: Ref;
  var newK$_10: Perm;
  var newK$_11: Perm;
  var arg_this$_9_1: Ref;
  var newK$_12: Perm;
  var newK$_13: Perm;
  var newK$_14: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_9 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_5[$frac] || (NoPerm[$frac] == k$_5[$frac] && NoPerm[$eps] < k$_5[$eps]);
    assume state(Heap, Mask);
    assume k$_5[$frac] < FullPerm[$frac] || (k$_5[$frac] == FullPerm[$frac] && k$_5[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_9)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_9)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodekeys$] := PermAdd(Mask[this$_9, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodeheight$] := PermAdd(Mask[this$_9, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_9, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of k in r.AVLTreeNodekeys$
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,522:11) [10631]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,522:11) [10632]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall i: Int :: true && i in old(this$_9.AVLTreeNodekeys$) ==> i in r.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,523:12) [10633]"}
        this$_9 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,523:12) [10634]"}
        HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
      if (Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], i_2)) {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,523:12) [10635]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,523:12) [10636]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      }
      assume state(Heap, Mask);
    assume (forall i_1: int ::
      
      Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], i_1) ==> Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_1)
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall i: Int :: true && i in r.AVLTreeNodekeys$ ==> i in old(this$_9.AVLTreeNodekeys$) || (i == k))
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,524:12) [10637]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,524:12) [10638]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_3)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,524:12) [10639]"}
          this$_9 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,524:12) [10640]"}
          HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
      }
      assume state(Heap, Mask);
    assume (forall i_3_1: int ::
      
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_3_1) ==> Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], i_3_1) || i_3_1 == k
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of k in old(this$_9.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,525:11) [10641]"}
        this$_9 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,525:11) [10642]"}
        HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], k)) {
      
      // -- Check definedness of r.AVLTreeNodekeys$ == old(this$_9.AVLTreeNodekeys$)
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,525:11) [10643]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,525:11) [10644]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,525:11) [10645]"}
          this$_9 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,525:11) [10646]"}
          HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], old(Heap)[this$_9, AVLTreeNodekeys$]);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of !k in old(this$_9.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,526:11) [10647]"}
        this$_9 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,526:11) [10648]"}
        HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (!Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], k)) {
      
      // -- Check definedness of |r.AVLTreeNodekeys$| == |old(this$_9.AVLTreeNodekeys$)| + 1
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,526:11) [10649]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,526:11) [10650]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,526:11) [10651]"}
          this$_9 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,526:11) [10652]"}
          HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == Seq#Length(old(Heap)[this$_9, AVLTreeNodekeys$]) + 1;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,527:11) [10653]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,527:11) [10654]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodeheight$ might be null. (AVLTree.sil,527:11) [10655]"}
        this$_9 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodeheight$. (AVLTree.sil,527:11) [10656]"}
        HasDirectPerm(old(Mask), this$_9, AVLTreeNodeheight$);
      if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$])) {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,527:11) [10657]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,527:11) [10658]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodeheight$ might be null. (AVLTree.sil,527:11) [10659]"}
          this$_9 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodeheight$. (AVLTree.sil,527:11) [10660]"}
          HasDirectPerm(old(Mask), this$_9, AVLTreeNodeheight$);
      }
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$] + 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of k in old(this$_9.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,528:11) [10661]"}
        this$_9 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,528:11) [10662]"}
        HasDirectPerm(old(Mask), this$_9, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], k)) {
      
      // -- Check definedness of r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$)
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,528:11) [10663]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,528:11) [10664]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_9.AVLTreeNodeheight$ might be null. (AVLTree.sil,528:11) [10665]"}
          this$_9 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_9.AVLTreeNodeheight$. (AVLTree.sil,528:11) [10666]"}
          HasDirectPerm(old(Mask), this$_9, AVLTreeNodeheight$);
        assume state(Heap, Mask);
      assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$];
      assume state(Heap, Mask);
    }
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_9 == null || Heap[this$_9, $allocated];
    assume k$_5[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_9), write) -- AVLTree.sil,548:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_9));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_9) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_9). (AVLTree.sil,548:3) [10669]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_9)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_9)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_9)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_9)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_9)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_9)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_9)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(this$_9))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(this$_9)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(this$_9)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodekey$] := PermAdd(Mask[this$_9, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodeheight$] := PermAdd(Mask[this$_9, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodeleft$] := PermAdd(Mask[this$_9, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNoderight$] := PermAdd(Mask[this$_9, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodekeys$] := PermAdd(Mask[this$_9, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_9 != null;
    Mask[this$_9, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_9, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_9, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_9)], Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_9, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_9, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_9, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[this$_9, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_9, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_9, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_9)], Heap[this$_9, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])]);
    }
    if (Heap[this$_9, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_9, AVLTreeNoderight$] != null;
      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_9, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_9, AVLTreeNoderight$] != null;
      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_9, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_9, AVLTreeNoderight$] != null;
      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_9, AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[this$_9, AVLTreeNodekey$] < rk
      );
    }
    if (Heap[this$_9, AVLTreeNoderight$] != null) {
      assume Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[this$_9, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_9, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_9, AVLTreeNodekey$])), (if Heap[this$_9, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[this$_9, AVLTreeNodekeys$], Heap[this$_9, AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[this$_9, AVLTreeNodekeys$], kk) == ((Heap[this$_9, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[this$_9, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[this$_9, AVLTreeNodekey$]))
    );
    assume Heap[this$_9, AVLTreeNodeheight$] == (if (if Heap[this$_9, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_9, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_9, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_9, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[this$_9, AVLTreeNodebalanceFactor$] == (if Heap[this$_9, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_9, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[this$_9, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[this$_9, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[this$_9, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_9.AVLTreeNodekey$ == k) -- AVLTree.sil,549:3
    
    // -- Check definedness of this$_9.AVLTreeNodekey$ == k
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_9.AVLTreeNodekey$. (AVLTree.sil,549:7) [10670]"}
        HasDirectPerm(Mask, this$_9, AVLTreeNodekey$);
      assume state(Heap, Mask);
    if (Heap[this$_9, AVLTreeNodekey$] == k) {
      
      // -- Translating statement: r := this$_9 -- AVLTree.sil,550:5
        r_1 := this$_9;
        assume state(Heap, Mask);
      
      // -- Translating statement: assert k == Seq(this$_9.AVLTreeNodekey$)[0] -- AVLTree.sil,551:5
        
        // -- Check definedness of k == Seq(this$_9.AVLTreeNodekey$)[0]
          assert {:msg "  Assert might fail. Receiver of this$_9.AVLTreeNodekey$ might be null. (AVLTree.sil,551:5) [10671]"}
            this$_9 != null;
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_9.AVLTreeNodekey$. (AVLTree.sil,551:5) [10672]"}
            HasDirectPerm(Mask, this$_9, AVLTreeNodekey$);
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  Assert might fail. Assertion k == Seq(this$_9.AVLTreeNodekey$)[0] might not hold. (AVLTree.sil,551:5) [10673]"}
          k == Seq#Index(Seq#Singleton(Heap[this$_9, AVLTreeNodekey$]), 0);
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_4  -- AVLTree.sil,552:5
        
        // -- Translation of statement fresh newK$_4)
          havoc newK$_4;
          assume (newK$_4[$frac] > 0.000000000 && newK$_4[$frac] < 0.001000000) && newK$_4[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_4) -- AVLTree.sil,553:5
        
        // -- Translating statement: AVLTreeNodeclose$(r, newK$_4) -- AVLTree.sil,554:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,554:7) [10674]"}
              r_1 != null;
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_4 > none might not hold. (AVLTree.sil,554:7) [10675]"}
              NoPerm[$frac] < newK$_4[$frac] || (NoPerm[$frac] == newK$_4[$frac] && NoPerm[$eps] < newK$_4[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_4 might not hold. (AVLTree.sil,554:7) [10676]"}
              newK$_4[$frac] < FullPerm[$frac] || (newK$_4[$frac] == FullPerm[$frac] && newK$_4[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,554:7) [10677]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,554:7) [10678]"}
              r_1 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,554:7) [10679]"}
                (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
            }
            Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,554:7) [10680]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,554:7) [10681]"}
              r_1 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,554:7) [10682]"}
                (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
            }
            Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,554:7) [10683]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,554:7) [10684]"}
              r_1 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,554:7) [10685]"}
                (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
            }
            Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,554:7) [10686]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,554:7) [10687]"}
              r_1 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,554:7) [10688]"}
                (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
            }
            Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,554:7) [10689]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,554:7) [10690]"}
              r_1 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,554:7) [10691]"}
                (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
            }
            Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,554:7) [10692]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,554:7) [10693]"}
              r_1 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,554:7) [10694]"}
                (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,554:7) [10695]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,554:7) [10696]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,554:7) [10697]"}
                Heap[r_1, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,554:7) [10698]"}
                  (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,554:7) [10699]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,554:7) [10700]"}
                Heap[r_1, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,554:7) [10701]"}
                  (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,554:7) [10702]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,554:7) [10703]"}
                Heap[r_1, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,554:7) [10704]"}
                  (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,554:7) [10705]"}
                (forall k0: int ::
                
                Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0) ==> k0 < Heap[r_1, AVLTreeNodekey$]
              );
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,554:7) [10706]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,554:7) [10707]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,554:7) [10708]"}
                Heap[r_1, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,554:7) [10709]"}
                  (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,554:7) [10710]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,554:7) [10711]"}
                Heap[r_1, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,554:7) [10712]"}
                  (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,554:7) [10713]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,554:7) [10714]"}
                Heap[r_1, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,554:7) [10715]"}
                  (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,554:7) [10716]"}
                (forall k1: int ::
                
                Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1) ==> Heap[r_1, AVLTreeNodekey$] < k1
              );
            }
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,554:7) [10717]"}
              (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,554:7) [10718]"}
              (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
            assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
            assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_4 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,554:7) [10719]"}
            newK$_4[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: if (k < this$_9.AVLTreeNodekey$) -- AVLTree.sil,556:5
        
        // -- Check definedness of k < this$_9.AVLTreeNodekey$
          assert {:msg "  Conditional statement might fail. Receiver of this$_9.AVLTreeNodekey$ might be null. (AVLTree.sil,556:12) [10720]"}
            this$_9 != null;
          assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_9.AVLTreeNodekey$. (AVLTree.sil,556:12) [10721]"}
            HasDirectPerm(Mask, this$_9, AVLTreeNodekey$);
          assume state(Heap, Mask);
        if (k < Heap[this$_9, AVLTreeNodekey$]) {
          
          // -- Translating statement: if (this$_9.AVLTreeNodeleft$ == null) -- AVLTree.sil,557:5
            
            // -- Check definedness of this$_9.AVLTreeNodeleft$ == null
              assert {:msg "  Conditional statement might fail. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,557:9) [10722]"}
                this$_9 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,557:9) [10723]"}
                HasDirectPerm(Mask, this$_9, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            if (Heap[this$_9, AVLTreeNodeleft$] == null) {
              
              // -- Translating statement: n$_5 := new(old$methodPermission, joinable$, AVLTreeroot$, AVLTreekeys$, AVLTreeNodekey$, AVLTreeNodeheight$, AVLTreeNodeleft$, AVLTreeNoderight$, AVLTreeNodekeys$, AVLTreeNodebalanceFactor$, par$AVLTreeinit$this$_2, par$AVLTreeinit$k$, old$AVLTreeinsert$0, old$AVLTreeinsert$1, par$AVLTreeinsert$this$_3, par$AVLTreeinsert$k$_1, par$AVLTreeinsert$k, old$AVLTreeremove$0, old$AVLTreeremove$1, par$AVLTreeremove$this$_4, par$AVLTreeremove$k$_2, par$AVLTreeremove$k, par$AVLTreehas$this$_5, par$AVLTreehas$k$_3, par$AVLTreehas$k, par$AVLTreeNodeinit$this$_8, par$AVLTreeNodeinit$k$_4, par$AVLTreeNodeinit$k, old$AVLTreeNodeinsert$0, old$AVLTreeNodeinsert$1, old$AVLTreeNodeinsert$2, old$AVLTreeNodeinsert$3, old$AVLTreeNodeinsert$4, old$AVLTreeNodeinsert$5, old$AVLTreeNodeinsert$6, old$AVLTreeNodeinsert$7, old$AVLTreeNodeinsert$8, old$AVLTreeNodeinsert$9, par$AVLTreeNodeinsert$this$_9, par$AVLTreeNodeinsert$k$_5, par$AVLTreeNodeinsert$k, old$AVLTreeNoderemove$0, old$AVLTreeNoderemove$1, old$AVLTreeNoderemove$2, old$AVLTreeNoderemove$3, old$AVLTreeNoderemove$4, old$AVLTreeNoderemove$5, old$AVLTreeNoderemove$6, old$AVLTreeNoderemove$7, old$AVLTreeNoderemove$8, old$AVLTreeNoderemove$9, old$AVLTreeNoderemove$10, old$AVLTreeNoderemove$11, old$AVLTreeNoderemove$12, old$AVLTreeNoderemove$13, par$AVLTreeNoderemove$this$_10, par$AVLTreeNoderemove$k$_6, par$AVLTreeNoderemove$k, old$AVLTreeNodepruneMax$0, old$AVLTreeNodepruneMax$1, old$AVLTreeNodepruneMax$2, old$AVLTreeNodepruneMax$3, old$AVLTreeNodepruneMax$4, old$AVLTreeNodepruneMax$5, old$AVLTreeNodepruneMax$6, old$AVLTreeNodepruneMax$7, par$AVLTreeNodepruneMax$this$_11, par$AVLTreeNodepruneMax$k$_7, old$AVLTreeNodepruneMin$0, old$AVLTreeNodepruneMin$1, old$AVLTreeNodepruneMin$2, old$AVLTreeNodepruneMin$3, old$AVLTreeNodepruneMin$4, old$AVLTreeNodepruneMin$5, old$AVLTreeNodepruneMin$6, old$AVLTreeNodepruneMin$7, par$AVLTreeNodepruneMin$this$_12, par$AVLTreeNodepruneMin$k$_8, par$AVLTreeNodehas$this$_13, par$AVLTreeNodehas$k$_9, par$AVLTreeNodehas$k, par$AVLTreeNodegetBalanceFactor$this$_14, par$AVLTreeNodegetBalanceFactor$k$_10, par$AVLTreeNodegetBalanceFactorI$this$_15, par$AVLTreeNodegetBalanceFactorI$k$_11, old$AVLTreeNodeclose$0, old$AVLTreeNodeclose$1, old$AVLTreeNodeclose$2, old$AVLTreeNodeclose$3, old$AVLTreeNodeclose$4, old$AVLTreeNodeclose$5, old$AVLTreeNodeclose$6, old$AVLTreeNodeclose$7, old$AVLTreeNodeclose$8, old$AVLTreeNodeclose$9, old$AVLTreeNodeclose$10, old$AVLTreeNodeclose$11, old$AVLTreeNodeclose$12, old$AVLTreeNodeclose$13, old$AVLTreeNodeclose$14, old$AVLTreeNodeclose$15, old$AVLTreeNodeclose$16, par$AVLTreeNodeclose$this$_16, par$AVLTreeNodeclose$k$_12, old$AVLTreeNoderebalanceLeft$0, old$AVLTreeNoderebalanceLeft$1, old$AVLTreeNoderebalanceLeft$2, old$AVLTreeNoderebalanceLeft$3, old$AVLTreeNoderebalanceLeft$4, old$AVLTreeNoderebalanceLeft$5, par$AVLTreeNoderebalanceLeft$this$_17, par$AVLTreeNoderebalanceLeft$k$_13, old$AVLTreeNoderebalanceRL$0, old$AVLTreeNoderebalanceRL$1, old$AVLTreeNoderebalanceRL$2, old$AVLTreeNoderebalanceRL$3, old$AVLTreeNoderebalanceRL$4, par$AVLTreeNoderebalanceRL$this$_18, par$AVLTreeNoderebalanceRL$k$_14, old$AVLTreeNoderebalanceRR$0, old$AVLTreeNoderebalanceRR$1, old$AVLTreeNoderebalanceRR$2, old$AVLTreeNoderebalanceRR$3, old$AVLTreeNoderebalanceRR$4, old$AVLTreeNoderebalanceRR$5, par$AVLTreeNoderebalanceRR$this$_19, par$AVLTreeNoderebalanceRR$k$_15, old$AVLTreeNoderebalanceRight$0, old$AVLTreeNoderebalanceRight$1, old$AVLTreeNoderebalanceRight$2, old$AVLTreeNoderebalanceRight$3, old$AVLTreeNoderebalanceRight$4, old$AVLTreeNoderebalanceRight$5, par$AVLTreeNoderebalanceRight$this$_20, par$AVLTreeNoderebalanceRight$k$_16, old$AVLTreeNoderebalanceLR$0, old$AVLTreeNoderebalanceLR$1, old$AVLTreeNoderebalanceLR$2, old$AVLTreeNoderebalanceLR$3, old$AVLTreeNoderebalanceLR$4, par$AVLTreeNoderebalanceLR$this$_21, par$AVLTreeNoderebalanceLR$k$_17, old$AVLTreeNoderebalanceLL$0, old$AVLTreeNoderebalanceLL$1, old$AVLTreeNoderebalanceLL$2, old$AVLTreeNoderebalanceLL$3, old$AVLTreeNoderebalanceLL$4, old$AVLTreeNoderebalanceLL$5, par$AVLTreeNoderebalanceLL$this$_22, par$AVLTreeNoderebalanceLL$k$_18) -- AVLTree.sil,558:7
                havoc freshObj;
                assume freshObj != null && !Heap[freshObj, $allocated];
                Heap[freshObj, $allocated] := true;
                n$_5 := freshObj;
                Mask[n$_5, old$methodPermission] := FullPerm;
                Mask[n$_5, joinable$] := FullPerm;
                Mask[n$_5, AVLTreeroot$] := FullPerm;
                Mask[n$_5, AVLTreekeys$] := FullPerm;
                Mask[n$_5, AVLTreeNodekey$] := FullPerm;
                Mask[n$_5, AVLTreeNodeheight$] := FullPerm;
                Mask[n$_5, AVLTreeNodeleft$] := FullPerm;
                Mask[n$_5, AVLTreeNoderight$] := FullPerm;
                Mask[n$_5, AVLTreeNodekeys$] := FullPerm;
                Mask[n$_5, AVLTreeNodebalanceFactor$] := FullPerm;
                Mask[n$_5, par$AVLTreeinit$this$_2] := FullPerm;
                Mask[n$_5, par$AVLTreeinit$k$] := FullPerm;
                Mask[n$_5, old$AVLTreeinsert$0] := FullPerm;
                Mask[n$_5, old$AVLTreeinsert$1] := FullPerm;
                Mask[n$_5, par$AVLTreeinsert$this$_3] := FullPerm;
                Mask[n$_5, par$AVLTreeinsert$k$_1] := FullPerm;
                Mask[n$_5, par$AVLTreeinsert$k] := FullPerm;
                Mask[n$_5, old$AVLTreeremove$0] := FullPerm;
                Mask[n$_5, old$AVLTreeremove$1] := FullPerm;
                Mask[n$_5, par$AVLTreeremove$this$_4] := FullPerm;
                Mask[n$_5, par$AVLTreeremove$k$_2] := FullPerm;
                Mask[n$_5, par$AVLTreeremove$k] := FullPerm;
                Mask[n$_5, par$AVLTreehas$this$_5] := FullPerm;
                Mask[n$_5, par$AVLTreehas$k$_3] := FullPerm;
                Mask[n$_5, par$AVLTreehas$k] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinit$this$_8] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinit$k$_4] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinit$k] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$7] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$8] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$9] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinsert$this$_9] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinsert$k$_5] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinsert$k] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$7] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$8] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$9] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$10] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$11] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$12] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$13] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderemove$this$_10] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderemove$k$_6] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderemove$k] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$7] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMax$this$_11] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMax$k$_7] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$7] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMin$this$_12] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMin$k$_8] := FullPerm;
                Mask[n$_5, par$AVLTreeNodehas$this$_13] := FullPerm;
                Mask[n$_5, par$AVLTreeNodehas$k$_9] := FullPerm;
                Mask[n$_5, par$AVLTreeNodehas$k] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactor$this$_14] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactor$k$_10] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactorI$this$_15] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactorI$k$_11] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$7] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$8] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$9] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$10] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$11] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$12] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$13] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$14] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$15] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$16] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeclose$this$_16] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeclose$k$_12] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLeft$this$_17] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLeft$k$_13] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$4] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRL$this$_18] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRL$k$_14] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRR$this$_19] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRR$k$_15] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRight$this$_20] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRight$k$_16] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$4] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLR$this$_21] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLR$k$_17] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLL$this$_22] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLL$k$_18] := FullPerm;
                assume state(Heap, Mask);
              
              // -- Translating statement: nl := n$_5 -- AVLTree.sil,559:7
                nl := n$_5;
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_5  -- AVLTree.sil,560:7
                
                // -- Translation of statement fresh newK$_5)
                  havoc newK$_5;
                  assume (newK$_5[$frac] > 0.000000000 && newK$_5[$frac] < 0.001000000) && newK$_5[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_5) -- AVLTree.sil,561:7
                
                // -- Translating statement: AVLTreeNodeinit$(nl, newK$_5, k) -- AVLTree.sil,562:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion nl != null might not hold. (AVLTree.sil,562:9) [10724]"}
                      nl != null;
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion newK$_5 > none might not hold. (AVLTree.sil,562:9) [10725]"}
                      NoPerm[$frac] < newK$_5[$frac] || (NoPerm[$frac] == newK$_5[$frac] && NoPerm[$eps] < newK$_5[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion write > newK$_5 might not hold. (AVLTree.sil,562:9) [10726]"}
                      newK$_5[$frac] < FullPerm[$frac] || (newK$_5[$frac] == FullPerm[$frac] && newK$_5[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,562:9) [10727]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nl.AVLTreeNodekey$ might be null. (AVLTree.sil,562:9) [10728]"}
                      nl != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nl.AVLTreeNodekey$. (AVLTree.sil,562:9) [10729]"}
                        (perm[$frac] < Mask[nl, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[nl, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[nl, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[nl, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[nl, AVLTreeNodekey$][$eps]);
                    }
                    Mask[nl, AVLTreeNodekey$] := PermSub(Mask[nl, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,562:9) [10730]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nl.AVLTreeNodeheight$ might be null. (AVLTree.sil,562:9) [10731]"}
                      nl != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nl.AVLTreeNodeheight$. (AVLTree.sil,562:9) [10732]"}
                        (perm[$frac] < Mask[nl, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[nl, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[nl, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[nl, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[nl, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[nl, AVLTreeNodeheight$] := PermSub(Mask[nl, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,562:9) [10733]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nl.AVLTreeNodeleft$ might be null. (AVLTree.sil,562:9) [10734]"}
                      nl != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nl.AVLTreeNodeleft$. (AVLTree.sil,562:9) [10735]"}
                        (perm[$frac] < Mask[nl, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[nl, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[nl, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[nl, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[nl, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[nl, AVLTreeNodeleft$] := PermSub(Mask[nl, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,562:9) [10736]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nl.AVLTreeNoderight$ might be null. (AVLTree.sil,562:9) [10737]"}
                      nl != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nl.AVLTreeNoderight$. (AVLTree.sil,562:9) [10738]"}
                        (perm[$frac] < Mask[nl, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[nl, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[nl, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[nl, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[nl, AVLTreeNoderight$][$eps]);
                    }
                    Mask[nl, AVLTreeNoderight$] := PermSub(Mask[nl, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,562:9) [10739]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nl.AVLTreeNodekeys$ might be null. (AVLTree.sil,562:9) [10740]"}
                      nl != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nl.AVLTreeNodekeys$. (AVLTree.sil,562:9) [10741]"}
                        (perm[$frac] < Mask[nl, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[nl, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[nl, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[nl, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[nl, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[nl, AVLTreeNodekeys$] := PermSub(Mask[nl, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,562:9) [10742]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nl.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,562:9) [10743]"}
                      nl != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nl.AVLTreeNodebalanceFactor$. (AVLTree.sil,562:9) [10744]"}
                        (perm[$frac] < Mask[nl, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[nl, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[nl, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[nl, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[nl, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[nl, AVLTreeNodebalanceFactor$] := PermSub(Mask[nl, AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(nl)] := PermAdd(Mask[null, AVLTreeNodevalid$(nl)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nl != null;
                    Mask[nl, AVLTreeNodekeys$] := PermAdd(Mask[nl, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nl != null;
                    Mask[nl, AVLTreeNodeheight$] := PermAdd(Mask[nl, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nl != null;
                    Mask[nl, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nl, AVLTreeNodebalanceFactor$], perm);
                    assume Heap[nl, AVLTreeNodeheight$] == 1;
                    assume Seq#Equal(Heap[nl, AVLTreeNodekeys$], Seq#Singleton(k));
                    assume Heap[nl, AVLTreeNodebalanceFactor$] == 0;
                    assume Seq#Contains(Heap[nl, AVLTreeNodekeys$], k);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. The parameter newK$_5 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,562:9) [10745]"}
                    newK$_5[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: fresh newK$_6  -- AVLTree.sil,565:7
                
                // -- Translation of statement fresh newK$_6)
                  havoc newK$_6;
                  assume (newK$_6[$frac] > 0.000000000 && newK$_6[$frac] < 0.001000000) && newK$_6[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_6) -- AVLTree.sil,566:7
                
                // -- Translating statement: nl := AVLTreeNodeinsert$(this$_9.AVLTreeNodeleft$, newK$_6, k) -- AVLTree.sil,567:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_9.AVLTreeNodeleft$
                    assert {:msg "  Method call might fail. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,567:9) [10746]"}
                      this$_9 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,567:9) [10747]"}
                      HasDirectPerm(Mask, this$_9, AVLTreeNodeleft$);
                    assume state(Heap, Mask);
                  arg_this$_9 := Heap[this$_9, AVLTreeNodeleft$];
                  havoc nl;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion this$_9.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,567:9) [10748]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion newK$_6 > none might not hold. (AVLTree.sil,567:9) [10749]"}
                      NoPerm[$frac] < newK$_6[$frac] || (NoPerm[$frac] == newK$_6[$frac] && NoPerm[$eps] < newK$_6[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion write > newK$_6 might not hold. (AVLTree.sil,567:9) [10750]"}
                      newK$_6[$frac] < FullPerm[$frac] || (newK$_6[$frac] == FullPerm[$frac] && newK$_6[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNodeleft$). (AVLTree.sil,567:9) [10751]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,567:9) [10752]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,567:9) [10753]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,567:9) [10754]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,567:9) [10755]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,567:9) [10756]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,567:9) [10757]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,567:9) [10758]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,567:9) [10759]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,567:9) [10760]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    assume nl != null;
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(nl)] := PermAdd(Mask[null, AVLTreeNodevalid$(nl)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nl != null;
                    Mask[nl, AVLTreeNodekeys$] := PermAdd(Mask[nl, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nl != null;
                    Mask[nl, AVLTreeNodeheight$] := PermAdd(Mask[nl, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nl != null;
                    Mask[nl, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nl, AVLTreeNodebalanceFactor$], perm);
                    assume Seq#Contains(Heap[nl, AVLTreeNodekeys$], k);
                    assume (forall i_6: int ::
                      
                      Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], i_6) ==> Seq#Contains(Heap[nl, AVLTreeNodekeys$], i_6)
                    );
                    assume (forall i_7: int ::
                      
                      Seq#Contains(Heap[nl, AVLTreeNodekeys$], i_7) ==> Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], i_7) || i_7 == k
                    );
                    if (Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], k)) {
                      assume Seq#Equal(Heap[nl, AVLTreeNodekeys$], PreCallHeap[arg_this$_9, AVLTreeNodekeys$]);
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], k)) {
                      assume Seq#Length(Heap[nl, AVLTreeNodekeys$]) == Seq#Length(PreCallHeap[arg_this$_9, AVLTreeNodekeys$]) + 1;
                    }
                    assume Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9, AVLTreeNodeheight$] || Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9, AVLTreeNodeheight$] + 1;
                    if (Seq#Contains(PreCallHeap[arg_this$_9, AVLTreeNodekeys$], k)) {
                      assume Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9, AVLTreeNodeheight$];
                    }
                    assume state(Heap, Mask);
                  assume nl == null || Heap[nl, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. The parameter newK$_6 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,567:9) [10761]"}
                    newK$_6[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: this$_9.AVLTreeNodeleft$ := nl -- AVLTree.sil,570:5
            
            // -- Check definedness of this$_9.AVLTreeNodeleft$
              assert {:msg "  Assignment might fail. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,570:5) [10762]"}
                this$_9 != null;
              assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,570:5) [10763]"}
                HasDirectPerm(Mask, this$_9, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            Heap[this$_9, AVLTreeNodeleft$] := nl;
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,570:5) [10764]"}
              FullPerm[$frac] == Mask[this$_9, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_9, AVLTreeNodeleft$][$eps];
            assume state(Heap, Mask);
          
          // -- Translating statement: fresh newK$_7  -- AVLTree.sil,571:5
            
            // -- Translation of statement fresh newK$_7)
              havoc newK$_7;
              assume (newK$_7[$frac] > 0.000000000 && newK$_7[$frac] < 0.001000000) && newK$_7[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_7) -- AVLTree.sil,572:5
            
            // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_9, newK$_7) -- AVLTree.sil,573:7
              PreCallHeap := Heap;
              PreCallMask := Mask;
              havoc bf;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_9 != null might not hold. (AVLTree.sil,573:7) [10765]"}
                  this$_9 != null;
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_7 > none might not hold. (AVLTree.sil,573:7) [10766]"}
                  NoPerm[$frac] < newK$_7[$frac] || (NoPerm[$frac] == newK$_7[$frac] && NoPerm[$eps] < newK$_7[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_7 might not hold. (AVLTree.sil,573:7) [10767]"}
                  newK$_7[$frac] < FullPerm[$frac] || (newK$_7[$frac] == FullPerm[$frac] && newK$_7[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_7 might not be positive. (AVLTree.sil,573:7) [10768]"}
                  newK$_7[$frac] > 0.000000000 || (newK$_7[$frac] == 0.000000000 && newK$_7[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,573:7) [10769]"}
                  this$_9 != null;
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNodeleft$). (AVLTree.sil,573:7) [10770]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                }
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_7 might not be positive. (AVLTree.sil,573:7) [10771]"}
                    newK$_7[$frac] > 0.000000000 || (newK$_7[$frac] == 0.000000000 && newK$_7[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,573:7) [10772]"}
                    Heap[this$_9, AVLTreeNodeleft$] != null;
                }
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_7 might not be positive. (AVLTree.sil,573:7) [10773]"}
                  newK$_7[$frac] > 0.000000000 || (newK$_7[$frac] == 0.000000000 && newK$_7[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,573:7) [10774]"}
                  this$_9 != null;
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNoderight$). (AVLTree.sil,573:7) [10775]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                }
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_7 might not be positive. (AVLTree.sil,573:7) [10776]"}
                    newK$_7[$frac] > 0.000000000 || (newK$_7[$frac] == 0.000000000 && newK$_7[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,573:7) [10777]"}
                    Heap[this$_9, AVLTreeNoderight$] != null;
                }
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                perm := NoPerm;
                perm := PermAdd(perm, newK$_7);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,573:7) [10778]"}
                    Mask[this$_9, AVLTreeNodeleft$][$frac] > 0.000000000;
                  assume perm[$frac] < Mask[this$_9, AVLTreeNodeleft$][$frac];
                }
                Mask[this$_9, AVLTreeNodeleft$] := PermSub(Mask[this$_9, AVLTreeNodeleft$], perm);
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, newK$_7);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,573:7) [10779]"}
                      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                    assume perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
                  }
                  Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                perm := NoPerm;
                perm := PermAdd(perm, newK$_7);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,573:7) [10780]"}
                    Mask[this$_9, AVLTreeNoderight$][$frac] > 0.000000000;
                  assume perm[$frac] < Mask[this$_9, AVLTreeNoderight$][$frac];
                }
                Mask[this$_9, AVLTreeNoderight$] := PermSub(Mask[this$_9, AVLTreeNoderight$], perm);
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, newK$_7);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,573:7) [10781]"}
                      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                    assume perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
                  }
                  Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                perm := newK$_7;
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_9 != null;
                Mask[this$_9, AVLTreeNodeleft$] := PermAdd(Mask[this$_9, AVLTreeNodeleft$], perm);
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := FullPerm;
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                  
                  // -- Extra unfolding of predicate
                    
                }
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := newK$_7;
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume Heap[this$_9, AVLTreeNodeleft$] != null;
                  Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                perm := newK$_7;
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_9 != null;
                Mask[this$_9, AVLTreeNoderight$] := PermAdd(Mask[this$_9, AVLTreeNoderight$], perm);
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := FullPerm;
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                  
                  // -- Extra unfolding of predicate
                    
                }
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := newK$_7;
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume Heap[this$_9, AVLTreeNoderight$] != null;
                  Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                assume bf == (if Heap[this$_9, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_9, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$]);
                if (bf > 0) {
                  assume Heap[this$_9, AVLTreeNodeleft$] != null;
                }
                if (bf < 0) {
                  assume Heap[this$_9, AVLTreeNoderight$] != null;
                }
                assume state(Heap, Mask);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_7 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,573:7) [10782]"}
                newK$_7[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (bf == 2) -- AVLTree.sil,575:5
            if (bf == 2) {
              
              // -- Translating statement: fresh newK$_8  -- AVLTree.sil,576:7
                
                // -- Translation of statement fresh newK$_8)
                  havoc newK$_8;
                  assume (newK$_8[$frac] > 0.000000000 && newK$_8[$frac] < 0.001000000) && newK$_8[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_8) -- AVLTree.sil,577:7
                
                // -- Translating statement: r := AVLTreeNoderebalanceLeft$(this$_9, newK$_8) -- AVLTree.sil,578:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  havoc r_1;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_9 != null might not hold. (AVLTree.sil,578:9) [10783]"}
                      this$_9 != null;
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion newK$_8 > none might not hold. (AVLTree.sil,578:9) [10784]"}
                      NoPerm[$frac] < newK$_8[$frac] || (NoPerm[$frac] == newK$_8[$frac] && NoPerm[$eps] < newK$_8[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion write > newK$_8 might not hold. (AVLTree.sil,578:9) [10785]"}
                      newK$_8[$frac] < FullPerm[$frac] || (newK$_8[$frac] == FullPerm[$frac] && newK$_8[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,578:9) [10786]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodekey$ might be null. (AVLTree.sil,578:9) [10787]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodekey$. (AVLTree.sil,578:9) [10788]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodekey$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodekey$] := PermSub(Mask[this$_9, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,578:9) [10789]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodeheight$ might be null. (AVLTree.sil,578:9) [10790]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeheight$. (AVLTree.sil,578:9) [10791]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodeheight$] := PermSub(Mask[this$_9, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,578:9) [10792]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,578:9) [10793]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,578:9) [10794]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodeleft$] := PermSub(Mask[this$_9, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,578:9) [10795]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,578:9) [10796]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,578:9) [10797]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNoderight$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNoderight$] := PermSub(Mask[this$_9, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,578:9) [10798]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,578:9) [10799]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,578:9) [10800]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodekeys$] := PermSub(Mask[this$_9, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,578:9) [10801]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,578:9) [10802]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodebalanceFactor$. (AVLTree.sil,578:9) [10803]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_9, AVLTreeNodebalanceFactor$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_9.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,578:9) [10804]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNodeleft$). (AVLTree.sil,578:9) [10805]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,578:9) [10806]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,578:9) [10807]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,578:9) [10808]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,578:9) [10809]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,578:9) [10810]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,578:9) [10811]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,578:9) [10812]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,578:9) [10813]"}
                      Heap[this$_9, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,578:9) [10814]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_9.AVLTreeNodekey$)) might not hold. (AVLTree.sil,578:9) [10815]"}
                      (forall k0_1: int ::
                      
                      Seq#Contains(Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[this$_9, AVLTreeNodekey$]
                    );
                    if (Heap[this$_9, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNoderight$). (AVLTree.sil,578:9) [10816]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[this$_9, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,578:9) [10817]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,578:9) [10818]"}
                        Heap[this$_9, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,578:9) [10819]"}
                          (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[this$_9, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,578:9) [10820]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,578:9) [10821]"}
                        Heap[this$_9, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,578:9) [10822]"}
                          (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[this$_9, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,578:9) [10823]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,578:9) [10824]"}
                        Heap[this$_9, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,578:9) [10825]"}
                          (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[this$_9, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_9.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_9.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,578:9) [10826]"}
                        (forall k1_1: int ::
                        
                        Seq#Contains(Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_9, AVLTreeNodekey$] < k1_1
                      );
                    }
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_9.AVLTreeNoderight$ == null ? 0 : this$_9.AVLTreeNoderight$.AVLTreeNodeheight$) == 2 might not hold. (AVLTree.sil,578:9) [10827]"}
                      Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_9, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    assume r_1 != null;
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
                    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(PreCallHeap[PreCallHeap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(PreCallHeap[this$_9, AVLTreeNodekey$])), (if PreCallHeap[this$_9, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$])));
                    assume state(Heap, Mask);
                  assume r_1 == null || Heap[r_1, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. The parameter newK$_8 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,578:9) [10828]"}
                    newK$_8[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: r := this$_9 -- AVLTree.sil,581:7
                r_1 := this$_9;
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_9  -- AVLTree.sil,582:7
                
                // -- Translation of statement fresh newK$_9)
                  havoc newK$_9;
                  assume (newK$_9[$frac] > 0.000000000 && newK$_9[$frac] < 0.001000000) && newK$_9[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_9) -- AVLTree.sil,583:7
                
                // -- Translating statement: AVLTreeNodeclose$(r, newK$_9) -- AVLTree.sil,584:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,584:9) [10829]"}
                      r_1 != null;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_9 > none might not hold. (AVLTree.sil,584:9) [10830]"}
                      NoPerm[$frac] < newK$_9[$frac] || (NoPerm[$frac] == newK$_9[$frac] && NoPerm[$eps] < newK$_9[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_9 might not hold. (AVLTree.sil,584:9) [10831]"}
                      newK$_9[$frac] < FullPerm[$frac] || (newK$_9[$frac] == FullPerm[$frac] && newK$_9[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,584:9) [10832]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,584:9) [10833]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,584:9) [10834]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,584:9) [10835]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,584:9) [10836]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,584:9) [10837]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,584:9) [10838]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,584:9) [10839]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,584:9) [10840]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,584:9) [10841]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,584:9) [10842]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,584:9) [10843]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,584:9) [10844]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,584:9) [10845]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,584:9) [10846]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,584:9) [10847]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,584:9) [10848]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,584:9) [10849]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,584:9) [10850]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,584:9) [10851]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,584:9) [10852]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,584:9) [10853]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,584:9) [10854]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,584:9) [10855]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,584:9) [10856]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,584:9) [10857]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,584:9) [10858]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,584:9) [10859]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,584:9) [10860]"}
                        (forall k0_2: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_2) ==> k0_2 < Heap[r_1, AVLTreeNodekey$]
                      );
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,584:9) [10861]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,584:9) [10862]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,584:9) [10863]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,584:9) [10864]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,584:9) [10865]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,584:9) [10866]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,584:9) [10867]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,584:9) [10868]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,584:9) [10869]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,584:9) [10870]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,584:9) [10871]"}
                        (forall k1_2: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[r_1, AVLTreeNodekey$] < k1_2
                      );
                    }
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,584:9) [10872]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,584:9) [10873]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
                    assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                    assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_9 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,584:9) [10874]"}
                    newK$_9[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: if (this$_9.AVLTreeNoderight$ == null) -- AVLTree.sil,588:5
            
            // -- Check definedness of this$_9.AVLTreeNoderight$ == null
              assert {:msg "  Conditional statement might fail. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,588:9) [10875]"}
                this$_9 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,588:9) [10876]"}
                HasDirectPerm(Mask, this$_9, AVLTreeNoderight$);
              assume state(Heap, Mask);
            if (Heap[this$_9, AVLTreeNoderight$] == null) {
              
              // -- Translating statement: n$_5 := new(old$methodPermission, joinable$, AVLTreeroot$, AVLTreekeys$, AVLTreeNodekey$, AVLTreeNodeheight$, AVLTreeNodeleft$, AVLTreeNoderight$, AVLTreeNodekeys$, AVLTreeNodebalanceFactor$, par$AVLTreeinit$this$_2, par$AVLTreeinit$k$, old$AVLTreeinsert$0, old$AVLTreeinsert$1, par$AVLTreeinsert$this$_3, par$AVLTreeinsert$k$_1, par$AVLTreeinsert$k, old$AVLTreeremove$0, old$AVLTreeremove$1, par$AVLTreeremove$this$_4, par$AVLTreeremove$k$_2, par$AVLTreeremove$k, par$AVLTreehas$this$_5, par$AVLTreehas$k$_3, par$AVLTreehas$k, par$AVLTreeNodeinit$this$_8, par$AVLTreeNodeinit$k$_4, par$AVLTreeNodeinit$k, old$AVLTreeNodeinsert$0, old$AVLTreeNodeinsert$1, old$AVLTreeNodeinsert$2, old$AVLTreeNodeinsert$3, old$AVLTreeNodeinsert$4, old$AVLTreeNodeinsert$5, old$AVLTreeNodeinsert$6, old$AVLTreeNodeinsert$7, old$AVLTreeNodeinsert$8, old$AVLTreeNodeinsert$9, par$AVLTreeNodeinsert$this$_9, par$AVLTreeNodeinsert$k$_5, par$AVLTreeNodeinsert$k, old$AVLTreeNoderemove$0, old$AVLTreeNoderemove$1, old$AVLTreeNoderemove$2, old$AVLTreeNoderemove$3, old$AVLTreeNoderemove$4, old$AVLTreeNoderemove$5, old$AVLTreeNoderemove$6, old$AVLTreeNoderemove$7, old$AVLTreeNoderemove$8, old$AVLTreeNoderemove$9, old$AVLTreeNoderemove$10, old$AVLTreeNoderemove$11, old$AVLTreeNoderemove$12, old$AVLTreeNoderemove$13, par$AVLTreeNoderemove$this$_10, par$AVLTreeNoderemove$k$_6, par$AVLTreeNoderemove$k, old$AVLTreeNodepruneMax$0, old$AVLTreeNodepruneMax$1, old$AVLTreeNodepruneMax$2, old$AVLTreeNodepruneMax$3, old$AVLTreeNodepruneMax$4, old$AVLTreeNodepruneMax$5, old$AVLTreeNodepruneMax$6, old$AVLTreeNodepruneMax$7, par$AVLTreeNodepruneMax$this$_11, par$AVLTreeNodepruneMax$k$_7, old$AVLTreeNodepruneMin$0, old$AVLTreeNodepruneMin$1, old$AVLTreeNodepruneMin$2, old$AVLTreeNodepruneMin$3, old$AVLTreeNodepruneMin$4, old$AVLTreeNodepruneMin$5, old$AVLTreeNodepruneMin$6, old$AVLTreeNodepruneMin$7, par$AVLTreeNodepruneMin$this$_12, par$AVLTreeNodepruneMin$k$_8, par$AVLTreeNodehas$this$_13, par$AVLTreeNodehas$k$_9, par$AVLTreeNodehas$k, par$AVLTreeNodegetBalanceFactor$this$_14, par$AVLTreeNodegetBalanceFactor$k$_10, par$AVLTreeNodegetBalanceFactorI$this$_15, par$AVLTreeNodegetBalanceFactorI$k$_11, old$AVLTreeNodeclose$0, old$AVLTreeNodeclose$1, old$AVLTreeNodeclose$2, old$AVLTreeNodeclose$3, old$AVLTreeNodeclose$4, old$AVLTreeNodeclose$5, old$AVLTreeNodeclose$6, old$AVLTreeNodeclose$7, old$AVLTreeNodeclose$8, old$AVLTreeNodeclose$9, old$AVLTreeNodeclose$10, old$AVLTreeNodeclose$11, old$AVLTreeNodeclose$12, old$AVLTreeNodeclose$13, old$AVLTreeNodeclose$14, old$AVLTreeNodeclose$15, old$AVLTreeNodeclose$16, par$AVLTreeNodeclose$this$_16, par$AVLTreeNodeclose$k$_12, old$AVLTreeNoderebalanceLeft$0, old$AVLTreeNoderebalanceLeft$1, old$AVLTreeNoderebalanceLeft$2, old$AVLTreeNoderebalanceLeft$3, old$AVLTreeNoderebalanceLeft$4, old$AVLTreeNoderebalanceLeft$5, par$AVLTreeNoderebalanceLeft$this$_17, par$AVLTreeNoderebalanceLeft$k$_13, old$AVLTreeNoderebalanceRL$0, old$AVLTreeNoderebalanceRL$1, old$AVLTreeNoderebalanceRL$2, old$AVLTreeNoderebalanceRL$3, old$AVLTreeNoderebalanceRL$4, par$AVLTreeNoderebalanceRL$this$_18, par$AVLTreeNoderebalanceRL$k$_14, old$AVLTreeNoderebalanceRR$0, old$AVLTreeNoderebalanceRR$1, old$AVLTreeNoderebalanceRR$2, old$AVLTreeNoderebalanceRR$3, old$AVLTreeNoderebalanceRR$4, old$AVLTreeNoderebalanceRR$5, par$AVLTreeNoderebalanceRR$this$_19, par$AVLTreeNoderebalanceRR$k$_15, old$AVLTreeNoderebalanceRight$0, old$AVLTreeNoderebalanceRight$1, old$AVLTreeNoderebalanceRight$2, old$AVLTreeNoderebalanceRight$3, old$AVLTreeNoderebalanceRight$4, old$AVLTreeNoderebalanceRight$5, par$AVLTreeNoderebalanceRight$this$_20, par$AVLTreeNoderebalanceRight$k$_16, old$AVLTreeNoderebalanceLR$0, old$AVLTreeNoderebalanceLR$1, old$AVLTreeNoderebalanceLR$2, old$AVLTreeNoderebalanceLR$3, old$AVLTreeNoderebalanceLR$4, par$AVLTreeNoderebalanceLR$this$_21, par$AVLTreeNoderebalanceLR$k$_17, old$AVLTreeNoderebalanceLL$0, old$AVLTreeNoderebalanceLL$1, old$AVLTreeNoderebalanceLL$2, old$AVLTreeNoderebalanceLL$3, old$AVLTreeNoderebalanceLL$4, old$AVLTreeNoderebalanceLL$5, par$AVLTreeNoderebalanceLL$this$_22, par$AVLTreeNoderebalanceLL$k$_18) -- AVLTree.sil,589:7
                havoc freshObj;
                assume freshObj != null && !Heap[freshObj, $allocated];
                Heap[freshObj, $allocated] := true;
                n$_5 := freshObj;
                Mask[n$_5, old$methodPermission] := FullPerm;
                Mask[n$_5, joinable$] := FullPerm;
                Mask[n$_5, AVLTreeroot$] := FullPerm;
                Mask[n$_5, AVLTreekeys$] := FullPerm;
                Mask[n$_5, AVLTreeNodekey$] := FullPerm;
                Mask[n$_5, AVLTreeNodeheight$] := FullPerm;
                Mask[n$_5, AVLTreeNodeleft$] := FullPerm;
                Mask[n$_5, AVLTreeNoderight$] := FullPerm;
                Mask[n$_5, AVLTreeNodekeys$] := FullPerm;
                Mask[n$_5, AVLTreeNodebalanceFactor$] := FullPerm;
                Mask[n$_5, par$AVLTreeinit$this$_2] := FullPerm;
                Mask[n$_5, par$AVLTreeinit$k$] := FullPerm;
                Mask[n$_5, old$AVLTreeinsert$0] := FullPerm;
                Mask[n$_5, old$AVLTreeinsert$1] := FullPerm;
                Mask[n$_5, par$AVLTreeinsert$this$_3] := FullPerm;
                Mask[n$_5, par$AVLTreeinsert$k$_1] := FullPerm;
                Mask[n$_5, par$AVLTreeinsert$k] := FullPerm;
                Mask[n$_5, old$AVLTreeremove$0] := FullPerm;
                Mask[n$_5, old$AVLTreeremove$1] := FullPerm;
                Mask[n$_5, par$AVLTreeremove$this$_4] := FullPerm;
                Mask[n$_5, par$AVLTreeremove$k$_2] := FullPerm;
                Mask[n$_5, par$AVLTreeremove$k] := FullPerm;
                Mask[n$_5, par$AVLTreehas$this$_5] := FullPerm;
                Mask[n$_5, par$AVLTreehas$k$_3] := FullPerm;
                Mask[n$_5, par$AVLTreehas$k] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinit$this$_8] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinit$k$_4] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinit$k] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$7] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$8] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeinsert$9] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinsert$this$_9] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinsert$k$_5] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeinsert$k] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$7] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$8] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$9] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$10] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$11] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$12] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderemove$13] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderemove$this$_10] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderemove$k$_6] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderemove$k] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMax$7] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMax$this$_11] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMax$k$_7] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodepruneMin$7] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMin$this$_12] := FullPerm;
                Mask[n$_5, par$AVLTreeNodepruneMin$k$_8] := FullPerm;
                Mask[n$_5, par$AVLTreeNodehas$this$_13] := FullPerm;
                Mask[n$_5, par$AVLTreeNodehas$k$_9] := FullPerm;
                Mask[n$_5, par$AVLTreeNodehas$k] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactor$this$_14] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactor$k$_10] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactorI$this$_15] := FullPerm;
                Mask[n$_5, par$AVLTreeNodegetBalanceFactorI$k$_11] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$5] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$6] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$7] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$8] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$9] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$10] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$11] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$12] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$13] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$14] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$15] := FullPerm;
                Mask[n$_5, old$AVLTreeNodeclose$16] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeclose$this$_16] := FullPerm;
                Mask[n$_5, par$AVLTreeNodeclose$k$_12] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLeft$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLeft$this$_17] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLeft$k$_13] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRL$4] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRL$this$_18] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRL$k$_14] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRR$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRR$this$_19] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRR$k$_15] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceRight$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRight$this$_20] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceRight$k$_16] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLR$4] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLR$this$_21] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLR$k$_17] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$0] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$1] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$2] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$3] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$4] := FullPerm;
                Mask[n$_5, old$AVLTreeNoderebalanceLL$5] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLL$this$_22] := FullPerm;
                Mask[n$_5, par$AVLTreeNoderebalanceLL$k$_18] := FullPerm;
                assume state(Heap, Mask);
              
              // -- Translating statement: nr := n$_5 -- AVLTree.sil,590:7
                nr := n$_5;
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_10  -- AVLTree.sil,591:7
                
                // -- Translation of statement fresh newK$_10)
                  havoc newK$_10;
                  assume (newK$_10[$frac] > 0.000000000 && newK$_10[$frac] < 0.001000000) && newK$_10[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_10) -- AVLTree.sil,592:7
                
                // -- Translating statement: AVLTreeNodeinit$(nr, newK$_10, k) -- AVLTree.sil,593:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion nr != null might not hold. (AVLTree.sil,593:9) [10877]"}
                      nr != null;
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion newK$_10 > none might not hold. (AVLTree.sil,593:9) [10878]"}
                      NoPerm[$frac] < newK$_10[$frac] || (NoPerm[$frac] == newK$_10[$frac] && NoPerm[$eps] < newK$_10[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Assertion write > newK$_10 might not hold. (AVLTree.sil,593:9) [10879]"}
                      newK$_10[$frac] < FullPerm[$frac] || (newK$_10[$frac] == FullPerm[$frac] && newK$_10[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,593:9) [10880]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nr.AVLTreeNodekey$ might be null. (AVLTree.sil,593:9) [10881]"}
                      nr != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nr.AVLTreeNodekey$. (AVLTree.sil,593:9) [10882]"}
                        (perm[$frac] < Mask[nr, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[nr, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[nr, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[nr, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[nr, AVLTreeNodekey$][$eps]);
                    }
                    Mask[nr, AVLTreeNodekey$] := PermSub(Mask[nr, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,593:9) [10883]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nr.AVLTreeNodeheight$ might be null. (AVLTree.sil,593:9) [10884]"}
                      nr != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nr.AVLTreeNodeheight$. (AVLTree.sil,593:9) [10885]"}
                        (perm[$frac] < Mask[nr, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[nr, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[nr, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[nr, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[nr, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[nr, AVLTreeNodeheight$] := PermSub(Mask[nr, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,593:9) [10886]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nr.AVLTreeNodeleft$ might be null. (AVLTree.sil,593:9) [10887]"}
                      nr != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nr.AVLTreeNodeleft$. (AVLTree.sil,593:9) [10888]"}
                        (perm[$frac] < Mask[nr, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[nr, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[nr, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[nr, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[nr, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[nr, AVLTreeNodeleft$] := PermSub(Mask[nr, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,593:9) [10889]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nr.AVLTreeNoderight$ might be null. (AVLTree.sil,593:9) [10890]"}
                      nr != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nr.AVLTreeNoderight$. (AVLTree.sil,593:9) [10891]"}
                        (perm[$frac] < Mask[nr, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[nr, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[nr, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[nr, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[nr, AVLTreeNoderight$][$eps]);
                    }
                    Mask[nr, AVLTreeNoderight$] := PermSub(Mask[nr, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,593:9) [10892]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nr.AVLTreeNodekeys$ might be null. (AVLTree.sil,593:9) [10893]"}
                      nr != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nr.AVLTreeNodekeys$. (AVLTree.sil,593:9) [10894]"}
                        (perm[$frac] < Mask[nr, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[nr, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[nr, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[nr, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[nr, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[nr, AVLTreeNodekeys$] := PermSub(Mask[nr, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,593:9) [10895]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. Receiver of nr.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,593:9) [10896]"}
                      nr != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. There might be insufficient permission to access nr.AVLTreeNodebalanceFactor$. (AVLTree.sil,593:9) [10897]"}
                        (perm[$frac] < Mask[nr, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[nr, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[nr, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[nr, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[nr, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[nr, AVLTreeNodebalanceFactor$] := PermSub(Mask[nr, AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(nr)] := PermAdd(Mask[null, AVLTreeNodevalid$(nr)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nr != null;
                    Mask[nr, AVLTreeNodekeys$] := PermAdd(Mask[nr, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nr != null;
                    Mask[nr, AVLTreeNodeheight$] := PermAdd(Mask[nr, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nr != null;
                    Mask[nr, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nr, AVLTreeNodebalanceFactor$], perm);
                    assume Heap[nr, AVLTreeNodeheight$] == 1;
                    assume Seq#Equal(Heap[nr, AVLTreeNodekeys$], Seq#Singleton(k));
                    assume Heap[nr, AVLTreeNodebalanceFactor$] == 0;
                    assume Seq#Contains(Heap[nr, AVLTreeNodekeys$], k);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodeinit$ might not hold. The parameter newK$_10 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,593:9) [10898]"}
                    newK$_10[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: fresh newK$_11  -- AVLTree.sil,596:7
                
                // -- Translation of statement fresh newK$_11)
                  havoc newK$_11;
                  assume (newK$_11[$frac] > 0.000000000 && newK$_11[$frac] < 0.001000000) && newK$_11[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_11) -- AVLTree.sil,597:7
                
                // -- Translating statement: nr := AVLTreeNodeinsert$(this$_9.AVLTreeNoderight$, newK$_11, k) -- AVLTree.sil,598:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_9.AVLTreeNoderight$
                    assert {:msg "  Method call might fail. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,598:9) [10899]"}
                      this$_9 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,598:9) [10900]"}
                      HasDirectPerm(Mask, this$_9, AVLTreeNoderight$);
                    assume state(Heap, Mask);
                  arg_this$_9_1 := Heap[this$_9, AVLTreeNoderight$];
                  havoc nr;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion this$_9.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,598:9) [10901]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion newK$_11 > none might not hold. (AVLTree.sil,598:9) [10902]"}
                      NoPerm[$frac] < newK$_11[$frac] || (NoPerm[$frac] == newK$_11[$frac] && NoPerm[$eps] < newK$_11[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Assertion write > newK$_11 might not hold. (AVLTree.sil,598:9) [10903]"}
                      newK$_11[$frac] < FullPerm[$frac] || (newK$_11[$frac] == FullPerm[$frac] && newK$_11[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNoderight$). (AVLTree.sil,598:9) [10904]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,598:9) [10905]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,598:9) [10906]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,598:9) [10907]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,598:9) [10908]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,598:9) [10909]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,598:9) [10910]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,598:9) [10911]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,598:9) [10912]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,598:9) [10913]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    assume nr != null;
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(nr)] := PermAdd(Mask[null, AVLTreeNodevalid$(nr)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nr != null;
                    Mask[nr, AVLTreeNodekeys$] := PermAdd(Mask[nr, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nr != null;
                    Mask[nr, AVLTreeNodeheight$] := PermAdd(Mask[nr, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume nr != null;
                    Mask[nr, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nr, AVLTreeNodebalanceFactor$], perm);
                    assume Seq#Contains(Heap[nr, AVLTreeNodekeys$], k);
                    assume (forall i_8: int ::
                      
                      Seq#Contains(PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$], i_8) ==> Seq#Contains(Heap[nr, AVLTreeNodekeys$], i_8)
                    );
                    assume (forall i_9: int ::
                      
                      Seq#Contains(Heap[nr, AVLTreeNodekeys$], i_9) ==> Seq#Contains(PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$], i_9) || i_9 == k
                    );
                    if (Seq#Contains(PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$], k)) {
                      assume Seq#Equal(Heap[nr, AVLTreeNodekeys$], PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$]);
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$], k)) {
                      assume Seq#Length(Heap[nr, AVLTreeNodekeys$]) == Seq#Length(PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$]) + 1;
                    }
                    assume Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9_1, AVLTreeNodeheight$] || Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9_1, AVLTreeNodeheight$] + 1;
                    if (Seq#Contains(PreCallHeap[arg_this$_9_1, AVLTreeNodekeys$], k)) {
                      assume Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_9_1, AVLTreeNodeheight$];
                    }
                    assume state(Heap, Mask);
                  assume nr == null || Heap[nr, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNodeinsert$ might not hold. The parameter newK$_11 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,598:9) [10914]"}
                    newK$_11[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: this$_9.AVLTreeNoderight$ := nr -- AVLTree.sil,601:5
            
            // -- Check definedness of this$_9.AVLTreeNoderight$
              assert {:msg "  Assignment might fail. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,601:5) [10915]"}
                this$_9 != null;
              assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,601:5) [10916]"}
                HasDirectPerm(Mask, this$_9, AVLTreeNoderight$);
              assume state(Heap, Mask);
            Heap[this$_9, AVLTreeNoderight$] := nr;
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,601:5) [10917]"}
              FullPerm[$frac] == Mask[this$_9, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_9, AVLTreeNoderight$][$eps];
            assume state(Heap, Mask);
          
          // -- Translating statement: fresh newK$_12  -- AVLTree.sil,602:5
            
            // -- Translation of statement fresh newK$_12)
              havoc newK$_12;
              assume (newK$_12[$frac] > 0.000000000 && newK$_12[$frac] < 0.001000000) && newK$_12[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_12) -- AVLTree.sil,603:5
            
            // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_9, newK$_12) -- AVLTree.sil,604:7
              PreCallHeap := Heap;
              PreCallMask := Mask;
              havoc bf;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_9 != null might not hold. (AVLTree.sil,604:7) [10918]"}
                  this$_9 != null;
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_12 > none might not hold. (AVLTree.sil,604:7) [10919]"}
                  NoPerm[$frac] < newK$_12[$frac] || (NoPerm[$frac] == newK$_12[$frac] && NoPerm[$eps] < newK$_12[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_12 might not hold. (AVLTree.sil,604:7) [10920]"}
                  newK$_12[$frac] < FullPerm[$frac] || (newK$_12[$frac] == FullPerm[$frac] && newK$_12[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_12 might not be positive. (AVLTree.sil,604:7) [10921]"}
                  newK$_12[$frac] > 0.000000000 || (newK$_12[$frac] == 0.000000000 && newK$_12[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,604:7) [10922]"}
                  this$_9 != null;
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNodeleft$). (AVLTree.sil,604:7) [10923]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                }
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_12 might not be positive. (AVLTree.sil,604:7) [10924]"}
                    newK$_12[$frac] > 0.000000000 || (newK$_12[$frac] == 0.000000000 && newK$_12[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,604:7) [10925]"}
                    Heap[this$_9, AVLTreeNodeleft$] != null;
                }
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_12 might not be positive. (AVLTree.sil,604:7) [10926]"}
                  newK$_12[$frac] > 0.000000000 || (newK$_12[$frac] == 0.000000000 && newK$_12[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,604:7) [10927]"}
                  this$_9 != null;
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNoderight$). (AVLTree.sil,604:7) [10928]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                }
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_12 might not be positive. (AVLTree.sil,604:7) [10929]"}
                    newK$_12[$frac] > 0.000000000 || (newK$_12[$frac] == 0.000000000 && newK$_12[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,604:7) [10930]"}
                    Heap[this$_9, AVLTreeNoderight$] != null;
                }
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                perm := NoPerm;
                perm := PermAdd(perm, newK$_12);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,604:7) [10931]"}
                    Mask[this$_9, AVLTreeNodeleft$][$frac] > 0.000000000;
                  assume perm[$frac] < Mask[this$_9, AVLTreeNodeleft$][$frac];
                }
                Mask[this$_9, AVLTreeNodeleft$] := PermSub(Mask[this$_9, AVLTreeNodeleft$], perm);
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, newK$_12);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,604:7) [10932]"}
                      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                    assume perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
                  }
                  Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                perm := NoPerm;
                perm := PermAdd(perm, newK$_12);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,604:7) [10933]"}
                    Mask[this$_9, AVLTreeNoderight$][$frac] > 0.000000000;
                  assume perm[$frac] < Mask[this$_9, AVLTreeNoderight$][$frac];
                }
                Mask[this$_9, AVLTreeNoderight$] := PermSub(Mask[this$_9, AVLTreeNoderight$], perm);
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, newK$_12);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,604:7) [10934]"}
                      Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                    assume perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
                  }
                  Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                perm := newK$_12;
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_9 != null;
                Mask[this$_9, AVLTreeNodeleft$] := PermAdd(Mask[this$_9, AVLTreeNodeleft$], perm);
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := FullPerm;
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                  
                  // -- Extra unfolding of predicate
                    
                }
                if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                  perm := newK$_12;
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume Heap[this$_9, AVLTreeNodeleft$] != null;
                  Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                perm := newK$_12;
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_9 != null;
                Mask[this$_9, AVLTreeNoderight$] := PermAdd(Mask[this$_9, AVLTreeNoderight$], perm);
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := FullPerm;
                  Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                  
                  // -- Extra unfolding of predicate
                    
                }
                if (Heap[this$_9, AVLTreeNoderight$] != null) {
                  perm := newK$_12;
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume Heap[this$_9, AVLTreeNoderight$] != null;
                  Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                assume bf == (if Heap[this$_9, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_9, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$]);
                if (bf > 0) {
                  assume Heap[this$_9, AVLTreeNodeleft$] != null;
                }
                if (bf < 0) {
                  assume Heap[this$_9, AVLTreeNoderight$] != null;
                }
                assume state(Heap, Mask);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_12 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,604:7) [10935]"}
                newK$_12[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (bf == 0 - 2) -- AVLTree.sil,606:5
            if (bf == -2) {
              
              // -- Translating statement: fresh newK$_13  -- AVLTree.sil,607:7
                
                // -- Translation of statement fresh newK$_13)
                  havoc newK$_13;
                  assume (newK$_13[$frac] > 0.000000000 && newK$_13[$frac] < 0.001000000) && newK$_13[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_13) -- AVLTree.sil,608:7
                
                // -- Translating statement: r := AVLTreeNoderebalanceRight$(this$_9, newK$_13) -- AVLTree.sil,609:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  havoc r_1;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion this$_9 != null might not hold. (AVLTree.sil,609:9) [10936]"}
                      this$_9 != null;
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion newK$_13 > none might not hold. (AVLTree.sil,609:9) [10937]"}
                      NoPerm[$frac] < newK$_13[$frac] || (NoPerm[$frac] == newK$_13[$frac] && NoPerm[$eps] < newK$_13[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion write > newK$_13 might not hold. (AVLTree.sil,609:9) [10938]"}
                      newK$_13[$frac] < FullPerm[$frac] || (newK$_13[$frac] == FullPerm[$frac] && newK$_13[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,609:9) [10939]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodekey$ might be null. (AVLTree.sil,609:9) [10940]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodekey$. (AVLTree.sil,609:9) [10941]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodekey$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodekey$] := PermSub(Mask[this$_9, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,609:9) [10942]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodeheight$ might be null. (AVLTree.sil,609:9) [10943]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeheight$. (AVLTree.sil,609:9) [10944]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodeheight$] := PermSub(Mask[this$_9, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,609:9) [10945]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodeleft$ might be null. (AVLTree.sil,609:9) [10946]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$. (AVLTree.sil,609:9) [10947]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodeleft$] := PermSub(Mask[this$_9, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,609:9) [10948]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNoderight$ might be null. (AVLTree.sil,609:9) [10949]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$. (AVLTree.sil,609:9) [10950]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNoderight$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNoderight$] := PermSub(Mask[this$_9, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,609:9) [10951]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodekeys$ might be null. (AVLTree.sil,609:9) [10952]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodekeys$. (AVLTree.sil,609:9) [10953]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodekeys$] := PermSub(Mask[this$_9, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,609:9) [10954]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,609:9) [10955]"}
                      this$_9 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodebalanceFactor$. (AVLTree.sil,609:9) [10956]"}
                        (perm[$frac] < Mask[this$_9, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_9, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_9, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_9, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_9, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[this$_9, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_9, AVLTreeNodebalanceFactor$], perm);
                    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNodeleft$). (AVLTree.sil,609:9) [10957]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,609:9) [10958]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,609:9) [10959]"}
                        Heap[this$_9, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,609:9) [10960]"}
                          (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,609:9) [10961]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,609:9) [10962]"}
                        Heap[this$_9, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,609:9) [10963]"}
                          (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,609:9) [10964]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,609:9) [10965]"}
                        Heap[this$_9, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,609:9) [10966]"}
                          (perm[$frac] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[this$_9, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (forall k: Int :: true && k in this$_9.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_9.AVLTreeNodekey$)) might not hold. (AVLTree.sil,609:9) [10967]"}
                        (forall k_1_1: int ::
                        
                        Seq#Contains(Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$], k_1_1) ==> k_1_1 < Heap[this$_9, AVLTreeNodekey$]
                      );
                    }
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion this$_9.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,609:9) [10968]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_9.AVLTreeNoderight$). (AVLTree.sil,609:9) [10969]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_9, AVLTreeNoderight$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,609:9) [10970]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,609:9) [10971]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,609:9) [10972]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,609:9) [10973]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,609:9) [10974]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,609:9) [10975]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,609:9) [10976]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_9.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,609:9) [10977]"}
                      Heap[this$_9, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_9.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,609:9) [10978]"}
                        (perm[$frac] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_9.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_9.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,609:9) [10979]"}
                      (forall k1_3: int ::
                      
                      Seq#Contains(Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_9, AVLTreeNodekey$] < k1_3
                    );
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (this$_9.AVLTreeNodeleft$ == null ? 0 : this$_9.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_9.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2 might not hold. (AVLTree.sil,609:9) [10980]"}
                      (if Heap[this$_9, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_9, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    assume r_1 != null;
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_9, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
                    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_9, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_9, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_9, AVLTreeNodekey$])), PreCallHeap[PreCallHeap[this$_9, AVLTreeNoderight$], AVLTreeNodekeys$]));
                    assume state(Heap, Mask);
                  assume r_1 == null || Heap[r_1, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. The parameter newK$_13 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,609:9) [10981]"}
                    newK$_13[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: r := this$_9 -- AVLTree.sil,612:7
                r_1 := this$_9;
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_14  -- AVLTree.sil,613:7
                
                // -- Translation of statement fresh newK$_14)
                  havoc newK$_14;
                  assume (newK$_14[$frac] > 0.000000000 && newK$_14[$frac] < 0.001000000) && newK$_14[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_14) -- AVLTree.sil,614:7
                
                // -- Translating statement: AVLTreeNodeclose$(r, newK$_14) -- AVLTree.sil,615:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,615:9) [10982]"}
                      r_1 != null;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_14 > none might not hold. (AVLTree.sil,615:9) [10983]"}
                      NoPerm[$frac] < newK$_14[$frac] || (NoPerm[$frac] == newK$_14[$frac] && NoPerm[$eps] < newK$_14[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_14 might not hold. (AVLTree.sil,615:9) [10984]"}
                      newK$_14[$frac] < FullPerm[$frac] || (newK$_14[$frac] == FullPerm[$frac] && newK$_14[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,615:9) [10985]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,615:9) [10986]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,615:9) [10987]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,615:9) [10988]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,615:9) [10989]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,615:9) [10990]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,615:9) [10991]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,615:9) [10992]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,615:9) [10993]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,615:9) [10994]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,615:9) [10995]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,615:9) [10996]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,615:9) [10997]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,615:9) [10998]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,615:9) [10999]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,615:9) [11000]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,615:9) [11001]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,615:9) [11002]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,615:9) [11003]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,615:9) [11004]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,615:9) [11005]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,615:9) [11006]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,615:9) [11007]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,615:9) [11008]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,615:9) [11009]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,615:9) [11010]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,615:9) [11011]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,615:9) [11012]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,615:9) [11013]"}
                        (forall k0_3: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_3) ==> k0_3 < Heap[r_1, AVLTreeNodekey$]
                      );
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,615:9) [11014]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,615:9) [11015]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,615:9) [11016]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,615:9) [11017]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,615:9) [11018]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,615:9) [11019]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,615:9) [11020]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,615:9) [11021]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,615:9) [11022]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,615:9) [11023]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,615:9) [11024]"}
                        (forall k1_4: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_4) ==> Heap[r_1, AVLTreeNodekey$] < k1_4
                      );
                    }
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,615:9) [11025]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,615:9) [11026]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
                    assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                    assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_14 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,615:9) [11027]"}
                    newK$_14[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion r != null might not hold. (AVLTree.sil,517:11) [11028]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,518:11) [11029]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,519:11) [11030]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,519:11) [11031]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,519:11) [11032]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,520:11) [11033]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,520:11) [11034]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,520:11) [11035]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,521:11) [11036]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,521:11) [11037]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,521:11) [11038]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion k in r.AVLTreeNodekeys$ might not hold. (AVLTree.sil,522:11) [11039]"}
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k);
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion (forall i: Int :: true && i in old(this$_9.AVLTreeNodekeys$) ==> i in r.AVLTreeNodekeys$) might not hold. (AVLTree.sil,523:12) [11040]"}
      (forall i_4: int ::
      
      Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], i_4) ==> Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_4)
    );
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion (forall i: Int :: true && i in r.AVLTreeNodekeys$ ==> i in old(this$_9.AVLTreeNodekeys$) || (i == k)) might not hold. (AVLTree.sil,524:12) [11041]"}
      (forall i_5: int ::
      
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_5) ==> Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], i_5) || i_5 == k
    );
    if (Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], k)) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion r.AVLTreeNodekeys$ == old(this$_9.AVLTreeNodekeys$) might not hold. (AVLTree.sil,525:11) [11042]"}
        Seq#Equal(Heap[r_1, AVLTreeNodekeys$], old(Heap)[this$_9, AVLTreeNodekeys$]);
    }
    if (!Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], k)) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion |r.AVLTreeNodekeys$| == |old(this$_9.AVLTreeNodekeys$)| + 1 might not hold. (AVLTree.sil,526:11) [11043]"}
        Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == Seq#Length(old(Heap)[this$_9, AVLTreeNodekeys$]) + 1;
    }
    assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,527:11) [11044]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$] + 1;
    if (Seq#Contains(old(Heap)[this$_9, AVLTreeNodekeys$], k)) {
      assert {:msg "  Postcondition of AVLTreeNodeinsert$ might not hold. Assertion r.AVLTreeNodeheight$ == old(this$_9.AVLTreeNodeheight$) might not hold. (AVLTree.sil,528:11) [11045]"}
        Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_9, AVLTreeNodeheight$];
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderemove$
// ==================================================

procedure AVLTreeNoderemove$(this$_10: Ref, k$_6: Perm, k: int) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var i_10: int;
  var i_11: int;
  var oldVersion: int;
  var newVersion: int;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  var nl: Ref;
  var nr: Ref;
  var newK$_39: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var bf: int;
  var ExhaleHeap: HeapType;
  var newK$_40: Perm;
  var arg_this$_11: Ref;
  var newK$_41: Perm;
  var arg_this$_12: Ref;
  var newK$_42: Perm;
  var newK$_43: Perm;
  var arg_this$_10: Ref;
  var newK$_44: Perm;
  var newK$_45: Perm;
  var newK$_46: Perm;
  var newK$_47: Perm;
  var newK$_48: Perm;
  var arg_this$_10_1: Ref;
  var newK$_49: Perm;
  var newK$_50: Perm;
  var newK$_51: Perm;
  var newK$_52: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_10 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_6[$frac] || (NoPerm[$frac] == k$_6[$frac] && NoPerm[$eps] < k$_6[$eps]);
    assume state(Heap, Mask);
    assume k$_6[$frac] < FullPerm[$frac] || (k$_6[$frac] == FullPerm[$frac] && k$_6[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_10)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_10)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodekeys$] := PermAdd(Mask[this$_10, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodeheight$] := PermAdd(Mask[this$_10, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_10, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    
    // -- Check definedness of old(this$_10.AVLTreeNodekeys$) == Seq(k)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,629:11) [11046]"}
        this$_10 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,629:11) [11047]"}
        HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (Seq#Equal(old(Heap)[this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
      assume r_1 == null;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of old(this$_10.AVLTreeNodekeys$) != Seq(k)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,630:11) [11048]"}
        this$_10 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,630:11) [11049]"}
        HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (!Seq#Equal(old(Heap)[this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
      assume r_1 != null;
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of !k in r.AVLTreeNodekeys$
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,635:11) [11050]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,635:11) [11051]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      assume !Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of (forall i: Int :: true && i in old(this$_10.AVLTreeNodekeys$) ==> i in r.AVLTreeNodekeys$ || (i == k))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,636:11) [11052]"}
          this$_10 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,636:11) [11053]"}
          HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
        if (Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], i_10)) {
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,636:11) [11054]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,636:11) [11055]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        }
        assume state(Heap, Mask);
      assume (forall i_1: int ::
        
        Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], i_1) ==> Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_1) || i_1 == k
      );
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of (forall i: Int :: true && i in r.AVLTreeNodekeys$ ==> i in old(this$_10.AVLTreeNodekeys$) && (i != k))
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,637:11) [11056]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,637:11) [11057]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_11)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,637:11) [11058]"}
            this$_10 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,637:11) [11059]"}
            HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
        }
        assume state(Heap, Mask);
      assume (forall i_3_1: int ::
        
        Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_3_1) ==> Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], i_3_1) && i_3_1 != k
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of !k in old(this$_10.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,638:11) [11060]"}
        this$_10 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,638:11) [11061]"}
        HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (!Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
      assume r_1 != null;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of !k in old(this$_10.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,639:11) [11062]"}
        this$_10 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,639:11) [11063]"}
        HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (!Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
      
      // -- Check definedness of r.AVLTreeNodekeys$ == old(this$_10.AVLTreeNodekeys$)
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,639:11) [11064]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,639:11) [11065]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,639:11) [11066]"}
          this$_10 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,639:11) [11067]"}
          HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], old(Heap)[this$_10, AVLTreeNodekeys$]);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of k in old(this$_10.AVLTreeNodekeys$)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,640:11) [11068]"}
          this$_10 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,640:11) [11069]"}
          HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      if (Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
        
        // -- Check definedness of |r.AVLTreeNodekeys$| == |old(this$_10.AVLTreeNodekeys$)| - 1
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,640:11) [11070]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,640:11) [11071]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
          assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,640:11) [11072]"}
            this$_10 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,640:11) [11073]"}
            HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
          assume state(Heap, Mask);
        assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == Seq#Length(old(Heap)[this$_10, AVLTreeNodekeys$]) - 1;
        assume state(Heap, Mask);
      }
    }
    
    // -- Check definedness of old(this$_10.AVLTreeNodeheight$) > 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,641:11) [11074]"}
        this$_10 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,641:11) [11075]"}
        HasDirectPerm(old(Mask), this$_10, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    if (old(Heap)[this$_10, AVLTreeNodeheight$] > 1) {
      assume r_1 != null;
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_10.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ + 1 == old(this$_10.AVLTreeNodeheight$))
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,642:11) [11076]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,642:11) [11077]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,642:11) [11078]"}
          this$_10 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,642:11) [11079]"}
          HasDirectPerm(old(Mask), this$_10, AVLTreeNodeheight$);
        if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_10, AVLTreeNodeheight$])) {
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,642:11) [11080]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,642:11) [11081]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
          assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,642:11) [11082]"}
            this$_10 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,642:11) [11083]"}
            HasDirectPerm(old(Mask), this$_10, AVLTreeNodeheight$);
        }
        assume state(Heap, Mask);
      assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_10, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] + 1 == old(Heap)[this$_10, AVLTreeNodeheight$];
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of !k in old(this$_10.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,643:11) [11084]"}
        this$_10 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,643:11) [11085]"}
        HasDirectPerm(old(Mask), this$_10, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    if (!Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
      
      // -- Check definedness of r.AVLTreeNodeheight$ == old(this$_10.AVLTreeNodeheight$)
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,643:11) [11086]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,643:11) [11087]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,643:11) [11088]"}
          this$_10 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,643:11) [11089]"}
          HasDirectPerm(old(Mask), this$_10, AVLTreeNodeheight$);
        assume state(Heap, Mask);
      assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_10, AVLTreeNodeheight$];
      assume state(Heap, Mask);
    }
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_10 == null || Heap[this$_10, $allocated];
    assume k$_6[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_10), write) -- AVLTree.sil,666:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_10));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_10) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_10). (AVLTree.sil,666:3) [11092]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_10)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_10)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_10)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_10)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_10)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_10)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_10)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(this$_10))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(this$_10)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(this$_10)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodekey$] := PermAdd(Mask[this$_10, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodeheight$] := PermAdd(Mask[this$_10, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodeleft$] := PermAdd(Mask[this$_10, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNoderight$] := PermAdd(Mask[this$_10, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodekeys$] := PermAdd(Mask[this$_10, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_10 != null;
    Mask[this$_10, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_10, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_10, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_10)], Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_10, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_10, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_10, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[this$_10, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_10, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_10, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_10)], Heap[this$_10, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])]);
    }
    if (Heap[this$_10, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_10, AVLTreeNoderight$] != null;
      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_10, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_10, AVLTreeNoderight$] != null;
      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_10, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_10, AVLTreeNoderight$] != null;
      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_10, AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[this$_10, AVLTreeNodekey$] < rk
      );
    }
    if (Heap[this$_10, AVLTreeNoderight$] != null) {
      assume Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[this$_10, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_10, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_10, AVLTreeNodekey$])), (if Heap[this$_10, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[this$_10, AVLTreeNodekeys$], Heap[this$_10, AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[this$_10, AVLTreeNodekeys$], kk) == ((Heap[this$_10, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[this$_10, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[this$_10, AVLTreeNodekey$]))
    );
    assume Heap[this$_10, AVLTreeNodeheight$] == (if (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[this$_10, AVLTreeNodebalanceFactor$] == (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[this$_10, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[this$_10, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[this$_10, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_10.AVLTreeNodekey$ == k) -- AVLTree.sil,667:3
    
    // -- Check definedness of this$_10.AVLTreeNodekey$ == k
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNodekey$. (AVLTree.sil,667:7) [11093]"}
        HasDirectPerm(Mask, this$_10, AVLTreeNodekey$);
      assume state(Heap, Mask);
    if (Heap[this$_10, AVLTreeNodekey$] == k) {
      
      // -- Translating statement: if ((this$_10.AVLTreeNodeleft$ == null) || (this$_10.AVLTreeNoderight$ == null)) -- AVLTree.sil,668:5
        
        // -- Check definedness of (this$_10.AVLTreeNodeleft$ == null) || (this$_10.AVLTreeNoderight$ == null)
          assert {:msg "  Conditional statement might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,668:9) [11094]"}
            this$_10 != null;
          assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,668:9) [11095]"}
            HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
          if (!(Heap[this$_10, AVLTreeNodeleft$] == null)) {
            assert {:msg "  Conditional statement might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,668:9) [11096]"}
              this$_10 != null;
            assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,668:9) [11097]"}
              HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
          }
          assume state(Heap, Mask);
        if (Heap[this$_10, AVLTreeNodeleft$] == null || Heap[this$_10, AVLTreeNoderight$] == null) {
          
          // -- Translating statement: assert (this$_10.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNoderight$), write) in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ != Seq()) -- AVLTree.sil,669:7
            
            // -- Check definedness of (this$_10.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNoderight$), write) in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ != Seq())
              assert {:msg "  Assert might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,669:7) [11098]"}
                this$_10 != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,669:7) [11099]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
              if (Heap[this$_10, AVLTreeNoderight$] != null) {
                UnfoldingHeap := Heap;
                UnfoldingMask := Mask;
                assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$]));
                // Phase 1: pure assertions and fixed permissions
                perm := NoPerm;
                perm := PermAdd(perm, FullPerm);
                if (perm != NoPerm) {
                  assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,669:7) [11100]"}
                    (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])][$eps]);
                }
                UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])], perm);
                
                // -- Update version of predicate
                  if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$]))) {
                    oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])];
                    havoc newVersion;
                    assume oldVersion < newVersion;
                    UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])] := newVersion;
                  }
                perm := Perm(1.000000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                perm := Perm(1.000000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
                perm := Perm(1.000000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  perm := FullPerm;
                  UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$])]);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  assume (forall lk_1: int ::
                    
                    Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$]
                  );
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  perm := FullPerm;
                  UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$])]);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  assume (forall rk_1: int ::
                    
                    Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$] < rk_1
                  );
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
                }
                assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
                assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$]);
                assume (forall kk_1: int ::
                  
                  Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1) == ((UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$]))
                );
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
                assume state(UnfoldingHeap, UnfoldingMask);
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,669:7) [11101]"}
                  HasDirectPerm(UnfoldingMask, this$_10, AVLTreeNoderight$);
                assert {:msg "  Assert might fail. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,669:7) [11102]"}
                  UnfoldingHeap[this$_10, AVLTreeNoderight$] != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,669:7) [11103]"}
                  HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$);
                assert {:msg "  Assert might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,669:7) [11104]"}
                  this$_10 != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,669:7) [11105]"}
                  HasDirectPerm(UnfoldingMask, this$_10, AVLTreeNoderight$);
                
                // -- Free assumptions
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                    havoc newPMask;
                    assume (forall <A, B> o_6: Ref, f_9: (Field A B) ::
                      { newPMask[o_6, f_9] }
                      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][o_6, f_9] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$])][o_6, f_9] ==> newPMask[o_6, f_9]
                    );
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])] := newPMask;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                    havoc newPMask;
                    assume (forall <A, B> o_7: Ref, f_10: (Field A B) ::
                      { newPMask[o_7, f_10] }
                      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][o_7, f_10] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$])][o_7, f_10] ==> newPMask[o_7, f_10]
                    );
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])] := newPMask;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
                  }
              }
              assume state(Heap, Mask);
            // Phase 1: pure assertions and fixed permissions
            if (Heap[this$_10, AVLTreeNoderight$] != null) {
              assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNoderight$), write) in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ != Seq()) might not hold. (AVLTree.sil,669:7) [11106]"}
                !Seq#Equal(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], (Seq#Empty(): Seq_ int));
            }
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            
            // -- Free assumptions
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekey$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_8: Ref, f_11: (Field A B) ::
                  { newPMask[o_8, f_11] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][o_8, f_11] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$])][o_8, f_11] ==> newPMask[o_8, f_11]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])] := newPMask;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_9: Ref, f_12: (Field A B) ::
                  { newPMask[o_9, f_12] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][o_9, f_12] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$])][o_9, f_12] ==> newPMask[o_9, f_12]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])] := newPMask;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNoderight$])][Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
              }
            assume state(Heap, Mask);
          
          // -- Translating statement: assert (this$_10.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$), write) in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ != Seq()) -- AVLTree.sil,670:7
            
            // -- Check definedness of (this$_10.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$), write) in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ != Seq())
              assert {:msg "  Assert might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,670:7) [11107]"}
                this$_10 != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,670:7) [11108]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
              if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                UnfoldingHeap := Heap;
                UnfoldingMask := Mask;
                assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$]));
                // Phase 1: pure assertions and fixed permissions
                perm := NoPerm;
                perm := PermAdd(perm, FullPerm);
                if (perm != NoPerm) {
                  assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,670:7) [11109]"}
                    (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])][$eps]);
                }
                UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])], perm);
                
                // -- Update version of predicate
                  if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$]))) {
                    oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])];
                    havoc newVersion;
                    assume oldVersion < newVersion;
                    UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])] := newVersion;
                  }
                perm := Perm(1.000000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                perm := Perm(1.000000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
                perm := Perm(1.000000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  perm := FullPerm;
                  UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  assume (forall lk_2: int ::
                    
                    Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$]
                  );
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  perm := FullPerm;
                  UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_10, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$])]);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  perm := Perm(0.500000000, 0.000000000);
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
                  UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  assume (forall rk_2: int ::
                    
                    Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$] < rk_2
                  );
                }
                if (UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
                }
                assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
                assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$]);
                assume (forall kk_2: int ::
                  
                  Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2) == ((UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$]))
                );
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
                assume UnfoldingHeap[UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
                assume state(UnfoldingHeap, UnfoldingMask);
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,670:7) [11110]"}
                  HasDirectPerm(UnfoldingMask, this$_10, AVLTreeNodeleft$);
                assert {:msg "  Assert might fail. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,670:7) [11111]"}
                  UnfoldingHeap[this$_10, AVLTreeNodeleft$] != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,670:7) [11112]"}
                  HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$);
                assert {:msg "  Assert might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,670:7) [11113]"}
                  this$_10 != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,670:7) [11114]"}
                  HasDirectPerm(UnfoldingMask, this$_10, AVLTreeNodeleft$);
                
                // -- Free assumptions
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                    havoc newPMask;
                    assume (forall <A, B> o_10: Ref, f_13: (Field A B) ::
                      { newPMask[o_10, f_13] }
                      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][o_10, f_13] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_10, f_13] ==> newPMask[o_10, f_13]
                    );
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])] := newPMask;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                    havoc newPMask;
                    assume (forall <A, B> o_11: Ref, f_14: (Field A B) ::
                      { newPMask[o_11, f_14] }
                      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][o_11, f_14] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$])][o_11, f_14] ==> newPMask[o_11, f_14]
                    );
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])] := newPMask;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
                  }
                  if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
                  }
              }
              assume state(Heap, Mask);
            // Phase 1: pure assertions and fixed permissions
            if (Heap[this$_10, AVLTreeNodeleft$] != null) {
              assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$), write) in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ != Seq()) might not hold. (AVLTree.sil,670:7) [11115]"}
                !Seq#Equal(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], (Seq#Empty(): Seq_ int));
            }
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            
            // -- Free assumptions
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_12: Ref, f_15: (Field A B) ::
                  { newPMask[o_12, f_15] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][o_12, f_15] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_12, f_15] ==> newPMask[o_12, f_15]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])] := newPMask;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_13: Ref, f_16: (Field A B) ::
                  { newPMask[o_13, f_16] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][o_13, f_16] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$])][o_13, f_16] ==> newPMask[o_13, f_16]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])] := newPMask;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_10, AVLTreeNodeleft$])][Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
              }
            assume state(Heap, Mask);
          
          // -- Translating statement: if (this$_10.AVLTreeNodeleft$ == null) -- AVLTree.sil,671:7
            
            // -- Check definedness of this$_10.AVLTreeNodeleft$ == null
              assert {:msg "  Conditional statement might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,671:11) [11116]"}
                this$_10 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,671:11) [11117]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            if (Heap[this$_10, AVLTreeNodeleft$] == null) {
              
              // -- Translating statement: r := this$_10.AVLTreeNoderight$ -- AVLTree.sil,672:9
                
                // -- Check definedness of this$_10.AVLTreeNoderight$
                  assert {:msg "  Assignment might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,672:9) [11118]"}
                    this$_10 != null;
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,672:9) [11119]"}
                    HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
                  assume state(Heap, Mask);
                r_1 := Heap[this$_10, AVLTreeNoderight$];
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: r := this$_10.AVLTreeNodeleft$ -- AVLTree.sil,674:9
                
                // -- Check definedness of this$_10.AVLTreeNodeleft$
                  assert {:msg "  Assignment might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,674:9) [11120]"}
                    this$_10 != null;
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,674:9) [11121]"}
                    HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
                  assume state(Heap, Mask);
                r_1 := Heap[this$_10, AVLTreeNodeleft$];
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: nl := this$_10.AVLTreeNodeleft$ -- AVLTree.sil,677:7
            
            // -- Check definedness of this$_10.AVLTreeNodeleft$
              assert {:msg "  Assignment might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,677:7) [11122]"}
                this$_10 != null;
              assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,677:7) [11123]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            nl := Heap[this$_10, AVLTreeNodeleft$];
            assume state(Heap, Mask);
          
          // -- Translating statement: nr := this$_10.AVLTreeNoderight$ -- AVLTree.sil,678:7
            
            // -- Check definedness of this$_10.AVLTreeNoderight$
              assert {:msg "  Assignment might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,678:7) [11124]"}
                this$_10 != null;
              assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,678:7) [11125]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
              assume state(Heap, Mask);
            nr := Heap[this$_10, AVLTreeNoderight$];
            assume state(Heap, Mask);
          
          // -- Translating statement: fresh newK$_39  -- AVLTree.sil,679:7
            
            // -- Translation of statement fresh newK$_39)
              havoc newK$_39;
              assume (newK$_39[$frac] > 0.000000000 && newK$_39[$frac] < 0.001000000) && newK$_39[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_39) -- AVLTree.sil,680:7
            
            // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_10, newK$_39) -- AVLTree.sil,681:9
              PreCallHeap := Heap;
              PreCallMask := Mask;
              havoc bf;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_10 != null might not hold. (AVLTree.sil,681:9) [11126]"}
                  this$_10 != null;
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_39 > none might not hold. (AVLTree.sil,681:9) [11127]"}
                  NoPerm[$frac] < newK$_39[$frac] || (NoPerm[$frac] == newK$_39[$frac] && NoPerm[$eps] < newK$_39[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_39 might not hold. (AVLTree.sil,681:9) [11128]"}
                  newK$_39[$frac] < FullPerm[$frac] || (newK$_39[$frac] == FullPerm[$frac] && newK$_39[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_39 might not be positive. (AVLTree.sil,681:9) [11129]"}
                  newK$_39[$frac] > 0.000000000 || (newK$_39[$frac] == 0.000000000 && newK$_39[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,681:9) [11130]"}
                  this$_10 != null;
                if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,681:9) [11131]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                }
                if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_39 might not be positive. (AVLTree.sil,681:9) [11132]"}
                    newK$_39[$frac] > 0.000000000 || (newK$_39[$frac] == 0.000000000 && newK$_39[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,681:9) [11133]"}
                    Heap[this$_10, AVLTreeNodeleft$] != null;
                }
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_39 might not be positive. (AVLTree.sil,681:9) [11134]"}
                  newK$_39[$frac] > 0.000000000 || (newK$_39[$frac] == 0.000000000 && newK$_39[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,681:9) [11135]"}
                  this$_10 != null;
                if (Heap[this$_10, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,681:9) [11136]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                }
                if (Heap[this$_10, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_39 might not be positive. (AVLTree.sil,681:9) [11137]"}
                    newK$_39[$frac] > 0.000000000 || (newK$_39[$frac] == 0.000000000 && newK$_39[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,681:9) [11138]"}
                    Heap[this$_10, AVLTreeNoderight$] != null;
                }
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                perm := NoPerm;
                perm := PermAdd(perm, newK$_39);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,681:9) [11139]"}
                    Mask[this$_10, AVLTreeNodeleft$][$frac] > 0.000000000;
                  assume perm[$frac] < Mask[this$_10, AVLTreeNodeleft$][$frac];
                }
                Mask[this$_10, AVLTreeNodeleft$] := PermSub(Mask[this$_10, AVLTreeNodeleft$], perm);
                if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, newK$_39);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,681:9) [11140]"}
                      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                    assume perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
                  }
                  Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                perm := NoPerm;
                perm := PermAdd(perm, newK$_39);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,681:9) [11141]"}
                    Mask[this$_10, AVLTreeNoderight$][$frac] > 0.000000000;
                  assume perm[$frac] < Mask[this$_10, AVLTreeNoderight$][$frac];
                }
                Mask[this$_10, AVLTreeNoderight$] := PermSub(Mask[this$_10, AVLTreeNoderight$], perm);
                if (Heap[this$_10, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, newK$_39);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,681:9) [11142]"}
                      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                    assume perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
                  }
                  Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                perm := newK$_39;
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_10 != null;
                Mask[this$_10, AVLTreeNodeleft$] := PermAdd(Mask[this$_10, AVLTreeNodeleft$], perm);
                if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                  perm := FullPerm;
                  Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                  
                  // -- Extra unfolding of predicate
                    
                }
                if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                  perm := newK$_39;
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume Heap[this$_10, AVLTreeNodeleft$] != null;
                  Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                perm := newK$_39;
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_10 != null;
                Mask[this$_10, AVLTreeNoderight$] := PermAdd(Mask[this$_10, AVLTreeNoderight$], perm);
                if (Heap[this$_10, AVLTreeNoderight$] != null) {
                  perm := FullPerm;
                  Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                  
                  // -- Extra unfolding of predicate
                    
                }
                if (Heap[this$_10, AVLTreeNoderight$] != null) {
                  perm := newK$_39;
                  assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                  assume Heap[this$_10, AVLTreeNoderight$] != null;
                  Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                assume bf == (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]);
                if (bf > 0) {
                  assume Heap[this$_10, AVLTreeNodeleft$] != null;
                }
                if (bf < 0) {
                  assume Heap[this$_10, AVLTreeNoderight$] != null;
                }
                assume state(Heap, Mask);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_39 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,681:9) [11143]"}
                newK$_39[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (bf > 0) -- AVLTree.sil,683:7
            if (bf > 0) {
              
              // -- Translating statement: fresh newK$_40  -- AVLTree.sil,684:9
                
                // -- Translation of statement fresh newK$_40)
                  havoc newK$_40;
                  assume (newK$_40[$frac] > 0.000000000 && newK$_40[$frac] < 0.001000000) && newK$_40[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_40) -- AVLTree.sil,685:9
                
                // -- Translating statement: nl, r := AVLTreeNodepruneMax$(this$_10.AVLTreeNodeleft$, newK$_40) -- AVLTree.sil,686:11
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_10.AVLTreeNodeleft$
                    assert {:msg "  Method call might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,686:11) [11144]"}
                      this$_10 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,686:11) [11145]"}
                      HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
                    assume state(Heap, Mask);
                  arg_this$_11 := Heap[this$_10, AVLTreeNodeleft$];
                  havoc nl, r_1;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Assertion this$_10.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,686:11) [11146]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Assertion newK$_40 > none might not hold. (AVLTree.sil,686:11) [11147]"}
                      NoPerm[$frac] < newK$_40[$frac] || (NoPerm[$frac] == newK$_40[$frac] && NoPerm[$eps] < newK$_40[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Assertion write > newK$_40 might not hold. (AVLTree.sil,686:11) [11148]"}
                      newK$_40[$frac] < FullPerm[$frac] || (newK$_40[$frac] == FullPerm[$frac] && newK$_40[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,686:11) [11149]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,686:11) [11150]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,686:11) [11151]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,686:11) [11152]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,686:11) [11153]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,686:11) [11154]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,686:11) [11155]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,686:11) [11156]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,686:11) [11157]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,686:11) [11158]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    if (nl != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(nl)] := PermAdd(Mask[null, AVLTreeNodevalid$(nl)], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (nl != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nl != null;
                      Mask[nl, AVLTreeNodekeys$] := PermAdd(Mask[nl, AVLTreeNodekeys$], perm);
                    }
                    if (nl != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nl != null;
                      Mask[nl, AVLTreeNodeheight$] := PermAdd(Mask[nl, AVLTreeNodeheight$], perm);
                    }
                    if (nl != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nl != null;
                      Mask[nl, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nl, AVLTreeNodebalanceFactor$], perm);
                    }
                    if (nl != null) {
                      assume Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_11, AVLTreeNodeheight$] || Heap[nl, AVLTreeNodeheight$] + 1 == PreCallHeap[arg_this$_11, AVLTreeNodeheight$];
                    }
                    if (nl != null) {
                      assume Seq#Length(Heap[nl, AVLTreeNodekeys$]) + 1 == Seq#Length(PreCallHeap[arg_this$_11, AVLTreeNodekeys$]);
                    }
                    if (PreCallHeap[arg_this$_11, AVLTreeNodeheight$] > 1) {
                      assume nl != null;
                    }
                    if (PreCallHeap[arg_this$_11, AVLTreeNodeheight$] == 1) {
                      assume nl == null;
                    }
                    assume PreCallHeap[arg_this$_11, AVLTreeNodeheight$] == (if nl == null then 0 else Heap[nl, AVLTreeNodeheight$]) || PreCallHeap[arg_this$_11, AVLTreeNodeheight$] == (if nl == null then 0 else Heap[nl, AVLTreeNodeheight$]) + 1;
                    assume r_1 != null;
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Heap[r_1, AVLTreeNodeheight$] == 1;
                    assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == 1;
                    assume Seq#Equal(Seq#Append((if nl == null then (Seq#Empty(): Seq_ int) else Heap[nl, AVLTreeNodekeys$]), Heap[r_1, AVLTreeNodekeys$]), PreCallHeap[arg_this$_11, AVLTreeNodekeys$]);
                    if (nl != null) {
                      assume (forall k0: int ::
                        
                        Seq#Contains(Heap[nl, AVLTreeNodekeys$], k0) ==> k0 < Seq#Index(Heap[r_1, AVLTreeNodekeys$], 0)
                      );
                    }
                    assume state(Heap, Mask);
                  assume nl == null || Heap[nl, $allocated];
                  assume r_1 == null || Heap[r_1, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. The parameter newK$_40 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,686:11) [11159]"}
                    newK$_40[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: fresh newK$_41  -- AVLTree.sil,689:9
                
                // -- Translation of statement fresh newK$_41)
                  havoc newK$_41;
                  assume (newK$_41[$frac] > 0.000000000 && newK$_41[$frac] < 0.001000000) && newK$_41[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_41) -- AVLTree.sil,690:9
                
                // -- Translating statement: nr, r := AVLTreeNodepruneMin$(this$_10.AVLTreeNoderight$, newK$_41) -- AVLTree.sil,691:11
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_10.AVLTreeNoderight$
                    assert {:msg "  Method call might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,691:11) [11160]"}
                      this$_10 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,691:11) [11161]"}
                      HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
                    assume state(Heap, Mask);
                  arg_this$_12 := Heap[this$_10, AVLTreeNoderight$];
                  havoc nr, r_1;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Assertion this$_10.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,691:11) [11162]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Assertion newK$_41 > none might not hold. (AVLTree.sil,691:11) [11163]"}
                      NoPerm[$frac] < newK$_41[$frac] || (NoPerm[$frac] == newK$_41[$frac] && NoPerm[$eps] < newK$_41[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Assertion write > newK$_41 might not hold. (AVLTree.sil,691:11) [11164]"}
                      newK$_41[$frac] < FullPerm[$frac] || (newK$_41[$frac] == FullPerm[$frac] && newK$_41[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,691:11) [11165]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,691:11) [11166]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,691:11) [11167]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,691:11) [11168]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,691:11) [11169]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,691:11) [11170]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,691:11) [11171]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,691:11) [11172]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,691:11) [11173]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,691:11) [11174]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    if (nr != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(nr)] := PermAdd(Mask[null, AVLTreeNodevalid$(nr)], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (nr != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nr != null;
                      Mask[nr, AVLTreeNodekeys$] := PermAdd(Mask[nr, AVLTreeNodekeys$], perm);
                    }
                    if (nr != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nr != null;
                      Mask[nr, AVLTreeNodeheight$] := PermAdd(Mask[nr, AVLTreeNodeheight$], perm);
                    }
                    if (nr != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nr != null;
                      Mask[nr, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nr, AVLTreeNodebalanceFactor$], perm);
                    }
                    if (nr != null) {
                      assume Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_12, AVLTreeNodeheight$] || Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_12, AVLTreeNodeheight$] - 1;
                    }
                    if (nr != null) {
                      assume Seq#Length(Heap[nr, AVLTreeNodekeys$]) + 1 == Seq#Length(PreCallHeap[arg_this$_12, AVLTreeNodekeys$]);
                    }
                    if (PreCallHeap[arg_this$_12, AVLTreeNodeheight$] > 1) {
                      assume nr != null;
                    }
                    if (PreCallHeap[arg_this$_12, AVLTreeNodeheight$] == 1) {
                      assume nr == null;
                    }
                    assume PreCallHeap[arg_this$_12, AVLTreeNodeheight$] == (if nr == null then 0 else Heap[nr, AVLTreeNodeheight$]) || PreCallHeap[arg_this$_12, AVLTreeNodeheight$] == (if nr == null then 0 else Heap[nr, AVLTreeNodeheight$]) + 1;
                    assume r_1 != null;
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Heap[r_1, AVLTreeNodeheight$] == 1;
                    assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == 1;
                    assume Seq#Equal(Seq#Append(Heap[r_1, AVLTreeNodekeys$], (if nr == null then (Seq#Empty(): Seq_ int) else Heap[nr, AVLTreeNodekeys$])), PreCallHeap[arg_this$_12, AVLTreeNodekeys$]);
                    if (nr != null) {
                      assume (forall k0_1: int ::
                        
                        Seq#Contains(Heap[nr, AVLTreeNodekeys$], k0_1) ==> Seq#Index(Heap[r_1, AVLTreeNodekeys$], 0) < k0_1
                      );
                    }
                    assume state(Heap, Mask);
                  assume nr == null || Heap[nr, $allocated];
                  assume r_1 == null || Heap[r_1, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. The parameter newK$_41 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,691:11) [11175]"}
                    newK$_41[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(AVLTreeNodevalid$(r), write) -- AVLTree.sil,694:7
            assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(r_1));
            // Phase 1: pure assertions and fixed permissions
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  Unfolding AVLTreeNodevalid$(r) might fail. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,694:7) [11178]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Update version of predicate
              if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(r_1))) {
                oldVersion := Heap[null, AVLTreeNodevalid$(r_1)];
                havoc newVersion;
                assume oldVersion < newVersion;
                Heap[null, AVLTreeNodevalid$(r_1)] := newVersion;
              }
            perm := Perm(1.000000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekey$] := PermAdd(Mask[r_1, AVLTreeNodekey$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(1.000000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeleft$] := PermAdd(Mask[r_1, AVLTreeNodeleft$], perm);
            perm := Perm(1.000000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNoderight$] := PermAdd(Mask[r_1, AVLTreeNoderight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(r_1, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(r_1)], Heap[r_1, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])]);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[r_1, AVLTreeNodeleft$] != null;
              Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[r_1, AVLTreeNodeleft$] != null;
              Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[r_1, AVLTreeNodeleft$] != null;
              Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              assume (forall lk_3: int ::
                
                Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_3) ==> lk_3 < Heap[r_1, AVLTreeNodekey$]
              );
            }
            if (Heap[r_1, AVLTreeNodeleft$] != null) {
              assume Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(r_1, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(r_1)], Heap[r_1, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])]);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[r_1, AVLTreeNoderight$] != null;
              Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[r_1, AVLTreeNoderight$] != null;
              Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[r_1, AVLTreeNoderight$] != null;
              Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              assume (forall rk_3: int ::
                
                Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], rk_3) ==> Heap[r_1, AVLTreeNodekey$] < rk_3
              );
            }
            if (Heap[r_1, AVLTreeNoderight$] != null) {
              assume Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
            }
            assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[r_1, AVLTreeNodekey$])), (if Heap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
            assume Seq#Contains(Heap[r_1, AVLTreeNodekeys$], Heap[r_1, AVLTreeNodekey$]);
            assume (forall kk_3: int ::
              
              Seq#Contains(Heap[r_1, AVLTreeNodekeys$], kk_3) == ((Heap[r_1, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_3)) || ((Heap[r_1, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], kk_3)) || kk_3 == Heap[r_1, AVLTreeNodekey$]))
            );
            assume Heap[r_1, AVLTreeNodeheight$] == (if (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
            assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
            assume Heap[r_1, AVLTreeNodebalanceFactor$] <= 1;
            assume Heap[r_1, AVLTreeNodebalanceFactor$] >= -1;
            assume Heap[r_1, AVLTreeNodeheight$] > 0;
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: r.AVLTreeNodeleft$ := nl -- AVLTree.sil,695:7
            
            // -- Check definedness of r.AVLTreeNodeleft$
              assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,695:7) [11179]"}
                HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            Heap[r_1, AVLTreeNodeleft$] := nl;
            assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,695:7) [11180]"}
              FullPerm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps];
            assume state(Heap, Mask);
          
          // -- Translating statement: r.AVLTreeNoderight$ := nr -- AVLTree.sil,696:7
            
            // -- Check definedness of r.AVLTreeNoderight$
              assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,696:7) [11181]"}
                r_1 != null;
              assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,696:7) [11182]"}
                HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
              assume state(Heap, Mask);
            Heap[r_1, AVLTreeNoderight$] := nr;
            assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,696:7) [11183]"}
              FullPerm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps];
            assume state(Heap, Mask);
          
          // -- Translating statement: fresh newK$_42  -- AVLTree.sil,697:7
            
            // -- Translation of statement fresh newK$_42)
              havoc newK$_42;
              assume (newK$_42[$frac] > 0.000000000 && newK$_42[$frac] < 0.001000000) && newK$_42[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_42) -- AVLTree.sil,698:7
            
            // -- Translating statement: AVLTreeNodeclose$(r, newK$_42) -- AVLTree.sil,699:9
              PreCallHeap := Heap;
              PreCallMask := Mask;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,699:9) [11184]"}
                  r_1 != null;
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_42 > none might not hold. (AVLTree.sil,699:9) [11185]"}
                  NoPerm[$frac] < newK$_42[$frac] || (NoPerm[$frac] == newK$_42[$frac] && NoPerm[$eps] < newK$_42[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_42 might not hold. (AVLTree.sil,699:9) [11186]"}
                  newK$_42[$frac] < FullPerm[$frac] || (newK$_42[$frac] == FullPerm[$frac] && newK$_42[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,699:9) [11187]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,699:9) [11188]"}
                  r_1 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,699:9) [11189]"}
                    (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
                }
                Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,699:9) [11190]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,699:9) [11191]"}
                  r_1 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,699:9) [11192]"}
                    (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
                }
                Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,699:9) [11193]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,699:9) [11194]"}
                  r_1 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,699:9) [11195]"}
                    (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
                }
                Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,699:9) [11196]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,699:9) [11197]"}
                  r_1 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,699:9) [11198]"}
                    (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
                }
                Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,699:9) [11199]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,699:9) [11200]"}
                  r_1 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,699:9) [11201]"}
                    (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
                }
                Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,699:9) [11202]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,699:9) [11203]"}
                  r_1 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,699:9) [11204]"}
                    (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                if (Heap[r_1, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,699:9) [11205]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
                }
                if (Heap[r_1, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,699:9) [11206]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,699:9) [11207]"}
                    Heap[r_1, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,699:9) [11208]"}
                      (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                if (Heap[r_1, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,699:9) [11209]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,699:9) [11210]"}
                    Heap[r_1, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,699:9) [11211]"}
                      (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                }
                if (Heap[r_1, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,699:9) [11212]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,699:9) [11213]"}
                    Heap[r_1, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,699:9) [11214]"}
                      (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[r_1, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,699:9) [11215]"}
                    (forall k0_2: int ::
                    
                    Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_2) ==> k0_2 < Heap[r_1, AVLTreeNodekey$]
                  );
                }
                if (Heap[r_1, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,699:9) [11216]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
                }
                if (Heap[r_1, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,699:9) [11217]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,699:9) [11218]"}
                    Heap[r_1, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,699:9) [11219]"}
                      (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                if (Heap[r_1, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,699:9) [11220]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,699:9) [11221]"}
                    Heap[r_1, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,699:9) [11222]"}
                      (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                }
                if (Heap[r_1, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,699:9) [11223]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,699:9) [11224]"}
                    Heap[r_1, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,699:9) [11225]"}
                      (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[r_1, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,699:9) [11226]"}
                    (forall k1: int ::
                    
                    Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1) ==> Heap[r_1, AVLTreeNodekey$] < k1
                  );
                }
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,699:9) [11227]"}
                  (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,699:9) [11228]"}
                  (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                perm := FullPerm;
                Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                
                // -- Extra unfolding of predicate
                  
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
                assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
                assume state(Heap, Mask);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_42 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,699:9) [11229]"}
                newK$_42[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: if (k < this$_10.AVLTreeNodekey$) -- AVLTree.sil,702:5
        
        // -- Check definedness of k < this$_10.AVLTreeNodekey$
          assert {:msg "  Conditional statement might fail. Receiver of this$_10.AVLTreeNodekey$ might be null. (AVLTree.sil,702:12) [11230]"}
            this$_10 != null;
          assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNodekey$. (AVLTree.sil,702:12) [11231]"}
            HasDirectPerm(Mask, this$_10, AVLTreeNodekey$);
          assume state(Heap, Mask);
        if (k < Heap[this$_10, AVLTreeNodekey$]) {
          
          // -- Translating statement: if (this$_10.AVLTreeNodeleft$ != null) -- AVLTree.sil,703:5
            
            // -- Check definedness of this$_10.AVLTreeNodeleft$ != null
              assert {:msg "  Conditional statement might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,703:9) [11232]"}
                this$_10 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,703:9) [11233]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            if (Heap[this$_10, AVLTreeNodeleft$] != null) {
              
              // -- Translating statement: fresh newK$_43  -- AVLTree.sil,704:7
                
                // -- Translation of statement fresh newK$_43)
                  havoc newK$_43;
                  assume (newK$_43[$frac] > 0.000000000 && newK$_43[$frac] < 0.001000000) && newK$_43[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_43) -- AVLTree.sil,705:7
                
                // -- Translating statement: nl := AVLTreeNoderemove$(this$_10.AVLTreeNodeleft$, newK$_43, k) -- AVLTree.sil,706:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_10.AVLTreeNodeleft$
                    assert {:msg "  Method call might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,706:9) [11234]"}
                      this$_10 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,706:9) [11235]"}
                      HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
                    assume state(Heap, Mask);
                  arg_this$_10 := Heap[this$_10, AVLTreeNodeleft$];
                  havoc nl;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion this$_10.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,706:9) [11236]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion newK$_43 > none might not hold. (AVLTree.sil,706:9) [11237]"}
                      NoPerm[$frac] < newK$_43[$frac] || (NoPerm[$frac] == newK$_43[$frac] && NoPerm[$eps] < newK$_43[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion write > newK$_43 might not hold. (AVLTree.sil,706:9) [11238]"}
                      newK$_43[$frac] < FullPerm[$frac] || (newK$_43[$frac] == FullPerm[$frac] && newK$_43[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,706:9) [11239]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,706:9) [11240]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,706:9) [11241]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,706:9) [11242]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,706:9) [11243]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,706:9) [11244]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,706:9) [11245]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,706:9) [11246]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,706:9) [11247]"}
                      Heap[this$_10, AVLTreeNodeleft$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,706:9) [11248]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    if (Seq#Equal(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
                      assume nl == null;
                    }
                    if (!Seq#Equal(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
                      assume nl != null;
                    }
                    if (nl != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(nl)] := PermAdd(Mask[null, AVLTreeNodevalid$(nl)], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (nl != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nl != null;
                      Mask[nl, AVLTreeNodekeys$] := PermAdd(Mask[nl, AVLTreeNodekeys$], perm);
                    }
                    if (nl != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nl != null;
                      Mask[nl, AVLTreeNodeheight$] := PermAdd(Mask[nl, AVLTreeNodeheight$], perm);
                    }
                    if (nl != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nl != null;
                      Mask[nl, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nl, AVLTreeNodebalanceFactor$], perm);
                    }
                    if (nl != null) {
                      assume !Seq#Contains(Heap[nl, AVLTreeNodekeys$], k);
                    }
                    if (nl != null) {
                      assume (forall i_6: int ::
                        
                        Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], i_6) ==> Seq#Contains(Heap[nl, AVLTreeNodekeys$], i_6) || i_6 == k
                      );
                    }
                    if (nl != null) {
                      assume (forall i_7: int ::
                        
                        Seq#Contains(Heap[nl, AVLTreeNodekeys$], i_7) ==> Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], i_7) && i_7 != k
                      );
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
                      assume nl != null;
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
                      assume Seq#Equal(Heap[nl, AVLTreeNodekeys$], PreCallHeap[arg_this$_10, AVLTreeNodekeys$]);
                    }
                    if (nl != null) {
                      if (Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
                        assume Seq#Length(Heap[nl, AVLTreeNodekeys$]) == Seq#Length(PreCallHeap[arg_this$_10, AVLTreeNodekeys$]) - 1;
                      }
                    }
                    if (PreCallHeap[arg_this$_10, AVLTreeNodeheight$] > 1) {
                      assume nl != null;
                    }
                    if (nl != null) {
                      assume Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_10, AVLTreeNodeheight$] || Heap[nl, AVLTreeNodeheight$] + 1 == PreCallHeap[arg_this$_10, AVLTreeNodeheight$];
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_10, AVLTreeNodekeys$], k)) {
                      assume Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_10, AVLTreeNodeheight$];
                    }
                    assume state(Heap, Mask);
                  assume nl == null || Heap[nl, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. The parameter newK$_43 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,706:9) [11249]"}
                    newK$_43[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: this$_10.AVLTreeNodeleft$ := nl -- AVLTree.sil,708:7
                
                // -- Check definedness of this$_10.AVLTreeNodeleft$
                  assert {:msg "  Assignment might fail. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,708:7) [11250]"}
                    this$_10 != null;
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,708:7) [11251]"}
                    HasDirectPerm(Mask, this$_10, AVLTreeNodeleft$);
                  assume state(Heap, Mask);
                Heap[this$_10, AVLTreeNodeleft$] := nl;
                assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,708:7) [11252]"}
                  FullPerm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_10, AVLTreeNodeleft$][$eps];
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_44  -- AVLTree.sil,709:7
                
                // -- Translation of statement fresh newK$_44)
                  havoc newK$_44;
                  assume (newK$_44[$frac] > 0.000000000 && newK$_44[$frac] < 0.001000000) && newK$_44[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_44) -- AVLTree.sil,710:7
                
                // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_10, newK$_44) -- AVLTree.sil,711:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  havoc bf;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_10 != null might not hold. (AVLTree.sil,711:9) [11253]"}
                      this$_10 != null;
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_44 > none might not hold. (AVLTree.sil,711:9) [11254]"}
                      NoPerm[$frac] < newK$_44[$frac] || (NoPerm[$frac] == newK$_44[$frac] && NoPerm[$eps] < newK$_44[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_44 might not hold. (AVLTree.sil,711:9) [11255]"}
                      newK$_44[$frac] < FullPerm[$frac] || (newK$_44[$frac] == FullPerm[$frac] && newK$_44[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_44 might not be positive. (AVLTree.sil,711:9) [11256]"}
                      newK$_44[$frac] > 0.000000000 || (newK$_44[$frac] == 0.000000000 && newK$_44[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,711:9) [11257]"}
                      this$_10 != null;
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,711:9) [11258]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_44 might not be positive. (AVLTree.sil,711:9) [11259]"}
                        newK$_44[$frac] > 0.000000000 || (newK$_44[$frac] == 0.000000000 && newK$_44[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,711:9) [11260]"}
                        Heap[this$_10, AVLTreeNodeleft$] != null;
                    }
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_44 might not be positive. (AVLTree.sil,711:9) [11261]"}
                      newK$_44[$frac] > 0.000000000 || (newK$_44[$frac] == 0.000000000 && newK$_44[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,711:9) [11262]"}
                      this$_10 != null;
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,711:9) [11263]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_44 might not be positive. (AVLTree.sil,711:9) [11264]"}
                        newK$_44[$frac] > 0.000000000 || (newK$_44[$frac] == 0.000000000 && newK$_44[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,711:9) [11265]"}
                        Heap[this$_10, AVLTreeNoderight$] != null;
                    }
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    perm := NoPerm;
                    perm := PermAdd(perm, newK$_44);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,711:9) [11266]"}
                        Mask[this$_10, AVLTreeNodeleft$][$frac] > 0.000000000;
                      assume perm[$frac] < Mask[this$_10, AVLTreeNodeleft$][$frac];
                    }
                    Mask[this$_10, AVLTreeNodeleft$] := PermSub(Mask[this$_10, AVLTreeNodeleft$], perm);
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, newK$_44);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,711:9) [11267]"}
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                        assume perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
                      }
                      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    perm := NoPerm;
                    perm := PermAdd(perm, newK$_44);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,711:9) [11268]"}
                        Mask[this$_10, AVLTreeNoderight$][$frac] > 0.000000000;
                      assume perm[$frac] < Mask[this$_10, AVLTreeNoderight$][$frac];
                    }
                    Mask[this$_10, AVLTreeNoderight$] := PermSub(Mask[this$_10, AVLTreeNoderight$], perm);
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, newK$_44);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,711:9) [11269]"}
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                        assume perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
                      }
                      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := newK$_44;
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume this$_10 != null;
                    Mask[this$_10, AVLTreeNodeleft$] := PermAdd(Mask[this$_10, AVLTreeNodeleft$], perm);
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := newK$_44;
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume Heap[this$_10, AVLTreeNodeleft$] != null;
                      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    perm := newK$_44;
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume this$_10 != null;
                    Mask[this$_10, AVLTreeNoderight$] := PermAdd(Mask[this$_10, AVLTreeNoderight$], perm);
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := newK$_44;
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume Heap[this$_10, AVLTreeNoderight$] != null;
                      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    assume bf == (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]);
                    if (bf > 0) {
                      assume Heap[this$_10, AVLTreeNodeleft$] != null;
                    }
                    if (bf < 0) {
                      assume Heap[this$_10, AVLTreeNoderight$] != null;
                    }
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_44 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,711:9) [11270]"}
                    newK$_44[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: if (bf == 0 - 2) -- AVLTree.sil,713:7
                if (bf == -2) {
                  
                  // -- Translating statement: fresh newK$_45  -- AVLTree.sil,714:9
                    
                    // -- Translation of statement fresh newK$_45)
                      havoc newK$_45;
                      assume (newK$_45[$frac] > 0.000000000 && newK$_45[$frac] < 0.001000000) && newK$_45[$eps] == 0.000000000;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: constraining(newK$_45) -- AVLTree.sil,715:9
                    
                    // -- Translating statement: r := AVLTreeNoderebalanceRight$(this$_10, newK$_45) -- AVLTree.sil,716:11
                      PreCallHeap := Heap;
                      PreCallMask := Mask;
                      havoc r_1;
                      
                      // -- Exhaling precondition
                        havoc ExhaleHeap;
                        // Phase 1: pure assertions and fixed permissions
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion this$_10 != null might not hold. (AVLTree.sil,716:11) [11271]"}
                          this$_10 != null;
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion newK$_45 > none might not hold. (AVLTree.sil,716:11) [11272]"}
                          NoPerm[$frac] < newK$_45[$frac] || (NoPerm[$frac] == newK$_45[$frac] && NoPerm[$eps] < newK$_45[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion write > newK$_45 might not hold. (AVLTree.sil,716:11) [11273]"}
                          newK$_45[$frac] < FullPerm[$frac] || (newK$_45[$frac] == FullPerm[$frac] && newK$_45[$eps] < FullPerm[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,716:11) [11274]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodekey$ might be null. (AVLTree.sil,716:11) [11275]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodekey$. (AVLTree.sil,716:11) [11276]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodekey$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodekey$] := PermSub(Mask[this$_10, AVLTreeNodekey$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,716:11) [11277]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,716:11) [11278]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,716:11) [11279]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodeheight$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodeheight$] := PermSub(Mask[this$_10, AVLTreeNodeheight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,716:11) [11280]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,716:11) [11281]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,716:11) [11282]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodeleft$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodeleft$] := PermSub(Mask[this$_10, AVLTreeNodeleft$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,716:11) [11283]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,716:11) [11284]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,716:11) [11285]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNoderight$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNoderight$] := PermSub(Mask[this$_10, AVLTreeNoderight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,716:11) [11286]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,716:11) [11287]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,716:11) [11288]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodekeys$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodekeys$] := PermSub(Mask[this$_10, AVLTreeNodekeys$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,716:11) [11289]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,716:11) [11290]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodebalanceFactor$. (AVLTree.sil,716:11) [11291]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodebalanceFactor$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_10, AVLTreeNodebalanceFactor$], perm);
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          perm := NoPerm;
                          perm := PermAdd(perm, FullPerm);
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,716:11) [11292]"}
                              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                          }
                          Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,716:11) [11293]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,716:11) [11294]"}
                            Heap[this$_10, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,716:11) [11295]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,716:11) [11296]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,716:11) [11297]"}
                            Heap[this$_10, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,716:11) [11298]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,716:11) [11299]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,716:11) [11300]"}
                            Heap[this$_10, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,716:11) [11301]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (forall k: Int :: true && k in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_10.AVLTreeNodekey$)) might not hold. (AVLTree.sil,716:11) [11302]"}
                            (forall k_1_1: int ::
                            
                            Seq#Contains(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], k_1_1) ==> k_1_1 < Heap[this$_10, AVLTreeNodekey$]
                          );
                        }
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion this$_10.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,716:11) [11303]"}
                          Heap[this$_10, AVLTreeNoderight$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, FullPerm);
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,716:11) [11304]"}
                            (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                        }
                        Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,716:11) [11305]"}
                          Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,716:11) [11306]"}
                          Heap[this$_10, AVLTreeNoderight$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,716:11) [11307]"}
                            (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                        }
                        Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,716:11) [11308]"}
                          Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,716:11) [11309]"}
                          Heap[this$_10, AVLTreeNoderight$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,716:11) [11310]"}
                            (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                        }
                        Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,716:11) [11311]"}
                          Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,716:11) [11312]"}
                          Heap[this$_10, AVLTreeNoderight$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,716:11) [11313]"}
                            (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                        }
                        Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_10.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,716:11) [11314]"}
                          (forall k1_1: int ::
                          
                          Seq#Contains(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_10, AVLTreeNodekey$] < k1_1
                        );
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (this$_10.AVLTreeNodeleft$ == null ? 0 : this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2 might not hold. (AVLTree.sil,716:11) [11315]"}
                          (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
                        // Phase 2: abstract read permissions (and scaled abstract read permissions)
                        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                        // Finish exhale
                        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                        Heap := ExhaleHeap;
                      
                      // -- Inhaling postcondition
                        assume r_1 != null;
                        perm := FullPerm;
                        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                        
                        // -- Extra unfolding of predicate
                          
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                        assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
                        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_10, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_10, AVLTreeNodekey$])), PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$]));
                        assume state(Heap, Mask);
                      assume r_1 == null || Heap[r_1, $allocated];
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. The parameter newK$_45 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,716:11) [11316]"}
                        newK$_45[$eps] == 0.000000000;
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: fresh newK$_46  -- AVLTree.sil,719:9
                    
                    // -- Translation of statement fresh newK$_46)
                      havoc newK$_46;
                      assume (newK$_46[$frac] > 0.000000000 && newK$_46[$frac] < 0.001000000) && newK$_46[$eps] == 0.000000000;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: constraining(newK$_46) -- AVLTree.sil,720:9
                    
                    // -- Translating statement: AVLTreeNodeclose$(this$_10, newK$_46) -- AVLTree.sil,721:11
                      PreCallHeap := Heap;
                      PreCallMask := Mask;
                      
                      // -- Exhaling precondition
                        havoc ExhaleHeap;
                        // Phase 1: pure assertions and fixed permissions
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_10 != null might not hold. (AVLTree.sil,721:11) [11317]"}
                          this$_10 != null;
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_46 > none might not hold. (AVLTree.sil,721:11) [11318]"}
                          NoPerm[$frac] < newK$_46[$frac] || (NoPerm[$frac] == newK$_46[$frac] && NoPerm[$eps] < newK$_46[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_46 might not hold. (AVLTree.sil,721:11) [11319]"}
                          newK$_46[$frac] < FullPerm[$frac] || (newK$_46[$frac] == FullPerm[$frac] && newK$_46[$eps] < FullPerm[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,721:11) [11320]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodekey$ might be null. (AVLTree.sil,721:11) [11321]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodekey$. (AVLTree.sil,721:11) [11322]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodekey$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodekey$] := PermSub(Mask[this$_10, AVLTreeNodekey$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,721:11) [11323]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,721:11) [11324]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,721:11) [11325]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodeheight$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodeheight$] := PermSub(Mask[this$_10, AVLTreeNodeheight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,721:11) [11326]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,721:11) [11327]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,721:11) [11328]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodeleft$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodeleft$] := PermSub(Mask[this$_10, AVLTreeNodeleft$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,721:11) [11329]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,721:11) [11330]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,721:11) [11331]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNoderight$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNoderight$] := PermSub(Mask[this$_10, AVLTreeNoderight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,721:11) [11332]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,721:11) [11333]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,721:11) [11334]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodekeys$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodekeys$] := PermSub(Mask[this$_10, AVLTreeNodekeys$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,721:11) [11335]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,721:11) [11336]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodebalanceFactor$. (AVLTree.sil,721:11) [11337]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodebalanceFactor$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_10, AVLTreeNodebalanceFactor$], perm);
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          perm := NoPerm;
                          perm := PermAdd(perm, FullPerm);
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,721:11) [11338]"}
                              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                          }
                          Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,721:11) [11339]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,721:11) [11340]"}
                            Heap[this$_10, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,721:11) [11341]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,721:11) [11342]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,721:11) [11343]"}
                            Heap[this$_10, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,721:11) [11344]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,721:11) [11345]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,721:11) [11346]"}
                            Heap[this$_10, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,721:11) [11347]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_10.AVLTreeNodekey$)) might not hold. (AVLTree.sil,721:11) [11348]"}
                            (forall k0_3: int ::
                            
                            Seq#Contains(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_3) ==> k0_3 < Heap[this$_10, AVLTreeNodekey$]
                          );
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          perm := NoPerm;
                          perm := PermAdd(perm, FullPerm);
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,721:11) [11349]"}
                              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                          }
                          Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,721:11) [11350]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,721:11) [11351]"}
                            Heap[this$_10, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,721:11) [11352]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,721:11) [11353]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,721:11) [11354]"}
                            Heap[this$_10, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,721:11) [11355]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,721:11) [11356]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,721:11) [11357]"}
                            Heap[this$_10, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,721:11) [11358]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_10.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,721:11) [11359]"}
                            (forall k1_2: int ::
                            
                            Seq#Contains(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[this$_10, AVLTreeNodekey$] < k1_2
                          );
                        }
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_10.AVLTreeNodeleft$ == null ? 0 : this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_10.AVLTreeNoderight$ == null ? 0 : this$_10.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,721:11) [11360]"}
                          (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_10.AVLTreeNodeleft$ == null ? 0 : this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_10.AVLTreeNoderight$ == null ? 0 : this$_10.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,721:11) [11361]"}
                          (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                        // Phase 2: abstract read permissions (and scaled abstract read permissions)
                        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                        // Finish exhale
                        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                        Heap := ExhaleHeap;
                      
                      // -- Inhaling postcondition
                        perm := FullPerm;
                        Mask[null, AVLTreeNodevalid$(this$_10)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_10)], perm);
                        
                        // -- Extra unfolding of predicate
                          
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume this$_10 != null;
                        Mask[this$_10, AVLTreeNodeheight$] := PermAdd(Mask[this$_10, AVLTreeNodeheight$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume this$_10 != null;
                        Mask[this$_10, AVLTreeNodekeys$] := PermAdd(Mask[this$_10, AVLTreeNodekeys$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume this$_10 != null;
                        Mask[this$_10, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_10, AVLTreeNodebalanceFactor$], perm);
                        assume Seq#Equal(Heap[this$_10, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_10, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_10, AVLTreeNodekey$])), (if PreCallHeap[this$_10, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$])));
                        assume Heap[this$_10, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_10, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_10, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_10, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_10, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                        assume Heap[this$_10, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_10, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_10, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]);
                        assume state(Heap, Mask);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_46 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,721:11) [11362]"}
                        newK$_46[$eps] == 0.000000000;
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: r := this$_10 -- AVLTree.sil,723:9
                    r_1 := this$_10;
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: r := this$_10 -- AVLTree.sil,726:7
                r_1 := this$_10;
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_47  -- AVLTree.sil,727:7
                
                // -- Translation of statement fresh newK$_47)
                  havoc newK$_47;
                  assume (newK$_47[$frac] > 0.000000000 && newK$_47[$frac] < 0.001000000) && newK$_47[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_47) -- AVLTree.sil,728:7
                
                // -- Translating statement: AVLTreeNodeclose$(r, newK$_47) -- AVLTree.sil,729:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,729:9) [11363]"}
                      r_1 != null;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_47 > none might not hold. (AVLTree.sil,729:9) [11364]"}
                      NoPerm[$frac] < newK$_47[$frac] || (NoPerm[$frac] == newK$_47[$frac] && NoPerm[$eps] < newK$_47[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_47 might not hold. (AVLTree.sil,729:9) [11365]"}
                      newK$_47[$frac] < FullPerm[$frac] || (newK$_47[$frac] == FullPerm[$frac] && newK$_47[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,729:9) [11366]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,729:9) [11367]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,729:9) [11368]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,729:9) [11369]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,729:9) [11370]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,729:9) [11371]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,729:9) [11372]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,729:9) [11373]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,729:9) [11374]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,729:9) [11375]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,729:9) [11376]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,729:9) [11377]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,729:9) [11378]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,729:9) [11379]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,729:9) [11380]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,729:9) [11381]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,729:9) [11382]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,729:9) [11383]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,729:9) [11384]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,729:9) [11385]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,729:9) [11386]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,729:9) [11387]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,729:9) [11388]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,729:9) [11389]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,729:9) [11390]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,729:9) [11391]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,729:9) [11392]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,729:9) [11393]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,729:9) [11394]"}
                        (forall k0_4: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_4) ==> k0_4 < Heap[r_1, AVLTreeNodekey$]
                      );
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,729:9) [11395]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,729:9) [11396]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,729:9) [11397]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,729:9) [11398]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,729:9) [11399]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,729:9) [11400]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,729:9) [11401]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,729:9) [11402]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,729:9) [11403]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,729:9) [11404]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,729:9) [11405]"}
                        (forall k1_3: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[r_1, AVLTreeNodekey$] < k1_3
                      );
                    }
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,729:9) [11406]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,729:9) [11407]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
                    assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                    assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_47 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,729:9) [11408]"}
                    newK$_47[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: if (this$_10.AVLTreeNoderight$ != null) -- AVLTree.sil,732:5
            
            // -- Check definedness of this$_10.AVLTreeNoderight$ != null
              assert {:msg "  Conditional statement might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,732:12) [11409]"}
                this$_10 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,732:12) [11410]"}
                HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
              assume state(Heap, Mask);
            if (Heap[this$_10, AVLTreeNoderight$] != null) {
              
              // -- Translating statement: fresh newK$_48  -- AVLTree.sil,733:5
                
                // -- Translation of statement fresh newK$_48)
                  havoc newK$_48;
                  assume (newK$_48[$frac] > 0.000000000 && newK$_48[$frac] < 0.001000000) && newK$_48[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_48) -- AVLTree.sil,734:5
                
                // -- Translating statement: nr := AVLTreeNoderemove$(this$_10.AVLTreeNoderight$, newK$_48, k) -- AVLTree.sil,735:7
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_10.AVLTreeNoderight$
                    assert {:msg "  Method call might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,735:7) [11411]"}
                      this$_10 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,735:7) [11412]"}
                      HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
                    assume state(Heap, Mask);
                  arg_this$_10_1 := Heap[this$_10, AVLTreeNoderight$];
                  havoc nr;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion this$_10.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,735:7) [11413]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion newK$_48 > none might not hold. (AVLTree.sil,735:7) [11414]"}
                      NoPerm[$frac] < newK$_48[$frac] || (NoPerm[$frac] == newK$_48[$frac] && NoPerm[$eps] < newK$_48[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Assertion write > newK$_48 might not hold. (AVLTree.sil,735:7) [11415]"}
                      newK$_48[$frac] < FullPerm[$frac] || (newK$_48[$frac] == FullPerm[$frac] && newK$_48[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,735:7) [11416]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,735:7) [11417]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,735:7) [11418]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,735:7) [11419]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,735:7) [11420]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,735:7) [11421]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,735:7) [11422]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,735:7) [11423]"}
                      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,735:7) [11424]"}
                      Heap[this$_10, AVLTreeNoderight$] != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,735:7) [11425]"}
                        (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    if (Seq#Equal(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], Seq#Singleton(k))) {
                      assume nr == null;
                    }
                    if (!Seq#Equal(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], Seq#Singleton(k))) {
                      assume nr != null;
                    }
                    if (nr != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(nr)] := PermAdd(Mask[null, AVLTreeNodevalid$(nr)], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (nr != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nr != null;
                      Mask[nr, AVLTreeNodekeys$] := PermAdd(Mask[nr, AVLTreeNodekeys$], perm);
                    }
                    if (nr != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nr != null;
                      Mask[nr, AVLTreeNodeheight$] := PermAdd(Mask[nr, AVLTreeNodeheight$], perm);
                    }
                    if (nr != null) {
                      perm := Perm(0.500000000, 0.000000000);
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume nr != null;
                      Mask[nr, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nr, AVLTreeNodebalanceFactor$], perm);
                    }
                    if (nr != null) {
                      assume !Seq#Contains(Heap[nr, AVLTreeNodekeys$], k);
                    }
                    if (nr != null) {
                      assume (forall i_8: int ::
                        
                        Seq#Contains(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], i_8) ==> Seq#Contains(Heap[nr, AVLTreeNodekeys$], i_8) || i_8 == k
                      );
                    }
                    if (nr != null) {
                      assume (forall i_9: int ::
                        
                        Seq#Contains(Heap[nr, AVLTreeNodekeys$], i_9) ==> Seq#Contains(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], i_9) && i_9 != k
                      );
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], k)) {
                      assume nr != null;
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], k)) {
                      assume Seq#Equal(Heap[nr, AVLTreeNodekeys$], PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$]);
                    }
                    if (nr != null) {
                      if (Seq#Contains(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], k)) {
                        assume Seq#Length(Heap[nr, AVLTreeNodekeys$]) == Seq#Length(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$]) - 1;
                      }
                    }
                    if (PreCallHeap[arg_this$_10_1, AVLTreeNodeheight$] > 1) {
                      assume nr != null;
                    }
                    if (nr != null) {
                      assume Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_10_1, AVLTreeNodeheight$] || Heap[nr, AVLTreeNodeheight$] + 1 == PreCallHeap[arg_this$_10_1, AVLTreeNodeheight$];
                    }
                    if (!Seq#Contains(PreCallHeap[arg_this$_10_1, AVLTreeNodekeys$], k)) {
                      assume Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_10_1, AVLTreeNodeheight$];
                    }
                    assume state(Heap, Mask);
                  assume nr == null || Heap[nr, $allocated];
                  assert {:msg "  The precondition of method AVLTreeNoderemove$ might not hold. The parameter newK$_48 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,735:7) [11426]"}
                    newK$_48[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: this$_10.AVLTreeNoderight$ := nr -- AVLTree.sil,737:5
                
                // -- Check definedness of this$_10.AVLTreeNoderight$
                  assert {:msg "  Assignment might fail. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,737:5) [11427]"}
                    this$_10 != null;
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,737:5) [11428]"}
                    HasDirectPerm(Mask, this$_10, AVLTreeNoderight$);
                  assume state(Heap, Mask);
                Heap[this$_10, AVLTreeNoderight$] := nr;
                assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,737:5) [11429]"}
                  FullPerm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_10, AVLTreeNoderight$][$eps];
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_49  -- AVLTree.sil,738:5
                
                // -- Translation of statement fresh newK$_49)
                  havoc newK$_49;
                  assume (newK$_49[$frac] > 0.000000000 && newK$_49[$frac] < 0.001000000) && newK$_49[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_49) -- AVLTree.sil,739:5
                
                // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_10, newK$_49) -- AVLTree.sil,740:7
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  havoc bf;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_10 != null might not hold. (AVLTree.sil,740:7) [11430]"}
                      this$_10 != null;
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_49 > none might not hold. (AVLTree.sil,740:7) [11431]"}
                      NoPerm[$frac] < newK$_49[$frac] || (NoPerm[$frac] == newK$_49[$frac] && NoPerm[$eps] < newK$_49[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_49 might not hold. (AVLTree.sil,740:7) [11432]"}
                      newK$_49[$frac] < FullPerm[$frac] || (newK$_49[$frac] == FullPerm[$frac] && newK$_49[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_49 might not be positive. (AVLTree.sil,740:7) [11433]"}
                      newK$_49[$frac] > 0.000000000 || (newK$_49[$frac] == 0.000000000 && newK$_49[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,740:7) [11434]"}
                      this$_10 != null;
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,740:7) [11435]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_49 might not be positive. (AVLTree.sil,740:7) [11436]"}
                        newK$_49[$frac] > 0.000000000 || (newK$_49[$frac] == 0.000000000 && newK$_49[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,740:7) [11437]"}
                        Heap[this$_10, AVLTreeNodeleft$] != null;
                    }
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_49 might not be positive. (AVLTree.sil,740:7) [11438]"}
                      newK$_49[$frac] > 0.000000000 || (newK$_49[$frac] == 0.000000000 && newK$_49[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,740:7) [11439]"}
                      this$_10 != null;
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,740:7) [11440]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_49 might not be positive. (AVLTree.sil,740:7) [11441]"}
                        newK$_49[$frac] > 0.000000000 || (newK$_49[$frac] == 0.000000000 && newK$_49[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,740:7) [11442]"}
                        Heap[this$_10, AVLTreeNoderight$] != null;
                    }
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    perm := NoPerm;
                    perm := PermAdd(perm, newK$_49);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,740:7) [11443]"}
                        Mask[this$_10, AVLTreeNodeleft$][$frac] > 0.000000000;
                      assume perm[$frac] < Mask[this$_10, AVLTreeNodeleft$][$frac];
                    }
                    Mask[this$_10, AVLTreeNodeleft$] := PermSub(Mask[this$_10, AVLTreeNodeleft$], perm);
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, newK$_49);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,740:7) [11444]"}
                          Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                        assume perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
                      }
                      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    perm := NoPerm;
                    perm := PermAdd(perm, newK$_49);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,740:7) [11445]"}
                        Mask[this$_10, AVLTreeNoderight$][$frac] > 0.000000000;
                      assume perm[$frac] < Mask[this$_10, AVLTreeNoderight$][$frac];
                    }
                    Mask[this$_10, AVLTreeNoderight$] := PermSub(Mask[this$_10, AVLTreeNoderight$], perm);
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, newK$_49);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,740:7) [11446]"}
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                        assume perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
                      }
                      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := newK$_49;
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume this$_10 != null;
                    Mask[this$_10, AVLTreeNodeleft$] := PermAdd(Mask[this$_10, AVLTreeNodeleft$], perm);
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (Heap[this$_10, AVLTreeNodeleft$] != null) {
                      perm := newK$_49;
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume Heap[this$_10, AVLTreeNodeleft$] != null;
                      Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    perm := newK$_49;
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume this$_10 != null;
                    Mask[this$_10, AVLTreeNoderight$] := PermAdd(Mask[this$_10, AVLTreeNoderight$], perm);
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := FullPerm;
                      Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                      
                      // -- Extra unfolding of predicate
                        
                    }
                    if (Heap[this$_10, AVLTreeNoderight$] != null) {
                      perm := newK$_49;
                      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                      assume Heap[this$_10, AVLTreeNoderight$] != null;
                      Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    assume bf == (if Heap[this$_10, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]);
                    if (bf > 0) {
                      assume Heap[this$_10, AVLTreeNodeleft$] != null;
                    }
                    if (bf < 0) {
                      assume Heap[this$_10, AVLTreeNoderight$] != null;
                    }
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_49 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,740:7) [11447]"}
                    newK$_49[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: if (bf == 2) -- AVLTree.sil,742:5
                if (bf == 2) {
                  
                  // -- Translating statement: fresh newK$_50  -- AVLTree.sil,743:7
                    
                    // -- Translation of statement fresh newK$_50)
                      havoc newK$_50;
                      assume (newK$_50[$frac] > 0.000000000 && newK$_50[$frac] < 0.001000000) && newK$_50[$eps] == 0.000000000;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: constraining(newK$_50) -- AVLTree.sil,744:7
                    
                    // -- Translating statement: r := AVLTreeNoderebalanceLeft$(this$_10, newK$_50) -- AVLTree.sil,745:9
                      PreCallHeap := Heap;
                      PreCallMask := Mask;
                      havoc r_1;
                      
                      // -- Exhaling precondition
                        havoc ExhaleHeap;
                        // Phase 1: pure assertions and fixed permissions
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_10 != null might not hold. (AVLTree.sil,745:9) [11448]"}
                          this$_10 != null;
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion newK$_50 > none might not hold. (AVLTree.sil,745:9) [11449]"}
                          NoPerm[$frac] < newK$_50[$frac] || (NoPerm[$frac] == newK$_50[$frac] && NoPerm[$eps] < newK$_50[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion write > newK$_50 might not hold. (AVLTree.sil,745:9) [11450]"}
                          newK$_50[$frac] < FullPerm[$frac] || (newK$_50[$frac] == FullPerm[$frac] && newK$_50[$eps] < FullPerm[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,745:9) [11451]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodekey$ might be null. (AVLTree.sil,745:9) [11452]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodekey$. (AVLTree.sil,745:9) [11453]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodekey$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodekey$] := PermSub(Mask[this$_10, AVLTreeNodekey$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,745:9) [11454]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodeheight$ might be null. (AVLTree.sil,745:9) [11455]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeheight$. (AVLTree.sil,745:9) [11456]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodeheight$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodeheight$] := PermSub(Mask[this$_10, AVLTreeNodeheight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,745:9) [11457]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodeleft$ might be null. (AVLTree.sil,745:9) [11458]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$. (AVLTree.sil,745:9) [11459]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodeleft$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodeleft$] := PermSub(Mask[this$_10, AVLTreeNodeleft$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,745:9) [11460]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNoderight$ might be null. (AVLTree.sil,745:9) [11461]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$. (AVLTree.sil,745:9) [11462]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNoderight$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNoderight$] := PermSub(Mask[this$_10, AVLTreeNoderight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,745:9) [11463]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodekeys$ might be null. (AVLTree.sil,745:9) [11464]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodekeys$. (AVLTree.sil,745:9) [11465]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodekeys$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodekeys$] := PermSub(Mask[this$_10, AVLTreeNodekeys$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,745:9) [11466]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,745:9) [11467]"}
                          this$_10 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodebalanceFactor$. (AVLTree.sil,745:9) [11468]"}
                            (perm[$frac] < Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_10, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_10, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_10, AVLTreeNodebalanceFactor$][$eps]);
                        }
                        Mask[this$_10, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_10, AVLTreeNodebalanceFactor$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_10.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,745:9) [11469]"}
                          Heap[this$_10, AVLTreeNodeleft$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, FullPerm);
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNodeleft$). (AVLTree.sil,745:9) [11470]"}
                            (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])][$eps]);
                        }
                        Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNodeleft$])], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,745:9) [11471]"}
                          Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,745:9) [11472]"}
                          Heap[this$_10, AVLTreeNodeleft$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,745:9) [11473]"}
                            (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                        }
                        Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,745:9) [11474]"}
                          Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,745:9) [11475]"}
                          Heap[this$_10, AVLTreeNodeleft$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,745:9) [11476]"}
                            (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                        }
                        Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,745:9) [11477]"}
                          Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,745:9) [11478]"}
                          Heap[this$_10, AVLTreeNodeleft$] != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,745:9) [11479]"}
                            (perm[$frac] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                        }
                        Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_10.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_10.AVLTreeNodekey$)) might not hold. (AVLTree.sil,745:9) [11480]"}
                          (forall k0_5: int ::
                          
                          Seq#Contains(Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_5) ==> k0_5 < Heap[this$_10, AVLTreeNodekey$]
                        );
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          perm := NoPerm;
                          perm := PermAdd(perm, FullPerm);
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_10.AVLTreeNoderight$). (AVLTree.sil,745:9) [11481]"}
                              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])][$eps]);
                          }
                          Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_10, AVLTreeNoderight$])], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,745:9) [11482]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,745:9) [11483]"}
                            Heap[this$_10, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,745:9) [11484]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,745:9) [11485]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,745:9) [11486]"}
                            Heap[this$_10, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,745:9) [11487]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,745:9) [11488]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,745:9) [11489]"}
                            Heap[this$_10, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_10.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,745:9) [11490]"}
                              (perm[$frac] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                          }
                          Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                        }
                        if (Heap[this$_10, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_10.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_10.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,745:9) [11491]"}
                            (forall k1_4: int ::
                            
                            Seq#Contains(Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$], k1_4) ==> Heap[this$_10, AVLTreeNodekey$] < k1_4
                          );
                        }
                        assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_10.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_10.AVLTreeNoderight$ == null ? 0 : this$_10.AVLTreeNoderight$.AVLTreeNodeheight$) == 2 might not hold. (AVLTree.sil,745:9) [11492]"}
                          Heap[Heap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_10, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_10, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
                        // Phase 2: abstract read permissions (and scaled abstract read permissions)
                        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                        // Finish exhale
                        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                        Heap := ExhaleHeap;
                      
                      // -- Inhaling postcondition
                        assume r_1 != null;
                        perm := FullPerm;
                        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                        
                        // -- Extra unfolding of predicate
                          
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                        assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
                        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(PreCallHeap[PreCallHeap[this$_10, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(PreCallHeap[this$_10, AVLTreeNodekey$])), (if PreCallHeap[this$_10, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_10, AVLTreeNoderight$], AVLTreeNodekeys$])));
                        assume state(Heap, Mask);
                      assume r_1 == null || Heap[r_1, $allocated];
                      assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. The parameter newK$_50 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,745:9) [11493]"}
                        newK$_50[$eps] == 0.000000000;
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: r := this$_10 -- AVLTree.sil,748:7
                    r_1 := this$_10;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fresh newK$_51  -- AVLTree.sil,749:7
                    
                    // -- Translation of statement fresh newK$_51)
                      havoc newK$_51;
                      assume (newK$_51[$frac] > 0.000000000 && newK$_51[$frac] < 0.001000000) && newK$_51[$eps] == 0.000000000;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: constraining(newK$_51) -- AVLTree.sil,750:7
                    
                    // -- Translating statement: AVLTreeNodeclose$(r, newK$_51) -- AVLTree.sil,751:9
                      PreCallHeap := Heap;
                      PreCallMask := Mask;
                      
                      // -- Exhaling precondition
                        havoc ExhaleHeap;
                        // Phase 1: pure assertions and fixed permissions
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,751:9) [11494]"}
                          r_1 != null;
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_51 > none might not hold. (AVLTree.sil,751:9) [11495]"}
                          NoPerm[$frac] < newK$_51[$frac] || (NoPerm[$frac] == newK$_51[$frac] && NoPerm[$eps] < newK$_51[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_51 might not hold. (AVLTree.sil,751:9) [11496]"}
                          newK$_51[$frac] < FullPerm[$frac] || (newK$_51[$frac] == FullPerm[$frac] && newK$_51[$eps] < FullPerm[$eps]);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,751:9) [11497]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,751:9) [11498]"}
                          r_1 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,751:9) [11499]"}
                            (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
                        }
                        Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,751:9) [11500]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,751:9) [11501]"}
                          r_1 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,751:9) [11502]"}
                            (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
                        }
                        Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,751:9) [11503]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,751:9) [11504]"}
                          r_1 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,751:9) [11505]"}
                            (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
                        }
                        Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,751:9) [11506]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,751:9) [11507]"}
                          r_1 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,751:9) [11508]"}
                            (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
                        }
                        Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,751:9) [11509]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,751:9) [11510]"}
                          r_1 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,751:9) [11511]"}
                            (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
                        }
                        Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,751:9) [11512]"}
                          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,751:9) [11513]"}
                          r_1 != null;
                        perm := NoPerm;
                        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,751:9) [11514]"}
                            (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
                        }
                        Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                        if (Heap[r_1, AVLTreeNodeleft$] != null) {
                          perm := NoPerm;
                          perm := PermAdd(perm, FullPerm);
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,751:9) [11515]"}
                              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
                          }
                          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
                        }
                        if (Heap[r_1, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,751:9) [11516]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,751:9) [11517]"}
                            Heap[r_1, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,751:9) [11518]"}
                              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                          }
                          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                        }
                        if (Heap[r_1, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,751:9) [11519]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,751:9) [11520]"}
                            Heap[r_1, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,751:9) [11521]"}
                              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                          }
                          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                        }
                        if (Heap[r_1, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,751:9) [11522]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,751:9) [11523]"}
                            Heap[r_1, AVLTreeNodeleft$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,751:9) [11524]"}
                              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                          }
                          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                        }
                        if (Heap[r_1, AVLTreeNodeleft$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,751:9) [11525]"}
                            (forall k0_6: int ::
                            
                            Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_6) ==> k0_6 < Heap[r_1, AVLTreeNodekey$]
                          );
                        }
                        if (Heap[r_1, AVLTreeNoderight$] != null) {
                          perm := NoPerm;
                          perm := PermAdd(perm, FullPerm);
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,751:9) [11526]"}
                              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
                          }
                          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
                        }
                        if (Heap[r_1, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,751:9) [11527]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,751:9) [11528]"}
                            Heap[r_1, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,751:9) [11529]"}
                              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                          }
                          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                        }
                        if (Heap[r_1, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,751:9) [11530]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,751:9) [11531]"}
                            Heap[r_1, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,751:9) [11532]"}
                              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                          }
                          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                        }
                        if (Heap[r_1, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,751:9) [11533]"}
                            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,751:9) [11534]"}
                            Heap[r_1, AVLTreeNoderight$] != null;
                          perm := NoPerm;
                          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,751:9) [11535]"}
                              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                          }
                          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                        }
                        if (Heap[r_1, AVLTreeNoderight$] != null) {
                          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,751:9) [11536]"}
                            (forall k1_5: int ::
                            
                            Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_5) ==> Heap[r_1, AVLTreeNodekey$] < k1_5
                          );
                        }
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,751:9) [11537]"}
                          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,751:9) [11538]"}
                          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                        // Phase 2: abstract read permissions (and scaled abstract read permissions)
                        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                        // Finish exhale
                        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                        Heap := ExhaleHeap;
                      
                      // -- Inhaling postcondition
                        perm := FullPerm;
                        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                        
                        // -- Extra unfolding of predicate
                          
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                        perm := Perm(0.500000000, 0.000000000);
                        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                        assume r_1 != null;
                        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
                        assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                        assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
                        assume state(Heap, Mask);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_51 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,751:9) [11539]"}
                        newK$_51[$eps] == 0.000000000;
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: r := this$_10 -- AVLTree.sil,755:5
                r_1 := this$_10;
                assume state(Heap, Mask);
              
              // -- Translating statement: fresh newK$_52  -- AVLTree.sil,756:5
                
                // -- Translation of statement fresh newK$_52)
                  havoc newK$_52;
                  assume (newK$_52[$frac] > 0.000000000 && newK$_52[$frac] < 0.001000000) && newK$_52[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_52) -- AVLTree.sil,757:5
                
                // -- Translating statement: AVLTreeNodeclose$(r, newK$_52) -- AVLTree.sil,758:7
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,758:7) [11540]"}
                      r_1 != null;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_52 > none might not hold. (AVLTree.sil,758:7) [11541]"}
                      NoPerm[$frac] < newK$_52[$frac] || (NoPerm[$frac] == newK$_52[$frac] && NoPerm[$eps] < newK$_52[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_52 might not hold. (AVLTree.sil,758:7) [11542]"}
                      newK$_52[$frac] < FullPerm[$frac] || (newK$_52[$frac] == FullPerm[$frac] && newK$_52[$eps] < FullPerm[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,758:7) [11543]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,758:7) [11544]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,758:7) [11545]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,758:7) [11546]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,758:7) [11547]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,758:7) [11548]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,758:7) [11549]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,758:7) [11550]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,758:7) [11551]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,758:7) [11552]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,758:7) [11553]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,758:7) [11554]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
                    }
                    Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,758:7) [11555]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,758:7) [11556]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,758:7) [11557]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,758:7) [11558]"}
                      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,758:7) [11559]"}
                      r_1 != null;
                    perm := NoPerm;
                    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,758:7) [11560]"}
                        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
                    }
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,758:7) [11561]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,758:7) [11562]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,758:7) [11563]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,758:7) [11564]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,758:7) [11565]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,758:7) [11566]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,758:7) [11567]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,758:7) [11568]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,758:7) [11569]"}
                        Heap[r_1, AVLTreeNodeleft$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,758:7) [11570]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNodeleft$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,758:7) [11571]"}
                        (forall k0_7: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_7) ==> k0_7 < Heap[r_1, AVLTreeNodekey$]
                      );
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      perm := NoPerm;
                      perm := PermAdd(perm, FullPerm);
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,758:7) [11572]"}
                          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
                      }
                      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,758:7) [11573]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,758:7) [11574]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,758:7) [11575]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,758:7) [11576]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,758:7) [11577]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,758:7) [11578]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,758:7) [11579]"}
                        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,758:7) [11580]"}
                        Heap[r_1, AVLTreeNoderight$] != null;
                      perm := NoPerm;
                      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,758:7) [11581]"}
                          (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                      }
                      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                    }
                    if (Heap[r_1, AVLTreeNoderight$] != null) {
                      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,758:7) [11582]"}
                        (forall k1_6: int ::
                        
                        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_6) ==> Heap[r_1, AVLTreeNodekey$] < k1_6
                      );
                    }
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,758:7) [11583]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,758:7) [11584]"}
                      (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                    perm := Perm(0.500000000, 0.000000000);
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume r_1 != null;
                    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
                    assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                    assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_52 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,758:7) [11585]"}
                    newK$_52[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    if (Seq#Equal(old(Heap)[this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion r == null might not hold. (AVLTree.sil,629:11) [11586]"}
        r_1 == null;
    }
    if (!Seq#Equal(old(Heap)[this$_10, AVLTreeNodekeys$], Seq#Singleton(k))) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion r != null might not hold. (AVLTree.sil,630:11) [11587]"}
        r_1 != null;
    }
    if (r_1 != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,631:11) [11588]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,632:11) [11589]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,632:11) [11590]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,632:11) [11591]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
      }
      Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,633:11) [11592]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,633:11) [11593]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,633:11) [11594]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
      }
      Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,634:11) [11595]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,634:11) [11596]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,634:11) [11597]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion !k in r.AVLTreeNodekeys$ might not hold. (AVLTree.sil,635:11) [11598]"}
        !Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion (forall i: Int :: true && i in old(this$_10.AVLTreeNodekeys$) ==> i in r.AVLTreeNodekeys$ || (i == k)) might not hold. (AVLTree.sil,636:11) [11599]"}
        (forall i_4: int ::
        
        Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], i_4) ==> Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_4) || i_4 == k
      );
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion (forall i: Int :: true && i in r.AVLTreeNodekeys$ ==> i in old(this$_10.AVLTreeNodekeys$) && (i != k)) might not hold. (AVLTree.sil,637:11) [11600]"}
        (forall i_5: int ::
        
        Seq#Contains(Heap[r_1, AVLTreeNodekeys$], i_5) ==> Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], i_5) && i_5 != k
      );
    }
    if (!Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion r != null might not hold. (AVLTree.sil,638:11) [11601]"}
        r_1 != null;
    }
    if (!Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion r.AVLTreeNodekeys$ == old(this$_10.AVLTreeNodekeys$) might not hold. (AVLTree.sil,639:11) [11602]"}
        Seq#Equal(Heap[r_1, AVLTreeNodekeys$], old(Heap)[this$_10, AVLTreeNodekeys$]);
    }
    if (r_1 != null) {
      if (Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
        assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion |r.AVLTreeNodekeys$| == |old(this$_10.AVLTreeNodekeys$)| - 1 might not hold. (AVLTree.sil,640:11) [11603]"}
          Seq#Length(Heap[r_1, AVLTreeNodekeys$]) == Seq#Length(old(Heap)[this$_10, AVLTreeNodekeys$]) - 1;
      }
    }
    if (old(Heap)[this$_10, AVLTreeNodeheight$] > 1) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion r != null might not hold. (AVLTree.sil,641:11) [11604]"}
        r_1 != null;
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_10.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ + 1 == old(this$_10.AVLTreeNodeheight$)) might not hold. (AVLTree.sil,642:11) [11605]"}
        Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_10, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] + 1 == old(Heap)[this$_10, AVLTreeNodeheight$];
    }
    if (!Seq#Contains(old(Heap)[this$_10, AVLTreeNodekeys$], k)) {
      assert {:msg "  Postcondition of AVLTreeNoderemove$ might not hold. Assertion r.AVLTreeNodeheight$ == old(this$_10.AVLTreeNodeheight$) might not hold. (AVLTree.sil,643:11) [11606]"}
        Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_10, AVLTreeNodeheight$];
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodepruneMax$
// ==================================================

procedure AVLTreeNodepruneMax$(this$_11: Ref, k$_7: Perm) returns (r_1: Ref, m: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k0_8: int;
  var oldVersion: int;
  var newVersion: int;
  var newK$_30: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var k1_7: int;
  var newK$_31: Perm;
  var arg_this$_11: Ref;
  var nr: Ref;
  var newK$_32: Perm;
  var bf: int;
  var newK$_33: Perm;
  var newK$_34: Perm;
  var k2: int;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_11 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_7[$frac] || (NoPerm[$frac] == k$_7[$frac] && NoPerm[$eps] < k$_7[$eps]);
    assume state(Heap, Mask);
    assume k$_7[$frac] < FullPerm[$frac] || (k$_7[$frac] == FullPerm[$frac] && k$_7[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_11)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_11)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodekeys$] := PermAdd(Mask[this$_11, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodeheight$] := PermAdd(Mask[this$_11, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    if (r_1 != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_11.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ + 1 == old(this$_11.AVLTreeNodeheight$))
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,775:11) [11607]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,775:11) [11608]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,775:11) [11609]"}
          this$_11 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,775:11) [11610]"}
          HasDirectPerm(old(Mask), this$_11, AVLTreeNodeheight$);
        if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_11, AVLTreeNodeheight$])) {
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,775:11) [11611]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,775:11) [11612]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
          assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,775:11) [11613]"}
            this$_11 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,775:11) [11614]"}
            HasDirectPerm(old(Mask), this$_11, AVLTreeNodeheight$);
        }
        assume state(Heap, Mask);
      assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_11, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] + 1 == old(Heap)[this$_11, AVLTreeNodeheight$];
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of |r.AVLTreeNodekeys$| + 1 == |old(this$_11.AVLTreeNodekeys$)|
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,776:11) [11615]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,776:11) [11616]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodekeys$ might be null. (AVLTree.sil,776:11) [11617]"}
          this$_11 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodekeys$. (AVLTree.sil,776:11) [11618]"}
          HasDirectPerm(old(Mask), this$_11, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) + 1 == Seq#Length(old(Heap)[this$_11, AVLTreeNodekeys$]);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of old(this$_11.AVLTreeNodeheight$) > 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,777:11) [11619]"}
        this$_11 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,777:11) [11620]"}
        HasDirectPerm(old(Mask), this$_11, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    if (old(Heap)[this$_11, AVLTreeNodeheight$] > 1) {
      assume r_1 != null;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of old(this$_11.AVLTreeNodeheight$) == 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,778:11) [11621]"}
        this$_11 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,778:11) [11622]"}
        HasDirectPerm(old(Mask), this$_11, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    if (old(Heap)[this$_11, AVLTreeNodeheight$] == 1) {
      assume r_1 == null;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of (old(this$_11.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$)) || (old(this$_11.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,779:11) [11623]"}
        this$_11 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,779:11) [11624]"}
        HasDirectPerm(old(Mask), this$_11, AVLTreeNodeheight$);
      if (r_1 == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,779:11) [11625]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,779:11) [11626]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      }
      if (!(old(Heap)[this$_11, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]))) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,779:11) [11627]"}
          this$_11 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,779:11) [11628]"}
          HasDirectPerm(old(Mask), this$_11, AVLTreeNodeheight$);
        if (r_1 == null) {
        } else {
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,779:11) [11629]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,779:11) [11630]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        }
      }
      assume state(Heap, Mask);
    assume old(Heap)[this$_11, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) || old(Heap)[this$_11, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) + 1;
    assume state(Heap, Mask);
    assume m != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(m)] := PermAdd(Mask[null, AVLTreeNodevalid$(m)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume m != null;
    Mask[m, AVLTreeNodekeys$] := PermAdd(Mask[m, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume m != null;
    Mask[m, AVLTreeNodeheight$] := PermAdd(Mask[m, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume m != null;
    Mask[m, AVLTreeNodebalanceFactor$] := PermAdd(Mask[m, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of m.AVLTreeNodeheight$ == 1
      assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodeheight$ might be null. (AVLTree.sil,785:11) [11631]"}
        m != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodeheight$. (AVLTree.sil,785:11) [11632]"}
        HasDirectPerm(Mask, m, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    assume Heap[m, AVLTreeNodeheight$] == 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of |m.AVLTreeNodekeys$| == 1
      assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,786:11) [11633]"}
        m != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,786:11) [11634]"}
        HasDirectPerm(Mask, m, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Length(Heap[m, AVLTreeNodekeys$]) == 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of (r == null ? Seq() : r.AVLTreeNodekeys$) ++ m.AVLTreeNodekeys$ == old(this$_11.AVLTreeNodekeys$)
      if (r_1 == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,787:11) [11635]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,787:11) [11636]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,787:11) [11637]"}
        m != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,787:11) [11638]"}
        HasDirectPerm(Mask, m, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_11.AVLTreeNodekeys$ might be null. (AVLTree.sil,787:11) [11639]"}
        this$_11 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_11.AVLTreeNodekeys$. (AVLTree.sil,787:11) [11640]"}
        HasDirectPerm(old(Mask), this$_11, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Equal(Seq#Append((if r_1 == null then (Seq#Empty(): Seq_ int) else Heap[r_1, AVLTreeNodekeys$]), Heap[m, AVLTreeNodekeys$]), old(Heap)[this$_11, AVLTreeNodekeys$]);
    assume state(Heap, Mask);
    if (r_1 != null) {
      
      // -- Check definedness of (forall k0: Int :: true && k0 in r.AVLTreeNodekeys$ ==> (k0 < m.AVLTreeNodekeys$[0]))
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,788:11) [11641]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,788:11) [11642]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k0_8)) {
          assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,788:11) [11643]"}
            m != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,788:11) [11644]"}
            HasDirectPerm(Mask, m, AVLTreeNodekeys$);
        }
        assume state(Heap, Mask);
      assume (forall k0_1: int ::
        
        Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k0_1) ==> k0_1 < Seq#Index(Heap[m, AVLTreeNodekeys$], 0)
      );
      assume state(Heap, Mask);
    }
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_11 == null || Heap[this$_11, $allocated];
    assume k$_7[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_11), write) -- AVLTree.sil,801:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_11));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_11) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_11). (AVLTree.sil,801:3) [11647]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_11)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_11)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_11)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_11)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_11)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_11)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_11)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(this$_11))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(this$_11)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(this$_11)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodekey$] := PermAdd(Mask[this$_11, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodeheight$] := PermAdd(Mask[this$_11, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodeleft$] := PermAdd(Mask[this$_11, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNoderight$] := PermAdd(Mask[this$_11, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodekeys$] := PermAdd(Mask[this$_11, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_11 != null;
    Mask[this$_11, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_11, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_11, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_11)], Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_11, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_11, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_11, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_11, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_11, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_11, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_11, AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[this$_11, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_11, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_11, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_11, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_11)], Heap[this$_11, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])]);
    }
    if (Heap[this$_11, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_11, AVLTreeNoderight$] != null;
      Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_11, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_11, AVLTreeNoderight$] != null;
      Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_11, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_11, AVLTreeNoderight$] != null;
      Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_11, AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[this$_11, AVLTreeNodekey$] < rk
      );
    }
    if (Heap[this$_11, AVLTreeNoderight$] != null) {
      assume Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[this$_11, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_11, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_11, AVLTreeNodekey$])), (if Heap[this$_11, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[this$_11, AVLTreeNodekeys$], Heap[this$_11, AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[this$_11, AVLTreeNodekeys$], kk) == ((Heap[this$_11, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[this$_11, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[this$_11, AVLTreeNodekey$]))
    );
    assume Heap[this$_11, AVLTreeNodeheight$] == (if (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[this$_11, AVLTreeNodebalanceFactor$] == (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[this$_11, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[this$_11, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[this$_11, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_11.AVLTreeNoderight$ == null) -- AVLTree.sil,802:3
    
    // -- Check definedness of this$_11.AVLTreeNoderight$ == null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,802:7) [11648]"}
        HasDirectPerm(Mask, this$_11, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_11, AVLTreeNoderight$] == null) {
      
      // -- Translating statement: r := this$_11.AVLTreeNodeleft$ -- AVLTree.sil,803:5
        
        // -- Check definedness of this$_11.AVLTreeNodeleft$
          assert {:msg "  Assignment might fail. Receiver of this$_11.AVLTreeNodeleft$ might be null. (AVLTree.sil,803:5) [11649]"}
            this$_11 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,803:5) [11650]"}
            HasDirectPerm(Mask, this$_11, AVLTreeNodeleft$);
          assume state(Heap, Mask);
        r_1 := Heap[this$_11, AVLTreeNodeleft$];
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_11.AVLTreeNodeleft$ := null -- AVLTree.sil,804:5
        
        // -- Check definedness of this$_11.AVLTreeNodeleft$
          assert {:msg "  Assignment might fail. Receiver of this$_11.AVLTreeNodeleft$ might be null. (AVLTree.sil,804:5) [11651]"}
            this$_11 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,804:5) [11652]"}
            HasDirectPerm(Mask, this$_11, AVLTreeNodeleft$);
          assume state(Heap, Mask);
        Heap[this$_11, AVLTreeNodeleft$] := null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,804:5) [11653]"}
          FullPerm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_11, AVLTreeNodeleft$][$eps];
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_30  -- AVLTree.sil,805:5
        
        // -- Translation of statement fresh newK$_30)
          havoc newK$_30;
          assume (newK$_30[$frac] > 0.000000000 && newK$_30[$frac] < 0.001000000) && newK$_30[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_30) -- AVLTree.sil,806:5
        
        // -- Translating statement: AVLTreeNodeclose$(this$_11, newK$_30) -- AVLTree.sil,807:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_11 != null might not hold. (AVLTree.sil,807:7) [11654]"}
              this$_11 != null;
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_30 > none might not hold. (AVLTree.sil,807:7) [11655]"}
              NoPerm[$frac] < newK$_30[$frac] || (NoPerm[$frac] == newK$_30[$frac] && NoPerm[$eps] < newK$_30[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_30 might not hold. (AVLTree.sil,807:7) [11656]"}
              newK$_30[$frac] < FullPerm[$frac] || (newK$_30[$frac] == FullPerm[$frac] && newK$_30[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,807:7) [11657]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodekey$ might be null. (AVLTree.sil,807:7) [11658]"}
              this$_11 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodekey$. (AVLTree.sil,807:7) [11659]"}
                (perm[$frac] < Mask[this$_11, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodekey$][$eps]);
            }
            Mask[this$_11, AVLTreeNodekey$] := PermSub(Mask[this$_11, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,807:7) [11660]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,807:7) [11661]"}
              this$_11 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,807:7) [11662]"}
                (perm[$frac] < Mask[this$_11, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodeheight$][$eps]);
            }
            Mask[this$_11, AVLTreeNodeheight$] := PermSub(Mask[this$_11, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,807:7) [11663]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$ might be null. (AVLTree.sil,807:7) [11664]"}
              this$_11 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,807:7) [11665]"}
                (perm[$frac] < Mask[this$_11, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodeleft$][$eps]);
            }
            Mask[this$_11, AVLTreeNodeleft$] := PermSub(Mask[this$_11, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,807:7) [11666]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$ might be null. (AVLTree.sil,807:7) [11667]"}
              this$_11 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,807:7) [11668]"}
                (perm[$frac] < Mask[this$_11, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNoderight$][$eps]);
            }
            Mask[this$_11, AVLTreeNoderight$] := PermSub(Mask[this$_11, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,807:7) [11669]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodekeys$ might be null. (AVLTree.sil,807:7) [11670]"}
              this$_11 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodekeys$. (AVLTree.sil,807:7) [11671]"}
                (perm[$frac] < Mask[this$_11, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodekeys$][$eps]);
            }
            Mask[this$_11, AVLTreeNodekeys$] := PermSub(Mask[this$_11, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,807:7) [11672]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,807:7) [11673]"}
              this$_11 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodebalanceFactor$. (AVLTree.sil,807:7) [11674]"}
                (perm[$frac] < Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[this$_11, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNodeleft$). (AVLTree.sil,807:7) [11675]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])], perm);
            }
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,807:7) [11676]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,807:7) [11677]"}
                Heap[this$_11, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,807:7) [11678]"}
                  (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,807:7) [11679]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,807:7) [11680]"}
                Heap[this$_11, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,807:7) [11681]"}
                  (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,807:7) [11682]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,807:7) [11683]"}
                Heap[this$_11, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,807:7) [11684]"}
                  (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_11.AVLTreeNodekey$)) might not hold. (AVLTree.sil,807:7) [11685]"}
                (forall k0_3: int ::
                
                Seq#Contains(Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_3) ==> k0_3 < Heap[this$_11, AVLTreeNodekey$]
              );
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNoderight$). (AVLTree.sil,807:7) [11686]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,807:7) [11687]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,807:7) [11688]"}
                Heap[this$_11, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,807:7) [11689]"}
                  (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,807:7) [11690]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,807:7) [11691]"}
                Heap[this$_11, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,807:7) [11692]"}
                  (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,807:7) [11693]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,807:7) [11694]"}
                Heap[this$_11, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,807:7) [11695]"}
                  (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_11.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,807:7) [11696]"}
                (forall k1: int ::
                
                Seq#Contains(Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], k1) ==> Heap[this$_11, AVLTreeNodekey$] < k1
              );
            }
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_11.AVLTreeNodeleft$ == null ? 0 : this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_11.AVLTreeNoderight$ == null ? 0 : this$_11.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,807:7) [11697]"}
              (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_11.AVLTreeNodeleft$ == null ? 0 : this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_11.AVLTreeNoderight$ == null ? 0 : this$_11.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,807:7) [11698]"}
              (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(this$_11)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_11)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_11 != null;
            Mask[this$_11, AVLTreeNodeheight$] := PermAdd(Mask[this$_11, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_11 != null;
            Mask[this$_11, AVLTreeNodekeys$] := PermAdd(Mask[this$_11, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_11 != null;
            Mask[this$_11, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
            assume Seq#Equal(Heap[this$_11, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_11, AVLTreeNodekey$])), (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$])));
            assume Heap[this$_11, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
            assume Heap[this$_11, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]);
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_30 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,807:7) [11699]"}
            newK$_30[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: m := this$_11 -- AVLTree.sil,809:5
        m := this$_11;
        assume state(Heap, Mask);
      
      // -- Translating statement: assert (r != null) ==> (forall k1: Int :: true && k1 in r.AVLTreeNodekeys$ ==> (k1 < m.AVLTreeNodekeys$[0])) -- AVLTree.sil,810:5
        
        // -- Check definedness of (r != null) ==> (forall k1: Int :: true && k1 in r.AVLTreeNodekeys$ ==> (k1 < m.AVLTreeNodekeys$[0]))
          if (r_1 != null) {
            assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,810:5) [11700]"}
              r_1 != null;
            assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,810:5) [11701]"}
              HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
            if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k1_7)) {
              assert {:msg "  Assert might fail. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,810:5) [11702]"}
                m != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,810:5) [11703]"}
                HasDirectPerm(Mask, m, AVLTreeNodekeys$);
            }
          }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        if (r_1 != null) {
          assert {:msg "  Assert might fail. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNodekeys$ ==> (k1 < m.AVLTreeNodekeys$[0])) might not hold. (AVLTree.sil,810:5) [11704]"}
            (forall k1_2: int ::
            
            Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k1_2) ==> k1_2 < Seq#Index(Heap[m, AVLTreeNodekeys$], 0)
          );
        }
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: fresh newK$_31  -- AVLTree.sil,812:5
        
        // -- Translation of statement fresh newK$_31)
          havoc newK$_31;
          assume (newK$_31[$frac] > 0.000000000 && newK$_31[$frac] < 0.001000000) && newK$_31[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_31) -- AVLTree.sil,813:5
        
        // -- Translating statement: nr, m := AVLTreeNodepruneMax$(this$_11.AVLTreeNoderight$, newK$_31) -- AVLTree.sil,814:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Check definedness of this$_11.AVLTreeNoderight$
            assert {:msg "  Method call might fail. Receiver of this$_11.AVLTreeNoderight$ might be null. (AVLTree.sil,814:7) [11705]"}
              this$_11 != null;
            assert {:msg "  Method call might fail. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,814:7) [11706]"}
              HasDirectPerm(Mask, this$_11, AVLTreeNoderight$);
            assume state(Heap, Mask);
          arg_this$_11 := Heap[this$_11, AVLTreeNoderight$];
          havoc nr, m;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Assertion this$_11.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,814:7) [11707]"}
              Heap[this$_11, AVLTreeNoderight$] != null;
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Assertion newK$_31 > none might not hold. (AVLTree.sil,814:7) [11708]"}
              NoPerm[$frac] < newK$_31[$frac] || (NoPerm[$frac] == newK$_31[$frac] && NoPerm[$eps] < newK$_31[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Assertion write > newK$_31 might not hold. (AVLTree.sil,814:7) [11709]"}
              newK$_31[$frac] < FullPerm[$frac] || (newK$_31[$frac] == FullPerm[$frac] && newK$_31[$eps] < FullPerm[$eps]);
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNoderight$). (AVLTree.sil,814:7) [11710]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,814:7) [11711]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,814:7) [11712]"}
              Heap[this$_11, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,814:7) [11713]"}
                (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,814:7) [11714]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,814:7) [11715]"}
              Heap[this$_11, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,814:7) [11716]"}
                (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,814:7) [11717]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,814:7) [11718]"}
              Heap[this$_11, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,814:7) [11719]"}
                (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            if (nr != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(nr)] := PermAdd(Mask[null, AVLTreeNodevalid$(nr)], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (nr != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume nr != null;
              Mask[nr, AVLTreeNodekeys$] := PermAdd(Mask[nr, AVLTreeNodekeys$], perm);
            }
            if (nr != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume nr != null;
              Mask[nr, AVLTreeNodeheight$] := PermAdd(Mask[nr, AVLTreeNodeheight$], perm);
            }
            if (nr != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume nr != null;
              Mask[nr, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nr, AVLTreeNodebalanceFactor$], perm);
            }
            if (nr != null) {
              assume Heap[nr, AVLTreeNodeheight$] == PreCallHeap[arg_this$_11, AVLTreeNodeheight$] || Heap[nr, AVLTreeNodeheight$] + 1 == PreCallHeap[arg_this$_11, AVLTreeNodeheight$];
            }
            if (nr != null) {
              assume Seq#Length(Heap[nr, AVLTreeNodekeys$]) + 1 == Seq#Length(PreCallHeap[arg_this$_11, AVLTreeNodekeys$]);
            }
            if (PreCallHeap[arg_this$_11, AVLTreeNodeheight$] > 1) {
              assume nr != null;
            }
            if (PreCallHeap[arg_this$_11, AVLTreeNodeheight$] == 1) {
              assume nr == null;
            }
            assume PreCallHeap[arg_this$_11, AVLTreeNodeheight$] == (if nr == null then 0 else Heap[nr, AVLTreeNodeheight$]) || PreCallHeap[arg_this$_11, AVLTreeNodeheight$] == (if nr == null then 0 else Heap[nr, AVLTreeNodeheight$]) + 1;
            assume m != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(m)] := PermAdd(Mask[null, AVLTreeNodevalid$(m)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume m != null;
            Mask[m, AVLTreeNodekeys$] := PermAdd(Mask[m, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume m != null;
            Mask[m, AVLTreeNodeheight$] := PermAdd(Mask[m, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume m != null;
            Mask[m, AVLTreeNodebalanceFactor$] := PermAdd(Mask[m, AVLTreeNodebalanceFactor$], perm);
            assume Heap[m, AVLTreeNodeheight$] == 1;
            assume Seq#Length(Heap[m, AVLTreeNodekeys$]) == 1;
            assume Seq#Equal(Seq#Append((if nr == null then (Seq#Empty(): Seq_ int) else Heap[nr, AVLTreeNodekeys$]), Heap[m, AVLTreeNodekeys$]), PreCallHeap[arg_this$_11, AVLTreeNodekeys$]);
            if (nr != null) {
              assume (forall k0_4: int ::
                
                Seq#Contains(Heap[nr, AVLTreeNodekeys$], k0_4) ==> k0_4 < Seq#Index(Heap[m, AVLTreeNodekeys$], 0)
              );
            }
            assume state(Heap, Mask);
          assume nr == null || Heap[nr, $allocated];
          assume m == null || Heap[m, $allocated];
          assert {:msg "  The precondition of method AVLTreeNodepruneMax$ might not hold. The parameter newK$_31 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,814:7) [11720]"}
            newK$_31[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_11.AVLTreeNoderight$ := nr -- AVLTree.sil,816:5
        
        // -- Check definedness of this$_11.AVLTreeNoderight$
          assert {:msg "  Assignment might fail. Receiver of this$_11.AVLTreeNoderight$ might be null. (AVLTree.sil,816:5) [11721]"}
            this$_11 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,816:5) [11722]"}
            HasDirectPerm(Mask, this$_11, AVLTreeNoderight$);
          assume state(Heap, Mask);
        Heap[this$_11, AVLTreeNoderight$] := nr;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,816:5) [11723]"}
          FullPerm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_11, AVLTreeNoderight$][$eps];
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_32  -- AVLTree.sil,817:5
        
        // -- Translation of statement fresh newK$_32)
          havoc newK$_32;
          assume (newK$_32[$frac] > 0.000000000 && newK$_32[$frac] < 0.001000000) && newK$_32[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_32) -- AVLTree.sil,818:5
        
        // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_11, newK$_32) -- AVLTree.sil,819:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          havoc bf;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_11 != null might not hold. (AVLTree.sil,819:7) [11724]"}
              this$_11 != null;
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_32 > none might not hold. (AVLTree.sil,819:7) [11725]"}
              NoPerm[$frac] < newK$_32[$frac] || (NoPerm[$frac] == newK$_32[$frac] && NoPerm[$eps] < newK$_32[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_32 might not hold. (AVLTree.sil,819:7) [11726]"}
              newK$_32[$frac] < FullPerm[$frac] || (newK$_32[$frac] == FullPerm[$frac] && newK$_32[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_32 might not be positive. (AVLTree.sil,819:7) [11727]"}
              newK$_32[$frac] > 0.000000000 || (newK$_32[$frac] == 0.000000000 && newK$_32[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_11.AVLTreeNodeleft$ might be null. (AVLTree.sil,819:7) [11728]"}
              this$_11 != null;
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNodeleft$). (AVLTree.sil,819:7) [11729]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])], perm);
            }
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_32 might not be positive. (AVLTree.sil,819:7) [11730]"}
                newK$_32[$frac] > 0.000000000 || (newK$_32[$frac] == 0.000000000 && newK$_32[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,819:7) [11731]"}
                Heap[this$_11, AVLTreeNodeleft$] != null;
            }
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_32 might not be positive. (AVLTree.sil,819:7) [11732]"}
              newK$_32[$frac] > 0.000000000 || (newK$_32[$frac] == 0.000000000 && newK$_32[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_11.AVLTreeNoderight$ might be null. (AVLTree.sil,819:7) [11733]"}
              this$_11 != null;
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNoderight$). (AVLTree.sil,819:7) [11734]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_32 might not be positive. (AVLTree.sil,819:7) [11735]"}
                newK$_32[$frac] > 0.000000000 || (newK$_32[$frac] == 0.000000000 && newK$_32[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,819:7) [11736]"}
                Heap[this$_11, AVLTreeNoderight$] != null;
            }
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            perm := NoPerm;
            perm := PermAdd(perm, newK$_32);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,819:7) [11737]"}
                Mask[this$_11, AVLTreeNodeleft$][$frac] > 0.000000000;
              assume perm[$frac] < Mask[this$_11, AVLTreeNodeleft$][$frac];
            }
            Mask[this$_11, AVLTreeNodeleft$] := PermSub(Mask[this$_11, AVLTreeNodeleft$], perm);
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, newK$_32);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,819:7) [11738]"}
                  Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                assume perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
              }
              Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            perm := NoPerm;
            perm := PermAdd(perm, newK$_32);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,819:7) [11739]"}
                Mask[this$_11, AVLTreeNoderight$][$frac] > 0.000000000;
              assume perm[$frac] < Mask[this$_11, AVLTreeNoderight$][$frac];
            }
            Mask[this$_11, AVLTreeNoderight$] := PermSub(Mask[this$_11, AVLTreeNoderight$], perm);
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, newK$_32);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,819:7) [11740]"}
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                assume perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
              }
              Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := newK$_32;
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_11 != null;
            Mask[this$_11, AVLTreeNodeleft$] := PermAdd(Mask[this$_11, AVLTreeNodeleft$], perm);
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (Heap[this$_11, AVLTreeNodeleft$] != null) {
              perm := newK$_32;
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[this$_11, AVLTreeNodeleft$] != null;
              Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            perm := newK$_32;
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_11 != null;
            Mask[this$_11, AVLTreeNoderight$] := PermAdd(Mask[this$_11, AVLTreeNoderight$], perm);
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (Heap[this$_11, AVLTreeNoderight$] != null) {
              perm := newK$_32;
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[this$_11, AVLTreeNoderight$] != null;
              Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            assume bf == (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]);
            if (bf > 0) {
              assume Heap[this$_11, AVLTreeNodeleft$] != null;
            }
            if (bf < 0) {
              assume Heap[this$_11, AVLTreeNoderight$] != null;
            }
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_32 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,819:7) [11741]"}
            newK$_32[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: if (bf == 2) -- AVLTree.sil,821:5
        if (bf == 2) {
          
          // -- Translating statement: fresh newK$_33  -- AVLTree.sil,822:7
            
            // -- Translation of statement fresh newK$_33)
              havoc newK$_33;
              assume (newK$_33[$frac] > 0.000000000 && newK$_33[$frac] < 0.001000000) && newK$_33[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_33) -- AVLTree.sil,823:7
            
            // -- Translating statement: r := AVLTreeNoderebalanceLeft$(this$_11, newK$_33) -- AVLTree.sil,824:9
              PreCallHeap := Heap;
              PreCallMask := Mask;
              havoc r_1;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_11 != null might not hold. (AVLTree.sil,824:9) [11742]"}
                  this$_11 != null;
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion newK$_33 > none might not hold. (AVLTree.sil,824:9) [11743]"}
                  NoPerm[$frac] < newK$_33[$frac] || (NoPerm[$frac] == newK$_33[$frac] && NoPerm[$eps] < newK$_33[$eps]);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion write > newK$_33 might not hold. (AVLTree.sil,824:9) [11744]"}
                  newK$_33[$frac] < FullPerm[$frac] || (newK$_33[$frac] == FullPerm[$frac] && newK$_33[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,824:9) [11745]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodekey$ might be null. (AVLTree.sil,824:9) [11746]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodekey$. (AVLTree.sil,824:9) [11747]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodekey$][$eps]);
                }
                Mask[this$_11, AVLTreeNodekey$] := PermSub(Mask[this$_11, AVLTreeNodekey$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,824:9) [11748]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,824:9) [11749]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,824:9) [11750]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodeheight$][$eps]);
                }
                Mask[this$_11, AVLTreeNodeheight$] := PermSub(Mask[this$_11, AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,824:9) [11751]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodeleft$ might be null. (AVLTree.sil,824:9) [11752]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,824:9) [11753]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodeleft$][$eps]);
                }
                Mask[this$_11, AVLTreeNodeleft$] := PermSub(Mask[this$_11, AVLTreeNodeleft$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,824:9) [11754]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNoderight$ might be null. (AVLTree.sil,824:9) [11755]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,824:9) [11756]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNoderight$][$eps]);
                }
                Mask[this$_11, AVLTreeNoderight$] := PermSub(Mask[this$_11, AVLTreeNoderight$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,824:9) [11757]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodekeys$ might be null. (AVLTree.sil,824:9) [11758]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodekeys$. (AVLTree.sil,824:9) [11759]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodekeys$][$eps]);
                }
                Mask[this$_11, AVLTreeNodekeys$] := PermSub(Mask[this$_11, AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,824:9) [11760]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,824:9) [11761]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodebalanceFactor$. (AVLTree.sil,824:9) [11762]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[this$_11, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_11.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,824:9) [11763]"}
                  Heap[this$_11, AVLTreeNodeleft$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, FullPerm);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNodeleft$). (AVLTree.sil,824:9) [11764]"}
                    (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps]);
                }
                Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,824:9) [11765]"}
                  Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,824:9) [11766]"}
                  Heap[this$_11, AVLTreeNodeleft$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,824:9) [11767]"}
                    (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                }
                Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,824:9) [11768]"}
                  Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,824:9) [11769]"}
                  Heap[this$_11, AVLTreeNodeleft$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,824:9) [11770]"}
                    (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                }
                Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,824:9) [11771]"}
                  Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,824:9) [11772]"}
                  Heap[this$_11, AVLTreeNodeleft$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,824:9) [11773]"}
                    (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_11.AVLTreeNodekey$)) might not hold. (AVLTree.sil,824:9) [11774]"}
                  (forall k0_5: int ::
                  
                  Seq#Contains(Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_5) ==> k0_5 < Heap[this$_11, AVLTreeNodekey$]
                );
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNoderight$). (AVLTree.sil,824:9) [11775]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,824:9) [11776]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,824:9) [11777]"}
                    Heap[this$_11, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,824:9) [11778]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,824:9) [11779]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,824:9) [11780]"}
                    Heap[this$_11, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,824:9) [11781]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,824:9) [11782]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,824:9) [11783]"}
                    Heap[this$_11, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,824:9) [11784]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_11.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,824:9) [11785]"}
                    (forall k1_3: int ::
                    
                    Seq#Contains(Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_11, AVLTreeNodekey$] < k1_3
                  );
                }
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. Assertion this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_11.AVLTreeNoderight$ == null ? 0 : this$_11.AVLTreeNoderight$.AVLTreeNodeheight$) == 2 might not hold. (AVLTree.sil,824:9) [11786]"}
                  Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                assume r_1 != null;
                perm := FullPerm;
                Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                
                // -- Extra unfolding of predicate
                  
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
                assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(PreCallHeap[this$_11, AVLTreeNodekey$])), (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$])));
                assume state(Heap, Mask);
              assume r_1 == null || Heap[r_1, $allocated];
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLeft$ might not hold. The parameter newK$_33 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,824:9) [11787]"}
                newK$_33[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: fresh newK$_34  -- AVLTree.sil,827:7
            
            // -- Translation of statement fresh newK$_34)
              havoc newK$_34;
              assume (newK$_34[$frac] > 0.000000000 && newK$_34[$frac] < 0.001000000) && newK$_34[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_34) -- AVLTree.sil,828:7
            
            // -- Translating statement: AVLTreeNodeclose$(this$_11, newK$_34) -- AVLTree.sil,829:9
              PreCallHeap := Heap;
              PreCallMask := Mask;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_11 != null might not hold. (AVLTree.sil,829:9) [11788]"}
                  this$_11 != null;
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_34 > none might not hold. (AVLTree.sil,829:9) [11789]"}
                  NoPerm[$frac] < newK$_34[$frac] || (NoPerm[$frac] == newK$_34[$frac] && NoPerm[$eps] < newK$_34[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_34 might not hold. (AVLTree.sil,829:9) [11790]"}
                  newK$_34[$frac] < FullPerm[$frac] || (newK$_34[$frac] == FullPerm[$frac] && newK$_34[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,829:9) [11791]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodekey$ might be null. (AVLTree.sil,829:9) [11792]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodekey$. (AVLTree.sil,829:9) [11793]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodekey$][$eps]);
                }
                Mask[this$_11, AVLTreeNodekey$] := PermSub(Mask[this$_11, AVLTreeNodekey$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,829:9) [11794]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeheight$ might be null. (AVLTree.sil,829:9) [11795]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeheight$. (AVLTree.sil,829:9) [11796]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodeheight$][$eps]);
                }
                Mask[this$_11, AVLTreeNodeheight$] := PermSub(Mask[this$_11, AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,829:9) [11797]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$ might be null. (AVLTree.sil,829:9) [11798]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$. (AVLTree.sil,829:9) [11799]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodeleft$][$eps]);
                }
                Mask[this$_11, AVLTreeNodeleft$] := PermSub(Mask[this$_11, AVLTreeNodeleft$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,829:9) [11800]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$ might be null. (AVLTree.sil,829:9) [11801]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$. (AVLTree.sil,829:9) [11802]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNoderight$][$eps]);
                }
                Mask[this$_11, AVLTreeNoderight$] := PermSub(Mask[this$_11, AVLTreeNoderight$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,829:9) [11803]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodekeys$ might be null. (AVLTree.sil,829:9) [11804]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodekeys$. (AVLTree.sil,829:9) [11805]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodekeys$][$eps]);
                }
                Mask[this$_11, AVLTreeNodekeys$] := PermSub(Mask[this$_11, AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,829:9) [11806]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,829:9) [11807]"}
                  this$_11 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodebalanceFactor$. (AVLTree.sil,829:9) [11808]"}
                    (perm[$frac] < Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_11, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_11, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_11, AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[this$_11, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
                if (Heap[this$_11, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNodeleft$). (AVLTree.sil,829:9) [11809]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNodeleft$])], perm);
                }
                if (Heap[this$_11, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,829:9) [11810]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,829:9) [11811]"}
                    Heap[this$_11, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,829:9) [11812]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                if (Heap[this$_11, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,829:9) [11813]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,829:9) [11814]"}
                    Heap[this$_11, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,829:9) [11815]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                }
                if (Heap[this$_11, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,829:9) [11816]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,829:9) [11817]"}
                    Heap[this$_11, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,829:9) [11818]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[this$_11, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_11.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_11.AVLTreeNodekey$)) might not hold. (AVLTree.sil,829:9) [11819]"}
                    (forall k0_6: int ::
                    
                    Seq#Contains(Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_6) ==> k0_6 < Heap[this$_11, AVLTreeNodekey$]
                  );
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_11.AVLTreeNoderight$). (AVLTree.sil,829:9) [11820]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_11, AVLTreeNoderight$])], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,829:9) [11821]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,829:9) [11822]"}
                    Heap[this$_11, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,829:9) [11823]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,829:9) [11824]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,829:9) [11825]"}
                    Heap[this$_11, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,829:9) [11826]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,829:9) [11827]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,829:9) [11828]"}
                    Heap[this$_11, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_11.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,829:9) [11829]"}
                      (perm[$frac] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[this$_11, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_11.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_11.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,829:9) [11830]"}
                    (forall k1_4: int ::
                    
                    Seq#Contains(Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$], k1_4) ==> Heap[this$_11, AVLTreeNodekey$] < k1_4
                  );
                }
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_11.AVLTreeNodeleft$ == null ? 0 : this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_11.AVLTreeNoderight$ == null ? 0 : this$_11.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,829:9) [11831]"}
                  (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_11.AVLTreeNodeleft$ == null ? 0 : this$_11.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_11.AVLTreeNoderight$ == null ? 0 : this$_11.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,829:9) [11832]"}
                  (if Heap[this$_11, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_11, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                perm := FullPerm;
                Mask[null, AVLTreeNodevalid$(this$_11)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_11)], perm);
                
                // -- Extra unfolding of predicate
                  
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_11 != null;
                Mask[this$_11, AVLTreeNodeheight$] := PermAdd(Mask[this$_11, AVLTreeNodeheight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_11 != null;
                Mask[this$_11, AVLTreeNodekeys$] := PermAdd(Mask[this$_11, AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_11 != null;
                Mask[this$_11, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_11, AVLTreeNodebalanceFactor$], perm);
                assume Seq#Equal(Heap[this$_11, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_11, AVLTreeNodekey$])), (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodekeys$])));
                assume Heap[this$_11, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                assume Heap[this$_11, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_11, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_11, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_11, AVLTreeNoderight$], AVLTreeNodeheight$]);
                assume state(Heap, Mask);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_34 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,829:9) [11833]"}
                newK$_34[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: r := this$_11 -- AVLTree.sil,831:7
            r_1 := this$_11;
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: assert (r != null) ==> (forall k2: Int :: true && k2 in r.AVLTreeNodekeys$ ==> (k2 < m.AVLTreeNodekeys$[0])) -- AVLTree.sil,833:5
        
        // -- Check definedness of (r != null) ==> (forall k2: Int :: true && k2 in r.AVLTreeNodekeys$ ==> (k2 < m.AVLTreeNodekeys$[0]))
          if (r_1 != null) {
            assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,833:5) [11834]"}
              r_1 != null;
            assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,833:5) [11835]"}
              HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
            if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k2)) {
              assert {:msg "  Assert might fail. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,833:5) [11836]"}
                m != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,833:5) [11837]"}
                HasDirectPerm(Mask, m, AVLTreeNodekeys$);
            }
          }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        if (r_1 != null) {
          assert {:msg "  Assert might fail. Assertion (forall k2: Int :: true && k2 in r.AVLTreeNodekeys$ ==> (k2 < m.AVLTreeNodekeys$[0])) might not hold. (AVLTree.sil,833:5) [11838]"}
            (forall k2_1: int ::
            
            Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k2_1) ==> k2_1 < Seq#Index(Heap[m, AVLTreeNodekeys$], 0)
          );
        }
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    if (r_1 != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,771:11) [11839]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,772:11) [11840]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,772:11) [11841]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,772:11) [11842]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
      }
      Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,773:11) [11843]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,773:11) [11844]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,773:11) [11845]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
      }
      Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,774:11) [11846]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,774:11) [11847]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,774:11) [11848]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_11.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ + 1 == old(this$_11.AVLTreeNodeheight$)) might not hold. (AVLTree.sil,775:11) [11849]"}
        Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_11, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] + 1 == old(Heap)[this$_11, AVLTreeNodeheight$];
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion |r.AVLTreeNodekeys$| + 1 == |old(this$_11.AVLTreeNodekeys$)| might not hold. (AVLTree.sil,776:11) [11850]"}
        Seq#Length(Heap[r_1, AVLTreeNodekeys$]) + 1 == Seq#Length(old(Heap)[this$_11, AVLTreeNodekeys$]);
    }
    if (old(Heap)[this$_11, AVLTreeNodeheight$] > 1) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion r != null might not hold. (AVLTree.sil,777:11) [11851]"}
        r_1 != null;
    }
    if (old(Heap)[this$_11, AVLTreeNodeheight$] == 1) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion r == null might not hold. (AVLTree.sil,778:11) [11852]"}
        r_1 == null;
    }
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion (old(this$_11.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$)) || (old(this$_11.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,779:11) [11853]"}
      old(Heap)[this$_11, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) || old(Heap)[this$_11, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) + 1;
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion m != null might not hold. (AVLTree.sil,780:11) [11854]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(m). (AVLTree.sil,781:11) [11855]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(m)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(m)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(m)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(m)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(m)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(m)] := PermSub(Mask[null, AVLTreeNodevalid$(m)], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,782:11) [11856]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,782:11) [11857]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,782:11) [11858]"}
        (perm[$frac] < Mask[m, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[m, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[m, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[m, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[m, AVLTreeNodekeys$][$eps]);
    }
    Mask[m, AVLTreeNodekeys$] := PermSub(Mask[m, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,783:11) [11859]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Receiver of m.AVLTreeNodeheight$ might be null. (AVLTree.sil,783:11) [11860]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access m.AVLTreeNodeheight$. (AVLTree.sil,783:11) [11861]"}
        (perm[$frac] < Mask[m, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[m, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[m, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[m, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[m, AVLTreeNodeheight$][$eps]);
    }
    Mask[m, AVLTreeNodeheight$] := PermSub(Mask[m, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,784:11) [11862]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Receiver of m.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,784:11) [11863]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. There might be insufficient permission to access m.AVLTreeNodebalanceFactor$. (AVLTree.sil,784:11) [11864]"}
        (perm[$frac] < Mask[m, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[m, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[m, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[m, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[m, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[m, AVLTreeNodebalanceFactor$] := PermSub(Mask[m, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion m.AVLTreeNodeheight$ == 1 might not hold. (AVLTree.sil,785:11) [11865]"}
      Heap[m, AVLTreeNodeheight$] == 1;
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion |m.AVLTreeNodekeys$| == 1 might not hold. (AVLTree.sil,786:11) [11866]"}
      Seq#Length(Heap[m, AVLTreeNodekeys$]) == 1;
    assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion (r == null ? Seq() : r.AVLTreeNodekeys$) ++ m.AVLTreeNodekeys$ == old(this$_11.AVLTreeNodekeys$) might not hold. (AVLTree.sil,787:11) [11867]"}
      Seq#Equal(Seq#Append((if r_1 == null then (Seq#Empty(): Seq_ int) else Heap[r_1, AVLTreeNodekeys$]), Heap[m, AVLTreeNodekeys$]), old(Heap)[this$_11, AVLTreeNodekeys$]);
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMax$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodekeys$ ==> (k0 < m.AVLTreeNodekeys$[0])) might not hold. (AVLTree.sil,788:11) [11868]"}
        (forall k0_2: int ::
        
        Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k0_2) ==> k0_2 < Seq#Index(Heap[m, AVLTreeNodekeys$], 0)
      );
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodepruneMin$
// ==================================================

procedure AVLTreeNodepruneMin$(this$_12: Ref, k$_8: Perm) returns (r_1: Ref, m: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k0_9: int;
  var oldVersion: int;
  var newVersion: int;
  var newK$_53: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var k1_8: int;
  var newK$_54: Perm;
  var arg_this$_12: Ref;
  var nl: Ref;
  var newK$_55: Perm;
  var bf: int;
  var newK$_56: Perm;
  var newK$_57: Perm;
  var k2_2: int;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_12 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_8[$frac] || (NoPerm[$frac] == k$_8[$frac] && NoPerm[$eps] < k$_8[$eps]);
    assume state(Heap, Mask);
    assume k$_8[$frac] < FullPerm[$frac] || (k$_8[$frac] == FullPerm[$frac] && k$_8[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_12)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_12)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodekeys$] := PermAdd(Mask[this$_12, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodeheight$] := PermAdd(Mask[this$_12, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    if (r_1 != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume r_1 != null;
      Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,849:11) [11869]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,849:11) [11870]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,849:11) [11871]"}
          this$_12 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,849:11) [11872]"}
          HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
        if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$])) {
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,849:11) [11873]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,849:11) [11874]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
          assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,849:11) [11875]"}
            this$_12 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,849:11) [11876]"}
            HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
        }
        assume state(Heap, Mask);
      assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] - 1;
      assume state(Heap, Mask);
    }
    if (r_1 != null) {
      
      // -- Check definedness of |r.AVLTreeNodekeys$| + 1 == |old(this$_12.AVLTreeNodekeys$)|
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,850:11) [11877]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,850:11) [11878]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodekeys$ might be null. (AVLTree.sil,850:11) [11879]"}
          this$_12 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodekeys$. (AVLTree.sil,850:11) [11880]"}
          HasDirectPerm(old(Mask), this$_12, AVLTreeNodekeys$);
        assume state(Heap, Mask);
      assume Seq#Length(Heap[r_1, AVLTreeNodekeys$]) + 1 == Seq#Length(old(Heap)[this$_12, AVLTreeNodekeys$]);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of old(this$_12.AVLTreeNodeheight$) > 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,851:11) [11881]"}
        this$_12 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,851:11) [11882]"}
        HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    if (old(Heap)[this$_12, AVLTreeNodeheight$] > 1) {
      assume r_1 != null;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of old(this$_12.AVLTreeNodeheight$) == 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,852:11) [11883]"}
        this$_12 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,852:11) [11884]"}
        HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    if (old(Heap)[this$_12, AVLTreeNodeheight$] == 1) {
      assume r_1 == null;
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of (old(this$_12.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$)) || (old(this$_12.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,853:11) [11885]"}
        this$_12 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,853:11) [11886]"}
        HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
      if (r_1 == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,853:11) [11887]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,853:11) [11888]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      }
      if (!(old(Heap)[this$_12, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]))) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,853:11) [11889]"}
          this$_12 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,853:11) [11890]"}
          HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
        if (r_1 == null) {
        } else {
          assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,853:11) [11891]"}
            r_1 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,853:11) [11892]"}
            HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        }
      }
      assume state(Heap, Mask);
    assume old(Heap)[this$_12, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) || old(Heap)[this$_12, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) + 1;
    assume state(Heap, Mask);
    assume m != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(m)] := PermAdd(Mask[null, AVLTreeNodevalid$(m)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume m != null;
    Mask[m, AVLTreeNodekeys$] := PermAdd(Mask[m, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume m != null;
    Mask[m, AVLTreeNodeheight$] := PermAdd(Mask[m, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume m != null;
    Mask[m, AVLTreeNodebalanceFactor$] := PermAdd(Mask[m, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of m.AVLTreeNodeheight$ == 1
      assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodeheight$ might be null. (AVLTree.sil,859:11) [11893]"}
        m != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodeheight$. (AVLTree.sil,859:11) [11894]"}
        HasDirectPerm(Mask, m, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    assume Heap[m, AVLTreeNodeheight$] == 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of |m.AVLTreeNodekeys$| == 1
      assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,860:11) [11895]"}
        m != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,860:11) [11896]"}
        HasDirectPerm(Mask, m, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Length(Heap[m, AVLTreeNodekeys$]) == 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of m.AVLTreeNodekeys$ ++ (r == null ? Seq() : r.AVLTreeNodekeys$) == old(this$_12.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,861:11) [11897]"}
        m != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,861:11) [11898]"}
        HasDirectPerm(Mask, m, AVLTreeNodekeys$);
      if (r_1 == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,861:11) [11899]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,861:11) [11900]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_12.AVLTreeNodekeys$ might be null. (AVLTree.sil,861:11) [11901]"}
        this$_12 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_12.AVLTreeNodekeys$. (AVLTree.sil,861:11) [11902]"}
        HasDirectPerm(old(Mask), this$_12, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume Seq#Equal(Seq#Append(Heap[m, AVLTreeNodekeys$], (if r_1 == null then (Seq#Empty(): Seq_ int) else Heap[r_1, AVLTreeNodekeys$])), old(Heap)[this$_12, AVLTreeNodekeys$]);
    assume state(Heap, Mask);
    if (r_1 != null) {
      
      // -- Check definedness of (forall k0: Int :: true && k0 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k0))
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,862:11) [11903]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,862:11) [11904]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
        if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k0_9)) {
          assert {:msg "  Contract might not be well-formed. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,862:11) [11905]"}
            m != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,862:11) [11906]"}
            HasDirectPerm(Mask, m, AVLTreeNodekeys$);
        }
        assume state(Heap, Mask);
      assume (forall k0_1: int ::
        
        Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k0_1) ==> Seq#Index(Heap[m, AVLTreeNodekeys$], 0) < k0_1
      );
      assume state(Heap, Mask);
    }
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_12 == null || Heap[this$_12, $allocated];
    assume k$_8[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_12), write) -- AVLTree.sil,875:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_12));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_12) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_12). (AVLTree.sil,875:3) [11909]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_12)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_12)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_12)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_12)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_12)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_12)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_12)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(this$_12))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(this$_12)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(this$_12)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodekey$] := PermAdd(Mask[this$_12, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodeheight$] := PermAdd(Mask[this$_12, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodeleft$] := PermAdd(Mask[this$_12, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNoderight$] := PermAdd(Mask[this$_12, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodekeys$] := PermAdd(Mask[this$_12, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_12 != null;
    Mask[this$_12, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_12, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_12, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_12)], Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_12, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_12, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_12, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_12, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_12, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_12, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_12, AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[this$_12, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_12, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_12, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_12, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_12)], Heap[this$_12, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])]);
    }
    if (Heap[this$_12, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_12, AVLTreeNoderight$] != null;
      Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_12, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_12, AVLTreeNoderight$] != null;
      Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_12, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_12, AVLTreeNoderight$] != null;
      Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_12, AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[this$_12, AVLTreeNodekey$] < rk
      );
    }
    if (Heap[this$_12, AVLTreeNoderight$] != null) {
      assume Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[this$_12, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_12, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_12, AVLTreeNodekey$])), (if Heap[this$_12, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[this$_12, AVLTreeNodekeys$], Heap[this$_12, AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[this$_12, AVLTreeNodekeys$], kk) == ((Heap[this$_12, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[this$_12, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[this$_12, AVLTreeNodekey$]))
    );
    assume Heap[this$_12, AVLTreeNodeheight$] == (if (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[this$_12, AVLTreeNodebalanceFactor$] == (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[this$_12, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[this$_12, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[this$_12, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this$_12.AVLTreeNodeleft$ == null) -- AVLTree.sil,876:3
    
    // -- Check definedness of this$_12.AVLTreeNodeleft$ == null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,876:7) [11910]"}
        HasDirectPerm(Mask, this$_12, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_12, AVLTreeNodeleft$] == null) {
      
      // -- Translating statement: r := this$_12.AVLTreeNoderight$ -- AVLTree.sil,877:5
        
        // -- Check definedness of this$_12.AVLTreeNoderight$
          assert {:msg "  Assignment might fail. Receiver of this$_12.AVLTreeNoderight$ might be null. (AVLTree.sil,877:5) [11911]"}
            this$_12 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,877:5) [11912]"}
            HasDirectPerm(Mask, this$_12, AVLTreeNoderight$);
          assume state(Heap, Mask);
        r_1 := Heap[this$_12, AVLTreeNoderight$];
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_12.AVLTreeNoderight$ := null -- AVLTree.sil,878:5
        
        // -- Check definedness of this$_12.AVLTreeNoderight$
          assert {:msg "  Assignment might fail. Receiver of this$_12.AVLTreeNoderight$ might be null. (AVLTree.sil,878:5) [11913]"}
            this$_12 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,878:5) [11914]"}
            HasDirectPerm(Mask, this$_12, AVLTreeNoderight$);
          assume state(Heap, Mask);
        Heap[this$_12, AVLTreeNoderight$] := null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,878:5) [11915]"}
          FullPerm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_12, AVLTreeNoderight$][$eps];
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_53  -- AVLTree.sil,879:5
        
        // -- Translation of statement fresh newK$_53)
          havoc newK$_53;
          assume (newK$_53[$frac] > 0.000000000 && newK$_53[$frac] < 0.001000000) && newK$_53[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_53) -- AVLTree.sil,880:5
        
        // -- Translating statement: AVLTreeNodeclose$(this$_12, newK$_53) -- AVLTree.sil,881:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_12 != null might not hold. (AVLTree.sil,881:7) [11916]"}
              this$_12 != null;
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_53 > none might not hold. (AVLTree.sil,881:7) [11917]"}
              NoPerm[$frac] < newK$_53[$frac] || (NoPerm[$frac] == newK$_53[$frac] && NoPerm[$eps] < newK$_53[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_53 might not hold. (AVLTree.sil,881:7) [11918]"}
              newK$_53[$frac] < FullPerm[$frac] || (newK$_53[$frac] == FullPerm[$frac] && newK$_53[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,881:7) [11919]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodekey$ might be null. (AVLTree.sil,881:7) [11920]"}
              this$_12 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodekey$. (AVLTree.sil,881:7) [11921]"}
                (perm[$frac] < Mask[this$_12, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodekey$][$eps]);
            }
            Mask[this$_12, AVLTreeNodekey$] := PermSub(Mask[this$_12, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,881:7) [11922]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,881:7) [11923]"}
              this$_12 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,881:7) [11924]"}
                (perm[$frac] < Mask[this$_12, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodeheight$][$eps]);
            }
            Mask[this$_12, AVLTreeNodeheight$] := PermSub(Mask[this$_12, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,881:7) [11925]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$ might be null. (AVLTree.sil,881:7) [11926]"}
              this$_12 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,881:7) [11927]"}
                (perm[$frac] < Mask[this$_12, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodeleft$][$eps]);
            }
            Mask[this$_12, AVLTreeNodeleft$] := PermSub(Mask[this$_12, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,881:7) [11928]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$ might be null. (AVLTree.sil,881:7) [11929]"}
              this$_12 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,881:7) [11930]"}
                (perm[$frac] < Mask[this$_12, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNoderight$][$eps]);
            }
            Mask[this$_12, AVLTreeNoderight$] := PermSub(Mask[this$_12, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,881:7) [11931]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodekeys$ might be null. (AVLTree.sil,881:7) [11932]"}
              this$_12 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodekeys$. (AVLTree.sil,881:7) [11933]"}
                (perm[$frac] < Mask[this$_12, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodekeys$][$eps]);
            }
            Mask[this$_12, AVLTreeNodekeys$] := PermSub(Mask[this$_12, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,881:7) [11934]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,881:7) [11935]"}
              this$_12 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodebalanceFactor$. (AVLTree.sil,881:7) [11936]"}
                (perm[$frac] < Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[this$_12, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNodeleft$). (AVLTree.sil,881:7) [11937]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
            }
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,881:7) [11938]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,881:7) [11939]"}
                Heap[this$_12, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,881:7) [11940]"}
                  (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,881:7) [11941]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,881:7) [11942]"}
                Heap[this$_12, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,881:7) [11943]"}
                  (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,881:7) [11944]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,881:7) [11945]"}
                Heap[this$_12, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,881:7) [11946]"}
                  (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_12.AVLTreeNodekey$)) might not hold. (AVLTree.sil,881:7) [11947]"}
                (forall k0_3: int ::
                
                Seq#Contains(Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_3) ==> k0_3 < Heap[this$_12, AVLTreeNodekey$]
              );
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNoderight$). (AVLTree.sil,881:7) [11948]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])], perm);
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,881:7) [11949]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,881:7) [11950]"}
                Heap[this$_12, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,881:7) [11951]"}
                  (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,881:7) [11952]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,881:7) [11953]"}
                Heap[this$_12, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,881:7) [11954]"}
                  (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,881:7) [11955]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,881:7) [11956]"}
                Heap[this$_12, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,881:7) [11957]"}
                  (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_12.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_12.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,881:7) [11958]"}
                (forall k1: int ::
                
                Seq#Contains(Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], k1) ==> Heap[this$_12, AVLTreeNodekey$] < k1
              );
            }
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_12.AVLTreeNodeleft$ == null ? 0 : this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_12.AVLTreeNoderight$ == null ? 0 : this$_12.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,881:7) [11959]"}
              (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_12.AVLTreeNodeleft$ == null ? 0 : this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_12.AVLTreeNoderight$ == null ? 0 : this$_12.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,881:7) [11960]"}
              (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(this$_12)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_12)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_12 != null;
            Mask[this$_12, AVLTreeNodeheight$] := PermAdd(Mask[this$_12, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_12 != null;
            Mask[this$_12, AVLTreeNodekeys$] := PermAdd(Mask[this$_12, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_12 != null;
            Mask[this$_12, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
            assume Seq#Equal(Heap[this$_12, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_12, AVLTreeNodekey$])), (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$])));
            assume Heap[this$_12, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
            assume Heap[this$_12, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]);
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_53 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,881:7) [11961]"}
            newK$_53[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: m := this$_12 -- AVLTree.sil,883:5
        m := this$_12;
        assume state(Heap, Mask);
      
      // -- Translating statement: assert (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) -- AVLTree.sil,884:5
        
        // -- Check definedness of (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
          if (r_1 != null) {
            assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,884:5) [11962]"}
              r_1 != null;
            assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,884:5) [11963]"}
              HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
            assert {:msg "  Assert might fail. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,884:5) [11964]"}
              this$_12 != null;
            assert {:msg "  Assert might fail. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,884:5) [11965]"}
              HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
            if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$])) {
              assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,884:5) [11966]"}
                r_1 != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,884:5) [11967]"}
                HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
              assert {:msg "  Assert might fail. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,884:5) [11968]"}
                this$_12 != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,884:5) [11969]"}
                HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
            }
          }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        if (r_1 != null) {
          assert {:msg "  Assert might fail. Assertion (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) might not hold. (AVLTree.sil,884:5) [11970]"}
            Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] - 1;
        }
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        assume state(Heap, Mask);
      
      // -- Translating statement: assert (r != null) ==> (forall k1: Int :: true && k1 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k1)) -- AVLTree.sil,885:5
        
        // -- Check definedness of (r != null) ==> (forall k1: Int :: true && k1 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k1))
          if (r_1 != null) {
            assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,885:5) [11971]"}
              r_1 != null;
            assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,885:5) [11972]"}
              HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
            if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k1_8)) {
              assert {:msg "  Assert might fail. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,885:5) [11973]"}
                m != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,885:5) [11974]"}
                HasDirectPerm(Mask, m, AVLTreeNodekeys$);
            }
          }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        if (r_1 != null) {
          assert {:msg "  Assert might fail. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k1)) might not hold. (AVLTree.sil,885:5) [11975]"}
            (forall k1_2: int ::
            
            Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k1_2) ==> Seq#Index(Heap[m, AVLTreeNodekeys$], 0) < k1_2
          );
        }
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: fresh newK$_54  -- AVLTree.sil,887:5
        
        // -- Translation of statement fresh newK$_54)
          havoc newK$_54;
          assume (newK$_54[$frac] > 0.000000000 && newK$_54[$frac] < 0.001000000) && newK$_54[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_54) -- AVLTree.sil,888:5
        
        // -- Translating statement: nl, m := AVLTreeNodepruneMin$(this$_12.AVLTreeNodeleft$, newK$_54) -- AVLTree.sil,889:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          
          // -- Check definedness of this$_12.AVLTreeNodeleft$
            assert {:msg "  Method call might fail. Receiver of this$_12.AVLTreeNodeleft$ might be null. (AVLTree.sil,889:7) [11976]"}
              this$_12 != null;
            assert {:msg "  Method call might fail. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,889:7) [11977]"}
              HasDirectPerm(Mask, this$_12, AVLTreeNodeleft$);
            assume state(Heap, Mask);
          arg_this$_12 := Heap[this$_12, AVLTreeNodeleft$];
          havoc nl, m;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Assertion this$_12.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,889:7) [11978]"}
              Heap[this$_12, AVLTreeNodeleft$] != null;
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Assertion newK$_54 > none might not hold. (AVLTree.sil,889:7) [11979]"}
              NoPerm[$frac] < newK$_54[$frac] || (NoPerm[$frac] == newK$_54[$frac] && NoPerm[$eps] < newK$_54[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Assertion write > newK$_54 might not hold. (AVLTree.sil,889:7) [11980]"}
              newK$_54[$frac] < FullPerm[$frac] || (newK$_54[$frac] == FullPerm[$frac] && newK$_54[$eps] < FullPerm[$eps]);
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNodeleft$). (AVLTree.sil,889:7) [11981]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,889:7) [11982]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,889:7) [11983]"}
              Heap[this$_12, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,889:7) [11984]"}
                (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,889:7) [11985]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,889:7) [11986]"}
              Heap[this$_12, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,889:7) [11987]"}
                (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,889:7) [11988]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,889:7) [11989]"}
              Heap[this$_12, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,889:7) [11990]"}
                (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            if (nl != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(nl)] := PermAdd(Mask[null, AVLTreeNodevalid$(nl)], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (nl != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume nl != null;
              Mask[nl, AVLTreeNodekeys$] := PermAdd(Mask[nl, AVLTreeNodekeys$], perm);
            }
            if (nl != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume nl != null;
              Mask[nl, AVLTreeNodeheight$] := PermAdd(Mask[nl, AVLTreeNodeheight$], perm);
            }
            if (nl != null) {
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume nl != null;
              Mask[nl, AVLTreeNodebalanceFactor$] := PermAdd(Mask[nl, AVLTreeNodebalanceFactor$], perm);
            }
            if (nl != null) {
              assume Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_12, AVLTreeNodeheight$] || Heap[nl, AVLTreeNodeheight$] == PreCallHeap[arg_this$_12, AVLTreeNodeheight$] - 1;
            }
            if (nl != null) {
              assume Seq#Length(Heap[nl, AVLTreeNodekeys$]) + 1 == Seq#Length(PreCallHeap[arg_this$_12, AVLTreeNodekeys$]);
            }
            if (PreCallHeap[arg_this$_12, AVLTreeNodeheight$] > 1) {
              assume nl != null;
            }
            if (PreCallHeap[arg_this$_12, AVLTreeNodeheight$] == 1) {
              assume nl == null;
            }
            assume PreCallHeap[arg_this$_12, AVLTreeNodeheight$] == (if nl == null then 0 else Heap[nl, AVLTreeNodeheight$]) || PreCallHeap[arg_this$_12, AVLTreeNodeheight$] == (if nl == null then 0 else Heap[nl, AVLTreeNodeheight$]) + 1;
            assume m != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(m)] := PermAdd(Mask[null, AVLTreeNodevalid$(m)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume m != null;
            Mask[m, AVLTreeNodekeys$] := PermAdd(Mask[m, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume m != null;
            Mask[m, AVLTreeNodeheight$] := PermAdd(Mask[m, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume m != null;
            Mask[m, AVLTreeNodebalanceFactor$] := PermAdd(Mask[m, AVLTreeNodebalanceFactor$], perm);
            assume Heap[m, AVLTreeNodeheight$] == 1;
            assume Seq#Length(Heap[m, AVLTreeNodekeys$]) == 1;
            assume Seq#Equal(Seq#Append(Heap[m, AVLTreeNodekeys$], (if nl == null then (Seq#Empty(): Seq_ int) else Heap[nl, AVLTreeNodekeys$])), PreCallHeap[arg_this$_12, AVLTreeNodekeys$]);
            if (nl != null) {
              assume (forall k0_4: int ::
                
                Seq#Contains(Heap[nl, AVLTreeNodekeys$], k0_4) ==> Seq#Index(Heap[m, AVLTreeNodekeys$], 0) < k0_4
              );
            }
            assume state(Heap, Mask);
          assume nl == null || Heap[nl, $allocated];
          assume m == null || Heap[m, $allocated];
          assert {:msg "  The precondition of method AVLTreeNodepruneMin$ might not hold. The parameter newK$_54 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,889:7) [11991]"}
            newK$_54[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: this$_12.AVLTreeNodeleft$ := nl -- AVLTree.sil,891:5
        
        // -- Check definedness of this$_12.AVLTreeNodeleft$
          assert {:msg "  Assignment might fail. Receiver of this$_12.AVLTreeNodeleft$ might be null. (AVLTree.sil,891:5) [11992]"}
            this$_12 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,891:5) [11993]"}
            HasDirectPerm(Mask, this$_12, AVLTreeNodeleft$);
          assume state(Heap, Mask);
        Heap[this$_12, AVLTreeNodeleft$] := nl;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,891:5) [11994]"}
          FullPerm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_12, AVLTreeNodeleft$][$eps];
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_55  -- AVLTree.sil,892:5
        
        // -- Translation of statement fresh newK$_55)
          havoc newK$_55;
          assume (newK$_55[$frac] > 0.000000000 && newK$_55[$frac] < 0.001000000) && newK$_55[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_55) -- AVLTree.sil,893:5
        
        // -- Translating statement: bf := AVLTreeNodegetBalanceFactorI$(this$_12, newK$_55) -- AVLTree.sil,894:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          havoc bf;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_12 != null might not hold. (AVLTree.sil,894:7) [11995]"}
              this$_12 != null;
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion newK$_55 > none might not hold. (AVLTree.sil,894:7) [11996]"}
              NoPerm[$frac] < newK$_55[$frac] || (NoPerm[$frac] == newK$_55[$frac] && NoPerm[$eps] < newK$_55[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Assertion write > newK$_55 might not hold. (AVLTree.sil,894:7) [11997]"}
              newK$_55[$frac] < FullPerm[$frac] || (newK$_55[$frac] == FullPerm[$frac] && newK$_55[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_55 might not be positive. (AVLTree.sil,894:7) [11998]"}
              newK$_55[$frac] > 0.000000000 || (newK$_55[$frac] == 0.000000000 && newK$_55[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_12.AVLTreeNodeleft$ might be null. (AVLTree.sil,894:7) [11999]"}
              this$_12 != null;
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNodeleft$). (AVLTree.sil,894:7) [12000]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
            }
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_55 might not be positive. (AVLTree.sil,894:7) [12001]"}
                newK$_55[$frac] > 0.000000000 || (newK$_55[$frac] == 0.000000000 && newK$_55[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,894:7) [12002]"}
                Heap[this$_12, AVLTreeNodeleft$] != null;
            }
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_55 might not be positive. (AVLTree.sil,894:7) [12003]"}
              newK$_55[$frac] > 0.000000000 || (newK$_55[$frac] == 0.000000000 && newK$_55[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_12.AVLTreeNoderight$ might be null. (AVLTree.sil,894:7) [12004]"}
              this$_12 != null;
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNoderight$). (AVLTree.sil,894:7) [12005]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])], perm);
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Fraction newK$_55 might not be positive. (AVLTree.sil,894:7) [12006]"}
                newK$_55[$frac] > 0.000000000 || (newK$_55[$frac] == 0.000000000 && newK$_55[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,894:7) [12007]"}
                Heap[this$_12, AVLTreeNoderight$] != null;
            }
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            perm := NoPerm;
            perm := PermAdd(perm, newK$_55);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,894:7) [12008]"}
                Mask[this$_12, AVLTreeNodeleft$][$frac] > 0.000000000;
              assume perm[$frac] < Mask[this$_12, AVLTreeNodeleft$][$frac];
            }
            Mask[this$_12, AVLTreeNodeleft$] := PermSub(Mask[this$_12, AVLTreeNodeleft$], perm);
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, newK$_55);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,894:7) [12009]"}
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] > 0.000000000;
                assume perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac];
              }
              Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            perm := NoPerm;
            perm := PermAdd(perm, newK$_55);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,894:7) [12010]"}
                Mask[this$_12, AVLTreeNoderight$][$frac] > 0.000000000;
              assume perm[$frac] < Mask[this$_12, AVLTreeNoderight$][$frac];
            }
            Mask[this$_12, AVLTreeNoderight$] := PermSub(Mask[this$_12, AVLTreeNoderight$], perm);
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, newK$_55);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,894:7) [12011]"}
                  Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] > 0.000000000;
                assume perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac];
              }
              Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            perm := newK$_55;
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_12 != null;
            Mask[this$_12, AVLTreeNodeleft$] := PermAdd(Mask[this$_12, AVLTreeNodeleft$], perm);
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (Heap[this$_12, AVLTreeNodeleft$] != null) {
              perm := newK$_55;
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[this$_12, AVLTreeNodeleft$] != null;
              Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            perm := newK$_55;
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume this$_12 != null;
            Mask[this$_12, AVLTreeNoderight$] := PermAdd(Mask[this$_12, AVLTreeNoderight$], perm);
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              perm := FullPerm;
              Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])], perm);
              
              // -- Extra unfolding of predicate
                
            }
            if (Heap[this$_12, AVLTreeNoderight$] != null) {
              perm := newK$_55;
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume Heap[this$_12, AVLTreeNoderight$] != null;
              Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            assume bf == (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]);
            if (bf > 0) {
              assume Heap[this$_12, AVLTreeNodeleft$] != null;
            }
            if (bf < 0) {
              assume Heap[this$_12, AVLTreeNoderight$] != null;
            }
            assume state(Heap, Mask);
          assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactorI$ might not hold. The parameter newK$_55 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,894:7) [12012]"}
            newK$_55[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: if (bf == 0 - 2) -- AVLTree.sil,896:5
        if (bf == -2) {
          
          // -- Translating statement: fresh newK$_56  -- AVLTree.sil,897:7
            
            // -- Translation of statement fresh newK$_56)
              havoc newK$_56;
              assume (newK$_56[$frac] > 0.000000000 && newK$_56[$frac] < 0.001000000) && newK$_56[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_56) -- AVLTree.sil,898:7
            
            // -- Translating statement: r := AVLTreeNoderebalanceRight$(this$_12, newK$_56) -- AVLTree.sil,899:9
              PreCallHeap := Heap;
              PreCallMask := Mask;
              havoc r_1;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion this$_12 != null might not hold. (AVLTree.sil,899:9) [12013]"}
                  this$_12 != null;
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion newK$_56 > none might not hold. (AVLTree.sil,899:9) [12014]"}
                  NoPerm[$frac] < newK$_56[$frac] || (NoPerm[$frac] == newK$_56[$frac] && NoPerm[$eps] < newK$_56[$eps]);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion write > newK$_56 might not hold. (AVLTree.sil,899:9) [12015]"}
                  newK$_56[$frac] < FullPerm[$frac] || (newK$_56[$frac] == FullPerm[$frac] && newK$_56[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,899:9) [12016]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodekey$ might be null. (AVLTree.sil,899:9) [12017]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodekey$. (AVLTree.sil,899:9) [12018]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodekey$][$eps]);
                }
                Mask[this$_12, AVLTreeNodekey$] := PermSub(Mask[this$_12, AVLTreeNodekey$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,899:9) [12019]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,899:9) [12020]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,899:9) [12021]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodeheight$][$eps]);
                }
                Mask[this$_12, AVLTreeNodeheight$] := PermSub(Mask[this$_12, AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,899:9) [12022]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodeleft$ might be null. (AVLTree.sil,899:9) [12023]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,899:9) [12024]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodeleft$][$eps]);
                }
                Mask[this$_12, AVLTreeNodeleft$] := PermSub(Mask[this$_12, AVLTreeNodeleft$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,899:9) [12025]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNoderight$ might be null. (AVLTree.sil,899:9) [12026]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,899:9) [12027]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNoderight$][$eps]);
                }
                Mask[this$_12, AVLTreeNoderight$] := PermSub(Mask[this$_12, AVLTreeNoderight$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,899:9) [12028]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodekeys$ might be null. (AVLTree.sil,899:9) [12029]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodekeys$. (AVLTree.sil,899:9) [12030]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodekeys$][$eps]);
                }
                Mask[this$_12, AVLTreeNodekeys$] := PermSub(Mask[this$_12, AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,899:9) [12031]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,899:9) [12032]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodebalanceFactor$. (AVLTree.sil,899:9) [12033]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[this$_12, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNodeleft$). (AVLTree.sil,899:9) [12034]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,899:9) [12035]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,899:9) [12036]"}
                    Heap[this$_12, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,899:9) [12037]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,899:9) [12038]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,899:9) [12039]"}
                    Heap[this$_12, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,899:9) [12040]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,899:9) [12041]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,899:9) [12042]"}
                    Heap[this$_12, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,899:9) [12043]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (forall k: Int :: true && k in this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_12.AVLTreeNodekey$)) might not hold. (AVLTree.sil,899:9) [12044]"}
                    (forall k: int ::
                    
                    Seq#Contains(Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], k) ==> k < Heap[this$_12, AVLTreeNodekey$]
                  );
                }
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion this$_12.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,899:9) [12045]"}
                  Heap[this$_12, AVLTreeNoderight$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, FullPerm);
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNoderight$). (AVLTree.sil,899:9) [12046]"}
                    (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps]);
                }
                Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,899:9) [12047]"}
                  Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,899:9) [12048]"}
                  Heap[this$_12, AVLTreeNoderight$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,899:9) [12049]"}
                    (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                }
                Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,899:9) [12050]"}
                  Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,899:9) [12051]"}
                  Heap[this$_12, AVLTreeNoderight$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,899:9) [12052]"}
                    (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                }
                Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,899:9) [12053]"}
                  Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,899:9) [12054]"}
                  Heap[this$_12, AVLTreeNoderight$] != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,899:9) [12055]"}
                    (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_12.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_12.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,899:9) [12056]"}
                  (forall k1_3: int ::
                  
                  Seq#Contains(Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_12, AVLTreeNodekey$] < k1_3
                );
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. Assertion (this$_12.AVLTreeNodeleft$ == null ? 0 : this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_12.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2 might not hold. (AVLTree.sil,899:9) [12057]"}
                  (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                assume r_1 != null;
                perm := FullPerm;
                Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
                
                // -- Extra unfolding of predicate
                  
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume r_1 != null;
                Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
                assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
                assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_12, AVLTreeNodekey$])), PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$]));
                assume state(Heap, Mask);
              assume r_1 == null || Heap[r_1, $allocated];
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRight$ might not hold. The parameter newK$_56 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,899:9) [12058]"}
                newK$_56[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: assert (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) -- AVLTree.sil,901:7
            
            // -- Check definedness of (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
              if (r_1 != null) {
                assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,901:7) [12059]"}
                  r_1 != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,901:7) [12060]"}
                  HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
                assert {:msg "  Assert might fail. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,901:7) [12061]"}
                  this$_12 != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,901:7) [12062]"}
                  HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
                if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$])) {
                  assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,901:7) [12063]"}
                    r_1 != null;
                  assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,901:7) [12064]"}
                    HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
                  assert {:msg "  Assert might fail. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,901:7) [12065]"}
                    this$_12 != null;
                  assert {:msg "  Assert might fail. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,901:7) [12066]"}
                    HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
                }
              }
              assume state(Heap, Mask);
            // Phase 1: pure assertions and fixed permissions
            if (r_1 != null) {
              assert {:msg "  Assert might fail. Assertion (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) might not hold. (AVLTree.sil,901:7) [12067]"}
                Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] - 1;
            }
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: fresh newK$_57  -- AVLTree.sil,903:7
            
            // -- Translation of statement fresh newK$_57)
              havoc newK$_57;
              assume (newK$_57[$frac] > 0.000000000 && newK$_57[$frac] < 0.001000000) && newK$_57[$eps] == 0.000000000;
            assume state(Heap, Mask);
          
          // -- Translating statement: constraining(newK$_57) -- AVLTree.sil,904:7
            
            // -- Translating statement: AVLTreeNodeclose$(this$_12, newK$_57) -- AVLTree.sil,905:9
              PreCallHeap := Heap;
              PreCallMask := Mask;
              
              // -- Exhaling precondition
                havoc ExhaleHeap;
                // Phase 1: pure assertions and fixed permissions
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_12 != null might not hold. (AVLTree.sil,905:9) [12068]"}
                  this$_12 != null;
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_57 > none might not hold. (AVLTree.sil,905:9) [12069]"}
                  NoPerm[$frac] < newK$_57[$frac] || (NoPerm[$frac] == newK$_57[$frac] && NoPerm[$eps] < newK$_57[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_57 might not hold. (AVLTree.sil,905:9) [12070]"}
                  newK$_57[$frac] < FullPerm[$frac] || (newK$_57[$frac] == FullPerm[$frac] && newK$_57[$eps] < FullPerm[$eps]);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,905:9) [12071]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodekey$ might be null. (AVLTree.sil,905:9) [12072]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodekey$. (AVLTree.sil,905:9) [12073]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodekey$][$eps]);
                }
                Mask[this$_12, AVLTreeNodekey$] := PermSub(Mask[this$_12, AVLTreeNodekey$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,905:9) [12074]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,905:9) [12075]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,905:9) [12076]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodeheight$][$eps]);
                }
                Mask[this$_12, AVLTreeNodeheight$] := PermSub(Mask[this$_12, AVLTreeNodeheight$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,905:9) [12077]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$ might be null. (AVLTree.sil,905:9) [12078]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$. (AVLTree.sil,905:9) [12079]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodeleft$][$eps]);
                }
                Mask[this$_12, AVLTreeNodeleft$] := PermSub(Mask[this$_12, AVLTreeNodeleft$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,905:9) [12080]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$ might be null. (AVLTree.sil,905:9) [12081]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$. (AVLTree.sil,905:9) [12082]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNoderight$][$eps]);
                }
                Mask[this$_12, AVLTreeNoderight$] := PermSub(Mask[this$_12, AVLTreeNoderight$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,905:9) [12083]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodekeys$ might be null. (AVLTree.sil,905:9) [12084]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodekeys$. (AVLTree.sil,905:9) [12085]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodekeys$][$eps]);
                }
                Mask[this$_12, AVLTreeNodekeys$] := PermSub(Mask[this$_12, AVLTreeNodekeys$], perm);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,905:9) [12086]"}
                  Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,905:9) [12087]"}
                  this$_12 != null;
                perm := NoPerm;
                perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodebalanceFactor$. (AVLTree.sil,905:9) [12088]"}
                    (perm[$frac] < Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_12, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_12, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_12, AVLTreeNodebalanceFactor$][$eps]);
                }
                Mask[this$_12, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNodeleft$). (AVLTree.sil,905:9) [12089]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNodeleft$])], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,905:9) [12090]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,905:9) [12091]"}
                    Heap[this$_12, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,905:9) [12092]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,905:9) [12093]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,905:9) [12094]"}
                    Heap[this$_12, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,905:9) [12095]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,905:9) [12096]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,905:9) [12097]"}
                    Heap[this$_12, AVLTreeNodeleft$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,905:9) [12098]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[this$_12, AVLTreeNodeleft$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_12.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_12.AVLTreeNodekey$)) might not hold. (AVLTree.sil,905:9) [12099]"}
                    (forall k0_5: int ::
                    
                    Seq#Contains(Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_5) ==> k0_5 < Heap[this$_12, AVLTreeNodekey$]
                  );
                }
                if (Heap[this$_12, AVLTreeNoderight$] != null) {
                  perm := NoPerm;
                  perm := PermAdd(perm, FullPerm);
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_12.AVLTreeNoderight$). (AVLTree.sil,905:9) [12100]"}
                      (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])][$eps]);
                  }
                  Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_12, AVLTreeNoderight$])], perm);
                }
                if (Heap[this$_12, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,905:9) [12101]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,905:9) [12102]"}
                    Heap[this$_12, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,905:9) [12103]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
                }
                if (Heap[this$_12, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,905:9) [12104]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,905:9) [12105]"}
                    Heap[this$_12, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,905:9) [12106]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                }
                if (Heap[this$_12, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,905:9) [12107]"}
                    Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_12.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,905:9) [12108]"}
                    Heap[this$_12, AVLTreeNoderight$] != null;
                  perm := NoPerm;
                  perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_12.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,905:9) [12109]"}
                      (perm[$frac] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
                  }
                  Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
                }
                if (Heap[this$_12, AVLTreeNoderight$] != null) {
                  assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_12.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_12.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,905:9) [12110]"}
                    (forall k1_4: int ::
                    
                    Seq#Contains(Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$], k1_4) ==> Heap[this$_12, AVLTreeNodekey$] < k1_4
                  );
                }
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_12.AVLTreeNodeleft$ == null ? 0 : this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_12.AVLTreeNoderight$ == null ? 0 : this$_12.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,905:9) [12111]"}
                  (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
                assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_12.AVLTreeNodeleft$ == null ? 0 : this$_12.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_12.AVLTreeNoderight$ == null ? 0 : this$_12.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,905:9) [12112]"}
                  (if Heap[this$_12, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_12, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
                // Phase 2: abstract read permissions (and scaled abstract read permissions)
                // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
                // Finish exhale
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
              
              // -- Inhaling postcondition
                perm := FullPerm;
                Mask[null, AVLTreeNodevalid$(this$_12)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_12)], perm);
                
                // -- Extra unfolding of predicate
                  
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_12 != null;
                Mask[this$_12, AVLTreeNodeheight$] := PermAdd(Mask[this$_12, AVLTreeNodeheight$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_12 != null;
                Mask[this$_12, AVLTreeNodekeys$] := PermAdd(Mask[this$_12, AVLTreeNodekeys$], perm);
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume this$_12 != null;
                Mask[this$_12, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_12, AVLTreeNodebalanceFactor$], perm);
                assume Seq#Equal(Heap[this$_12, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_12, AVLTreeNodekey$])), (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodekeys$])));
                assume Heap[this$_12, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
                assume Heap[this$_12, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_12, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_12, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_12, AVLTreeNoderight$], AVLTreeNodeheight$]);
                assume state(Heap, Mask);
              assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_57 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,905:9) [12113]"}
                newK$_57[$eps] == 0.000000000;
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: r := this$_12 -- AVLTree.sil,907:7
            r_1 := this$_12;
            assume state(Heap, Mask);
          
          // -- Translating statement: assert (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) -- AVLTree.sil,908:7
            
            // -- Check definedness of (r != null) ==> (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1)
              if (r_1 != null) {
                assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,908:7) [12114]"}
                  r_1 != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,908:7) [12115]"}
                  HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
                assert {:msg "  Assert might fail. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,908:7) [12116]"}
                  this$_12 != null;
                assert {:msg "  Assert might fail. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,908:7) [12117]"}
                  HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
                if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$])) {
                  assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,908:7) [12118]"}
                    r_1 != null;
                  assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,908:7) [12119]"}
                    HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
                  assert {:msg "  Assert might fail. Receiver of this$_12.AVLTreeNodeheight$ might be null. (AVLTree.sil,908:7) [12120]"}
                    this$_12 != null;
                  assert {:msg "  Assert might fail. There might be insufficient permission to access this$_12.AVLTreeNodeheight$. (AVLTree.sil,908:7) [12121]"}
                    HasDirectPerm(old(Mask), this$_12, AVLTreeNodeheight$);
                }
              }
              assume state(Heap, Mask);
            // Phase 1: pure assertions and fixed permissions
            if (r_1 != null) {
              assert {:msg "  Assert might fail. Assertion (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) might not hold. (AVLTree.sil,908:7) [12122]"}
                Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] - 1;
            }
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: assert (r != null) ==> (forall k2: Int :: true && k2 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k2)) -- AVLTree.sil,910:5
        
        // -- Check definedness of (r != null) ==> (forall k2: Int :: true && k2 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k2))
          if (r_1 != null) {
            assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,910:5) [12123]"}
              r_1 != null;
            assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,910:5) [12124]"}
              HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
            if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k2_2)) {
              assert {:msg "  Assert might fail. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,910:5) [12125]"}
                m != null;
              assert {:msg "  Assert might fail. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,910:5) [12126]"}
                HasDirectPerm(Mask, m, AVLTreeNodekeys$);
            }
          }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        if (r_1 != null) {
          assert {:msg "  Assert might fail. Assertion (forall k2: Int :: true && k2 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k2)) might not hold. (AVLTree.sil,910:5) [12127]"}
            (forall k2_1: int ::
            
            Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k2_1) ==> Seq#Index(Heap[m, AVLTreeNodekeys$], 0) < k2_1
          );
        }
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    if (r_1 != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,845:11) [12128]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,846:11) [12129]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,846:11) [12130]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,846:11) [12131]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
      }
      Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,847:11) [12132]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,847:11) [12133]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,847:11) [12134]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
      }
      Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,848:11) [12135]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,848:11) [12136]"}
        r_1 != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,848:11) [12137]"}
          (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_12.AVLTreeNodeheight$) - 1) might not hold. (AVLTree.sil,849:11) [12138]"}
        Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[this$_12, AVLTreeNodeheight$] - 1;
    }
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion |r.AVLTreeNodekeys$| + 1 == |old(this$_12.AVLTreeNodekeys$)| might not hold. (AVLTree.sil,850:11) [12139]"}
        Seq#Length(Heap[r_1, AVLTreeNodekeys$]) + 1 == Seq#Length(old(Heap)[this$_12, AVLTreeNodekeys$]);
    }
    if (old(Heap)[this$_12, AVLTreeNodeheight$] > 1) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion r != null might not hold. (AVLTree.sil,851:11) [12140]"}
        r_1 != null;
    }
    if (old(Heap)[this$_12, AVLTreeNodeheight$] == 1) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion r == null might not hold. (AVLTree.sil,852:11) [12141]"}
        r_1 == null;
    }
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion (old(this$_12.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$)) || (old(this$_12.AVLTreeNodeheight$) == (r == null ? 0 : r.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,853:11) [12142]"}
      old(Heap)[this$_12, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) || old(Heap)[this$_12, AVLTreeNodeheight$] == (if r_1 == null then 0 else Heap[r_1, AVLTreeNodeheight$]) + 1;
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion m != null might not hold. (AVLTree.sil,854:11) [12143]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(m). (AVLTree.sil,855:11) [12144]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(m)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(m)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(m)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(m)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(m)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(m)] := PermSub(Mask[null, AVLTreeNodevalid$(m)], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,856:11) [12145]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Receiver of m.AVLTreeNodekeys$ might be null. (AVLTree.sil,856:11) [12146]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access m.AVLTreeNodekeys$. (AVLTree.sil,856:11) [12147]"}
        (perm[$frac] < Mask[m, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[m, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[m, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[m, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[m, AVLTreeNodekeys$][$eps]);
    }
    Mask[m, AVLTreeNodekeys$] := PermSub(Mask[m, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,857:11) [12148]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Receiver of m.AVLTreeNodeheight$ might be null. (AVLTree.sil,857:11) [12149]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access m.AVLTreeNodeheight$. (AVLTree.sil,857:11) [12150]"}
        (perm[$frac] < Mask[m, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[m, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[m, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[m, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[m, AVLTreeNodeheight$][$eps]);
    }
    Mask[m, AVLTreeNodeheight$] := PermSub(Mask[m, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,858:11) [12151]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Receiver of m.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,858:11) [12152]"}
      m != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. There might be insufficient permission to access m.AVLTreeNodebalanceFactor$. (AVLTree.sil,858:11) [12153]"}
        (perm[$frac] < Mask[m, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[m, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[m, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[m, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[m, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[m, AVLTreeNodebalanceFactor$] := PermSub(Mask[m, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion m.AVLTreeNodeheight$ == 1 might not hold. (AVLTree.sil,859:11) [12154]"}
      Heap[m, AVLTreeNodeheight$] == 1;
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion |m.AVLTreeNodekeys$| == 1 might not hold. (AVLTree.sil,860:11) [12155]"}
      Seq#Length(Heap[m, AVLTreeNodekeys$]) == 1;
    assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion m.AVLTreeNodekeys$ ++ (r == null ? Seq() : r.AVLTreeNodekeys$) == old(this$_12.AVLTreeNodekeys$) might not hold. (AVLTree.sil,861:11) [12156]"}
      Seq#Equal(Seq#Append(Heap[m, AVLTreeNodekeys$], (if r_1 == null then (Seq#Empty(): Seq_ int) else Heap[r_1, AVLTreeNodekeys$])), old(Heap)[this$_12, AVLTreeNodekeys$]);
    if (r_1 != null) {
      assert {:msg "  Postcondition of AVLTreeNodepruneMin$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodekeys$ ==> (m.AVLTreeNodekeys$[0] < k0)) might not hold. (AVLTree.sil,862:11) [12157]"}
        (forall k0_2: int ::
        
        Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k0_2) ==> Seq#Index(Heap[m, AVLTreeNodekeys$], 0) < k0_2
      );
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodehas$
// ==================================================

procedure AVLTreeNodehas$(this$_13: Ref, k$_9: Perm, k: int) returns (b_2: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var oldVersion: int;
  var newVersion: int;
  var newK$_28: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_13: Ref;
  var ExhaleHeap: HeapType;
  var newK$_29: Perm;
  var arg_this$_13_1: Ref;
  var freshVersion: int;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_13 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_9[$frac] || (NoPerm[$frac] == k$_9[$frac] && NoPerm[$eps] < k$_9[$eps]);
    assume state(Heap, Mask);
    assume k$_9[$frac] < FullPerm[$frac] || (k$_9[$frac] == FullPerm[$frac] && k$_9[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_13)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_13)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := k$_9;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodekeys$] := PermAdd(Mask[this$_13, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_13)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_13)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := k$_9;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodekeys$] := PermAdd(Mask[this$_13, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of b == k in this$_13.AVLTreeNodekeys$
      assert {:msg "  Contract might not be well-formed. Receiver of this$_13.AVLTreeNodekeys$ might be null. (AVLTree.sil,922:11) [12158]"}
        this$_13 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_13.AVLTreeNodekeys$. (AVLTree.sil,922:11) [12159]"}
        HasDirectPerm(Mask, this$_13, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    assume b_2 == Seq#Contains(Heap[this$_13, AVLTreeNodekeys$], k);
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_13 == null || Heap[this$_13, $allocated];
    assume k$_9[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_13), write) -- AVLTree.sil,930:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_13));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_13). (AVLTree.sil,930:3) [12162]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_13)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_13)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_13)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_13)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_13)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_13)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_13)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(this$_13))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(this$_13)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(this$_13)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodekey$] := PermAdd(Mask[this$_13, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodeheight$] := PermAdd(Mask[this$_13, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodeleft$] := PermAdd(Mask[this$_13, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNoderight$] := PermAdd(Mask[this$_13, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodekeys$] := PermAdd(Mask[this$_13, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_13 != null;
    Mask[this$_13, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_13, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_13, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_13, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_13, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[this$_13, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])]);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_13, AVLTreeNoderight$] != null;
      Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_13, AVLTreeNoderight$] != null;
      Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_13, AVLTreeNoderight$] != null;
      Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[this$_13, AVLTreeNodekey$] < rk
      );
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assume Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[this$_13, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_13, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_13, AVLTreeNodekey$])), (if Heap[this$_13, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[this$_13, AVLTreeNodekeys$], Heap[this$_13, AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[this$_13, AVLTreeNodekeys$], kk) == ((Heap[this$_13, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[this$_13, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[this$_13, AVLTreeNodekey$]))
    );
    assume Heap[this$_13, AVLTreeNodeheight$] == (if (if Heap[this$_13, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_13, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_13, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_13, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[this$_13, AVLTreeNodebalanceFactor$] == (if Heap[this$_13, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_13, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[this$_13, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[this$_13, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[this$_13, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (k == this$_13.AVLTreeNodekey$) -- AVLTree.sil,931:3
    
    // -- Check definedness of k == this$_13.AVLTreeNodekey$
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_13.AVLTreeNodekey$. (AVLTree.sil,931:7) [12163]"}
        HasDirectPerm(Mask, this$_13, AVLTreeNodekey$);
      assume state(Heap, Mask);
    if (k == Heap[this$_13, AVLTreeNodekey$]) {
      
      // -- Translating statement: b := true -- AVLTree.sil,932:5
        b_2 := true;
        assume state(Heap, Mask);
      
      // -- Translating statement: assert Seq(this$_13.AVLTreeNodekey$)[0] == k -- AVLTree.sil,933:5
        
        // -- Check definedness of Seq(this$_13.AVLTreeNodekey$)[0] == k
          assert {:msg "  Assert might fail. Receiver of this$_13.AVLTreeNodekey$ might be null. (AVLTree.sil,933:5) [12164]"}
            this$_13 != null;
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_13.AVLTreeNodekey$. (AVLTree.sil,933:5) [12165]"}
            HasDirectPerm(Mask, this$_13, AVLTreeNodekey$);
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  Assert might fail. Assertion Seq(this$_13.AVLTreeNodekey$)[0] == k might not hold. (AVLTree.sil,933:5) [12166]"}
          Seq#Index(Seq#Singleton(Heap[this$_13, AVLTreeNodekey$]), 0) == k;
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: if (k < this$_13.AVLTreeNodekey$) -- AVLTree.sil,934:5
        
        // -- Check definedness of k < this$_13.AVLTreeNodekey$
          assert {:msg "  Conditional statement might fail. Receiver of this$_13.AVLTreeNodekey$ might be null. (AVLTree.sil,934:12) [12167]"}
            this$_13 != null;
          assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_13.AVLTreeNodekey$. (AVLTree.sil,934:12) [12168]"}
            HasDirectPerm(Mask, this$_13, AVLTreeNodekey$);
          assume state(Heap, Mask);
        if (k < Heap[this$_13, AVLTreeNodekey$]) {
          
          // -- Translating statement: if (this$_13.AVLTreeNodeleft$ != null) -- AVLTree.sil,935:5
            
            // -- Check definedness of this$_13.AVLTreeNodeleft$ != null
              assert {:msg "  Conditional statement might fail. Receiver of this$_13.AVLTreeNodeleft$ might be null. (AVLTree.sil,935:9) [12169]"}
                this$_13 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_13.AVLTreeNodeleft$. (AVLTree.sil,935:9) [12170]"}
                HasDirectPerm(Mask, this$_13, AVLTreeNodeleft$);
              assume state(Heap, Mask);
            if (Heap[this$_13, AVLTreeNodeleft$] != null) {
              
              // -- Translating statement: fresh newK$_28  -- AVLTree.sil,936:7
                
                // -- Translation of statement fresh newK$_28)
                  havoc newK$_28;
                  assume (newK$_28[$frac] > 0.000000000 && newK$_28[$frac] < 0.001000000) && newK$_28[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_28) -- AVLTree.sil,937:7
                
                // -- Translating statement: b := AVLTreeNodehas$(this$_13.AVLTreeNodeleft$, newK$_28, k) -- AVLTree.sil,938:9
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_13.AVLTreeNodeleft$
                    assert {:msg "  Method call might fail. Receiver of this$_13.AVLTreeNodeleft$ might be null. (AVLTree.sil,938:9) [12171]"}
                      this$_13 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_13.AVLTreeNodeleft$. (AVLTree.sil,938:9) [12172]"}
                      HasDirectPerm(Mask, this$_13, AVLTreeNodeleft$);
                    assume state(Heap, Mask);
                  arg_this$_13 := Heap[this$_13, AVLTreeNodeleft$];
                  havoc b_2;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion this$_13.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,938:9) [12173]"}
                      Heap[this$_13, AVLTreeNodeleft$] != null;
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion newK$_28 > none might not hold. (AVLTree.sil,938:9) [12174]"}
                      NoPerm[$frac] < newK$_28[$frac] || (NoPerm[$frac] == newK$_28[$frac] && NoPerm[$eps] < newK$_28[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion write > newK$_28 might not hold. (AVLTree.sil,938:9) [12175]"}
                      newK$_28[$frac] < FullPerm[$frac] || (newK$_28[$frac] == FullPerm[$frac] && newK$_28[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_13.AVLTreeNodeleft$). (AVLTree.sil,938:9) [12176]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Fraction newK$_28 might not be positive. (AVLTree.sil,938:9) [12177]"}
                      newK$_28[$frac] > 0.000000000 || (newK$_28[$frac] == 0.000000000 && newK$_28[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Receiver of this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,938:9) [12178]"}
                      Heap[this$_13, AVLTreeNodeleft$] != null;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    perm := NoPerm;
                    perm := PermAdd(perm, newK$_28);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. There might be insufficient permission to access this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,938:9) [12179]"}
                        Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] > 0.000000000;
                      assume perm[$frac] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac];
                    }
                    Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(arg_this$_13)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_13)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := newK$_28;
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume arg_this$_13 != null;
                    Mask[arg_this$_13, AVLTreeNodekeys$] := PermAdd(Mask[arg_this$_13, AVLTreeNodekeys$], perm);
                    assume b_2 == Seq#Contains(Heap[arg_this$_13, AVLTreeNodekeys$], k);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. The parameter newK$_28 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,938:9) [12180]"}
                    newK$_28[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: b := false -- AVLTree.sil,941:7
                b_2 := false;
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: if (this$_13.AVLTreeNoderight$ != null) -- AVLTree.sil,943:5
            
            // -- Check definedness of this$_13.AVLTreeNoderight$ != null
              assert {:msg "  Conditional statement might fail. Receiver of this$_13.AVLTreeNoderight$ might be null. (AVLTree.sil,943:12) [12181]"}
                this$_13 != null;
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this$_13.AVLTreeNoderight$. (AVLTree.sil,943:12) [12182]"}
                HasDirectPerm(Mask, this$_13, AVLTreeNoderight$);
              assume state(Heap, Mask);
            if (Heap[this$_13, AVLTreeNoderight$] != null) {
              
              // -- Translating statement: fresh newK$_29  -- AVLTree.sil,944:5
                
                // -- Translation of statement fresh newK$_29)
                  havoc newK$_29;
                  assume (newK$_29[$frac] > 0.000000000 && newK$_29[$frac] < 0.001000000) && newK$_29[$eps] == 0.000000000;
                assume state(Heap, Mask);
              
              // -- Translating statement: constraining(newK$_29) -- AVLTree.sil,945:5
                
                // -- Translating statement: b := AVLTreeNodehas$(this$_13.AVLTreeNoderight$, newK$_29, k) -- AVLTree.sil,946:7
                  PreCallHeap := Heap;
                  PreCallMask := Mask;
                  
                  // -- Check definedness of this$_13.AVLTreeNoderight$
                    assert {:msg "  Method call might fail. Receiver of this$_13.AVLTreeNoderight$ might be null. (AVLTree.sil,946:7) [12183]"}
                      this$_13 != null;
                    assert {:msg "  Method call might fail. There might be insufficient permission to access this$_13.AVLTreeNoderight$. (AVLTree.sil,946:7) [12184]"}
                      HasDirectPerm(Mask, this$_13, AVLTreeNoderight$);
                    assume state(Heap, Mask);
                  arg_this$_13_1 := Heap[this$_13, AVLTreeNoderight$];
                  havoc b_2;
                  
                  // -- Exhaling precondition
                    havoc ExhaleHeap;
                    // Phase 1: pure assertions and fixed permissions
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion this$_13.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,946:7) [12185]"}
                      Heap[this$_13, AVLTreeNoderight$] != null;
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion newK$_29 > none might not hold. (AVLTree.sil,946:7) [12186]"}
                      NoPerm[$frac] < newK$_29[$frac] || (NoPerm[$frac] == newK$_29[$frac] && NoPerm[$eps] < newK$_29[$eps]);
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Assertion write > newK$_29 might not hold. (AVLTree.sil,946:7) [12187]"}
                      newK$_29[$frac] < FullPerm[$frac] || (newK$_29[$frac] == FullPerm[$frac] && newK$_29[$eps] < FullPerm[$eps]);
                    perm := NoPerm;
                    perm := PermAdd(perm, FullPerm);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_13.AVLTreeNoderight$). (AVLTree.sil,946:7) [12188]"}
                        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$eps]);
                    }
                    Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])], perm);
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Fraction newK$_29 might not be positive. (AVLTree.sil,946:7) [12189]"}
                      newK$_29[$frac] > 0.000000000 || (newK$_29[$frac] == 0.000000000 && newK$_29[$eps] > 0.000000000);
                    assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. Receiver of this$_13.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,946:7) [12190]"}
                      Heap[this$_13, AVLTreeNoderight$] != null;
                    // Phase 2: abstract read permissions (and scaled abstract read permissions)
                    perm := NoPerm;
                    perm := PermAdd(perm, newK$_29);
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. There might be insufficient permission to access this$_13.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,946:7) [12191]"}
                        Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] > 0.000000000;
                      assume perm[$frac] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$frac];
                    }
                    Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
                    // Finish exhale
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                  
                  // -- Inhaling postcondition
                    perm := FullPerm;
                    Mask[null, AVLTreeNodevalid$(arg_this$_13_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_13_1)], perm);
                    
                    // -- Extra unfolding of predicate
                      
                    perm := newK$_29;
                    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                    assume arg_this$_13_1 != null;
                    Mask[arg_this$_13_1, AVLTreeNodekeys$] := PermAdd(Mask[arg_this$_13_1, AVLTreeNodekeys$], perm);
                    assume b_2 == Seq#Contains(Heap[arg_this$_13_1, AVLTreeNodekeys$], k);
                    assume state(Heap, Mask);
                  assert {:msg "  The precondition of method AVLTreeNodehas$ might not hold. The parameter newK$_29 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,946:7) [12192]"}
                    newK$_29[$eps] == 0.000000000;
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: b := false -- AVLTree.sil,949:5
                b_2 := false;
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreeNodevalid$(this$_13), write) -- AVLTree.sil,951:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_13));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,951:3) [12193]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodekey$ might be null. (AVLTree.sil,951:3) [12194]"}
      this$_13 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodekey$. (AVLTree.sil,951:3) [12195]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNodekey$][$eps]);
    }
    Mask[this$_13, AVLTreeNodekey$] := PermSub(Mask[this$_13, AVLTreeNodekey$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12196]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodeheight$ might be null. (AVLTree.sil,951:3) [12197]"}
      this$_13 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodeheight$. (AVLTree.sil,951:3) [12198]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNodeheight$][$eps]);
    }
    Mask[this$_13, AVLTreeNodeheight$] := PermSub(Mask[this$_13, AVLTreeNodeheight$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,951:3) [12199]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodeleft$ might be null. (AVLTree.sil,951:3) [12200]"}
      this$_13 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodeleft$. (AVLTree.sil,951:3) [12201]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNodeleft$][$eps]);
    }
    Mask[this$_13, AVLTreeNodeleft$] := PermSub(Mask[this$_13, AVLTreeNodeleft$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,951:3) [12202]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNoderight$ might be null. (AVLTree.sil,951:3) [12203]"}
      this$_13 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNoderight$. (AVLTree.sil,951:3) [12204]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNoderight$][$eps]);
    }
    Mask[this$_13, AVLTreeNoderight$] := PermSub(Mask[this$_13, AVLTreeNoderight$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12205]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodekeys$ might be null. (AVLTree.sil,951:3) [12206]"}
      this$_13 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodekeys$. (AVLTree.sil,951:3) [12207]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNodekeys$][$eps]);
    }
    Mask[this$_13, AVLTreeNodekeys$] := PermSub(Mask[this$_13, AVLTreeNodekeys$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12208]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,951:3) [12209]"}
      this$_13 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodebalanceFactor$. (AVLTree.sil,951:3) [12210]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[this$_13, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_13, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_13.AVLTreeNodeleft$). (AVLTree.sil,951:3) [12213]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12214]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,951:3) [12215]"}
        Heap[this$_13, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,951:3) [12216]"}
          (perm[$frac] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12217]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,951:3) [12218]"}
        Heap[this$_13, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,951:3) [12219]"}
          (perm[$frac] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12220]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,951:3) [12221]"}
        Heap[this$_13, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,951:3) [12222]"}
          (perm[$frac] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion (forall lk: Int :: true && lk in this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (lk < this$_13.AVLTreeNodekey$)) might not hold. (AVLTree.sil,951:3) [12223]"}
        (forall lk_1: int ::
        
        Seq#Contains(Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < Heap[this$_13, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,951:3) [12224]"}
        Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_13.AVLTreeNoderight$). (AVLTree.sil,951:3) [12227]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])]);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12228]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,951:3) [12229]"}
        Heap[this$_13, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,951:3) [12230]"}
          (perm[$frac] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12231]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,951:3) [12232]"}
        Heap[this$_13, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,951:3) [12233]"}
          (perm[$frac] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,951:3) [12234]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Receiver of this$_13.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,951:3) [12235]"}
        Heap[this$_13, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. There might be insufficient permission to access this$_13.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,951:3) [12236]"}
          (perm[$frac] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion (forall rk: Int :: true && rk in this$_13.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_13.AVLTreeNodekey$ < rk)) might not hold. (AVLTree.sil,951:3) [12237]"}
        (forall rk_1: int ::
        
        Seq#Contains(Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> Heap[this$_13, AVLTreeNodekey$] < rk_1
      );
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNoderight$.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,951:3) [12238]"}
        Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodekeys$ == (this$_13.AVLTreeNodeleft$ == null ? Seq() : this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_13.AVLTreeNodekey$) ++ (this$_13.AVLTreeNoderight$ == null ? Seq() : this$_13.AVLTreeNoderight$.AVLTreeNodekeys$) might not hold. (AVLTree.sil,951:3) [12239]"}
      Seq#Equal(Heap[this$_13, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_13, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_13, AVLTreeNodekey$])), (if Heap[this$_13, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodekey$ in this$_13.AVLTreeNodekeys$ might not hold. (AVLTree.sil,951:3) [12240]"}
      Seq#Contains(Heap[this$_13, AVLTreeNodekeys$], Heap[this$_13, AVLTreeNodekey$]);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion (forall kk: Int :: true ==> (kk in this$_13.AVLTreeNodekeys$ == (this$_13.AVLTreeNodeleft$ != null) && kk in this$_13.AVLTreeNodeleft$.AVLTreeNodekeys$ || ((this$_13.AVLTreeNoderight$ != null) && kk in this$_13.AVLTreeNoderight$.AVLTreeNodekeys$ || (kk == this$_13.AVLTreeNodekey$)))) might not hold. (AVLTree.sil,951:3) [12241]"}
      (forall kk_1: int ::
      
      Seq#Contains(Heap[this$_13, AVLTreeNodekeys$], kk_1) == ((Heap[this$_13, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((Heap[this$_13, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == Heap[this$_13, AVLTreeNodekey$]))
    );
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodeheight$ == ((this$_13.AVLTreeNodeleft$ == null ? 0 : this$_13.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_13.AVLTreeNoderight$ == null ? 0 : this$_13.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_13.AVLTreeNodeleft$ == null ? 0 : this$_13.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_13.AVLTreeNoderight$ == null ? 0 : this$_13.AVLTreeNoderight$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,951:3) [12242]"}
      Heap[this$_13, AVLTreeNodeheight$] == (if (if Heap[this$_13, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_13, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_13, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_13, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodebalanceFactor$ == (this$_13.AVLTreeNodeleft$ == null ? 0 : this$_13.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_13.AVLTreeNoderight$ == null ? 0 : this$_13.AVLTreeNoderight$.AVLTreeNodeheight$) might not hold. (AVLTree.sil,951:3) [12243]"}
      Heap[this$_13, AVLTreeNodebalanceFactor$] == (if Heap[this$_13, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_13, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodebalanceFactor$ <= 1 might not hold. (AVLTree.sil,951:3) [12244]"}
      Heap[this$_13, AVLTreeNodebalanceFactor$] <= 1;
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodebalanceFactor$ >= 0 - 1 might not hold. (AVLTree.sil,951:3) [12245]"}
      Heap[this$_13, AVLTreeNodebalanceFactor$] >= -1;
    assert {:msg "  Folding AVLTreeNodevalid$(this$_13) might fail. Assertion this$_13.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,951:3) [12246]"}
      Heap[this$_13, AVLTreeNodeheight$] > 0;
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_13, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_13)], Heap[this$_13, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_13, AVLTreeNoderight$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_13)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_13)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(this$_13)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreeNodevalid$(this$_13)] := freshVersion;
    Heap[null, AVLTreeNodevalid$#sm(this$_13)][this$_13, AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_13)][this$_13, AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_13)][this$_13, AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_13)][this$_13, AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_13)][this$_13, AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_13)][this$_13, AVLTreeNodebalanceFactor$] := true;
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_14: Ref, f_17: (Field A B) ::
        { newPMask[o_14, f_17] }
        Heap[null, AVLTreeNodevalid$#sm(this$_13)][o_14, f_17] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_13, AVLTreeNodeleft$])][o_14, f_17] ==> newPMask[o_14, f_17]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_13)] := newPMask;
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_13)][Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_13)][Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_13, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_13)][Heap[this$_13, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_15: Ref, f_18: (Field A B) ::
        { newPMask[o_15, f_18] }
        Heap[null, AVLTreeNodevalid$#sm(this$_13)][o_15, f_18] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_13, AVLTreeNoderight$])][o_15, f_18] ==> newPMask[o_15, f_18]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_13)] := newPMask;
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_13)][Heap[this$_13, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_13)][Heap[this$_13, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_13, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_13)][Heap[this$_13, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodehas$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_13). (AVLTree.sil,920:11) [12247]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_13)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_13)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_13)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_13)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_13)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_13)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_13)], perm);
    assert {:msg "  Postcondition of AVLTreeNodehas$ might not hold. Fraction k$_9 might not be positive. (AVLTree.sil,921:11) [12248]"}
      k$_9[$frac] > 0.000000000 || (k$_9[$frac] == 0.000000000 && k$_9[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodehas$ might not hold. Receiver of this$_13.AVLTreeNodekeys$ might be null. (AVLTree.sil,921:11) [12249]"}
      this$_13 != null;
    assert {:msg "  Postcondition of AVLTreeNodehas$ might not hold. Assertion b == k in this$_13.AVLTreeNodekeys$ might not hold. (AVLTree.sil,922:11) [12250]"}
      b_2 == Seq#Contains(Heap[this$_13, AVLTreeNodekeys$], k);
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    perm := NoPerm;
    perm := PermAdd(perm, k$_9);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodehas$ might not hold. There might be insufficient permission to access this$_13.AVLTreeNodekeys$. (AVLTree.sil,921:11) [12251]"}
        (perm[$frac] < Mask[this$_13, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_13, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_13, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_13, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_13, AVLTreeNodekeys$][$eps]);
    }
    Mask[this$_13, AVLTreeNodekeys$] := PermSub(Mask[this$_13, AVLTreeNodekeys$], perm);
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodegetBalanceFactor$
// ==================================================

procedure AVLTreeNodegetBalanceFactor$(this$_14: Ref, k$_10: Perm) returns (bf: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newPMask: PMaskType;
  var lh: int;
  var rh: int;
  var freshVersion: int;
  var ExhaleHeap: HeapType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_14 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_10[$frac] || (NoPerm[$frac] == k$_10[$frac] && NoPerm[$eps] < k$_10[$eps]);
    assume state(Heap, Mask);
    assume k$_10[$frac] < FullPerm[$frac] || (k$_10[$frac] == FullPerm[$frac] && k$_10[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_14)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_14)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := k$_10;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_14, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_14)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_14)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := k$_10;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_14, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of bf == this$_14.AVLTreeNodebalanceFactor$
      assert {:msg "  Contract might not be well-formed. Receiver of this$_14.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,962:11) [12252]"}
        this$_14 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_14.AVLTreeNodebalanceFactor$. (AVLTree.sil,962:11) [12253]"}
        HasDirectPerm(Mask, this$_14, AVLTreeNodebalanceFactor$);
      assume state(Heap, Mask);
    assume bf == Heap[this$_14, AVLTreeNodebalanceFactor$];
    assume state(Heap, Mask);
    
    // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_14), write) in (bf > 0) ==> (this$_14.AVLTreeNodeleft$ != null))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_14));
      // Phase 1: pure assertions and fixed permissions
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access AVLTreeNodevalid$(this$_14). (AVLTree.sil,963:12) [12254]"}
          (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$eps]);
      }
      UnfoldingMask[null, AVLTreeNodevalid$(this$_14)] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(this$_14)], perm);
      
      // -- Update version of predicate
        if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(this$_14))) {
          oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)];
          havoc newVersion;
          assume oldVersion < newVersion;
          UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)] := newVersion;
        }
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodekey$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodekey$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodeheight$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodeheight$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodeleft$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodeleft$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNoderight$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNoderight$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodekeys$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodekeys$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodebalanceFactor$], perm);
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNodeleft$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)], UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNodeleft$])]);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        assume (forall lk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[this$_14, AVLTreeNodekey$]
        );
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNoderight$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)], UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNoderight$])]);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        assume (forall rk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[this$_14, AVLTreeNodekey$] < rk
        );
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
      }
      assume Seq#Equal(UnfoldingHeap[this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[this$_14, AVLTreeNodekey$])), (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
      assume Seq#Contains(UnfoldingHeap[this$_14, AVLTreeNodekeys$], UnfoldingHeap[this$_14, AVLTreeNodekey$]);
      assume (forall kk: int ::
        
        Seq#Contains(UnfoldingHeap[this$_14, AVLTreeNodekeys$], kk) == ((UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[this$_14, AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[this$_14, AVLTreeNodekey$]))
      );
      assume UnfoldingHeap[this$_14, AVLTreeNodeheight$] == (if (if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
      assume UnfoldingHeap[this$_14, AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
      assume UnfoldingHeap[this$_14, AVLTreeNodebalanceFactor$] <= 1;
      assume UnfoldingHeap[this$_14, AVLTreeNodebalanceFactor$] >= -1;
      assume UnfoldingHeap[this$_14, AVLTreeNodeheight$] > 0;
      assume state(UnfoldingHeap, UnfoldingMask);
      if (bf > 0) {
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_14.AVLTreeNodeleft$. (AVLTree.sil,963:12) [12255]"}
          HasDirectPerm(UnfoldingMask, this$_14, AVLTreeNodeleft$);
      }
      
      // -- Free assumptions
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_16: Ref, f_19: (Field A B) ::
            { newPMask[o_16, f_19] }
            Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_16, f_19] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_16, f_19] ==> newPMask[o_16, f_19]
          );
          Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
        }
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_17: Ref, f_20: (Field A B) ::
            { newPMask[o_17, f_20] }
            Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_17, f_20] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_17, f_20] ==> newPMask[o_17, f_20]
          );
          Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
      assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_18: Ref, f_21: (Field A B) ::
        { newPMask[o_18, f_21] }
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_18, f_21] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_18, f_21] ==> newPMask[o_18, f_21]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_19: Ref, f_22: (Field A B) ::
        { newPMask[o_19, f_22] }
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_19, f_22] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_19, f_22] ==> newPMask[o_19, f_22]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume bf > 0 ==> Heap[this$_14, AVLTreeNodeleft$] != null;
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_20: Ref, f_23: (Field A B) ::
          { newPMask[o_20, f_23] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_20, f_23] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_20, f_23] ==> newPMask[o_20, f_23]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_21: Ref, f_24: (Field A B) ::
          { newPMask[o_21, f_24] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_21, f_24] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_21, f_24] ==> newPMask[o_21, f_24]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
    
    // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_14), write) in (bf < 0) ==> (this$_14.AVLTreeNoderight$ != null))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_14));
      // Phase 1: pure assertions and fixed permissions
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access AVLTreeNodevalid$(this$_14). (AVLTree.sil,964:12) [12256]"}
          (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(this$_14)][$eps]);
      }
      UnfoldingMask[null, AVLTreeNodevalid$(this$_14)] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(this$_14)], perm);
      
      // -- Update version of predicate
        if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(this$_14))) {
          oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)];
          havoc newVersion;
          assume oldVersion < newVersion;
          UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)] := newVersion;
        }
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodekey$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodekey$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodeheight$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodeheight$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodeleft$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodeleft$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNoderight$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNoderight$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodekeys$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodekeys$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume this$_14 != null;
      UnfoldingMask[this$_14, AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[this$_14, AVLTreeNodebalanceFactor$], perm);
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNodeleft$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)], UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNodeleft$])]);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        assume (forall lk_1: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < UnfoldingHeap[this$_14, AVLTreeNodekey$]
        );
      }
      if (UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNoderight$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(this$_14)], UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_14, AVLTreeNoderight$])]);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_14, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        assume (forall rk_1: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> UnfoldingHeap[this$_14, AVLTreeNodekey$] < rk_1
        );
      }
      if (UnfoldingHeap[this$_14, AVLTreeNoderight$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
      }
      assume Seq#Equal(UnfoldingHeap[this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[this$_14, AVLTreeNodekey$])), (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
      assume Seq#Contains(UnfoldingHeap[this$_14, AVLTreeNodekeys$], UnfoldingHeap[this$_14, AVLTreeNodekey$]);
      assume (forall kk_1: int ::
        
        Seq#Contains(UnfoldingHeap[this$_14, AVLTreeNodekeys$], kk_1) == ((UnfoldingHeap[this$_14, AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((UnfoldingHeap[this$_14, AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == UnfoldingHeap[this$_14, AVLTreeNodekey$]))
      );
      assume UnfoldingHeap[this$_14, AVLTreeNodeheight$] == (if (if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
      assume UnfoldingHeap[this$_14, AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
      assume UnfoldingHeap[this$_14, AVLTreeNodebalanceFactor$] <= 1;
      assume UnfoldingHeap[this$_14, AVLTreeNodebalanceFactor$] >= -1;
      assume UnfoldingHeap[this$_14, AVLTreeNodeheight$] > 0;
      assume state(UnfoldingHeap, UnfoldingMask);
      if (bf < 0) {
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_14.AVLTreeNoderight$. (AVLTree.sil,964:12) [12257]"}
          HasDirectPerm(UnfoldingMask, this$_14, AVLTreeNoderight$);
      }
      
      // -- Free assumptions
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_22: Ref, f_25: (Field A B) ::
            { newPMask[o_22, f_25] }
            Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_22, f_25] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_22, f_25] ==> newPMask[o_22, f_25]
          );
          Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
        }
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_23: Ref, f_26: (Field A B) ::
            { newPMask[o_23, f_26] }
            Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_23, f_26] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_23, f_26] ==> newPMask[o_23, f_26]
          );
          Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
      assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_24: Ref, f_27: (Field A B) ::
        { newPMask[o_24, f_27] }
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_24, f_27] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_24, f_27] ==> newPMask[o_24, f_27]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_25: Ref, f_28: (Field A B) ::
        { newPMask[o_25, f_28] }
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_25, f_28] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_25, f_28] ==> newPMask[o_25, f_28]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume bf < 0 ==> Heap[this$_14, AVLTreeNoderight$] != null;
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_26: Ref, f_29: (Field A B) ::
          { newPMask[o_26, f_29] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_26, f_29] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_26, f_29] ==> newPMask[o_26, f_29]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_27: Ref, f_30: (Field A B) ::
          { newPMask[o_27, f_30] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_27, f_30] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_27, f_30] ==> newPMask[o_27, f_30]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_14 == null || Heap[this$_14, $allocated];
    assume k$_10[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_14), write) -- AVLTree.sil,972:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_14));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_14). (AVLTree.sil,972:3) [12260]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_14)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_14)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_14)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_14)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_14)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(this$_14))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(this$_14)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(this$_14)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodekey$] := PermAdd(Mask[this$_14, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodeheight$] := PermAdd(Mask[this$_14, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodeleft$] := PermAdd(Mask[this$_14, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNoderight$] := PermAdd(Mask[this$_14, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodekeys$] := PermAdd(Mask[this$_14, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_14 != null;
    Mask[this$_14, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_14, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_14, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_14, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_14, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assume (forall lk_2: int ::
        
        Seq#Contains(Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < Heap[this$_14, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])]);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_14, AVLTreeNoderight$] != null;
      Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_14, AVLTreeNoderight$] != null;
      Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_14, AVLTreeNoderight$] != null;
      Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assume (forall rk_2: int ::
        
        Seq#Contains(Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> Heap[this$_14, AVLTreeNodekey$] < rk_2
      );
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assume Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_14, AVLTreeNodekey$])), (if Heap[this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[this$_14, AVLTreeNodekeys$], Heap[this$_14, AVLTreeNodekey$]);
    assume (forall kk_2: int ::
      
      Seq#Contains(Heap[this$_14, AVLTreeNodekeys$], kk_2) == ((Heap[this$_14, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((Heap[this$_14, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == Heap[this$_14, AVLTreeNodekey$]))
    );
    assume Heap[this$_14, AVLTreeNodeheight$] == (if (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[this$_14, AVLTreeNodebalanceFactor$] == (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[this$_14, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[this$_14, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[this$_14, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: lh := (this$_14.AVLTreeNodeleft$ == null ? 0 : this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$) -- AVLTree.sil,973:3
    
    // -- Check definedness of (this$_14.AVLTreeNodeleft$ == null ? 0 : this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$. (AVLTree.sil,973:3) [12261]"}
        HasDirectPerm(Mask, this$_14, AVLTreeNodeleft$);
      if (Heap[this$_14, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,973:3) [12262]"}
          Heap[this$_14, AVLTreeNodeleft$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,973:3) [12263]"}
          HasDirectPerm(Mask, Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_14.AVLTreeNodeleft$ might be null. (AVLTree.sil,973:3) [12264]"}
          this$_14 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$. (AVLTree.sil,973:3) [12265]"}
          HasDirectPerm(Mask, this$_14, AVLTreeNodeleft$);
      }
      assume state(Heap, Mask);
    lh := (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
  
  // -- Translating statement: rh := (this$_14.AVLTreeNoderight$ == null ? 0 : this$_14.AVLTreeNoderight$.AVLTreeNodeheight$) -- AVLTree.sil,974:3
    
    // -- Check definedness of (this$_14.AVLTreeNoderight$ == null ? 0 : this$_14.AVLTreeNoderight$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. Receiver of this$_14.AVLTreeNoderight$ might be null. (AVLTree.sil,974:3) [12266]"}
        this$_14 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$. (AVLTree.sil,974:3) [12267]"}
        HasDirectPerm(Mask, this$_14, AVLTreeNoderight$);
      if (Heap[this$_14, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_14.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,974:3) [12268]"}
          Heap[this$_14, AVLTreeNoderight$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,974:3) [12269]"}
          HasDirectPerm(Mask, Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_14.AVLTreeNoderight$ might be null. (AVLTree.sil,974:3) [12270]"}
          this$_14 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$. (AVLTree.sil,974:3) [12271]"}
          HasDirectPerm(Mask, this$_14, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    rh := (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
  
  // -- Translating statement: bf := lh - rh -- AVLTree.sil,975:3
    bf := lh - rh;
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreeNodevalid$(this$_14), write) -- AVLTree.sil,976:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_14));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,976:3) [12272]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodekey$ might be null. (AVLTree.sil,976:3) [12273]"}
      this$_14 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodekey$. (AVLTree.sil,976:3) [12274]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNodekey$][$eps]);
    }
    Mask[this$_14, AVLTreeNodekey$] := PermSub(Mask[this$_14, AVLTreeNodekey$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12275]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodeheight$ might be null. (AVLTree.sil,976:3) [12276]"}
      this$_14 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodeheight$. (AVLTree.sil,976:3) [12277]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNodeheight$][$eps]);
    }
    Mask[this$_14, AVLTreeNodeheight$] := PermSub(Mask[this$_14, AVLTreeNodeheight$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,976:3) [12278]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodeleft$ might be null. (AVLTree.sil,976:3) [12279]"}
      this$_14 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$. (AVLTree.sil,976:3) [12280]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNodeleft$][$eps]);
    }
    Mask[this$_14, AVLTreeNodeleft$] := PermSub(Mask[this$_14, AVLTreeNodeleft$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,976:3) [12281]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNoderight$ might be null. (AVLTree.sil,976:3) [12282]"}
      this$_14 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$. (AVLTree.sil,976:3) [12283]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNoderight$][$eps]);
    }
    Mask[this$_14, AVLTreeNoderight$] := PermSub(Mask[this$_14, AVLTreeNoderight$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12284]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodekeys$ might be null. (AVLTree.sil,976:3) [12285]"}
      this$_14 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodekeys$. (AVLTree.sil,976:3) [12286]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNodekeys$][$eps]);
    }
    Mask[this$_14, AVLTreeNodekeys$] := PermSub(Mask[this$_14, AVLTreeNodekeys$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12287]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,976:3) [12288]"}
      this$_14 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodebalanceFactor$. (AVLTree.sil,976:3) [12289]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[this$_14, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_14, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_14.AVLTreeNodeleft$). (AVLTree.sil,976:3) [12292]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12293]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,976:3) [12294]"}
        Heap[this$_14, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,976:3) [12295]"}
          (perm[$frac] < Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12296]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,976:3) [12297]"}
        Heap[this$_14, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,976:3) [12298]"}
          (perm[$frac] < Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12299]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,976:3) [12300]"}
        Heap[this$_14, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,976:3) [12301]"}
          (perm[$frac] < Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion (forall lk: Int :: true && lk in this$_14.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (lk < this$_14.AVLTreeNodekey$)) might not hold. (AVLTree.sil,976:3) [12302]"}
        (forall lk_3: int ::
        
        Seq#Contains(Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_3) ==> lk_3 < Heap[this$_14, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,976:3) [12303]"}
        Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_14.AVLTreeNoderight$). (AVLTree.sil,976:3) [12306]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])]);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12307]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,976:3) [12308]"}
        Heap[this$_14, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,976:3) [12309]"}
          (perm[$frac] < Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12310]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,976:3) [12311]"}
        Heap[this$_14, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,976:3) [12312]"}
          (perm[$frac] < Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,976:3) [12313]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Receiver of this$_14.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,976:3) [12314]"}
        Heap[this$_14, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. There might be insufficient permission to access this$_14.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,976:3) [12315]"}
          (perm[$frac] < Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion (forall rk: Int :: true && rk in this$_14.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_14.AVLTreeNodekey$ < rk)) might not hold. (AVLTree.sil,976:3) [12316]"}
        (forall rk_3: int ::
        
        Seq#Contains(Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk_3) ==> Heap[this$_14, AVLTreeNodekey$] < rk_3
      );
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNoderight$.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,976:3) [12317]"}
        Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodekeys$ == (this$_14.AVLTreeNodeleft$ == null ? Seq() : this$_14.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_14.AVLTreeNodekey$) ++ (this$_14.AVLTreeNoderight$ == null ? Seq() : this$_14.AVLTreeNoderight$.AVLTreeNodekeys$) might not hold. (AVLTree.sil,976:3) [12318]"}
      Seq#Equal(Heap[this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_14, AVLTreeNodekey$])), (if Heap[this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodekey$ in this$_14.AVLTreeNodekeys$ might not hold. (AVLTree.sil,976:3) [12319]"}
      Seq#Contains(Heap[this$_14, AVLTreeNodekeys$], Heap[this$_14, AVLTreeNodekey$]);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion (forall kk: Int :: true ==> (kk in this$_14.AVLTreeNodekeys$ == (this$_14.AVLTreeNodeleft$ != null) && kk in this$_14.AVLTreeNodeleft$.AVLTreeNodekeys$ || ((this$_14.AVLTreeNoderight$ != null) && kk in this$_14.AVLTreeNoderight$.AVLTreeNodekeys$ || (kk == this$_14.AVLTreeNodekey$)))) might not hold. (AVLTree.sil,976:3) [12320]"}
      (forall kk_3: int ::
      
      Seq#Contains(Heap[this$_14, AVLTreeNodekeys$], kk_3) == ((Heap[this$_14, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_3)) || ((Heap[this$_14, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk_3)) || kk_3 == Heap[this$_14, AVLTreeNodekey$]))
    );
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodeheight$ == ((this$_14.AVLTreeNodeleft$ == null ? 0 : this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_14.AVLTreeNoderight$ == null ? 0 : this$_14.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_14.AVLTreeNodeleft$ == null ? 0 : this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_14.AVLTreeNoderight$ == null ? 0 : this$_14.AVLTreeNoderight$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,976:3) [12321]"}
      Heap[this$_14, AVLTreeNodeheight$] == (if (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodebalanceFactor$ == (this$_14.AVLTreeNodeleft$ == null ? 0 : this$_14.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_14.AVLTreeNoderight$ == null ? 0 : this$_14.AVLTreeNoderight$.AVLTreeNodeheight$) might not hold. (AVLTree.sil,976:3) [12322]"}
      Heap[this$_14, AVLTreeNodebalanceFactor$] == (if Heap[this$_14, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_14, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodebalanceFactor$ <= 1 might not hold. (AVLTree.sil,976:3) [12323]"}
      Heap[this$_14, AVLTreeNodebalanceFactor$] <= 1;
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodebalanceFactor$ >= 0 - 1 might not hold. (AVLTree.sil,976:3) [12324]"}
      Heap[this$_14, AVLTreeNodebalanceFactor$] >= -1;
    assert {:msg "  Folding AVLTreeNodevalid$(this$_14) might fail. Assertion this$_14.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,976:3) [12325]"}
      Heap[this$_14, AVLTreeNodeheight$] > 0;
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_14, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_14)], Heap[this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_14, AVLTreeNoderight$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_14)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_14)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(this$_14)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreeNodevalid$(this$_14)] := freshVersion;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_28: Ref, f_31: (Field A B) ::
        { newPMask[o_28, f_31] }
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_28, f_31] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_28, f_31] ==> newPMask[o_28, f_31]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_14, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_29: Ref, f_32: (Field A B) ::
        { newPMask[o_29, f_32] }
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_29, f_32] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_29, f_32] ==> newPMask[o_29, f_32]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_14, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_14). (AVLTree.sil,960:11) [12326]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_14)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_14)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_14)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_14)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_14)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_14)], perm);
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. Fraction k$_10 might not be positive. (AVLTree.sil,961:11) [12327]"}
      k$_10[$frac] > 0.000000000 || (k$_10[$frac] == 0.000000000 && k$_10[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. Receiver of this$_14.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,961:11) [12328]"}
      this$_14 != null;
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. Assertion bf == this$_14.AVLTreeNodebalanceFactor$ might not hold. (AVLTree.sil,962:11) [12329]"}
      bf == Heap[this$_14, AVLTreeNodebalanceFactor$];
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. Assertion (unfolding acc(AVLTreeNodevalid$(this$_14), write) in (bf > 0) ==> (this$_14.AVLTreeNodeleft$ != null)) might not hold. (AVLTree.sil,963:12) [12330]"}
      bf > 0 ==> Heap[this$_14, AVLTreeNodeleft$] != null;
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. Assertion (unfolding acc(AVLTreeNodevalid$(this$_14), write) in (bf < 0) ==> (this$_14.AVLTreeNoderight$ != null)) might not hold. (AVLTree.sil,964:12) [12331]"}
      bf < 0 ==> Heap[this$_14, AVLTreeNoderight$] != null;
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    perm := NoPerm;
    perm := PermAdd(perm, k$_10);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactor$ might not hold. There might be insufficient permission to access this$_14.AVLTreeNodebalanceFactor$. (AVLTree.sil,961:11) [12332]"}
        (perm[$frac] < Mask[this$_14, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_14, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_14, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_14, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_14, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[this$_14, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_14, AVLTreeNodebalanceFactor$], perm);
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_30: Ref, f_33: (Field A B) ::
          { newPMask[o_30, f_33] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_30, f_33] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_30, f_33] ==> newPMask[o_30, f_33]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_31: Ref, f_34: (Field A B) ::
          { newPMask[o_31, f_34] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_31, f_34] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_31, f_34] ==> newPMask[o_31, f_34]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(this$_14)][this$_14, AVLTreeNodebalanceFactor$] := true;
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_32: Ref, f_35: (Field A B) ::
          { newPMask[o_32, f_35] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_32, f_35] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNodeleft$])][o_32, f_35] ==> newPMask[o_32, f_35]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_33: Ref, f_36: (Field A B) ::
          { newPMask[o_33, f_36] }
          Heap[null, AVLTreeNodevalid$#sm(this$_14)][o_33, f_36] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_14, AVLTreeNoderight$])][o_33, f_36] ==> newPMask[o_33, f_36]
        );
        Heap[null, AVLTreeNodevalid$#sm(this$_14)] := newPMask;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[this$_14, AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(this$_14)][Heap[this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodegetBalanceFactorI$
// ==================================================

procedure AVLTreeNodegetBalanceFactorI$(this$_15: Ref, k$_11: Perm) returns (bf: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var lh: int;
  var rh: int;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newPMask: PMaskType;
  var ExhaleHeap: HeapType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_15 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_11[$frac] || (NoPerm[$frac] == k$_11[$frac] && NoPerm[$eps] < k$_11[$eps]);
    assume state(Heap, Mask);
    assume k$_11[$frac] < FullPerm[$frac] || (k$_11[$frac] == FullPerm[$frac] && k$_11[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := k$_11;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_15 != null;
    Mask[this$_15, AVLTreeNodeleft$] := PermAdd(Mask[this$_15, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_15.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,984:12) [12333]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,984:12) [12334]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,984:12) [12335]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_15.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,985:12) [12336]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,985:12) [12337]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$, k$_11)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,985:12) [12338]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,985:12) [12339]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := k$_11;
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_15, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    perm := k$_11;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_15 != null;
    Mask[this$_15, AVLTreeNoderight$] := PermAdd(Mask[this$_15, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_15.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,987:12) [12340]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,987:12) [12341]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,987:12) [12342]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_15.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,988:12) [12343]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,988:12) [12344]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_15.AVLTreeNoderight$.AVLTreeNodeheight$, k$_11)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,988:12) [12345]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,988:12) [12346]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := k$_11;
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_15, AVLTreeNoderight$] != null;
      Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := k$_11;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_15 != null;
    Mask[this$_15, AVLTreeNodeleft$] := PermAdd(Mask[this$_15, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_15.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,990:11) [12347]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,990:11) [12348]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,990:11) [12349]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_15.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,991:11) [12350]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,991:11) [12351]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$, k$_11)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,991:11) [12352]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,991:11) [12353]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := k$_11;
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_15, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    perm := k$_11;
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_15 != null;
    Mask[this$_15, AVLTreeNoderight$] := PermAdd(Mask[this$_15, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_15.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,993:11) [12354]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,993:11) [12355]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,993:11) [12356]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_15.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,994:11) [12357]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,994:11) [12358]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_15.AVLTreeNoderight$.AVLTreeNodeheight$, k$_11)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,994:11) [12359]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,994:11) [12360]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := k$_11;
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_15, AVLTreeNoderight$] != null;
      Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of bf == (this$_15.AVLTreeNodeleft$ == null ? 0 : this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_15.AVLTreeNoderight$ == null ? 0 : this$_15.AVLTreeNoderight$.AVLTreeNodeheight$)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,995:11) [12361]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,995:11) [12362]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      if (Heap[this$_15, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,995:11) [12363]"}
          Heap[this$_15, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,995:11) [12364]"}
          HasDirectPerm(Mask, Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,995:11) [12365]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,995:11) [12366]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,995:11) [12367]"}
        this$_15 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,995:11) [12368]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      if (Heap[this$_15, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,995:11) [12369]"}
          Heap[this$_15, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,995:11) [12370]"}
          HasDirectPerm(Mask, Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,995:11) [12371]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,995:11) [12372]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume bf == (if Heap[this$_15, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_15, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
    if (bf > 0) {
      
      // -- Check definedness of this$_15.AVLTreeNodeleft$ != null
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,996:11) [12373]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,996:11) [12374]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      assume Heap[this$_15, AVLTreeNodeleft$] != null;
      assume state(Heap, Mask);
    }
    if (bf < 0) {
      
      // -- Check definedness of this$_15.AVLTreeNoderight$ != null
        assert {:msg "  Contract might not be well-formed. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,997:11) [12375]"}
          this$_15 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,997:11) [12376]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
        assume state(Heap, Mask);
      assume Heap[this$_15, AVLTreeNoderight$] != null;
      assume state(Heap, Mask);
    }
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_15 == null || Heap[this$_15, $allocated];
    assume k$_11[$eps] == 0.000000000;
  
  // -- Translating statement: lh := (this$_15.AVLTreeNodeleft$ == null ? 0 : this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$) -- AVLTree.sil,1005:3
    
    // -- Check definedness of (this$_15.AVLTreeNodeleft$ == null ? 0 : this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,1005:3) [12377]"}
        this$_15 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,1005:3) [12378]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      if (Heap[this$_15, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1005:3) [12379]"}
          Heap[this$_15, AVLTreeNodeleft$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1005:3) [12380]"}
          HasDirectPerm(Mask, Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,1005:3) [12381]"}
          this$_15 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,1005:3) [12382]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      }
      assume state(Heap, Mask);
    lh := (if Heap[this$_15, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
  
  // -- Translating statement: rh := (this$_15.AVLTreeNoderight$ == null ? 0 : this$_15.AVLTreeNoderight$.AVLTreeNodeheight$) -- AVLTree.sil,1006:3
    
    // -- Check definedness of (this$_15.AVLTreeNoderight$ == null ? 0 : this$_15.AVLTreeNoderight$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,1006:3) [12383]"}
        this$_15 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,1006:3) [12384]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      if (Heap[this$_15, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1006:3) [12385]"}
          Heap[this$_15, AVLTreeNoderight$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1006:3) [12386]"}
          HasDirectPerm(Mask, Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,1006:3) [12387]"}
          this$_15 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,1006:3) [12388]"}
          HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    rh := (if Heap[this$_15, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
  
  // -- Translating statement: bf := lh - rh -- AVLTree.sil,1007:3
    bf := lh - rh;
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (this$_15.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write) in this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ > 0) -- AVLTree.sil,1008:3
    
    // -- Check definedness of (this$_15.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write) in this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ > 0)
      assert {:msg "  Assert might fail. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,1008:3) [12389]"}
        this$_15 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,1008:3) [12390]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNoderight$);
      if (Heap[this$_15, AVLTreeNoderight$] != null) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$]));
        // Phase 1: pure assertions and fixed permissions
        perm := NoPerm;
        perm := PermAdd(perm, FullPerm);
        if (perm != NoPerm) {
          assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_15.AVLTreeNoderight$). (AVLTree.sil,1008:3) [12391]"}
            (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])][$eps]);
        }
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])], perm);
        
        // -- Update version of predicate
          if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$]))) {
            oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])];
            havoc newVersion;
            assume oldVersion < newVersion;
            UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])] := newVersion;
          }
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assume (forall lk: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$]
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assume (forall rk: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$] < rk
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
        }
        assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$]);
        assume (forall kk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$], kk) == ((UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$]))
        );
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
        assume state(UnfoldingHeap, UnfoldingMask);
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,1008:3) [12392]"}
          HasDirectPerm(UnfoldingMask, this$_15, AVLTreeNoderight$);
        assert {:msg "  Assert might fail. Receiver of this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1008:3) [12393]"}
          UnfoldingHeap[this$_15, AVLTreeNoderight$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1008:3) [12394]"}
          HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assert might fail. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,1008:3) [12395]"}
          this$_15 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,1008:3) [12396]"}
          HasDirectPerm(UnfoldingMask, this$_15, AVLTreeNoderight$);
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_34: Ref, f_37: (Field A B) ::
              { newPMask[o_34, f_37] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][o_34, f_37] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$])][o_34, f_37] ==> newPMask[o_34, f_37]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])] := newPMask;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_35: Ref, f_38: (Field A B) ::
              { newPMask[o_35, f_38] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][o_35, f_38] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$])][o_35, f_38] ==> newPMask[o_35, f_38]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])] := newPMask;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNoderight$), write) in this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ > 0) might not hold. (AVLTree.sil,1008:3) [12397]"}
        Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[this$_15, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_36: Ref, f_39: (Field A B) ::
          { newPMask[o_36, f_39] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][o_36, f_39] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$])][o_36, f_39] ==> newPMask[o_36, f_39]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])] := newPMask;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_37: Ref, f_40: (Field A B) ::
          { newPMask[o_37, f_40] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][o_37, f_40] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$])][o_37, f_40] ==> newPMask[o_37, f_40]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])] := newPMask;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNoderight$])][Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (this$_15.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write) in this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0) -- AVLTree.sil,1009:3
    
    // -- Check definedness of (this$_15.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write) in this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0)
      assert {:msg "  Assert might fail. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,1009:3) [12398]"}
        this$_15 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,1009:3) [12399]"}
        HasDirectPerm(Mask, this$_15, AVLTreeNodeleft$);
      if (Heap[this$_15, AVLTreeNodeleft$] != null) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$]));
        // Phase 1: pure assertions and fixed permissions
        perm := NoPerm;
        perm := PermAdd(perm, FullPerm);
        if (perm != NoPerm) {
          assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$). (AVLTree.sil,1009:3) [12400]"}
            (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])][$eps]);
        }
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])], perm);
        
        // -- Update version of predicate
          if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$]))) {
            oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])];
            havoc newVersion;
            assume oldVersion < newVersion;
            UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])] := newVersion;
          }
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assume (forall lk_1: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$]
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_15, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assume (forall rk_1: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$] < rk_1
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
        }
        assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$]);
        assume (forall kk_1: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1) == ((UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$]))
        );
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
        assume UnfoldingHeap[UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
        assume state(UnfoldingHeap, UnfoldingMask);
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,1009:3) [12401]"}
          HasDirectPerm(UnfoldingMask, this$_15, AVLTreeNodeleft$);
        assert {:msg "  Assert might fail. Receiver of this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1009:3) [12402]"}
          UnfoldingHeap[this$_15, AVLTreeNodeleft$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1009:3) [12403]"}
          HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assert might fail. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,1009:3) [12404]"}
          this$_15 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,1009:3) [12405]"}
          HasDirectPerm(UnfoldingMask, this$_15, AVLTreeNodeleft$);
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_38: Ref, f_41: (Field A B) ::
              { newPMask[o_38, f_41] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][o_38, f_41] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_38, f_41] ==> newPMask[o_38, f_41]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])] := newPMask;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_39: Ref, f_42: (Field A B) ::
              { newPMask[o_39, f_42] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][o_39, f_42] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$])][o_39, f_42] ==> newPMask[o_39, f_42]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])] := newPMask;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$), write) in this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0) might not hold. (AVLTree.sil,1009:3) [12406]"}
        Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_40: Ref, f_43: (Field A B) ::
          { newPMask[o_40, f_43] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][o_40, f_43] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_40, f_43] ==> newPMask[o_40, f_43]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])] := newPMask;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_41: Ref, f_44: (Field A B) ::
          { newPMask[o_41, f_44] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][o_41, f_44] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$])][o_41, f_44] ==> newPMask[o_41, f_44]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])] := newPMask;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_15, AVLTreeNodeleft$])][Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
  
  // -- Translating statement: assert lh >= 0 -- AVLTree.sil,1010:3
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion lh >= 0 might not hold. (AVLTree.sil,1010:3) [12407]"}
      lh >= 0;
    assume state(Heap, Mask);
  
  // -- Translating statement: assert rh >= 0 -- AVLTree.sil,1011:3
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion rh >= 0 might not hold. (AVLTree.sil,1011:3) [12408]"}
      rh >= 0;
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Fraction k$_11 might not be positive. (AVLTree.sil,989:11) [12409]"}
      k$_11[$frac] > 0.000000000 || (k$_11[$frac] == 0.000000000 && k$_11[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_15.AVLTreeNodeleft$ might be null. (AVLTree.sil,989:11) [12410]"}
      this$_15 != null;
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_15.AVLTreeNodeleft$). (AVLTree.sil,990:11) [12411]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNodeleft$])], perm);
    }
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Fraction k$_11 might not be positive. (AVLTree.sil,991:11) [12412]"}
        k$_11[$frac] > 0.000000000 || (k$_11[$frac] == 0.000000000 && k$_11[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,991:11) [12413]"}
        Heap[this$_15, AVLTreeNodeleft$] != null;
    }
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Fraction k$_11 might not be positive. (AVLTree.sil,992:11) [12414]"}
      k$_11[$frac] > 0.000000000 || (k$_11[$frac] == 0.000000000 && k$_11[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_15.AVLTreeNoderight$ might be null. (AVLTree.sil,992:11) [12415]"}
      this$_15 != null;
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_15.AVLTreeNoderight$). (AVLTree.sil,993:11) [12416]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_15, AVLTreeNoderight$])], perm);
    }
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Fraction k$_11 might not be positive. (AVLTree.sil,994:11) [12417]"}
        k$_11[$frac] > 0.000000000 || (k$_11[$frac] == 0.000000000 && k$_11[$eps] > 0.000000000);
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Receiver of this$_15.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,994:11) [12418]"}
        Heap[this$_15, AVLTreeNoderight$] != null;
    }
    assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Assertion bf == (this$_15.AVLTreeNodeleft$ == null ? 0 : this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_15.AVLTreeNoderight$ == null ? 0 : this$_15.AVLTreeNoderight$.AVLTreeNodeheight$) might not hold. (AVLTree.sil,995:11) [12419]"}
      bf == (if Heap[this$_15, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_15, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$]);
    if (bf > 0) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_15.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,996:11) [12420]"}
        Heap[this$_15, AVLTreeNodeleft$] != null;
    }
    if (bf < 0) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. Assertion this$_15.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,997:11) [12421]"}
        Heap[this$_15, AVLTreeNoderight$] != null;
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    perm := NoPerm;
    perm := PermAdd(perm, k$_11);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_15.AVLTreeNodeleft$. (AVLTree.sil,989:11) [12422]"}
        (perm[$frac] < Mask[this$_15, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_15, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_15, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_15, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_15, AVLTreeNodeleft$][$eps]);
    }
    Mask[this$_15, AVLTreeNodeleft$] := PermSub(Mask[this$_15, AVLTreeNodeleft$], perm);
    if (Heap[this$_15, AVLTreeNodeleft$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, k$_11);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_15.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,991:11) [12423]"}
          (perm[$frac] < Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_15, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    perm := NoPerm;
    perm := PermAdd(perm, k$_11);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_15.AVLTreeNoderight$. (AVLTree.sil,992:11) [12424]"}
        (perm[$frac] < Mask[this$_15, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_15, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_15, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_15, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_15, AVLTreeNoderight$][$eps]);
    }
    Mask[this$_15, AVLTreeNoderight$] := PermSub(Mask[this$_15, AVLTreeNoderight$], perm);
    if (Heap[this$_15, AVLTreeNoderight$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, k$_11);
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of AVLTreeNodegetBalanceFactorI$ might not hold. There might be insufficient permission to access this$_15.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,994:11) [12425]"}
          (perm[$frac] < Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_15, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNodeclose$
// ==================================================

procedure AVLTreeNodeclose$(this$_16: Ref, k$_12: Perm) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var k0_10: int;
  var k1_9: int;
  var lh: int;
  var rh: int;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newPMask: PMaskType;
  var freshVersion: int;
  var ExhaleHeap: HeapType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_16 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_12[$frac] || (NoPerm[$frac] == k$_12[$frac] && NoPerm[$eps] < k$_12[$eps]);
    assume state(Heap, Mask);
    assume k$_12[$frac] < FullPerm[$frac] || (k$_12[$frac] == FullPerm[$frac] && k$_12[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodekey$] := PermAdd(Mask[this$_16, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodeheight$] := PermAdd(Mask[this$_16, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodeleft$] := PermAdd(Mask[this$_16, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNoderight$] := PermAdd(Mask[this$_16, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodekeys$] := PermAdd(Mask[this$_16, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_16, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_16.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1024:12) [12426]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1024:12) [12427]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1024:12) [12428]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1025:12) [12429]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1025:12) [12430]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1025:12) [12431]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1025:12) [12432]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_16, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1026:12) [12433]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1026:12) [12434]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1026:12) [12435]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1026:12) [12436]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_16, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1027:12) [12437]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1027:12) [12438]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_16.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1027:12) [12439]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1027:12) [12440]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_16, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1028:12) [12441]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1028:12) [12442]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of (forall k0: Int :: true && k0 in this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_16.AVLTreeNodekey$))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1028:12) [12443]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1028:12) [12444]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1028:12) [12445]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1028:12) [12446]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        if (Seq#Contains(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_10)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1028:12) [12447]"}
            this$_16 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1028:12) [12448]"}
            HasDirectPerm(Mask, this$_16, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k0_1: int ::
        
        Seq#Contains(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[this$_16, AVLTreeNodekey$]
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1029:12) [12449]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1029:12) [12450]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_16.AVLTreeNoderight$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1029:12) [12451]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1030:12) [12452]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1030:12) [12453]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1030:12) [12454]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1030:12) [12455]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_16, AVLTreeNoderight$] != null;
      Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1031:12) [12456]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1031:12) [12457]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_16.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1031:12) [12458]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1031:12) [12459]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_16, AVLTreeNoderight$] != null;
      Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1032:12) [12460]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1032:12) [12461]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_16.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1032:12) [12462]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1032:12) [12463]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_16, AVLTreeNoderight$] != null;
      Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_16.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1033:12) [12464]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1033:12) [12465]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of (forall k1: Int :: true && k1 in this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_16.AVLTreeNodekey$ < k1))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1033:12) [12466]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1033:12) [12467]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1033:12) [12468]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1033:12) [12469]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        if (Seq#Contains(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], k1_9)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1033:12) [12470]"}
            this$_16 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1033:12) [12471]"}
            HasDirectPerm(Mask, this$_16, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k1_1: int ::
        
        Seq#Contains(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_16, AVLTreeNodekey$] < k1_1
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1034:12) [12472]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1034:12) [12473]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1034:12) [12474]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1034:12) [12475]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1034:12) [12476]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1034:12) [12477]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1034:12) [12478]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1034:12) [12479]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1034:12) [12480]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1034:12) [12481]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1034:12) [12482]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1034:12) [12483]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1035:12) [12484]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1035:12) [12485]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1035:12) [12486]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1035:12) [12487]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1035:12) [12488]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1035:12) [12489]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1035:12) [12490]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1035:12) [12491]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1035:12) [12492]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1035:12) [12493]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1035:12) [12494]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1035:12) [12495]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_16)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_16)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodeheight$] := PermAdd(Mask[this$_16, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodekeys$] := PermAdd(Mask[this$_16, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_16 != null;
    Mask[this$_16, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_16, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_16.AVLTreeNodekeys$ == (old(this$_16.AVLTreeNodeleft$) == null ? Seq() : old(this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_16.AVLTreeNodekey$)) ++ (old(this$_16.AVLTreeNoderight$) == null ? Seq() : old(this$_16.AVLTreeNoderight$.AVLTreeNodekeys$))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodekeys$ might be null. (AVLTree.sil,1040:11) [12496]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodekeys$. (AVLTree.sil,1040:11) [12497]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1040:11) [12498]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1040:11) [12499]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
      if (old(Heap)[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1040:11) [12500]"}
          old(Heap)[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1040:11) [12501]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1040:11) [12502]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1040:11) [12503]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1040:11) [12504]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1040:11) [12505]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1040:11) [12506]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1040:11) [12507]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
      if (old(Heap)[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1040:11) [12508]"}
          old(Heap)[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1040:11) [12509]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1040:11) [12510]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1040:11) [12511]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[this$_16, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_16, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_16, AVLTreeNodekey$])), (if old(Heap)[this$_16, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_16.AVLTreeNodeheight$ == ((old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) > (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) ? (old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) + 1 : (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeheight$ might be null. (AVLTree.sil,1041:11) [12512]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeheight$. (AVLTree.sil,1041:11) [12513]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1041:11) [12514]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1041:11) [12515]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
      if (old(Heap)[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1041:11) [12516]"}
          old(Heap)[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1041:11) [12517]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1041:11) [12518]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1041:11) [12519]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1041:11) [12520]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1041:11) [12521]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
      if (old(Heap)[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1041:11) [12522]"}
          old(Heap)[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1041:11) [12523]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1041:11) [12524]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1041:11) [12525]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
      }
      if ((if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$])) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1041:11) [12526]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1041:11) [12527]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
        if (old(Heap)[this$_16, AVLTreeNodeleft$] == null) {
        } else {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1041:11) [12528]"}
            old(Heap)[this$_16, AVLTreeNodeleft$] != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1041:11) [12529]"}
            HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
          assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1041:11) [12530]"}
            this$_16 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1041:11) [12531]"}
            HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
        }
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1041:11) [12532]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1041:11) [12533]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
        if (old(Heap)[this$_16, AVLTreeNoderight$] == null) {
        } else {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1041:11) [12534]"}
            old(Heap)[this$_16, AVLTreeNoderight$] != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1041:11) [12535]"}
            HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
          assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1041:11) [12536]"}
            this$_16 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1041:11) [12537]"}
            HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
        }
      }
      assume state(Heap, Mask);
    assume Heap[this$_16, AVLTreeNodeheight$] == (if (if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_16.AVLTreeNodebalanceFactor$ == (old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) - (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1042:11) [12538]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodebalanceFactor$. (AVLTree.sil,1042:11) [12539]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodebalanceFactor$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1042:11) [12540]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1042:11) [12541]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
      if (old(Heap)[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1042:11) [12542]"}
          old(Heap)[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1042:11) [12543]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1042:11) [12544]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1042:11) [12545]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1042:11) [12546]"}
        this$_16 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1042:11) [12547]"}
        HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
      if (old(Heap)[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1042:11) [12548]"}
          old(Heap)[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1042:11) [12549]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1042:11) [12550]"}
          this$_16 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1042:11) [12551]"}
          HasDirectPerm(old(Mask), this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Heap[this$_16, AVLTreeNodebalanceFactor$] == (if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_16 == null || Heap[this$_16, $allocated];
    assume k$_12[$eps] == 0.000000000;
  
  // -- Translating statement: lh := (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) -- AVLTree.sil,1050:3
    
    // -- Check definedness of (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1050:3) [12552]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1050:3) [12553]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1050:3) [12554]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1050:3) [12555]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1050:3) [12556]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1050:3) [12557]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      }
      assume state(Heap, Mask);
    lh := (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
  
  // -- Translating statement: rh := (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) -- AVLTree.sil,1051:3
    
    // -- Check definedness of (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1051:3) [12558]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1051:3) [12559]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1051:3) [12560]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1051:3) [12561]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1051:3) [12562]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1051:3) [12563]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    rh := (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (this$_16.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$), write) in this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0) -- AVLTree.sil,1052:3
    
    // -- Check definedness of (this$_16.AVLTreeNodeleft$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$), write) in this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0)
      assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1052:3) [12564]"}
        this$_16 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1052:3) [12565]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] != null) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$]));
        // Phase 1: pure assertions and fixed permissions
        perm := NoPerm;
        perm := PermAdd(perm, FullPerm);
        if (perm != NoPerm) {
          assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$). (AVLTree.sil,1052:3) [12566]"}
            (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])][$eps]);
        }
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])], perm);
        
        // -- Update version of predicate
          if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$]))) {
            oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])];
            havoc newVersion;
            assume oldVersion < newVersion;
            UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])] := newVersion;
          }
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assume (forall lk: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$]
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assume (forall rk: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$] < rk
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
        }
        assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$]);
        assume (forall kk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], kk) == ((UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$]))
        );
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
        assume state(UnfoldingHeap, UnfoldingMask);
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1052:3) [12567]"}
          HasDirectPerm(UnfoldingMask, this$_16, AVLTreeNodeleft$);
        assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1052:3) [12568]"}
          UnfoldingHeap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1052:3) [12569]"}
          HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1052:3) [12570]"}
          this$_16 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1052:3) [12571]"}
          HasDirectPerm(UnfoldingMask, this$_16, AVLTreeNodeleft$);
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_42: Ref, f_45: (Field A B) ::
              { newPMask[o_42, f_45] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][o_42, f_45] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_42, f_45] ==> newPMask[o_42, f_45]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])] := newPMask;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_43: Ref, f_46: (Field A B) ::
              { newPMask[o_43, f_46] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][o_43, f_46] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$])][o_43, f_46] ==> newPMask[o_43, f_46]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])] := newPMask;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$), write) in this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0) might not hold. (AVLTree.sil,1052:3) [12572]"}
        Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_44: Ref, f_47: (Field A B) ::
          { newPMask[o_44, f_47] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][o_44, f_47] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_44, f_47] ==> newPMask[o_44, f_47]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])] := newPMask;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_45: Ref, f_48: (Field A B) ::
          { newPMask[o_45, f_48] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][o_45, f_48] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$])][o_45, f_48] ==> newPMask[o_45, f_48]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])] := newPMask;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (this$_16.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNoderight$), write) in this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ > 0) -- AVLTree.sil,1053:3
    
    // -- Check definedness of (this$_16.AVLTreeNoderight$ != null) ==> (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNoderight$), write) in this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ > 0)
      assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1053:3) [12573]"}
        this$_16 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1053:3) [12574]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] != null) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$]));
        // Phase 1: pure assertions and fixed permissions
        perm := NoPerm;
        perm := PermAdd(perm, FullPerm);
        if (perm != NoPerm) {
          assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_16.AVLTreeNoderight$). (AVLTree.sil,1053:3) [12575]"}
            (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])][$eps]);
        }
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])], perm);
        
        // -- Update version of predicate
          if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$]))) {
            oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])];
            havoc newVersion;
            assume oldVersion < newVersion;
            UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])] := newVersion;
          }
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
        perm := Perm(1.000000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assume (forall lk_1: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$]
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := FullPerm;
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_16, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$])]);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assume (forall rk_1: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$] < rk_1
          );
        }
        if (UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
        }
        assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$]);
        assume (forall kk_1: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1) == ((UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$]))
        );
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
        assume UnfoldingHeap[UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
        assume state(UnfoldingHeap, UnfoldingMask);
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1053:3) [12576]"}
          HasDirectPerm(UnfoldingMask, this$_16, AVLTreeNoderight$);
        assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1053:3) [12577]"}
          UnfoldingHeap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1053:3) [12578]"}
          HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1053:3) [12579]"}
          this$_16 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1053:3) [12580]"}
          HasDirectPerm(UnfoldingMask, this$_16, AVLTreeNoderight$);
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_46: Ref, f_49: (Field A B) ::
              { newPMask[o_46, f_49] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][o_46, f_49] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$])][o_46, f_49] ==> newPMask[o_46, f_49]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])] := newPMask;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_47: Ref, f_50: (Field A B) ::
              { newPMask[o_47, f_50] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][o_47, f_50] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$])][o_47, f_50] ==> newPMask[o_47, f_50]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])] := newPMask;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_16.AVLTreeNoderight$), write) in this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ > 0) might not hold. (AVLTree.sil,1053:3) [12581]"}
        Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_48: Ref, f_51: (Field A B) ::
          { newPMask[o_48, f_51] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][o_48, f_51] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$])][o_48, f_51] ==> newPMask[o_48, f_51]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])] := newPMask;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_49: Ref, f_52: (Field A B) ::
          { newPMask[o_49, f_52] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][o_49, f_52] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$])][o_49, f_52] ==> newPMask[o_49, f_52]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])] := newPMask;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_16.AVLTreeNodeheight$ := ((this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) + 1) -- AVLTree.sil,1054:3
    
    // -- Check definedness of this$_16.AVLTreeNodeheight$
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeheight$ might be null. (AVLTree.sil,1054:3) [12582]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeheight$. (AVLTree.sil,1054:3) [12583]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeheight$);
      assume state(Heap, Mask);
    
    // -- Check definedness of ((this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1054:3) [12584]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1054:3) [12585]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1054:3) [12586]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1054:3) [12587]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1054:3) [12588]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1054:3) [12589]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1054:3) [12590]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1054:3) [12591]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1054:3) [12592]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1054:3) [12593]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1054:3) [12594]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1054:3) [12595]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      }
      if ((if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$])) {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1054:3) [12596]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1054:3) [12597]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        if (Heap[this$_16, AVLTreeNodeleft$] == null) {
        } else {
          assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1054:3) [12598]"}
            Heap[this$_16, AVLTreeNodeleft$] != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1054:3) [12599]"}
            HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
          assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1054:3) [12600]"}
            this$_16 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1054:3) [12601]"}
            HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
        }
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1054:3) [12602]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1054:3) [12603]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        if (Heap[this$_16, AVLTreeNoderight$] == null) {
        } else {
          assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1054:3) [12604]"}
            Heap[this$_16, AVLTreeNoderight$] != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1054:3) [12605]"}
            HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
          assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1054:3) [12606]"}
            this$_16 != null;
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1054:3) [12607]"}
            HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
        }
      }
      assume state(Heap, Mask);
    Heap[this$_16, AVLTreeNodeheight$] := (if (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeheight$. (AVLTree.sil,1054:3) [12608]"}
      FullPerm[$frac] == Mask[this$_16, AVLTreeNodeheight$][$frac] && FullPerm[$eps] == Mask[this$_16, AVLTreeNodeheight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_16.AVLTreeNodebalanceFactor$ := (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) -- AVLTree.sil,1055:3
    
    // -- Check definedness of this$_16.AVLTreeNodebalanceFactor$
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1055:3) [12609]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodebalanceFactor$. (AVLTree.sil,1055:3) [12610]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodebalanceFactor$);
      assume state(Heap, Mask);
    
    // -- Check definedness of (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1055:3) [12611]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1055:3) [12612]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1055:3) [12613]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1055:3) [12614]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1055:3) [12615]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1055:3) [12616]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1055:3) [12617]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1055:3) [12618]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1055:3) [12619]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1055:3) [12620]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1055:3) [12621]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1055:3) [12622]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    Heap[this$_16, AVLTreeNodebalanceFactor$] := (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodebalanceFactor$. (AVLTree.sil,1055:3) [12623]"}
      FullPerm[$frac] == Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] && FullPerm[$eps] == Mask[this$_16, AVLTreeNodebalanceFactor$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_16.AVLTreeNodekeys$ := (this$_16.AVLTreeNodeleft$ == null ? Seq() : this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_16.AVLTreeNodekey$) ++ (this$_16.AVLTreeNoderight$ == null ? Seq() : this$_16.AVLTreeNoderight$.AVLTreeNodekeys$) -- AVLTree.sil,1056:3
    
    // -- Check definedness of this$_16.AVLTreeNodekeys$
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodekeys$ might be null. (AVLTree.sil,1056:3) [12624]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodekeys$. (AVLTree.sil,1056:3) [12625]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodekeys$);
      assume state(Heap, Mask);
    
    // -- Check definedness of (this$_16.AVLTreeNodeleft$ == null ? Seq() : this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_16.AVLTreeNodekey$) ++ (this$_16.AVLTreeNoderight$ == null ? Seq() : this$_16.AVLTreeNoderight$.AVLTreeNodekeys$)
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1056:3) [12626]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1056:3) [12627]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      if (Heap[this$_16, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1056:3) [12628]"}
          Heap[this$_16, AVLTreeNodeleft$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1056:3) [12629]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1056:3) [12630]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1056:3) [12631]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNodeleft$);
      }
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1056:3) [12632]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1056:3) [12633]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodekey$);
      assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1056:3) [12634]"}
        this$_16 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1056:3) [12635]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      if (Heap[this$_16, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1056:3) [12636]"}
          Heap[this$_16, AVLTreeNoderight$] != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1056:3) [12637]"}
          HasDirectPerm(Mask, Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Assignment might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1056:3) [12638]"}
          this$_16 != null;
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1056:3) [12639]"}
          HasDirectPerm(Mask, this$_16, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    Heap[this$_16, AVLTreeNodekeys$] := Seq#Append(Seq#Append((if Heap[this$_16, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_16, AVLTreeNodekey$])), (if Heap[this$_16, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$]));
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_16.AVLTreeNodekeys$. (AVLTree.sil,1056:3) [12640]"}
      FullPerm[$frac] == Mask[this$_16, AVLTreeNodekeys$][$frac] && FullPerm[$eps] == Mask[this$_16, AVLTreeNodekeys$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: assert Seq(this$_16.AVLTreeNodekey$)[0] == this$_16.AVLTreeNodekey$ -- AVLTree.sil,1057:3
    
    // -- Check definedness of Seq(this$_16.AVLTreeNodekey$)[0] == this$_16.AVLTreeNodekey$
      assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1057:3) [12641]"}
        this$_16 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1057:3) [12642]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodekey$);
      assert {:msg "  Assert might fail. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1057:3) [12643]"}
        this$_16 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1057:3) [12644]"}
        HasDirectPerm(Mask, this$_16, AVLTreeNodekey$);
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion Seq(this$_16.AVLTreeNodekey$)[0] == this$_16.AVLTreeNodekey$ might not hold. (AVLTree.sil,1057:3) [12645]"}
      Seq#Index(Seq#Singleton(Heap[this$_16, AVLTreeNodekey$]), 0) == Heap[this$_16, AVLTreeNodekey$];
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(AVLTreeNodevalid$(this$_16), write) -- AVLTree.sil,1058:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(this$_16));
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,1058:3) [12646]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodekey$ might be null. (AVLTree.sil,1058:3) [12647]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodekey$. (AVLTree.sil,1058:3) [12648]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodekey$][$eps]);
    }
    Mask[this$_16, AVLTreeNodekey$] := PermSub(Mask[this$_16, AVLTreeNodekey$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12649]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodeheight$ might be null. (AVLTree.sil,1058:3) [12650]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodeheight$. (AVLTree.sil,1058:3) [12651]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodeheight$][$eps]);
    }
    Mask[this$_16, AVLTreeNodeheight$] := PermSub(Mask[this$_16, AVLTreeNodeheight$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,1058:3) [12652]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodeleft$ might be null. (AVLTree.sil,1058:3) [12653]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$. (AVLTree.sil,1058:3) [12654]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodeleft$][$eps]);
    }
    Mask[this$_16, AVLTreeNodeleft$] := PermSub(Mask[this$_16, AVLTreeNodeleft$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 100 / 100 might not be positive. (AVLTree.sil,1058:3) [12655]"}
      Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNoderight$ might be null. (AVLTree.sil,1058:3) [12656]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$. (AVLTree.sil,1058:3) [12657]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNoderight$][$eps]);
    }
    Mask[this$_16, AVLTreeNoderight$] := PermSub(Mask[this$_16, AVLTreeNoderight$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12658]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodekeys$ might be null. (AVLTree.sil,1058:3) [12659]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodekeys$. (AVLTree.sil,1058:3) [12660]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodekeys$][$eps]);
    }
    Mask[this$_16, AVLTreeNodekeys$] := PermSub(Mask[this$_16, AVLTreeNodekeys$], perm);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12661]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1058:3) [12662]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodebalanceFactor$. (AVLTree.sil,1058:3) [12663]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[this$_16, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_16, AVLTreeNodebalanceFactor$], perm);
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_16.AVLTreeNodeleft$). (AVLTree.sil,1058:3) [12666]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_16, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_16)], Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12667]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1058:3) [12668]"}
        Heap[this$_16, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1058:3) [12669]"}
          (perm[$frac] < Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12670]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1058:3) [12671]"}
        Heap[this$_16, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1058:3) [12672]"}
          (perm[$frac] < Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12673]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1058:3) [12674]"}
        Heap[this$_16, AVLTreeNodeleft$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1058:3) [12675]"}
          (perm[$frac] < Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion (forall lk: Int :: true && lk in this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (lk < this$_16.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1058:3) [12676]"}
        (forall lk_2: int ::
        
        Seq#Contains(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < Heap[this$_16, AVLTreeNodekey$]
      );
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,1058:3) [12677]"}
        Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_16.AVLTreeNoderight$). (AVLTree.sil,1058:3) [12680]"}
          (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])][$eps]);
      }
      Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])], perm);
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_16, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_16)], Heap[this$_16, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])]);
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12681]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1058:3) [12682]"}
        Heap[this$_16, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1058:3) [12683]"}
          (perm[$frac] < Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
      }
      Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12684]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1058:3) [12685]"}
        Heap[this$_16, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1058:3) [12686]"}
          (perm[$frac] < Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
      }
      Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Fraction 50 / 100 might not be positive. (AVLTree.sil,1058:3) [12687]"}
        Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Receiver of this$_16.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1058:3) [12688]"}
        Heap[this$_16, AVLTreeNoderight$] != null;
      perm := NoPerm;
      perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
      if (perm != NoPerm) {
        assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. There might be insufficient permission to access this$_16.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1058:3) [12689]"}
          (perm[$frac] < Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
      }
      Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion (forall rk: Int :: true && rk in this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_16.AVLTreeNodekey$ < rk)) might not hold. (AVLTree.sil,1058:3) [12690]"}
        (forall rk_2: int ::
        
        Seq#Contains(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> Heap[this$_16, AVLTreeNodekey$] < rk_2
      );
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNoderight$.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,1058:3) [12691]"}
        Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodekeys$ == (this$_16.AVLTreeNodeleft$ == null ? Seq() : this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(this$_16.AVLTreeNodekey$) ++ (this$_16.AVLTreeNoderight$ == null ? Seq() : this$_16.AVLTreeNoderight$.AVLTreeNodekeys$) might not hold. (AVLTree.sil,1058:3) [12692]"}
      Seq#Equal(Heap[this$_16, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[this$_16, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[this$_16, AVLTreeNodekey$])), (if Heap[this$_16, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodekey$ in this$_16.AVLTreeNodekeys$ might not hold. (AVLTree.sil,1058:3) [12693]"}
      Seq#Contains(Heap[this$_16, AVLTreeNodekeys$], Heap[this$_16, AVLTreeNodekey$]);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion (forall kk: Int :: true ==> (kk in this$_16.AVLTreeNodekeys$ == (this$_16.AVLTreeNodeleft$ != null) && kk in this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$ || ((this$_16.AVLTreeNoderight$ != null) && kk in this$_16.AVLTreeNoderight$.AVLTreeNodekeys$ || (kk == this$_16.AVLTreeNodekey$)))) might not hold. (AVLTree.sil,1058:3) [12694]"}
      (forall kk_2: int ::
      
      Seq#Contains(Heap[this$_16, AVLTreeNodekeys$], kk_2) == ((Heap[this$_16, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((Heap[this$_16, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == Heap[this$_16, AVLTreeNodekey$]))
    );
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodeheight$ == ((this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) > (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) ? (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1 : (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,1058:3) [12695]"}
      Heap[this$_16, AVLTreeNodeheight$] == (if (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodebalanceFactor$ == (this$_16.AVLTreeNodeleft$ == null ? 0 : this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_16.AVLTreeNoderight$ == null ? 0 : this$_16.AVLTreeNoderight$.AVLTreeNodeheight$) might not hold. (AVLTree.sil,1058:3) [12696]"}
      Heap[this$_16, AVLTreeNodebalanceFactor$] == (if Heap[this$_16, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_16, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodebalanceFactor$ <= 1 might not hold. (AVLTree.sil,1058:3) [12697]"}
      Heap[this$_16, AVLTreeNodebalanceFactor$] <= 1;
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodebalanceFactor$ >= 0 - 1 might not hold. (AVLTree.sil,1058:3) [12698]"}
      Heap[this$_16, AVLTreeNodebalanceFactor$] >= -1;
    assert {:msg "  Folding AVLTreeNodevalid$(this$_16) might fail. Assertion this$_16.AVLTreeNodeheight$ > 0 might not hold. (AVLTree.sil,1058:3) [12699]"}
      Heap[this$_16, AVLTreeNodeheight$] > 0;
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_16, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_16)], Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_16, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_16)], Heap[this$_16, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])]);
    }
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_16, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_16)], Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNodeleft$])]);
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      
      // -- Record predicate instance information
        assume InsidePredicate(this$_16, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(this$_16)], Heap[this$_16, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_16, AVLTreeNoderight$])]);
    }
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(this$_16)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_16)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(this$_16)] := ZeroPMask;
    havoc freshVersion;
    Heap[null, AVLTreeNodevalid$(this$_16)] := freshVersion;
    Heap[null, AVLTreeNodevalid$#sm(this$_16)][this$_16, AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_16)][this$_16, AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_16)][this$_16, AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_16)][this$_16, AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_16)][this$_16, AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(this$_16)][this$_16, AVLTreeNodebalanceFactor$] := true;
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_50: Ref, f_53: (Field A B) ::
        { newPMask[o_50, f_53] }
        Heap[null, AVLTreeNodevalid$#sm(this$_16)][o_50, f_53] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNodeleft$])][o_50, f_53] ==> newPMask[o_50, f_53]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_16)] := newPMask;
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_16)][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_16)][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_16, AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_16)][Heap[this$_16, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_51: Ref, f_54: (Field A B) ::
        { newPMask[o_51, f_54] }
        Heap[null, AVLTreeNodevalid$#sm(this$_16)][o_51, f_54] || Heap[null, AVLTreeNodevalid$#sm(Heap[this$_16, AVLTreeNoderight$])][o_51, f_54] ==> newPMask[o_51, f_54]
      );
      Heap[null, AVLTreeNodevalid$#sm(this$_16)] := newPMask;
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_16)][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_16)][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[this$_16, AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(this$_16)][Heap[this$_16, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_16). (AVLTree.sil,1036:11) [12700]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(this$_16)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_16)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(this$_16)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(this$_16)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(this$_16)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(this$_16)] := PermSub(Mask[null, AVLTreeNodevalid$(this$_16)], perm);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1037:11) [12701]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Receiver of this$_16.AVLTreeNodeheight$ might be null. (AVLTree.sil,1037:11) [12702]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_16.AVLTreeNodeheight$. (AVLTree.sil,1037:11) [12703]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodeheight$][$eps]);
    }
    Mask[this$_16, AVLTreeNodeheight$] := PermSub(Mask[this$_16, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1038:11) [12704]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Receiver of this$_16.AVLTreeNodekeys$ might be null. (AVLTree.sil,1038:11) [12705]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_16.AVLTreeNodekeys$. (AVLTree.sil,1038:11) [12706]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodekeys$][$eps]);
    }
    Mask[this$_16, AVLTreeNodekeys$] := PermSub(Mask[this$_16, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1039:11) [12707]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Receiver of this$_16.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1039:11) [12708]"}
      this$_16 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_16.AVLTreeNodebalanceFactor$. (AVLTree.sil,1039:11) [12709]"}
        (perm[$frac] < Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_16, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_16, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_16, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[this$_16, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_16, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Assertion this$_16.AVLTreeNodekeys$ == (old(this$_16.AVLTreeNodeleft$) == null ? Seq() : old(this$_16.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_16.AVLTreeNodekey$)) ++ (old(this$_16.AVLTreeNoderight$) == null ? Seq() : old(this$_16.AVLTreeNoderight$.AVLTreeNodekeys$)) might not hold. (AVLTree.sil,1040:11) [12710]"}
      Seq#Equal(Heap[this$_16, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_16, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_16, AVLTreeNodekey$])), (if old(Heap)[this$_16, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Assertion this$_16.AVLTreeNodeheight$ == ((old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) > (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) ? (old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) + 1 : (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) + 1) might not hold. (AVLTree.sil,1041:11) [12711]"}
      Heap[this$_16, AVLTreeNodeheight$] == (if (if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assert {:msg "  Postcondition of AVLTreeNodeclose$ might not hold. Assertion this$_16.AVLTreeNodebalanceFactor$ == (old(this$_16.AVLTreeNodeleft$) == null ? 0 : old(this$_16.AVLTreeNodeleft$.AVLTreeNodeheight$)) - (old(this$_16.AVLTreeNoderight$) == null ? 0 : old(this$_16.AVLTreeNoderight$.AVLTreeNodeheight$)) might not hold. (AVLTree.sil,1042:11) [12712]"}
      Heap[this$_16, AVLTreeNodebalanceFactor$] == (if old(Heap)[this$_16, AVLTreeNodeleft$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if old(Heap)[this$_16, AVLTreeNoderight$] == null then 0 else old(Heap)[old(Heap)[this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderebalanceLeft$
// ==================================================

procedure AVLTreeNoderebalanceLeft$(this$_17: Ref, k$_13: Perm) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k0_11: int;
  var k1_10: int;
  var newK$_18: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_14: Ref;
  var lbf: int;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newK$_19: Perm;
  var newK$_20: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_17 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_13[$frac] || (NoPerm[$frac] == k$_13[$frac] && NoPerm[$eps] < k$_13[$eps]);
    assume state(Heap, Mask);
    assume k$_13[$frac] < FullPerm[$frac] || (k$_13[$frac] == FullPerm[$frac] && k$_13[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_17 != null;
    Mask[this$_17, AVLTreeNodekey$] := PermAdd(Mask[this$_17, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_17 != null;
    Mask[this$_17, AVLTreeNodeheight$] := PermAdd(Mask[this$_17, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_17 != null;
    Mask[this$_17, AVLTreeNodeleft$] := PermAdd(Mask[this$_17, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_17 != null;
    Mask[this$_17, AVLTreeNoderight$] := PermAdd(Mask[this$_17, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_17 != null;
    Mask[this$_17, AVLTreeNodekeys$] := PermAdd(Mask[this$_17, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_17 != null;
    Mask[this$_17, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_17, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_17.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1071:12) [12713]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1071:12) [12714]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume Heap[this$_17, AVLTreeNodeleft$] != null;
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1072:12) [12715]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1073:12) [12716]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1073:12) [12717]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_17, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1074:12) [12718]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1074:12) [12719]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_17, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1075:12) [12720]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1075:12) [12721]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_17, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall k0: Int :: true && k0 in this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_17.AVLTreeNodekey$))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1076:13) [12722]"}
        Heap[this$_17, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1076:13) [12723]"}
        HasDirectPerm(Mask, Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1076:13) [12724]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1076:13) [12725]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      if (Seq#Contains(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_11)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodekey$ might be null. (AVLTree.sil,1076:13) [12726]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodekey$. (AVLTree.sil,1076:13) [12727]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    assume (forall k0_1: int ::
      
      Seq#Contains(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[this$_17, AVLTreeNodekey$]
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_17.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1077:12) [12728]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1077:12) [12729]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_17, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_17.AVLTreeNoderight$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1077:12) [12730]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_17.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1078:12) [12731]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1078:12) [12732]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_17, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_17.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1078:12) [12733]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1078:12) [12734]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_17, AVLTreeNoderight$] != null;
      Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_17.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1079:12) [12735]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1079:12) [12736]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_17, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_17.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1079:12) [12737]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1079:12) [12738]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_17, AVLTreeNoderight$] != null;
      Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_17.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1080:12) [12739]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1080:12) [12740]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_17, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_17.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1080:12) [12741]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1080:12) [12742]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_17, AVLTreeNoderight$] != null;
      Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_17.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1081:12) [12743]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1081:12) [12744]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_17, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of (forall k1: Int :: true && k1 in this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_17.AVLTreeNodekey$ < k1))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1081:12) [12745]"}
          Heap[this$_17, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1081:12) [12746]"}
          HasDirectPerm(Mask, Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1081:12) [12747]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1081:12) [12748]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
        if (Seq#Contains(Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], k1_10)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodekey$ might be null. (AVLTree.sil,1081:12) [12749]"}
            this$_17 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodekey$. (AVLTree.sil,1081:12) [12750]"}
            HasDirectPerm(Mask, this$_17, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k1_1: int ::
        
        Seq#Contains(Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_17, AVLTreeNodekey$] < k1_1
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_17.AVLTreeNoderight$ == null ? 0 : this$_17.AVLTreeNoderight$.AVLTreeNodeheight$) == 2
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1082:12) [12751]"}
        Heap[this$_17, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1082:12) [12752]"}
        HasDirectPerm(Mask, Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1082:12) [12753]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1082:12) [12754]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1082:12) [12755]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1082:12) [12756]"}
        HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      if (Heap[this$_17, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1082:12) [12757]"}
          Heap[this$_17, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1082:12) [12758]"}
          HasDirectPerm(Mask, Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1082:12) [12759]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1082:12) [12760]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_17, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1088:11) [12761]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1088:11) [12762]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1088:11) [12763]"}
        old(Heap)[this$_17, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1088:11) [12764]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1088:11) [12765]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1088:11) [12766]"}
        HasDirectPerm(old(Mask), this$_17, AVLTreeNodeleft$);
      if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$])) {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1088:11) [12767]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1088:11) [12768]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1088:11) [12769]"}
          old(Heap)[this$_17, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1088:11) [12770]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1088:11) [12771]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1088:11) [12772]"}
          HasDirectPerm(old(Mask), this$_17, AVLTreeNodeleft$);
      }
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodekeys$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_17.AVLTreeNodekey$)) ++ (old(this$_17.AVLTreeNoderight$) == null ? Seq() : old(this$_17.AVLTreeNoderight$.AVLTreeNodekeys$))
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1089:11) [12773]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1089:11) [12774]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1089:11) [12775]"}
        old(Heap)[this$_17, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1089:11) [12776]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1089:11) [12777]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1089:11) [12778]"}
        HasDirectPerm(old(Mask), this$_17, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNodekey$ might be null. (AVLTree.sil,1089:11) [12779]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNodekey$. (AVLTree.sil,1089:11) [12780]"}
        HasDirectPerm(old(Mask), this$_17, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1089:11) [12781]"}
        this$_17 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1089:11) [12782]"}
        HasDirectPerm(old(Mask), this$_17, AVLTreeNoderight$);
      if (old(Heap)[this$_17, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1089:11) [12783]"}
          old(Heap)[this$_17, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1089:11) [12784]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1089:11) [12785]"}
          this$_17 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1089:11) [12786]"}
          HasDirectPerm(old(Mask), this$_17, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(old(Heap)[this$_17, AVLTreeNodekey$])), (if old(Heap)[this$_17, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_17 == null || Heap[this$_17, $allocated];
    assume k$_13[$eps] == 0.000000000;
  
  // -- Translating statement: fresh newK$_18  -- AVLTree.sil,1099:3
    
    // -- Translation of statement fresh newK$_18)
      havoc newK$_18;
      assume (newK$_18[$frac] > 0.000000000 && newK$_18[$frac] < 0.001000000) && newK$_18[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_18) -- AVLTree.sil,1100:3
    
    // -- Translating statement: lbf := AVLTreeNodegetBalanceFactor$(this$_17.AVLTreeNodeleft$, newK$_18) -- AVLTree.sil,1101:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Check definedness of this$_17.AVLTreeNodeleft$
        assert {:msg "  Method call might fail. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1101:5) [12787]"}
          this$_17 != null;
        assert {:msg "  Method call might fail. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1101:5) [12788]"}
          HasDirectPerm(Mask, this$_17, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      arg_this$_14 := Heap[this$_17, AVLTreeNodeleft$];
      havoc lbf;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Assertion this$_17.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,1101:5) [12789]"}
          Heap[this$_17, AVLTreeNodeleft$] != null;
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Assertion newK$_18 > none might not hold. (AVLTree.sil,1101:5) [12790]"}
          NoPerm[$frac] < newK$_18[$frac] || (NoPerm[$frac] == newK$_18[$frac] && NoPerm[$eps] < newK$_18[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Assertion write > newK$_18 might not hold. (AVLTree.sil,1101:5) [12791]"}
          newK$_18[$frac] < FullPerm[$frac] || (newK$_18[$frac] == FullPerm[$frac] && newK$_18[$eps] < FullPerm[$eps]);
        perm := NoPerm;
        perm := PermAdd(perm, FullPerm);
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$). (AVLTree.sil,1101:5) [12792]"}
            (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$eps]);
        }
        Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])], perm);
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Fraction newK$_18 might not be positive. (AVLTree.sil,1101:5) [12793]"}
          newK$_18[$frac] > 0.000000000 || (newK$_18[$frac] == 0.000000000 && newK$_18[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1101:5) [12794]"}
          Heap[this$_17, AVLTreeNodeleft$] != null;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        perm := NoPerm;
        perm := PermAdd(perm, newK$_18);
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1101:5) [12795]"}
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] > 0.000000000;
          assume perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac];
        }
        Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(arg_this$_14)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_14)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := newK$_18;
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_14 != null;
        Mask[arg_this$_14, AVLTreeNodebalanceFactor$] := PermAdd(Mask[arg_this$_14, AVLTreeNodebalanceFactor$], perm);
        assume lbf == Heap[arg_this$_14, AVLTreeNodebalanceFactor$];
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_52: Ref, f_55: (Field A B) ::
            { newPMask[o_52, f_55] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_52, f_55] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_52, f_55] ==> newPMask[o_52, f_55]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_53: Ref, f_56: (Field A B) ::
            { newPMask[o_53, f_56] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_53, f_56] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_53, f_56] ==> newPMask[o_53, f_56]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
        assume lbf > 0 ==> Heap[arg_this$_14, AVLTreeNodeleft$] != null;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_54: Ref, f_57: (Field A B) ::
            { newPMask[o_54, f_57] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_54, f_57] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_54, f_57] ==> newPMask[o_54, f_57]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_55: Ref, f_58: (Field A B) ::
            { newPMask[o_55, f_58] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_55, f_58] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_55, f_58] ==> newPMask[o_55, f_58]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
        assume lbf < 0 ==> Heap[arg_this$_14, AVLTreeNoderight$] != null;
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_56: Ref, f_59: (Field A B) ::
              { newPMask[o_56, f_59] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_56, f_59] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_56, f_59] ==> newPMask[o_56, f_59]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_57: Ref, f_60: (Field A B) ::
              { newPMask[o_57, f_60] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_57, f_60] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_57, f_60] ==> newPMask[o_57, f_60]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_58: Ref, f_61: (Field A B) ::
              { newPMask[o_58, f_61] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_58, f_61] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_58, f_61] ==> newPMask[o_58, f_61]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_59: Ref, f_62: (Field A B) ::
              { newPMask[o_59, f_62] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_59, f_62] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_59, f_62] ==> newPMask[o_59, f_62]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
        assume state(Heap, Mask);
        
        // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(arg_this$_14), write) in (lbf > 0) ==> (arg_this$_14.AVLTreeNodeleft$ != null))
          UnfoldingHeap := Heap;
          UnfoldingMask := Mask;
          assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(arg_this$_14));
          // Phase 1: pure assertions and fixed permissions
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  An internal error occurred. There might be insufficient permission to access AVLTreeNodevalid$(arg_this$_14). (AVLTree.sil,963:12) [12796]"}
              (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps]);
          }
          UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)], perm);
          
          // -- Update version of predicate
            if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(arg_this$_14))) {
              oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)];
              havoc newVersion;
              assume oldVersion < newVersion;
              UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)] := newVersion;
            }
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekey$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekey$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeheight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeheight$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeleft$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeleft$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNoderight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNoderight$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekeys$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekeys$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$], perm);
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume (forall lk: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume (forall rk: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[arg_this$_14, AVLTreeNodekey$] < rk
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          }
          assume Seq#Equal(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[arg_this$_14, AVLTreeNodekey$])), (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
          assume Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]);
          assume (forall kk: int ::
            
            Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], kk) == ((UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]))
          );
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] == (if (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] <= 1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] >= -1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] > 0;
          assume state(UnfoldingHeap, UnfoldingMask);
          
          // -- Free assumptions
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_60: Ref, f_63: (Field A B) ::
                { newPMask[o_60, f_63] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_60, f_63] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_60, f_63] ==> newPMask[o_60, f_63]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_61: Ref, f_64: (Field A B) ::
                { newPMask[o_61, f_64] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_61, f_64] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_61, f_64] ==> newPMask[o_61, f_64]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            }
          assume state(Heap, Mask);
        
        // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(arg_this$_14), write) in (lbf < 0) ==> (arg_this$_14.AVLTreeNoderight$ != null))
          UnfoldingHeap := Heap;
          UnfoldingMask := Mask;
          assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(arg_this$_14));
          // Phase 1: pure assertions and fixed permissions
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  An internal error occurred. There might be insufficient permission to access AVLTreeNodevalid$(arg_this$_14). (AVLTree.sil,964:12) [12797]"}
              (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps]);
          }
          UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)], perm);
          
          // -- Update version of predicate
            if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(arg_this$_14))) {
              oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)];
              havoc newVersion;
              assume oldVersion < newVersion;
              UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)] := newVersion;
            }
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekey$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekey$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeheight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeheight$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeleft$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeleft$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNoderight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNoderight$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekeys$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekeys$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$], perm);
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume (forall lk_1: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume (forall rk_1: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> UnfoldingHeap[arg_this$_14, AVLTreeNodekey$] < rk_1
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          }
          assume Seq#Equal(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[arg_this$_14, AVLTreeNodekey$])), (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
          assume Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]);
          assume (forall kk_1: int ::
            
            Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], kk_1) == ((UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]))
          );
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] == (if (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] <= 1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] >= -1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] > 0;
          assume state(UnfoldingHeap, UnfoldingMask);
          
          // -- Free assumptions
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_62: Ref, f_65: (Field A B) ::
                { newPMask[o_62, f_65] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_62, f_65] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_62, f_65] ==> newPMask[o_62, f_65]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_63: Ref, f_66: (Field A B) ::
                { newPMask[o_63, f_66] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_63, f_66] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_63, f_66] ==> newPMask[o_63, f_66]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            }
          assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. The parameter newK$_18 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1101:5) [12798]"}
        newK$_18[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (lbf < 0) -- AVLTree.sil,1103:3
    if (lbf < 0) {
      
      // -- Translating statement: assert (unfolding acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write) in lbf == 0 - 1) -- AVLTree.sil,1104:5
        
        // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write) in lbf == 0 - 1)
          UnfoldingHeap := Heap;
          UnfoldingMask := Mask;
          assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$]));
          // Phase 1: pure assertions and fixed permissions
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$). (AVLTree.sil,1104:5) [12799]"}
              (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$eps]);
          }
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])], perm);
          
          // -- Update version of predicate
            if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$]))) {
              oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])];
              havoc newVersion;
              assume oldVersion < newVersion;
              UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])] := newVersion;
            }
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
          UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            assume (forall lk_2: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$]
            );
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])]);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            assume (forall rk_2: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] < rk_2
            );
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          }
          assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
          assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$]);
          assume (forall kk_2: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2) == ((UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$]))
          );
          assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
          assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
          assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
          assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
          assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          assume state(UnfoldingHeap, UnfoldingMask);
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1104:5) [12800]"}
            HasDirectPerm(UnfoldingMask, this$_17, AVLTreeNodeleft$);
          
          // -- Free assumptions
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_64: Ref, f_67: (Field A B) ::
                { newPMask[o_64, f_67] }
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_64, f_67] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_64, f_67] ==> newPMask[o_64, f_67]
              );
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_65: Ref, f_68: (Field A B) ::
                { newPMask[o_65, f_68] }
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_65, f_68] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])][o_65, f_68] ==> newPMask[o_65, f_68]
              );
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            }
            if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write) in lbf == 0 - 1) might not hold. (AVLTree.sil,1104:5) [12801]"}
          lbf == -1;
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_66: Ref, f_69: (Field A B) ::
              { newPMask[o_66, f_69] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_66, f_69] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_66, f_69] ==> newPMask[o_66, f_69]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_67: Ref, f_70: (Field A B) ::
              { newPMask[o_67, f_70] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_67, f_70] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])][o_67, f_70] ==> newPMask[o_67, f_70]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_19  -- AVLTree.sil,1105:5
        
        // -- Translation of statement fresh newK$_19)
          havoc newK$_19;
          assume (newK$_19[$frac] > 0.000000000 && newK$_19[$frac] < 0.001000000) && newK$_19[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_19) -- AVLTree.sil,1106:5
        
        // -- Translating statement: r := AVLTreeNoderebalanceRL$(this$_17, newK$_19) -- AVLTree.sil,1107:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          havoc r_1;
          
          // -- Exhaling precondition
            
            // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write) in this$_17.AVLTreeNodeleft$.AVLTreeNoderight$ != null)
              UnfoldingHeap := Heap;
              UnfoldingMask := Mask;
              assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$]));
              // Phase 1: pure assertions and fixed permissions
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  An internal error occurred. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$). (AVLTree.sil,1138:13) [12802]"}
                  (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])][$eps]);
              }
              UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])], perm);
              
              // -- Update version of predicate
                if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$]))) {
                  oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])];
                  havoc newVersion;
                  assume oldVersion < newVersion;
                  UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])] := newVersion;
                }
              perm := Perm(1.000000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
              UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
              UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
              perm := Perm(1.000000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
              UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
              perm := Perm(1.000000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
              UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
              UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_17, AVLTreeNodeleft$] != null;
              UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                perm := FullPerm;
                UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                assume (forall lk_3: int ::
                  
                  Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_3) ==> lk_3 < UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$]
                );
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                perm := FullPerm;
                UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_17, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])]);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                assume (forall rk_3: int ::
                  
                  Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_3) ==> UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] < rk_3
                );
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
              }
              assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
              assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$]);
              assume (forall kk_3: int ::
                
                Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_3) == ((UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_3)) || ((UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_3)) || kk_3 == UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$]))
              );
              assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
              assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
              assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
              assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
              assume UnfoldingHeap[UnfoldingHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
              assume state(UnfoldingHeap, UnfoldingMask);
              
              // -- Free assumptions
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_68: Ref, f_71: (Field A B) ::
                    { newPMask[o_68, f_71] }
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_68, f_71] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_68, f_71] ==> newPMask[o_68, f_71]
                  );
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_69: Ref, f_72: (Field A B) ::
                    { newPMask[o_69, f_72] }
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_69, f_72] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])][o_69, f_72] ==> newPMask[o_69, f_72]
                  );
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
                }
                if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
                }
              assume state(Heap, Mask);
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion this$_17 != null might not hold. (AVLTree.sil,1107:7) [12803]"}
              this$_17 != null;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion newK$_19 > none might not hold. (AVLTree.sil,1107:7) [12804]"}
              NoPerm[$frac] < newK$_19[$frac] || (NoPerm[$frac] == newK$_19[$frac] && NoPerm[$eps] < newK$_19[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion write > newK$_19 might not hold. (AVLTree.sil,1107:7) [12805]"}
              newK$_19[$frac] < FullPerm[$frac] || (newK$_19[$frac] == FullPerm[$frac] && newK$_19[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1107:7) [12806]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodekey$ might be null. (AVLTree.sil,1107:7) [12807]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodekey$. (AVLTree.sil,1107:7) [12808]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodekey$][$eps]);
            }
            Mask[this$_17, AVLTreeNodekey$] := PermSub(Mask[this$_17, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1107:7) [12809]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodeheight$ might be null. (AVLTree.sil,1107:7) [12810]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeheight$. (AVLTree.sil,1107:7) [12811]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodeheight$][$eps]);
            }
            Mask[this$_17, AVLTreeNodeheight$] := PermSub(Mask[this$_17, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1107:7) [12812]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1107:7) [12813]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1107:7) [12814]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodeleft$][$eps]);
            }
            Mask[this$_17, AVLTreeNodeleft$] := PermSub(Mask[this$_17, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1107:7) [12815]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1107:7) [12816]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1107:7) [12817]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNoderight$][$eps]);
            }
            Mask[this$_17, AVLTreeNoderight$] := PermSub(Mask[this$_17, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1107:7) [12818]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodekeys$ might be null. (AVLTree.sil,1107:7) [12819]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodekeys$. (AVLTree.sil,1107:7) [12820]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodekeys$][$eps]);
            }
            Mask[this$_17, AVLTreeNodekeys$] := PermSub(Mask[this$_17, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1107:7) [12821]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1107:7) [12822]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodebalanceFactor$. (AVLTree.sil,1107:7) [12823]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[this$_17, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_17, AVLTreeNodebalanceFactor$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion this$_17.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,1107:7) [12824]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$). (AVLTree.sil,1107:7) [12825]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1107:7) [12826]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1107:7) [12827]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1107:7) [12828]"}
                (perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1107:7) [12829]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1107:7) [12830]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1107:7) [12831]"}
                (perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1107:7) [12832]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1107:7) [12833]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1107:7) [12834]"}
                (perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_17.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1107:7) [12835]"}
              (forall k0_2: int ::
              
              Seq#Contains(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_2) ==> k0_2 < Heap[this$_17, AVLTreeNodekey$]
            );
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNoderight$). (AVLTree.sil,1107:7) [12836]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1107:7) [12837]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1107:7) [12838]"}
                Heap[this$_17, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1107:7) [12839]"}
                  (perm[$frac] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1107:7) [12840]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1107:7) [12841]"}
                Heap[this$_17, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1107:7) [12842]"}
                  (perm[$frac] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1107:7) [12843]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1107:7) [12844]"}
                Heap[this$_17, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1107:7) [12845]"}
                  (perm[$frac] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_17.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1107:7) [12846]"}
                (forall k1_2: int ::
                
                Seq#Contains(Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[this$_17, AVLTreeNodekey$] < k1_2
              );
            }
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion (unfolding acc(AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$), write) in this$_17.AVLTreeNodeleft$.AVLTreeNoderight$ != null) might not hold. (AVLTree.sil,1107:7) [12847]"}
              Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_17.AVLTreeNoderight$ == null ? 0 : this$_17.AVLTreeNoderight$.AVLTreeNodeheight$) == 2 might not hold. (AVLTree.sil,1107:7) [12848]"}
              Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_17, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. Assertion this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ == 0 - 1 might not hold. (AVLTree.sil,1107:7) [12849]"}
              Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == -1;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            
            // -- Free assumptions
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_70: Ref, f_73: (Field A B) ::
                  { newPMask[o_70, f_73] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_70, f_73] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_70, f_73] ==> newPMask[o_70, f_73]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_71: Ref, f_74: (Field A B) ::
                  { newPMask[o_71, f_74] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][o_71, f_74] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$])][o_71, f_74] ==> newPMask[o_71, f_74]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])] := newPMask;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_17, AVLTreeNodeleft$])][Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
              }
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            assume r_1 != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$];
            assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(PreCallHeap[PreCallHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(PreCallHeap[this$_17, AVLTreeNodekey$])), (if PreCallHeap[this$_17, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$])));
            assume state(Heap, Mask);
          assume r_1 == null || Heap[r_1, $allocated];
          assert {:msg "  The precondition of method AVLTreeNoderebalanceRL$ might not hold. The parameter newK$_19 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1107:7) [12850]"}
            newK$_19[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: fresh newK$_20  -- AVLTree.sil,1110:5
        
        // -- Translation of statement fresh newK$_20)
          havoc newK$_20;
          assume (newK$_20[$frac] > 0.000000000 && newK$_20[$frac] < 0.001000000) && newK$_20[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_20) -- AVLTree.sil,1111:5
        
        // -- Translating statement: r := AVLTreeNoderebalanceRR$(this$_17, newK$_20) -- AVLTree.sil,1112:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          havoc r_1;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion this$_17 != null might not hold. (AVLTree.sil,1112:7) [12851]"}
              this$_17 != null;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion newK$_20 > none might not hold. (AVLTree.sil,1112:7) [12852]"}
              NoPerm[$frac] < newK$_20[$frac] || (NoPerm[$frac] == newK$_20[$frac] && NoPerm[$eps] < newK$_20[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion write > newK$_20 might not hold. (AVLTree.sil,1112:7) [12853]"}
              newK$_20[$frac] < FullPerm[$frac] || (newK$_20[$frac] == FullPerm[$frac] && newK$_20[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1112:7) [12854]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodekey$ might be null. (AVLTree.sil,1112:7) [12855]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodekey$. (AVLTree.sil,1112:7) [12856]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodekey$][$eps]);
            }
            Mask[this$_17, AVLTreeNodekey$] := PermSub(Mask[this$_17, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1112:7) [12857]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodeheight$ might be null. (AVLTree.sil,1112:7) [12858]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeheight$. (AVLTree.sil,1112:7) [12859]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodeheight$][$eps]);
            }
            Mask[this$_17, AVLTreeNodeheight$] := PermSub(Mask[this$_17, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1112:7) [12860]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodeleft$ might be null. (AVLTree.sil,1112:7) [12861]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$. (AVLTree.sil,1112:7) [12862]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodeleft$][$eps]);
            }
            Mask[this$_17, AVLTreeNodeleft$] := PermSub(Mask[this$_17, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1112:7) [12863]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNoderight$ might be null. (AVLTree.sil,1112:7) [12864]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$. (AVLTree.sil,1112:7) [12865]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNoderight$][$eps]);
            }
            Mask[this$_17, AVLTreeNoderight$] := PermSub(Mask[this$_17, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1112:7) [12866]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodekeys$ might be null. (AVLTree.sil,1112:7) [12867]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodekeys$. (AVLTree.sil,1112:7) [12868]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodekeys$][$eps]);
            }
            Mask[this$_17, AVLTreeNodekeys$] := PermSub(Mask[this$_17, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1112:7) [12869]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1112:7) [12870]"}
              this$_17 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodebalanceFactor$. (AVLTree.sil,1112:7) [12871]"}
                (perm[$frac] < Mask[this$_17, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_17, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_17, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_17, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_17, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[this$_17, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_17, AVLTreeNodebalanceFactor$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion this$_17.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,1112:7) [12872]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNodeleft$). (AVLTree.sil,1112:7) [12873]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNodeleft$])], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1112:7) [12874]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1112:7) [12875]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1112:7) [12876]"}
                (perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1112:7) [12877]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1112:7) [12878]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1112:7) [12879]"}
                (perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1112:7) [12880]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1112:7) [12881]"}
              Heap[this$_17, AVLTreeNodeleft$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1112:7) [12882]"}
                (perm[$frac] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion (forall k: Int :: true && k in this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_17.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1112:7) [12883]"}
              (forall k: int ::
              
              Seq#Contains(Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], k) ==> k < Heap[this$_17, AVLTreeNodekey$]
            );
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_17.AVLTreeNoderight$). (AVLTree.sil,1112:7) [12884]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_17, AVLTreeNoderight$])], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1112:7) [12885]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1112:7) [12886]"}
                Heap[this$_17, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1112:7) [12887]"}
                  (perm[$frac] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1112:7) [12888]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1112:7) [12889]"}
                Heap[this$_17, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1112:7) [12890]"}
                  (perm[$frac] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1112:7) [12891]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Receiver of this$_17.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1112:7) [12892]"}
                Heap[this$_17, AVLTreeNoderight$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access this$_17.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1112:7) [12893]"}
                  (perm[$frac] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_17, AVLTreeNoderight$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_17.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_17.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1112:7) [12894]"}
                (forall k1_3: int ::
                
                Seq#Contains(Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_17, AVLTreeNodekey$] < k1_3
              );
            }
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_17.AVLTreeNoderight$ == null ? 0 : this$_17.AVLTreeNoderight$.AVLTreeNodeheight$) == 2 might not hold. (AVLTree.sil,1112:7) [12895]"}
              Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_17, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_17, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. Assertion this$_17.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ >= 0 might not hold. (AVLTree.sil,1112:7) [12896]"}
              Heap[Heap[this$_17, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= 0;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            assume r_1 != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
            assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(PreCallHeap[PreCallHeap[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(PreCallHeap[this$_17, AVLTreeNodekey$])), (if PreCallHeap[this$_17, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$])));
            assume state(Heap, Mask);
          assume r_1 == null || Heap[r_1, $allocated];
          assert {:msg "  The precondition of method AVLTreeNoderebalanceRR$ might not hold. The parameter newK$_20 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1112:7) [12897]"}
            newK$_20[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1083:11) [12898]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1084:11) [12899]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1085:11) [12900]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1085:11) [12901]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1085:11) [12902]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1086:11) [12903]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1086:11) [12904]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1086:11) [12905]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1087:11) [12906]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1087:11) [12907]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1087:11) [12908]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,1088:11) [12909]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLeft$ might not hold. Assertion r.AVLTreeNodekeys$ == old(this$_17.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_17.AVLTreeNodekey$)) ++ (old(this$_17.AVLTreeNoderight$) == null ? Seq() : old(this$_17.AVLTreeNoderight$.AVLTreeNodekeys$)) might not hold. (AVLTree.sil,1089:11) [12910]"}
      Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this$_17, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(old(Heap)[this$_17, AVLTreeNodekey$])), (if old(Heap)[this$_17, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_17, AVLTreeNoderight$], AVLTreeNodekeys$])));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderebalanceRL$
// ==================================================

procedure AVLTreeNoderebalanceRL$(this$_18: Ref, k$_14: Perm) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k0_12: int;
  var k1_11: int;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newPMask: PMaskType;
  var k2_3: int;
  var k3: int;
  var k4: int;
  var newK$_25: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_16: Ref;
  var ExhaleHeap: HeapType;
  var k5: int;
  var newK$_26: Perm;
  var newK$_27: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_18 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_14[$frac] || (NoPerm[$frac] == k$_14[$frac] && NoPerm[$eps] < k$_14[$eps]);
    assume state(Heap, Mask);
    assume k$_14[$frac] < FullPerm[$frac] || (k$_14[$frac] == FullPerm[$frac] && k$_14[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_18 != null;
    Mask[this$_18, AVLTreeNodekey$] := PermAdd(Mask[this$_18, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_18 != null;
    Mask[this$_18, AVLTreeNodeheight$] := PermAdd(Mask[this$_18, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_18 != null;
    Mask[this$_18, AVLTreeNodeleft$] := PermAdd(Mask[this$_18, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_18 != null;
    Mask[this$_18, AVLTreeNoderight$] := PermAdd(Mask[this$_18, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_18 != null;
    Mask[this$_18, AVLTreeNodekeys$] := PermAdd(Mask[this$_18, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_18 != null;
    Mask[this$_18, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_18, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1127:12) [12911]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1127:12) [12912]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1128:12) [12913]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1129:12) [12914]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1129:12) [12915]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1130:12) [12916]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1130:12) [12917]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1131:12) [12918]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1131:12) [12919]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall k0: Int :: true && k0 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_18.AVLTreeNodekey$))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1132:13) [12920]"}
        Heap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1132:13) [12921]"}
        HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1132:13) [12922]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1132:13) [12923]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      if (Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_12)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1132:13) [12924]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1132:13) [12925]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    assume (forall k0_1: int ::
      
      Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[this$_18, AVLTreeNodekey$]
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_18.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1133:12) [12926]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1133:12) [12927]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_18, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_18.AVLTreeNoderight$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1133:12) [12928]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_18.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1134:12) [12929]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1134:12) [12930]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_18, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_18.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1134:12) [12931]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1134:12) [12932]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_18, AVLTreeNoderight$] != null;
      Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_18.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1135:12) [12933]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1135:12) [12934]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_18, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_18.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1135:12) [12935]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1135:12) [12936]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_18, AVLTreeNoderight$] != null;
      Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_18.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1136:12) [12937]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1136:12) [12938]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_18, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_18.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1136:12) [12939]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1136:12) [12940]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_18, AVLTreeNoderight$] != null;
      Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_18.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1137:12) [12941]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1137:12) [12942]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_18, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of (forall k1: Int :: true && k1 in this$_18.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_18.AVLTreeNodekey$ < k1))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1137:12) [12943]"}
          Heap[this$_18, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1137:12) [12944]"}
          HasDirectPerm(Mask, Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1137:12) [12945]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1137:12) [12946]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
        if (Seq#Contains(Heap[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$], k1_11)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1137:12) [12947]"}
            this$_18 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1137:12) [12948]"}
            HasDirectPerm(Mask, this$_18, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k1_1: int ::
        
        Seq#Contains(Heap[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_18, AVLTreeNodekey$] < k1_1
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write) in this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ != null)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$]));
      // Phase 1: pure assertions and fixed permissions
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$). (AVLTree.sil,1138:13) [12949]"}
          (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])][$eps]);
      }
      UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])], perm);
      
      // -- Update version of predicate
        if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$]))) {
          oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])];
          havoc newVersion;
          assume oldVersion < newVersion;
          UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])] := newVersion;
        }
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        assume (forall lk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]
        );
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_18, AVLTreeNodeleft$])], UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])]);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        assume (forall rk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] < rk
        );
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
      }
      assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
      assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]);
      assume (forall kk: int ::
        
        Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], kk) == ((UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]))
      );
      assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
      assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
      assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
      assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
      assume UnfoldingHeap[UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1138:13) [12950]"}
        HasDirectPerm(UnfoldingMask, this$_18, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ might be null. (AVLTree.sil,1138:13) [12951]"}
        UnfoldingHeap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$. (AVLTree.sil,1138:13) [12952]"}
        HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1138:13) [12953]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1138:13) [12954]"}
        HasDirectPerm(UnfoldingMask, this$_18, AVLTreeNodeleft$);
      
      // -- Free assumptions
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_72: Ref, f_75: (Field A B) ::
            { newPMask[o_72, f_75] }
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][o_72, f_75] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_72, f_75] ==> newPMask[o_72, f_75]
          );
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])] := newPMask;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_73: Ref, f_76: (Field A B) ::
            { newPMask[o_73, f_76] }
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][o_73, f_76] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][o_73, f_76] ==> newPMask[o_73, f_76]
          );
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])] := newPMask;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
      assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_74: Ref, f_77: (Field A B) ::
        { newPMask[o_74, f_77] }
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][o_74, f_77] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_74, f_77] ==> newPMask[o_74, f_77]
      );
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])] := newPMask;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_75: Ref, f_78: (Field A B) ::
        { newPMask[o_75, f_78] }
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][o_75, f_78] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][o_75, f_78] ==> newPMask[o_75, f_78]
      );
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])] := newPMask;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_76: Ref, f_79: (Field A B) ::
          { newPMask[o_76, f_79] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][o_76, f_79] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][o_76, f_79] ==> newPMask[o_76, f_79]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])] := newPMask;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_77: Ref, f_80: (Field A B) ::
          { newPMask[o_77, f_80] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][o_77, f_80] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][o_77, f_80] ==> newPMask[o_77, f_80]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])] := newPMask;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_18, AVLTreeNodeleft$])][Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_18.AVLTreeNoderight$ == null ? 0 : this$_18.AVLTreeNoderight$.AVLTreeNodeheight$) == 2
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1139:12) [12955]"}
        Heap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1139:12) [12956]"}
        HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1139:12) [12957]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1139:12) [12958]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1139:12) [12959]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1139:12) [12960]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      if (Heap[this$_18, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1139:12) [12961]"}
          Heap[this$_18, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1139:12) [12962]"}
          HasDirectPerm(Mask, Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1139:12) [12963]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1139:12) [12964]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_18, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ == 0 - 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1140:12) [12965]"}
        Heap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1140:12) [12966]"}
        HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1140:12) [12967]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1140:12) [12968]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == -1;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodeheight$ == old(this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1146:11) [12969]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1146:11) [12970]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1146:11) [12971]"}
        old(Heap)[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1146:11) [12972]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1146:11) [12973]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1146:11) [12974]"}
        HasDirectPerm(old(Mask), this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$];
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodekeys$ == old(this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_18.AVLTreeNodekey$)) ++ (old(this$_18.AVLTreeNoderight$) == null ? Seq() : old(this$_18.AVLTreeNoderight$.AVLTreeNodekeys$))
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1147:11) [12975]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1147:11) [12976]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1147:11) [12977]"}
        old(Heap)[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1147:11) [12978]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1147:11) [12979]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1147:11) [12980]"}
        HasDirectPerm(old(Mask), this$_18, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1147:11) [12981]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1147:11) [12982]"}
        HasDirectPerm(old(Mask), this$_18, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1147:11) [12983]"}
        this$_18 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1147:11) [12984]"}
        HasDirectPerm(old(Mask), this$_18, AVLTreeNoderight$);
      if (old(Heap)[this$_18, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1147:11) [12985]"}
          old(Heap)[this$_18, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1147:11) [12986]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1147:11) [12987]"}
          this$_18 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1147:11) [12988]"}
          HasDirectPerm(old(Mask), this$_18, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(old(Heap)[this$_18, AVLTreeNodekey$])), (if old(Heap)[this$_18, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_18 == null || Heap[this$_18, $allocated];
    assume k$_14[$eps] == 0.000000000;
  
  // -- Translating statement: assert (forall k2: Int :: true && k2 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k2 < this$_18.AVLTreeNodekey$)) -- AVLTree.sil,1156:3
    
    // -- Check definedness of (forall k2: Int :: true && k2 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k2 < this$_18.AVLTreeNodekey$))
      assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1156:3) [12989]"}
        Heap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1156:3) [12990]"}
        HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1156:3) [12991]"}
        this$_18 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1156:3) [12992]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      if (Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k2_3)) {
        assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1156:3) [12993]"}
          this$_18 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1156:3) [12994]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion (forall k2: Int :: true && k2 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k2 < this$_18.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1156:3) [12995]"}
      (forall k2_1: int ::
      
      Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k2_1) ==> k2_1 < Heap[this$_18, AVLTreeNodekey$]
    );
    assume state(Heap, Mask);
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write) -- AVLTree.sil,1157:3
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$), write)
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$) might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1157:3) [12996]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$]));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$). (AVLTree.sil,1157:3) [12999]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$]))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_18, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])], Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      assume (forall lk_1: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]
      );
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      assume Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])], Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])]);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      assume (forall rk_1: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] < rk_1
      );
    }
    if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      assume Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$])), (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]);
    assume (forall kk_1: int ::
      
      Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1) == ((Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]))
    );
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r := this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ -- AVLTree.sil,1158:3
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ might be null. (AVLTree.sil,1158:3) [13000]"}
        Heap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$. (AVLTree.sil,1158:3) [13001]"}
        HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$);
      assert {:msg "  Assignment might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1158:3) [13002]"}
        this$_18 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1158:3) [13003]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    r_1 := Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$];
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (forall k3: Int :: true && k3 in r.AVLTreeNodekeys$ ==> (k3 < this$_18.AVLTreeNodekey$)) -- AVLTree.sil,1159:3
    
    // -- Check definedness of (forall k3: Int :: true && k3 in r.AVLTreeNodekeys$ ==> (k3 < this$_18.AVLTreeNodekey$))
      assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1159:3) [13004]"}
        r_1 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1159:3) [13005]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k3)) {
        assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1159:3) [13006]"}
          this$_18 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1159:3) [13007]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion (forall k3: Int :: true && k3 in r.AVLTreeNodekeys$ ==> (k3 < this$_18.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1159:3) [13008]"}
      (forall k3_1: int ::
      
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k3_1) ==> k3_1 < Heap[this$_18, AVLTreeNodekey$]
    );
    assume state(Heap, Mask);
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(r), write) -- AVLTree.sil,1160:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(r_1));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(r) might fail. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1160:3) [13011]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(r_1))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(r_1)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(r_1)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekey$] := PermAdd(Mask[r_1, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeleft$] := PermAdd(Mask[r_1, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNoderight$] := PermAdd(Mask[r_1, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(r_1, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(r_1)], Heap[r_1, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])]);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNodeleft$] != null;
      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNodeleft$] != null;
      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNodeleft$] != null;
      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      assume (forall lk_2: int ::
        
        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < Heap[r_1, AVLTreeNodekey$]
      );
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(r_1, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(r_1)], Heap[r_1, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])]);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNoderight$] != null;
      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNoderight$] != null;
      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNoderight$] != null;
      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      assume (forall rk_2: int ::
        
        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> Heap[r_1, AVLTreeNodekey$] < rk_2
      );
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      assume Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[r_1, AVLTreeNodekey$])), (if Heap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[r_1, AVLTreeNodekeys$], Heap[r_1, AVLTreeNodekey$]);
    assume (forall kk_2: int ::
      
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], kk_2) == ((Heap[r_1, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((Heap[r_1, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == Heap[r_1, AVLTreeNodekey$]))
    );
    assume Heap[r_1, AVLTreeNodeheight$] == (if (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[r_1, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[r_1, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[r_1, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (r.AVLTreeNoderight$ != null) ==> (forall k4: Int :: true && k4 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (k4 < this$_18.AVLTreeNodekey$)) -- AVLTree.sil,1161:3
    
    // -- Check definedness of (r.AVLTreeNoderight$ != null) ==> (forall k4: Int :: true && k4 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (k4 < this$_18.AVLTreeNodekey$))
      assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1161:3) [13012]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      if (Heap[r_1, AVLTreeNoderight$] != null) {
        assert {:msg "  Assert might fail. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1161:3) [13013]"}
          Heap[r_1, AVLTreeNoderight$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1161:3) [13014]"}
          HasDirectPerm(Mask, Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Assert might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1161:3) [13015]"}
          r_1 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1161:3) [13016]"}
          HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
        if (Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k4)) {
          assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1161:3) [13017]"}
            this$_18 != null;
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1161:3) [13018]"}
            HasDirectPerm(Mask, this$_18, AVLTreeNodekey$);
        }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      assert {:msg "  Assert might fail. Assertion (forall k4: Int :: true && k4 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (k4 < this$_18.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1161:3) [13019]"}
        (forall k4_1: int ::
        
        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k4_1) ==> k4_1 < Heap[this$_18, AVLTreeNodekey$]
      );
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ := r.AVLTreeNodeleft$ -- AVLTree.sil,1162:3
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ might be null. (AVLTree.sil,1162:3) [13020]"}
        Heap[this$_18, AVLTreeNodeleft$] != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$. (AVLTree.sil,1162:3) [13021]"}
        HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$);
      assert {:msg "  Assignment might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1162:3) [13022]"}
        this$_18 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1162:3) [13023]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1162:3) [13024]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1162:3) [13025]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := Heap[r_1, AVLTreeNodeleft$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$. (AVLTree.sil,1162:3) [13026]"}
      FullPerm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_25  -- AVLTree.sil,1163:3
    
    // -- Translation of statement fresh newK$_25)
      havoc newK$_25;
      assume (newK$_25[$frac] > 0.000000000 && newK$_25[$frac] < 0.001000000) && newK$_25[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_25) -- AVLTree.sil,1164:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_18.AVLTreeNodeleft$, newK$_25) -- AVLTree.sil,1165:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Check definedness of this$_18.AVLTreeNodeleft$
        assert {:msg "  Method call might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1165:5) [13027]"}
          this$_18 != null;
        assert {:msg "  Method call might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1165:5) [13028]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      arg_this$_16 := Heap[this$_18, AVLTreeNodeleft$];
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_18.AVLTreeNodeleft$ != null might not hold. (AVLTree.sil,1165:5) [13029]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_25 > none might not hold. (AVLTree.sil,1165:5) [13030]"}
          NoPerm[$frac] < newK$_25[$frac] || (NoPerm[$frac] == newK$_25[$frac] && NoPerm[$eps] < newK$_25[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_25 might not hold. (AVLTree.sil,1165:5) [13031]"}
          newK$_25[$frac] < FullPerm[$frac] || (newK$_25[$frac] == FullPerm[$frac] && newK$_25[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1165:5) [13032]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekey$ might be null. (AVLTree.sil,1165:5) [13033]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekey$. (AVLTree.sil,1165:5) [13034]"}
            (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$][$eps]);
        }
        Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1165:5) [13035]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1165:5) [13036]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1165:5) [13037]"}
            (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
        }
        Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1165:5) [13038]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$ might be null. (AVLTree.sil,1165:5) [13039]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$. (AVLTree.sil,1165:5) [13040]"}
            (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$][$eps]);
        }
        Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1165:5) [13041]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ might be null. (AVLTree.sil,1165:5) [13042]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$. (AVLTree.sil,1165:5) [13043]"}
            (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$][$eps]);
        }
        Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1165:5) [13044]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1165:5) [13045]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1165:5) [13046]"}
            (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
        }
        Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1165:5) [13047]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1165:5) [13048]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1165:5) [13049]"}
            (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$). (AVLTree.sil,1165:5) [13050]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1165:5) [13051]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1165:5) [13052]"}
            Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1165:5) [13053]"}
              (perm[$frac] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1165:5) [13054]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1165:5) [13055]"}
            Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1165:5) [13056]"}
              (perm[$frac] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1165:5) [13057]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1165:5) [13058]"}
            Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1165:5) [13059]"}
              (perm[$frac] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_18.AVLTreeNodeleft$.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1165:5) [13060]"}
            (forall k0_2: int ::
            
            Seq#Contains(Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], k0_2) ==> k0_2 < Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$]
          );
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$.AVLTreeNoderight$). (AVLTree.sil,1165:5) [13061]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1165:5) [13062]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1165:5) [13063]"}
            Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1165:5) [13064]"}
              (perm[$frac] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1165:5) [13065]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1165:5) [13066]"}
            Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1165:5) [13067]"}
              (perm[$frac] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1165:5) [13068]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1165:5) [13069]"}
            Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1165:5) [13070]"}
              (perm[$frac] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_18.AVLTreeNodeleft$.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1165:5) [13071]"}
            (forall k1_2: int ::
            
            Seq#Contains(Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekey$] < k1_2
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$ == null ? 0 : this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ == null ? 0 : this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1165:5) [13072]"}
          (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$ == null ? 0 : this$_18.AVLTreeNodeleft$.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_18.AVLTreeNodeleft$.AVLTreeNoderight$ == null ? 0 : this$_18.AVLTreeNodeleft$.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1165:5) [13073]"}
          (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(arg_this$_16)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_16)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_16 != null;
        Mask[arg_this$_16, AVLTreeNodeheight$] := PermAdd(Mask[arg_this$_16, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_16 != null;
        Mask[arg_this$_16, AVLTreeNodekeys$] := PermAdd(Mask[arg_this$_16, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_16 != null;
        Mask[arg_this$_16, AVLTreeNodebalanceFactor$] := PermAdd(Mask[arg_this$_16, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[arg_this$_16, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[arg_this$_16, AVLTreeNodekey$])), (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[arg_this$_16, AVLTreeNodeheight$] == (if (if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[arg_this$_16, AVLTreeNodebalanceFactor$] == (if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_25 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1165:5) [13074]"}
        newK$_25[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r.AVLTreeNodeleft$ := this$_18.AVLTreeNodeleft$ -- AVLTree.sil,1167:3
    
    // -- Check definedness of r.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1167:3) [13075]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1167:3) [13076]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1167:3) [13077]"}
        this$_18 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1167:3) [13078]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[r_1, AVLTreeNodeleft$] := Heap[this$_18, AVLTreeNodeleft$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1167:3) [13079]"}
      FullPerm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_18.AVLTreeNodeleft$ := r.AVLTreeNoderight$ -- AVLTree.sil,1168:3
    
    // -- Check definedness of this$_18.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1168:3) [13080]"}
        this$_18 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1168:3) [13081]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1168:3) [13082]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1168:3) [13083]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[this$_18, AVLTreeNodeleft$] := Heap[r_1, AVLTreeNoderight$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1168:3) [13084]"}
      FullPerm[$frac] == Mask[this$_18, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_18, AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (this$_18.AVLTreeNodeleft$ != null) ==> (forall k5: Int :: true && k5 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k5 < this$_18.AVLTreeNodekey$)) -- AVLTree.sil,1169:3
    
    // -- Check definedness of (this$_18.AVLTreeNodeleft$ != null) ==> (forall k5: Int :: true && k5 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k5 < this$_18.AVLTreeNodekey$))
      assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1169:3) [13085]"}
        this$_18 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1169:3) [13086]"}
        HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
      if (Heap[this$_18, AVLTreeNodeleft$] != null) {
        assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1169:3) [13087]"}
          Heap[this$_18, AVLTreeNodeleft$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1169:3) [13088]"}
          HasDirectPerm(Mask, Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1169:3) [13089]"}
          this$_18 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1169:3) [13090]"}
          HasDirectPerm(Mask, this$_18, AVLTreeNodeleft$);
        if (Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k5)) {
          assert {:msg "  Assert might fail. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1169:3) [13091]"}
            this$_18 != null;
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1169:3) [13092]"}
            HasDirectPerm(Mask, this$_18, AVLTreeNodekey$);
        }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[this$_18, AVLTreeNodeleft$] != null) {
      assert {:msg "  Assert might fail. Assertion (forall k5: Int :: true && k5 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k5 < this$_18.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1169:3) [13093]"}
        (forall k5_1: int ::
        
        Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k5_1) ==> k5_1 < Heap[this$_18, AVLTreeNodekey$]
      );
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_26  -- AVLTree.sil,1170:3
    
    // -- Translation of statement fresh newK$_26)
      havoc newK$_26;
      assume (newK$_26[$frac] > 0.000000000 && newK$_26[$frac] < 0.001000000) && newK$_26[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_26) -- AVLTree.sil,1171:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_18, newK$_26) -- AVLTree.sil,1172:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_18 != null might not hold. (AVLTree.sil,1172:5) [13094]"}
          this$_18 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_26 > none might not hold. (AVLTree.sil,1172:5) [13095]"}
          NoPerm[$frac] < newK$_26[$frac] || (NoPerm[$frac] == newK$_26[$frac] && NoPerm[$eps] < newK$_26[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_26 might not hold. (AVLTree.sil,1172:5) [13096]"}
          newK$_26[$frac] < FullPerm[$frac] || (newK$_26[$frac] == FullPerm[$frac] && newK$_26[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1172:5) [13097]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodekey$ might be null. (AVLTree.sil,1172:5) [13098]"}
          this$_18 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodekey$. (AVLTree.sil,1172:5) [13099]"}
            (perm[$frac] < Mask[this$_18, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_18, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_18, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_18, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_18, AVLTreeNodekey$][$eps]);
        }
        Mask[this$_18, AVLTreeNodekey$] := PermSub(Mask[this$_18, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1172:5) [13100]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeheight$ might be null. (AVLTree.sil,1172:5) [13101]"}
          this$_18 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeheight$. (AVLTree.sil,1172:5) [13102]"}
            (perm[$frac] < Mask[this$_18, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_18, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_18, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_18, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_18, AVLTreeNodeheight$][$eps]);
        }
        Mask[this$_18, AVLTreeNodeheight$] := PermSub(Mask[this$_18, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1172:5) [13103]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$ might be null. (AVLTree.sil,1172:5) [13104]"}
          this$_18 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$. (AVLTree.sil,1172:5) [13105]"}
            (perm[$frac] < Mask[this$_18, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_18, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_18, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_18, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_18, AVLTreeNodeleft$][$eps]);
        }
        Mask[this$_18, AVLTreeNodeleft$] := PermSub(Mask[this$_18, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1172:5) [13106]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNoderight$ might be null. (AVLTree.sil,1172:5) [13107]"}
          this$_18 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNoderight$. (AVLTree.sil,1172:5) [13108]"}
            (perm[$frac] < Mask[this$_18, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_18, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_18, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_18, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_18, AVLTreeNoderight$][$eps]);
        }
        Mask[this$_18, AVLTreeNoderight$] := PermSub(Mask[this$_18, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1172:5) [13109]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodekeys$ might be null. (AVLTree.sil,1172:5) [13110]"}
          this$_18 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodekeys$. (AVLTree.sil,1172:5) [13111]"}
            (perm[$frac] < Mask[this$_18, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_18, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_18, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_18, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_18, AVLTreeNodekeys$][$eps]);
        }
        Mask[this$_18, AVLTreeNodekeys$] := PermSub(Mask[this$_18, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1172:5) [13112]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1172:5) [13113]"}
          this$_18 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodebalanceFactor$. (AVLTree.sil,1172:5) [13114]"}
            (perm[$frac] < Mask[this$_18, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_18, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_18, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_18, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_18, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[this$_18, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_18, AVLTreeNodebalanceFactor$], perm);
        if (Heap[this$_18, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_18.AVLTreeNodeleft$). (AVLTree.sil,1172:5) [13115]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNodeleft$])], perm);
        }
        if (Heap[this$_18, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1172:5) [13116]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1172:5) [13117]"}
            Heap[this$_18, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1172:5) [13118]"}
              (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_18, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1172:5) [13119]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1172:5) [13120]"}
            Heap[this$_18, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1172:5) [13121]"}
              (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_18, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1172:5) [13122]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1172:5) [13123]"}
            Heap[this$_18, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1172:5) [13124]"}
              (perm[$frac] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_18, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_18.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1172:5) [13125]"}
            (forall k0_3: int ::
            
            Seq#Contains(Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_3) ==> k0_3 < Heap[this$_18, AVLTreeNodekey$]
          );
        }
        if (Heap[this$_18, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_18.AVLTreeNoderight$). (AVLTree.sil,1172:5) [13126]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_18, AVLTreeNoderight$])], perm);
        }
        if (Heap[this$_18, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1172:5) [13127]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1172:5) [13128]"}
            Heap[this$_18, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1172:5) [13129]"}
              (perm[$frac] < Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_18, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1172:5) [13130]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1172:5) [13131]"}
            Heap[this$_18, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1172:5) [13132]"}
              (perm[$frac] < Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_18, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1172:5) [13133]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_18.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1172:5) [13134]"}
            Heap[this$_18, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_18.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1172:5) [13135]"}
              (perm[$frac] < Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_18, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_18.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_18.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1172:5) [13136]"}
            (forall k1_3: int ::
            
            Seq#Contains(Heap[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_18, AVLTreeNodekey$] < k1_3
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_18.AVLTreeNodeleft$ == null ? 0 : this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_18.AVLTreeNoderight$ == null ? 0 : this$_18.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1172:5) [13137]"}
          (if Heap[this$_18, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_18, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_18.AVLTreeNodeleft$ == null ? 0 : this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_18.AVLTreeNoderight$ == null ? 0 : this$_18.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1172:5) [13138]"}
          (if Heap[this$_18, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_18, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(this$_18)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_18)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_18 != null;
        Mask[this$_18, AVLTreeNodeheight$] := PermAdd(Mask[this$_18, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_18 != null;
        Mask[this$_18, AVLTreeNodekeys$] := PermAdd(Mask[this$_18, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_18 != null;
        Mask[this$_18, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_18, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[this$_18, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_18, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_18, AVLTreeNodekey$])), (if PreCallHeap[this$_18, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[this$_18, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_18, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_18, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_18, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_18, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[this$_18, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_18, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_18, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_18, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_26 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1172:5) [13139]"}
        newK$_26[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r.AVLTreeNoderight$ := this$_18 -- AVLTree.sil,1174:3
    
    // -- Check definedness of r.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1174:3) [13140]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1174:3) [13141]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[r_1, AVLTreeNoderight$] := this$_18;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1174:3) [13142]"}
      FullPerm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_27  -- AVLTree.sil,1175:3
    
    // -- Translation of statement fresh newK$_27)
      havoc newK$_27;
      assume (newK$_27[$frac] > 0.000000000 && newK$_27[$frac] < 0.001000000) && newK$_27[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_27) -- AVLTree.sil,1176:3
    
    // -- Translating statement: AVLTreeNodeclose$(r, newK$_27) -- AVLTree.sil,1177:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1177:5) [13143]"}
          r_1 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_27 > none might not hold. (AVLTree.sil,1177:5) [13144]"}
          NoPerm[$frac] < newK$_27[$frac] || (NoPerm[$frac] == newK$_27[$frac] && NoPerm[$eps] < newK$_27[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_27 might not hold. (AVLTree.sil,1177:5) [13145]"}
          newK$_27[$frac] < FullPerm[$frac] || (newK$_27[$frac] == FullPerm[$frac] && newK$_27[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1177:5) [13146]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,1177:5) [13147]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,1177:5) [13148]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
        }
        Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1177:5) [13149]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1177:5) [13150]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1177:5) [13151]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
        }
        Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1177:5) [13152]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1177:5) [13153]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1177:5) [13154]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
        }
        Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1177:5) [13155]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1177:5) [13156]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1177:5) [13157]"}
            (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
        }
        Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1177:5) [13158]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1177:5) [13159]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1177:5) [13160]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
        }
        Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1177:5) [13161]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1177:5) [13162]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1177:5) [13163]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,1177:5) [13164]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1177:5) [13165]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1177:5) [13166]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1177:5) [13167]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1177:5) [13168]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1177:5) [13169]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1177:5) [13170]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1177:5) [13171]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1177:5) [13172]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1177:5) [13173]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1177:5) [13174]"}
            (forall k0_4: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_4) ==> k0_4 < Heap[r_1, AVLTreeNodekey$]
          );
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,1177:5) [13175]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1177:5) [13176]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1177:5) [13177]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1177:5) [13178]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1177:5) [13179]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1177:5) [13180]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1177:5) [13181]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1177:5) [13182]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1177:5) [13183]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1177:5) [13184]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1177:5) [13185]"}
            (forall k1_4: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_4) ==> Heap[r_1, AVLTreeNodekey$] < k1_4
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1177:5) [13186]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1177:5) [13187]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_27 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1177:5) [13188]"}
        newK$_27[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1141:11) [13189]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1142:11) [13190]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1143:11) [13191]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1143:11) [13192]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1143:11) [13193]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1144:11) [13194]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1144:11) [13195]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1144:11) [13196]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1145:11) [13197]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1145:11) [13198]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1145:11) [13199]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Assertion r.AVLTreeNodeheight$ == old(this$_18.AVLTreeNodeleft$.AVLTreeNodeheight$) might not hold. (AVLTree.sil,1146:11) [13200]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_18, AVLTreeNodeleft$], AVLTreeNodeheight$];
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRL$ might not hold. Assertion r.AVLTreeNodekeys$ == old(this$_18.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_18.AVLTreeNodekey$)) ++ (old(this$_18.AVLTreeNoderight$) == null ? Seq() : old(this$_18.AVLTreeNoderight$.AVLTreeNodekeys$)) might not hold. (AVLTree.sil,1147:11) [13201]"}
      Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this$_18, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(old(Heap)[this$_18, AVLTreeNodekey$])), (if old(Heap)[this$_18, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_18, AVLTreeNoderight$], AVLTreeNodekeys$])));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderebalanceRR$
// ==================================================

procedure AVLTreeNoderebalanceRR$(this$_19: Ref, k$_15: Perm) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k_1: int;
  var k1_12: int;
  var oldVersion: int;
  var newVersion: int;
  var newK$: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var newK$_1: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_19 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_15[$frac] || (NoPerm[$frac] == k$_15[$frac] && NoPerm[$eps] < k$_15[$eps]);
    assume state(Heap, Mask);
    assume k$_15[$frac] < FullPerm[$frac] || (k$_15[$frac] == FullPerm[$frac] && k$_15[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_19 != null;
    Mask[this$_19, AVLTreeNodekey$] := PermAdd(Mask[this$_19, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_19 != null;
    Mask[this$_19, AVLTreeNodeheight$] := PermAdd(Mask[this$_19, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_19 != null;
    Mask[this$_19, AVLTreeNodeleft$] := PermAdd(Mask[this$_19, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_19 != null;
    Mask[this$_19, AVLTreeNoderight$] := PermAdd(Mask[this$_19, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_19 != null;
    Mask[this$_19, AVLTreeNodekeys$] := PermAdd(Mask[this$_19, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_19 != null;
    Mask[this$_19, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_19, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_19.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1191:12) [13202]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1191:12) [13203]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1192:12) [13204]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1193:12) [13205]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1193:12) [13206]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1194:12) [13207]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1194:12) [13208]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1195:12) [13209]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1195:12) [13210]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall k: Int :: true && k in this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_19.AVLTreeNodekey$))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1196:13) [13211]"}
        Heap[this$_19, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1196:13) [13212]"}
        HasDirectPerm(Mask, Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1196:13) [13213]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1196:13) [13214]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      if (Seq#Contains(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], k_1)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodekey$ might be null. (AVLTree.sil,1196:13) [13215]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodekey$. (AVLTree.sil,1196:13) [13216]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    assume (forall k_1_2: int ::
      
      Seq#Contains(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], k_1_2) ==> k_1_2 < Heap[this$_19, AVLTreeNodekey$]
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_19.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1197:12) [13217]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1197:12) [13218]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_19, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_19.AVLTreeNoderight$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1197:12) [13219]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_19.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1198:12) [13220]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1198:12) [13221]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_19, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_19.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1198:12) [13222]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1198:12) [13223]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_19, AVLTreeNoderight$] != null;
      Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_19.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1199:12) [13224]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1199:12) [13225]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_19, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_19.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1199:12) [13226]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1199:12) [13227]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_19, AVLTreeNoderight$] != null;
      Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_19.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1200:12) [13228]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1200:12) [13229]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_19, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of acc(this$_19.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1200:12) [13230]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1200:12) [13231]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_19, AVLTreeNoderight$] != null;
      Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_19.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1201:12) [13232]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1201:12) [13233]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      assume state(Heap, Mask);
    if (Heap[this$_19, AVLTreeNoderight$] != null) {
      
      // -- Check definedness of (forall k1: Int :: true && k1 in this$_19.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_19.AVLTreeNodekey$ < k1))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1201:12) [13234]"}
          Heap[this$_19, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1201:12) [13235]"}
          HasDirectPerm(Mask, Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1201:12) [13236]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1201:12) [13237]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
        if (Seq#Contains(Heap[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$], k1_12)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodekey$ might be null. (AVLTree.sil,1201:12) [13238]"}
            this$_19 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodekey$. (AVLTree.sil,1201:12) [13239]"}
            HasDirectPerm(Mask, this$_19, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k1_1: int ::
        
        Seq#Contains(Heap[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_19, AVLTreeNodekey$] < k1_1
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$ - (this$_19.AVLTreeNoderight$ == null ? 0 : this$_19.AVLTreeNoderight$.AVLTreeNodeheight$) == 2
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1202:12) [13240]"}
        Heap[this$_19, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1202:12) [13241]"}
        HasDirectPerm(Mask, Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1202:12) [13242]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1202:12) [13243]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1202:12) [13244]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1202:12) [13245]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      if (Heap[this$_19, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1202:12) [13246]"}
          Heap[this$_19, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1202:12) [13247]"}
          HasDirectPerm(Mask, Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1202:12) [13248]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1202:12) [13249]"}
          HasDirectPerm(Mask, this$_19, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] - (if Heap[this$_19, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$]) == 2;
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ >= 0
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1203:12) [13250]"}
        Heap[this$_19, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1203:12) [13251]"}
        HasDirectPerm(Mask, Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1203:12) [13252]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1203:12) [13253]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= 0;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1209:11) [13254]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1209:11) [13255]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1209:11) [13256]"}
        old(Heap)[this$_19, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1209:11) [13257]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1209:11) [13258]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1209:11) [13259]"}
        HasDirectPerm(old(Mask), this$_19, AVLTreeNodeleft$);
      if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$])) {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1209:11) [13260]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1209:11) [13261]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1209:11) [13262]"}
          old(Heap)[this$_19, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1209:11) [13263]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1209:11) [13264]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1209:11) [13265]"}
          HasDirectPerm(old(Mask), this$_19, AVLTreeNodeleft$);
      }
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodekeys$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_19.AVLTreeNodekey$)) ++ (old(this$_19.AVLTreeNoderight$) == null ? Seq() : old(this$_19.AVLTreeNoderight$.AVLTreeNodekeys$))
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1210:11) [13266]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1210:11) [13267]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1210:11) [13268]"}
        old(Heap)[this$_19, AVLTreeNodeleft$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1210:11) [13269]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1210:11) [13270]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1210:11) [13271]"}
        HasDirectPerm(old(Mask), this$_19, AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNodekey$ might be null. (AVLTree.sil,1210:11) [13272]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNodekey$. (AVLTree.sil,1210:11) [13273]"}
        HasDirectPerm(old(Mask), this$_19, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1210:11) [13274]"}
        this$_19 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1210:11) [13275]"}
        HasDirectPerm(old(Mask), this$_19, AVLTreeNoderight$);
      if (old(Heap)[this$_19, AVLTreeNoderight$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1210:11) [13276]"}
          old(Heap)[this$_19, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1210:11) [13277]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1210:11) [13278]"}
          this$_19 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1210:11) [13279]"}
          HasDirectPerm(old(Mask), this$_19, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(old(Heap)[this$_19, AVLTreeNodekey$])), (if old(Heap)[this$_19, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_19 == null || Heap[this$_19, $allocated];
    assume k$_15[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$), write) -- AVLTree.sil,1218:3
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$), write)
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$) might fail. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1218:3) [13280]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$]));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$). (AVLTree.sil,1218:3) [13283]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$]))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_19, AVLTreeNodeleft$] != null;
    Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])], Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$])]);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$]
      );
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null) {
      assume Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])], Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$])]);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$] < rk
      );
    }
    if (Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null) {
      assume Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$])), (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], kk) == ((Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekey$]))
    );
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] == (if (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] == (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r := this$_19.AVLTreeNodeleft$ -- AVLTree.sil,1219:3
    
    // -- Check definedness of this$_19.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1219:3) [13284]"}
        this$_19 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1219:3) [13285]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    r_1 := Heap[this$_19, AVLTreeNodeleft$];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_19.AVLTreeNodeleft$ := r.AVLTreeNoderight$ -- AVLTree.sil,1220:3
    
    // -- Check definedness of this$_19.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1220:3) [13286]"}
        this$_19 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1220:3) [13287]"}
        HasDirectPerm(Mask, this$_19, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1220:3) [13288]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1220:3) [13289]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[this$_19, AVLTreeNodeleft$] := Heap[r_1, AVLTreeNoderight$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1220:3) [13290]"}
      FullPerm[$frac] == Mask[this$_19, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[this$_19, AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$  -- AVLTree.sil,1221:3
    
    // -- Translation of statement fresh newK$)
      havoc newK$;
      assume (newK$[$frac] > 0.000000000 && newK$[$frac] < 0.001000000) && newK$[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$) -- AVLTree.sil,1222:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_19, newK$) -- AVLTree.sil,1223:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_19 != null might not hold. (AVLTree.sil,1223:5) [13291]"}
          this$_19 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$ > none might not hold. (AVLTree.sil,1223:5) [13292]"}
          NoPerm[$frac] < newK$[$frac] || (NoPerm[$frac] == newK$[$frac] && NoPerm[$eps] < newK$[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$ might not hold. (AVLTree.sil,1223:5) [13293]"}
          newK$[$frac] < FullPerm[$frac] || (newK$[$frac] == FullPerm[$frac] && newK$[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1223:5) [13294]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodekey$ might be null. (AVLTree.sil,1223:5) [13295]"}
          this$_19 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodekey$. (AVLTree.sil,1223:5) [13296]"}
            (perm[$frac] < Mask[this$_19, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_19, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_19, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_19, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_19, AVLTreeNodekey$][$eps]);
        }
        Mask[this$_19, AVLTreeNodekey$] := PermSub(Mask[this$_19, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1223:5) [13297]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodeheight$ might be null. (AVLTree.sil,1223:5) [13298]"}
          this$_19 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodeheight$. (AVLTree.sil,1223:5) [13299]"}
            (perm[$frac] < Mask[this$_19, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_19, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_19, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_19, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_19, AVLTreeNodeheight$][$eps]);
        }
        Mask[this$_19, AVLTreeNodeheight$] := PermSub(Mask[this$_19, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1223:5) [13300]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodeleft$ might be null. (AVLTree.sil,1223:5) [13301]"}
          this$_19 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodeleft$. (AVLTree.sil,1223:5) [13302]"}
            (perm[$frac] < Mask[this$_19, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_19, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_19, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_19, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_19, AVLTreeNodeleft$][$eps]);
        }
        Mask[this$_19, AVLTreeNodeleft$] := PermSub(Mask[this$_19, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1223:5) [13303]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNoderight$ might be null. (AVLTree.sil,1223:5) [13304]"}
          this$_19 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNoderight$. (AVLTree.sil,1223:5) [13305]"}
            (perm[$frac] < Mask[this$_19, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_19, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_19, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_19, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_19, AVLTreeNoderight$][$eps]);
        }
        Mask[this$_19, AVLTreeNoderight$] := PermSub(Mask[this$_19, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1223:5) [13306]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodekeys$ might be null. (AVLTree.sil,1223:5) [13307]"}
          this$_19 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodekeys$. (AVLTree.sil,1223:5) [13308]"}
            (perm[$frac] < Mask[this$_19, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_19, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_19, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_19, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_19, AVLTreeNodekeys$][$eps]);
        }
        Mask[this$_19, AVLTreeNodekeys$] := PermSub(Mask[this$_19, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1223:5) [13309]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1223:5) [13310]"}
          this$_19 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodebalanceFactor$. (AVLTree.sil,1223:5) [13311]"}
            (perm[$frac] < Mask[this$_19, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_19, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_19, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_19, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_19, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[this$_19, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_19, AVLTreeNodebalanceFactor$], perm);
        if (Heap[this$_19, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_19.AVLTreeNodeleft$). (AVLTree.sil,1223:5) [13312]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNodeleft$])], perm);
        }
        if (Heap[this$_19, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1223:5) [13313]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1223:5) [13314]"}
            Heap[this$_19, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1223:5) [13315]"}
              (perm[$frac] < Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_19, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1223:5) [13316]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1223:5) [13317]"}
            Heap[this$_19, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1223:5) [13318]"}
              (perm[$frac] < Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_19, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1223:5) [13319]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1223:5) [13320]"}
            Heap[this$_19, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1223:5) [13321]"}
              (perm[$frac] < Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_19, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_19.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1223:5) [13322]"}
            (forall k0: int ::
            
            Seq#Contains(Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], k0) ==> k0 < Heap[this$_19, AVLTreeNodekey$]
          );
        }
        if (Heap[this$_19, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_19.AVLTreeNoderight$). (AVLTree.sil,1223:5) [13323]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_19, AVLTreeNoderight$])], perm);
        }
        if (Heap[this$_19, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1223:5) [13324]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1223:5) [13325]"}
            Heap[this$_19, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1223:5) [13326]"}
              (perm[$frac] < Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_19, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1223:5) [13327]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1223:5) [13328]"}
            Heap[this$_19, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1223:5) [13329]"}
              (perm[$frac] < Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_19, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1223:5) [13330]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_19.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1223:5) [13331]"}
            Heap[this$_19, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_19.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1223:5) [13332]"}
              (perm[$frac] < Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_19, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_19.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_19.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1223:5) [13333]"}
            (forall k1_2: int ::
            
            Seq#Contains(Heap[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[this$_19, AVLTreeNodekey$] < k1_2
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_19.AVLTreeNodeleft$ == null ? 0 : this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_19.AVLTreeNoderight$ == null ? 0 : this$_19.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1223:5) [13334]"}
          (if Heap[this$_19, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_19, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_19.AVLTreeNodeleft$ == null ? 0 : this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_19.AVLTreeNoderight$ == null ? 0 : this$_19.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1223:5) [13335]"}
          (if Heap[this$_19, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_19, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(this$_19)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_19)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_19 != null;
        Mask[this$_19, AVLTreeNodeheight$] := PermAdd(Mask[this$_19, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_19 != null;
        Mask[this$_19, AVLTreeNodekeys$] := PermAdd(Mask[this$_19, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_19 != null;
        Mask[this$_19, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_19, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[this$_19, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_19, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_19, AVLTreeNodekey$])), (if PreCallHeap[this$_19, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[this$_19, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_19, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_19, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_19, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_19, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[this$_19, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_19, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_19, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_19, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$ might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1223:5) [13336]"}
        newK$[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r.AVLTreeNoderight$ := this$_19 -- AVLTree.sil,1225:3
    
    // -- Check definedness of r.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1225:3) [13337]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1225:3) [13338]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[r_1, AVLTreeNoderight$] := this$_19;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1225:3) [13339]"}
      FullPerm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_1  -- AVLTree.sil,1226:3
    
    // -- Translation of statement fresh newK$_1)
      havoc newK$_1;
      assume (newK$_1[$frac] > 0.000000000 && newK$_1[$frac] < 0.001000000) && newK$_1[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_1) -- AVLTree.sil,1227:3
    
    // -- Translating statement: AVLTreeNodeclose$(r, newK$_1) -- AVLTree.sil,1228:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1228:5) [13340]"}
          r_1 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_1 > none might not hold. (AVLTree.sil,1228:5) [13341]"}
          NoPerm[$frac] < newK$_1[$frac] || (NoPerm[$frac] == newK$_1[$frac] && NoPerm[$eps] < newK$_1[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_1 might not hold. (AVLTree.sil,1228:5) [13342]"}
          newK$_1[$frac] < FullPerm[$frac] || (newK$_1[$frac] == FullPerm[$frac] && newK$_1[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1228:5) [13343]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,1228:5) [13344]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,1228:5) [13345]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
        }
        Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1228:5) [13346]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1228:5) [13347]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1228:5) [13348]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
        }
        Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1228:5) [13349]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1228:5) [13350]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1228:5) [13351]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
        }
        Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1228:5) [13352]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1228:5) [13353]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1228:5) [13354]"}
            (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
        }
        Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1228:5) [13355]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1228:5) [13356]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1228:5) [13357]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
        }
        Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1228:5) [13358]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1228:5) [13359]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1228:5) [13360]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,1228:5) [13361]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1228:5) [13362]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1228:5) [13363]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1228:5) [13364]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1228:5) [13365]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1228:5) [13366]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1228:5) [13367]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1228:5) [13368]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1228:5) [13369]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1228:5) [13370]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1228:5) [13371]"}
            (forall k0_1: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[r_1, AVLTreeNodekey$]
          );
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,1228:5) [13372]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1228:5) [13373]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1228:5) [13374]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1228:5) [13375]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1228:5) [13376]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1228:5) [13377]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1228:5) [13378]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1228:5) [13379]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1228:5) [13380]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1228:5) [13381]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1228:5) [13382]"}
            (forall k1_3: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[r_1, AVLTreeNodekey$] < k1_3
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1228:5) [13383]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1228:5) [13384]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_1 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1228:5) [13385]"}
        newK$_1[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1204:11) [13386]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1205:11) [13387]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1206:11) [13388]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1206:11) [13389]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1206:11) [13390]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1207:11) [13391]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1207:11) [13392]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1207:11) [13393]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1208:11) [13394]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1208:11) [13395]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1208:11) [13396]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,1209:11) [13397]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodeheight$] + 1;
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRR$ might not hold. Assertion r.AVLTreeNodekeys$ == old(this$_19.AVLTreeNodeleft$.AVLTreeNodekeys$) ++ Seq(old(this$_19.AVLTreeNodekey$)) ++ (old(this$_19.AVLTreeNoderight$) == null ? Seq() : old(this$_19.AVLTreeNoderight$.AVLTreeNodekeys$)) might not hold. (AVLTree.sil,1210:11) [13398]"}
      Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append(old(Heap)[old(Heap)[this$_19, AVLTreeNodeleft$], AVLTreeNodekeys$], Seq#Singleton(old(Heap)[this$_19, AVLTreeNodekey$])), (if old(Heap)[this$_19, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_19, AVLTreeNoderight$], AVLTreeNodekeys$])));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderebalanceRight$
// ==================================================

procedure AVLTreeNoderebalanceRight$(this$_20: Ref, k$_16: Perm) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k_2: int;
  var k1_13: int;
  var newK$_22: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_14: Ref;
  var rbf: int;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newK$_23: Perm;
  var newK$_24: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_20 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_16[$frac] || (NoPerm[$frac] == k$_16[$frac] && NoPerm[$eps] < k$_16[$eps]);
    assume state(Heap, Mask);
    assume k$_16[$frac] < FullPerm[$frac] || (k$_16[$frac] == FullPerm[$frac] && k$_16[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_20 != null;
    Mask[this$_20, AVLTreeNodekey$] := PermAdd(Mask[this$_20, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_20 != null;
    Mask[this$_20, AVLTreeNodeheight$] := PermAdd(Mask[this$_20, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_20 != null;
    Mask[this$_20, AVLTreeNodeleft$] := PermAdd(Mask[this$_20, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_20 != null;
    Mask[this$_20, AVLTreeNoderight$] := PermAdd(Mask[this$_20, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_20 != null;
    Mask[this$_20, AVLTreeNodekeys$] := PermAdd(Mask[this$_20, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_20 != null;
    Mask[this$_20, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_20, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_20.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1242:12) [13399]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1242:12) [13400]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_20, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_20.AVLTreeNodeleft$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1242:12) [13401]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_20.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1243:12) [13402]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1243:12) [13403]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_20, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1243:12) [13404]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1243:12) [13405]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_20, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_20.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1244:12) [13406]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1244:12) [13407]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_20, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1244:12) [13408]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1244:12) [13409]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_20, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_20.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1245:12) [13410]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1245:12) [13411]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_20, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_20.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1245:12) [13412]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1245:12) [13413]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_20, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_20.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1246:12) [13414]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1246:12) [13415]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_20, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of (forall k: Int :: true && k in this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_20.AVLTreeNodekey$))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1246:12) [13416]"}
          Heap[this$_20, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1246:12) [13417]"}
          HasDirectPerm(Mask, Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1246:12) [13418]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1246:12) [13419]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
        if (Seq#Contains(Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], k_2)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodekey$ might be null. (AVLTree.sil,1246:12) [13420]"}
            this$_20 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodekey$. (AVLTree.sil,1246:12) [13421]"}
            HasDirectPerm(Mask, this$_20, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k_1_2: int ::
        
        Seq#Contains(Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], k_1_2) ==> k_1_2 < Heap[this$_20, AVLTreeNodekey$]
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_20.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1247:12) [13422]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1247:12) [13423]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Heap[this$_20, AVLTreeNoderight$] != null;
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1248:12) [13424]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1249:12) [13425]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1249:12) [13426]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_20, AVLTreeNoderight$] != null;
    Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_20.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1250:12) [13427]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1250:12) [13428]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_20, AVLTreeNoderight$] != null;
    Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1251:12) [13429]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1251:12) [13430]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_20, AVLTreeNoderight$] != null;
    Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall k1: Int :: true && k1 in this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_20.AVLTreeNodekey$ < k1))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1252:13) [13431]"}
        Heap[this$_20, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1252:13) [13432]"}
        HasDirectPerm(Mask, Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1252:13) [13433]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1252:13) [13434]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      if (Seq#Contains(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], k1_13)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodekey$ might be null. (AVLTree.sil,1252:13) [13435]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodekey$. (AVLTree.sil,1252:13) [13436]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    assume (forall k1_1: int ::
      
      Seq#Contains(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_20, AVLTreeNodekey$] < k1_1
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of (this$_20.AVLTreeNodeleft$ == null ? 0 : this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1253:12) [13437]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1253:12) [13438]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      if (Heap[this$_20, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1253:12) [13439]"}
          Heap[this$_20, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1253:12) [13440]"}
          HasDirectPerm(Mask, Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1253:12) [13441]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1253:12) [13442]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1253:12) [13443]"}
        Heap[this$_20, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1253:12) [13444]"}
        HasDirectPerm(Mask, Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1253:12) [13445]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1253:12) [13446]"}
        HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume (if Heap[this$_20, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1259:11) [13447]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1259:11) [13448]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1259:11) [13449]"}
        old(Heap)[this$_20, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1259:11) [13450]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1259:11) [13451]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1259:11) [13452]"}
        HasDirectPerm(old(Mask), this$_20, AVLTreeNoderight$);
      if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$])) {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1259:11) [13453]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1259:11) [13454]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1259:11) [13455]"}
          old(Heap)[this$_20, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1259:11) [13456]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1259:11) [13457]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1259:11) [13458]"}
          HasDirectPerm(old(Mask), this$_20, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodekeys$ == (old(this$_20.AVLTreeNodeleft$) == null ? Seq() : old(this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_20.AVLTreeNodekey$)) ++ old(this$_20.AVLTreeNoderight$.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1260:11) [13459]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1260:11) [13460]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1260:11) [13461]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1260:11) [13462]"}
        HasDirectPerm(old(Mask), this$_20, AVLTreeNodeleft$);
      if (old(Heap)[this$_20, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1260:11) [13463]"}
          old(Heap)[this$_20, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1260:11) [13464]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1260:11) [13465]"}
          this$_20 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1260:11) [13466]"}
          HasDirectPerm(old(Mask), this$_20, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNodekey$ might be null. (AVLTree.sil,1260:11) [13467]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNodekey$. (AVLTree.sil,1260:11) [13468]"}
        HasDirectPerm(old(Mask), this$_20, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1260:11) [13469]"}
        old(Heap)[this$_20, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1260:11) [13470]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1260:11) [13471]"}
        this$_20 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1260:11) [13472]"}
        HasDirectPerm(old(Mask), this$_20, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_20, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_20, AVLTreeNodekey$])), old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$]));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_20 == null || Heap[this$_20, $allocated];
    assume k$_16[$eps] == 0.000000000;
  
  // -- Translating statement: fresh newK$_22  -- AVLTree.sil,1270:3
    
    // -- Translation of statement fresh newK$_22)
      havoc newK$_22;
      assume (newK$_22[$frac] > 0.000000000 && newK$_22[$frac] < 0.001000000) && newK$_22[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_22) -- AVLTree.sil,1271:3
    
    // -- Translating statement: rbf := AVLTreeNodegetBalanceFactor$(this$_20.AVLTreeNoderight$, newK$_22) -- AVLTree.sil,1272:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Check definedness of this$_20.AVLTreeNoderight$
        assert {:msg "  Method call might fail. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1272:5) [13473]"}
          this$_20 != null;
        assert {:msg "  Method call might fail. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1272:5) [13474]"}
          HasDirectPerm(Mask, this$_20, AVLTreeNoderight$);
        assume state(Heap, Mask);
      arg_this$_14 := Heap[this$_20, AVLTreeNoderight$];
      havoc rbf;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Assertion this$_20.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,1272:5) [13475]"}
          Heap[this$_20, AVLTreeNoderight$] != null;
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Assertion newK$_22 > none might not hold. (AVLTree.sil,1272:5) [13476]"}
          NoPerm[$frac] < newK$_22[$frac] || (NoPerm[$frac] == newK$_22[$frac] && NoPerm[$eps] < newK$_22[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Assertion write > newK$_22 might not hold. (AVLTree.sil,1272:5) [13477]"}
          newK$_22[$frac] < FullPerm[$frac] || (newK$_22[$frac] == FullPerm[$frac] && newK$_22[$eps] < FullPerm[$eps]);
        perm := NoPerm;
        perm := PermAdd(perm, FullPerm);
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNoderight$). (AVLTree.sil,1272:5) [13478]"}
            (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$eps]);
        }
        Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])], perm);
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Fraction newK$_22 might not be positive. (AVLTree.sil,1272:5) [13479]"}
          newK$_22[$frac] > 0.000000000 || (newK$_22[$frac] == 0.000000000 && newK$_22[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1272:5) [13480]"}
          Heap[this$_20, AVLTreeNoderight$] != null;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        perm := NoPerm;
        perm := PermAdd(perm, newK$_22);
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1272:5) [13481]"}
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] > 0.000000000;
          assume perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac];
        }
        Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(arg_this$_14)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_14)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := newK$_22;
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_14 != null;
        Mask[arg_this$_14, AVLTreeNodebalanceFactor$] := PermAdd(Mask[arg_this$_14, AVLTreeNodebalanceFactor$], perm);
        assume rbf == Heap[arg_this$_14, AVLTreeNodebalanceFactor$];
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_78: Ref, f_81: (Field A B) ::
            { newPMask[o_78, f_81] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_78, f_81] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_78, f_81] ==> newPMask[o_78, f_81]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_79: Ref, f_82: (Field A B) ::
            { newPMask[o_79, f_82] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_79, f_82] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_79, f_82] ==> newPMask[o_79, f_82]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
        assume rbf > 0 ==> Heap[arg_this$_14, AVLTreeNodeleft$] != null;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_80: Ref, f_83: (Field A B) ::
            { newPMask[o_80, f_83] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_80, f_83] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_80, f_83] ==> newPMask[o_80, f_83]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_81: Ref, f_84: (Field A B) ::
            { newPMask[o_81, f_84] }
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_81, f_84] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_81, f_84] ==> newPMask[o_81, f_84]
          );
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
        assume rbf < 0 ==> Heap[arg_this$_14, AVLTreeNoderight$] != null;
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_82: Ref, f_85: (Field A B) ::
              { newPMask[o_82, f_85] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_82, f_85] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_82, f_85] ==> newPMask[o_82, f_85]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_83: Ref, f_86: (Field A B) ::
              { newPMask[o_83, f_86] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_83, f_86] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_83, f_86] ==> newPMask[o_83, f_86]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_84: Ref, f_87: (Field A B) ::
              { newPMask[o_84, f_87] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_84, f_87] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_84, f_87] ==> newPMask[o_84, f_87]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_85: Ref, f_88: (Field A B) ::
              { newPMask[o_85, f_88] }
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_85, f_88] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_85, f_88] ==> newPMask[o_85, f_88]
            );
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
        assume state(Heap, Mask);
        
        // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(arg_this$_14), write) in (rbf > 0) ==> (arg_this$_14.AVLTreeNodeleft$ != null))
          UnfoldingHeap := Heap;
          UnfoldingMask := Mask;
          assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(arg_this$_14));
          // Phase 1: pure assertions and fixed permissions
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  An internal error occurred. There might be insufficient permission to access AVLTreeNodevalid$(arg_this$_14). (AVLTree.sil,963:12) [13482]"}
              (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps]);
          }
          UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)], perm);
          
          // -- Update version of predicate
            if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(arg_this$_14))) {
              oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)];
              havoc newVersion;
              assume oldVersion < newVersion;
              UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)] := newVersion;
            }
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekey$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekey$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeheight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeheight$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeleft$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeleft$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNoderight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNoderight$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekeys$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekeys$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$], perm);
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume (forall lk: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume (forall rk: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[arg_this$_14, AVLTreeNodekey$] < rk
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          }
          assume Seq#Equal(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[arg_this$_14, AVLTreeNodekey$])), (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
          assume Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]);
          assume (forall kk: int ::
            
            Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], kk) == ((UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]))
          );
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] == (if (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] <= 1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] >= -1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] > 0;
          assume state(UnfoldingHeap, UnfoldingMask);
          
          // -- Free assumptions
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_86: Ref, f_89: (Field A B) ::
                { newPMask[o_86, f_89] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_86, f_89] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_86, f_89] ==> newPMask[o_86, f_89]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_87: Ref, f_90: (Field A B) ::
                { newPMask[o_87, f_90] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_87, f_90] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_87, f_90] ==> newPMask[o_87, f_90]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            }
          assume state(Heap, Mask);
        
        // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(arg_this$_14), write) in (rbf < 0) ==> (arg_this$_14.AVLTreeNoderight$ != null))
          UnfoldingHeap := Heap;
          UnfoldingMask := Mask;
          assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(arg_this$_14));
          // Phase 1: pure assertions and fixed permissions
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  An internal error occurred. There might be insufficient permission to access AVLTreeNodevalid$(arg_this$_14). (AVLTree.sil,964:12) [13483]"}
              (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)][$eps]);
          }
          UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(arg_this$_14)], perm);
          
          // -- Update version of predicate
            if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(arg_this$_14))) {
              oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)];
              havoc newVersion;
              assume oldVersion < newVersion;
              UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)] := newVersion;
            }
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekey$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekey$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeheight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeheight$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodeleft$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodeleft$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNoderight$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNoderight$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodekeys$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodekeys$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume arg_this$_14 != null;
          UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[arg_this$_14, AVLTreeNodebalanceFactor$], perm);
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume (forall lk_1: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(arg_this$_14, AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(arg_this$_14)], UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[arg_this$_14, AVLTreeNoderight$])]);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume (forall rk_1: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> UnfoldingHeap[arg_this$_14, AVLTreeNodekey$] < rk_1
            );
          }
          if (UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          }
          assume Seq#Equal(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[arg_this$_14, AVLTreeNodekey$])), (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$])));
          assume Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]);
          assume (forall kk_1: int ::
            
            Seq#Contains(UnfoldingHeap[arg_this$_14, AVLTreeNodekeys$], kk_1) == ((UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == UnfoldingHeap[arg_this$_14, AVLTreeNodekey$]))
          );
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] == (if (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[arg_this$_14, AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$]);
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] <= 1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodebalanceFactor$] >= -1;
          assume UnfoldingHeap[arg_this$_14, AVLTreeNodeheight$] > 0;
          assume state(UnfoldingHeap, UnfoldingMask);
          
          // -- Free assumptions
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekey$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeheight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodeleft$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNoderight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodekeys$] := true;
            Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][arg_this$_14, AVLTreeNodebalanceFactor$] := true;
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_88: Ref, f_91: (Field A B) ::
                { newPMask[o_88, f_91] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_88, f_91] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNodeleft$])][o_88, f_91] ==> newPMask[o_88, f_91]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_89: Ref, f_92: (Field A B) ::
                { newPMask[o_89, f_92] }
                Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][o_89, f_92] || Heap[null, AVLTreeNodevalid$#sm(Heap[arg_this$_14, AVLTreeNoderight$])][o_89, f_92] ==> newPMask[o_89, f_92]
              );
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)] := newPMask;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            }
            if (Heap[arg_this$_14, AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(arg_this$_14)][Heap[arg_this$_14, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            }
          assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodegetBalanceFactor$ might not hold. The parameter newK$_22 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1272:5) [13484]"}
        newK$_22[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (rbf > 0) -- AVLTree.sil,1274:3
    if (rbf > 0) {
      
      // -- Translating statement: assert (unfolding acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write) in rbf == 1) -- AVLTree.sil,1275:5
        
        // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write) in rbf == 1)
          UnfoldingHeap := Heap;
          UnfoldingMask := Mask;
          assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$]));
          // Phase 1: pure assertions and fixed permissions
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  Assert might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNoderight$). (AVLTree.sil,1275:5) [13485]"}
              (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$eps]);
          }
          UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])], perm);
          
          // -- Update version of predicate
            if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$]))) {
              oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])];
              havoc newVersion;
              assume oldVersion < newVersion;
              UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])] := newVersion;
            }
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
          perm := Perm(1.000000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          perm := Perm(0.500000000, 0.000000000);
          assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
          assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
          UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])]);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            assume (forall lk_2: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$]
            );
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            perm := FullPerm;
            UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])]);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null;
            UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            assume (forall rk_2: int ::
              
              Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] < rk_2
            );
          }
          if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          }
          assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
          assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$]);
          assume (forall kk_2: int ::
            
            Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], kk_2) == ((UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$]))
          );
          assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
          assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
          assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
          assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
          assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
          assume state(UnfoldingHeap, UnfoldingMask);
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1275:5) [13486]"}
            HasDirectPerm(UnfoldingMask, this$_20, AVLTreeNoderight$);
          
          // -- Free assumptions
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_90: Ref, f_93: (Field A B) ::
                { newPMask[o_90, f_93] }
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_90, f_93] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])][o_90, f_93] ==> newPMask[o_90, f_93]
              );
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
              havoc newPMask;
              assume (forall <A, B> o_91: Ref, f_94: (Field A B) ::
                { newPMask[o_91, f_94] }
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_91, f_94] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])][o_91, f_94] ==> newPMask[o_91, f_94]
              );
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
            }
            if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
            }
          assume state(Heap, Mask);
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  Assert might fail. Assertion (unfolding acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write) in rbf == 1) might not hold. (AVLTree.sil,1275:5) [13487]"}
          rbf == 1;
        
        // -- Free assumptions
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_92: Ref, f_95: (Field A B) ::
              { newPMask[o_92, f_95] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_92, f_95] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])][o_92, f_95] ==> newPMask[o_92, f_95]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            havoc newPMask;
            assume (forall <A, B> o_93: Ref, f_96: (Field A B) ::
              { newPMask[o_93, f_96] }
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_93, f_96] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])][o_93, f_96] ==> newPMask[o_93, f_96]
            );
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
          }
          if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
          }
        assume state(Heap, Mask);
      
      // -- Translating statement: fresh newK$_23  -- AVLTree.sil,1276:5
        
        // -- Translation of statement fresh newK$_23)
          havoc newK$_23;
          assume (newK$_23[$frac] > 0.000000000 && newK$_23[$frac] < 0.001000000) && newK$_23[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_23) -- AVLTree.sil,1277:5
        
        // -- Translating statement: r := AVLTreeNoderebalanceLR$(this$_20, newK$_23) -- AVLTree.sil,1278:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          havoc r_1;
          
          // -- Exhaling precondition
            
            // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write) in this$_20.AVLTreeNoderight$.AVLTreeNodeleft$ != null)
              UnfoldingHeap := Heap;
              UnfoldingMask := Mask;
              assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$]));
              // Phase 1: pure assertions and fixed permissions
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  An internal error occurred. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNoderight$). (AVLTree.sil,1309:13) [13488]"}
                  (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])][$eps]);
              }
              UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])], perm);
              
              // -- Update version of predicate
                if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$]))) {
                  oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])];
                  havoc newVersion;
                  assume oldVersion < newVersion;
                  UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])] := newVersion;
                }
              perm := Perm(1.000000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
              UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$], perm);
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
              UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
              perm := Perm(1.000000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
              UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
              perm := Perm(1.000000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
              UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], perm);
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
              UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
              perm := Perm(0.500000000, 0.000000000);
              assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
              assume UnfoldingHeap[this$_20, AVLTreeNoderight$] != null;
              UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                perm := FullPerm;
                UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])]);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                assume (forall lk_3: int ::
                  
                  Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_3) ==> lk_3 < UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$]
                );
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                perm := FullPerm;
                UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_20, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])]);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                perm := Perm(0.500000000, 0.000000000);
                assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
                assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null;
                UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                assume (forall rk_3: int ::
                  
                  Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_3) ==> UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] < rk_3
                );
              }
              if (UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
              }
              assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
              assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$]);
              assume (forall kk_3: int ::
                
                Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], kk_3) == ((UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_3)) || ((UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_3)) || kk_3 == UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$]))
              );
              assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
              assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
              assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
              assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
              assume UnfoldingHeap[UnfoldingHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
              assume state(UnfoldingHeap, UnfoldingMask);
              
              // -- Free assumptions
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_94: Ref, f_97: (Field A B) ::
                    { newPMask[o_94, f_97] }
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_94, f_97] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])][o_94, f_97] ==> newPMask[o_94, f_97]
                  );
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_95: Ref, f_98: (Field A B) ::
                    { newPMask[o_95, f_98] }
                    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_95, f_98] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])][o_95, f_98] ==> newPMask[o_95, f_98]
                  );
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
                }
                if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
                }
              assume state(Heap, Mask);
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion this$_20 != null might not hold. (AVLTree.sil,1278:7) [13489]"}
              this$_20 != null;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion newK$_23 > none might not hold. (AVLTree.sil,1278:7) [13490]"}
              NoPerm[$frac] < newK$_23[$frac] || (NoPerm[$frac] == newK$_23[$frac] && NoPerm[$eps] < newK$_23[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion write > newK$_23 might not hold. (AVLTree.sil,1278:7) [13491]"}
              newK$_23[$frac] < FullPerm[$frac] || (newK$_23[$frac] == FullPerm[$frac] && newK$_23[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1278:7) [13492]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodekey$ might be null. (AVLTree.sil,1278:7) [13493]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodekey$. (AVLTree.sil,1278:7) [13494]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodekey$][$eps]);
            }
            Mask[this$_20, AVLTreeNodekey$] := PermSub(Mask[this$_20, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1278:7) [13495]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodeheight$ might be null. (AVLTree.sil,1278:7) [13496]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeheight$. (AVLTree.sil,1278:7) [13497]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodeheight$][$eps]);
            }
            Mask[this$_20, AVLTreeNodeheight$] := PermSub(Mask[this$_20, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1278:7) [13498]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1278:7) [13499]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1278:7) [13500]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodeleft$][$eps]);
            }
            Mask[this$_20, AVLTreeNodeleft$] := PermSub(Mask[this$_20, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1278:7) [13501]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1278:7) [13502]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1278:7) [13503]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNoderight$][$eps]);
            }
            Mask[this$_20, AVLTreeNoderight$] := PermSub(Mask[this$_20, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1278:7) [13504]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodekeys$ might be null. (AVLTree.sil,1278:7) [13505]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodekeys$. (AVLTree.sil,1278:7) [13506]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodekeys$][$eps]);
            }
            Mask[this$_20, AVLTreeNodekeys$] := PermSub(Mask[this$_20, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1278:7) [13507]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1278:7) [13508]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodebalanceFactor$. (AVLTree.sil,1278:7) [13509]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[this$_20, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_20, AVLTreeNodebalanceFactor$], perm);
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNodeleft$). (AVLTree.sil,1278:7) [13510]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1278:7) [13511]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1278:7) [13512]"}
                Heap[this$_20, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1278:7) [13513]"}
                  (perm[$frac] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1278:7) [13514]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1278:7) [13515]"}
                Heap[this$_20, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1278:7) [13516]"}
                  (perm[$frac] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1278:7) [13517]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1278:7) [13518]"}
                Heap[this$_20, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1278:7) [13519]"}
                  (perm[$frac] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion (forall k: Int :: true && k in this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_20.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1278:7) [13520]"}
                (forall k_2_1: int ::
                
                Seq#Contains(Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], k_2_1) ==> k_2_1 < Heap[this$_20, AVLTreeNodekey$]
              );
            }
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion this$_20.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,1278:7) [13521]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNoderight$). (AVLTree.sil,1278:7) [13522]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1278:7) [13523]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1278:7) [13524]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1278:7) [13525]"}
                (perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1278:7) [13526]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1278:7) [13527]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1278:7) [13528]"}
                (perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1278:7) [13529]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1278:7) [13530]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1278:7) [13531]"}
                (perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_20.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1278:7) [13532]"}
              (forall k1_2: int ::
              
              Seq#Contains(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[this$_20, AVLTreeNodekey$] < k1_2
            );
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion (unfolding acc(AVLTreeNodevalid$(this$_20.AVLTreeNoderight$), write) in this$_20.AVLTreeNoderight$.AVLTreeNodeleft$ != null) might not hold. (AVLTree.sil,1278:7) [13533]"}
              Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion (this$_20.AVLTreeNodeleft$ == null ? 0 : this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2 might not hold. (AVLTree.sil,1278:7) [13534]"}
              (if Heap[this$_20, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. Assertion this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ == 1 might not hold. (AVLTree.sil,1278:7) [13535]"}
              Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == 1;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            
            // -- Free assumptions
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekey$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
              Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_96: Ref, f_99: (Field A B) ::
                  { newPMask[o_96, f_99] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_96, f_99] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$])][o_96, f_99] ==> newPMask[o_96, f_99]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                havoc newPMask;
                assume (forall <A, B> o_97: Ref, f_100: (Field A B) ::
                  { newPMask[o_97, f_100] }
                  Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][o_97, f_100] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$])][o_97, f_100] ==> newPMask[o_97, f_100]
                );
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])] := newPMask;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
              }
              if (Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
                Heap[null, AVLTreeNodevalid$#sm(Heap[this$_20, AVLTreeNoderight$])][Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
              }
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            assume r_1 != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$];
            assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_20, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_20, AVLTreeNodekey$])), PreCallHeap[PreCallHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$]));
            assume state(Heap, Mask);
          assume r_1 == null || Heap[r_1, $allocated];
          assert {:msg "  The precondition of method AVLTreeNoderebalanceLR$ might not hold. The parameter newK$_23 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1278:7) [13536]"}
            newK$_23[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: fresh newK$_24  -- AVLTree.sil,1281:5
        
        // -- Translation of statement fresh newK$_24)
          havoc newK$_24;
          assume (newK$_24[$frac] > 0.000000000 && newK$_24[$frac] < 0.001000000) && newK$_24[$eps] == 0.000000000;
        assume state(Heap, Mask);
      
      // -- Translating statement: constraining(newK$_24) -- AVLTree.sil,1282:5
        
        // -- Translating statement: r := AVLTreeNoderebalanceLL$(this$_20, newK$_24) -- AVLTree.sil,1283:7
          PreCallHeap := Heap;
          PreCallMask := Mask;
          havoc r_1;
          
          // -- Exhaling precondition
            havoc ExhaleHeap;
            // Phase 1: pure assertions and fixed permissions
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion this$_20 != null might not hold. (AVLTree.sil,1283:7) [13537]"}
              this$_20 != null;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion newK$_24 > none might not hold. (AVLTree.sil,1283:7) [13538]"}
              NoPerm[$frac] < newK$_24[$frac] || (NoPerm[$frac] == newK$_24[$frac] && NoPerm[$eps] < newK$_24[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion write > newK$_24 might not hold. (AVLTree.sil,1283:7) [13539]"}
              newK$_24[$frac] < FullPerm[$frac] || (newK$_24[$frac] == FullPerm[$frac] && newK$_24[$eps] < FullPerm[$eps]);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1283:7) [13540]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodekey$ might be null. (AVLTree.sil,1283:7) [13541]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodekey$. (AVLTree.sil,1283:7) [13542]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodekey$][$eps]);
            }
            Mask[this$_20, AVLTreeNodekey$] := PermSub(Mask[this$_20, AVLTreeNodekey$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1283:7) [13543]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodeheight$ might be null. (AVLTree.sil,1283:7) [13544]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeheight$. (AVLTree.sil,1283:7) [13545]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodeheight$][$eps]);
            }
            Mask[this$_20, AVLTreeNodeheight$] := PermSub(Mask[this$_20, AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1283:7) [13546]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodeleft$ might be null. (AVLTree.sil,1283:7) [13547]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$. (AVLTree.sil,1283:7) [13548]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodeleft$][$eps]);
            }
            Mask[this$_20, AVLTreeNodeleft$] := PermSub(Mask[this$_20, AVLTreeNodeleft$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1283:7) [13549]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNoderight$ might be null. (AVLTree.sil,1283:7) [13550]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$. (AVLTree.sil,1283:7) [13551]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNoderight$][$eps]);
            }
            Mask[this$_20, AVLTreeNoderight$] := PermSub(Mask[this$_20, AVLTreeNoderight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1283:7) [13552]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodekeys$ might be null. (AVLTree.sil,1283:7) [13553]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodekeys$. (AVLTree.sil,1283:7) [13554]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodekeys$][$eps]);
            }
            Mask[this$_20, AVLTreeNodekeys$] := PermSub(Mask[this$_20, AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1283:7) [13555]"}
              Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1283:7) [13556]"}
              this$_20 != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodebalanceFactor$. (AVLTree.sil,1283:7) [13557]"}
                (perm[$frac] < Mask[this$_20, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_20, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_20, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_20, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_20, AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[this$_20, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_20, AVLTreeNodebalanceFactor$], perm);
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              perm := NoPerm;
              perm := PermAdd(perm, FullPerm);
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNodeleft$). (AVLTree.sil,1283:7) [13558]"}
                  (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])][$eps]);
              }
              Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNodeleft$])], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1283:7) [13559]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1283:7) [13560]"}
                Heap[this$_20, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1283:7) [13561]"}
                  (perm[$frac] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
              }
              Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1283:7) [13562]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1283:7) [13563]"}
                Heap[this$_20, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1283:7) [13564]"}
                  (perm[$frac] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
              }
              Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1283:7) [13565]"}
                Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1283:7) [13566]"}
                Heap[this$_20, AVLTreeNodeleft$] != null;
              perm := NoPerm;
              perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1283:7) [13567]"}
                  (perm[$frac] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
              }
              Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
            }
            if (Heap[this$_20, AVLTreeNodeleft$] != null) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_20.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1283:7) [13568]"}
                (forall k0: int ::
                
                Seq#Contains(Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$], k0) ==> k0 < Heap[this$_20, AVLTreeNodekey$]
              );
            }
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion this$_20.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,1283:7) [13569]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, FullPerm);
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_20.AVLTreeNoderight$). (AVLTree.sil,1283:7) [13570]"}
                (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])][$eps]);
            }
            Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_20, AVLTreeNoderight$])], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1283:7) [13571]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1283:7) [13572]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1283:7) [13573]"}
                (perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
            }
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1283:7) [13574]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1283:7) [13575]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1283:7) [13576]"}
                (perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
            }
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1283:7) [13577]"}
              Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Receiver of this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1283:7) [13578]"}
              Heap[this$_20, AVLTreeNoderight$] != null;
            perm := NoPerm;
            perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1283:7) [13579]"}
                (perm[$frac] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
            }
            Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_20.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_20.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1283:7) [13580]"}
              (forall k1_3: int ::
              
              Seq#Contains(Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_20, AVLTreeNodekey$] < k1_3
            );
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion (this$_20.AVLTreeNodeleft$ == null ? 0 : this$_20.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_20.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2 might not hold. (AVLTree.sil,1283:7) [13581]"}
              (if Heap[this$_20, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_20, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
            assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. Assertion this$_20.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ <= 0 might not hold. (AVLTree.sil,1283:7) [13582]"}
              Heap[Heap[this$_20, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 0;
            // Phase 2: abstract read permissions (and scaled abstract read permissions)
            // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
            // Finish exhale
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
          
          // -- Inhaling postcondition
            assume r_1 != null;
            perm := FullPerm;
            Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
            
            // -- Extra unfolding of predicate
              
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
            perm := Perm(0.500000000, 0.000000000);
            assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
            assume r_1 != null;
            Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
            assume Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == PreCallHeap[PreCallHeap[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
            assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_20, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_20, AVLTreeNodekey$])), PreCallHeap[PreCallHeap[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$]));
            assume state(Heap, Mask);
          assume r_1 == null || Heap[r_1, $allocated];
          assert {:msg "  The precondition of method AVLTreeNoderebalanceLL$ might not hold. The parameter newK$_24 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1283:7) [13583]"}
            newK$_24[$eps] == 0.000000000;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1254:11) [13584]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1255:11) [13585]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1256:11) [13586]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1256:11) [13587]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1256:11) [13588]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1257:11) [13589]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1257:11) [13590]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1257:11) [13591]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1258:11) [13592]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1258:11) [13593]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1258:11) [13594]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_20.AVLTreeNoderight$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,1259:11) [13595]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
    assert {:msg "  Postcondition of AVLTreeNoderebalanceRight$ might not hold. Assertion r.AVLTreeNodekeys$ == (old(this$_20.AVLTreeNodeleft$) == null ? Seq() : old(this$_20.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_20.AVLTreeNodekey$)) ++ old(this$_20.AVLTreeNoderight$.AVLTreeNodekeys$) might not hold. (AVLTree.sil,1260:11) [13596]"}
      Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_20, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_20, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_20, AVLTreeNodekey$])), old(Heap)[old(Heap)[this$_20, AVLTreeNoderight$], AVLTreeNodekeys$]));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderebalanceLR$
// ==================================================

procedure AVLTreeNoderebalanceLR$(this$_21: Ref, k$_17: Perm) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k_3: int;
  var k1_14: int;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var oldVersion: int;
  var newVersion: int;
  var newPMask: PMaskType;
  var k2_4: int;
  var k3_2: int;
  var k4_2: int;
  var newK$_15: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_this$_16: Ref;
  var ExhaleHeap: HeapType;
  var k5_2: int;
  var newK$_16: Perm;
  var newK$_17: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_21 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_17[$frac] || (NoPerm[$frac] == k$_17[$frac] && NoPerm[$eps] < k$_17[$eps]);
    assume state(Heap, Mask);
    assume k$_17[$frac] < FullPerm[$frac] || (k$_17[$frac] == FullPerm[$frac] && k$_17[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_21 != null;
    Mask[this$_21, AVLTreeNodekey$] := PermAdd(Mask[this$_21, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_21 != null;
    Mask[this$_21, AVLTreeNodeheight$] := PermAdd(Mask[this$_21, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_21 != null;
    Mask[this$_21, AVLTreeNodeleft$] := PermAdd(Mask[this$_21, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_21 != null;
    Mask[this$_21, AVLTreeNoderight$] := PermAdd(Mask[this$_21, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_21 != null;
    Mask[this$_21, AVLTreeNodekeys$] := PermAdd(Mask[this$_21, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_21 != null;
    Mask[this$_21, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_21, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_21.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1298:12) [13597]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1298:12) [13598]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_21, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_21.AVLTreeNodeleft$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1298:12) [13599]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_21.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1299:12) [13600]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1299:12) [13601]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_21, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1299:12) [13602]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1299:12) [13603]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_21, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_21.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1300:12) [13604]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1300:12) [13605]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_21, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1300:12) [13606]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1300:12) [13607]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_21, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_21.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1301:12) [13608]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1301:12) [13609]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_21, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_21.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1301:12) [13610]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1301:12) [13611]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_21, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_21.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1302:12) [13612]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1302:12) [13613]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_21, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of (forall k: Int :: true && k in this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k < this$_21.AVLTreeNodekey$))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1302:12) [13614]"}
          Heap[this$_21, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1302:12) [13615]"}
          HasDirectPerm(Mask, Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1302:12) [13616]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1302:12) [13617]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
        if (Seq#Contains(Heap[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$], k_3)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1302:12) [13618]"}
            this$_21 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1302:12) [13619]"}
            HasDirectPerm(Mask, this$_21, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k_1_2: int ::
        
        Seq#Contains(Heap[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$], k_1_2) ==> k_1_2 < Heap[this$_21, AVLTreeNodekey$]
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_21.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1303:12) [13620]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1303:12) [13621]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1304:12) [13622]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_21.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1305:12) [13623]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1305:12) [13624]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_21.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1306:12) [13625]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1306:12) [13626]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1307:12) [13627]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1307:12) [13628]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall k1: Int :: true && k1 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k1))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1308:13) [13629]"}
        Heap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1308:13) [13630]"}
        HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1308:13) [13631]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1308:13) [13632]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      if (Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k1_14)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1308:13) [13633]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1308:13) [13634]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    assume (forall k1_1: int ::
      
      Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_21, AVLTreeNodekey$] < k1_1
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of (unfolding acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write) in this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ != null)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$]));
      // Phase 1: pure assertions and fixed permissions
      perm := NoPerm;
      perm := PermAdd(perm, FullPerm);
      if (perm != NoPerm) {
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access AVLTreeNodevalid$(this$_21.AVLTreeNoderight$). (AVLTree.sil,1309:13) [13635]"}
          (perm[$frac] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])][$frac] || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])][$frac] && perm[$eps] < UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])][$eps])) || (perm[$frac] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])][$frac] && perm[$eps] == UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])][$eps]);
      }
      UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])] := PermSub(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])], perm);
      
      // -- Update version of predicate
        if (HasDirectPerm(UnfoldingMask, null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$]))) {
          oldVersion := UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])];
          havoc newVersion;
          assume oldVersion < newVersion;
          UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])] := newVersion;
        }
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
      perm := Perm(1.000000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])]);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        assume (forall lk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]
        );
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        perm := FullPerm;
        UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(UnfoldingMask[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[this$_21, AVLTreeNoderight$])], UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), UnfoldingHeap[null, AVLTreeNodevalid$(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])]);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
        UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(UnfoldingMask[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        assume (forall rk: int ::
          
          Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] < rk
        );
      }
      if (UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        assume UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
      }
      assume Seq#Equal(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$])), (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
      assume Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]);
      assume (forall kk: int ::
        
        Seq#Contains(UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], kk) == ((UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]))
      );
      assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
      assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else UnfoldingHeap[UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
      assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
      assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
      assume UnfoldingHeap[UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1309:13) [13636]"}
        HasDirectPerm(UnfoldingMask, this$_21, AVLTreeNoderight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ might be null. (AVLTree.sil,1309:13) [13637]"}
        UnfoldingHeap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$. (AVLTree.sil,1309:13) [13638]"}
        HasDirectPerm(UnfoldingMask, UnfoldingHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1309:13) [13639]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1309:13) [13640]"}
        HasDirectPerm(UnfoldingMask, this$_21, AVLTreeNoderight$);
      
      // -- Free assumptions
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_98: Ref, f_101: (Field A B) ::
            { newPMask[o_98, f_101] }
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][o_98, f_101] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][o_98, f_101] ==> newPMask[o_98, f_101]
          );
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])] := newPMask;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          havoc newPMask;
          assume (forall <A, B> o_99: Ref, f_102: (Field A B) ::
            { newPMask[o_99, f_102] }
            Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][o_99, f_102] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][o_99, f_102] ==> newPMask[o_99, f_102]
          );
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])] := newPMask;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
        }
      assume state(Heap, Mask);
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_100: Ref, f_103: (Field A B) ::
        { newPMask[o_100, f_103] }
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][o_100, f_103] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][o_100, f_103] ==> newPMask[o_100, f_103]
      );
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])] := newPMask;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      havoc newPMask;
      assume (forall <A, B> o_101: Ref, f_104: (Field A B) ::
        { newPMask[o_101, f_104] }
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][o_101, f_104] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][o_101, f_104] ==> newPMask[o_101, f_104]
      );
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])] := newPMask;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
    }
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
    
    // -- Free assumptions
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_102: Ref, f_105: (Field A B) ::
          { newPMask[o_102, f_105] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][o_102, f_105] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][o_102, f_105] ==> newPMask[o_102, f_105]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])] := newPMask;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := true;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        havoc newPMask;
        assume (forall <A, B> o_103: Ref, f_106: (Field A B) ::
          { newPMask[o_103, f_106] }
          Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][o_103, f_106] || Heap[null, AVLTreeNodevalid$#sm(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][o_103, f_106] ==> newPMask[o_103, f_106]
        );
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])] := newPMask;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := true;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := true;
      }
      if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
        Heap[null, AVLTreeNodevalid$#sm(Heap[this$_21, AVLTreeNoderight$])][Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := true;
      }
    assume state(Heap, Mask);
    
    // -- Check definedness of (this$_21.AVLTreeNodeleft$ == null ? 0 : this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_21.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1310:12) [13641]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1310:12) [13642]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      if (Heap[this$_21, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1310:12) [13643]"}
          Heap[this$_21, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1310:12) [13644]"}
          HasDirectPerm(Mask, Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1310:12) [13645]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1310:12) [13646]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1310:12) [13647]"}
        Heap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1310:12) [13648]"}
        HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1310:12) [13649]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1310:12) [13650]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume (if Heap[this$_21, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ == 1
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1311:12) [13651]"}
        Heap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1311:12) [13652]"}
        HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1311:12) [13653]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1311:12) [13654]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == 1;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodeheight$ == old(this$_21.AVLTreeNoderight$.AVLTreeNodeheight$)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1317:11) [13655]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1317:11) [13656]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1317:11) [13657]"}
        old(Heap)[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1317:11) [13658]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1317:11) [13659]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1317:11) [13660]"}
        HasDirectPerm(old(Mask), this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$];
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodekeys$ == (old(this$_21.AVLTreeNodeleft$) == null ? Seq() : old(this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_21.AVLTreeNodekey$)) ++ old(this$_21.AVLTreeNoderight$.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1318:11) [13661]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1318:11) [13662]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1318:11) [13663]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1318:11) [13664]"}
        HasDirectPerm(old(Mask), this$_21, AVLTreeNodeleft$);
      if (old(Heap)[this$_21, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1318:11) [13665]"}
          old(Heap)[this$_21, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1318:11) [13666]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1318:11) [13667]"}
          this$_21 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1318:11) [13668]"}
          HasDirectPerm(old(Mask), this$_21, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1318:11) [13669]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1318:11) [13670]"}
        HasDirectPerm(old(Mask), this$_21, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1318:11) [13671]"}
        old(Heap)[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1318:11) [13672]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1318:11) [13673]"}
        this$_21 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1318:11) [13674]"}
        HasDirectPerm(old(Mask), this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_21, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_21, AVLTreeNodekey$])), old(Heap)[old(Heap)[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$]));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_21 == null || Heap[this$_21, $allocated];
    assume k$_17[$eps] == 0.000000000;
  
  // -- Translating statement: assert (forall k2: Int :: true && k2 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k2)) -- AVLTree.sil,1327:3
    
    // -- Check definedness of (forall k2: Int :: true && k2 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k2))
      assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1327:3) [13675]"}
        Heap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1327:3) [13676]"}
        HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1327:3) [13677]"}
        this$_21 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1327:3) [13678]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      if (Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k2_4)) {
        assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1327:3) [13679]"}
          this$_21 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1327:3) [13680]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion (forall k2: Int :: true && k2 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k2)) might not hold. (AVLTree.sil,1327:3) [13681]"}
      (forall k2_1: int ::
      
      Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k2_1) ==> Heap[this$_21, AVLTreeNodekey$] < k2_1
    );
    assume state(Heap, Mask);
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write) -- AVLTree.sil,1328:3
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_21.AVLTreeNoderight$), write)
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_21.AVLTreeNoderight$) might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1328:3) [13682]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$]));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_21.AVLTreeNoderight$) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_21.AVLTreeNoderight$). (AVLTree.sil,1328:3) [13685]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$]))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_21, AVLTreeNoderight$] != null;
    Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_21, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])], Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])]);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      assume (forall lk_1: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk_1) ==> lk_1 < Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]
      );
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      assume Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_21, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])], Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])]);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      assume (forall rk_1: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk_1) ==> Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] < rk_1
      );
    }
    if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      assume Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$])), (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]);
    assume (forall kk_1: int ::
      
      Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], kk_1) == ((Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk_1)) || ((Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk_1)) || kk_1 == Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]))
    );
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r := this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ -- AVLTree.sil,1329:3
    
    // -- Check definedness of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ might be null. (AVLTree.sil,1329:3) [13686]"}
        Heap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$. (AVLTree.sil,1329:3) [13687]"}
        HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$);
      assert {:msg "  Assignment might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1329:3) [13688]"}
        this$_21 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1329:3) [13689]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    r_1 := Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$];
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (forall k3: Int :: true && k3 in r.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k3)) -- AVLTree.sil,1330:3
    
    // -- Check definedness of (forall k3: Int :: true && k3 in r.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k3))
      assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1330:3) [13690]"}
        r_1 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1330:3) [13691]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      if (Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k3_2)) {
        assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1330:3) [13692]"}
          this$_21 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1330:3) [13693]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Assert might fail. Assertion (forall k3: Int :: true && k3 in r.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k3)) might not hold. (AVLTree.sil,1330:3) [13694]"}
      (forall k3_1: int ::
      
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], k3_1) ==> Heap[this$_21, AVLTreeNodekey$] < k3_1
    );
    assume state(Heap, Mask);
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(r), write) -- AVLTree.sil,1331:3
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(r_1));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(r) might fail. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1331:3) [13697]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(r_1))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(r_1)];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(r_1)] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekey$] := PermAdd(Mask[r_1, AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeleft$] := PermAdd(Mask[r_1, AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNoderight$] := PermAdd(Mask[r_1, AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(r_1, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(r_1)], Heap[r_1, AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])]);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNodeleft$] != null;
      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNodeleft$] != null;
      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNodeleft$] != null;
      Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      assume (forall lk_2: int ::
        
        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], lk_2) ==> lk_2 < Heap[r_1, AVLTreeNodekey$]
      );
    }
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      assume Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(r_1, AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(r_1)], Heap[r_1, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])]);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNoderight$] != null;
      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNoderight$] != null;
      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[r_1, AVLTreeNoderight$] != null;
      Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      assume (forall rk_2: int ::
        
        Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], rk_2) ==> Heap[r_1, AVLTreeNodekey$] < rk_2
      );
    }
    if (Heap[r_1, AVLTreeNoderight$] != null) {
      assume Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[r_1, AVLTreeNodekey$])), (if Heap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[r_1, AVLTreeNodekeys$], Heap[r_1, AVLTreeNodekey$]);
    assume (forall kk_2: int ::
      
      Seq#Contains(Heap[r_1, AVLTreeNodekeys$], kk_2) == ((Heap[r_1, AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], kk_2)) || ((Heap[r_1, AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], kk_2)) || kk_2 == Heap[r_1, AVLTreeNodekey$]))
    );
    assume Heap[r_1, AVLTreeNodeheight$] == (if (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[r_1, AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[r_1, AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[r_1, AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (r.AVLTreeNodeleft$ != null) ==> (forall k4: Int :: true && k4 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k4)) -- AVLTree.sil,1332:3
    
    // -- Check definedness of (r.AVLTreeNodeleft$ != null) ==> (forall k4: Int :: true && k4 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k4))
      assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1332:3) [13698]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      if (Heap[r_1, AVLTreeNodeleft$] != null) {
        assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1332:3) [13699]"}
          Heap[r_1, AVLTreeNodeleft$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1332:3) [13700]"}
          HasDirectPerm(Mask, Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Assert might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1332:3) [13701]"}
          r_1 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1332:3) [13702]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
        if (Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k4_2)) {
          assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1332:3) [13703]"}
            this$_21 != null;
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1332:3) [13704]"}
            HasDirectPerm(Mask, this$_21, AVLTreeNodekey$);
        }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[r_1, AVLTreeNodeleft$] != null) {
      assert {:msg "  Assert might fail. Assertion (forall k4: Int :: true && k4 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k4)) might not hold. (AVLTree.sil,1332:3) [13705]"}
        (forall k4_1: int ::
        
        Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k4_1) ==> Heap[this$_21, AVLTreeNodekey$] < k4_1
      );
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ := r.AVLTreeNoderight$ -- AVLTree.sil,1333:3
    
    // -- Check definedness of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ might be null. (AVLTree.sil,1333:3) [13706]"}
        Heap[this$_21, AVLTreeNoderight$] != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$. (AVLTree.sil,1333:3) [13707]"}
        HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$);
      assert {:msg "  Assignment might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1333:3) [13708]"}
        this$_21 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1333:3) [13709]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1333:3) [13710]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1333:3) [13711]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := Heap[r_1, AVLTreeNoderight$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$. (AVLTree.sil,1333:3) [13712]"}
      FullPerm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_15  -- AVLTree.sil,1334:3
    
    // -- Translation of statement fresh newK$_15)
      havoc newK$_15;
      assume (newK$_15[$frac] > 0.000000000 && newK$_15[$frac] < 0.001000000) && newK$_15[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_15) -- AVLTree.sil,1335:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_21.AVLTreeNoderight$, newK$_15) -- AVLTree.sil,1336:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Check definedness of this$_21.AVLTreeNoderight$
        assert {:msg "  Method call might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1336:5) [13713]"}
          this$_21 != null;
        assert {:msg "  Method call might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1336:5) [13714]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
        assume state(Heap, Mask);
      arg_this$_16 := Heap[this$_21, AVLTreeNoderight$];
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_21.AVLTreeNoderight$ != null might not hold. (AVLTree.sil,1336:5) [13715]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_15 > none might not hold. (AVLTree.sil,1336:5) [13716]"}
          NoPerm[$frac] < newK$_15[$frac] || (NoPerm[$frac] == newK$_15[$frac] && NoPerm[$eps] < newK$_15[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_15 might not hold. (AVLTree.sil,1336:5) [13717]"}
          newK$_15[$frac] < FullPerm[$frac] || (newK$_15[$frac] == FullPerm[$frac] && newK$_15[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1336:5) [13718]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekey$ might be null. (AVLTree.sil,1336:5) [13719]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekey$. (AVLTree.sil,1336:5) [13720]"}
            (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$][$eps]);
        }
        Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1336:5) [13721]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1336:5) [13722]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1336:5) [13723]"}
            (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
        }
        Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1336:5) [13724]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ might be null. (AVLTree.sil,1336:5) [13725]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$. (AVLTree.sil,1336:5) [13726]"}
            (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$][$eps]);
        }
        Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1336:5) [13727]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNoderight$ might be null. (AVLTree.sil,1336:5) [13728]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNoderight$. (AVLTree.sil,1336:5) [13729]"}
            (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$][$eps]);
        }
        Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1336:5) [13730]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1336:5) [13731]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1336:5) [13732]"}
            (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
        }
        Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1336:5) [13733]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1336:5) [13734]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1336:5) [13735]"}
            (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_21.AVLTreeNoderight$.AVLTreeNodeleft$). (AVLTree.sil,1336:5) [13736]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1336:5) [13737]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1336:5) [13738]"}
            Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1336:5) [13739]"}
              (perm[$frac] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1336:5) [13740]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1336:5) [13741]"}
            Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1336:5) [13742]"}
              (perm[$frac] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1336:5) [13743]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1336:5) [13744]"}
            Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1336:5) [13745]"}
              (perm[$frac] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_21.AVLTreeNoderight$.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1336:5) [13746]"}
            (forall k0: int ::
            
            Seq#Contains(Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], k0) ==> k0 < Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$]
          );
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_21.AVLTreeNoderight$.AVLTreeNoderight$). (AVLTree.sil,1336:5) [13747]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1336:5) [13748]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1336:5) [13749]"}
            Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1336:5) [13750]"}
              (perm[$frac] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1336:5) [13751]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1336:5) [13752]"}
            Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1336:5) [13753]"}
              (perm[$frac] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1336:5) [13754]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1336:5) [13755]"}
            Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1336:5) [13756]"}
              (perm[$frac] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNoderight$.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1336:5) [13757]"}
            (forall k1_2: int ::
            
            Seq#Contains(Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekey$] < k1_2
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ == null ? 0 : this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_21.AVLTreeNoderight$.AVLTreeNoderight$ == null ? 0 : this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1336:5) [13758]"}
          (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_21.AVLTreeNoderight$.AVLTreeNodeleft$ == null ? 0 : this$_21.AVLTreeNoderight$.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_21.AVLTreeNoderight$.AVLTreeNoderight$ == null ? 0 : this$_21.AVLTreeNoderight$.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1336:5) [13759]"}
          (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(arg_this$_16)] := PermAdd(Mask[null, AVLTreeNodevalid$(arg_this$_16)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_16 != null;
        Mask[arg_this$_16, AVLTreeNodeheight$] := PermAdd(Mask[arg_this$_16, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_16 != null;
        Mask[arg_this$_16, AVLTreeNodekeys$] := PermAdd(Mask[arg_this$_16, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume arg_this$_16 != null;
        Mask[arg_this$_16, AVLTreeNodebalanceFactor$] := PermAdd(Mask[arg_this$_16, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[arg_this$_16, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[arg_this$_16, AVLTreeNodekey$])), (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[arg_this$_16, AVLTreeNodeheight$] == (if (if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[arg_this$_16, AVLTreeNodebalanceFactor$] == (if PreCallHeap[arg_this$_16, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[arg_this$_16, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[arg_this$_16, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_15 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1336:5) [13760]"}
        newK$_15[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r.AVLTreeNoderight$ := this$_21.AVLTreeNoderight$ -- AVLTree.sil,1338:3
    
    // -- Check definedness of r.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1338:3) [13761]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1338:3) [13762]"}
        HasDirectPerm(Mask, r_1, AVLTreeNoderight$);
      assume state(Heap, Mask);
    
    // -- Check definedness of this$_21.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1338:3) [13763]"}
        this$_21 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1338:3) [13764]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    Heap[r_1, AVLTreeNoderight$] := Heap[this$_21, AVLTreeNoderight$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1338:3) [13765]"}
      FullPerm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_21.AVLTreeNoderight$ := r.AVLTreeNodeleft$ -- AVLTree.sil,1339:3
    
    // -- Check definedness of this$_21.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1339:3) [13766]"}
        this$_21 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1339:3) [13767]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1339:3) [13768]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1339:3) [13769]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[this$_21, AVLTreeNoderight$] := Heap[r_1, AVLTreeNodeleft$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1339:3) [13770]"}
      FullPerm[$frac] == Mask[this$_21, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_21, AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: assert (this$_21.AVLTreeNoderight$ != null) ==> (forall k5: Int :: true && k5 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k5)) -- AVLTree.sil,1340:3
    
    // -- Check definedness of (this$_21.AVLTreeNoderight$ != null) ==> (forall k5: Int :: true && k5 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k5))
      assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1340:3) [13771]"}
        this$_21 != null;
      assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1340:3) [13772]"}
        HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
      if (Heap[this$_21, AVLTreeNoderight$] != null) {
        assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1340:3) [13773]"}
          Heap[this$_21, AVLTreeNoderight$] != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1340:3) [13774]"}
          HasDirectPerm(Mask, Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$);
        assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1340:3) [13775]"}
          this$_21 != null;
        assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1340:3) [13776]"}
          HasDirectPerm(Mask, this$_21, AVLTreeNoderight$);
        if (Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k5_2)) {
          assert {:msg "  Assert might fail. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1340:3) [13777]"}
            this$_21 != null;
          assert {:msg "  Assert might fail. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1340:3) [13778]"}
            HasDirectPerm(Mask, this$_21, AVLTreeNodekey$);
        }
      }
      assume state(Heap, Mask);
    // Phase 1: pure assertions and fixed permissions
    if (Heap[this$_21, AVLTreeNoderight$] != null) {
      assert {:msg "  Assert might fail. Assertion (forall k5: Int :: true && k5 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k5)) might not hold. (AVLTree.sil,1340:3) [13779]"}
        (forall k5_1: int ::
        
        Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k5_1) ==> Heap[this$_21, AVLTreeNodekey$] < k5_1
      );
    }
    // Phase 2: abstract read permissions (and scaled abstract read permissions)
    // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_16  -- AVLTree.sil,1341:3
    
    // -- Translation of statement fresh newK$_16)
      havoc newK$_16;
      assume (newK$_16[$frac] > 0.000000000 && newK$_16[$frac] < 0.001000000) && newK$_16[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_16) -- AVLTree.sil,1342:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_21, newK$_16) -- AVLTree.sil,1343:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_21 != null might not hold. (AVLTree.sil,1343:5) [13780]"}
          this$_21 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_16 > none might not hold. (AVLTree.sil,1343:5) [13781]"}
          NoPerm[$frac] < newK$_16[$frac] || (NoPerm[$frac] == newK$_16[$frac] && NoPerm[$eps] < newK$_16[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_16 might not hold. (AVLTree.sil,1343:5) [13782]"}
          newK$_16[$frac] < FullPerm[$frac] || (newK$_16[$frac] == FullPerm[$frac] && newK$_16[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1343:5) [13783]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodekey$ might be null. (AVLTree.sil,1343:5) [13784]"}
          this$_21 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodekey$. (AVLTree.sil,1343:5) [13785]"}
            (perm[$frac] < Mask[this$_21, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_21, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_21, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_21, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_21, AVLTreeNodekey$][$eps]);
        }
        Mask[this$_21, AVLTreeNodekey$] := PermSub(Mask[this$_21, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1343:5) [13786]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodeheight$ might be null. (AVLTree.sil,1343:5) [13787]"}
          this$_21 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodeheight$. (AVLTree.sil,1343:5) [13788]"}
            (perm[$frac] < Mask[this$_21, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_21, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_21, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_21, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_21, AVLTreeNodeheight$][$eps]);
        }
        Mask[this$_21, AVLTreeNodeheight$] := PermSub(Mask[this$_21, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1343:5) [13789]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodeleft$ might be null. (AVLTree.sil,1343:5) [13790]"}
          this$_21 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodeleft$. (AVLTree.sil,1343:5) [13791]"}
            (perm[$frac] < Mask[this$_21, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_21, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_21, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_21, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_21, AVLTreeNodeleft$][$eps]);
        }
        Mask[this$_21, AVLTreeNodeleft$] := PermSub(Mask[this$_21, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1343:5) [13792]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$ might be null. (AVLTree.sil,1343:5) [13793]"}
          this$_21 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$. (AVLTree.sil,1343:5) [13794]"}
            (perm[$frac] < Mask[this$_21, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_21, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_21, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_21, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_21, AVLTreeNoderight$][$eps]);
        }
        Mask[this$_21, AVLTreeNoderight$] := PermSub(Mask[this$_21, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1343:5) [13795]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodekeys$ might be null. (AVLTree.sil,1343:5) [13796]"}
          this$_21 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodekeys$. (AVLTree.sil,1343:5) [13797]"}
            (perm[$frac] < Mask[this$_21, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_21, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_21, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_21, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_21, AVLTreeNodekeys$][$eps]);
        }
        Mask[this$_21, AVLTreeNodekeys$] := PermSub(Mask[this$_21, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1343:5) [13798]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1343:5) [13799]"}
          this$_21 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodebalanceFactor$. (AVLTree.sil,1343:5) [13800]"}
            (perm[$frac] < Mask[this$_21, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_21, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_21, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_21, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_21, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[this$_21, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_21, AVLTreeNodebalanceFactor$], perm);
        if (Heap[this$_21, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_21.AVLTreeNodeleft$). (AVLTree.sil,1343:5) [13801]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNodeleft$])], perm);
        }
        if (Heap[this$_21, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1343:5) [13802]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1343:5) [13803]"}
            Heap[this$_21, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1343:5) [13804]"}
              (perm[$frac] < Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_21, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1343:5) [13805]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1343:5) [13806]"}
            Heap[this$_21, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1343:5) [13807]"}
              (perm[$frac] < Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_21, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1343:5) [13808]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1343:5) [13809]"}
            Heap[this$_21, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1343:5) [13810]"}
              (perm[$frac] < Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_21, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_21.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1343:5) [13811]"}
            (forall k0_1: int ::
            
            Seq#Contains(Heap[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[this$_21, AVLTreeNodekey$]
          );
        }
        if (Heap[this$_21, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_21.AVLTreeNoderight$). (AVLTree.sil,1343:5) [13812]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_21, AVLTreeNoderight$])], perm);
        }
        if (Heap[this$_21, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1343:5) [13813]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1343:5) [13814]"}
            Heap[this$_21, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1343:5) [13815]"}
              (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_21, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1343:5) [13816]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1343:5) [13817]"}
            Heap[this$_21, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1343:5) [13818]"}
              (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_21, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1343:5) [13819]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1343:5) [13820]"}
            Heap[this$_21, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_21.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1343:5) [13821]"}
              (perm[$frac] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_21, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_21.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_21.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1343:5) [13822]"}
            (forall k1_3: int ::
            
            Seq#Contains(Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[this$_21, AVLTreeNodekey$] < k1_3
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_21.AVLTreeNodeleft$ == null ? 0 : this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_21.AVLTreeNoderight$ == null ? 0 : this$_21.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1343:5) [13823]"}
          (if Heap[this$_21, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_21, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_21.AVLTreeNodeleft$ == null ? 0 : this$_21.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_21.AVLTreeNoderight$ == null ? 0 : this$_21.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1343:5) [13824]"}
          (if Heap[this$_21, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_21, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(this$_21)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_21)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_21 != null;
        Mask[this$_21, AVLTreeNodeheight$] := PermAdd(Mask[this$_21, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_21 != null;
        Mask[this$_21, AVLTreeNodekeys$] := PermAdd(Mask[this$_21, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_21 != null;
        Mask[this$_21, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_21, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[this$_21, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_21, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_21, AVLTreeNodekey$])), (if PreCallHeap[this$_21, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[this$_21, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_21, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_21, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_21, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_21, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[this$_21, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_21, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_21, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_21, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_16 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1343:5) [13825]"}
        newK$_16[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r.AVLTreeNodeleft$ := this$_21 -- AVLTree.sil,1345:3
    
    // -- Check definedness of r.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1345:3) [13826]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1345:3) [13827]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[r_1, AVLTreeNodeleft$] := this$_21;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1345:3) [13828]"}
      FullPerm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_17  -- AVLTree.sil,1346:3
    
    // -- Translation of statement fresh newK$_17)
      havoc newK$_17;
      assume (newK$_17[$frac] > 0.000000000 && newK$_17[$frac] < 0.001000000) && newK$_17[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_17) -- AVLTree.sil,1347:3
    
    // -- Translating statement: AVLTreeNodeclose$(r, newK$_17) -- AVLTree.sil,1348:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1348:5) [13829]"}
          r_1 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_17 > none might not hold. (AVLTree.sil,1348:5) [13830]"}
          NoPerm[$frac] < newK$_17[$frac] || (NoPerm[$frac] == newK$_17[$frac] && NoPerm[$eps] < newK$_17[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_17 might not hold. (AVLTree.sil,1348:5) [13831]"}
          newK$_17[$frac] < FullPerm[$frac] || (newK$_17[$frac] == FullPerm[$frac] && newK$_17[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1348:5) [13832]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,1348:5) [13833]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,1348:5) [13834]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
        }
        Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1348:5) [13835]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1348:5) [13836]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1348:5) [13837]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
        }
        Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1348:5) [13838]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1348:5) [13839]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1348:5) [13840]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
        }
        Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1348:5) [13841]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1348:5) [13842]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1348:5) [13843]"}
            (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
        }
        Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1348:5) [13844]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1348:5) [13845]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1348:5) [13846]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
        }
        Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1348:5) [13847]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1348:5) [13848]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1348:5) [13849]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,1348:5) [13850]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1348:5) [13851]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1348:5) [13852]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1348:5) [13853]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1348:5) [13854]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1348:5) [13855]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1348:5) [13856]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1348:5) [13857]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1348:5) [13858]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1348:5) [13859]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1348:5) [13860]"}
            (forall k0_2: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_2) ==> k0_2 < Heap[r_1, AVLTreeNodekey$]
          );
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,1348:5) [13861]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1348:5) [13862]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1348:5) [13863]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1348:5) [13864]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1348:5) [13865]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1348:5) [13866]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1348:5) [13867]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1348:5) [13868]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1348:5) [13869]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1348:5) [13870]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1348:5) [13871]"}
            (forall k1_4: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_4) ==> Heap[r_1, AVLTreeNodekey$] < k1_4
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1348:5) [13872]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1348:5) [13873]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_17 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1348:5) [13874]"}
        newK$_17[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1312:11) [13875]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1313:11) [13876]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1314:11) [13877]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1314:11) [13878]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1314:11) [13879]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1315:11) [13880]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1315:11) [13881]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1315:11) [13882]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1316:11) [13883]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1316:11) [13884]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1316:11) [13885]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Assertion r.AVLTreeNodeheight$ == old(this$_21.AVLTreeNoderight$.AVLTreeNodeheight$) might not hold. (AVLTree.sil,1317:11) [13886]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_21, AVLTreeNoderight$], AVLTreeNodeheight$];
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLR$ might not hold. Assertion r.AVLTreeNodekeys$ == (old(this$_21.AVLTreeNodeleft$) == null ? Seq() : old(this$_21.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_21.AVLTreeNodekey$)) ++ old(this$_21.AVLTreeNoderight$.AVLTreeNodekeys$) might not hold. (AVLTree.sil,1318:11) [13887]"}
      Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_21, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_21, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_21, AVLTreeNodekey$])), old(Heap)[old(Heap)[this$_21, AVLTreeNoderight$], AVLTreeNodekeys$]));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method AVLTreeNoderebalanceLL$
// ==================================================

procedure AVLTreeNoderebalanceLL$(this$_22: Ref, k$_18: Perm) returns (r_1: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var k0_13: int;
  var k1_15: int;
  var oldVersion: int;
  var newVersion: int;
  var newK$_37: Perm;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var newK$_38: Perm;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
  
  // -- Checked inhaling of precondition
    assume this$_22 != null;
    assume state(Heap, Mask);
    assume NoPerm[$frac] < k$_18[$frac] || (NoPerm[$frac] == k$_18[$frac] && NoPerm[$eps] < k$_18[$eps]);
    assume state(Heap, Mask);
    assume k$_18[$frac] < FullPerm[$frac] || (k$_18[$frac] == FullPerm[$frac] && k$_18[$eps] < FullPerm[$eps]);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_22 != null;
    Mask[this$_22, AVLTreeNodekey$] := PermAdd(Mask[this$_22, AVLTreeNodekey$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_22 != null;
    Mask[this$_22, AVLTreeNodeheight$] := PermAdd(Mask[this$_22, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_22 != null;
    Mask[this$_22, AVLTreeNodeleft$] := PermAdd(Mask[this$_22, AVLTreeNodeleft$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_22 != null;
    Mask[this$_22, AVLTreeNoderight$] := PermAdd(Mask[this$_22, AVLTreeNoderight$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_22 != null;
    Mask[this$_22, AVLTreeNodekeys$] := PermAdd(Mask[this$_22, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume this$_22 != null;
    Mask[this$_22, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_22, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_22.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1362:12) [13888]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1362:12) [13889]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_22, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(AVLTreeNodevalid$(this$_22.AVLTreeNodeleft$), write)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1362:12) [13890]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_22.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1363:12) [13891]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1363:12) [13892]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_22, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1363:12) [13893]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1363:12) [13894]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_22, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_22.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1364:12) [13895]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1364:12) [13896]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_22, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1364:12) [13897]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1364:12) [13898]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_22, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_22.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1365:12) [13899]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1365:12) [13900]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_22, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of acc(this$_22.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$, 50 / 100)
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1365:12) [13901]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1365:12) [13902]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
        assume state(Heap, Mask);
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[this$_22, AVLTreeNodeleft$] != null;
      Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_22.AVLTreeNodeleft$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1366:12) [13903]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1366:12) [13904]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    if (Heap[this$_22, AVLTreeNodeleft$] != null) {
      
      // -- Check definedness of (forall k0: Int :: true && k0 in this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_22.AVLTreeNodekey$))
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1366:12) [13905]"}
          Heap[this$_22, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1366:12) [13906]"}
          HasDirectPerm(Mask, Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1366:12) [13907]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1366:12) [13908]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
        if (Seq#Contains(Heap[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_13)) {
          assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodekey$ might be null. (AVLTree.sil,1366:12) [13909]"}
            this$_22 != null;
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodekey$. (AVLTree.sil,1366:12) [13910]"}
            HasDirectPerm(Mask, this$_22, AVLTreeNodekey$);
        }
        assume state(Heap, Mask);
      assume (forall k0_1: int ::
        
        Seq#Contains(Heap[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_1) ==> k0_1 < Heap[this$_22, AVLTreeNodekey$]
      );
      assume state(Heap, Mask);
    }
    
    // -- Check definedness of this$_22.AVLTreeNoderight$ != null
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1367:12) [13911]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1367:12) [13912]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_22.AVLTreeNoderight$), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1368:12) [13913]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1369:12) [13914]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1369:12) [13915]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_22.AVLTreeNoderight$.AVLTreeNodekeys$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1370:12) [13916]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1370:12) [13917]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$, 50 / 100)
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1371:12) [13918]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1371:12) [13919]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (forall k1: Int :: true && k1 in this$_22.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_22.AVLTreeNodekey$ < k1))
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1372:13) [13920]"}
        Heap[this$_22, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1372:13) [13921]"}
        HasDirectPerm(Mask, Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1372:13) [13922]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1372:13) [13923]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      if (Seq#Contains(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], k1_15)) {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodekey$ might be null. (AVLTree.sil,1372:13) [13924]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodekey$. (AVLTree.sil,1372:13) [13925]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodekey$);
      }
      assume state(Heap, Mask);
    assume (forall k1_1: int ::
      
      Seq#Contains(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], k1_1) ==> Heap[this$_22, AVLTreeNodekey$] < k1_1
    );
    assume state(Heap, Mask);
    
    // -- Check definedness of (this$_22.AVLTreeNodeleft$ == null ? 0 : this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$) - this$_22.AVLTreeNoderight$.AVLTreeNodeheight$ == 0 - 2
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1373:12) [13926]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1373:12) [13927]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      if (Heap[this$_22, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1373:12) [13928]"}
          Heap[this$_22, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1373:12) [13929]"}
          HasDirectPerm(Mask, Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1373:12) [13930]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1373:12) [13931]"}
          HasDirectPerm(Mask, this$_22, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1373:12) [13932]"}
        Heap[this$_22, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1373:12) [13933]"}
        HasDirectPerm(Mask, Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1373:12) [13934]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1373:12) [13935]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume (if Heap[this$_22, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$]) - Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] == -2;
    assume state(Heap, Mask);
    
    // -- Check definedness of this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ <= 0
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1374:12) [13936]"}
        Heap[this$_22, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1374:12) [13937]"}
        HasDirectPerm(Mask, Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1374:12) [13938]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1374:12) [13939]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 0;
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    assume Heap == old(Heap);
    assume Mask == old(Mask);
  if (*) {
    // Checked inhaling of postcondition to check definedness
    assume r_1 != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    
    // -- Extra unfolding of predicate
      
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
    assume state(Heap, Mask);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume r_1 != null;
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assume state(Heap, Mask);
    
    // -- Check definedness of (r.AVLTreeNodeheight$ == old(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$) + 1)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1380:11) [13940]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1380:11) [13941]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1380:11) [13942]"}
        old(Heap)[this$_22, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1380:11) [13943]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1380:11) [13944]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1380:11) [13945]"}
        HasDirectPerm(old(Mask), this$_22, AVLTreeNoderight$);
      if (!(Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$])) {
        assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1380:11) [13946]"}
          r_1 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1380:11) [13947]"}
          HasDirectPerm(Mask, r_1, AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1380:11) [13948]"}
          old(Heap)[this$_22, AVLTreeNoderight$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1380:11) [13949]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1380:11) [13950]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1380:11) [13951]"}
          HasDirectPerm(old(Mask), this$_22, AVLTreeNoderight$);
      }
      assume state(Heap, Mask);
    assume Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
    assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodekeys$ == (old(this$_22.AVLTreeNodeleft$) == null ? Seq() : old(this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_22.AVLTreeNodekey$)) ++ old(this$_22.AVLTreeNoderight$.AVLTreeNodekeys$)
      assert {:msg "  Contract might not be well-formed. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1381:11) [13952]"}
        r_1 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1381:11) [13953]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1381:11) [13954]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1381:11) [13955]"}
        HasDirectPerm(old(Mask), this$_22, AVLTreeNodeleft$);
      if (old(Heap)[this$_22, AVLTreeNodeleft$] == null) {
      } else {
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1381:11) [13956]"}
          old(Heap)[this$_22, AVLTreeNodeleft$] != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1381:11) [13957]"}
          HasDirectPerm(old(Mask), old(Heap)[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$);
        assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1381:11) [13958]"}
          this$_22 != null;
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1381:11) [13959]"}
          HasDirectPerm(old(Mask), this$_22, AVLTreeNodeleft$);
      }
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNodekey$ might be null. (AVLTree.sil,1381:11) [13960]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNodekey$. (AVLTree.sil,1381:11) [13961]"}
        HasDirectPerm(old(Mask), this$_22, AVLTreeNodekey$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1381:11) [13962]"}
        old(Heap)[this$_22, AVLTreeNoderight$] != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1381:11) [13963]"}
        HasDirectPerm(old(Mask), old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$);
      assert {:msg "  Contract might not be well-formed. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1381:11) [13964]"}
        this$_22 != null;
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1381:11) [13965]"}
        HasDirectPerm(old(Mask), this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_22, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_22, AVLTreeNodekey$])), old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$]));
    assume state(Heap, Mask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about method arguments
    assume this$_22 == null || Heap[this$_22, $allocated];
    assume k$_18[$eps] == 0.000000000;
  
  // -- Translating statement: unfold acc(AVLTreeNodevalid$(this$_22.AVLTreeNoderight$), write) -- AVLTree.sil,1389:3
    
    // -- Check definedness of acc(AVLTreeNodevalid$(this$_22.AVLTreeNoderight$), write)
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_22.AVLTreeNoderight$) might fail. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1389:3) [13966]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    assume AVLTreeNodevalid$#trigger(AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$]));
    // Phase 1: pure assertions and fixed permissions
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Unfolding AVLTreeNodevalid$(this$_22.AVLTreeNoderight$) might fail. There might be insufficient permission to access AVLTreeNodevalid$(this$_22.AVLTreeNoderight$). (AVLTree.sil,1389:3) [13969]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])], perm);
    
    // -- Update version of predicate
      if (HasDirectPerm(Mask, null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$]))) {
        oldVersion := Heap[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])];
        havoc newVersion;
        assume oldVersion < newVersion;
        Heap[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])] := newVersion;
      }
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], perm);
    perm := Perm(1.000000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    perm := Perm(0.500000000, 0.000000000);
    assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
    assume Heap[this$_22, AVLTreeNoderight$] != null;
    Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_22, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])], Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$])]);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null;
      Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      assume (forall lk: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], lk) ==> lk < Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$]
      );
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null) {
      assume Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$] > 0;
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := FullPerm;
      Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$])] := PermAdd(Mask[null, AVLTreeNodevalid$(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$])], perm);
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(Heap[this$_22, AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])], Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodevalid$(special_ref), Heap[null, AVLTreeNodevalid$(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$])]);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] := PermAdd(Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$], perm);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$] := PermAdd(Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], perm);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      perm := Perm(0.500000000, 0.000000000);
      assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
      assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null;
      Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermAdd(Mask[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      assume (forall rk: int ::
        
        Seq#Contains(Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], rk) ==> Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$] < rk
      );
    }
    if (Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null) {
      assume Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    }
    assume Seq#Equal(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], Seq#Append(Seq#Append((if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$])), (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$])));
    assume Seq#Contains(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$]);
    assume (forall kk: int ::
      
      Seq#Contains(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], kk) == ((Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] != null && Seq#Contains(Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodekeys$], kk)) || ((Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] != null && Seq#Contains(Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodekeys$], kk)) || kk == Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekey$]))
    );
    assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] == (if (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) then (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
    assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] == (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$] == null then 0 else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$] == null then 0 else Heap[Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNoderight$], AVLTreeNodeheight$]);
    assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] <= 1;
    assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] >= -1;
    assume Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] > 0;
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r := this$_22.AVLTreeNoderight$ -- AVLTree.sil,1390:3
    
    // -- Check definedness of this$_22.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1390:3) [13970]"}
        this$_22 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1390:3) [13971]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    r_1 := Heap[this$_22, AVLTreeNoderight$];
    assume state(Heap, Mask);
  
  // -- Translating statement: this$_22.AVLTreeNoderight$ := r.AVLTreeNodeleft$ -- AVLTree.sil,1391:3
    
    // -- Check definedness of this$_22.AVLTreeNoderight$
      assert {:msg "  Assignment might fail. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1391:3) [13972]"}
        this$_22 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1391:3) [13973]"}
        HasDirectPerm(Mask, this$_22, AVLTreeNoderight$);
      assume state(Heap, Mask);
    
    // -- Check definedness of r.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1391:3) [13974]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1391:3) [13975]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[this$_22, AVLTreeNoderight$] := Heap[r_1, AVLTreeNodeleft$];
    assert {:msg "  Assignment might fail. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1391:3) [13976]"}
      FullPerm[$frac] == Mask[this$_22, AVLTreeNoderight$][$frac] && FullPerm[$eps] == Mask[this$_22, AVLTreeNoderight$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_37  -- AVLTree.sil,1392:3
    
    // -- Translation of statement fresh newK$_37)
      havoc newK$_37;
      assume (newK$_37[$frac] > 0.000000000 && newK$_37[$frac] < 0.001000000) && newK$_37[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_37) -- AVLTree.sil,1393:3
    
    // -- Translating statement: AVLTreeNodeclose$(this$_22, newK$_37) -- AVLTree.sil,1394:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion this$_22 != null might not hold. (AVLTree.sil,1394:5) [13977]"}
          this$_22 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_37 > none might not hold. (AVLTree.sil,1394:5) [13978]"}
          NoPerm[$frac] < newK$_37[$frac] || (NoPerm[$frac] == newK$_37[$frac] && NoPerm[$eps] < newK$_37[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_37 might not hold. (AVLTree.sil,1394:5) [13979]"}
          newK$_37[$frac] < FullPerm[$frac] || (newK$_37[$frac] == FullPerm[$frac] && newK$_37[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1394:5) [13980]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodekey$ might be null. (AVLTree.sil,1394:5) [13981]"}
          this$_22 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodekey$. (AVLTree.sil,1394:5) [13982]"}
            (perm[$frac] < Mask[this$_22, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[this$_22, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[this$_22, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[this$_22, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[this$_22, AVLTreeNodekey$][$eps]);
        }
        Mask[this$_22, AVLTreeNodekey$] := PermSub(Mask[this$_22, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1394:5) [13983]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodeheight$ might be null. (AVLTree.sil,1394:5) [13984]"}
          this$_22 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodeheight$. (AVLTree.sil,1394:5) [13985]"}
            (perm[$frac] < Mask[this$_22, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[this$_22, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[this$_22, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[this$_22, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[this$_22, AVLTreeNodeheight$][$eps]);
        }
        Mask[this$_22, AVLTreeNodeheight$] := PermSub(Mask[this$_22, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1394:5) [13986]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodeleft$ might be null. (AVLTree.sil,1394:5) [13987]"}
          this$_22 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodeleft$. (AVLTree.sil,1394:5) [13988]"}
            (perm[$frac] < Mask[this$_22, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[this$_22, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[this$_22, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[this$_22, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[this$_22, AVLTreeNodeleft$][$eps]);
        }
        Mask[this$_22, AVLTreeNodeleft$] := PermSub(Mask[this$_22, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1394:5) [13989]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNoderight$ might be null. (AVLTree.sil,1394:5) [13990]"}
          this$_22 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNoderight$. (AVLTree.sil,1394:5) [13991]"}
            (perm[$frac] < Mask[this$_22, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[this$_22, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[this$_22, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[this$_22, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[this$_22, AVLTreeNoderight$][$eps]);
        }
        Mask[this$_22, AVLTreeNoderight$] := PermSub(Mask[this$_22, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1394:5) [13992]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodekeys$ might be null. (AVLTree.sil,1394:5) [13993]"}
          this$_22 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodekeys$. (AVLTree.sil,1394:5) [13994]"}
            (perm[$frac] < Mask[this$_22, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[this$_22, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[this$_22, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[this$_22, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[this$_22, AVLTreeNodekeys$][$eps]);
        }
        Mask[this$_22, AVLTreeNodekeys$] := PermSub(Mask[this$_22, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1394:5) [13995]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1394:5) [13996]"}
          this$_22 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodebalanceFactor$. (AVLTree.sil,1394:5) [13997]"}
            (perm[$frac] < Mask[this$_22, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[this$_22, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[this$_22, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[this$_22, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[this$_22, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[this$_22, AVLTreeNodebalanceFactor$] := PermSub(Mask[this$_22, AVLTreeNodebalanceFactor$], perm);
        if (Heap[this$_22, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_22.AVLTreeNodeleft$). (AVLTree.sil,1394:5) [13998]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNodeleft$])], perm);
        }
        if (Heap[this$_22, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1394:5) [13999]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1394:5) [14000]"}
            Heap[this$_22, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1394:5) [14001]"}
              (perm[$frac] < Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_22, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1394:5) [14002]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1394:5) [14003]"}
            Heap[this$_22, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1394:5) [14004]"}
              (perm[$frac] < Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_22, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1394:5) [14005]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1394:5) [14006]"}
            Heap[this$_22, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1394:5) [14007]"}
              (perm[$frac] < Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_22, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < this$_22.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1394:5) [14008]"}
            (forall k0_2: int ::
            
            Seq#Contains(Heap[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_2) ==> k0_2 < Heap[this$_22, AVLTreeNodekey$]
          );
        }
        if (Heap[this$_22, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(this$_22.AVLTreeNoderight$). (AVLTree.sil,1394:5) [14009]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[this$_22, AVLTreeNoderight$])], perm);
        }
        if (Heap[this$_22, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1394:5) [14010]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1394:5) [14011]"}
            Heap[this$_22, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1394:5) [14012]"}
              (perm[$frac] < Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[this$_22, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1394:5) [14013]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1394:5) [14014]"}
            Heap[this$_22, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1394:5) [14015]"}
              (perm[$frac] < Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[this$_22, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1394:5) [14016]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1394:5) [14017]"}
            Heap[this$_22, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access this$_22.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1394:5) [14018]"}
              (perm[$frac] < Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[this$_22, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in this$_22.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (this$_22.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1394:5) [14019]"}
            (forall k1_2: int ::
            
            Seq#Contains(Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$], k1_2) ==> Heap[this$_22, AVLTreeNodekey$] < k1_2
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_22.AVLTreeNodeleft$ == null ? 0 : this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_22.AVLTreeNoderight$ == null ? 0 : this$_22.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1394:5) [14020]"}
          (if Heap[this$_22, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_22, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (this$_22.AVLTreeNodeleft$ == null ? 0 : this$_22.AVLTreeNodeleft$.AVLTreeNodeheight$) - (this$_22.AVLTreeNoderight$ == null ? 0 : this$_22.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1394:5) [14021]"}
          (if Heap[this$_22, AVLTreeNodeleft$] == null then 0 else Heap[Heap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[this$_22, AVLTreeNoderight$] == null then 0 else Heap[Heap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(this$_22)] := PermAdd(Mask[null, AVLTreeNodevalid$(this$_22)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_22 != null;
        Mask[this$_22, AVLTreeNodeheight$] := PermAdd(Mask[this$_22, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_22 != null;
        Mask[this$_22, AVLTreeNodekeys$] := PermAdd(Mask[this$_22, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume this$_22 != null;
        Mask[this$_22, AVLTreeNodebalanceFactor$] := PermAdd(Mask[this$_22, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[this$_22, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[this$_22, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[this$_22, AVLTreeNodekey$])), (if PreCallHeap[this$_22, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[this$_22, AVLTreeNodeheight$] == (if (if PreCallHeap[this$_22, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[this$_22, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[this$_22, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[this$_22, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[this$_22, AVLTreeNodebalanceFactor$] == (if PreCallHeap[this$_22, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[this$_22, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[this$_22, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_37 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1394:5) [14022]"}
        newK$_37[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: r.AVLTreeNodeleft$ := this$_22 -- AVLTree.sil,1396:3
    
    // -- Check definedness of r.AVLTreeNodeleft$
      assert {:msg "  Assignment might fail. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1396:3) [14023]"}
        r_1 != null;
      assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1396:3) [14024]"}
        HasDirectPerm(Mask, r_1, AVLTreeNodeleft$);
      assume state(Heap, Mask);
    Heap[r_1, AVLTreeNodeleft$] := this$_22;
    assert {:msg "  Assignment might fail. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1396:3) [14025]"}
      FullPerm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && FullPerm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps];
    assume state(Heap, Mask);
  
  // -- Translating statement: fresh newK$_38  -- AVLTree.sil,1397:3
    
    // -- Translation of statement fresh newK$_38)
      havoc newK$_38;
      assume (newK$_38[$frac] > 0.000000000 && newK$_38[$frac] < 0.001000000) && newK$_38[$eps] == 0.000000000;
    assume state(Heap, Mask);
  
  // -- Translating statement: constraining(newK$_38) -- AVLTree.sil,1398:3
    
    // -- Translating statement: AVLTreeNodeclose$(r, newK$_38) -- AVLTree.sil,1399:5
      PreCallHeap := Heap;
      PreCallMask := Mask;
      
      // -- Exhaling precondition
        havoc ExhaleHeap;
        // Phase 1: pure assertions and fixed permissions
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1399:5) [14026]"}
          r_1 != null;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion newK$_38 > none might not hold. (AVLTree.sil,1399:5) [14027]"}
          NoPerm[$frac] < newK$_38[$frac] || (NoPerm[$frac] == newK$_38[$frac] && NoPerm[$eps] < newK$_38[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion write > newK$_38 might not hold. (AVLTree.sil,1399:5) [14028]"}
          newK$_38[$frac] < FullPerm[$frac] || (newK$_38[$frac] == FullPerm[$frac] && newK$_38[$eps] < FullPerm[$eps]);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1399:5) [14029]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekey$ might be null. (AVLTree.sil,1399:5) [14030]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekey$. (AVLTree.sil,1399:5) [14031]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekey$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekey$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekey$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekey$][$eps]);
        }
        Mask[r_1, AVLTreeNodekey$] := PermSub(Mask[r_1, AVLTreeNodekey$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1399:5) [14032]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1399:5) [14033]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1399:5) [14034]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
        }
        Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1399:5) [14035]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$ might be null. (AVLTree.sil,1399:5) [14036]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$. (AVLTree.sil,1399:5) [14037]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodeleft$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeleft$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeleft$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeleft$][$eps]);
        }
        Mask[r_1, AVLTreeNodeleft$] := PermSub(Mask[r_1, AVLTreeNodeleft$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1399:5) [14038]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$ might be null. (AVLTree.sil,1399:5) [14039]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$. (AVLTree.sil,1399:5) [14040]"}
            (perm[$frac] < Mask[r_1, AVLTreeNoderight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNoderight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNoderight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNoderight$][$eps]);
        }
        Mask[r_1, AVLTreeNoderight$] := PermSub(Mask[r_1, AVLTreeNoderight$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1399:5) [14041]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1399:5) [14042]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1399:5) [14043]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
        }
        Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 100 / 100 might not be positive. (AVLTree.sil,1399:5) [14044]"}
          Perm(1.000000000, 0.000000000)[$frac] > 0.000000000 || (Perm(1.000000000, 0.000000000)[$frac] == 0.000000000 && Perm(1.000000000, 0.000000000)[$eps] > 0.000000000);
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1399:5) [14045]"}
          r_1 != null;
        perm := NoPerm;
        perm := PermAdd(perm, Perm(1.000000000, 0.000000000));
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1399:5) [14046]"}
            (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
        }
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNodeleft$). (AVLTree.sil,1399:5) [14047]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNodeleft$])], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1399:5) [14048]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1399:5) [14049]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodeheight$. (AVLTree.sil,1399:5) [14050]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1399:5) [14051]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1399:5) [14052]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodekeys$. (AVLTree.sil,1399:5) [14053]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1399:5) [14054]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1399:5) [14055]"}
            Heap[r_1, AVLTreeNodeleft$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNodeleft$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1399:5) [14056]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNodeleft$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k0: Int :: true && k0 in r.AVLTreeNodeleft$.AVLTreeNodekeys$ ==> (k0 < r.AVLTreeNodekey$)) might not hold. (AVLTree.sil,1399:5) [14057]"}
            (forall k0_3: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$], k0_3) ==> k0_3 < Heap[r_1, AVLTreeNodekey$]
          );
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          perm := NoPerm;
          perm := PermAdd(perm, FullPerm);
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r.AVLTreeNoderight$). (AVLTree.sil,1399:5) [14058]"}
              (perm[$frac] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])][$eps]);
          }
          Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])] := PermSub(Mask[null, AVLTreeNodevalid$(Heap[r_1, AVLTreeNoderight$])], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1399:5) [14059]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodeheight$ might be null. (AVLTree.sil,1399:5) [14060]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodeheight$. (AVLTree.sil,1399:5) [14061]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1399:5) [14062]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodekeys$ might be null. (AVLTree.sil,1399:5) [14063]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodekeys$. (AVLTree.sil,1399:5) [14064]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1399:5) [14065]"}
            Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Receiver of r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1399:5) [14066]"}
            Heap[r_1, AVLTreeNoderight$] != null;
          perm := NoPerm;
          perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. There might be insufficient permission to access r.AVLTreeNoderight$.AVLTreeNodebalanceFactor$. (AVLTree.sil,1399:5) [14067]"}
              (perm[$frac] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$][$eps]);
          }
          Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$] := PermSub(Mask[Heap[r_1, AVLTreeNoderight$], AVLTreeNodebalanceFactor$], perm);
        }
        if (Heap[r_1, AVLTreeNoderight$] != null) {
          assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (forall k1: Int :: true && k1 in r.AVLTreeNoderight$.AVLTreeNodekeys$ ==> (r.AVLTreeNodekey$ < k1)) might not hold. (AVLTree.sil,1399:5) [14068]"}
            (forall k1_3: int ::
            
            Seq#Contains(Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$], k1_3) ==> Heap[r_1, AVLTreeNodekey$] < k1_3
          );
        }
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) <= 1 might not hold. (AVLTree.sil,1399:5) [14069]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) <= 1;
        assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. Assertion (r.AVLTreeNodeleft$ == null ? 0 : r.AVLTreeNodeleft$.AVLTreeNodeheight$) - (r.AVLTreeNoderight$ == null ? 0 : r.AVLTreeNoderight$.AVLTreeNodeheight$) >= 0 - 1 might not hold. (AVLTree.sil,1399:5) [14070]"}
          (if Heap[r_1, AVLTreeNodeleft$] == null then 0 else Heap[Heap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if Heap[r_1, AVLTreeNoderight$] == null then 0 else Heap[Heap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) >= -1;
        // Phase 2: abstract read permissions (and scaled abstract read permissions)
        // Phase 3: all remaining permissions (containing read permissions, but in a negative context)
        // Finish exhale
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
      
      // -- Inhaling postcondition
        perm := FullPerm;
        Mask[null, AVLTreeNodevalid$(r_1)] := PermAdd(Mask[null, AVLTreeNodevalid$(r_1)], perm);
        
        // -- Extra unfolding of predicate
          
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodeheight$] := PermAdd(Mask[r_1, AVLTreeNodeheight$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodekeys$] := PermAdd(Mask[r_1, AVLTreeNodekeys$], perm);
        perm := Perm(0.500000000, 0.000000000);
        assume perm[$frac] > 0.000000000 || (perm[$frac] == 0.000000000 && perm[$eps] > 0.000000000);
        assume r_1 != null;
        Mask[r_1, AVLTreeNodebalanceFactor$] := PermAdd(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
        assume Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if PreCallHeap[r_1, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(PreCallHeap[r_1, AVLTreeNodekey$])), (if PreCallHeap[r_1, AVLTreeNoderight$] == null then (Seq#Empty(): Seq_ int) else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodekeys$])));
        assume Heap[r_1, AVLTreeNodeheight$] == (if (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) > (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) then (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) + 1 else (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]) + 1);
        assume Heap[r_1, AVLTreeNodebalanceFactor$] == (if PreCallHeap[r_1, AVLTreeNodeleft$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNodeleft$], AVLTreeNodeheight$]) - (if PreCallHeap[r_1, AVLTreeNoderight$] == null then 0 else PreCallHeap[PreCallHeap[r_1, AVLTreeNoderight$], AVLTreeNodeheight$]);
        assume state(Heap, Mask);
      assert {:msg "  The precondition of method AVLTreeNodeclose$ might not hold. The parameter newK$_38 might be an epsilon permission, which is not allowed for method parameters. (AVLTree.sil,1399:5) [14071]"}
        newK$_38[$eps] == 0.000000000;
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    havoc ExhaleHeap;
    // Phase 1: pure assertions and fixed permissions
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Assertion r != null might not hold. (AVLTree.sil,1375:11) [14072]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, FullPerm);
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access AVLTreeNodevalid$(r). (AVLTree.sil,1376:11) [14073]"}
        (perm[$frac] < Mask[null, AVLTreeNodevalid$(r_1)][$frac] || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] < Mask[null, AVLTreeNodevalid$(r_1)][$eps])) || (perm[$frac] == Mask[null, AVLTreeNodevalid$(r_1)][$frac] && perm[$eps] == Mask[null, AVLTreeNodevalid$(r_1)][$eps]);
    }
    Mask[null, AVLTreeNodevalid$(r_1)] := PermSub(Mask[null, AVLTreeNodevalid$(r_1)], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1377:11) [14074]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Receiver of r.AVLTreeNodeheight$ might be null. (AVLTree.sil,1377:11) [14075]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access r.AVLTreeNodeheight$. (AVLTree.sil,1377:11) [14076]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodeheight$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodeheight$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodeheight$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodeheight$][$eps]);
    }
    Mask[r_1, AVLTreeNodeheight$] := PermSub(Mask[r_1, AVLTreeNodeheight$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1378:11) [14077]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Receiver of r.AVLTreeNodekeys$ might be null. (AVLTree.sil,1378:11) [14078]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access r.AVLTreeNodekeys$. (AVLTree.sil,1378:11) [14079]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodekeys$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodekeys$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodekeys$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodekeys$][$eps]);
    }
    Mask[r_1, AVLTreeNodekeys$] := PermSub(Mask[r_1, AVLTreeNodekeys$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Fraction 50 / 100 might not be positive. (AVLTree.sil,1379:11) [14080]"}
      Perm(0.500000000, 0.000000000)[$frac] > 0.000000000 || (Perm(0.500000000, 0.000000000)[$frac] == 0.000000000 && Perm(0.500000000, 0.000000000)[$eps] > 0.000000000);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Receiver of r.AVLTreeNodebalanceFactor$ might be null. (AVLTree.sil,1379:11) [14081]"}
      r_1 != null;
    perm := NoPerm;
    perm := PermAdd(perm, Perm(0.500000000, 0.000000000));
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. There might be insufficient permission to access r.AVLTreeNodebalanceFactor$. (AVLTree.sil,1379:11) [14082]"}
        (perm[$frac] < Mask[r_1, AVLTreeNodebalanceFactor$][$frac] || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] < Mask[r_1, AVLTreeNodebalanceFactor$][$eps])) || (perm[$frac] == Mask[r_1, AVLTreeNodebalanceFactor$][$frac] && perm[$eps] == Mask[r_1, AVLTreeNodebalanceFactor$][$eps]);
    }
    Mask[r_1, AVLTreeNodebalanceFactor$] := PermSub(Mask[r_1, AVLTreeNodebalanceFactor$], perm);
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Assertion (r.AVLTreeNodeheight$ == old(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$)) || (r.AVLTreeNodeheight$ == old(this$_22.AVLTreeNoderight$.AVLTreeNodeheight$) + 1) might not hold. (AVLTree.sil,1380:11) [14083]"}
      Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] || Heap[r_1, AVLTreeNodeheight$] == old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodeheight$] + 1;
    assert {:msg "  Postcondition of AVLTreeNoderebalanceLL$ might not hold. Assertion r.AVLTreeNodekeys$ == (old(this$_22.AVLTreeNodeleft$) == null ? Seq() : old(this$_22.AVLTreeNodeleft$.AVLTreeNodekeys$)) ++ Seq(old(this$_22.AVLTreeNodekey$)) ++ old(this$_22.AVLTreeNoderight$.AVLTreeNodekeys$) might not hold. (AVLTree.sil,1381:11) [14084]"}
      Seq#Equal(Heap[r_1, AVLTreeNodekeys$], Seq#Append(Seq#Append((if old(Heap)[this$_22, AVLTreeNodeleft$] == null then (Seq#Empty(): Seq_ int) else old(Heap)[old(Heap)[this$_22, AVLTreeNodeleft$], AVLTreeNodekeys$]), Seq#Singleton(old(Heap)[this$_22, AVLTreeNodekey$])), old(Heap)[old(Heap)[this$_22, AVLTreeNoderight$], AVLTreeNodekeys$]));
    // Finish exhale
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}