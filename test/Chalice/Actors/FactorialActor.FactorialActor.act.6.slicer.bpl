type Integer = int;
type Boolean = bool;
type HeapType = <a>[ref,Field (a)]a;
type MaskType = <a>[ref,Field (a)][PermissionComponent]int;
type CreditsType = [ref]int;
type ArgSeq = <T>[int]T;
type Field m0;
type ref;
type PermissionComponent;
type ModuleName;
type TypeName;
type Mu;
const null : ref;
const unique perm$R : PermissionComponent;
const unique perm$N : PermissionComponent;
const Permission$denominator : int;
const Permission$FullFraction : int;
const Permission$Zero : [PermissionComponent]int;
const Permission$Full : [PermissionComponent]int;
const ZeroMask : MaskType;
const unique joinable : Field (int);
const unique forkK : Field (int);
const channelK : int;
const monitorK : int;
const predicateK : int;
const nostate : HeapType;
const CurrentModule : ModuleName;
const CanAssumeFunctionDefs : bool;
const unique mu : Field (Mu);
const $LockBottom : Mu;
const unique held : Field (int);
const unique rdheld : Field (bool);
const ZeroCredits : CreditsType;
const unique Channel#t : TypeName;
const unique module#default : ModuleName;
const unique FactorialActorChannelExpEP#t : TypeName;
const unique FactorialActorChannelExpEP.state : Field (int);
const unique FactorialActorChannelExpEP.ch : Field (ref);
const unique FactorialActorChannelExpEP.expch : Field (ref);
const unique FactorialActorChannelExpEP.valid : Field (HeapType);
const unique FactorialActorChannelImpEP#t : TypeName;
const unique FactorialActorChannelImpEP.state : Field (int);
const unique FactorialActorChannelImpEP.ch : Field (ref);
const unique FactorialActorChannelImpEP.impch : Field (ref);
const unique FactorialActorChannelImpEP.valid : Field (HeapType);
const unique FactorialActorChannel#t : TypeName;
const unique FactorialActorChannel.imp : Field (ref);
const unique FactorialActorChannel.exp : Field (ref);
const unique FactorialActorChannel.valid : Field (HeapType);
const unique FactorialActorChannel.initImpState : Field (HeapType);
const unique FactorialActorChannel.initExpState : Field (HeapType);
const unique FactorialContChannelExpEP#t : TypeName;
const unique FactorialContChannelExpEP.state : Field (int);
const unique FactorialContChannelExpEP.ch : Field (ref);
const unique FactorialContChannelExpEP.expch : Field (ref);
const unique FactorialContChannelExpEP.valid : Field (HeapType);
const unique FactorialContChannelImpEP#t : TypeName;
const unique FactorialContChannelImpEP.state : Field (int);
const unique FactorialContChannelImpEP.ch : Field (ref);
const unique FactorialContChannelImpEP.impch : Field (ref);
const unique FactorialContChannelImpEP.valid : Field (HeapType);
const unique FactorialContChannel#t : TypeName;
const unique FactorialContChannel.imp : Field (ref);
const unique FactorialContChannel.exp : Field (ref);
const unique FactorialContChannel.valid : Field (HeapType);
const unique FactorialContChannel.initImpState : Field (HeapType);
const unique FactorialContChannel.initExpState : Field (HeapType);
const unique FutureChannelExpEP#t : TypeName;
const unique FutureChannelExpEP.state : Field (int);
const unique FutureChannelExpEP.ch : Field (ref);
const unique FutureChannelExpEP.expch : Field (ref);
const unique FutureChannelExpEP.valid : Field (HeapType);
const unique FutureChannelImpEP#t : TypeName;
const unique FutureChannelImpEP.state : Field (int);
const unique FutureChannelImpEP.ch : Field (ref);
const unique FutureChannelImpEP.impch : Field (ref);
const unique FutureChannelImpEP.valid : Field (HeapType);
const unique FutureChannel#t : TypeName;
const unique FutureChannel.imp : Field (ref);
const unique FutureChannel.exp : Field (ref);
const unique FutureChannel.valid : Field (HeapType);
const unique FutureChannel.initImpState : Field (HeapType);
const unique FutureChannel.initExpState : Field (HeapType);
const unique Future#t : TypeName;
const unique Future.sent : Field (ref);
const unique Future.value : Field (ref);
const unique Future.q : Field (ref);
const unique Message#t : TypeName;
const unique Message.type : Field (int);
const unique Message.sender1 : Field (ref);
const unique Message.sender3 : Field (ref);
const unique Message.sender2 : Field (ref);
const unique Message.sender4 : Field (ref);
const unique Message.receiver1 : Field (ref);
const unique Message.receiver2 : Field (ref);
const unique Message.receiver3 : Field (ref);
const unique Message.receiver4 : Field (ref);
const unique Message.v1 : Field (int);
const unique Message.vo1 : Field (int);
const unique Message.cust1 : Field (ref);
const unique Message.vr1 : Field (int);
const unique Message.old1 : Field (ref);
const unique Message.vr2 : Field (int);
const unique Message.old2 : Field (ref);
const unique Message.vr3 : Field (int);
const unique Message.invValue : Field (HeapType);
const unique Message.invResult1 : Field (HeapType);
const unique Message.invResult2 : Field (HeapType);
const unique Message.invFinalResult : Field (HeapType);
const unique Message.inv : Field (HeapType);
const unique FactorialActor#t : TypeName;
const unique FactorialActor.q : Field (ref);
const unique FactorialCont#t : TypeName;
const unique FactorialCont.q : Field (ref);
const unique FactorialCont.v : Field (int);
const unique FactorialCont.vo : Field (int);
const unique FactorialCont.cust : Field (ref);
function Fractions(int) : int;
function IsGoodState <T> (T) : bool;
function combine <T,U> (T,U) : T;
function dtype(ref) : TypeName;
function MuBelow(Mu,Mu) : bool;
function wf(HeapType,MaskType) : bool;
function IsGoodInhaleState(HeapType,HeapType,MaskType) : bool;
function {:expand  false} CanRead <T> (MaskType,ref,Field (T)) : bool;
function {:expand  false} CanWrite <T> (MaskType,ref,Field (T)) : bool;
function {:expand  true} IsGoodMask(MaskType) : bool;
function DecPerm <T> (MaskType,ref,Field (T),int) : MaskType;
function IncPerm <T> (MaskType,ref,Field (T),int) : MaskType;
function NonPredicateField <T> (Field (T)) : bool;
function PredicateField <T> (Field (T)) : bool;
function ite <T> (bool,T,T) : T;
function #Future.getQ(HeapType,MaskType,ref) : ref;
function ##Future.getQ(HeapType,ref) : ref;
function #Message.factorial(HeapType,MaskType,ref,int) : int;
function #Message.factorial#limited(HeapType,MaskType,ref,int) : int;
function ##Message.factorial(HeapType,ref,int) : int;
function #FactorialActor.getQ(HeapType,MaskType,ref) : ref;
function ##FactorialActor.getQ(HeapType,ref) : ref;
function #FactorialCont.getQ(HeapType,MaskType,ref) : ref;
function ##FactorialCont.getQ(HeapType,ref) : ref;
var Heap : HeapType;
var Mask : MaskType;
var Credits : CreditsType;
var current#67 : ref;
var this#127 : ref;
var msg#128 : ref;
var this#129 : ref;
var mi#130 : ref;
var mo#131 : ref;
var m#69 : ref;
var this#132 : ref;
var receiver#134 : ref;
var this#135 : ref;
var m#136 : ref;
var m#71 : ref;
var this#137 : ref;
var oldv#139 : ref;
var receiver#140 : ref;
var this#141 : ref;
var m#142 : ref;
var r#73 : ref;
var cont#75 : ref;
var this#143 : ref;
var custp#146 : ref;
var this#147 : ref;
var m#77 : ref;
var this#148 : ref;
var cust#151 : ref;
var receiver#152 : ref;
var this#153 : ref;
var m#154 : ref;
var r#79 : ref;
var methodK#_1151 : int;
var inhaleHeap#_1153_$_0 : HeapType;
var Heap_$_0 : HeapType;
var Mask_$_0 : MaskType;
var Heap_$_1 : HeapType;
var Mask_$_1 : MaskType;
var Heap_$_2 : HeapType;
var Mask_$_2 : MaskType;
var Heap_$_3 : HeapType;
var Mask_$_3 : MaskType;
var Heap_$_4 : HeapType;
var Mask_$_4 : MaskType;
var Heap_$_5 : HeapType;
var Mask_$_5 : MaskType;
var Credits_$_0 : CreditsType;
var unfoldK#_1154 : int;
var exhaleMask#_1155_$_0 : MaskType;
var inhaleHeap#_1157_$_0 : HeapType;
var Heap_$_6 : HeapType;
var Mask_$_6 : MaskType;
var Heap_$_7 : HeapType;
var Mask_$_7 : MaskType;
var Heap_$_8 : HeapType;
var Mask_$_8 : MaskType;
var Heap_$_9 : HeapType;
var Mask_$_9 : MaskType;
var Heap_$_10 : HeapType;
var Mask_$_10 : MaskType;
var Heap_$_11 : HeapType;
var Mask_$_11 : MaskType;
var unfoldK#_1158 : int;
var exhaleMask#_1159_$_0 : MaskType;
var inhaleHeap#_1161_$_0 : HeapType;
var Heap_$_12 : HeapType;
var Mask_$_12 : MaskType;
var Heap_$_13 : HeapType;
var Mask_$_13 : MaskType;
var Heap_$_14 : HeapType;
var Mask_$_14 : MaskType;
var Heap_$_15 : HeapType;
var Mask_$_15 : MaskType;
var Heap_$_16 : HeapType;
var Mask_$_16 : MaskType;
var Heap_$_17 : HeapType;
var Mask_$_17 : MaskType;
var Heap_$_18 : HeapType;
var Mask_$_18 : MaskType;
var Heap_$_19 : HeapType;
var Mask_$_19 : MaskType;
var unfoldK#_1162 : int;
var exhaleMask#_1163_$_0 : MaskType;
var inhaleHeap#_1165_$_0 : HeapType;
var Heap_$_20 : HeapType;
var Mask_$_20 : MaskType;
var Heap_$_21 : HeapType;
var Mask_$_21 : MaskType;
var unfoldK#_1166 : int;
var exhaleMask#_1167_$_0 : MaskType;
var inhaleHeap#_1169_$_0 : HeapType;
var Heap_$_22 : HeapType;
var Mask_$_22 : MaskType;
var Heap_$_23 : HeapType;
var Mask_$_23 : MaskType;
var whileK#_1176 : int;
var Credits_$_1 : CreditsType;
var exhaleMask#_1177_$_0 : MaskType;
var exhaleMask#_1177_$_1 : MaskType;
var exhaleMask#_1177_$_2 : MaskType;
var exhaleMask#_1177_$_3 : MaskType;
var exhaleMask#_1177_$_4 : MaskType;
var exhaleMask#_1177_$_5 : MaskType;
var exhaleMask#_1177_$_6 : MaskType;
var exhaleMask#_1177_$_7 : MaskType;
var exhaleMask#_1177_$_8 : MaskType;
var inhaleHeap#_1434_$_0 : HeapType;
var Heap_$_46 : HeapType;
var Mask_$_44 : MaskType;
var Heap_$_47 : HeapType;
var Mask_$_45 : MaskType;
var Heap_$_48 : HeapType;
var Mask_$_46 : MaskType;
var Heap_$_49 : HeapType;
var Mask_$_47 : MaskType;
var Heap_$_50 : HeapType;
var Mask_$_48 : MaskType;
var Heap_$_51 : HeapType;
var Mask_$_49 : MaskType;
var Heap_$_52 : HeapType;
var Mask_$_50 : MaskType;
var Heap_$_53 : HeapType;
var Mask_$_51 : MaskType;
var Heap_$_54 : HeapType;
var Mask_$_52 : MaskType;
var Credits_$_5 : CreditsType;
var inhaleHeap#_1189_$_0 : HeapType;
var Heap_$_34 : HeapType;
var Heap_$_35 : HeapType;
var Mask_$_33 : MaskType;
var Heap_$_36 : HeapType;
var Mask_$_34 : MaskType;
var Heap_$_37 : HeapType;
var Mask_$_35 : MaskType;
var Heap_$_38 : HeapType;
var Mask_$_36 : MaskType;
var Heap_$_39 : HeapType;
var Mask_$_37 : MaskType;
var Heap_$_40 : HeapType;
var Mask_$_38 : MaskType;
var Heap_$_41 : HeapType;
var Mask_$_39 : MaskType;
var Heap_$_42 : HeapType;
var Mask_$_40 : MaskType;
var Heap_$_43 : HeapType;
var Mask_$_41 : MaskType;
var Credits_$_3 : CreditsType;
var this#127_$_0 : ref;
var msg#128_$_0 : ref;
var inhaleHeap#_1192_$_0 : HeapType;
var Heap_$_44 : HeapType;
var Mask_$_42 : MaskType;
var Heap_$_45 : HeapType;
var Mask_$_43 : MaskType;
var Credits_$_4 : CreditsType;
var Mask_$_221 : MaskType;
var Credits_$_7 : CreditsType;
var Heap_$_134 : HeapType;
var Credits_$_8 : CreditsType;
var exhaleMask#_1420_$_0 : MaskType;
var exhaleMask#_1420_$_1 : MaskType;
var exhaleMask#_1420_$_2 : MaskType;
var exhaleMask#_1420_$_3 : MaskType;
var exhaleMask#_1420_$_4 : MaskType;
var exhaleMask#_1420_$_5 : MaskType;
var exhaleMask#_1420_$_6 : MaskType;
var exhaleMask#_1420_$_7 : MaskType;
var exhaleMask#_1420_$_8 : MaskType;
var methodCallK#_1196 : int;
var this#129_$_0 : ref;
var exhaleMask#_1197_$_0 : MaskType;
var exhaleMask#_1197_$_1 : MaskType;
var exhaleMask#_1197_$_2 : MaskType;
var mo#131_$_0 : ref;
var inhaleHeap#_1203_$_0 : HeapType;
var Heap_$_55 : HeapType;
var Mask_$_53 : MaskType;
var Heap_$_56 : HeapType;
var Mask_$_54 : MaskType;
var Heap_$_57 : HeapType;
var Mask_$_55 : MaskType;
var unfoldK#_1204 : int;
var exhaleMask#_1205_$_0 : MaskType;
var inhaleHeap#_1207_$_0 : HeapType;
var Heap_$_58 : HeapType;
var Mask_$_56 : MaskType;
var Heap_$_59 : HeapType;
var Mask_$_57 : MaskType;
var Heap_$_60 : HeapType;
var Mask_$_58 : MaskType;
var Heap_$_61 : HeapType;
var Mask_$_59 : MaskType;
var Heap_$_62 : HeapType;
var Mask_$_60 : MaskType;
var Heap_$_63 : HeapType;
var Mask_$_61 : MaskType;
var Heap_$_64 : HeapType;
var Mask_$_62 : MaskType;
var Heap_$_65 : HeapType;
var Mask_$_63 : MaskType;
var Mask_$_71 : MaskType;
var Heap_$_73 : HeapType;
var nw#_1321_$_0 : ref;
var Mask_$_72 : MaskType;
var Mask_$_73 : MaskType;
var Mask_$_74 : MaskType;
var Mask_$_75 : MaskType;
var Mask_$_76 : MaskType;
var methodCallK#_1325 : int;
var vp#144_$_0 : int;
var vop#145_$_0 : int;
var custp#146_$_0 : ref;
var exhaleMask#_1326_$_0 : MaskType;
var exhaleMask#_1326_$_1 : MaskType;
var exhaleMask#_1326_$_2 : MaskType;
var exhaleMask#_1326_$_3 : MaskType;
var exhaleMask#_1326_$_8 : MaskType;
var inhaleHeap#_1337_$_0 : HeapType;
var Heap_$_74 : HeapType;
var Mask_$_77 : MaskType;
var Heap_$_75 : HeapType;
var Mask_$_78 : MaskType;
var Heap_$_76 : HeapType;
var Mask_$_79 : MaskType;
var Heap_$_77 : HeapType;
var Mask_$_80 : MaskType;
var Heap_$_78 : HeapType;
var Mask_$_81 : MaskType;
var Heap_$_79 : HeapType;
var Mask_$_82 : MaskType;
var Heap_$_80 : HeapType;
var Mask_$_83 : MaskType;
var Heap_$_81 : HeapType;
var Mask_$_84 : MaskType;
var Heap_$_82 : HeapType;
var Mask_$_85 : MaskType;
var Heap_$_83 : HeapType;
var Mask_$_86 : MaskType;
var Heap_$_84 : HeapType;
var Mask_$_87 : MaskType;
var Heap_$_85 : HeapType;
var Mask_$_88 : MaskType;
var Heap_$_86 : HeapType;
var Mask_$_89 : MaskType;
var Heap_$_87 : HeapType;
var Mask_$_90 : MaskType;
var Heap_$_92 : HeapType;
var Mask_$_95 : MaskType;
var asyncMethodCallK#_1344 : int;
var argsSeq#_1343_$_0 : ArgSeq;
var argsSeq#_1343 : ArgSeq;
var Credits_$_6 : CreditsType;
var exhaleMask#_1345_$_0 : MaskType;
var exhaleMask#_1345_$_1 : MaskType;
var exhaleMask#_1345_$_2 : MaskType;
var exhaleMask#_1345_$_3 : MaskType;
var exhaleMask#_1345_$_4 : MaskType;
var exhaleMask#_1345_$_5 : MaskType;
var exhaleMask#_1345_$_6 : MaskType;
var exhaleMask#_1345_$_7 : MaskType;
var exhaleMask#_1345_$_12 : MaskType;
var token#_1338_$_0 : ref;
var Mask_$_96 : MaskType;
var asyncstate#_1339_$_0 : int;
var Heap_$_93 : HeapType;
var Heap_$_94 : HeapType;
var nw#_1358_$_0 : ref;
var Mask_$_97 : MaskType;
var Mask_$_98 : MaskType;
var Mask_$_99 : MaskType;
var Mask_$_100 : MaskType;
var Mask_$_101 : MaskType;
var Mask_$_102 : MaskType;
var Mask_$_103 : MaskType;
var Mask_$_104 : MaskType;
var Mask_$_105 : MaskType;
var Mask_$_106 : MaskType;
var Mask_$_107 : MaskType;
var Mask_$_108 : MaskType;
var Mask_$_109 : MaskType;
var Mask_$_110 : MaskType;
var Mask_$_111 : MaskType;
var Mask_$_112 : MaskType;
var Mask_$_113 : MaskType;
var Mask_$_114 : MaskType;
var Heap_$_95 : HeapType;
var methodCallK#_1362 : int;
var v#149_$_0 : int;
var vo#150_$_0 : int;
var exhaleMask#_1363_$_0 : MaskType;
var exhaleMask#_1363_$_1 : MaskType;
var exhaleMask#_1363_$_2 : MaskType;
var exhaleMask#_1363_$_3 : MaskType;
var exhaleMask#_1363_$_4 : MaskType;
var exhaleMask#_1363_$_5 : MaskType;
var exhaleMask#_1363_$_6 : MaskType;
var exhaleMask#_1363_$_7 : MaskType;
var exhaleMask#_1363_$_8 : MaskType;
var exhaleMask#_1363_$_16 : MaskType;
var inhaleHeap#_1382_$_0 : HeapType;
var Heap_$_96 : HeapType;
var Mask_$_115 : MaskType;
var Heap_$_97 : HeapType;
var Mask_$_116 : MaskType;
var Heap_$_98 : HeapType;
var Mask_$_117 : MaskType;
var Heap_$_99 : HeapType;
var Mask_$_118 : MaskType;
var methodCallK#_1386 : int;
var this#153_$_0 : ref;
var exhaleMask#_1387_$_0 : MaskType;
var exhaleMask#_1387_$_1 : MaskType;
var exhaleMask#_1387_$_2 : MaskType;
var exhaleMask#_1387_$_3 : MaskType;
var exhaleMask#_1387_$_4 : MaskType;
var inhaleHeap#_1395_$_0 : HeapType;
var Heap_$_100 : HeapType;
var Mask_$_119 : MaskType;
var Heap_$_101 : HeapType;
var Mask_$_120 : MaskType;
var nw#_1396_$_0 : ref;
var Mask_$_121 : MaskType;
var Mask_$_122 : MaskType;
var Mask_$_123 : MaskType;
var Mask_$_124 : MaskType;
var Mask_$_125 : MaskType;
var Mask_$_126 : MaskType;
var Mask_$_127 : MaskType;
var Mask_$_128 : MaskType;
var Mask_$_129 : MaskType;
var Mask_$_130 : MaskType;
var Mask_$_131 : MaskType;
var Mask_$_132 : MaskType;
var Mask_$_133 : MaskType;
var Mask_$_134 : MaskType;
var Mask_$_135 : MaskType;
var Mask_$_136 : MaskType;
var Mask_$_137 : MaskType;
var Mask_$_138 : MaskType;
var Heap_$_102 : HeapType;
var funcappK#_1410 : int;
var funcappK#_1418 : int;
var exhaleMask#_1363_$_9 : MaskType;
var exhaleMask#_1363_$_10 : MaskType;
var exhaleMask#_1363_$_11 : MaskType;
var exhaleMask#_1363_$_12 : MaskType;
var exhaleMask#_1363_$_13 : MaskType;
var exhaleMask#_1363_$_14 : MaskType;
var exhaleMask#_1363_$_15 : MaskType;
var exhaleMask#_1345_$_8 : MaskType;
var exhaleMask#_1345_$_9 : MaskType;
var exhaleMask#_1345_$_10 : MaskType;
var exhaleMask#_1345_$_11 : MaskType;
var Heap_$_88 : HeapType;
var Mask_$_91 : MaskType;
var Heap_$_89 : HeapType;
var Mask_$_92 : MaskType;
var Heap_$_90 : HeapType;
var Mask_$_93 : MaskType;
var Heap_$_91 : HeapType;
var Mask_$_94 : MaskType;
var exhaleMask#_1326_$_4 : MaskType;
var exhaleMask#_1326_$_5 : MaskType;
var exhaleMask#_1326_$_6 : MaskType;
var exhaleMask#_1326_$_7 : MaskType;
var nw#_1258_$_0 : ref;
var Mask_$_157 : MaskType;
var Mask_$_158 : MaskType;
var Mask_$_159 : MaskType;
var Mask_$_160 : MaskType;
var Mask_$_161 : MaskType;
var Mask_$_162 : MaskType;
var Mask_$_163 : MaskType;
var Mask_$_164 : MaskType;
var Mask_$_165 : MaskType;
var Mask_$_166 : MaskType;
var Mask_$_167 : MaskType;
var Mask_$_168 : MaskType;
var Mask_$_169 : MaskType;
var Mask_$_170 : MaskType;
var Mask_$_171 : MaskType;
var Mask_$_172 : MaskType;
var Mask_$_173 : MaskType;
var Mask_$_174 : MaskType;
var Heap_$_104 : HeapType;
var methodCallK#_1262 : int;
var receiver#140_$_0 : ref;
var exhaleMask#_1263_$_0 : MaskType;
var exhaleMask#_1263_$_1 : MaskType;
var exhaleMask#_1263_$_2 : MaskType;
var exhaleMask#_1263_$_3 : MaskType;
var exhaleMask#_1263_$_4 : MaskType;
var exhaleMask#_1263_$_5 : MaskType;
var exhaleMask#_1263_$_6 : MaskType;
var exhaleMask#_1263_$_7 : MaskType;
var exhaleMask#_1263_$_8 : MaskType;
var inhaleHeap#_1275_$_0 : HeapType;
var Heap_$_105 : HeapType;
var Mask_$_175 : MaskType;
var Heap_$_106 : HeapType;
var Mask_$_176 : MaskType;
var Heap_$_107 : HeapType;
var Mask_$_177 : MaskType;
var Heap_$_108 : HeapType;
var Mask_$_178 : MaskType;
var unfoldK#_1276 : int;
var exhaleMask#_1277_$_0 : MaskType;
var inhaleHeap#_1279_$_0 : HeapType;
var Heap_$_109 : HeapType;
var Mask_$_179 : MaskType;
var Heap_$_110 : HeapType;
var Mask_$_180 : MaskType;
var Heap_$_111 : HeapType;
var Mask_$_181 : MaskType;
var Heap_$_112 : HeapType;
var Mask_$_182 : MaskType;
var Heap_$_113 : HeapType;
var Mask_$_183 : MaskType;
var Heap_$_114 : HeapType;
var Mask_$_184 : MaskType;
var unfoldK#_1280 : int;
var exhaleMask#_1281_$_0 : MaskType;
var inhaleHeap#_1283_$_0 : HeapType;
var Heap_$_115 : HeapType;
var Mask_$_185 : MaskType;
var Heap_$_116 : HeapType;
var Mask_$_186 : MaskType;
var methodCallK#_1287 : int;
var this#141_$_0 : ref;
var exhaleMask#_1288_$_0 : MaskType;
var exhaleMask#_1288_$_1 : MaskType;
var exhaleMask#_1288_$_2 : MaskType;
var exhaleMask#_1288_$_3 : MaskType;
var exhaleMask#_1288_$_4 : MaskType;
var inhaleHeap#_1296_$_0 : HeapType;
var Heap_$_117 : HeapType;
var Mask_$_187 : MaskType;
var Heap_$_118 : HeapType;
var Mask_$_188 : MaskType;
var nw#_1297_$_0 : ref;
var Mask_$_189 : MaskType;
var Mask_$_190 : MaskType;
var Mask_$_191 : MaskType;
var Mask_$_192 : MaskType;
var Mask_$_193 : MaskType;
var Mask_$_194 : MaskType;
var Mask_$_195 : MaskType;
var Mask_$_196 : MaskType;
var Mask_$_197 : MaskType;
var Mask_$_198 : MaskType;
var Mask_$_199 : MaskType;
var Mask_$_200 : MaskType;
var Mask_$_201 : MaskType;
var Mask_$_202 : MaskType;
var Mask_$_203 : MaskType;
var Mask_$_204 : MaskType;
var Mask_$_205 : MaskType;
var Mask_$_206 : MaskType;
var Heap_$_119 : HeapType;
var funcappK#_1311 : int;
var funcappK#_1319 : int;
var nw#_1208_$_0 : ref;
var Mask_$_139 : MaskType;
var Mask_$_140 : MaskType;
var Mask_$_141 : MaskType;
var Mask_$_142 : MaskType;
var Mask_$_143 : MaskType;
var Mask_$_144 : MaskType;
var Mask_$_145 : MaskType;
var Mask_$_146 : MaskType;
var Mask_$_147 : MaskType;
var Mask_$_148 : MaskType;
var Mask_$_149 : MaskType;
var Mask_$_150 : MaskType;
var Mask_$_151 : MaskType;
var Mask_$_152 : MaskType;
var Mask_$_153 : MaskType;
var Mask_$_154 : MaskType;
var Mask_$_155 : MaskType;
var Mask_$_156 : MaskType;
var Heap_$_103 : HeapType;
var methodCallK#_1212 : int;
var receiver#134_$_0 : ref;
var exhaleMask#_1213_$_0 : MaskType;
var exhaleMask#_1213_$_1 : MaskType;
var exhaleMask#_1213_$_2 : MaskType;
var exhaleMask#_1213_$_3 : MaskType;
var exhaleMask#_1213_$_5 : MaskType;
var inhaleHeap#_1221_$_0 : HeapType;
var Heap_$_120 : HeapType;
var Mask_$_207 : MaskType;
var Heap_$_121 : HeapType;
var Mask_$_208 : MaskType;
var Heap_$_122 : HeapType;
var Mask_$_209 : MaskType;
var Heap_$_123 : HeapType;
var Mask_$_210 : MaskType;
var funcappK#_1235 : int;
var unfoldK#_1237 : int;
var exhaleMask#_1238_$_0 : MaskType;
var inhaleHeap#_1240_$_0 : HeapType;
var Heap_$_124 : HeapType;
var Mask_$_211 : MaskType;
var Heap_$_125 : HeapType;
var Mask_$_212 : MaskType;
var Heap_$_126 : HeapType;
var Mask_$_213 : MaskType;
var Heap_$_127 : HeapType;
var Mask_$_214 : MaskType;
var Heap_$_128 : HeapType;
var Mask_$_215 : MaskType;
var Heap_$_129 : HeapType;
var Mask_$_216 : MaskType;
var unfoldK#_1241 : int;
var exhaleMask#_1242_$_0 : MaskType;
var inhaleHeap#_1244_$_0 : HeapType;
var Heap_$_130 : HeapType;
var Mask_$_217 : MaskType;
var Heap_$_131 : HeapType;
var Mask_$_218 : MaskType;
var methodCallK#_1248 : int;
var this#135_$_0 : ref;
var exhaleMask#_1249_$_0 : MaskType;
var exhaleMask#_1249_$_1 : MaskType;
var exhaleMask#_1249_$_2 : MaskType;
var exhaleMask#_1249_$_3 : MaskType;
var exhaleMask#_1249_$_4 : MaskType;
var inhaleHeap#_1257_$_0 : HeapType;
var Heap_$_132 : HeapType;
var Mask_$_219 : MaskType;
var Heap_$_133 : HeapType;
var Mask_$_220 : MaskType;
var exhaleMask#_1213_$_4 : MaskType;
var Heap_$_66 : HeapType;
var Mask_$_64 : MaskType;
var Heap_$_67 : HeapType;
var Mask_$_65 : MaskType;
var Heap_$_68 : HeapType;
var Mask_$_66 : MaskType;
var Heap_$_69 : HeapType;
var Mask_$_67 : MaskType;
var Heap_$_70 : HeapType;
var Mask_$_68 : MaskType;
var Heap_$_71 : HeapType;
var Mask_$_69 : MaskType;
var Heap_$_72 : HeapType;
var Mask_$_70 : MaskType;
var inhaleHeap#_1188_$_0 : HeapType;
var Heap_$_24 : HeapType;
var Heap_$_25 : HeapType;
var Mask_$_24 : MaskType;
var Heap_$_26 : HeapType;
var Mask_$_25 : MaskType;
var Heap_$_27 : HeapType;
var Mask_$_26 : MaskType;
var Heap_$_28 : HeapType;
var Mask_$_27 : MaskType;
var Heap_$_29 : HeapType;
var Mask_$_28 : MaskType;
var Heap_$_30 : HeapType;
var Mask_$_29 : MaskType;
var Heap_$_31 : HeapType;
var Mask_$_30 : MaskType;
var Heap_$_32 : HeapType;
var Mask_$_31 : MaskType;
var Heap_$_33 : HeapType;
var Mask_$_32 : MaskType;
var Credits_$_2 : CreditsType;
var inhaleHeap#_1153 : HeapType;
var exhaleMask#_1155 : MaskType;
var inhaleHeap#_1157 : HeapType;
var exhaleMask#_1159 : MaskType;
var inhaleHeap#_1161 : HeapType;
var exhaleMask#_1163 : MaskType;
var inhaleHeap#_1165 : HeapType;
var exhaleMask#_1167 : MaskType;
var inhaleHeap#_1169 : HeapType;
var whileHeap#_1170 : HeapType;
var whileMask#_1171 : MaskType;
var whileCredits#_1172 : CreditsType;
var exhaleMask#_1177 : MaskType;
var inhaleHeap#_1188 : HeapType;
var inhaleHeap#_1189 : HeapType;
var iterStartHeap#_1173 : HeapType;
var iterStartMask#_1174 : MaskType;
var iterStartCredits#_1175 : CreditsType;
var inhaleHeap#_1192 : HeapType;
var callHeap#_1193 : HeapType;
var callMask#_1194 : MaskType;
var callCredits#_1195 : CreditsType;
var exhaleMask#_1197 : MaskType;
var inhaleHeap#_1203 : HeapType;
var exhaleMask#_1205 : MaskType;
var inhaleHeap#_1207 : HeapType;
var nw#_1208 : ref;
var vr#133 : int;
var callHeap#_1209 : HeapType;
var callMask#_1210 : MaskType;
var callCredits#_1211 : CreditsType;
var exhaleMask#_1213 : MaskType;
var inhaleHeap#_1221 : HeapType;
var Heap#_1225 : HeapType;
var Mask#_1226 : MaskType;
var Credits#_1227 : CreditsType;
var exhaleMask#_1228 : MaskType;
var Heap#_1232 : HeapType;
var Mask#_1233 : MaskType;
var Credits#_1234 : CreditsType;
var exhaleMask#_1236 : MaskType;
var exhaleMask#_1238 : MaskType;
var inhaleHeap#_1240 : HeapType;
var exhaleMask#_1242 : MaskType;
var inhaleHeap#_1244 : HeapType;
var callHeap#_1245 : HeapType;
var callMask#_1246 : MaskType;
var callCredits#_1247 : CreditsType;
var exhaleMask#_1249 : MaskType;
var inhaleHeap#_1257 : HeapType;
var nw#_1258 : ref;
var v#138 : int;
var callHeap#_1259 : HeapType;
var callMask#_1260 : MaskType;
var callCredits#_1261 : CreditsType;
var exhaleMask#_1263 : MaskType;
var inhaleHeap#_1275 : HeapType;
var exhaleMask#_1277 : MaskType;
var inhaleHeap#_1279 : HeapType;
var exhaleMask#_1281 : MaskType;
var inhaleHeap#_1283 : HeapType;
var callHeap#_1284 : HeapType;
var callMask#_1285 : MaskType;
var callCredits#_1286 : CreditsType;
var exhaleMask#_1288 : MaskType;
var inhaleHeap#_1296 : HeapType;
var nw#_1297 : ref;
var Heap#_1301 : HeapType;
var Mask#_1302 : MaskType;
var Credits#_1303 : CreditsType;
var exhaleMask#_1304 : MaskType;
var Heap#_1308 : HeapType;
var Mask#_1309 : MaskType;
var Credits#_1310 : CreditsType;
var exhaleMask#_1312 : MaskType;
var Heap#_1316 : HeapType;
var Mask#_1317 : MaskType;
var Credits#_1318 : CreditsType;
var exhaleMask#_1320 : MaskType;
var nw#_1321 : ref;
var vp#144 : int;
var vop#145 : int;
var callHeap#_1322 : HeapType;
var callMask#_1323 : MaskType;
var callCredits#_1324 : CreditsType;
var exhaleMask#_1326 : MaskType;
var inhaleHeap#_1337 : HeapType;
var preCallHeap#_1340 : HeapType;
var preCallMask#_1341 : MaskType;
var preCallCredits#_1342 : CreditsType;
var exhaleMask#_1345 : MaskType;
var token#_1338 : ref;
var asyncstate#_1339 : int;
var nw#_1358 : ref;
var v#149 : int;
var vo#150 : int;
var callHeap#_1359 : HeapType;
var callMask#_1360 : MaskType;
var callCredits#_1361 : CreditsType;
var exhaleMask#_1363 : MaskType;
var inhaleHeap#_1382 : HeapType;
var callHeap#_1383 : HeapType;
var callMask#_1384 : MaskType;
var callCredits#_1385 : CreditsType;
var exhaleMask#_1387 : MaskType;
var inhaleHeap#_1395 : HeapType;
var nw#_1396 : ref;
var Heap#_1400 : HeapType;
var Mask#_1401 : MaskType;
var Credits#_1402 : CreditsType;
var exhaleMask#_1403 : MaskType;
var Heap#_1407 : HeapType;
var Mask#_1408 : MaskType;
var Credits#_1409 : CreditsType;
var exhaleMask#_1411 : MaskType;
var Heap#_1415 : HeapType;
var Mask#_1416 : MaskType;
var Credits#_1417 : CreditsType;
var exhaleMask#_1419 : MaskType;
var exhaleMask#_1420 : MaskType;
var inhaleHeap#_1434 : HeapType;
procedure FactorialActor.act (this : ref)
{
	var methodK#_1151 : int;
	var unfoldK#_1154 : int;
	var unfoldK#_1158 : int;
	var unfoldK#_1162 : int;
	var unfoldK#_1166 : int;
	var whileK#_1176 : int;
	var current#67 : ref;
	var this#127 : ref;
	var msg#128 : ref;
	var methodCallK#_1196 : int;
	var this#129 : ref;
	var mi#130 : ref;
	var mo#131 : ref;
	var unfoldK#_1204 : int;
	var m#69 : ref;
	var methodCallK#_1212 : int;
	var this#132 : ref;
	var receiver#134 : ref;
	var funcappK#_1235 : int;
	var unfoldK#_1237 : int;
	var unfoldK#_1241 : int;
	var methodCallK#_1248 : int;
	var this#135 : ref;
	var m#136 : ref;
	var m#71 : ref;
	var methodCallK#_1262 : int;
	var this#137 : ref;
	var oldv#139 : ref;
	var receiver#140 : ref;
	var unfoldK#_1276 : int;
	var unfoldK#_1280 : int;
	var methodCallK#_1287 : int;
	var this#141 : ref;
	var m#142 : ref;
	var r#73 : ref;
	var funcappK#_1311 : int;
	var funcappK#_1319 : int;
	var cont#75 : ref;
	var methodCallK#_1325 : int;
	var this#143 : ref;
	var custp#146 : ref;
	var asyncMethodCallK#_1344 : int;
	var argsSeq#_1343 : ArgSeq;
	var this#147 : ref;
	var m#77 : ref;
	var methodCallK#_1362 : int;
	var this#148 : ref;
	var cust#151 : ref;
	var receiver#152 : ref;
	var methodCallK#_1386 : int;
	var this#153 : ref;
	var m#154 : ref;
	var r#79 : ref;
	var funcappK#_1410 : int;
	var funcappK#_1418 : int;
	var inhaleHeap#_1153_$_0 : HeapType;
	var Heap_$_0 : HeapType;
	var Mask_$_0 : MaskType;
	var Heap_$_1 : HeapType;
	var Mask_$_1 : MaskType;
	var Heap_$_2 : HeapType;
	var Mask_$_2 : MaskType;
	var Heap_$_3 : HeapType;
	var Mask_$_3 : MaskType;
	var Heap_$_4 : HeapType;
	var Mask_$_4 : MaskType;
	var Heap_$_5 : HeapType;
	var Mask_$_5 : MaskType;
	var Credits_$_0 : CreditsType;
	var exhaleMask#_1155_$_0 : MaskType;
	var inhaleHeap#_1157_$_0 : HeapType;
	var Heap_$_6 : HeapType;
	var Mask_$_6 : MaskType;
	var Heap_$_7 : HeapType;
	var Mask_$_7 : MaskType;
	var Heap_$_8 : HeapType;
	var Mask_$_8 : MaskType;
	var Heap_$_9 : HeapType;
	var Mask_$_9 : MaskType;
	var Heap_$_10 : HeapType;
	var Mask_$_10 : MaskType;
	var Heap_$_11 : HeapType;
	var Mask_$_11 : MaskType;
	var exhaleMask#_1159_$_0 : MaskType;
	var inhaleHeap#_1161_$_0 : HeapType;
	var Heap_$_12 : HeapType;
	var Mask_$_12 : MaskType;
	var Heap_$_13 : HeapType;
	var Mask_$_13 : MaskType;
	var Heap_$_14 : HeapType;
	var Mask_$_14 : MaskType;
	var Heap_$_15 : HeapType;
	var Mask_$_15 : MaskType;
	var Heap_$_16 : HeapType;
	var Mask_$_16 : MaskType;
	var Heap_$_17 : HeapType;
	var Mask_$_17 : MaskType;
	var Heap_$_18 : HeapType;
	var Mask_$_18 : MaskType;
	var Heap_$_19 : HeapType;
	var Mask_$_19 : MaskType;
	var exhaleMask#_1163_$_0 : MaskType;
	var inhaleHeap#_1165_$_0 : HeapType;
	var Heap_$_20 : HeapType;
	var Mask_$_20 : MaskType;
	var Heap_$_21 : HeapType;
	var Mask_$_21 : MaskType;
	var exhaleMask#_1167_$_0 : MaskType;
	var inhaleHeap#_1169_$_0 : HeapType;
	var Heap_$_22 : HeapType;
	var Mask_$_22 : MaskType;
	var Heap_$_23 : HeapType;
	var Mask_$_23 : MaskType;
	var Credits_$_1 : CreditsType;
	var exhaleMask#_1177_$_0 : MaskType;
	var exhaleMask#_1177_$_1 : MaskType;
	var exhaleMask#_1177_$_2 : MaskType;
	var exhaleMask#_1177_$_3 : MaskType;
	var exhaleMask#_1177_$_4 : MaskType;
	var exhaleMask#_1177_$_5 : MaskType;
	var exhaleMask#_1177_$_6 : MaskType;
	var exhaleMask#_1177_$_7 : MaskType;
	var exhaleMask#_1177_$_8 : MaskType;
	var Heap_$_24 : HeapType;
	var inhaleHeap#_1188_$_0 : HeapType;
	var Heap_$_25 : HeapType;
	var Mask_$_24 : MaskType;
	var Heap_$_26 : HeapType;
	var Mask_$_25 : MaskType;
	var Heap_$_27 : HeapType;
	var Mask_$_26 : MaskType;
	var Heap_$_28 : HeapType;
	var Mask_$_27 : MaskType;
	var Heap_$_29 : HeapType;
	var Mask_$_28 : MaskType;
	var Heap_$_30 : HeapType;
	var Mask_$_29 : MaskType;
	var Heap_$_31 : HeapType;
	var Mask_$_30 : MaskType;
	var Heap_$_32 : HeapType;
	var Mask_$_31 : MaskType;
	var Heap_$_33 : HeapType;
	var Mask_$_32 : MaskType;
	var Credits_$_2 : CreditsType;
	var Heap_$_34 : HeapType;
	var inhaleHeap#_1189_$_0 : HeapType;
	var Heap_$_35 : HeapType;
	var Mask_$_33 : MaskType;
	var Heap_$_36 : HeapType;
	var Mask_$_34 : MaskType;
	var Heap_$_37 : HeapType;
	var Mask_$_35 : MaskType;
	var Heap_$_38 : HeapType;
	var Mask_$_36 : MaskType;
	var Heap_$_39 : HeapType;
	var Mask_$_37 : MaskType;
	var Heap_$_40 : HeapType;
	var Mask_$_38 : MaskType;
	var Heap_$_41 : HeapType;
	var Mask_$_39 : MaskType;
	var Heap_$_42 : HeapType;
	var Mask_$_40 : MaskType;
	var Heap_$_43 : HeapType;
	var Mask_$_41 : MaskType;
	var Credits_$_3 : CreditsType;
	var this#127_$_0 : ref;
	var msg#128_$_0 : ref;
	var inhaleHeap#_1192_$_0 : HeapType;
	var Heap_$_44 : HeapType;
	var Mask_$_42 : MaskType;
	var Heap_$_45 : HeapType;
	var Mask_$_43 : MaskType;
	var Credits_$_4 : CreditsType;
	var inhaleHeap#_1434_$_0 : HeapType;
	var Heap_$_46 : HeapType;
	var Mask_$_44 : MaskType;
	var Heap_$_47 : HeapType;
	var Mask_$_45 : MaskType;
	var Heap_$_48 : HeapType;
	var Mask_$_46 : MaskType;
	var Heap_$_49 : HeapType;
	var Mask_$_47 : MaskType;
	var Heap_$_50 : HeapType;
	var Mask_$_48 : MaskType;
	var Heap_$_51 : HeapType;
	var Mask_$_49 : MaskType;
	var Heap_$_52 : HeapType;
	var Mask_$_50 : MaskType;
	var Heap_$_53 : HeapType;
	var Mask_$_51 : MaskType;
	var Heap_$_54 : HeapType;
	var Mask_$_52 : MaskType;
	var Credits_$_5 : CreditsType;
	var this#129_$_0 : ref;
	var exhaleMask#_1197_$_0 : MaskType;
	var exhaleMask#_1197_$_1 : MaskType;
	var exhaleMask#_1197_$_2 : MaskType;
	var mo#131_$_0 : ref;
	var inhaleHeap#_1203_$_0 : HeapType;
	var Heap_$_55 : HeapType;
	var Mask_$_53 : MaskType;
	var Heap_$_56 : HeapType;
	var Mask_$_54 : MaskType;
	var Heap_$_57 : HeapType;
	var Mask_$_55 : MaskType;
	var exhaleMask#_1205_$_0 : MaskType;
	var inhaleHeap#_1207_$_0 : HeapType;
	var Heap_$_58 : HeapType;
	var Mask_$_56 : MaskType;
	var Heap_$_59 : HeapType;
	var Mask_$_57 : MaskType;
	var Heap_$_60 : HeapType;
	var Mask_$_58 : MaskType;
	var Heap_$_61 : HeapType;
	var Mask_$_59 : MaskType;
	var Heap_$_62 : HeapType;
	var Mask_$_60 : MaskType;
	var Heap_$_63 : HeapType;
	var Mask_$_61 : MaskType;
	var Heap_$_64 : HeapType;
	var Mask_$_62 : MaskType;
	var Heap_$_65 : HeapType;
	var Mask_$_63 : MaskType;
	var Heap_$_66 : HeapType;
	var Mask_$_64 : MaskType;
	var Heap_$_67 : HeapType;
	var Mask_$_65 : MaskType;
	var Heap_$_68 : HeapType;
	var Mask_$_66 : MaskType;
	var Heap_$_69 : HeapType;
	var Mask_$_67 : MaskType;
	var Heap_$_70 : HeapType;
	var Mask_$_68 : MaskType;
	var Heap_$_71 : HeapType;
	var Mask_$_69 : MaskType;
	var Heap_$_72 : HeapType;
	var Mask_$_70 : MaskType;
	var Mask_$_71 : MaskType;
	var Heap_$_73 : HeapType;
	var nw#_1321_$_0 : ref;
	var Mask_$_72 : MaskType;
	var Mask_$_73 : MaskType;
	var Mask_$_74 : MaskType;
	var Mask_$_75 : MaskType;
	var Mask_$_76 : MaskType;
	var vp#144_$_0 : int;
	var vop#145_$_0 : int;
	var custp#146_$_0 : ref;
	var exhaleMask#_1326_$_0 : MaskType;
	var exhaleMask#_1326_$_1 : MaskType;
	var exhaleMask#_1326_$_2 : MaskType;
	var exhaleMask#_1326_$_3 : MaskType;
	var exhaleMask#_1326_$_4 : MaskType;
	var exhaleMask#_1326_$_5 : MaskType;
	var exhaleMask#_1326_$_6 : MaskType;
	var exhaleMask#_1326_$_7 : MaskType;
	var exhaleMask#_1326_$_8 : MaskType;
	var inhaleHeap#_1337_$_0 : HeapType;
	var Heap_$_74 : HeapType;
	var Mask_$_77 : MaskType;
	var Heap_$_75 : HeapType;
	var Mask_$_78 : MaskType;
	var Heap_$_76 : HeapType;
	var Mask_$_79 : MaskType;
	var Heap_$_77 : HeapType;
	var Mask_$_80 : MaskType;
	var Heap_$_78 : HeapType;
	var Mask_$_81 : MaskType;
	var Heap_$_79 : HeapType;
	var Mask_$_82 : MaskType;
	var Heap_$_80 : HeapType;
	var Mask_$_83 : MaskType;
	var Heap_$_81 : HeapType;
	var Mask_$_84 : MaskType;
	var Heap_$_82 : HeapType;
	var Mask_$_85 : MaskType;
	var Heap_$_83 : HeapType;
	var Mask_$_86 : MaskType;
	var Heap_$_84 : HeapType;
	var Mask_$_87 : MaskType;
	var Heap_$_85 : HeapType;
	var Mask_$_88 : MaskType;
	var Heap_$_86 : HeapType;
	var Mask_$_89 : MaskType;
	var Heap_$_87 : HeapType;
	var Mask_$_90 : MaskType;
	var Heap_$_88 : HeapType;
	var Mask_$_91 : MaskType;
	var Heap_$_89 : HeapType;
	var Mask_$_92 : MaskType;
	var Heap_$_90 : HeapType;
	var Mask_$_93 : MaskType;
	var Heap_$_91 : HeapType;
	var Mask_$_94 : MaskType;
	var Heap_$_92 : HeapType;
	var Mask_$_95 : MaskType;
	var argsSeq#_1343_$_0 : ArgSeq;
	var Credits_$_6 : CreditsType;
	var exhaleMask#_1345_$_0 : MaskType;
	var exhaleMask#_1345_$_1 : MaskType;
	var exhaleMask#_1345_$_2 : MaskType;
	var exhaleMask#_1345_$_3 : MaskType;
	var exhaleMask#_1345_$_4 : MaskType;
	var exhaleMask#_1345_$_5 : MaskType;
	var exhaleMask#_1345_$_6 : MaskType;
	var exhaleMask#_1345_$_7 : MaskType;
	var exhaleMask#_1345_$_8 : MaskType;
	var exhaleMask#_1345_$_9 : MaskType;
	var exhaleMask#_1345_$_10 : MaskType;
	var exhaleMask#_1345_$_11 : MaskType;
	var exhaleMask#_1345_$_12 : MaskType;
	var token#_1338_$_0 : ref;
	var Mask_$_96 : MaskType;
	var asyncstate#_1339_$_0 : int;
	var Heap_$_93 : HeapType;
	var Heap_$_94 : HeapType;
	var nw#_1358_$_0 : ref;
	var Mask_$_97 : MaskType;
	var Mask_$_98 : MaskType;
	var Mask_$_99 : MaskType;
	var Mask_$_100 : MaskType;
	var Mask_$_101 : MaskType;
	var Mask_$_102 : MaskType;
	var Mask_$_103 : MaskType;
	var Mask_$_104 : MaskType;
	var Mask_$_105 : MaskType;
	var Mask_$_106 : MaskType;
	var Mask_$_107 : MaskType;
	var Mask_$_108 : MaskType;
	var Mask_$_109 : MaskType;
	var Mask_$_110 : MaskType;
	var Mask_$_111 : MaskType;
	var Mask_$_112 : MaskType;
	var Mask_$_113 : MaskType;
	var Mask_$_114 : MaskType;
	var Heap_$_95 : HeapType;
	var v#149_$_0 : int;
	var vo#150_$_0 : int;
	var exhaleMask#_1363_$_0 : MaskType;
	var exhaleMask#_1363_$_1 : MaskType;
	var exhaleMask#_1363_$_2 : MaskType;
	var exhaleMask#_1363_$_3 : MaskType;
	var exhaleMask#_1363_$_4 : MaskType;
	var exhaleMask#_1363_$_5 : MaskType;
	var exhaleMask#_1363_$_6 : MaskType;
	var exhaleMask#_1363_$_7 : MaskType;
	var exhaleMask#_1363_$_8 : MaskType;
	var exhaleMask#_1363_$_9 : MaskType;
	var exhaleMask#_1363_$_10 : MaskType;
	var exhaleMask#_1363_$_11 : MaskType;
	var exhaleMask#_1363_$_12 : MaskType;
	var exhaleMask#_1363_$_13 : MaskType;
	var exhaleMask#_1363_$_14 : MaskType;
	var exhaleMask#_1363_$_15 : MaskType;
	var exhaleMask#_1363_$_16 : MaskType;
	var inhaleHeap#_1382_$_0 : HeapType;
	var Heap_$_96 : HeapType;
	var Mask_$_115 : MaskType;
	var Heap_$_97 : HeapType;
	var Mask_$_116 : MaskType;
	var Heap_$_98 : HeapType;
	var Mask_$_117 : MaskType;
	var Heap_$_99 : HeapType;
	var Mask_$_118 : MaskType;
	var this#153_$_0 : ref;
	var exhaleMask#_1387_$_0 : MaskType;
	var exhaleMask#_1387_$_1 : MaskType;
	var exhaleMask#_1387_$_2 : MaskType;
	var exhaleMask#_1387_$_3 : MaskType;
	var exhaleMask#_1387_$_4 : MaskType;
	var inhaleHeap#_1395_$_0 : HeapType;
	var Heap_$_100 : HeapType;
	var Mask_$_119 : MaskType;
	var Heap_$_101 : HeapType;
	var Mask_$_120 : MaskType;
	var nw#_1396_$_0 : ref;
	var Mask_$_121 : MaskType;
	var Mask_$_122 : MaskType;
	var Mask_$_123 : MaskType;
	var Mask_$_124 : MaskType;
	var Mask_$_125 : MaskType;
	var Mask_$_126 : MaskType;
	var Mask_$_127 : MaskType;
	var Mask_$_128 : MaskType;
	var Mask_$_129 : MaskType;
	var Mask_$_130 : MaskType;
	var Mask_$_131 : MaskType;
	var Mask_$_132 : MaskType;
	var Mask_$_133 : MaskType;
	var Mask_$_134 : MaskType;
	var Mask_$_135 : MaskType;
	var Mask_$_136 : MaskType;
	var Mask_$_137 : MaskType;
	var Mask_$_138 : MaskType;
	var Heap_$_102 : HeapType;
	var nw#_1208_$_0 : ref;
	var Mask_$_139 : MaskType;
	var Mask_$_140 : MaskType;
	var Mask_$_141 : MaskType;
	var Mask_$_142 : MaskType;
	var Mask_$_143 : MaskType;
	var Mask_$_144 : MaskType;
	var Mask_$_145 : MaskType;
	var Mask_$_146 : MaskType;
	var Mask_$_147 : MaskType;
	var Mask_$_148 : MaskType;
	var Mask_$_149 : MaskType;
	var Mask_$_150 : MaskType;
	var Mask_$_151 : MaskType;
	var Mask_$_152 : MaskType;
	var Mask_$_153 : MaskType;
	var Mask_$_154 : MaskType;
	var Mask_$_155 : MaskType;
	var Mask_$_156 : MaskType;
	var Heap_$_103 : HeapType;
	var receiver#134_$_0 : ref;
	var nw#_1258_$_0 : ref;
	var Mask_$_157 : MaskType;
	var Mask_$_158 : MaskType;
	var Mask_$_159 : MaskType;
	var Mask_$_160 : MaskType;
	var Mask_$_161 : MaskType;
	var Mask_$_162 : MaskType;
	var Mask_$_163 : MaskType;
	var Mask_$_164 : MaskType;
	var Mask_$_165 : MaskType;
	var Mask_$_166 : MaskType;
	var Mask_$_167 : MaskType;
	var Mask_$_168 : MaskType;
	var Mask_$_169 : MaskType;
	var Mask_$_170 : MaskType;
	var Mask_$_171 : MaskType;
	var Mask_$_172 : MaskType;
	var Mask_$_173 : MaskType;
	var Mask_$_174 : MaskType;
	var Heap_$_104 : HeapType;
	var receiver#140_$_0 : ref;
	var exhaleMask#_1263_$_0 : MaskType;
	var exhaleMask#_1263_$_1 : MaskType;
	var exhaleMask#_1263_$_2 : MaskType;
	var exhaleMask#_1263_$_3 : MaskType;
	var exhaleMask#_1263_$_4 : MaskType;
	var exhaleMask#_1263_$_5 : MaskType;
	var exhaleMask#_1263_$_6 : MaskType;
	var exhaleMask#_1263_$_7 : MaskType;
	var exhaleMask#_1263_$_8 : MaskType;
	var inhaleHeap#_1275_$_0 : HeapType;
	var Heap_$_105 : HeapType;
	var Mask_$_175 : MaskType;
	var Heap_$_106 : HeapType;
	var Mask_$_176 : MaskType;
	var Heap_$_107 : HeapType;
	var Mask_$_177 : MaskType;
	var Heap_$_108 : HeapType;
	var Mask_$_178 : MaskType;
	var exhaleMask#_1277_$_0 : MaskType;
	var inhaleHeap#_1279_$_0 : HeapType;
	var Heap_$_109 : HeapType;
	var Mask_$_179 : MaskType;
	var Heap_$_110 : HeapType;
	var Mask_$_180 : MaskType;
	var Heap_$_111 : HeapType;
	var Mask_$_181 : MaskType;
	var Heap_$_112 : HeapType;
	var Mask_$_182 : MaskType;
	var Heap_$_113 : HeapType;
	var Mask_$_183 : MaskType;
	var Heap_$_114 : HeapType;
	var Mask_$_184 : MaskType;
	var exhaleMask#_1281_$_0 : MaskType;
	var inhaleHeap#_1283_$_0 : HeapType;
	var Heap_$_115 : HeapType;
	var Mask_$_185 : MaskType;
	var Heap_$_116 : HeapType;
	var Mask_$_186 : MaskType;
	var this#141_$_0 : ref;
	var exhaleMask#_1288_$_0 : MaskType;
	var exhaleMask#_1288_$_1 : MaskType;
	var exhaleMask#_1288_$_2 : MaskType;
	var exhaleMask#_1288_$_3 : MaskType;
	var exhaleMask#_1288_$_4 : MaskType;
	var inhaleHeap#_1296_$_0 : HeapType;
	var Heap_$_117 : HeapType;
	var Mask_$_187 : MaskType;
	var Heap_$_118 : HeapType;
	var Mask_$_188 : MaskType;
	var nw#_1297_$_0 : ref;
	var Mask_$_189 : MaskType;
	var Mask_$_190 : MaskType;
	var Mask_$_191 : MaskType;
	var Mask_$_192 : MaskType;
	var Mask_$_193 : MaskType;
	var Mask_$_194 : MaskType;
	var Mask_$_195 : MaskType;
	var Mask_$_196 : MaskType;
	var Mask_$_197 : MaskType;
	var Mask_$_198 : MaskType;
	var Mask_$_199 : MaskType;
	var Mask_$_200 : MaskType;
	var Mask_$_201 : MaskType;
	var Mask_$_202 : MaskType;
	var Mask_$_203 : MaskType;
	var Mask_$_204 : MaskType;
	var Mask_$_205 : MaskType;
	var Mask_$_206 : MaskType;
	var Heap_$_119 : HeapType;
	var exhaleMask#_1213_$_0 : MaskType;
	var exhaleMask#_1213_$_1 : MaskType;
	var exhaleMask#_1213_$_2 : MaskType;
	var exhaleMask#_1213_$_3 : MaskType;
	var exhaleMask#_1213_$_4 : MaskType;
	var exhaleMask#_1213_$_5 : MaskType;
	var inhaleHeap#_1221_$_0 : HeapType;
	var Heap_$_120 : HeapType;
	var Mask_$_207 : MaskType;
	var Heap_$_121 : HeapType;
	var Mask_$_208 : MaskType;
	var Heap_$_122 : HeapType;
	var Mask_$_209 : MaskType;
	var Heap_$_123 : HeapType;
	var Mask_$_210 : MaskType;
	var exhaleMask#_1238_$_0 : MaskType;
	var inhaleHeap#_1240_$_0 : HeapType;
	var Heap_$_124 : HeapType;
	var Mask_$_211 : MaskType;
	var Heap_$_125 : HeapType;
	var Mask_$_212 : MaskType;
	var Heap_$_126 : HeapType;
	var Mask_$_213 : MaskType;
	var Heap_$_127 : HeapType;
	var Mask_$_214 : MaskType;
	var Heap_$_128 : HeapType;
	var Mask_$_215 : MaskType;
	var Heap_$_129 : HeapType;
	var Mask_$_216 : MaskType;
	var exhaleMask#_1242_$_0 : MaskType;
	var inhaleHeap#_1244_$_0 : HeapType;
	var Heap_$_130 : HeapType;
	var Mask_$_217 : MaskType;
	var Heap_$_131 : HeapType;
	var Mask_$_218 : MaskType;
	var this#135_$_0 : ref;
	var exhaleMask#_1249_$_0 : MaskType;
	var exhaleMask#_1249_$_1 : MaskType;
	var exhaleMask#_1249_$_2 : MaskType;
	var exhaleMask#_1249_$_3 : MaskType;
	var exhaleMask#_1249_$_4 : MaskType;
	var inhaleHeap#_1257_$_0 : HeapType;
	var Heap_$_132 : HeapType;
	var Mask_$_219 : MaskType;
	var Heap_$_133 : HeapType;
	var Mask_$_220 : MaskType;
	var Mask_$_221 : MaskType;
	var Credits_$_7 : CreditsType;
	var Heap_$_134 : HeapType;
	var Credits_$_8 : CreditsType;
	var exhaleMask#_1420_$_0 : MaskType;
	var exhaleMask#_1420_$_1 : MaskType;
	var exhaleMask#_1420_$_2 : MaskType;
	var exhaleMask#_1420_$_3 : MaskType;
	var exhaleMask#_1420_$_4 : MaskType;
	var exhaleMask#_1420_$_5 : MaskType;
	var exhaleMask#_1420_$_6 : MaskType;
	var exhaleMask#_1420_$_7 : MaskType;
	var exhaleMask#_1420_$_8 : MaskType;
	var $_$_condition : bool;
	var $_$_condition_$0 : bool;
	var $_$_condition_$1 : bool;
	var $_$_condition_$2 : bool;
	var $_$_condition_$3 : bool;
	var $_$_condition_$5 : bool;
	var $_$_condition_$6 : bool;
	var $_$_condition_$7 : bool;
	var $_$_condition_$8 : bool;
	var $_$_condition_$9 : bool;
	var $_$_condition_$10 : bool;
	var $_$_condition_$11 : bool;
	var $_$_condition_$12 : bool;
	var $_$_condition_$13 : bool;
	var $_$_condition_$15 : bool;
	var $_$_condition_$16 : bool;
	var $_$_condition_$17 : bool;
	var $_$_condition_$18 : bool;
	var $_$_condition_$19 : bool;
	var $_$_condition_$20 : bool;
	var $_$_condition_$22 : bool;
	var $_$_condition_$23 : bool;
	var $_$_condition_$25 : bool;
	var $_$_condition_$26 : bool;
	var $_$_condition_$27 : bool;
$start:
	assume Permission$denominator > 0;
	assume (Permission$Zero[perm$R] == 0) && (Permission$Zero[perm$N] == 0);
	assume (Permission$Full[perm$R] == Permission$FullFraction) && (Permission$Full[perm$N] == 0);
	assume (((((forall  o_$17 : ref, f_$19 : Field (Boolean) , pc_$0 : PermissionComponent :: ( ZeroMask[o_$17,f_$19][pc_$0] == 0 ))) && ((forall  o_$18 : ref, f_$20 : Field (Integer) , pc_$1 : PermissionComponent :: ( ZeroMask[o_$18,f_$20][pc_$1] == 0 )))) && ((forall  o_$19 : ref, f_$21 : Field (ref) , pc_$2 : PermissionComponent :: ( ZeroMask[o_$19,f_$21][pc_$2] == 0 )))) && ((forall  o_$20 : ref, f_$22 : Field (HeapType) , pc_$3 : PermissionComponent :: ( ZeroMask[o_$20,f_$22][pc_$3] == 0 )))) && ((forall  o_$21 : ref, f_$23 : Field (Mu) , pc_$4 : PermissionComponent :: ( ZeroMask[o_$21,f_$23][pc_$4] == 0 )));
	assume IsGoodMask(ZeroMask);
	assume NonPredicateField(joinable);
	assume NonPredicateField(forkK);
	assume (forall  n : Integer :: {Fractions(n)} ( Fractions(n) == (n * Permission$denominator) ));
	assume (forall  x : Integer, y : Integer :: ( ((0 <= x) && (x <= y)) ==> (Fractions(x) <= Fractions(y)) ));
	assume Permission$FullFraction == Fractions(100);
	assume (0 < channelK) && ((1000 * channelK) < Fractions(1));
	assume (0 < monitorK) && ((1000 * monitorK) < Fractions(1));
	assume (0 < predicateK) && ((1000 * predicateK) < Fractions(1));
	assume (predicateK == channelK) && (channelK == monitorK);
	assume (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((forall  a_$2 : Boolean, b_$2 : Boolean :: {IsGoodState(combine(a_$2,b_$2))} ( IsGoodState(combine(a_$2,b_$2)) <==> (IsGoodState(a_$2) && IsGoodState(b_$2)) ))) && ((forall  a_$3 : Boolean, b_$3 : Integer :: {IsGoodState(combine(a_$3,b_$3))} ( IsGoodState(combine(a_$3,b_$3)) <==> (IsGoodState(a_$3) && IsGoodState(b_$3)) )))) && ((forall  a_$4 : Boolean, b_$4 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$4,b_$4))} ( IsGoodState(combine(a_$4,b_$4)) <==> (IsGoodState(a_$4) && IsGoodState(b_$4)) )))) && ((forall  a_$5 : Boolean, b_$5 : PermissionComponent :: {IsGoodState(combine(a_$5,b_$5))} ( IsGoodState(combine(a_$5,b_$5)) <==> (IsGoodState(a_$5) && IsGoodState(b_$5)) )))) && ((forall  a_$6 : Boolean, b_$6 : MaskType :: {IsGoodState(combine(a_$6,b_$6))} ( IsGoodState(combine(a_$6,b_$6)) <==> (IsGoodState(a_$6) && IsGoodState(b_$6)) )))) && ((forall  a_$7 : Boolean, b_$7 : ref :: {IsGoodState(combine(a_$7,b_$7))} ( IsGoodState(combine(a_$7,b_$7)) <==> (IsGoodState(a_$7) && IsGoodState(b_$7)) )))) && ((forall  a_$8 : Boolean, b_$8 : Field (Integer)  :: {IsGoodState(combine(a_$8,b_$8))} ( IsGoodState(combine(a_$8,b_$8)) <==> (IsGoodState(a_$8) && IsGoodState(b_$8)) )))) && ((forall  a_$9 : Boolean, b_$9 : HeapType :: {IsGoodState(combine(a_$9,b_$9))} ( IsGoodState(combine(a_$9,b_$9)) <==> (IsGoodState(a_$9) && IsGoodState(b_$9)) )))) && ((forall  a_$10 : Boolean, b_$10 : Field (Mu)  :: {IsGoodState(combine(a_$10,b_$10))} ( IsGoodState(combine(a_$10,b_$10)) <==> (IsGoodState(a_$10) && IsGoodState(b_$10)) )))) && ((forall  a_$11 : Boolean, b_$11 : Mu :: {IsGoodState(combine(a_$11,b_$11))} ( IsGoodState(combine(a_$11,b_$11)) <==> (IsGoodState(a_$11) && IsGoodState(b_$11)) )))) && ((forall  a_$12 : Boolean, b_$12 : Field (Boolean)  :: {IsGoodState(combine(a_$12,b_$12))} ( IsGoodState(combine(a_$12,b_$12)) <==> (IsGoodState(a_$12) && IsGoodState(b_$12)) )))) && ((forall  a_$13 : Boolean, b_$13 : CreditsType :: {IsGoodState(combine(a_$13,b_$13))} ( IsGoodState(combine(a_$13,b_$13)) <==> (IsGoodState(a_$13) && IsGoodState(b_$13)) )))) && ((forall  a_$14 : Boolean, b_$14 : Field (ref)  :: {IsGoodState(combine(a_$14,b_$14))} ( IsGoodState(combine(a_$14,b_$14)) <==> (IsGoodState(a_$14) && IsGoodState(b_$14)) )))) && ((forall  a_$15 : Boolean, b_$15 : Field (HeapType)  :: {IsGoodState(combine(a_$15,b_$15))} ( IsGoodState(combine(a_$15,b_$15)) <==> (IsGoodState(a_$15) && IsGoodState(b_$15)) )))) && ((forall  a_$16 : Boolean, b_$16 : ModuleName :: {IsGoodState(combine(a_$16,b_$16))} ( IsGoodState(combine(a_$16,b_$16)) <==> (IsGoodState(a_$16) && IsGoodState(b_$16)) )))) && ((forall  a_$17 : Boolean, b_$17 : TypeName :: {IsGoodState(combine(a_$17,b_$17))} ( IsGoodState(combine(a_$17,b_$17)) <==> (IsGoodState(a_$17) && IsGoodState(b_$17)) )))) && ((forall  a_$18 : Boolean, b_$18 : ArgSeq :: {IsGoodState(combine(a_$18,b_$18))} ( IsGoodState(combine(a_$18,b_$18)) <==> (IsGoodState(a_$18) && IsGoodState(b_$18)) )))) && ((forall  a_$19 : Integer, b_$19 : Boolean :: {IsGoodState(combine(a_$19,b_$19))} ( IsGoodState(combine(a_$19,b_$19)) <==> (IsGoodState(a_$19) && IsGoodState(b_$19)) )))) && ((forall  a_$20 : Integer, b_$20 : Integer :: {IsGoodState(combine(a_$20,b_$20))} ( IsGoodState(combine(a_$20,b_$20)) <==> (IsGoodState(a_$20) && IsGoodState(b_$20)) )))) && ((forall  a_$21 : Integer, b_$21 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$21,b_$21))} ( IsGoodState(combine(a_$21,b_$21)) <==> (IsGoodState(a_$21) && IsGoodState(b_$21)) )))) && ((forall  a_$22 : Integer, b_$22 : PermissionComponent :: {IsGoodState(combine(a_$22,b_$22))} ( IsGoodState(combine(a_$22,b_$22)) <==> (IsGoodState(a_$22) && IsGoodState(b_$22)) )))) && ((forall  a_$23 : Integer, b_$23 : MaskType :: {IsGoodState(combine(a_$23,b_$23))} ( IsGoodState(combine(a_$23,b_$23)) <==> (IsGoodState(a_$23) && IsGoodState(b_$23)) )))) && ((forall  a_$24 : Integer, b_$24 : ref :: {IsGoodState(combine(a_$24,b_$24))} ( IsGoodState(combine(a_$24,b_$24)) <==> (IsGoodState(a_$24) && IsGoodState(b_$24)) )))) && ((forall  a_$25 : Integer, b_$25 : Field (Integer)  :: {IsGoodState(combine(a_$25,b_$25))} ( IsGoodState(combine(a_$25,b_$25)) <==> (IsGoodState(a_$25) && IsGoodState(b_$25)) )))) && ((forall  a_$26 : Integer, b_$26 : HeapType :: {IsGoodState(combine(a_$26,b_$26))} ( IsGoodState(combine(a_$26,b_$26)) <==> (IsGoodState(a_$26) && IsGoodState(b_$26)) )))) && ((forall  a_$27 : Integer, b_$27 : Field (Mu)  :: {IsGoodState(combine(a_$27,b_$27))} ( IsGoodState(combine(a_$27,b_$27)) <==> (IsGoodState(a_$27) && IsGoodState(b_$27)) )))) && ((forall  a_$28 : Integer, b_$28 : Mu :: {IsGoodState(combine(a_$28,b_$28))} ( IsGoodState(combine(a_$28,b_$28)) <==> (IsGoodState(a_$28) && IsGoodState(b_$28)) )))) && ((forall  a_$29 : Integer, b_$29 : Field (Boolean)  :: {IsGoodState(combine(a_$29,b_$29))} ( IsGoodState(combine(a_$29,b_$29)) <==> (IsGoodState(a_$29) && IsGoodState(b_$29)) )))) && ((forall  a_$30 : Integer, b_$30 : CreditsType :: {IsGoodState(combine(a_$30,b_$30))} ( IsGoodState(combine(a_$30,b_$30)) <==> (IsGoodState(a_$30) && IsGoodState(b_$30)) )))) && ((forall  a_$31 : Integer, b_$31 : Field (ref)  :: {IsGoodState(combine(a_$31,b_$31))} ( IsGoodState(combine(a_$31,b_$31)) <==> (IsGoodState(a_$31) && IsGoodState(b_$31)) )))) && ((forall  a_$32 : Integer, b_$32 : Field (HeapType)  :: {IsGoodState(combine(a_$32,b_$32))} ( IsGoodState(combine(a_$32,b_$32)) <==> (IsGoodState(a_$32) && IsGoodState(b_$32)) )))) && ((forall  a_$33 : Integer, b_$33 : ModuleName :: {IsGoodState(combine(a_$33,b_$33))} ( IsGoodState(combine(a_$33,b_$33)) <==> (IsGoodState(a_$33) && IsGoodState(b_$33)) )))) && ((forall  a_$34 : Integer, b_$34 : TypeName :: {IsGoodState(combine(a_$34,b_$34))} ( IsGoodState(combine(a_$34,b_$34)) <==> (IsGoodState(a_$34) && IsGoodState(b_$34)) )))) && ((forall  a_$35 : Integer, b_$35 : ArgSeq :: {IsGoodState(combine(a_$35,b_$35))} ( IsGoodState(combine(a_$35,b_$35)) <==> (IsGoodState(a_$35) && IsGoodState(b_$35)) )))) && ((forall  a_$36 : [PermissionComponent]Integer, b_$36 : Boolean :: {IsGoodState(combine(a_$36,b_$36))} ( IsGoodState(combine(a_$36,b_$36)) <==> (IsGoodState(a_$36) && IsGoodState(b_$36)) )))) && ((forall  a_$37 : [PermissionComponent]Integer, b_$37 : Integer :: {IsGoodState(combine(a_$37,b_$37))} ( IsGoodState(combine(a_$37,b_$37)) <==> (IsGoodState(a_$37) && IsGoodState(b_$37)) )))) && ((forall  a_$38 : [PermissionComponent]Integer, b_$38 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$38,b_$38))} ( IsGoodState(combine(a_$38,b_$38)) <==> (IsGoodState(a_$38) && IsGoodState(b_$38)) )))) && ((forall  a_$39 : [PermissionComponent]Integer, b_$39 : PermissionComponent :: {IsGoodState(combine(a_$39,b_$39))} ( IsGoodState(combine(a_$39,b_$39)) <==> (IsGoodState(a_$39) && IsGoodState(b_$39)) )))) && ((forall  a_$40 : [PermissionComponent]Integer, b_$40 : MaskType :: {IsGoodState(combine(a_$40,b_$40))} ( IsGoodState(combine(a_$40,b_$40)) <==> (IsGoodState(a_$40) && IsGoodState(b_$40)) )))) && ((forall  a_$41 : [PermissionComponent]Integer, b_$41 : ref :: {IsGoodState(combine(a_$41,b_$41))} ( IsGoodState(combine(a_$41,b_$41)) <==> (IsGoodState(a_$41) && IsGoodState(b_$41)) )))) && ((forall  a_$42 : [PermissionComponent]Integer, b_$42 : Field (Integer)  :: {IsGoodState(combine(a_$42,b_$42))} ( IsGoodState(combine(a_$42,b_$42)) <==> (IsGoodState(a_$42) && IsGoodState(b_$42)) )))) && ((forall  a_$43 : [PermissionComponent]Integer, b_$43 : HeapType :: {IsGoodState(combine(a_$43,b_$43))} ( IsGoodState(combine(a_$43,b_$43)) <==> (IsGoodState(a_$43) && IsGoodState(b_$43)) )))) && ((forall  a_$44 : [PermissionComponent]Integer, b_$44 : Field (Mu)  :: {IsGoodState(combine(a_$44,b_$44))} ( IsGoodState(combine(a_$44,b_$44)) <==> (IsGoodState(a_$44) && IsGoodState(b_$44)) )))) && ((forall  a_$45 : [PermissionComponent]Integer, b_$45 : Mu :: {IsGoodState(combine(a_$45,b_$45))} ( IsGoodState(combine(a_$45,b_$45)) <==> (IsGoodState(a_$45) && IsGoodState(b_$45)) )))) && ((forall  a_$46 : [PermissionComponent]Integer, b_$46 : Field (Boolean)  :: {IsGoodState(combine(a_$46,b_$46))} ( IsGoodState(combine(a_$46,b_$46)) <==> (IsGoodState(a_$46) && IsGoodState(b_$46)) )))) && ((forall  a_$47 : [PermissionComponent]Integer, b_$47 : CreditsType :: {IsGoodState(combine(a_$47,b_$47))} ( IsGoodState(combine(a_$47,b_$47)) <==> (IsGoodState(a_$47) && IsGoodState(b_$47)) )))) && ((forall  a_$48 : [PermissionComponent]Integer, b_$48 : Field (ref)  :: {IsGoodState(combine(a_$48,b_$48))} ( IsGoodState(combine(a_$48,b_$48)) <==> (IsGoodState(a_$48) && IsGoodState(b_$48)) )))) && ((forall  a_$49 : [PermissionComponent]Integer, b_$49 : Field (HeapType)  :: {IsGoodState(combine(a_$49,b_$49))} ( IsGoodState(combine(a_$49,b_$49)) <==> (IsGoodState(a_$49) && IsGoodState(b_$49)) )))) && ((forall  a_$50 : [PermissionComponent]Integer, b_$50 : ModuleName :: {IsGoodState(combine(a_$50,b_$50))} ( IsGoodState(combine(a_$50,b_$50)) <==> (IsGoodState(a_$50) && IsGoodState(b_$50)) )))) && ((forall  a_$51 : [PermissionComponent]Integer, b_$51 : TypeName :: {IsGoodState(combine(a_$51,b_$51))} ( IsGoodState(combine(a_$51,b_$51)) <==> (IsGoodState(a_$51) && IsGoodState(b_$51)) )))) && ((forall  a_$52 : [PermissionComponent]Integer, b_$52 : ArgSeq :: {IsGoodState(combine(a_$52,b_$52))} ( IsGoodState(combine(a_$52,b_$52)) <==> (IsGoodState(a_$52) && IsGoodState(b_$52)) )))) && ((forall  a_$53 : PermissionComponent, b_$53 : Boolean :: {IsGoodState(combine(a_$53,b_$53))} ( IsGoodState(combine(a_$53,b_$53)) <==> (IsGoodState(a_$53) && IsGoodState(b_$53)) )))) && ((forall  a_$54 : PermissionComponent, b_$54 : Integer :: {IsGoodState(combine(a_$54,b_$54))} ( IsGoodState(combine(a_$54,b_$54)) <==> (IsGoodState(a_$54) && IsGoodState(b_$54)) )))) && ((forall  a_$55 : PermissionComponent, b_$55 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$55,b_$55))} ( IsGoodState(combine(a_$55,b_$55)) <==> (IsGoodState(a_$55) && IsGoodState(b_$55)) )))) && ((forall  a_$56 : PermissionComponent, b_$56 : PermissionComponent :: {IsGoodState(combine(a_$56,b_$56))} ( IsGoodState(combine(a_$56,b_$56)) <==> (IsGoodState(a_$56) && IsGoodState(b_$56)) )))) && ((forall  a_$57 : PermissionComponent, b_$57 : MaskType :: {IsGoodState(combine(a_$57,b_$57))} ( IsGoodState(combine(a_$57,b_$57)) <==> (IsGoodState(a_$57) && IsGoodState(b_$57)) )))) && ((forall  a_$58 : PermissionComponent, b_$58 : ref :: {IsGoodState(combine(a_$58,b_$58))} ( IsGoodState(combine(a_$58,b_$58)) <==> (IsGoodState(a_$58) && IsGoodState(b_$58)) )))) && ((forall  a_$59 : PermissionComponent, b_$59 : Field (Integer)  :: {IsGoodState(combine(a_$59,b_$59))} ( IsGoodState(combine(a_$59,b_$59)) <==> (IsGoodState(a_$59) && IsGoodState(b_$59)) )))) && ((forall  a_$60 : PermissionComponent, b_$60 : HeapType :: {IsGoodState(combine(a_$60,b_$60))} ( IsGoodState(combine(a_$60,b_$60)) <==> (IsGoodState(a_$60) && IsGoodState(b_$60)) )))) && ((forall  a_$61 : PermissionComponent, b_$61 : Field (Mu)  :: {IsGoodState(combine(a_$61,b_$61))} ( IsGoodState(combine(a_$61,b_$61)) <==> (IsGoodState(a_$61) && IsGoodState(b_$61)) )))) && ((forall  a_$62 : PermissionComponent, b_$62 : Mu :: {IsGoodState(combine(a_$62,b_$62))} ( IsGoodState(combine(a_$62,b_$62)) <==> (IsGoodState(a_$62) && IsGoodState(b_$62)) )))) && ((forall  a_$63 : PermissionComponent, b_$63 : Field (Boolean)  :: {IsGoodState(combine(a_$63,b_$63))} ( IsGoodState(combine(a_$63,b_$63)) <==> (IsGoodState(a_$63) && IsGoodState(b_$63)) )))) && ((forall  a_$64 : PermissionComponent, b_$64 : CreditsType :: {IsGoodState(combine(a_$64,b_$64))} ( IsGoodState(combine(a_$64,b_$64)) <==> (IsGoodState(a_$64) && IsGoodState(b_$64)) )))) && ((forall  a_$65 : PermissionComponent, b_$65 : Field (ref)  :: {IsGoodState(combine(a_$65,b_$65))} ( IsGoodState(combine(a_$65,b_$65)) <==> (IsGoodState(a_$65) && IsGoodState(b_$65)) )))) && ((forall  a_$66 : PermissionComponent, b_$66 : Field (HeapType)  :: {IsGoodState(combine(a_$66,b_$66))} ( IsGoodState(combine(a_$66,b_$66)) <==> (IsGoodState(a_$66) && IsGoodState(b_$66)) )))) && ((forall  a_$67 : PermissionComponent, b_$67 : ModuleName :: {IsGoodState(combine(a_$67,b_$67))} ( IsGoodState(combine(a_$67,b_$67)) <==> (IsGoodState(a_$67) && IsGoodState(b_$67)) )))) && ((forall  a_$68 : PermissionComponent, b_$68 : TypeName :: {IsGoodState(combine(a_$68,b_$68))} ( IsGoodState(combine(a_$68,b_$68)) <==> (IsGoodState(a_$68) && IsGoodState(b_$68)) )))) && ((forall  a_$69 : PermissionComponent, b_$69 : ArgSeq :: {IsGoodState(combine(a_$69,b_$69))} ( IsGoodState(combine(a_$69,b_$69)) <==> (IsGoodState(a_$69) && IsGoodState(b_$69)) )))) && ((forall  a_$70 : MaskType, b_$70 : Boolean :: {IsGoodState(combine(a_$70,b_$70))} ( IsGoodState(combine(a_$70,b_$70)) <==> (IsGoodState(a_$70) && IsGoodState(b_$70)) )))) && ((forall  a_$71 : MaskType, b_$71 : Integer :: {IsGoodState(combine(a_$71,b_$71))} ( IsGoodState(combine(a_$71,b_$71)) <==> (IsGoodState(a_$71) && IsGoodState(b_$71)) )))) && ((forall  a_$72 : MaskType, b_$72 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$72,b_$72))} ( IsGoodState(combine(a_$72,b_$72)) <==> (IsGoodState(a_$72) && IsGoodState(b_$72)) )))) && ((forall  a_$73 : MaskType, b_$73 : PermissionComponent :: {IsGoodState(combine(a_$73,b_$73))} ( IsGoodState(combine(a_$73,b_$73)) <==> (IsGoodState(a_$73) && IsGoodState(b_$73)) )))) && ((forall  a_$74 : MaskType, b_$74 : MaskType :: {IsGoodState(combine(a_$74,b_$74))} ( IsGoodState(combine(a_$74,b_$74)) <==> (IsGoodState(a_$74) && IsGoodState(b_$74)) )))) && ((forall  a_$75 : MaskType, b_$75 : ref :: {IsGoodState(combine(a_$75,b_$75))} ( IsGoodState(combine(a_$75,b_$75)) <==> (IsGoodState(a_$75) && IsGoodState(b_$75)) )))) && ((forall  a_$76 : MaskType, b_$76 : Field (Integer)  :: {IsGoodState(combine(a_$76,b_$76))} ( IsGoodState(combine(a_$76,b_$76)) <==> (IsGoodState(a_$76) && IsGoodState(b_$76)) )))) && ((forall  a_$77 : MaskType, b_$77 : HeapType :: {IsGoodState(combine(a_$77,b_$77))} ( IsGoodState(combine(a_$77,b_$77)) <==> (IsGoodState(a_$77) && IsGoodState(b_$77)) )))) && ((forall  a_$78 : MaskType, b_$78 : Field (Mu)  :: {IsGoodState(combine(a_$78,b_$78))} ( IsGoodState(combine(a_$78,b_$78)) <==> (IsGoodState(a_$78) && IsGoodState(b_$78)) )))) && ((forall  a_$79 : MaskType, b_$79 : Mu :: {IsGoodState(combine(a_$79,b_$79))} ( IsGoodState(combine(a_$79,b_$79)) <==> (IsGoodState(a_$79) && IsGoodState(b_$79)) )))) && ((forall  a_$80 : MaskType, b_$80 : Field (Boolean)  :: {IsGoodState(combine(a_$80,b_$80))} ( IsGoodState(combine(a_$80,b_$80)) <==> (IsGoodState(a_$80) && IsGoodState(b_$80)) )))) && ((forall  a_$81 : MaskType, b_$81 : CreditsType :: {IsGoodState(combine(a_$81,b_$81))} ( IsGoodState(combine(a_$81,b_$81)) <==> (IsGoodState(a_$81) && IsGoodState(b_$81)) )))) && ((forall  a_$82 : MaskType, b_$82 : Field (ref)  :: {IsGoodState(combine(a_$82,b_$82))} ( IsGoodState(combine(a_$82,b_$82)) <==> (IsGoodState(a_$82) && IsGoodState(b_$82)) )))) && ((forall  a_$83 : MaskType, b_$83 : Field (HeapType)  :: {IsGoodState(combine(a_$83,b_$83))} ( IsGoodState(combine(a_$83,b_$83)) <==> (IsGoodState(a_$83) && IsGoodState(b_$83)) )))) && ((forall  a_$84 : MaskType, b_$84 : ModuleName :: {IsGoodState(combine(a_$84,b_$84))} ( IsGoodState(combine(a_$84,b_$84)) <==> (IsGoodState(a_$84) && IsGoodState(b_$84)) )))) && ((forall  a_$85 : MaskType, b_$85 : TypeName :: {IsGoodState(combine(a_$85,b_$85))} ( IsGoodState(combine(a_$85,b_$85)) <==> (IsGoodState(a_$85) && IsGoodState(b_$85)) )))) && ((forall  a_$86 : MaskType, b_$86 : ArgSeq :: {IsGoodState(combine(a_$86,b_$86))} ( IsGoodState(combine(a_$86,b_$86)) <==> (IsGoodState(a_$86) && IsGoodState(b_$86)) )))) && ((forall  a_$87 : ref, b_$87 : Boolean :: {IsGoodState(combine(a_$87,b_$87))} ( IsGoodState(combine(a_$87,b_$87)) <==> (IsGoodState(a_$87) && IsGoodState(b_$87)) )))) && ((forall  a_$88 : ref, b_$88 : Integer :: {IsGoodState(combine(a_$88,b_$88))} ( IsGoodState(combine(a_$88,b_$88)) <==> (IsGoodState(a_$88) && IsGoodState(b_$88)) )))) && ((forall  a_$89 : ref, b_$89 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$89,b_$89))} ( IsGoodState(combine(a_$89,b_$89)) <==> (IsGoodState(a_$89) && IsGoodState(b_$89)) )))) && ((forall  a_$90 : ref, b_$90 : PermissionComponent :: {IsGoodState(combine(a_$90,b_$90))} ( IsGoodState(combine(a_$90,b_$90)) <==> (IsGoodState(a_$90) && IsGoodState(b_$90)) )))) && ((forall  a_$91 : ref, b_$91 : MaskType :: {IsGoodState(combine(a_$91,b_$91))} ( IsGoodState(combine(a_$91,b_$91)) <==> (IsGoodState(a_$91) && IsGoodState(b_$91)) )))) && ((forall  a_$92 : ref, b_$92 : ref :: {IsGoodState(combine(a_$92,b_$92))} ( IsGoodState(combine(a_$92,b_$92)) <==> (IsGoodState(a_$92) && IsGoodState(b_$92)) )))) && ((forall  a_$93 : ref, b_$93 : Field (Integer)  :: {IsGoodState(combine(a_$93,b_$93))} ( IsGoodState(combine(a_$93,b_$93)) <==> (IsGoodState(a_$93) && IsGoodState(b_$93)) )))) && ((forall  a_$94 : ref, b_$94 : HeapType :: {IsGoodState(combine(a_$94,b_$94))} ( IsGoodState(combine(a_$94,b_$94)) <==> (IsGoodState(a_$94) && IsGoodState(b_$94)) )))) && ((forall  a_$95 : ref, b_$95 : Field (Mu)  :: {IsGoodState(combine(a_$95,b_$95))} ( IsGoodState(combine(a_$95,b_$95)) <==> (IsGoodState(a_$95) && IsGoodState(b_$95)) )))) && ((forall  a_$96 : ref, b_$96 : Mu :: {IsGoodState(combine(a_$96,b_$96))} ( IsGoodState(combine(a_$96,b_$96)) <==> (IsGoodState(a_$96) && IsGoodState(b_$96)) )))) && ((forall  a_$97 : ref, b_$97 : Field (Boolean)  :: {IsGoodState(combine(a_$97,b_$97))} ( IsGoodState(combine(a_$97,b_$97)) <==> (IsGoodState(a_$97) && IsGoodState(b_$97)) )))) && ((forall  a_$98 : ref, b_$98 : CreditsType :: {IsGoodState(combine(a_$98,b_$98))} ( IsGoodState(combine(a_$98,b_$98)) <==> (IsGoodState(a_$98) && IsGoodState(b_$98)) )))) && ((forall  a_$99 : ref, b_$99 : Field (ref)  :: {IsGoodState(combine(a_$99,b_$99))} ( IsGoodState(combine(a_$99,b_$99)) <==> (IsGoodState(a_$99) && IsGoodState(b_$99)) )))) && ((forall  a_$100 : ref, b_$100 : Field (HeapType)  :: {IsGoodState(combine(a_$100,b_$100))} ( IsGoodState(combine(a_$100,b_$100)) <==> (IsGoodState(a_$100) && IsGoodState(b_$100)) )))) && ((forall  a_$101 : ref, b_$101 : ModuleName :: {IsGoodState(combine(a_$101,b_$101))} ( IsGoodState(combine(a_$101,b_$101)) <==> (IsGoodState(a_$101) && IsGoodState(b_$101)) )))) && ((forall  a_$102 : ref, b_$102 : TypeName :: {IsGoodState(combine(a_$102,b_$102))} ( IsGoodState(combine(a_$102,b_$102)) <==> (IsGoodState(a_$102) && IsGoodState(b_$102)) )))) && ((forall  a_$103 : ref, b_$103 : ArgSeq :: {IsGoodState(combine(a_$103,b_$103))} ( IsGoodState(combine(a_$103,b_$103)) <==> (IsGoodState(a_$103) && IsGoodState(b_$103)) )))) && ((forall  a_$104 : Field (Integer) , b_$104 : Boolean :: {IsGoodState(combine(a_$104,b_$104))} ( IsGoodState(combine(a_$104,b_$104)) <==> (IsGoodState(a_$104) && IsGoodState(b_$104)) )))) && ((forall  a_$105 : Field (Integer) , b_$105 : Integer :: {IsGoodState(combine(a_$105,b_$105))} ( IsGoodState(combine(a_$105,b_$105)) <==> (IsGoodState(a_$105) && IsGoodState(b_$105)) )))) && ((forall  a_$106 : Field (Integer) , b_$106 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$106,b_$106))} ( IsGoodState(combine(a_$106,b_$106)) <==> (IsGoodState(a_$106) && IsGoodState(b_$106)) )))) && ((forall  a_$107 : Field (Integer) , b_$107 : PermissionComponent :: {IsGoodState(combine(a_$107,b_$107))} ( IsGoodState(combine(a_$107,b_$107)) <==> (IsGoodState(a_$107) && IsGoodState(b_$107)) )))) && ((forall  a_$108 : Field (Integer) , b_$108 : MaskType :: {IsGoodState(combine(a_$108,b_$108))} ( IsGoodState(combine(a_$108,b_$108)) <==> (IsGoodState(a_$108) && IsGoodState(b_$108)) )))) && ((forall  a_$109 : Field (Integer) , b_$109 : ref :: {IsGoodState(combine(a_$109,b_$109))} ( IsGoodState(combine(a_$109,b_$109)) <==> (IsGoodState(a_$109) && IsGoodState(b_$109)) )))) && ((forall  a_$110 : Field (Integer) , b_$110 : Field (Integer)  :: {IsGoodState(combine(a_$110,b_$110))} ( IsGoodState(combine(a_$110,b_$110)) <==> (IsGoodState(a_$110) && IsGoodState(b_$110)) )))) && ((forall  a_$111 : Field (Integer) , b_$111 : HeapType :: {IsGoodState(combine(a_$111,b_$111))} ( IsGoodState(combine(a_$111,b_$111)) <==> (IsGoodState(a_$111) && IsGoodState(b_$111)) )))) && ((forall  a_$112 : Field (Integer) , b_$112 : Field (Mu)  :: {IsGoodState(combine(a_$112,b_$112))} ( IsGoodState(combine(a_$112,b_$112)) <==> (IsGoodState(a_$112) && IsGoodState(b_$112)) )))) && ((forall  a_$113 : Field (Integer) , b_$113 : Mu :: {IsGoodState(combine(a_$113,b_$113))} ( IsGoodState(combine(a_$113,b_$113)) <==> (IsGoodState(a_$113) && IsGoodState(b_$113)) )))) && ((forall  a_$114 : Field (Integer) , b_$114 : Field (Boolean)  :: {IsGoodState(combine(a_$114,b_$114))} ( IsGoodState(combine(a_$114,b_$114)) <==> (IsGoodState(a_$114) && IsGoodState(b_$114)) )))) && ((forall  a_$115 : Field (Integer) , b_$115 : CreditsType :: {IsGoodState(combine(a_$115,b_$115))} ( IsGoodState(combine(a_$115,b_$115)) <==> (IsGoodState(a_$115) && IsGoodState(b_$115)) )))) && ((forall  a_$116 : Field (Integer) , b_$116 : Field (ref)  :: {IsGoodState(combine(a_$116,b_$116))} ( IsGoodState(combine(a_$116,b_$116)) <==> (IsGoodState(a_$116) && IsGoodState(b_$116)) )))) && ((forall  a_$117 : Field (Integer) , b_$117 : Field (HeapType)  :: {IsGoodState(combine(a_$117,b_$117))} ( IsGoodState(combine(a_$117,b_$117)) <==> (IsGoodState(a_$117) && IsGoodState(b_$117)) )))) && ((forall  a_$118 : Field (Integer) , b_$118 : ModuleName :: {IsGoodState(combine(a_$118,b_$118))} ( IsGoodState(combine(a_$118,b_$118)) <==> (IsGoodState(a_$118) && IsGoodState(b_$118)) )))) && ((forall  a_$119 : Field (Integer) , b_$119 : TypeName :: {IsGoodState(combine(a_$119,b_$119))} ( IsGoodState(combine(a_$119,b_$119)) <==> (IsGoodState(a_$119) && IsGoodState(b_$119)) )))) && ((forall  a_$120 : Field (Integer) , b_$120 : ArgSeq :: {IsGoodState(combine(a_$120,b_$120))} ( IsGoodState(combine(a_$120,b_$120)) <==> (IsGoodState(a_$120) && IsGoodState(b_$120)) )))) && ((forall  a_$121 : HeapType, b_$121 : Boolean :: {IsGoodState(combine(a_$121,b_$121))} ( IsGoodState(combine(a_$121,b_$121)) <==> (IsGoodState(a_$121) && IsGoodState(b_$121)) )))) && ((forall  a_$122 : HeapType, b_$122 : Integer :: {IsGoodState(combine(a_$122,b_$122))} ( IsGoodState(combine(a_$122,b_$122)) <==> (IsGoodState(a_$122) && IsGoodState(b_$122)) )))) && ((forall  a_$123 : HeapType, b_$123 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$123,b_$123))} ( IsGoodState(combine(a_$123,b_$123)) <==> (IsGoodState(a_$123) && IsGoodState(b_$123)) )))) && ((forall  a_$124 : HeapType, b_$124 : PermissionComponent :: {IsGoodState(combine(a_$124,b_$124))} ( IsGoodState(combine(a_$124,b_$124)) <==> (IsGoodState(a_$124) && IsGoodState(b_$124)) )))) && ((forall  a_$125 : HeapType, b_$125 : MaskType :: {IsGoodState(combine(a_$125,b_$125))} ( IsGoodState(combine(a_$125,b_$125)) <==> (IsGoodState(a_$125) && IsGoodState(b_$125)) )))) && ((forall  a_$126 : HeapType, b_$126 : ref :: {IsGoodState(combine(a_$126,b_$126))} ( IsGoodState(combine(a_$126,b_$126)) <==> (IsGoodState(a_$126) && IsGoodState(b_$126)) )))) && ((forall  a_$127 : HeapType, b_$127 : Field (Integer)  :: {IsGoodState(combine(a_$127,b_$127))} ( IsGoodState(combine(a_$127,b_$127)) <==> (IsGoodState(a_$127) && IsGoodState(b_$127)) )))) && ((forall  a_$128 : HeapType, b_$128 : HeapType :: {IsGoodState(combine(a_$128,b_$128))} ( IsGoodState(combine(a_$128,b_$128)) <==> (IsGoodState(a_$128) && IsGoodState(b_$128)) )))) && ((forall  a_$129 : HeapType, b_$129 : Field (Mu)  :: {IsGoodState(combine(a_$129,b_$129))} ( IsGoodState(combine(a_$129,b_$129)) <==> (IsGoodState(a_$129) && IsGoodState(b_$129)) )))) && ((forall  a_$130 : HeapType, b_$130 : Mu :: {IsGoodState(combine(a_$130,b_$130))} ( IsGoodState(combine(a_$130,b_$130)) <==> (IsGoodState(a_$130) && IsGoodState(b_$130)) )))) && ((forall  a_$131 : HeapType, b_$131 : Field (Boolean)  :: {IsGoodState(combine(a_$131,b_$131))} ( IsGoodState(combine(a_$131,b_$131)) <==> (IsGoodState(a_$131) && IsGoodState(b_$131)) )))) && ((forall  a_$132 : HeapType, b_$132 : CreditsType :: {IsGoodState(combine(a_$132,b_$132))} ( IsGoodState(combine(a_$132,b_$132)) <==> (IsGoodState(a_$132) && IsGoodState(b_$132)) )))) && ((forall  a_$133 : HeapType, b_$133 : Field (ref)  :: {IsGoodState(combine(a_$133,b_$133))} ( IsGoodState(combine(a_$133,b_$133)) <==> (IsGoodState(a_$133) && IsGoodState(b_$133)) )))) && ((forall  a_$134 : HeapType, b_$134 : Field (HeapType)  :: {IsGoodState(combine(a_$134,b_$134))} ( IsGoodState(combine(a_$134,b_$134)) <==> (IsGoodState(a_$134) && IsGoodState(b_$134)) )))) && ((forall  a_$135 : HeapType, b_$135 : ModuleName :: {IsGoodState(combine(a_$135,b_$135))} ( IsGoodState(combine(a_$135,b_$135)) <==> (IsGoodState(a_$135) && IsGoodState(b_$135)) )))) && ((forall  a_$136 : HeapType, b_$136 : TypeName :: {IsGoodState(combine(a_$136,b_$136))} ( IsGoodState(combine(a_$136,b_$136)) <==> (IsGoodState(a_$136) && IsGoodState(b_$136)) )))) && ((forall  a_$137 : HeapType, b_$137 : ArgSeq :: {IsGoodState(combine(a_$137,b_$137))} ( IsGoodState(combine(a_$137,b_$137)) <==> (IsGoodState(a_$137) && IsGoodState(b_$137)) )))) && ((forall  a_$138 : Field (Mu) , b_$138 : Boolean :: {IsGoodState(combine(a_$138,b_$138))} ( IsGoodState(combine(a_$138,b_$138)) <==> (IsGoodState(a_$138) && IsGoodState(b_$138)) )))) && ((forall  a_$139 : Field (Mu) , b_$139 : Integer :: {IsGoodState(combine(a_$139,b_$139))} ( IsGoodState(combine(a_$139,b_$139)) <==> (IsGoodState(a_$139) && IsGoodState(b_$139)) )))) && ((forall  a_$140 : Field (Mu) , b_$140 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$140,b_$140))} ( IsGoodState(combine(a_$140,b_$140)) <==> (IsGoodState(a_$140) && IsGoodState(b_$140)) )))) && ((forall  a_$141 : Field (Mu) , b_$141 : PermissionComponent :: {IsGoodState(combine(a_$141,b_$141))} ( IsGoodState(combine(a_$141,b_$141)) <==> (IsGoodState(a_$141) && IsGoodState(b_$141)) )))) && ((forall  a_$142 : Field (Mu) , b_$142 : MaskType :: {IsGoodState(combine(a_$142,b_$142))} ( IsGoodState(combine(a_$142,b_$142)) <==> (IsGoodState(a_$142) && IsGoodState(b_$142)) )))) && ((forall  a_$143 : Field (Mu) , b_$143 : ref :: {IsGoodState(combine(a_$143,b_$143))} ( IsGoodState(combine(a_$143,b_$143)) <==> (IsGoodState(a_$143) && IsGoodState(b_$143)) )))) && ((forall  a_$144 : Field (Mu) , b_$144 : Field (Integer)  :: {IsGoodState(combine(a_$144,b_$144))} ( IsGoodState(combine(a_$144,b_$144)) <==> (IsGoodState(a_$144) && IsGoodState(b_$144)) )))) && ((forall  a_$145 : Field (Mu) , b_$145 : HeapType :: {IsGoodState(combine(a_$145,b_$145))} ( IsGoodState(combine(a_$145,b_$145)) <==> (IsGoodState(a_$145) && IsGoodState(b_$145)) )))) && ((forall  a_$146 : Field (Mu) , b_$146 : Field (Mu)  :: {IsGoodState(combine(a_$146,b_$146))} ( IsGoodState(combine(a_$146,b_$146)) <==> (IsGoodState(a_$146) && IsGoodState(b_$146)) )))) && ((forall  a_$147 : Field (Mu) , b_$147 : Mu :: {IsGoodState(combine(a_$147,b_$147))} ( IsGoodState(combine(a_$147,b_$147)) <==> (IsGoodState(a_$147) && IsGoodState(b_$147)) )))) && ((forall  a_$148 : Field (Mu) , b_$148 : Field (Boolean)  :: {IsGoodState(combine(a_$148,b_$148))} ( IsGoodState(combine(a_$148,b_$148)) <==> (IsGoodState(a_$148) && IsGoodState(b_$148)) )))) && ((forall  a_$149 : Field (Mu) , b_$149 : CreditsType :: {IsGoodState(combine(a_$149,b_$149))} ( IsGoodState(combine(a_$149,b_$149)) <==> (IsGoodState(a_$149) && IsGoodState(b_$149)) )))) && ((forall  a_$150 : Field (Mu) , b_$150 : Field (ref)  :: {IsGoodState(combine(a_$150,b_$150))} ( IsGoodState(combine(a_$150,b_$150)) <==> (IsGoodState(a_$150) && IsGoodState(b_$150)) )))) && ((forall  a_$151 : Field (Mu) , b_$151 : Field (HeapType)  :: {IsGoodState(combine(a_$151,b_$151))} ( IsGoodState(combine(a_$151,b_$151)) <==> (IsGoodState(a_$151) && IsGoodState(b_$151)) )))) && ((forall  a_$152 : Field (Mu) , b_$152 : ModuleName :: {IsGoodState(combine(a_$152,b_$152))} ( IsGoodState(combine(a_$152,b_$152)) <==> (IsGoodState(a_$152) && IsGoodState(b_$152)) )))) && ((forall  a_$153 : Field (Mu) , b_$153 : TypeName :: {IsGoodState(combine(a_$153,b_$153))} ( IsGoodState(combine(a_$153,b_$153)) <==> (IsGoodState(a_$153) && IsGoodState(b_$153)) )))) && ((forall  a_$154 : Field (Mu) , b_$154 : ArgSeq :: {IsGoodState(combine(a_$154,b_$154))} ( IsGoodState(combine(a_$154,b_$154)) <==> (IsGoodState(a_$154) && IsGoodState(b_$154)) )))) && ((forall  a_$155 : Mu, b_$155 : Boolean :: {IsGoodState(combine(a_$155,b_$155))} ( IsGoodState(combine(a_$155,b_$155)) <==> (IsGoodState(a_$155) && IsGoodState(b_$155)) )))) && ((forall  a_$156 : Mu, b_$156 : Integer :: {IsGoodState(combine(a_$156,b_$156))} ( IsGoodState(combine(a_$156,b_$156)) <==> (IsGoodState(a_$156) && IsGoodState(b_$156)) )))) && ((forall  a_$157 : Mu, b_$157 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$157,b_$157))} ( IsGoodState(combine(a_$157,b_$157)) <==> (IsGoodState(a_$157) && IsGoodState(b_$157)) )))) && ((forall  a_$158 : Mu, b_$158 : PermissionComponent :: {IsGoodState(combine(a_$158,b_$158))} ( IsGoodState(combine(a_$158,b_$158)) <==> (IsGoodState(a_$158) && IsGoodState(b_$158)) )))) && ((forall  a_$159 : Mu, b_$159 : MaskType :: {IsGoodState(combine(a_$159,b_$159))} ( IsGoodState(combine(a_$159,b_$159)) <==> (IsGoodState(a_$159) && IsGoodState(b_$159)) )))) && ((forall  a_$160 : Mu, b_$160 : ref :: {IsGoodState(combine(a_$160,b_$160))} ( IsGoodState(combine(a_$160,b_$160)) <==> (IsGoodState(a_$160) && IsGoodState(b_$160)) )))) && ((forall  a_$161 : Mu, b_$161 : Field (Integer)  :: {IsGoodState(combine(a_$161,b_$161))} ( IsGoodState(combine(a_$161,b_$161)) <==> (IsGoodState(a_$161) && IsGoodState(b_$161)) )))) && ((forall  a_$162 : Mu, b_$162 : HeapType :: {IsGoodState(combine(a_$162,b_$162))} ( IsGoodState(combine(a_$162,b_$162)) <==> (IsGoodState(a_$162) && IsGoodState(b_$162)) )))) && ((forall  a_$163 : Mu, b_$163 : Field (Mu)  :: {IsGoodState(combine(a_$163,b_$163))} ( IsGoodState(combine(a_$163,b_$163)) <==> (IsGoodState(a_$163) && IsGoodState(b_$163)) )))) && ((forall  a_$164 : Mu, b_$164 : Mu :: {IsGoodState(combine(a_$164,b_$164))} ( IsGoodState(combine(a_$164,b_$164)) <==> (IsGoodState(a_$164) && IsGoodState(b_$164)) )))) && ((forall  a_$165 : Mu, b_$165 : Field (Boolean)  :: {IsGoodState(combine(a_$165,b_$165))} ( IsGoodState(combine(a_$165,b_$165)) <==> (IsGoodState(a_$165) && IsGoodState(b_$165)) )))) && ((forall  a_$166 : Mu, b_$166 : CreditsType :: {IsGoodState(combine(a_$166,b_$166))} ( IsGoodState(combine(a_$166,b_$166)) <==> (IsGoodState(a_$166) && IsGoodState(b_$166)) )))) && ((forall  a_$167 : Mu, b_$167 : Field (ref)  :: {IsGoodState(combine(a_$167,b_$167))} ( IsGoodState(combine(a_$167,b_$167)) <==> (IsGoodState(a_$167) && IsGoodState(b_$167)) )))) && ((forall  a_$168 : Mu, b_$168 : Field (HeapType)  :: {IsGoodState(combine(a_$168,b_$168))} ( IsGoodState(combine(a_$168,b_$168)) <==> (IsGoodState(a_$168) && IsGoodState(b_$168)) )))) && ((forall  a_$169 : Mu, b_$169 : ModuleName :: {IsGoodState(combine(a_$169,b_$169))} ( IsGoodState(combine(a_$169,b_$169)) <==> (IsGoodState(a_$169) && IsGoodState(b_$169)) )))) && ((forall  a_$170 : Mu, b_$170 : TypeName :: {IsGoodState(combine(a_$170,b_$170))} ( IsGoodState(combine(a_$170,b_$170)) <==> (IsGoodState(a_$170) && IsGoodState(b_$170)) )))) && ((forall  a_$171 : Mu, b_$171 : ArgSeq :: {IsGoodState(combine(a_$171,b_$171))} ( IsGoodState(combine(a_$171,b_$171)) <==> (IsGoodState(a_$171) && IsGoodState(b_$171)) )))) && ((forall  a_$172 : Field (Boolean) , b_$172 : Boolean :: {IsGoodState(combine(a_$172,b_$172))} ( IsGoodState(combine(a_$172,b_$172)) <==> (IsGoodState(a_$172) && IsGoodState(b_$172)) )))) && ((forall  a_$173 : Field (Boolean) , b_$173 : Integer :: {IsGoodState(combine(a_$173,b_$173))} ( IsGoodState(combine(a_$173,b_$173)) <==> (IsGoodState(a_$173) && IsGoodState(b_$173)) )))) && ((forall  a_$174 : Field (Boolean) , b_$174 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$174,b_$174))} ( IsGoodState(combine(a_$174,b_$174)) <==> (IsGoodState(a_$174) && IsGoodState(b_$174)) )))) && ((forall  a_$175 : Field (Boolean) , b_$175 : PermissionComponent :: {IsGoodState(combine(a_$175,b_$175))} ( IsGoodState(combine(a_$175,b_$175)) <==> (IsGoodState(a_$175) && IsGoodState(b_$175)) )))) && ((forall  a_$176 : Field (Boolean) , b_$176 : MaskType :: {IsGoodState(combine(a_$176,b_$176))} ( IsGoodState(combine(a_$176,b_$176)) <==> (IsGoodState(a_$176) && IsGoodState(b_$176)) )))) && ((forall  a_$177 : Field (Boolean) , b_$177 : ref :: {IsGoodState(combine(a_$177,b_$177))} ( IsGoodState(combine(a_$177,b_$177)) <==> (IsGoodState(a_$177) && IsGoodState(b_$177)) )))) && ((forall  a_$178 : Field (Boolean) , b_$178 : Field (Integer)  :: {IsGoodState(combine(a_$178,b_$178))} ( IsGoodState(combine(a_$178,b_$178)) <==> (IsGoodState(a_$178) && IsGoodState(b_$178)) )))) && ((forall  a_$179 : Field (Boolean) , b_$179 : HeapType :: {IsGoodState(combine(a_$179,b_$179))} ( IsGoodState(combine(a_$179,b_$179)) <==> (IsGoodState(a_$179) && IsGoodState(b_$179)) )))) && ((forall  a_$180 : Field (Boolean) , b_$180 : Field (Mu)  :: {IsGoodState(combine(a_$180,b_$180))} ( IsGoodState(combine(a_$180,b_$180)) <==> (IsGoodState(a_$180) && IsGoodState(b_$180)) )))) && ((forall  a_$181 : Field (Boolean) , b_$181 : Mu :: {IsGoodState(combine(a_$181,b_$181))} ( IsGoodState(combine(a_$181,b_$181)) <==> (IsGoodState(a_$181) && IsGoodState(b_$181)) )))) && ((forall  a_$182 : Field (Boolean) , b_$182 : Field (Boolean)  :: {IsGoodState(combine(a_$182,b_$182))} ( IsGoodState(combine(a_$182,b_$182)) <==> (IsGoodState(a_$182) && IsGoodState(b_$182)) )))) && ((forall  a_$183 : Field (Boolean) , b_$183 : CreditsType :: {IsGoodState(combine(a_$183,b_$183))} ( IsGoodState(combine(a_$183,b_$183)) <==> (IsGoodState(a_$183) && IsGoodState(b_$183)) )))) && ((forall  a_$184 : Field (Boolean) , b_$184 : Field (ref)  :: {IsGoodState(combine(a_$184,b_$184))} ( IsGoodState(combine(a_$184,b_$184)) <==> (IsGoodState(a_$184) && IsGoodState(b_$184)) )))) && ((forall  a_$185 : Field (Boolean) , b_$185 : Field (HeapType)  :: {IsGoodState(combine(a_$185,b_$185))} ( IsGoodState(combine(a_$185,b_$185)) <==> (IsGoodState(a_$185) && IsGoodState(b_$185)) )))) && ((forall  a_$186 : Field (Boolean) , b_$186 : ModuleName :: {IsGoodState(combine(a_$186,b_$186))} ( IsGoodState(combine(a_$186,b_$186)) <==> (IsGoodState(a_$186) && IsGoodState(b_$186)) )))) && ((forall  a_$187 : Field (Boolean) , b_$187 : TypeName :: {IsGoodState(combine(a_$187,b_$187))} ( IsGoodState(combine(a_$187,b_$187)) <==> (IsGoodState(a_$187) && IsGoodState(b_$187)) )))) && ((forall  a_$188 : Field (Boolean) , b_$188 : ArgSeq :: {IsGoodState(combine(a_$188,b_$188))} ( IsGoodState(combine(a_$188,b_$188)) <==> (IsGoodState(a_$188) && IsGoodState(b_$188)) )))) && ((forall  a_$189 : CreditsType, b_$189 : Boolean :: {IsGoodState(combine(a_$189,b_$189))} ( IsGoodState(combine(a_$189,b_$189)) <==> (IsGoodState(a_$189) && IsGoodState(b_$189)) )))) && ((forall  a_$190 : CreditsType, b_$190 : Integer :: {IsGoodState(combine(a_$190,b_$190))} ( IsGoodState(combine(a_$190,b_$190)) <==> (IsGoodState(a_$190) && IsGoodState(b_$190)) )))) && ((forall  a_$191 : CreditsType, b_$191 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$191,b_$191))} ( IsGoodState(combine(a_$191,b_$191)) <==> (IsGoodState(a_$191) && IsGoodState(b_$191)) )))) && ((forall  a_$192 : CreditsType, b_$192 : PermissionComponent :: {IsGoodState(combine(a_$192,b_$192))} ( IsGoodState(combine(a_$192,b_$192)) <==> (IsGoodState(a_$192) && IsGoodState(b_$192)) )))) && ((forall  a_$193 : CreditsType, b_$193 : MaskType :: {IsGoodState(combine(a_$193,b_$193))} ( IsGoodState(combine(a_$193,b_$193)) <==> (IsGoodState(a_$193) && IsGoodState(b_$193)) )))) && ((forall  a_$194 : CreditsType, b_$194 : ref :: {IsGoodState(combine(a_$194,b_$194))} ( IsGoodState(combine(a_$194,b_$194)) <==> (IsGoodState(a_$194) && IsGoodState(b_$194)) )))) && ((forall  a_$195 : CreditsType, b_$195 : Field (Integer)  :: {IsGoodState(combine(a_$195,b_$195))} ( IsGoodState(combine(a_$195,b_$195)) <==> (IsGoodState(a_$195) && IsGoodState(b_$195)) )))) && ((forall  a_$196 : CreditsType, b_$196 : HeapType :: {IsGoodState(combine(a_$196,b_$196))} ( IsGoodState(combine(a_$196,b_$196)) <==> (IsGoodState(a_$196) && IsGoodState(b_$196)) )))) && ((forall  a_$197 : CreditsType, b_$197 : Field (Mu)  :: {IsGoodState(combine(a_$197,b_$197))} ( IsGoodState(combine(a_$197,b_$197)) <==> (IsGoodState(a_$197) && IsGoodState(b_$197)) )))) && ((forall  a_$198 : CreditsType, b_$198 : Mu :: {IsGoodState(combine(a_$198,b_$198))} ( IsGoodState(combine(a_$198,b_$198)) <==> (IsGoodState(a_$198) && IsGoodState(b_$198)) )))) && ((forall  a_$199 : CreditsType, b_$199 : Field (Boolean)  :: {IsGoodState(combine(a_$199,b_$199))} ( IsGoodState(combine(a_$199,b_$199)) <==> (IsGoodState(a_$199) && IsGoodState(b_$199)) )))) && ((forall  a_$200 : CreditsType, b_$200 : CreditsType :: {IsGoodState(combine(a_$200,b_$200))} ( IsGoodState(combine(a_$200,b_$200)) <==> (IsGoodState(a_$200) && IsGoodState(b_$200)) )))) && ((forall  a_$201 : CreditsType, b_$201 : Field (ref)  :: {IsGoodState(combine(a_$201,b_$201))} ( IsGoodState(combine(a_$201,b_$201)) <==> (IsGoodState(a_$201) && IsGoodState(b_$201)) )))) && ((forall  a_$202 : CreditsType, b_$202 : Field (HeapType)  :: {IsGoodState(combine(a_$202,b_$202))} ( IsGoodState(combine(a_$202,b_$202)) <==> (IsGoodState(a_$202) && IsGoodState(b_$202)) )))) && ((forall  a_$203 : CreditsType, b_$203 : ModuleName :: {IsGoodState(combine(a_$203,b_$203))} ( IsGoodState(combine(a_$203,b_$203)) <==> (IsGoodState(a_$203) && IsGoodState(b_$203)) )))) && ((forall  a_$204 : CreditsType, b_$204 : TypeName :: {IsGoodState(combine(a_$204,b_$204))} ( IsGoodState(combine(a_$204,b_$204)) <==> (IsGoodState(a_$204) && IsGoodState(b_$204)) )))) && ((forall  a_$205 : CreditsType, b_$205 : ArgSeq :: {IsGoodState(combine(a_$205,b_$205))} ( IsGoodState(combine(a_$205,b_$205)) <==> (IsGoodState(a_$205) && IsGoodState(b_$205)) )))) && ((forall  a_$206 : Field (ref) , b_$206 : Boolean :: {IsGoodState(combine(a_$206,b_$206))} ( IsGoodState(combine(a_$206,b_$206)) <==> (IsGoodState(a_$206) && IsGoodState(b_$206)) )))) && ((forall  a_$207 : Field (ref) , b_$207 : Integer :: {IsGoodState(combine(a_$207,b_$207))} ( IsGoodState(combine(a_$207,b_$207)) <==> (IsGoodState(a_$207) && IsGoodState(b_$207)) )))) && ((forall  a_$208 : Field (ref) , b_$208 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$208,b_$208))} ( IsGoodState(combine(a_$208,b_$208)) <==> (IsGoodState(a_$208) && IsGoodState(b_$208)) )))) && ((forall  a_$209 : Field (ref) , b_$209 : PermissionComponent :: {IsGoodState(combine(a_$209,b_$209))} ( IsGoodState(combine(a_$209,b_$209)) <==> (IsGoodState(a_$209) && IsGoodState(b_$209)) )))) && ((forall  a_$210 : Field (ref) , b_$210 : MaskType :: {IsGoodState(combine(a_$210,b_$210))} ( IsGoodState(combine(a_$210,b_$210)) <==> (IsGoodState(a_$210) && IsGoodState(b_$210)) )))) && ((forall  a_$211 : Field (ref) , b_$211 : ref :: {IsGoodState(combine(a_$211,b_$211))} ( IsGoodState(combine(a_$211,b_$211)) <==> (IsGoodState(a_$211) && IsGoodState(b_$211)) )))) && ((forall  a_$212 : Field (ref) , b_$212 : Field (Integer)  :: {IsGoodState(combine(a_$212,b_$212))} ( IsGoodState(combine(a_$212,b_$212)) <==> (IsGoodState(a_$212) && IsGoodState(b_$212)) )))) && ((forall  a_$213 : Field (ref) , b_$213 : HeapType :: {IsGoodState(combine(a_$213,b_$213))} ( IsGoodState(combine(a_$213,b_$213)) <==> (IsGoodState(a_$213) && IsGoodState(b_$213)) )))) && ((forall  a_$214 : Field (ref) , b_$214 : Field (Mu)  :: {IsGoodState(combine(a_$214,b_$214))} ( IsGoodState(combine(a_$214,b_$214)) <==> (IsGoodState(a_$214) && IsGoodState(b_$214)) )))) && ((forall  a_$215 : Field (ref) , b_$215 : Mu :: {IsGoodState(combine(a_$215,b_$215))} ( IsGoodState(combine(a_$215,b_$215)) <==> (IsGoodState(a_$215) && IsGoodState(b_$215)) )))) && ((forall  a_$216 : Field (ref) , b_$216 : Field (Boolean)  :: {IsGoodState(combine(a_$216,b_$216))} ( IsGoodState(combine(a_$216,b_$216)) <==> (IsGoodState(a_$216) && IsGoodState(b_$216)) )))) && ((forall  a_$217 : Field (ref) , b_$217 : CreditsType :: {IsGoodState(combine(a_$217,b_$217))} ( IsGoodState(combine(a_$217,b_$217)) <==> (IsGoodState(a_$217) && IsGoodState(b_$217)) )))) && ((forall  a_$218 : Field (ref) , b_$218 : Field (ref)  :: {IsGoodState(combine(a_$218,b_$218))} ( IsGoodState(combine(a_$218,b_$218)) <==> (IsGoodState(a_$218) && IsGoodState(b_$218)) )))) && ((forall  a_$219 : Field (ref) , b_$219 : Field (HeapType)  :: {IsGoodState(combine(a_$219,b_$219))} ( IsGoodState(combine(a_$219,b_$219)) <==> (IsGoodState(a_$219) && IsGoodState(b_$219)) )))) && ((forall  a_$220 : Field (ref) , b_$220 : ModuleName :: {IsGoodState(combine(a_$220,b_$220))} ( IsGoodState(combine(a_$220,b_$220)) <==> (IsGoodState(a_$220) && IsGoodState(b_$220)) )))) && ((forall  a_$221 : Field (ref) , b_$221 : TypeName :: {IsGoodState(combine(a_$221,b_$221))} ( IsGoodState(combine(a_$221,b_$221)) <==> (IsGoodState(a_$221) && IsGoodState(b_$221)) )))) && ((forall  a_$222 : Field (ref) , b_$222 : ArgSeq :: {IsGoodState(combine(a_$222,b_$222))} ( IsGoodState(combine(a_$222,b_$222)) <==> (IsGoodState(a_$222) && IsGoodState(b_$222)) )))) && ((forall  a_$223 : Field (HeapType) , b_$223 : Boolean :: {IsGoodState(combine(a_$223,b_$223))} ( IsGoodState(combine(a_$223,b_$223)) <==> (IsGoodState(a_$223) && IsGoodState(b_$223)) )))) && ((forall  a_$224 : Field (HeapType) , b_$224 : Integer :: {IsGoodState(combine(a_$224,b_$224))} ( IsGoodState(combine(a_$224,b_$224)) <==> (IsGoodState(a_$224) && IsGoodState(b_$224)) )))) && ((forall  a_$225 : Field (HeapType) , b_$225 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$225,b_$225))} ( IsGoodState(combine(a_$225,b_$225)) <==> (IsGoodState(a_$225) && IsGoodState(b_$225)) )))) && ((forall  a_$226 : Field (HeapType) , b_$226 : PermissionComponent :: {IsGoodState(combine(a_$226,b_$226))} ( IsGoodState(combine(a_$226,b_$226)) <==> (IsGoodState(a_$226) && IsGoodState(b_$226)) )))) && ((forall  a_$227 : Field (HeapType) , b_$227 : MaskType :: {IsGoodState(combine(a_$227,b_$227))} ( IsGoodState(combine(a_$227,b_$227)) <==> (IsGoodState(a_$227) && IsGoodState(b_$227)) )))) && ((forall  a_$228 : Field (HeapType) , b_$228 : ref :: {IsGoodState(combine(a_$228,b_$228))} ( IsGoodState(combine(a_$228,b_$228)) <==> (IsGoodState(a_$228) && IsGoodState(b_$228)) )))) && ((forall  a_$229 : Field (HeapType) , b_$229 : Field (Integer)  :: {IsGoodState(combine(a_$229,b_$229))} ( IsGoodState(combine(a_$229,b_$229)) <==> (IsGoodState(a_$229) && IsGoodState(b_$229)) )))) && ((forall  a_$230 : Field (HeapType) , b_$230 : HeapType :: {IsGoodState(combine(a_$230,b_$230))} ( IsGoodState(combine(a_$230,b_$230)) <==> (IsGoodState(a_$230) && IsGoodState(b_$230)) )))) && ((forall  a_$231 : Field (HeapType) , b_$231 : Field (Mu)  :: {IsGoodState(combine(a_$231,b_$231))} ( IsGoodState(combine(a_$231,b_$231)) <==> (IsGoodState(a_$231) && IsGoodState(b_$231)) )))) && ((forall  a_$232 : Field (HeapType) , b_$232 : Mu :: {IsGoodState(combine(a_$232,b_$232))} ( IsGoodState(combine(a_$232,b_$232)) <==> (IsGoodState(a_$232) && IsGoodState(b_$232)) )))) && ((forall  a_$233 : Field (HeapType) , b_$233 : Field (Boolean)  :: {IsGoodState(combine(a_$233,b_$233))} ( IsGoodState(combine(a_$233,b_$233)) <==> (IsGoodState(a_$233) && IsGoodState(b_$233)) )))) && ((forall  a_$234 : Field (HeapType) , b_$234 : CreditsType :: {IsGoodState(combine(a_$234,b_$234))} ( IsGoodState(combine(a_$234,b_$234)) <==> (IsGoodState(a_$234) && IsGoodState(b_$234)) )))) && ((forall  a_$235 : Field (HeapType) , b_$235 : Field (ref)  :: {IsGoodState(combine(a_$235,b_$235))} ( IsGoodState(combine(a_$235,b_$235)) <==> (IsGoodState(a_$235) && IsGoodState(b_$235)) )))) && ((forall  a_$236 : Field (HeapType) , b_$236 : Field (HeapType)  :: {IsGoodState(combine(a_$236,b_$236))} ( IsGoodState(combine(a_$236,b_$236)) <==> (IsGoodState(a_$236) && IsGoodState(b_$236)) )))) && ((forall  a_$237 : Field (HeapType) , b_$237 : ModuleName :: {IsGoodState(combine(a_$237,b_$237))} ( IsGoodState(combine(a_$237,b_$237)) <==> (IsGoodState(a_$237) && IsGoodState(b_$237)) )))) && ((forall  a_$238 : Field (HeapType) , b_$238 : TypeName :: {IsGoodState(combine(a_$238,b_$238))} ( IsGoodState(combine(a_$238,b_$238)) <==> (IsGoodState(a_$238) && IsGoodState(b_$238)) )))) && ((forall  a_$239 : Field (HeapType) , b_$239 : ArgSeq :: {IsGoodState(combine(a_$239,b_$239))} ( IsGoodState(combine(a_$239,b_$239)) <==> (IsGoodState(a_$239) && IsGoodState(b_$239)) )))) && ((forall  a_$240 : ModuleName, b_$240 : Boolean :: {IsGoodState(combine(a_$240,b_$240))} ( IsGoodState(combine(a_$240,b_$240)) <==> (IsGoodState(a_$240) && IsGoodState(b_$240)) )))) && ((forall  a_$241 : ModuleName, b_$241 : Integer :: {IsGoodState(combine(a_$241,b_$241))} ( IsGoodState(combine(a_$241,b_$241)) <==> (IsGoodState(a_$241) && IsGoodState(b_$241)) )))) && ((forall  a_$242 : ModuleName, b_$242 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$242,b_$242))} ( IsGoodState(combine(a_$242,b_$242)) <==> (IsGoodState(a_$242) && IsGoodState(b_$242)) )))) && ((forall  a_$243 : ModuleName, b_$243 : PermissionComponent :: {IsGoodState(combine(a_$243,b_$243))} ( IsGoodState(combine(a_$243,b_$243)) <==> (IsGoodState(a_$243) && IsGoodState(b_$243)) )))) && ((forall  a_$244 : ModuleName, b_$244 : MaskType :: {IsGoodState(combine(a_$244,b_$244))} ( IsGoodState(combine(a_$244,b_$244)) <==> (IsGoodState(a_$244) && IsGoodState(b_$244)) )))) && ((forall  a_$245 : ModuleName, b_$245 : ref :: {IsGoodState(combine(a_$245,b_$245))} ( IsGoodState(combine(a_$245,b_$245)) <==> (IsGoodState(a_$245) && IsGoodState(b_$245)) )))) && ((forall  a_$246 : ModuleName, b_$246 : Field (Integer)  :: {IsGoodState(combine(a_$246,b_$246))} ( IsGoodState(combine(a_$246,b_$246)) <==> (IsGoodState(a_$246) && IsGoodState(b_$246)) )))) && ((forall  a_$247 : ModuleName, b_$247 : HeapType :: {IsGoodState(combine(a_$247,b_$247))} ( IsGoodState(combine(a_$247,b_$247)) <==> (IsGoodState(a_$247) && IsGoodState(b_$247)) )))) && ((forall  a_$248 : ModuleName, b_$248 : Field (Mu)  :: {IsGoodState(combine(a_$248,b_$248))} ( IsGoodState(combine(a_$248,b_$248)) <==> (IsGoodState(a_$248) && IsGoodState(b_$248)) )))) && ((forall  a_$249 : ModuleName, b_$249 : Mu :: {IsGoodState(combine(a_$249,b_$249))} ( IsGoodState(combine(a_$249,b_$249)) <==> (IsGoodState(a_$249) && IsGoodState(b_$249)) )))) && ((forall  a_$250 : ModuleName, b_$250 : Field (Boolean)  :: {IsGoodState(combine(a_$250,b_$250))} ( IsGoodState(combine(a_$250,b_$250)) <==> (IsGoodState(a_$250) && IsGoodState(b_$250)) )))) && ((forall  a_$251 : ModuleName, b_$251 : CreditsType :: {IsGoodState(combine(a_$251,b_$251))} ( IsGoodState(combine(a_$251,b_$251)) <==> (IsGoodState(a_$251) && IsGoodState(b_$251)) )))) && ((forall  a_$252 : ModuleName, b_$252 : Field (ref)  :: {IsGoodState(combine(a_$252,b_$252))} ( IsGoodState(combine(a_$252,b_$252)) <==> (IsGoodState(a_$252) && IsGoodState(b_$252)) )))) && ((forall  a_$253 : ModuleName, b_$253 : Field (HeapType)  :: {IsGoodState(combine(a_$253,b_$253))} ( IsGoodState(combine(a_$253,b_$253)) <==> (IsGoodState(a_$253) && IsGoodState(b_$253)) )))) && ((forall  a_$254 : ModuleName, b_$254 : ModuleName :: {IsGoodState(combine(a_$254,b_$254))} ( IsGoodState(combine(a_$254,b_$254)) <==> (IsGoodState(a_$254) && IsGoodState(b_$254)) )))) && ((forall  a_$255 : ModuleName, b_$255 : TypeName :: {IsGoodState(combine(a_$255,b_$255))} ( IsGoodState(combine(a_$255,b_$255)) <==> (IsGoodState(a_$255) && IsGoodState(b_$255)) )))) && ((forall  a_$256 : ModuleName, b_$256 : ArgSeq :: {IsGoodState(combine(a_$256,b_$256))} ( IsGoodState(combine(a_$256,b_$256)) <==> (IsGoodState(a_$256) && IsGoodState(b_$256)) )))) && ((forall  a_$257 : TypeName, b_$257 : Boolean :: {IsGoodState(combine(a_$257,b_$257))} ( IsGoodState(combine(a_$257,b_$257)) <==> (IsGoodState(a_$257) && IsGoodState(b_$257)) )))) && ((forall  a_$258 : TypeName, b_$258 : Integer :: {IsGoodState(combine(a_$258,b_$258))} ( IsGoodState(combine(a_$258,b_$258)) <==> (IsGoodState(a_$258) && IsGoodState(b_$258)) )))) && ((forall  a_$259 : TypeName, b_$259 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$259,b_$259))} ( IsGoodState(combine(a_$259,b_$259)) <==> (IsGoodState(a_$259) && IsGoodState(b_$259)) )))) && ((forall  a_$260 : TypeName, b_$260 : PermissionComponent :: {IsGoodState(combine(a_$260,b_$260))} ( IsGoodState(combine(a_$260,b_$260)) <==> (IsGoodState(a_$260) && IsGoodState(b_$260)) )))) && ((forall  a_$261 : TypeName, b_$261 : MaskType :: {IsGoodState(combine(a_$261,b_$261))} ( IsGoodState(combine(a_$261,b_$261)) <==> (IsGoodState(a_$261) && IsGoodState(b_$261)) )))) && ((forall  a_$262 : TypeName, b_$262 : ref :: {IsGoodState(combine(a_$262,b_$262))} ( IsGoodState(combine(a_$262,b_$262)) <==> (IsGoodState(a_$262) && IsGoodState(b_$262)) )))) && ((forall  a_$263 : TypeName, b_$263 : Field (Integer)  :: {IsGoodState(combine(a_$263,b_$263))} ( IsGoodState(combine(a_$263,b_$263)) <==> (IsGoodState(a_$263) && IsGoodState(b_$263)) )))) && ((forall  a_$264 : TypeName, b_$264 : HeapType :: {IsGoodState(combine(a_$264,b_$264))} ( IsGoodState(combine(a_$264,b_$264)) <==> (IsGoodState(a_$264) && IsGoodState(b_$264)) )))) && ((forall  a_$265 : TypeName, b_$265 : Field (Mu)  :: {IsGoodState(combine(a_$265,b_$265))} ( IsGoodState(combine(a_$265,b_$265)) <==> (IsGoodState(a_$265) && IsGoodState(b_$265)) )))) && ((forall  a_$266 : TypeName, b_$266 : Mu :: {IsGoodState(combine(a_$266,b_$266))} ( IsGoodState(combine(a_$266,b_$266)) <==> (IsGoodState(a_$266) && IsGoodState(b_$266)) )))) && ((forall  a_$267 : TypeName, b_$267 : Field (Boolean)  :: {IsGoodState(combine(a_$267,b_$267))} ( IsGoodState(combine(a_$267,b_$267)) <==> (IsGoodState(a_$267) && IsGoodState(b_$267)) )))) && ((forall  a_$268 : TypeName, b_$268 : CreditsType :: {IsGoodState(combine(a_$268,b_$268))} ( IsGoodState(combine(a_$268,b_$268)) <==> (IsGoodState(a_$268) && IsGoodState(b_$268)) )))) && ((forall  a_$269 : TypeName, b_$269 : Field (ref)  :: {IsGoodState(combine(a_$269,b_$269))} ( IsGoodState(combine(a_$269,b_$269)) <==> (IsGoodState(a_$269) && IsGoodState(b_$269)) )))) && ((forall  a_$270 : TypeName, b_$270 : Field (HeapType)  :: {IsGoodState(combine(a_$270,b_$270))} ( IsGoodState(combine(a_$270,b_$270)) <==> (IsGoodState(a_$270) && IsGoodState(b_$270)) )))) && ((forall  a_$271 : TypeName, b_$271 : ModuleName :: {IsGoodState(combine(a_$271,b_$271))} ( IsGoodState(combine(a_$271,b_$271)) <==> (IsGoodState(a_$271) && IsGoodState(b_$271)) )))) && ((forall  a_$272 : TypeName, b_$272 : TypeName :: {IsGoodState(combine(a_$272,b_$272))} ( IsGoodState(combine(a_$272,b_$272)) <==> (IsGoodState(a_$272) && IsGoodState(b_$272)) )))) && ((forall  a_$273 : TypeName, b_$273 : ArgSeq :: {IsGoodState(combine(a_$273,b_$273))} ( IsGoodState(combine(a_$273,b_$273)) <==> (IsGoodState(a_$273) && IsGoodState(b_$273)) )))) && ((forall  a_$274 : ArgSeq, b_$274 : Boolean :: {IsGoodState(combine(a_$274,b_$274))} ( IsGoodState(combine(a_$274,b_$274)) <==> (IsGoodState(a_$274) && IsGoodState(b_$274)) )))) && ((forall  a_$275 : ArgSeq, b_$275 : Integer :: {IsGoodState(combine(a_$275,b_$275))} ( IsGoodState(combine(a_$275,b_$275)) <==> (IsGoodState(a_$275) && IsGoodState(b_$275)) )))) && ((forall  a_$276 : ArgSeq, b_$276 : [PermissionComponent]Integer :: {IsGoodState(combine(a_$276,b_$276))} ( IsGoodState(combine(a_$276,b_$276)) <==> (IsGoodState(a_$276) && IsGoodState(b_$276)) )))) && ((forall  a_$277 : ArgSeq, b_$277 : PermissionComponent :: {IsGoodState(combine(a_$277,b_$277))} ( IsGoodState(combine(a_$277,b_$277)) <==> (IsGoodState(a_$277) && IsGoodState(b_$277)) )))) && ((forall  a_$278 : ArgSeq, b_$278 : MaskType :: {IsGoodState(combine(a_$278,b_$278))} ( IsGoodState(combine(a_$278,b_$278)) <==> (IsGoodState(a_$278) && IsGoodState(b_$278)) )))) && ((forall  a_$279 : ArgSeq, b_$279 : ref :: {IsGoodState(combine(a_$279,b_$279))} ( IsGoodState(combine(a_$279,b_$279)) <==> (IsGoodState(a_$279) && IsGoodState(b_$279)) )))) && ((forall  a_$280 : ArgSeq, b_$280 : Field (Integer)  :: {IsGoodState(combine(a_$280,b_$280))} ( IsGoodState(combine(a_$280,b_$280)) <==> (IsGoodState(a_$280) && IsGoodState(b_$280)) )))) && ((forall  a_$281 : ArgSeq, b_$281 : HeapType :: {IsGoodState(combine(a_$281,b_$281))} ( IsGoodState(combine(a_$281,b_$281)) <==> (IsGoodState(a_$281) && IsGoodState(b_$281)) )))) && ((forall  a_$282 : ArgSeq, b_$282 : Field (Mu)  :: {IsGoodState(combine(a_$282,b_$282))} ( IsGoodState(combine(a_$282,b_$282)) <==> (IsGoodState(a_$282) && IsGoodState(b_$282)) )))) && ((forall  a_$283 : ArgSeq, b_$283 : Mu :: {IsGoodState(combine(a_$283,b_$283))} ( IsGoodState(combine(a_$283,b_$283)) <==> (IsGoodState(a_$283) && IsGoodState(b_$283)) )))) && ((forall  a_$284 : ArgSeq, b_$284 : Field (Boolean)  :: {IsGoodState(combine(a_$284,b_$284))} ( IsGoodState(combine(a_$284,b_$284)) <==> (IsGoodState(a_$284) && IsGoodState(b_$284)) )))) && ((forall  a_$285 : ArgSeq, b_$285 : CreditsType :: {IsGoodState(combine(a_$285,b_$285))} ( IsGoodState(combine(a_$285,b_$285)) <==> (IsGoodState(a_$285) && IsGoodState(b_$285)) )))) && ((forall  a_$286 : ArgSeq, b_$286 : Field (ref)  :: {IsGoodState(combine(a_$286,b_$286))} ( IsGoodState(combine(a_$286,b_$286)) <==> (IsGoodState(a_$286) && IsGoodState(b_$286)) )))) && ((forall  a_$287 : ArgSeq, b_$287 : Field (HeapType)  :: {IsGoodState(combine(a_$287,b_$287))} ( IsGoodState(combine(a_$287,b_$287)) <==> (IsGoodState(a_$287) && IsGoodState(b_$287)) )))) && ((forall  a_$288 : ArgSeq, b_$288 : ModuleName :: {IsGoodState(combine(a_$288,b_$288))} ( IsGoodState(combine(a_$288,b_$288)) <==> (IsGoodState(a_$288) && IsGoodState(b_$288)) )))) && ((forall  a_$289 : ArgSeq, b_$289 : TypeName :: {IsGoodState(combine(a_$289,b_$289))} ( IsGoodState(combine(a_$289,b_$289)) <==> (IsGoodState(a_$289) && IsGoodState(b_$289)) )))) && ((forall  a_$290 : ArgSeq, b_$290 : ArgSeq :: {IsGoodState(combine(a_$290,b_$290))} ( IsGoodState(combine(a_$290,b_$290)) <==> (IsGoodState(a_$290) && IsGoodState(b_$290)) )));
	assume IsGoodState(nostate);
	assume NonPredicateField(mu);
	assume (forall  m : Mu, n_$0 : Mu :: {MuBelow(m,n_$0),MuBelow(n_$0,m)} ( !(MuBelow(m,n_$0) && MuBelow(n_$0,m)) ));
	assume (forall  m_$0 : Mu, n_$1 : Mu, o_$0 : Mu :: {MuBelow(m_$0,n_$1),MuBelow(n_$1,o_$0)} ( (MuBelow(m_$0,n_$1) && MuBelow(n_$1,o_$0)) ==> MuBelow(m_$0,o_$0) ));
	assume (forall  m_$1 : Mu, n_$2 : Mu :: ( MuBelow(m_$1,n_$2) ==> (!(n_$2 == $LockBottom)) ));
	assume NonPredicateField(held);
	assume NonPredicateField(rdheld);
	assume (forall  ih : HeapType, h : HeapType, m_$2 : MaskType :: {IsGoodInhaleState(ih,h,m_$2)} ( IsGoodInhaleState(ih,h,m_$2) <==> ((((((((((forall  o_$1_$0 : ref, f_$0_$0 : Field (Boolean)  :: {ih[o_$1_$0,f_$0_$0]} ( CanRead(m_$2,o_$1_$0,f_$0_$0) ==> (ih[o_$1_$0,f_$0_$0] == h[o_$1_$0,f_$0_$0]) ))) && ((forall  o_$1_$1 : ref, f_$0_$1 : Field (Integer)  :: {ih[o_$1_$1,f_$0_$1]} ( CanRead(m_$2,o_$1_$1,f_$0_$1) ==> (ih[o_$1_$1,f_$0_$1] == h[o_$1_$1,f_$0_$1]) )))) && ((forall  o_$1_$2 : ref, f_$0_$2 : Field (ref)  :: {ih[o_$1_$2,f_$0_$2]} ( CanRead(m_$2,o_$1_$2,f_$0_$2) ==> (ih[o_$1_$2,f_$0_$2] == h[o_$1_$2,f_$0_$2]) )))) && ((forall  o_$1_$3 : ref, f_$0_$3 : Field (HeapType)  :: {ih[o_$1_$3,f_$0_$3]} ( CanRead(m_$2,o_$1_$3,f_$0_$3) ==> (ih[o_$1_$3,f_$0_$3] == h[o_$1_$3,f_$0_$3]) )))) && ((forall  o_$1_$4 : ref, f_$0_$4 : Field (Mu)  :: {ih[o_$1_$4,f_$0_$4]} ( CanRead(m_$2,o_$1_$4,f_$0_$4) ==> (ih[o_$1_$4,f_$0_$4] == h[o_$1_$4,f_$0_$4]) )))) && ((forall  o_$2 : ref :: {ih[o_$2,held]} ( (0 < ih[o_$2,held]) <==> (0 < h[o_$2,held]) )))) && ((forall  o_$3 : ref :: {ih[o_$3,rdheld]} ( ih[o_$3,rdheld] <==> h[o_$3,rdheld] )))) && ((forall  o_$4 : ref :: {h[o_$4,held]} ( (0 < h[o_$4,held]) ==> (ih[o_$4,mu] == h[o_$4,mu]) )))) && ((forall  o_$5 : ref :: {h[o_$5,rdheld]} ( h[o_$5,rdheld] ==> (ih[o_$5,mu] == h[o_$5,mu]) )))) ));
	assume (((((forall  m_$3_$0 : MaskType, obj_$1 : ref, f_$1_$0 : Field (Boolean)  :: {CanRead(m_$3_$0,obj_$1,f_$1_$0)} {:expand  false}( CanRead(m_$3_$0,obj_$1,f_$1_$0) <==> ((0 < m_$3_$0[obj_$1,f_$1_$0][perm$R]) || (0 < m_$3_$0[obj_$1,f_$1_$0][perm$N])) ))) && ((forall  m_$3_$1 : MaskType, obj_$2 : ref, f_$1_$1 : Field (Integer)  :: {CanRead(m_$3_$1,obj_$2,f_$1_$1)} {:expand  false}( CanRead(m_$3_$1,obj_$2,f_$1_$1) <==> ((0 < m_$3_$1[obj_$2,f_$1_$1][perm$R]) || (0 < m_$3_$1[obj_$2,f_$1_$1][perm$N])) )))) && ((forall  m_$3_$2 : MaskType, obj_$3 : ref, f_$1_$2 : Field (ref)  :: {CanRead(m_$3_$2,obj_$3,f_$1_$2)} {:expand  false}( CanRead(m_$3_$2,obj_$3,f_$1_$2) <==> ((0 < m_$3_$2[obj_$3,f_$1_$2][perm$R]) || (0 < m_$3_$2[obj_$3,f_$1_$2][perm$N])) )))) && ((forall  m_$3_$3 : MaskType, obj_$4 : ref, f_$1_$3 : Field (HeapType)  :: {CanRead(m_$3_$3,obj_$4,f_$1_$3)} {:expand  false}( CanRead(m_$3_$3,obj_$4,f_$1_$3) <==> ((0 < m_$3_$3[obj_$4,f_$1_$3][perm$R]) || (0 < m_$3_$3[obj_$4,f_$1_$3][perm$N])) )))) && ((forall  m_$3_$4 : MaskType, obj_$5 : ref, f_$1_$4 : Field (Mu)  :: {CanRead(m_$3_$4,obj_$5,f_$1_$4)} {:expand  false}( CanRead(m_$3_$4,obj_$5,f_$1_$4) <==> ((0 < m_$3_$4[obj_$5,f_$1_$4][perm$R]) || (0 < m_$3_$4[obj_$5,f_$1_$4][perm$N])) )));
	assume (((((forall  m_$4_$0 : MaskType, obj_$0_$0 : ref, f_$2_$0 : Field (Boolean)  :: {CanWrite(m_$4_$0,obj_$0_$0,f_$2_$0)} {:expand  false}( CanWrite(m_$4_$0,obj_$0_$0,f_$2_$0) <==> ((m_$4_$0[obj_$0_$0,f_$2_$0][perm$R] == Permission$FullFraction) && (m_$4_$0[obj_$0_$0,f_$2_$0][perm$N] == 0)) ))) && ((forall  m_$4_$1 : MaskType, obj_$0_$1 : ref, f_$2_$1 : Field (Integer)  :: {CanWrite(m_$4_$1,obj_$0_$1,f_$2_$1)} {:expand  false}( CanWrite(m_$4_$1,obj_$0_$1,f_$2_$1) <==> ((m_$4_$1[obj_$0_$1,f_$2_$1][perm$R] == Permission$FullFraction) && (m_$4_$1[obj_$0_$1,f_$2_$1][perm$N] == 0)) )))) && ((forall  m_$4_$2 : MaskType, obj_$0_$2 : ref, f_$2_$2 : Field (ref)  :: {CanWrite(m_$4_$2,obj_$0_$2,f_$2_$2)} {:expand  false}( CanWrite(m_$4_$2,obj_$0_$2,f_$2_$2) <==> ((m_$4_$2[obj_$0_$2,f_$2_$2][perm$R] == Permission$FullFraction) && (m_$4_$2[obj_$0_$2,f_$2_$2][perm$N] == 0)) )))) && ((forall  m_$4_$3 : MaskType, obj_$0_$3 : ref, f_$2_$3 : Field (HeapType)  :: {CanWrite(m_$4_$3,obj_$0_$3,f_$2_$3)} {:expand  false}( CanWrite(m_$4_$3,obj_$0_$3,f_$2_$3) <==> ((m_$4_$3[obj_$0_$3,f_$2_$3][perm$R] == Permission$FullFraction) && (m_$4_$3[obj_$0_$3,f_$2_$3][perm$N] == 0)) )))) && ((forall  m_$4_$4 : MaskType, obj_$0_$4 : ref, f_$2_$4 : Field (Mu)  :: {CanWrite(m_$4_$4,obj_$0_$4,f_$2_$4)} {:expand  false}( CanWrite(m_$4_$4,obj_$0_$4,f_$2_$4) <==> ((m_$4_$4[obj_$0_$4,f_$2_$4][perm$R] == Permission$FullFraction) && (m_$4_$4[obj_$0_$4,f_$2_$4][perm$N] == 0)) )));
	assume (forall  m_$5 : MaskType :: {IsGoodMask(m_$5)} {:expand  true}( IsGoodMask(m_$5) <==> ((((((forall  o_$6_$0 : ref, f_$3_$0 : Field (Boolean)  :: ( ((0 <= m_$5[o_$6_$0,f_$3_$0][perm$R]) && (NonPredicateField(f_$3_$0) ==> ((m_$5[o_$6_$0,f_$3_$0][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6_$0,f_$3_$0][perm$N]) ==> (m_$5[o_$6_$0,f_$3_$0][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6_$0,f_$3_$0][perm$N] < 0) ==> (0 < m_$5[o_$6_$0,f_$3_$0][perm$R])) ))) && ((forall  o_$6_$1 : ref, f_$3_$1 : Field (Integer)  :: ( ((0 <= m_$5[o_$6_$1,f_$3_$1][perm$R]) && (NonPredicateField(f_$3_$1) ==> ((m_$5[o_$6_$1,f_$3_$1][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6_$1,f_$3_$1][perm$N]) ==> (m_$5[o_$6_$1,f_$3_$1][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6_$1,f_$3_$1][perm$N] < 0) ==> (0 < m_$5[o_$6_$1,f_$3_$1][perm$R])) )))) && ((forall  o_$6_$2 : ref, f_$3_$2 : Field (ref)  :: ( ((0 <= m_$5[o_$6_$2,f_$3_$2][perm$R]) && (NonPredicateField(f_$3_$2) ==> ((m_$5[o_$6_$2,f_$3_$2][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6_$2,f_$3_$2][perm$N]) ==> (m_$5[o_$6_$2,f_$3_$2][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6_$2,f_$3_$2][perm$N] < 0) ==> (0 < m_$5[o_$6_$2,f_$3_$2][perm$R])) )))) && ((forall  o_$6_$3 : ref, f_$3_$3 : Field (HeapType)  :: ( ((0 <= m_$5[o_$6_$3,f_$3_$3][perm$R]) && (NonPredicateField(f_$3_$3) ==> ((m_$5[o_$6_$3,f_$3_$3][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6_$3,f_$3_$3][perm$N]) ==> (m_$5[o_$6_$3,f_$3_$3][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6_$3,f_$3_$3][perm$N] < 0) ==> (0 < m_$5[o_$6_$3,f_$3_$3][perm$R])) )))) && ((forall  o_$6_$4 : ref, f_$3_$4 : Field (Mu)  :: ( ((0 <= m_$5[o_$6_$4,f_$3_$4][perm$R]) && (NonPredicateField(f_$3_$4) ==> ((m_$5[o_$6_$4,f_$3_$4][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6_$4,f_$3_$4][perm$N]) ==> (m_$5[o_$6_$4,f_$3_$4][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6_$4,f_$3_$4][perm$N] < 0) ==> (0 < m_$5[o_$6_$4,f_$3_$4][perm$R])) )))) ));
	assume (forall  h_$0 : HeapType, m_$6 : MaskType, o_$7 : ref, q : ref :: {wf(h_$0,m_$6),h_$0[o_$7,mu],h_$0[q,mu]} ( (((wf(h_$0,m_$6) && (!(o_$7 == q))) && ((0 < h_$0[o_$7,held]) || h_$0[o_$7,rdheld])) && ((0 < h_$0[q,held]) || h_$0[q,rdheld])) ==> (!(h_$0[o_$7,mu] == h_$0[q,mu])) ));
	assume (((((((((((((((((((((((((forall  m_$7_$0 : MaskType, o_$8_$0 : ref, f_$4_$0 : Field (Boolean) , howMuch_$3 : Integer, q_$0_$0 : ref, g_$4 : Field (Boolean)  :: {DecPerm(m_$7_$0,o_$8_$0,f_$4_$0,howMuch_$3)[q_$0_$0,g_$4][perm$R]} ( DecPerm(m_$7_$0,o_$8_$0,f_$4_$0,howMuch_$3)[q_$0_$0,g_$4][perm$R] == ite((o_$8_$0 == q_$0_$0) && (f_$4_$0 == g_$4),m_$7_$0[q_$0_$0,g_$4][perm$R] - howMuch_$3,m_$7_$0[q_$0_$0,g_$4][perm$R]) ))) && ((forall  m_$7_$1 : MaskType, o_$8_$1 : ref, f_$4_$1 : Field (Integer) , howMuch_$4 : Integer, q_$0_$1 : ref, g_$5 : Field (Boolean)  :: {DecPerm(m_$7_$1,o_$8_$1,f_$4_$1,howMuch_$4)[q_$0_$1,g_$5][perm$R]} ( DecPerm(m_$7_$1,o_$8_$1,f_$4_$1,howMuch_$4)[q_$0_$1,g_$5][perm$R] == ite((o_$8_$1 == q_$0_$1) && false,m_$7_$1[q_$0_$1,g_$5][perm$R] - howMuch_$4,m_$7_$1[q_$0_$1,g_$5][perm$R]) )))) && ((forall  m_$7_$2 : MaskType, o_$8_$2 : ref, f_$4_$2 : Field (ref) , howMuch_$5 : Integer, q_$0_$2 : ref, g_$6 : Field (Boolean)  :: {DecPerm(m_$7_$2,o_$8_$2,f_$4_$2,howMuch_$5)[q_$0_$2,g_$6][perm$R]} ( DecPerm(m_$7_$2,o_$8_$2,f_$4_$2,howMuch_$5)[q_$0_$2,g_$6][perm$R] == ite((o_$8_$2 == q_$0_$2) && false,m_$7_$2[q_$0_$2,g_$6][perm$R] - howMuch_$5,m_$7_$2[q_$0_$2,g_$6][perm$R]) )))) && ((forall  m_$7_$3 : MaskType, o_$8_$3 : ref, f_$4_$3 : Field (HeapType) , howMuch_$6 : Integer, q_$0_$3 : ref, g_$7 : Field (Boolean)  :: {DecPerm(m_$7_$3,o_$8_$3,f_$4_$3,howMuch_$6)[q_$0_$3,g_$7][perm$R]} ( DecPerm(m_$7_$3,o_$8_$3,f_$4_$3,howMuch_$6)[q_$0_$3,g_$7][perm$R] == ite((o_$8_$3 == q_$0_$3) && false,m_$7_$3[q_$0_$3,g_$7][perm$R] - howMuch_$6,m_$7_$3[q_$0_$3,g_$7][perm$R]) )))) && ((forall  m_$7_$4 : MaskType, o_$8_$4 : ref, f_$4_$4 : Field (Mu) , howMuch_$7 : Integer, q_$0_$4 : ref, g_$8 : Field (Boolean)  :: {DecPerm(m_$7_$4,o_$8_$4,f_$4_$4,howMuch_$7)[q_$0_$4,g_$8][perm$R]} ( DecPerm(m_$7_$4,o_$8_$4,f_$4_$4,howMuch_$7)[q_$0_$4,g_$8][perm$R] == ite((o_$8_$4 == q_$0_$4) && false,m_$7_$4[q_$0_$4,g_$8][perm$R] - howMuch_$7,m_$7_$4[q_$0_$4,g_$8][perm$R]) )))) && ((forall  m_$7_$5 : MaskType, o_$8_$5 : ref, f_$4_$5 : Field (Boolean) , howMuch_$8 : Integer, q_$0_$5 : ref, g_$9 : Field (Integer)  :: {DecPerm(m_$7_$5,o_$8_$5,f_$4_$5,howMuch_$8)[q_$0_$5,g_$9][perm$R]} ( DecPerm(m_$7_$5,o_$8_$5,f_$4_$5,howMuch_$8)[q_$0_$5,g_$9][perm$R] == ite((o_$8_$5 == q_$0_$5) && false,m_$7_$5[q_$0_$5,g_$9][perm$R] - howMuch_$8,m_$7_$5[q_$0_$5,g_$9][perm$R]) )))) && ((forall  m_$7_$6 : MaskType, o_$8_$6 : ref, f_$4_$6 : Field (Integer) , howMuch_$9 : Integer, q_$0_$6 : ref, g_$10 : Field (Integer)  :: {DecPerm(m_$7_$6,o_$8_$6,f_$4_$6,howMuch_$9)[q_$0_$6,g_$10][perm$R]} ( DecPerm(m_$7_$6,o_$8_$6,f_$4_$6,howMuch_$9)[q_$0_$6,g_$10][perm$R] == ite((o_$8_$6 == q_$0_$6) && (f_$4_$6 == g_$10),m_$7_$6[q_$0_$6,g_$10][perm$R] - howMuch_$9,m_$7_$6[q_$0_$6,g_$10][perm$R]) )))) && ((forall  m_$7_$7 : MaskType, o_$8_$7 : ref, f_$4_$7 : Field (ref) , howMuch_$10 : Integer, q_$0_$7 : ref, g_$11 : Field (Integer)  :: {DecPerm(m_$7_$7,o_$8_$7,f_$4_$7,howMuch_$10)[q_$0_$7,g_$11][perm$R]} ( DecPerm(m_$7_$7,o_$8_$7,f_$4_$7,howMuch_$10)[q_$0_$7,g_$11][perm$R] == ite((o_$8_$7 == q_$0_$7) && false,m_$7_$7[q_$0_$7,g_$11][perm$R] - howMuch_$10,m_$7_$7[q_$0_$7,g_$11][perm$R]) )))) && ((forall  m_$7_$8 : MaskType, o_$8_$8 : ref, f_$4_$8 : Field (HeapType) , howMuch_$11 : Integer, q_$0_$8 : ref, g_$12 : Field (Integer)  :: {DecPerm(m_$7_$8,o_$8_$8,f_$4_$8,howMuch_$11)[q_$0_$8,g_$12][perm$R]} ( DecPerm(m_$7_$8,o_$8_$8,f_$4_$8,howMuch_$11)[q_$0_$8,g_$12][perm$R] == ite((o_$8_$8 == q_$0_$8) && false,m_$7_$8[q_$0_$8,g_$12][perm$R] - howMuch_$11,m_$7_$8[q_$0_$8,g_$12][perm$R]) )))) && ((forall  m_$7_$9 : MaskType, o_$8_$9 : ref, f_$4_$9 : Field (Mu) , howMuch_$12 : Integer, q_$0_$9 : ref, g_$13 : Field (Integer)  :: {DecPerm(m_$7_$9,o_$8_$9,f_$4_$9,howMuch_$12)[q_$0_$9,g_$13][perm$R]} ( DecPerm(m_$7_$9,o_$8_$9,f_$4_$9,howMuch_$12)[q_$0_$9,g_$13][perm$R] == ite((o_$8_$9 == q_$0_$9) && false,m_$7_$9[q_$0_$9,g_$13][perm$R] - howMuch_$12,m_$7_$9[q_$0_$9,g_$13][perm$R]) )))) && ((forall  m_$7_$10 : MaskType, o_$8_$10 : ref, f_$4_$10 : Field (Boolean) , howMuch_$13 : Integer, q_$0_$10 : ref, g_$14 : Field (ref)  :: {DecPerm(m_$7_$10,o_$8_$10,f_$4_$10,howMuch_$13)[q_$0_$10,g_$14][perm$R]} ( DecPerm(m_$7_$10,o_$8_$10,f_$4_$10,howMuch_$13)[q_$0_$10,g_$14][perm$R] == ite((o_$8_$10 == q_$0_$10) && false,m_$7_$10[q_$0_$10,g_$14][perm$R] - howMuch_$13,m_$7_$10[q_$0_$10,g_$14][perm$R]) )))) && ((forall  m_$7_$11 : MaskType, o_$8_$11 : ref, f_$4_$11 : Field (Integer) , howMuch_$14 : Integer, q_$0_$11 : ref, g_$15 : Field (ref)  :: {DecPerm(m_$7_$11,o_$8_$11,f_$4_$11,howMuch_$14)[q_$0_$11,g_$15][perm$R]} ( DecPerm(m_$7_$11,o_$8_$11,f_$4_$11,howMuch_$14)[q_$0_$11,g_$15][perm$R] == ite((o_$8_$11 == q_$0_$11) && false,m_$7_$11[q_$0_$11,g_$15][perm$R] - howMuch_$14,m_$7_$11[q_$0_$11,g_$15][perm$R]) )))) && ((forall  m_$7_$12 : MaskType, o_$8_$12 : ref, f_$4_$12 : Field (ref) , howMuch_$15 : Integer, q_$0_$12 : ref, g_$16 : Field (ref)  :: {DecPerm(m_$7_$12,o_$8_$12,f_$4_$12,howMuch_$15)[q_$0_$12,g_$16][perm$R]} ( DecPerm(m_$7_$12,o_$8_$12,f_$4_$12,howMuch_$15)[q_$0_$12,g_$16][perm$R] == ite((o_$8_$12 == q_$0_$12) && (f_$4_$12 == g_$16),m_$7_$12[q_$0_$12,g_$16][perm$R] - howMuch_$15,m_$7_$12[q_$0_$12,g_$16][perm$R]) )))) && ((forall  m_$7_$13 : MaskType, o_$8_$13 : ref, f_$4_$13 : Field (HeapType) , howMuch_$16 : Integer, q_$0_$13 : ref, g_$17 : Field (ref)  :: {DecPerm(m_$7_$13,o_$8_$13,f_$4_$13,howMuch_$16)[q_$0_$13,g_$17][perm$R]} ( DecPerm(m_$7_$13,o_$8_$13,f_$4_$13,howMuch_$16)[q_$0_$13,g_$17][perm$R] == ite((o_$8_$13 == q_$0_$13) && false,m_$7_$13[q_$0_$13,g_$17][perm$R] - howMuch_$16,m_$7_$13[q_$0_$13,g_$17][perm$R]) )))) && ((forall  m_$7_$14 : MaskType, o_$8_$14 : ref, f_$4_$14 : Field (Mu) , howMuch_$17 : Integer, q_$0_$14 : ref, g_$18 : Field (ref)  :: {DecPerm(m_$7_$14,o_$8_$14,f_$4_$14,howMuch_$17)[q_$0_$14,g_$18][perm$R]} ( DecPerm(m_$7_$14,o_$8_$14,f_$4_$14,howMuch_$17)[q_$0_$14,g_$18][perm$R] == ite((o_$8_$14 == q_$0_$14) && false,m_$7_$14[q_$0_$14,g_$18][perm$R] - howMuch_$17,m_$7_$14[q_$0_$14,g_$18][perm$R]) )))) && ((forall  m_$7_$15 : MaskType, o_$8_$15 : ref, f_$4_$15 : Field (Boolean) , howMuch_$18 : Integer, q_$0_$15 : ref, g_$19 : Field (HeapType)  :: {DecPerm(m_$7_$15,o_$8_$15,f_$4_$15,howMuch_$18)[q_$0_$15,g_$19][perm$R]} ( DecPerm(m_$7_$15,o_$8_$15,f_$4_$15,howMuch_$18)[q_$0_$15,g_$19][perm$R] == ite((o_$8_$15 == q_$0_$15) && false,m_$7_$15[q_$0_$15,g_$19][perm$R] - howMuch_$18,m_$7_$15[q_$0_$15,g_$19][perm$R]) )))) && ((forall  m_$7_$16 : MaskType, o_$8_$16 : ref, f_$4_$16 : Field (Integer) , howMuch_$19 : Integer, q_$0_$16 : ref, g_$20 : Field (HeapType)  :: {DecPerm(m_$7_$16,o_$8_$16,f_$4_$16,howMuch_$19)[q_$0_$16,g_$20][perm$R]} ( DecPerm(m_$7_$16,o_$8_$16,f_$4_$16,howMuch_$19)[q_$0_$16,g_$20][perm$R] == ite((o_$8_$16 == q_$0_$16) && false,m_$7_$16[q_$0_$16,g_$20][perm$R] - howMuch_$19,m_$7_$16[q_$0_$16,g_$20][perm$R]) )))) && ((forall  m_$7_$17 : MaskType, o_$8_$17 : ref, f_$4_$17 : Field (ref) , howMuch_$20 : Integer, q_$0_$17 : ref, g_$21 : Field (HeapType)  :: {DecPerm(m_$7_$17,o_$8_$17,f_$4_$17,howMuch_$20)[q_$0_$17,g_$21][perm$R]} ( DecPerm(m_$7_$17,o_$8_$17,f_$4_$17,howMuch_$20)[q_$0_$17,g_$21][perm$R] == ite((o_$8_$17 == q_$0_$17) && false,m_$7_$17[q_$0_$17,g_$21][perm$R] - howMuch_$20,m_$7_$17[q_$0_$17,g_$21][perm$R]) )))) && ((forall  m_$7_$18 : MaskType, o_$8_$18 : ref, f_$4_$18 : Field (HeapType) , howMuch_$21 : Integer, q_$0_$18 : ref, g_$22 : Field (HeapType)  :: {DecPerm(m_$7_$18,o_$8_$18,f_$4_$18,howMuch_$21)[q_$0_$18,g_$22][perm$R]} ( DecPerm(m_$7_$18,o_$8_$18,f_$4_$18,howMuch_$21)[q_$0_$18,g_$22][perm$R] == ite((o_$8_$18 == q_$0_$18) && (f_$4_$18 == g_$22),m_$7_$18[q_$0_$18,g_$22][perm$R] - howMuch_$21,m_$7_$18[q_$0_$18,g_$22][perm$R]) )))) && ((forall  m_$7_$19 : MaskType, o_$8_$19 : ref, f_$4_$19 : Field (Mu) , howMuch_$22 : Integer, q_$0_$19 : ref, g_$23 : Field (HeapType)  :: {DecPerm(m_$7_$19,o_$8_$19,f_$4_$19,howMuch_$22)[q_$0_$19,g_$23][perm$R]} ( DecPerm(m_$7_$19,o_$8_$19,f_$4_$19,howMuch_$22)[q_$0_$19,g_$23][perm$R] == ite((o_$8_$19 == q_$0_$19) && false,m_$7_$19[q_$0_$19,g_$23][perm$R] - howMuch_$22,m_$7_$19[q_$0_$19,g_$23][perm$R]) )))) && ((forall  m_$7_$20 : MaskType, o_$8_$20 : ref, f_$4_$20 : Field (Boolean) , howMuch_$23 : Integer, q_$0_$20 : ref, g_$24 : Field (Mu)  :: {DecPerm(m_$7_$20,o_$8_$20,f_$4_$20,howMuch_$23)[q_$0_$20,g_$24][perm$R]} ( DecPerm(m_$7_$20,o_$8_$20,f_$4_$20,howMuch_$23)[q_$0_$20,g_$24][perm$R] == ite((o_$8_$20 == q_$0_$20) && false,m_$7_$20[q_$0_$20,g_$24][perm$R] - howMuch_$23,m_$7_$20[q_$0_$20,g_$24][perm$R]) )))) && ((forall  m_$7_$21 : MaskType, o_$8_$21 : ref, f_$4_$21 : Field (Integer) , howMuch_$24 : Integer, q_$0_$21 : ref, g_$25 : Field (Mu)  :: {DecPerm(m_$7_$21,o_$8_$21,f_$4_$21,howMuch_$24)[q_$0_$21,g_$25][perm$R]} ( DecPerm(m_$7_$21,o_$8_$21,f_$4_$21,howMuch_$24)[q_$0_$21,g_$25][perm$R] == ite((o_$8_$21 == q_$0_$21) && false,m_$7_$21[q_$0_$21,g_$25][perm$R] - howMuch_$24,m_$7_$21[q_$0_$21,g_$25][perm$R]) )))) && ((forall  m_$7_$22 : MaskType, o_$8_$22 : ref, f_$4_$22 : Field (ref) , howMuch_$25 : Integer, q_$0_$22 : ref, g_$26 : Field (Mu)  :: {DecPerm(m_$7_$22,o_$8_$22,f_$4_$22,howMuch_$25)[q_$0_$22,g_$26][perm$R]} ( DecPerm(m_$7_$22,o_$8_$22,f_$4_$22,howMuch_$25)[q_$0_$22,g_$26][perm$R] == ite((o_$8_$22 == q_$0_$22) && false,m_$7_$22[q_$0_$22,g_$26][perm$R] - howMuch_$25,m_$7_$22[q_$0_$22,g_$26][perm$R]) )))) && ((forall  m_$7_$23 : MaskType, o_$8_$23 : ref, f_$4_$23 : Field (HeapType) , howMuch_$26 : Integer, q_$0_$23 : ref, g_$27 : Field (Mu)  :: {DecPerm(m_$7_$23,o_$8_$23,f_$4_$23,howMuch_$26)[q_$0_$23,g_$27][perm$R]} ( DecPerm(m_$7_$23,o_$8_$23,f_$4_$23,howMuch_$26)[q_$0_$23,g_$27][perm$R] == ite((o_$8_$23 == q_$0_$23) && false,m_$7_$23[q_$0_$23,g_$27][perm$R] - howMuch_$26,m_$7_$23[q_$0_$23,g_$27][perm$R]) )))) && ((forall  m_$7_$24 : MaskType, o_$8_$24 : ref, f_$4_$24 : Field (Mu) , howMuch_$27 : Integer, q_$0_$24 : ref, g_$28 : Field (Mu)  :: {DecPerm(m_$7_$24,o_$8_$24,f_$4_$24,howMuch_$27)[q_$0_$24,g_$28][perm$R]} ( DecPerm(m_$7_$24,o_$8_$24,f_$4_$24,howMuch_$27)[q_$0_$24,g_$28][perm$R] == ite((o_$8_$24 == q_$0_$24) && (f_$4_$24 == g_$28),m_$7_$24[q_$0_$24,g_$28][perm$R] - howMuch_$27,m_$7_$24[q_$0_$24,g_$28][perm$R]) )));
	assume (((((((((((((((((((((((((forall  m_$9_$0 : MaskType, o_$10_$0 : ref, f_$6_$0 : Field (Boolean) , howMuch_$1_$0 : Integer, q_$2_$0 : ref, g_$1_$0 : Field (Boolean)  :: {IncPerm(m_$9_$0,o_$10_$0,f_$6_$0,howMuch_$1_$0)[q_$2_$0,g_$1_$0][perm$R]} ( IncPerm(m_$9_$0,o_$10_$0,f_$6_$0,howMuch_$1_$0)[q_$2_$0,g_$1_$0][perm$R] == ite((o_$10_$0 == q_$2_$0) && (f_$6_$0 == g_$1_$0),m_$9_$0[q_$2_$0,g_$1_$0][perm$R] + howMuch_$1_$0,m_$9_$0[q_$2_$0,g_$1_$0][perm$R]) ))) && ((forall  m_$9_$1 : MaskType, o_$10_$1 : ref, f_$6_$1 : Field (Integer) , howMuch_$1_$1 : Integer, q_$2_$1 : ref, g_$1_$1 : Field (Boolean)  :: {IncPerm(m_$9_$1,o_$10_$1,f_$6_$1,howMuch_$1_$1)[q_$2_$1,g_$1_$1][perm$R]} ( IncPerm(m_$9_$1,o_$10_$1,f_$6_$1,howMuch_$1_$1)[q_$2_$1,g_$1_$1][perm$R] == ite((o_$10_$1 == q_$2_$1) && false,m_$9_$1[q_$2_$1,g_$1_$1][perm$R] + howMuch_$1_$1,m_$9_$1[q_$2_$1,g_$1_$1][perm$R]) )))) && ((forall  m_$9_$2 : MaskType, o_$10_$2 : ref, f_$6_$2 : Field (ref) , howMuch_$1_$2 : Integer, q_$2_$2 : ref, g_$1_$2 : Field (Boolean)  :: {IncPerm(m_$9_$2,o_$10_$2,f_$6_$2,howMuch_$1_$2)[q_$2_$2,g_$1_$2][perm$R]} ( IncPerm(m_$9_$2,o_$10_$2,f_$6_$2,howMuch_$1_$2)[q_$2_$2,g_$1_$2][perm$R] == ite((o_$10_$2 == q_$2_$2) && false,m_$9_$2[q_$2_$2,g_$1_$2][perm$R] + howMuch_$1_$2,m_$9_$2[q_$2_$2,g_$1_$2][perm$R]) )))) && ((forall  m_$9_$3 : MaskType, o_$10_$3 : ref, f_$6_$3 : Field (HeapType) , howMuch_$1_$3 : Integer, q_$2_$3 : ref, g_$1_$3 : Field (Boolean)  :: {IncPerm(m_$9_$3,o_$10_$3,f_$6_$3,howMuch_$1_$3)[q_$2_$3,g_$1_$3][perm$R]} ( IncPerm(m_$9_$3,o_$10_$3,f_$6_$3,howMuch_$1_$3)[q_$2_$3,g_$1_$3][perm$R] == ite((o_$10_$3 == q_$2_$3) && false,m_$9_$3[q_$2_$3,g_$1_$3][perm$R] + howMuch_$1_$3,m_$9_$3[q_$2_$3,g_$1_$3][perm$R]) )))) && ((forall  m_$9_$4 : MaskType, o_$10_$4 : ref, f_$6_$4 : Field (Mu) , howMuch_$1_$4 : Integer, q_$2_$4 : ref, g_$1_$4 : Field (Boolean)  :: {IncPerm(m_$9_$4,o_$10_$4,f_$6_$4,howMuch_$1_$4)[q_$2_$4,g_$1_$4][perm$R]} ( IncPerm(m_$9_$4,o_$10_$4,f_$6_$4,howMuch_$1_$4)[q_$2_$4,g_$1_$4][perm$R] == ite((o_$10_$4 == q_$2_$4) && false,m_$9_$4[q_$2_$4,g_$1_$4][perm$R] + howMuch_$1_$4,m_$9_$4[q_$2_$4,g_$1_$4][perm$R]) )))) && ((forall  m_$9_$5 : MaskType, o_$10_$5 : ref, f_$6_$5 : Field (Boolean) , howMuch_$1_$5 : Integer, q_$2_$5 : ref, g_$1_$5 : Field (Integer)  :: {IncPerm(m_$9_$5,o_$10_$5,f_$6_$5,howMuch_$1_$5)[q_$2_$5,g_$1_$5][perm$R]} ( IncPerm(m_$9_$5,o_$10_$5,f_$6_$5,howMuch_$1_$5)[q_$2_$5,g_$1_$5][perm$R] == ite((o_$10_$5 == q_$2_$5) && false,m_$9_$5[q_$2_$5,g_$1_$5][perm$R] + howMuch_$1_$5,m_$9_$5[q_$2_$5,g_$1_$5][perm$R]) )))) && ((forall  m_$9_$6 : MaskType, o_$10_$6 : ref, f_$6_$6 : Field (Integer) , howMuch_$1_$6 : Integer, q_$2_$6 : ref, g_$1_$6 : Field (Integer)  :: {IncPerm(m_$9_$6,o_$10_$6,f_$6_$6,howMuch_$1_$6)[q_$2_$6,g_$1_$6][perm$R]} ( IncPerm(m_$9_$6,o_$10_$6,f_$6_$6,howMuch_$1_$6)[q_$2_$6,g_$1_$6][perm$R] == ite((o_$10_$6 == q_$2_$6) && (f_$6_$6 == g_$1_$6),m_$9_$6[q_$2_$6,g_$1_$6][perm$R] + howMuch_$1_$6,m_$9_$6[q_$2_$6,g_$1_$6][perm$R]) )))) && ((forall  m_$9_$7 : MaskType, o_$10_$7 : ref, f_$6_$7 : Field (ref) , howMuch_$1_$7 : Integer, q_$2_$7 : ref, g_$1_$7 : Field (Integer)  :: {IncPerm(m_$9_$7,o_$10_$7,f_$6_$7,howMuch_$1_$7)[q_$2_$7,g_$1_$7][perm$R]} ( IncPerm(m_$9_$7,o_$10_$7,f_$6_$7,howMuch_$1_$7)[q_$2_$7,g_$1_$7][perm$R] == ite((o_$10_$7 == q_$2_$7) && false,m_$9_$7[q_$2_$7,g_$1_$7][perm$R] + howMuch_$1_$7,m_$9_$7[q_$2_$7,g_$1_$7][perm$R]) )))) && ((forall  m_$9_$8 : MaskType, o_$10_$8 : ref, f_$6_$8 : Field (HeapType) , howMuch_$1_$8 : Integer, q_$2_$8 : ref, g_$1_$8 : Field (Integer)  :: {IncPerm(m_$9_$8,o_$10_$8,f_$6_$8,howMuch_$1_$8)[q_$2_$8,g_$1_$8][perm$R]} ( IncPerm(m_$9_$8,o_$10_$8,f_$6_$8,howMuch_$1_$8)[q_$2_$8,g_$1_$8][perm$R] == ite((o_$10_$8 == q_$2_$8) && false,m_$9_$8[q_$2_$8,g_$1_$8][perm$R] + howMuch_$1_$8,m_$9_$8[q_$2_$8,g_$1_$8][perm$R]) )))) && ((forall  m_$9_$9 : MaskType, o_$10_$9 : ref, f_$6_$9 : Field (Mu) , howMuch_$1_$9 : Integer, q_$2_$9 : ref, g_$1_$9 : Field (Integer)  :: {IncPerm(m_$9_$9,o_$10_$9,f_$6_$9,howMuch_$1_$9)[q_$2_$9,g_$1_$9][perm$R]} ( IncPerm(m_$9_$9,o_$10_$9,f_$6_$9,howMuch_$1_$9)[q_$2_$9,g_$1_$9][perm$R] == ite((o_$10_$9 == q_$2_$9) && false,m_$9_$9[q_$2_$9,g_$1_$9][perm$R] + howMuch_$1_$9,m_$9_$9[q_$2_$9,g_$1_$9][perm$R]) )))) && ((forall  m_$9_$10 : MaskType, o_$10_$10 : ref, f_$6_$10 : Field (Boolean) , howMuch_$1_$10 : Integer, q_$2_$10 : ref, g_$1_$10 : Field (ref)  :: {IncPerm(m_$9_$10,o_$10_$10,f_$6_$10,howMuch_$1_$10)[q_$2_$10,g_$1_$10][perm$R]} ( IncPerm(m_$9_$10,o_$10_$10,f_$6_$10,howMuch_$1_$10)[q_$2_$10,g_$1_$10][perm$R] == ite((o_$10_$10 == q_$2_$10) && false,m_$9_$10[q_$2_$10,g_$1_$10][perm$R] + howMuch_$1_$10,m_$9_$10[q_$2_$10,g_$1_$10][perm$R]) )))) && ((forall  m_$9_$11 : MaskType, o_$10_$11 : ref, f_$6_$11 : Field (Integer) , howMuch_$1_$11 : Integer, q_$2_$11 : ref, g_$1_$11 : Field (ref)  :: {IncPerm(m_$9_$11,o_$10_$11,f_$6_$11,howMuch_$1_$11)[q_$2_$11,g_$1_$11][perm$R]} ( IncPerm(m_$9_$11,o_$10_$11,f_$6_$11,howMuch_$1_$11)[q_$2_$11,g_$1_$11][perm$R] == ite((o_$10_$11 == q_$2_$11) && false,m_$9_$11[q_$2_$11,g_$1_$11][perm$R] + howMuch_$1_$11,m_$9_$11[q_$2_$11,g_$1_$11][perm$R]) )))) && ((forall  m_$9_$12 : MaskType, o_$10_$12 : ref, f_$6_$12 : Field (ref) , howMuch_$1_$12 : Integer, q_$2_$12 : ref, g_$1_$12 : Field (ref)  :: {IncPerm(m_$9_$12,o_$10_$12,f_$6_$12,howMuch_$1_$12)[q_$2_$12,g_$1_$12][perm$R]} ( IncPerm(m_$9_$12,o_$10_$12,f_$6_$12,howMuch_$1_$12)[q_$2_$12,g_$1_$12][perm$R] == ite((o_$10_$12 == q_$2_$12) && (f_$6_$12 == g_$1_$12),m_$9_$12[q_$2_$12,g_$1_$12][perm$R] + howMuch_$1_$12,m_$9_$12[q_$2_$12,g_$1_$12][perm$R]) )))) && ((forall  m_$9_$13 : MaskType, o_$10_$13 : ref, f_$6_$13 : Field (HeapType) , howMuch_$1_$13 : Integer, q_$2_$13 : ref, g_$1_$13 : Field (ref)  :: {IncPerm(m_$9_$13,o_$10_$13,f_$6_$13,howMuch_$1_$13)[q_$2_$13,g_$1_$13][perm$R]} ( IncPerm(m_$9_$13,o_$10_$13,f_$6_$13,howMuch_$1_$13)[q_$2_$13,g_$1_$13][perm$R] == ite((o_$10_$13 == q_$2_$13) && false,m_$9_$13[q_$2_$13,g_$1_$13][perm$R] + howMuch_$1_$13,m_$9_$13[q_$2_$13,g_$1_$13][perm$R]) )))) && ((forall  m_$9_$14 : MaskType, o_$10_$14 : ref, f_$6_$14 : Field (Mu) , howMuch_$1_$14 : Integer, q_$2_$14 : ref, g_$1_$14 : Field (ref)  :: {IncPerm(m_$9_$14,o_$10_$14,f_$6_$14,howMuch_$1_$14)[q_$2_$14,g_$1_$14][perm$R]} ( IncPerm(m_$9_$14,o_$10_$14,f_$6_$14,howMuch_$1_$14)[q_$2_$14,g_$1_$14][perm$R] == ite((o_$10_$14 == q_$2_$14) && false,m_$9_$14[q_$2_$14,g_$1_$14][perm$R] + howMuch_$1_$14,m_$9_$14[q_$2_$14,g_$1_$14][perm$R]) )))) && ((forall  m_$9_$15 : MaskType, o_$10_$15 : ref, f_$6_$15 : Field (Boolean) , howMuch_$1_$15 : Integer, q_$2_$15 : ref, g_$1_$15 : Field (HeapType)  :: {IncPerm(m_$9_$15,o_$10_$15,f_$6_$15,howMuch_$1_$15)[q_$2_$15,g_$1_$15][perm$R]} ( IncPerm(m_$9_$15,o_$10_$15,f_$6_$15,howMuch_$1_$15)[q_$2_$15,g_$1_$15][perm$R] == ite((o_$10_$15 == q_$2_$15) && false,m_$9_$15[q_$2_$15,g_$1_$15][perm$R] + howMuch_$1_$15,m_$9_$15[q_$2_$15,g_$1_$15][perm$R]) )))) && ((forall  m_$9_$16 : MaskType, o_$10_$16 : ref, f_$6_$16 : Field (Integer) , howMuch_$1_$16 : Integer, q_$2_$16 : ref, g_$1_$16 : Field (HeapType)  :: {IncPerm(m_$9_$16,o_$10_$16,f_$6_$16,howMuch_$1_$16)[q_$2_$16,g_$1_$16][perm$R]} ( IncPerm(m_$9_$16,o_$10_$16,f_$6_$16,howMuch_$1_$16)[q_$2_$16,g_$1_$16][perm$R] == ite((o_$10_$16 == q_$2_$16) && false,m_$9_$16[q_$2_$16,g_$1_$16][perm$R] + howMuch_$1_$16,m_$9_$16[q_$2_$16,g_$1_$16][perm$R]) )))) && ((forall  m_$9_$17 : MaskType, o_$10_$17 : ref, f_$6_$17 : Field (ref) , howMuch_$1_$17 : Integer, q_$2_$17 : ref, g_$1_$17 : Field (HeapType)  :: {IncPerm(m_$9_$17,o_$10_$17,f_$6_$17,howMuch_$1_$17)[q_$2_$17,g_$1_$17][perm$R]} ( IncPerm(m_$9_$17,o_$10_$17,f_$6_$17,howMuch_$1_$17)[q_$2_$17,g_$1_$17][perm$R] == ite((o_$10_$17 == q_$2_$17) && false,m_$9_$17[q_$2_$17,g_$1_$17][perm$R] + howMuch_$1_$17,m_$9_$17[q_$2_$17,g_$1_$17][perm$R]) )))) && ((forall  m_$9_$18 : MaskType, o_$10_$18 : ref, f_$6_$18 : Field (HeapType) , howMuch_$1_$18 : Integer, q_$2_$18 : ref, g_$1_$18 : Field (HeapType)  :: {IncPerm(m_$9_$18,o_$10_$18,f_$6_$18,howMuch_$1_$18)[q_$2_$18,g_$1_$18][perm$R]} ( IncPerm(m_$9_$18,o_$10_$18,f_$6_$18,howMuch_$1_$18)[q_$2_$18,g_$1_$18][perm$R] == ite((o_$10_$18 == q_$2_$18) && (f_$6_$18 == g_$1_$18),m_$9_$18[q_$2_$18,g_$1_$18][perm$R] + howMuch_$1_$18,m_$9_$18[q_$2_$18,g_$1_$18][perm$R]) )))) && ((forall  m_$9_$19 : MaskType, o_$10_$19 : ref, f_$6_$19 : Field (Mu) , howMuch_$1_$19 : Integer, q_$2_$19 : ref, g_$1_$19 : Field (HeapType)  :: {IncPerm(m_$9_$19,o_$10_$19,f_$6_$19,howMuch_$1_$19)[q_$2_$19,g_$1_$19][perm$R]} ( IncPerm(m_$9_$19,o_$10_$19,f_$6_$19,howMuch_$1_$19)[q_$2_$19,g_$1_$19][perm$R] == ite((o_$10_$19 == q_$2_$19) && false,m_$9_$19[q_$2_$19,g_$1_$19][perm$R] + howMuch_$1_$19,m_$9_$19[q_$2_$19,g_$1_$19][perm$R]) )))) && ((forall  m_$9_$20 : MaskType, o_$10_$20 : ref, f_$6_$20 : Field (Boolean) , howMuch_$1_$20 : Integer, q_$2_$20 : ref, g_$1_$20 : Field (Mu)  :: {IncPerm(m_$9_$20,o_$10_$20,f_$6_$20,howMuch_$1_$20)[q_$2_$20,g_$1_$20][perm$R]} ( IncPerm(m_$9_$20,o_$10_$20,f_$6_$20,howMuch_$1_$20)[q_$2_$20,g_$1_$20][perm$R] == ite((o_$10_$20 == q_$2_$20) && false,m_$9_$20[q_$2_$20,g_$1_$20][perm$R] + howMuch_$1_$20,m_$9_$20[q_$2_$20,g_$1_$20][perm$R]) )))) && ((forall  m_$9_$21 : MaskType, o_$10_$21 : ref, f_$6_$21 : Field (Integer) , howMuch_$1_$21 : Integer, q_$2_$21 : ref, g_$1_$21 : Field (Mu)  :: {IncPerm(m_$9_$21,o_$10_$21,f_$6_$21,howMuch_$1_$21)[q_$2_$21,g_$1_$21][perm$R]} ( IncPerm(m_$9_$21,o_$10_$21,f_$6_$21,howMuch_$1_$21)[q_$2_$21,g_$1_$21][perm$R] == ite((o_$10_$21 == q_$2_$21) && false,m_$9_$21[q_$2_$21,g_$1_$21][perm$R] + howMuch_$1_$21,m_$9_$21[q_$2_$21,g_$1_$21][perm$R]) )))) && ((forall  m_$9_$22 : MaskType, o_$10_$22 : ref, f_$6_$22 : Field (ref) , howMuch_$1_$22 : Integer, q_$2_$22 : ref, g_$1_$22 : Field (Mu)  :: {IncPerm(m_$9_$22,o_$10_$22,f_$6_$22,howMuch_$1_$22)[q_$2_$22,g_$1_$22][perm$R]} ( IncPerm(m_$9_$22,o_$10_$22,f_$6_$22,howMuch_$1_$22)[q_$2_$22,g_$1_$22][perm$R] == ite((o_$10_$22 == q_$2_$22) && false,m_$9_$22[q_$2_$22,g_$1_$22][perm$R] + howMuch_$1_$22,m_$9_$22[q_$2_$22,g_$1_$22][perm$R]) )))) && ((forall  m_$9_$23 : MaskType, o_$10_$23 : ref, f_$6_$23 : Field (HeapType) , howMuch_$1_$23 : Integer, q_$2_$23 : ref, g_$1_$23 : Field (Mu)  :: {IncPerm(m_$9_$23,o_$10_$23,f_$6_$23,howMuch_$1_$23)[q_$2_$23,g_$1_$23][perm$R]} ( IncPerm(m_$9_$23,o_$10_$23,f_$6_$23,howMuch_$1_$23)[q_$2_$23,g_$1_$23][perm$R] == ite((o_$10_$23 == q_$2_$23) && false,m_$9_$23[q_$2_$23,g_$1_$23][perm$R] + howMuch_$1_$23,m_$9_$23[q_$2_$23,g_$1_$23][perm$R]) )))) && ((forall  m_$9_$24 : MaskType, o_$10_$24 : ref, f_$6_$24 : Field (Mu) , howMuch_$1_$24 : Integer, q_$2_$24 : ref, g_$1_$24 : Field (Mu)  :: {IncPerm(m_$9_$24,o_$10_$24,f_$6_$24,howMuch_$1_$24)[q_$2_$24,g_$1_$24][perm$R]} ( IncPerm(m_$9_$24,o_$10_$24,f_$6_$24,howMuch_$1_$24)[q_$2_$24,g_$1_$24][perm$R] == ite((o_$10_$24 == q_$2_$24) && (f_$6_$24 == g_$1_$24),m_$9_$24[q_$2_$24,g_$1_$24][perm$R] + howMuch_$1_$24,m_$9_$24[q_$2_$24,g_$1_$24][perm$R]) )));
	assume (forall  o_$14 : ref :: ( ZeroCredits[o_$14] == 0 ));
	assume (((((forall  f_$10_$0 : Field (Boolean)  :: ( NonPredicateField(f_$10_$0) ==> (!PredicateField(f_$10_$0)) ))) && ((forall  f_$10_$1 : Field (Integer)  :: ( NonPredicateField(f_$10_$1) ==> (!PredicateField(f_$10_$1)) )))) && ((forall  f_$10_$2 : Field (ref)  :: ( NonPredicateField(f_$10_$2) ==> (!PredicateField(f_$10_$2)) )))) && ((forall  f_$10_$3 : Field (HeapType)  :: ( NonPredicateField(f_$10_$3) ==> (!PredicateField(f_$10_$3)) )))) && ((forall  f_$10_$4 : Field (Mu)  :: ( NonPredicateField(f_$10_$4) ==> (!PredicateField(f_$10_$4)) )));
	assume (((((forall  f_$11_$0 : Field (Boolean)  :: ( PredicateField(f_$11_$0) ==> (!NonPredicateField(f_$11_$0)) ))) && ((forall  f_$11_$1 : Field (Integer)  :: ( PredicateField(f_$11_$1) ==> (!NonPredicateField(f_$11_$1)) )))) && ((forall  f_$11_$2 : Field (ref)  :: ( PredicateField(f_$11_$2) ==> (!NonPredicateField(f_$11_$2)) )))) && ((forall  f_$11_$3 : Field (HeapType)  :: ( PredicateField(f_$11_$3) ==> (!NonPredicateField(f_$11_$3)) )))) && ((forall  f_$11_$4 : Field (Mu)  :: ( PredicateField(f_$11_$4) ==> (!NonPredicateField(f_$11_$4)) )));
	assume (((((((((((((((((forall  con_$1 : Boolean, a_$0_$0 : Boolean, b_$0_$0 : Boolean :: {ite(con_$1,a_$0_$0,b_$0_$0)} ( con_$1 ==> (ite(con_$1,a_$0_$0,b_$0_$0) == a_$0_$0) ))) && ((forall  con_$2 : Boolean, a_$0_$1 : Integer, b_$0_$1 : Integer :: {ite(con_$2,a_$0_$1,b_$0_$1)} ( con_$2 ==> (ite(con_$2,a_$0_$1,b_$0_$1) == a_$0_$1) )))) && ((forall  con_$3 : Boolean, a_$0_$2 : [PermissionComponent]Integer, b_$0_$2 : [PermissionComponent]Integer :: {ite(con_$3,a_$0_$2,b_$0_$2)} ( con_$3 ==> (ite(con_$3,a_$0_$2,b_$0_$2) == a_$0_$2) )))) && ((forall  con_$4 : Boolean, a_$0_$3 : PermissionComponent, b_$0_$3 : PermissionComponent :: {ite(con_$4,a_$0_$3,b_$0_$3)} ( con_$4 ==> (ite(con_$4,a_$0_$3,b_$0_$3) == a_$0_$3) )))) && ((forall  con_$5 : Boolean, a_$0_$4 : MaskType, b_$0_$4 : MaskType :: {ite(con_$5,a_$0_$4,b_$0_$4)} ( con_$5 ==> (ite(con_$5,a_$0_$4,b_$0_$4) == a_$0_$4) )))) && ((forall  con_$6 : Boolean, a_$0_$5 : ref, b_$0_$5 : ref :: {ite(con_$6,a_$0_$5,b_$0_$5)} ( con_$6 ==> (ite(con_$6,a_$0_$5,b_$0_$5) == a_$0_$5) )))) && ((forall  con_$7 : Boolean, a_$0_$6 : Field (Integer) , b_$0_$6 : Field (Integer)  :: {ite(con_$7,a_$0_$6,b_$0_$6)} ( con_$7 ==> (ite(con_$7,a_$0_$6,b_$0_$6) == a_$0_$6) )))) && ((forall  con_$8 : Boolean, a_$0_$7 : HeapType, b_$0_$7 : HeapType :: {ite(con_$8,a_$0_$7,b_$0_$7)} ( con_$8 ==> (ite(con_$8,a_$0_$7,b_$0_$7) == a_$0_$7) )))) && ((forall  con_$9 : Boolean, a_$0_$8 : Field (Mu) , b_$0_$8 : Field (Mu)  :: {ite(con_$9,a_$0_$8,b_$0_$8)} ( con_$9 ==> (ite(con_$9,a_$0_$8,b_$0_$8) == a_$0_$8) )))) && ((forall  con_$10 : Boolean, a_$0_$9 : Mu, b_$0_$9 : Mu :: {ite(con_$10,a_$0_$9,b_$0_$9)} ( con_$10 ==> (ite(con_$10,a_$0_$9,b_$0_$9) == a_$0_$9) )))) && ((forall  con_$11 : Boolean, a_$0_$10 : Field (Boolean) , b_$0_$10 : Field (Boolean)  :: {ite(con_$11,a_$0_$10,b_$0_$10)} ( con_$11 ==> (ite(con_$11,a_$0_$10,b_$0_$10) == a_$0_$10) )))) && ((forall  con_$12 : Boolean, a_$0_$11 : CreditsType, b_$0_$11 : CreditsType :: {ite(con_$12,a_$0_$11,b_$0_$11)} ( con_$12 ==> (ite(con_$12,a_$0_$11,b_$0_$11) == a_$0_$11) )))) && ((forall  con_$13 : Boolean, a_$0_$12 : Field (ref) , b_$0_$12 : Field (ref)  :: {ite(con_$13,a_$0_$12,b_$0_$12)} ( con_$13 ==> (ite(con_$13,a_$0_$12,b_$0_$12) == a_$0_$12) )))) && ((forall  con_$14 : Boolean, a_$0_$13 : Field (HeapType) , b_$0_$13 : Field (HeapType)  :: {ite(con_$14,a_$0_$13,b_$0_$13)} ( con_$14 ==> (ite(con_$14,a_$0_$13,b_$0_$13) == a_$0_$13) )))) && ((forall  con_$15 : Boolean, a_$0_$14 : ModuleName, b_$0_$14 : ModuleName :: {ite(con_$15,a_$0_$14,b_$0_$14)} ( con_$15 ==> (ite(con_$15,a_$0_$14,b_$0_$14) == a_$0_$14) )))) && ((forall  con_$16 : Boolean, a_$0_$15 : TypeName, b_$0_$15 : TypeName :: {ite(con_$16,a_$0_$15,b_$0_$15)} ( con_$16 ==> (ite(con_$16,a_$0_$15,b_$0_$15) == a_$0_$15) )))) && ((forall  con_$17 : Boolean, a_$0_$16 : ArgSeq, b_$0_$16 : ArgSeq :: {ite(con_$17,a_$0_$16,b_$0_$16)} ( con_$17 ==> (ite(con_$17,a_$0_$16,b_$0_$16) == a_$0_$16) )));
	assume (((((((((((((((((forall  con_$0_$0 : Boolean, a_$1_$0 : Boolean, b_$1_$0 : Boolean :: {ite(con_$0_$0,a_$1_$0,b_$1_$0)} ( (!con_$0_$0) ==> (ite(con_$0_$0,a_$1_$0,b_$1_$0) == b_$1_$0) ))) && ((forall  con_$0_$1 : Boolean, a_$1_$1 : Integer, b_$1_$1 : Integer :: {ite(con_$0_$1,a_$1_$1,b_$1_$1)} ( (!con_$0_$1) ==> (ite(con_$0_$1,a_$1_$1,b_$1_$1) == b_$1_$1) )))) && ((forall  con_$0_$2 : Boolean, a_$1_$2 : [PermissionComponent]Integer, b_$1_$2 : [PermissionComponent]Integer :: {ite(con_$0_$2,a_$1_$2,b_$1_$2)} ( (!con_$0_$2) ==> (ite(con_$0_$2,a_$1_$2,b_$1_$2) == b_$1_$2) )))) && ((forall  con_$0_$3 : Boolean, a_$1_$3 : PermissionComponent, b_$1_$3 : PermissionComponent :: {ite(con_$0_$3,a_$1_$3,b_$1_$3)} ( (!con_$0_$3) ==> (ite(con_$0_$3,a_$1_$3,b_$1_$3) == b_$1_$3) )))) && ((forall  con_$0_$4 : Boolean, a_$1_$4 : MaskType, b_$1_$4 : MaskType :: {ite(con_$0_$4,a_$1_$4,b_$1_$4)} ( (!con_$0_$4) ==> (ite(con_$0_$4,a_$1_$4,b_$1_$4) == b_$1_$4) )))) && ((forall  con_$0_$5 : Boolean, a_$1_$5 : ref, b_$1_$5 : ref :: {ite(con_$0_$5,a_$1_$5,b_$1_$5)} ( (!con_$0_$5) ==> (ite(con_$0_$5,a_$1_$5,b_$1_$5) == b_$1_$5) )))) && ((forall  con_$0_$6 : Boolean, a_$1_$6 : Field (Integer) , b_$1_$6 : Field (Integer)  :: {ite(con_$0_$6,a_$1_$6,b_$1_$6)} ( (!con_$0_$6) ==> (ite(con_$0_$6,a_$1_$6,b_$1_$6) == b_$1_$6) )))) && ((forall  con_$0_$7 : Boolean, a_$1_$7 : HeapType, b_$1_$7 : HeapType :: {ite(con_$0_$7,a_$1_$7,b_$1_$7)} ( (!con_$0_$7) ==> (ite(con_$0_$7,a_$1_$7,b_$1_$7) == b_$1_$7) )))) && ((forall  con_$0_$8 : Boolean, a_$1_$8 : Field (Mu) , b_$1_$8 : Field (Mu)  :: {ite(con_$0_$8,a_$1_$8,b_$1_$8)} ( (!con_$0_$8) ==> (ite(con_$0_$8,a_$1_$8,b_$1_$8) == b_$1_$8) )))) && ((forall  con_$0_$9 : Boolean, a_$1_$9 : Mu, b_$1_$9 : Mu :: {ite(con_$0_$9,a_$1_$9,b_$1_$9)} ( (!con_$0_$9) ==> (ite(con_$0_$9,a_$1_$9,b_$1_$9) == b_$1_$9) )))) && ((forall  con_$0_$10 : Boolean, a_$1_$10 : Field (Boolean) , b_$1_$10 : Field (Boolean)  :: {ite(con_$0_$10,a_$1_$10,b_$1_$10)} ( (!con_$0_$10) ==> (ite(con_$0_$10,a_$1_$10,b_$1_$10) == b_$1_$10) )))) && ((forall  con_$0_$11 : Boolean, a_$1_$11 : CreditsType, b_$1_$11 : CreditsType :: {ite(con_$0_$11,a_$1_$11,b_$1_$11)} ( (!con_$0_$11) ==> (ite(con_$0_$11,a_$1_$11,b_$1_$11) == b_$1_$11) )))) && ((forall  con_$0_$12 : Boolean, a_$1_$12 : Field (ref) , b_$1_$12 : Field (ref)  :: {ite(con_$0_$12,a_$1_$12,b_$1_$12)} ( (!con_$0_$12) ==> (ite(con_$0_$12,a_$1_$12,b_$1_$12) == b_$1_$12) )))) && ((forall  con_$0_$13 : Boolean, a_$1_$13 : Field (HeapType) , b_$1_$13 : Field (HeapType)  :: {ite(con_$0_$13,a_$1_$13,b_$1_$13)} ( (!con_$0_$13) ==> (ite(con_$0_$13,a_$1_$13,b_$1_$13) == b_$1_$13) )))) && ((forall  con_$0_$14 : Boolean, a_$1_$14 : ModuleName, b_$1_$14 : ModuleName :: {ite(con_$0_$14,a_$1_$14,b_$1_$14)} ( (!con_$0_$14) ==> (ite(con_$0_$14,a_$1_$14,b_$1_$14) == b_$1_$14) )))) && ((forall  con_$0_$15 : Boolean, a_$1_$15 : TypeName, b_$1_$15 : TypeName :: {ite(con_$0_$15,a_$1_$15,b_$1_$15)} ( (!con_$0_$15) ==> (ite(con_$0_$15,a_$1_$15,b_$1_$15) == b_$1_$15) )))) && ((forall  con_$0_$16 : Boolean, a_$1_$16 : ArgSeq, b_$1_$16 : ArgSeq :: {ite(con_$0_$16,a_$1_$16,b_$1_$16)} ( (!con_$0_$16) ==> (ite(con_$0_$16,a_$1_$16,b_$1_$16) == b_$1_$16) )));
	assume NonPredicateField(FactorialActorChannelExpEP.state);
	assume NonPredicateField(FactorialActorChannelExpEP.ch);
	assume NonPredicateField(FactorialActorChannelExpEP.expch);
	assume PredicateField(FactorialActorChannelExpEP.valid);
	assume NonPredicateField(FactorialActorChannelImpEP.state);
	assume NonPredicateField(FactorialActorChannelImpEP.ch);
	assume NonPredicateField(FactorialActorChannelImpEP.impch);
	assume PredicateField(FactorialActorChannelImpEP.valid);
	assume NonPredicateField(FactorialActorChannel.imp);
	assume NonPredicateField(FactorialActorChannel.exp);
	assume PredicateField(FactorialActorChannel.valid);
	assume PredicateField(FactorialActorChannel.initImpState);
	assume PredicateField(FactorialActorChannel.initExpState);
	assume NonPredicateField(FactorialContChannelExpEP.state);
	assume NonPredicateField(FactorialContChannelExpEP.ch);
	assume NonPredicateField(FactorialContChannelExpEP.expch);
	assume PredicateField(FactorialContChannelExpEP.valid);
	assume NonPredicateField(FactorialContChannelImpEP.state);
	assume NonPredicateField(FactorialContChannelImpEP.ch);
	assume NonPredicateField(FactorialContChannelImpEP.impch);
	assume PredicateField(FactorialContChannelImpEP.valid);
	assume NonPredicateField(FactorialContChannel.imp);
	assume NonPredicateField(FactorialContChannel.exp);
	assume PredicateField(FactorialContChannel.valid);
	assume PredicateField(FactorialContChannel.initImpState);
	assume PredicateField(FactorialContChannel.initExpState);
	assume NonPredicateField(FutureChannelExpEP.state);
	assume NonPredicateField(FutureChannelExpEP.ch);
	assume NonPredicateField(FutureChannelExpEP.expch);
	assume PredicateField(FutureChannelExpEP.valid);
	assume NonPredicateField(FutureChannelImpEP.state);
	assume NonPredicateField(FutureChannelImpEP.ch);
	assume NonPredicateField(FutureChannelImpEP.impch);
	assume PredicateField(FutureChannelImpEP.valid);
	assume NonPredicateField(FutureChannel.imp);
	assume NonPredicateField(FutureChannel.exp);
	assume PredicateField(FutureChannel.valid);
	assume PredicateField(FutureChannel.initImpState);
	assume PredicateField(FutureChannel.initExpState);
	assume NonPredicateField(Future.sent);
	assume NonPredicateField(Future.value);
	assume NonPredicateField(Future.q);
	assume (forall  Heap_$0 : HeapType, Mask_$0 : MaskType, this_$0 : ref :: {#Future.getQ(Heap_$0,Mask_$0,this_$0)} ( (wf(Heap_$0,Mask_$0) && (CurrentModule == module#default)) ==> (#Future.getQ(Heap_$0,Mask_$0,this_$0) == Heap_$0[this_$0,Future.q]) ));
	assume (forall  Heap_$1 : HeapType, Mask_$1 : MaskType, this_$1 : ref :: {#Future.getQ(Heap_$1,Mask_$1,this_$1)} ( ((wf(Heap_$1,Mask_$1) && IsGoodState(combine(nostate,combine(Heap_$1[this_$1,Future.q],Heap_$1[Heap_$1[this_$1,Future.q],FutureChannel.valid])))) && CanAssumeFunctionDefs) ==> (#Future.getQ(Heap_$1,Mask_$1,this_$1) == ##Future.getQ(combine(nostate,combine(Heap_$1[this_$1,Future.q],Heap_$1[Heap_$1[this_$1,Future.q],FutureChannel.valid])),this_$1)) ));
	assume NonPredicateField(Message.type);
	assume NonPredicateField(Message.sender1);
	assume NonPredicateField(Message.sender3);
	assume NonPredicateField(Message.sender2);
	assume NonPredicateField(Message.sender4);
	assume NonPredicateField(Message.receiver1);
	assume NonPredicateField(Message.receiver2);
	assume NonPredicateField(Message.receiver3);
	assume NonPredicateField(Message.receiver4);
	assume NonPredicateField(Message.v1);
	assume NonPredicateField(Message.vo1);
	assume NonPredicateField(Message.cust1);
	assume NonPredicateField(Message.vr1);
	assume NonPredicateField(Message.old1);
	assume NonPredicateField(Message.vr2);
	assume NonPredicateField(Message.old2);
	assume NonPredicateField(Message.vr3);
	assume (forall  Heap_$2 : HeapType, Mask_$2 : MaskType, this_$2 : ref, v#49 : Integer :: {#Message.factorial(Heap_$2,Mask_$2,this_$2,v#49)} ( (wf(Heap_$2,Mask_$2) && (CurrentModule == module#default)) ==> (#Message.factorial(Heap_$2,Mask_$2,this_$2,v#49) == ite(v#49 == 0,1,v#49 * #Message.factorial(Heap_$2,Mask_$2,this_$2,v#49 - 1))) ));
	assume (forall  Heap_$3 : HeapType, Mask_$3 : MaskType, this_$3 : ref, v#49_$0 : Integer :: {#Message.factorial(Heap_$3,Mask_$3,this_$3,v#49_$0)} ( #Message.factorial(Heap_$3,Mask_$3,this_$3,v#49_$0) == #Message.factorial#limited(Heap_$3,Mask_$3,this_$3,v#49_$0) ));
	assume (forall  Heap_$4 : HeapType, Mask_$4 : MaskType, this_$4 : ref, v#49_$1 : Integer :: {#Message.factorial#limited(Heap_$4,Mask_$4,this_$4,v#49_$1)} ( ((wf(Heap_$4,Mask_$4) && IsGoodState(combine(nostate,nostate))) && CanAssumeFunctionDefs) ==> (#Message.factorial#limited(Heap_$4,Mask_$4,this_$4,v#49_$1) == ##Message.factorial(combine(nostate,nostate),this_$4,v#49_$1)) ));
	assume (forall  Heap_$5 : HeapType, Mask_$5 : MaskType, this_$5 : ref, v#49_$2 : Integer :: {#Message.factorial(Heap_$5,Mask_$5,this_$5,v#49_$2)} ( (wf(Heap_$5,Mask_$5) && CanAssumeFunctionDefs) ==> ((v#49_$2 == 0) ==> (#Message.factorial(Heap_$5,Mask_$5,this_$5,v#49_$2) == 1)) ));
	assume (forall  Heap_$6 : HeapType, Mask_$6 : MaskType, this_$6 : ref, v#49_$3 : Integer :: {#Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3)} ( (wf(Heap_$6,Mask_$6) && CanAssumeFunctionDefs) ==> ((v#49_$3 > 0) ==> (#Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3) == (v#49_$3 * #Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3 - 1)))) ));
	assume PredicateField(Message.invValue);
	assume PredicateField(Message.invResult1);
	assume PredicateField(Message.invResult2);
	assume PredicateField(Message.invFinalResult);
	assume PredicateField(Message.inv);
	assume NonPredicateField(FactorialActor.q);
	assume (forall  Heap_$7 : HeapType, Mask_$7 : MaskType, this_$7 : ref :: {#FactorialActor.getQ(Heap_$7,Mask_$7,this_$7)} ( (wf(Heap_$7,Mask_$7) && (CurrentModule == module#default)) ==> (#FactorialActor.getQ(Heap_$7,Mask_$7,this_$7) == Heap_$7[this_$7,FactorialActor.q]) ));
	assume (forall  Heap_$8 : HeapType, Mask_$8 : MaskType, this_$8 : ref :: {#FactorialActor.getQ(Heap_$8,Mask_$8,this_$8)} ( ((wf(Heap_$8,Mask_$8) && IsGoodState(combine(nostate,combine(Heap_$8[this_$8,FactorialActor.q],Heap_$8[Heap_$8[this_$8,FactorialActor.q],FactorialActorChannel.valid])))) && CanAssumeFunctionDefs) ==> (#FactorialActor.getQ(Heap_$8,Mask_$8,this_$8) == ##FactorialActor.getQ(combine(nostate,combine(Heap_$8[this_$8,FactorialActor.q],Heap_$8[Heap_$8[this_$8,FactorialActor.q],FactorialActorChannel.valid])),this_$8)) ));
	assume NonPredicateField(FactorialCont.q);
	assume NonPredicateField(FactorialCont.v);
	assume NonPredicateField(FactorialCont.vo);
	assume NonPredicateField(FactorialCont.cust);
	assume (forall  Heap_$9 : HeapType, Mask_$9 : MaskType, this_$9 : ref :: {#FactorialCont.getQ(Heap_$9,Mask_$9,this_$9)} ( (wf(Heap_$9,Mask_$9) && (CurrentModule == module#default)) ==> (#FactorialCont.getQ(Heap_$9,Mask_$9,this_$9) == Heap_$9[this_$9,FactorialCont.q]) ));
	assume (forall  Heap_$10 : HeapType, Mask_$10 : MaskType, this_$10 : ref :: {#FactorialCont.getQ(Heap_$10,Mask_$10,this_$10)} ( ((wf(Heap_$10,Mask_$10) && IsGoodState(combine(nostate,combine(Heap_$10[this_$10,FactorialCont.q],Heap_$10[Heap_$10[this_$10,FactorialCont.q],FactorialContChannel.valid])))) && CanAssumeFunctionDefs) ==> (#FactorialCont.getQ(Heap_$10,Mask_$10,this_$10) == ##FactorialCont.getQ(combine(nostate,combine(Heap_$10[this_$10,FactorialCont.q],Heap_$10[Heap_$10[this_$10,FactorialCont.q],FactorialContChannel.valid])),this_$10)) ));
	goto PreconditionGeneratedEntry;
$exit:
	assume false;
PreconditionGeneratedEntry:
	assume IsGoodMask(Mask);
	assume (this == null) || (dtype(this) == FactorialActor#t);
	assume (current#67 == null) || (dtype(current#67) == Message#t);
	assume (this#127 == null) || (dtype(this#127) == Channel#t);
	assume (msg#128 == null) || (dtype(msg#128) == Message#t);
	assume (this#129 == null) || (dtype(this#129) == FactorialActorChannelImpEP#t);
	assume (mi#130 == null) || (dtype(mi#130) == Message#t);
	assume (mo#131 == null) || (dtype(mo#131) == Message#t);
	assume (m#69 == null) || (dtype(m#69) == Message#t);
	assume (this#132 == null) || (dtype(this#132) == Message#t);
	assume true;
	assume (receiver#134 == null) || (dtype(receiver#134) == Future#t);
	assume (this#135 == null) || (dtype(this#135) == FutureChannelExpEP#t);
	assume (m#136 == null) || (dtype(m#136) == Message#t);
	assume (m#71 == null) || (dtype(m#71) == Message#t);
	assume (this#137 == null) || (dtype(this#137) == Message#t);
	assume true;
	assume (oldv#139 == null) || (dtype(oldv#139) == FactorialActor#t);
	assume (receiver#140 == null) || (dtype(receiver#140) == FactorialCont#t);
	assume (this#141 == null) || (dtype(this#141) == FactorialContChannelExpEP#t);
	assume (m#142 == null) || (dtype(m#142) == Message#t);
	assume (r#73 == null) || (dtype(r#73) == Message#t);
	assume (cont#75 == null) || (dtype(cont#75) == FactorialCont#t);
	assume (this#143 == null) || (dtype(this#143) == FactorialCont#t);
	assume true;
	assume true;
	assume (custp#146 == null) || (dtype(custp#146) == FactorialCont#t);
	assume (this#147 == null) || (dtype(this#147) == FactorialCont#t);
	assume (m#77 == null) || (dtype(m#77) == Message#t);
	assume (this#148 == null) || (dtype(this#148) == Message#t);
	assume true;
	assume true;
	assume (cust#151 == null) || (dtype(cust#151) == FactorialCont#t);
	assume (receiver#152 == null) || (dtype(receiver#152) == FactorialActor#t);
	assume (this#153 == null) || (dtype(this#153) == FactorialActorChannelExpEP#t);
	assume (m#154 == null) || (dtype(m#154) == Message#t);
	assume (r#79 == null) || (dtype(r#79) == Message#t);
	assume !(this == null);
	assume wf(Heap,Mask);
	goto anon0;
anon0:
	assume (0 < methodK#_1151) && ((1000 * methodK#_1151) < Fractions(1));
	assume CurrentModule == module#default;
	assume CanAssumeFunctionDefs;
	assume IsGoodInhaleState(inhaleHeap#_1153_$_0,Heap,ZeroMask);
	assume !(this == null);
	assume Heap_$_0 == Heap[this,FactorialActor.q := inhaleHeap#_1153_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_0,ZeroMask);
	assume (Heap_$_0[this,FactorialActor.q] == null) || (dtype(Heap_$_0[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_0 == ZeroMask[this,FactorialActor.q := ZeroMask[this,FactorialActor.q][perm$R := ZeroMask[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_0);
	assume IsGoodState(inhaleHeap#_1153_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_0,Mask_$_0);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_0);
	assume !(Heap_$_0[this,FactorialActor.q] == null);
	assume !(Heap_$_0[this,FactorialActor.q] == null);
	assume Heap_$_1 == Heap_$_0[Heap_$_0[this,FactorialActor.q],FactorialActorChannel.valid := inhaleHeap#_1153_$_0[Heap_$_0[this,FactorialActor.q],FactorialActorChannel.valid]];
	assume wf(Heap_$_1,Mask_$_0);
	assume inhaleHeap#_1153_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid] == Heap_$_1;
	assume Fractions(100) > 0;
	assume Mask_$_1 == Mask_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid := Mask_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid][perm$R := Mask_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_1);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid]);
	assume wf(Heap_$_1,Mask_$_1);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_1);
	assume !(Heap_$_1[this,FactorialActor.q] == null);
	assume Heap_$_2 == Heap_$_1[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.initImpState := inhaleHeap#_1153_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.initImpState]];
	assume wf(Heap_$_2,Mask_$_1);
	assume inhaleHeap#_1153_$_0[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState] == Heap_$_2;
	assume Fractions(100) > 0;
	assume Mask_$_2 == Mask_$_1[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState := Mask_$_1[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R := Mask_$_1[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_2);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState]);
	assume wf(Heap_$_2,Mask_$_2);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_2);
	assume !(Heap_$_2[this,FactorialActor.q] == null);
	assume Heap_$_3 == Heap_$_2[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initExpState := inhaleHeap#_1153_$_0[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initExpState]];
	assume wf(Heap_$_3,Mask_$_2);
	assume inhaleHeap#_1153_$_0[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState] == Heap_$_3;
	assume Fractions(100) > 0;
	assume Mask_$_3 == Mask_$_2[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState := Mask_$_2[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R := Mask_$_2[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_3);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState]);
	assume wf(Heap_$_3,Mask_$_3);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_3);
	assume !(Heap_$_3[this,FactorialActor.q] == null);
	assume Heap_$_4 == Heap_$_3[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1153_$_0[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_4,Mask_$_3);
	assume (Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_4 == Mask_$_3[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_3[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_3[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_4);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_4,Mask_$_4);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_4);
	assume !(Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_5 == Heap_$_4[Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1153_$_0[Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_5,Mask_$_4);
	assume (Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_5 == Mask_$_4[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_4[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_4[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_5);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_5,Mask_$_5);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_5);
	assume !(Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Credits_$_0 == ZeroCredits[Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := ZeroCredits[Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_5);
	assume wf(Heap_$_5,Mask_$_5);
	assume Heap_$_5 == Heap;
	assume Mask_$_5 == Mask;
	assume Credits_$_0 == Credits;
	assume ((0 < unfoldK#_1154) && (unfoldK#_1154 < Fractions(1))) && ((1000 * unfoldK#_1154) < methodK#_1151);
	assert { :msg "  738.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  738.10: Location might not be readable." } true ==> CanRead(Mask_$_5,this,FactorialActor.q);
	assert { :msg "  738.3: The target of the fold statement might be null." } !(Heap_$_5[this,FactorialActor.q] == null);
	assert { :msg "  738.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  738.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.valid." } (Fractions(100) <= Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R]) ==> (0 <= Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$N]));
	assume exhaleMask#_1155_$_0 == Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid := Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R := Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_5);
	assume wf(Heap_$_5,Mask_$_5);
	assume wf(Heap_$_5,exhaleMask#_1155_$_0);
	assume wf(Heap_$_5,exhaleMask#_1155_$_0);
	assume inhaleHeap#_1157_$_0 == Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid];
	assume IsGoodInhaleState(inhaleHeap#_1157_$_0,Heap_$_5,exhaleMask#_1155_$_0);
	assume !(Heap_$_5[this,FactorialActor.q] == null);
	assume Heap_$_6 == Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1157_$_0[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_6,exhaleMask#_1155_$_0);
	assume (Heap_$_6[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_6[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_6 == exhaleMask#_1155_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1155_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1155_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_6);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_6,Mask_$_6);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_6);
	assume !(Heap_$_6[this,FactorialActor.q] == null);
	assume Heap_$_7 == Heap_$_6[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1157_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_7,Mask_$_6);
	assume (Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_7 == Mask_$_6[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_6[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_6[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_7);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_7,Mask_$_7);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_7);
	assume !(Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_8 == Heap_$_7[Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1157_$_0[Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_8,Mask_$_7);
	assume (Heap_$_8[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_8[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_8 == Mask_$_7[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_7[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_7[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_8);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_8,Mask_$_8);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_8);
	assume !(Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_9 == Heap_$_8[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch := inhaleHeap#_1157_$_0[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch]];
	assume wf(Heap_$_9,Mask_$_8);
	assume (Heap_$_9[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch] == null) || (dtype(Heap_$_9[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_9 == Mask_$_8[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch := Mask_$_8[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch][perm$R := Mask_$_8[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_9);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch]);
	assume wf(Heap_$_9,Mask_$_9);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_9);
	assume !(Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume !(Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_10 == Heap_$_9[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid := inhaleHeap#_1157_$_0[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid]];
	assume wf(Heap_$_10,Mask_$_9);
	assume inhaleHeap#_1157_$_0[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid] == Heap_$_10;
	assume Fractions(100) > 0;
	assume Mask_$_10 == Mask_$_9[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid := Mask_$_9[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R := Mask_$_9[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_10);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid]);
	assume wf(Heap_$_10,Mask_$_10);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_10);
	assume !(Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_11 == Heap_$_10[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1157_$_0[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_11,Mask_$_10);
	assume inhaleHeap#_1157_$_0[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_11;
	assume Fractions(100) > 0;
	assume Mask_$_11 == Mask_$_10[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_10[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_10[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_11);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_11,Mask_$_11);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_11);
	assume Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == Heap_$_11[this,FactorialActor.q];
	assume Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch] == Heap_$_11[this,FactorialActor.q];
	assume IsGoodMask(Mask_$_11);
	assume wf(Heap_$_11,Mask_$_11);
	assume ((0 < unfoldK#_1158) && (unfoldK#_1158 < Fractions(1))) && ((1000 * unfoldK#_1158) < methodK#_1151);
	assert { :msg "  739.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  739.10: Location might not be readable." } true ==> CanRead(Mask_$_11,this,FactorialActor.q);
	assert { :msg "  739.10: Receiver might be null." } true ==> (!(Heap_$_11[this,FactorialActor.q] == null));
	assert { :msg "  739.10: Location might not be readable." } true ==> CanRead(Mask_$_11,Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  739.3: The target of the fold statement might be null." } !(Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  739.3: unfold might fail because the predicate FactorialActorChannelImpEP.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  739.3: unfold might fail because the predicate FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannelImpEP.valid." } (Fractions(100) <= Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$N]));
	assume exhaleMask#_1159_$_0 == Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid := Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R := Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_11);
	assume wf(Heap_$_11,Mask_$_11);
	assume wf(Heap_$_11,exhaleMask#_1159_$_0);
	assume wf(Heap_$_11,exhaleMask#_1159_$_0);
	assume inhaleHeap#_1161_$_0 == Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid];
	assume IsGoodInhaleState(inhaleHeap#_1161_$_0,Heap_$_11,exhaleMask#_1159_$_0);
	assume !(Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_12 == Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1161_$_0[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_12,exhaleMask#_1159_$_0);
	assume (Heap_$_12[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_12[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_12 == exhaleMask#_1159_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := exhaleMask#_1159_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1159_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_12);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_12,Mask_$_12);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_12);
	assume !(Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_13 == Heap_$_12[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1161_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_13,Mask_$_12);
	assume (Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_13 == Mask_$_12[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_12[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_12[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_13);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_13,Mask_$_13);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_13);
	assume !(Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null);
	assume !(Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null);
	assume Heap_$_14 == Heap_$_13[Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp := inhaleHeap#_1161_$_0[Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp]];
	assume wf(Heap_$_14,Mask_$_13);
	assume (Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp] == null) || (dtype(Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_14 == Mask_$_13[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp := Mask_$_13[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp][perm$R := Mask_$_13[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_14);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp]);
	assume wf(Heap_$_14,Mask_$_14);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_14);
	assume !(Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp] == null);
	assume !(Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null);
	assume Heap_$_15 == Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp := inhaleHeap#_1161_$_0[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp]];
	assume wf(Heap_$_15,Mask_$_14);
	assume (Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp] == null) || (dtype(Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_15 == Mask_$_14[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp := Mask_$_14[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp][perm$R := Mask_$_14[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_15);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp]);
	assume wf(Heap_$_15,Mask_$_15);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_15);
	assume !(Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp] == null);
	assume !(Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp] == null);
	assume Heap_$_16 == Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1161_$_0[Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_16,Mask_$_15);
	assume (Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_16 == Mask_$_15[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_15[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_15[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_16);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_16,Mask_$_16);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_16);
	assume !(Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume !(Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp] == null);
	assume Heap_$_17 == Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch := inhaleHeap#_1161_$_0[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch]];
	assume wf(Heap_$_17,Mask_$_16);
	assume (Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch] == null) || (dtype(Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_17 == Mask_$_16[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch := Mask_$_16[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch][perm$R := Mask_$_16[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_17);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch]);
	assume wf(Heap_$_17,Mask_$_17);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_17);
	assume !(Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch] == null);
	assume !(Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_18 == Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1161_$_0[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_18,Mask_$_17);
	assume true;
	assume monitorK > 0;
	assume Mask_$_18 == Mask_$_17[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_17[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_17[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_18);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_18,Mask_$_18);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_18);
	assume !(Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch] == null);
	assume Heap_$_19 == Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu := inhaleHeap#_1161_$_0[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu]];
	assume wf(Heap_$_19,Mask_$_18);
	assume true;
	assume monitorK > 0;
	assume Mask_$_19 == Mask_$_18[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu := Mask_$_18[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu][perm$R := Mask_$_18[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_19);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu]);
	assume wf(Heap_$_19,Mask_$_19);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_19);
	assume IsGoodMask(Mask_$_19);
	assume wf(Heap_$_19,Mask_$_19);
	assume ((0 < unfoldK#_1162) && (unfoldK#_1162 < Fractions(1))) && ((1000 * unfoldK#_1162) < methodK#_1151);
	assert { :msg "  740.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  740.10: Location might not be readable." } true ==> CanRead(Mask_$_19,this,FactorialActor.q);
	assert { :msg "  740.3: The target of the fold statement might be null." } !(Heap_$_19[this,FactorialActor.q] == null);
	assert { :msg "  740.3: unfold might fail because the predicate FactorialActorChannel.initImpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  740.3: unfold might fail because the predicate FactorialActorChannel.initImpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initImpState." } (Fractions(100) <= Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R]) && ((Fractions(100) == Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R]) ==> (0 <= Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$N]));
	assume exhaleMask#_1163_$_0 == Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState := Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R := Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_19);
	assume wf(Heap_$_19,Mask_$_19);
	assume wf(Heap_$_19,exhaleMask#_1163_$_0);
	assume wf(Heap_$_19,exhaleMask#_1163_$_0);
	assume inhaleHeap#_1165_$_0 == Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState];
	assume IsGoodInhaleState(inhaleHeap#_1165_$_0,Heap_$_19,exhaleMask#_1163_$_0);
	assume !(Heap_$_19[this,FactorialActor.q] == null);
	assume Heap_$_20 == Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1165_$_0[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_20,exhaleMask#_1163_$_0);
	assume (Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_20 == exhaleMask#_1163_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1163_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1163_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_20);
	assume IsGoodState(inhaleHeap#_1165_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_20,Mask_$_20);
	assume wf(inhaleHeap#_1165_$_0,Mask_$_20);
	assume !(Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_21 == Heap_$_20[Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1165_$_0[Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_21,Mask_$_20);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_21 == Mask_$_20[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_20[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_20[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_21);
	assume IsGoodState(inhaleHeap#_1165_$_0[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_21,Mask_$_21);
	assume wf(inhaleHeap#_1165_$_0,Mask_$_21);
	assume Heap_$_21[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume IsGoodMask(Mask_$_21);
	assume wf(Heap_$_21,Mask_$_21);
	assume ((0 < unfoldK#_1166) && (unfoldK#_1166 < Fractions(1))) && ((1000 * unfoldK#_1166) < methodK#_1151);
	assert { :msg "  741.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  741.10: Location might not be readable." } true ==> CanRead(Mask_$_21,this,FactorialActor.q);
	assert { :msg "  741.3: The target of the fold statement might be null." } !(Heap_$_21[this,FactorialActor.q] == null);
	assert { :msg "  741.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  741.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initExpState." } (Fractions(100) <= Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R]) ==> (0 <= Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$N]));
	assume exhaleMask#_1167_$_0 == Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState := Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R := Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_21);
	assume wf(Heap_$_21,Mask_$_21);
	assume wf(Heap_$_21,exhaleMask#_1167_$_0);
	assume wf(Heap_$_21,exhaleMask#_1167_$_0);
	assume inhaleHeap#_1169_$_0 == Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState];
	assume IsGoodInhaleState(inhaleHeap#_1169_$_0,Heap_$_21,exhaleMask#_1167_$_0);
	assume !(Heap_$_21[this,FactorialActor.q] == null);
	assume Heap_$_22 == Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1169_$_0[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_22,exhaleMask#_1167_$_0);
	assume (Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_22 == exhaleMask#_1167_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp := exhaleMask#_1167_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := exhaleMask#_1167_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_22);
	assume IsGoodState(inhaleHeap#_1169_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_22,Mask_$_22);
	assume wf(inhaleHeap#_1169_$_0,Mask_$_22);
	assume !(Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_23 == Heap_$_22[Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1169_$_0[Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_23,Mask_$_22);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_23 == Mask_$_22[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_22[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_22[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume IsGoodState(inhaleHeap#_1169_$_0[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(inhaleHeap#_1169_$_0,Mask_$_23);
	assume Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume ((0 < whileK#_1176) && ((1000 * whileK#_1176) < Fractions(1))) && ((1000 * whileK#_1176) < methodK#_1151);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The expression at 743.27 might not evaluate to true." } !(Heap_$_23[this,FactorialActor.q] == null);
	assert { :msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.13 might not evaluate to true." } Heap_$_23[this,FactorialActor.q] == Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assert { :msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.28 might not evaluate to true." } !(Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.43 might not evaluate to true." } !(Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. The expression at 745.31 might not evaluate to true." } !(Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  746.13: The loop invariant might not hold on entry to the loop. The expression at 746.33 might not evaluate to true." } Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  747.13: The loop invariant might not hold on entry to the loop. The expression at 747.33 might not evaluate to true." } Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_1 == Credits_$_0[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_0[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] - 1];
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.13 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.13 for FactorialActor.q." } (monitorK <= Mask_$_23[this,FactorialActor.q][perm$R]) && ((monitorK == Mask_$_23[this,FactorialActor.q][perm$R]) ==> (0 <= Mask_$_23[this,FactorialActor.q][perm$N]));
	assume exhaleMask#_1177_$_0 == Mask_$_23[this,FactorialActor.q := Mask_$_23[this,FactorialActor.q][perm$R := Mask_$_23[this,FactorialActor.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_0);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.38 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.38 for FactorialActorChannel.imp." } (monitorK <= exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$N]));
	assume exhaleMask#_1177_$_1 == exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_1);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.56 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.56 for FactorialActorChannelImpEP.impch." } (monitorK <= exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1177_$_2 == exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_2);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.80 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.80 for mu." } (monitorK <= exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) && ((monitorK == exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) ==> (0 <= exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$N]));
	assume exhaleMask#_1177_$_3 == exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_3);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.107 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.107 for FactorialActorChannelImpEP.ch." } (monitorK <= exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$N]));
	assume exhaleMask#_1177_$_4 == exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_4);
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. The permission at 745.13 might not be positive." } monitorK > 0;
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 745.13 for FactorialActorChannel.exp." } (monitorK <= exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$N]));
	assume exhaleMask#_1177_$_5 == exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp := exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_5);
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. The permission at 745.46 might not be positive." } Fractions(100) > 0;
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 745.46 for FactorialActorChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1177_$_6 == exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_6);
	assert { :msg "  746.13: The loop invariant might not hold on entry to the loop. The permission at 746.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  746.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 746.13 for FactorialActorChannelExpEP.state." } (Fractions(100) <= exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$N]));
	assume exhaleMask#_1177_$_7 == exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_7);
	assert { :msg "  747.13: The loop invariant might not hold on entry to the loop. The permission at 747.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  747.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 747.13 for FactorialActorChannelImpEP.state." } (Fractions(100) <= exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$N]));
	assume exhaleMask#_1177_$_8 == exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_8);
	assume wf(Heap_$_23,exhaleMask#_1177_$_8);
	assert { :msg "  742.3: Loop invariant must consume all debt on entry to the loop." } (forall  ch : ref :: ( (ch == null) || (0 <= Credits_$_1[ch]) ));
	assert { :msg "  742.3: Method execution before loop might lock/unlock more than allowed by lockchange clause of loop." } (forall  lk#_1187 : ref :: {Heap_$_23[lk#_1187,held]} {Heap_$_23[lk#_1187,rdheld]} ( (((0 < Heap_$_23[lk#_1187,held]) <==> (0 < Heap[lk#_1187,held])) && (Heap_$_23[lk#_1187,rdheld] <==> Heap[lk#_1187,rdheld])) || false ));
	if ($_$_condition) { goto $cascade_0_$1_$0; } else { goto anon73_Then; }
$cascade_0_$1_$0:
	assume $_$_condition;
	if ($_$_condition_$0) { goto anon74_Then; } else { goto anon74_Else; }
anon73_Then:
	assume !$_$_condition;
	assume IsGoodInhaleState(inhaleHeap#_1188_$_0,Heap_$_24,ZeroMask);
	assume !(this == null);
	assume Heap_$_25 == Heap_$_24[this,FactorialActor.q := inhaleHeap#_1188_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_25,ZeroMask);
	assume (Heap_$_25[this,FactorialActor.q] == null) || (dtype(Heap_$_25[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_24 == ZeroMask[this,FactorialActor.q := ZeroMask[this,FactorialActor.q][perm$R := ZeroMask[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_24);
	assume IsGoodState(inhaleHeap#_1188_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_25,Mask_$_24);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_24);
	assert { :msg "  743.27: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.27: Location might not be readable." } true ==> CanRead(Mask_$_24,this,FactorialActor.q);
	assume !(Heap_$_25[this,FactorialActor.q] == null);
	assert { :msg "  743.41: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.41: Location might not be readable." } true ==> CanRead(Mask_$_24,this,FactorialActor.q);
	assume !(Heap_$_25[this,FactorialActor.q] == null);
	assume Heap_$_26 == Heap_$_25[Heap_$_25[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1188_$_0[Heap_$_25[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_26,Mask_$_24);
	assume (Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_25 == Mask_$_24[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_24[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_24[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_25);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_26,Mask_$_25);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_25);
	assert { :msg "  743.59: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.59: Location might not be readable." } true ==> CanRead(Mask_$_25,this,FactorialActor.q);
	assert { :msg "  743.59: Receiver might be null." } true ==> (!(Heap_$_26[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_25,Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_27 == Heap_$_26[Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1188_$_0[Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_27,Mask_$_25);
	assume (Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_26 == Mask_$_25[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_25[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_25[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_26);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_27,Mask_$_26);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_26);
	assert { :msg "  743.83: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.83: Location might not be readable." } true ==> CanRead(Mask_$_26,this,FactorialActor.q);
	assert { :msg "  743.83: Receiver might be null." } true ==> (!(Heap_$_27[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_26,Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_26,Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assume !(Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_28 == Heap_$_27[Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1188_$_0[Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_28,Mask_$_26);
	assume true;
	assume monitorK > 0;
	assume Mask_$_27 == Mask_$_26[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_26[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_26[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_27);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_28,Mask_$_27);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_27);
	assert { :msg "  743.110: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.110: Location might not be readable." } true ==> CanRead(Mask_$_27,this,FactorialActor.q);
	assert { :msg "  743.110: Receiver might be null." } true ==> (!(Heap_$_28[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_27,Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_29 == Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1188_$_0[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_29,Mask_$_27);
	assume (Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_28 == Mask_$_27[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_27[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_27[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_28);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_29,Mask_$_28);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_28);
	assert { :msg "  744.13: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.13: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.16: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.16: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.16: Receiver might be null." } true ==> (!(Heap_$_29[this,FactorialActor.q] == null));
	assert { :msg "  744.16: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  744.16: Receiver might be null." } true ==> (!(Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  744.16: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch);
	assume Heap_$_29[this,FactorialActor.q] == Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assert { :msg "  744.28: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.28: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.28: Receiver might be null." } true ==> (!(Heap_$_29[this,FactorialActor.q] == null));
	assert { :msg "  744.28: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  744.43: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.43: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.43: Receiver might be null." } true ==> (!(Heap_$_29[this,FactorialActor.q] == null));
	assert { :msg "  744.43: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  744.43: Receiver might be null." } true ==> (!(Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  744.43: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assume !(Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  745.16: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.16: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assume !(Heap_$_29[this,FactorialActor.q] == null);
	assume Heap_$_30 == Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1188_$_0[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_30,Mask_$_28);
	assume (Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_29 == Mask_$_28[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_28[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_28[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_29);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_30,Mask_$_29);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_29);
	assert { :msg "  745.31: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.31: Location might not be readable." } true ==> CanRead(Mask_$_29,this,FactorialActor.q);
	assert { :msg "  745.31: Receiver might be null." } true ==> (!(Heap_$_30[this,FactorialActor.q] == null));
	assert { :msg "  745.31: Location might not be readable." } true ==> CanRead(Mask_$_29,Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp);
	assume !(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,this,FactorialActor.q);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(Heap_$_30[this,FactorialActor.q] == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp);
	assert { :msg "  745.46: Receiver might be null." } !(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,this,FactorialActor.q);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(Heap_$_30[this,FactorialActor.q] == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp);
	assume !(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_31 == Heap_$_30[Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1188_$_0[Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_31,Mask_$_29);
	assume inhaleHeap#_1188_$_0[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_31;
	assume Fractions(100) > 0;
	assume Mask_$_30 == Mask_$_29[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_29[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_29[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_30);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_31,Mask_$_30);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_30);
	assert { :msg "  746.17: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  746.17: Location might not be readable." } true ==> CanRead(Mask_$_30,this,FactorialActor.q);
	assert { :msg "  746.17: Receiver might be null." } true ==> (!(Heap_$_31[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_30,Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp);
	assume !(Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_32 == Heap_$_31[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1188_$_0[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_32,Mask_$_30);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_31 == Mask_$_30[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_30[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_30[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_31);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_32,Mask_$_31);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_31);
	assert { :msg "  746.33: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  746.33: Location might not be readable." } true ==> CanRead(Mask_$_31,this,FactorialActor.q);
	assert { :msg "  746.33: Receiver might be null." } true ==> (!(Heap_$_32[this,FactorialActor.q] == null));
	assert { :msg "  746.33: Location might not be readable." } true ==> CanRead(Mask_$_31,Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp);
	assert { :msg "  746.33: Receiver might be null." } true ==> (!(Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp] == null));
	assert { :msg "  746.33: Location might not be readable." } true ==> CanRead(Mask_$_31,Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state);
	assume Heap_$_32[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  747.17: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  747.17: Location might not be readable." } true ==> CanRead(Mask_$_31,this,FactorialActor.q);
	assert { :msg "  747.17: Receiver might be null." } true ==> (!(Heap_$_32[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_31,Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_33 == Heap_$_32[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1188_$_0[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_33,Mask_$_31);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_32 == Mask_$_31[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_31[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_31[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_32);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_33,Mask_$_32);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_32);
	assert { :msg "  747.33: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  747.33: Location might not be readable." } true ==> CanRead(Mask_$_32,this,FactorialActor.q);
	assert { :msg "  747.33: Receiver might be null." } true ==> (!(Heap_$_33[this,FactorialActor.q] == null));
	assert { :msg "  747.33: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  747.33: Receiver might be null." } true ==> (!(Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  747.33: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state);
	assume Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assert { :msg "  748.20: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  748.20: Location might not be readable." } true ==> CanRead(Mask_$_32,this,FactorialActor.q);
	assert { :msg "  748.20: Receiver might be null." } true ==> (!(Heap_$_33[this,FactorialActor.q] == null));
	assert { :msg "  748.20: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  748.20: Receiver might be null." } true ==> (!(Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  748.20: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assert { :msg "  748.20: The target of the credit predicate might be null." } !(Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Credits_$_2 == ZeroCredits[Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := ZeroCredits[Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_32);
	assume wf(Heap_$_33,Mask_$_32);
	assume false;
	goto $exit;
anon74_Then:
	assume $_$_condition_$0;
	assume IsGoodInhaleState(inhaleHeap#_1189_$_0,Heap_$_34,ZeroMask);
	assume !(this == null);
	assume Heap_$_35 == Heap_$_34[this,FactorialActor.q := inhaleHeap#_1189_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_35,ZeroMask);
	assume (Heap_$_35[this,FactorialActor.q] == null) || (dtype(Heap_$_35[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_33 == ZeroMask[this,FactorialActor.q := ZeroMask[this,FactorialActor.q][perm$R := ZeroMask[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_33);
	assume IsGoodState(inhaleHeap#_1189_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_35,Mask_$_33);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_33);
	assume !(Heap_$_35[this,FactorialActor.q] == null);
	assume !(Heap_$_35[this,FactorialActor.q] == null);
	assume Heap_$_36 == Heap_$_35[Heap_$_35[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1189_$_0[Heap_$_35[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_36,Mask_$_33);
	assume (Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_34 == Mask_$_33[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_33[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_33[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_34);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_36,Mask_$_34);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_34);
	assume !(Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_37 == Heap_$_36[Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1189_$_0[Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_37,Mask_$_34);
	assume (Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_35 == Mask_$_34[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_34[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_34[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_35);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_37,Mask_$_35);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_35);
	assume !(Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_38 == Heap_$_37[Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1189_$_0[Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_38,Mask_$_35);
	assume true;
	assume monitorK > 0;
	assume Mask_$_36 == Mask_$_35[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_35[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_35[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_36);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_38,Mask_$_36);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_36);
	assume !(Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_39 == Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1189_$_0[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_39,Mask_$_36);
	assume (Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_37 == Mask_$_36[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_36[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_36[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_37);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_39,Mask_$_37);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_37);
	assume Heap_$_39[this,FactorialActor.q] == Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assume !(Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume !(Heap_$_39[this,FactorialActor.q] == null);
	assume Heap_$_40 == Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1189_$_0[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_40,Mask_$_37);
	assume (Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_38 == Mask_$_37[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_37[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_37[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_38);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_40,Mask_$_38);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_38);
	assume !(Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume !(Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_41 == Heap_$_40[Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1189_$_0[Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_41,Mask_$_38);
	assume inhaleHeap#_1189_$_0[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_41;
	assume Fractions(100) > 0;
	assume Mask_$_39 == Mask_$_38[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_38[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_38[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_39);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_41,Mask_$_39);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_39);
	assume !(Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_42 == Heap_$_41[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1189_$_0[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_42,Mask_$_39);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_40 == Mask_$_39[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_39[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_39[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_40);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_42,Mask_$_40);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_40);
	assume Heap_$_42[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assume !(Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_43 == Heap_$_42[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1189_$_0[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_43,Mask_$_40);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_41 == Mask_$_40[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_40[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_40[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_41);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_43,Mask_$_41);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_41);
	assume Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_3 == ZeroCredits[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := ZeroCredits[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_41);
	assume wf(Heap_$_43,Mask_$_41);
	assume (forall  lk#_1190 : ref :: {Heap_$_43[lk#_1190,held]} {Heap_$_43[lk#_1190,rdheld]} ( (((0 < Heap_$_43[lk#_1190,held]) <==> (0 < Heap[lk#_1190,held])) && (Heap_$_43[lk#_1190,rdheld] <==> Heap[lk#_1190,rdheld])) || false ));
	assume true;
	assert { :msg "  751.21: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  751.21: Location might not be readable." } true ==> CanRead(Mask_$_41,this,FactorialActor.q);
	assert { :msg "  751.21: Receiver might be null." } true ==> (!(Heap_$_43[this,FactorialActor.q] == null));
	assert { :msg "  751.21: Location might not be readable." } true ==> CanRead(Mask_$_41,Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  751.21: Receiver might be null." } true ==> (!(Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  751.21: Location might not be readable." } true ==> CanRead(Mask_$_41,Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assert { :msg "  751.21: The channel might be null." } !(Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  751.4: receive operation requires a credit" } 0 < Credits_$_3[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assert { :msg "  751.4: The mu field of the channel in the receive statement might not be readable." } CanRead(Mask_$_41,Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu);
	assert { :msg "  751.4: The channel must lie above waitlevel in the wait order" } (forall  o#_1191 : ref :: ( (((0 < Heap_$_43[o#_1191,held]) || Heap_$_43[o#_1191,rdheld]) || (Credits_$_3[o#_1191] < 0)) ==> MuBelow(Heap_$_43[o#_1191,mu],Heap_$_43[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]) ));
	assume this#127_$_0 == Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch];
	assume (msg#128_$_0 == null) || (dtype(msg#128_$_0) == Message#t);
	assume IsGoodInhaleState(inhaleHeap#_1192_$_0,Heap_$_43,Mask_$_41);
	assume !(msg#128_$_0 == null);
	assume !(msg#128_$_0 == null);
	assume Heap_$_44 == Heap_$_43[msg#128_$_0,Message.type := inhaleHeap#_1192_$_0[msg#128_$_0,Message.type]];
	assume wf(Heap_$_44,Mask_$_41);
	assume true;
	assume channelK > 0;
	assume Mask_$_42 == Mask_$_41[msg#128_$_0,Message.type := Mask_$_41[msg#128_$_0,Message.type][perm$R := Mask_$_41[msg#128_$_0,Message.type][perm$R] + channelK]];
	assume IsGoodMask(Mask_$_42);
	assume IsGoodState(inhaleHeap#_1192_$_0[msg#128_$_0,Message.type]);
	assume wf(Heap_$_44,Mask_$_42);
	assume wf(inhaleHeap#_1192_$_0,Mask_$_42);
	assume !(msg#128_$_0 == null);
	assume Heap_$_45 == Heap_$_44[msg#128_$_0,Message.inv := inhaleHeap#_1192_$_0[msg#128_$_0,Message.inv]];
	assume wf(Heap_$_45,Mask_$_42);
	assume inhaleHeap#_1192_$_0[msg#128_$_0,Message.inv] == Heap_$_45;
	assume Fractions(100) > 0;
	assume Mask_$_43 == Mask_$_42[msg#128_$_0,Message.inv := Mask_$_42[msg#128_$_0,Message.inv][perm$R := Mask_$_42[msg#128_$_0,Message.inv][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_43);
	assume IsGoodState(inhaleHeap#_1192_$_0[msg#128_$_0,Message.inv]);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(inhaleHeap#_1192_$_0,Mask_$_43);
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume Credits_$_4 == Credits_$_3[Heap_$_45[Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_3[Heap_$_45[Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] - 1];
	assert { :msg "  752.7: Receiver might be null." } true ==> (!(msg#128_$_0 == null));
	assert { :msg "  752.7: Location might not be readable." } true ==> CanRead(Mask_$_43,msg#128_$_0,Message.type);
	if ($_$_condition_$1) { goto anon75_Then; } else { goto anon75_Else; }
anon74_Else:
	assume !$_$_condition_$0;
	assume (forall  lk#_1433 : ref :: {Heap_$_23[lk#_1433,held]} {Heap_$_23[lk#_1433,rdheld]} ( (((0 < Heap_$_23[lk#_1433,held]) <==> (0 < Heap[lk#_1433,held])) && (Heap_$_23[lk#_1433,rdheld] <==> Heap[lk#_1433,rdheld])) || false ));
	assume IsGoodInhaleState(inhaleHeap#_1434_$_0,Heap_$_23,exhaleMask#_1177_$_8);
	assume !(this == null);
	assume Heap_$_46 == Heap_$_23[this,FactorialActor.q := inhaleHeap#_1434_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_46,exhaleMask#_1177_$_8);
	assume (Heap_$_46[this,FactorialActor.q] == null) || (dtype(Heap_$_46[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_44 == exhaleMask#_1177_$_8[this,FactorialActor.q := exhaleMask#_1177_$_8[this,FactorialActor.q][perm$R := exhaleMask#_1177_$_8[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_44);
	assume IsGoodState(inhaleHeap#_1434_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_46,Mask_$_44);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_44);
	assume !(Heap_$_46[this,FactorialActor.q] == null);
	assume !(Heap_$_46[this,FactorialActor.q] == null);
	assume Heap_$_47 == Heap_$_46[Heap_$_46[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1434_$_0[Heap_$_46[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_47,Mask_$_44);
	assume (Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_45 == Mask_$_44[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_44[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_44[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_45);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_47,Mask_$_45);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_45);
	assume !(Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_48 == Heap_$_47[Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1434_$_0[Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_48,Mask_$_45);
	assume (Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_46 == Mask_$_45[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_45[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_45[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_46);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_48,Mask_$_46);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_46);
	assume !(Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_49 == Heap_$_48[Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1434_$_0[Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_49,Mask_$_46);
	assume true;
	assume monitorK > 0;
	assume Mask_$_47 == Mask_$_46[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_46[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_46[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_47);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_49,Mask_$_47);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_47);
	assume !(Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_50 == Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1434_$_0[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_50,Mask_$_47);
	assume (Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_48 == Mask_$_47[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_47[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_47[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_48);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_50,Mask_$_48);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_48);
	assume Heap_$_50[this,FactorialActor.q] == Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assume !(Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume !(Heap_$_50[this,FactorialActor.q] == null);
	assume Heap_$_51 == Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1434_$_0[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_51,Mask_$_48);
	assume (Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_49 == Mask_$_48[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_48[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_48[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_49);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_51,Mask_$_49);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_49);
	assume !(Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume !(Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_52 == Heap_$_51[Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1434_$_0[Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_52,Mask_$_49);
	assume inhaleHeap#_1434_$_0[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_52;
	assume Fractions(100) > 0;
	assume Mask_$_50 == Mask_$_49[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_49[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_49[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_50);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_52,Mask_$_50);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_50);
	assume !(Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_53 == Heap_$_52[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1434_$_0[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_53,Mask_$_50);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_51 == Mask_$_50[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_50[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_50[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_51);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_53,Mask_$_51);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_51);
	assume Heap_$_53[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assume !(Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_54 == Heap_$_53[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1434_$_0[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_54,Mask_$_51);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_52 == Mask_$_51[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_51[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_51[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_52);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_54,Mask_$_52);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_52);
	assume Heap_$_54[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_5 == Credits_$_1[Heap_$_54[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_1[Heap_$_54[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_52);
	assume wf(Heap_$_54,Mask_$_52);
	assume !true;
	assert { :msg "  734.2: Method might lock/unlock more than allowed." } (forall  lk#_1435 : ref :: {Heap_$_54[lk#_1435,held]} {Heap_$_54[lk#_1435,rdheld]} ( (((0 < Heap_$_54[lk#_1435,held]) <==> (0 < Heap[lk#_1435,held])) && (Heap_$_54[lk#_1435,rdheld] <==> Heap[lk#_1435,rdheld])) || false ));
	assert { :msg "  734.2: Method body is not allowed to leave any debt." } (forall  ch_$0 : ref :: ( (ch_$0 == null) || (0 <= Credits_$_5[ch_$0]) ));
	goto $exit;
anon75_Then:
	assume $_$_condition_$1;
	assume $_$_condition_$1 <==> (Heap_$_45[msg#128_$_0,Message.type] == 1);
	assume Heap_$_45[msg#128_$_0,Message.type] == 1;
	assume ((0 < methodCallK#_1196) && ((1000 * methodCallK#_1196) < Fractions(1))) && ((1000 * methodCallK#_1196) < whileK#_1176);
	assert { :msg "  753.19: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  753.19: Location might not be readable." } true ==> CanRead(Mask_$_43,this,FactorialActor.q);
	assert { :msg "  753.19: Receiver might be null." } true ==> (!(Heap_$_45[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_43,Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  753.5: The target of the method call might be null." } !(Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume this#129_$_0 == Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp];
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The expression at 95.25 might not evaluate to true." } !(msg#128_$_0 == null);
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The expression at 95.57 might not evaluate to true." } Heap_$_45[msg#128_$_0,Message.type] == 1;
	assert { :msg "  753.5: The precondition at 96.11 might not hold. The expression at 96.11 might not evaluate to true." } Heap_$_45[this#129_$_0,FactorialActorChannelImpEP.state] == 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.11 for FactorialActorChannelImpEP.state." } (Fractions(100) <= Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$N]));
	assume exhaleMask#_1197_$_0 == Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state := Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R := Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(Heap_$_45,exhaleMask#_1197_$_0);
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.37 might not be positive." } monitorK > 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.37 for Message.type." } (monitorK <= exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$N]));
	assume exhaleMask#_1197_$_1 == exhaleMask#_1197_$_0[msg#128_$_0,Message.type := exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R := exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(Heap_$_45,exhaleMask#_1197_$_1);
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.71 might not be positive." } Fractions(100) > 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.71 for Message.inv." } (Fractions(100) <= exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R]) ==> (0 <= exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$N]));
	assume exhaleMask#_1197_$_2 == exhaleMask#_1197_$_1[msg#128_$_0,Message.inv := exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R := exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(Heap_$_45,exhaleMask#_1197_$_2);
	assume wf(Heap_$_45,exhaleMask#_1197_$_2);
	assume (mo#131_$_0 == null) || (dtype(mo#131_$_0) == Message#t);
	assume IsGoodInhaleState(inhaleHeap#_1203_$_0,Heap_$_45,exhaleMask#_1197_$_2);
	assume !(this#129_$_0 == null);
	assume Heap_$_55 == Heap_$_45[this#129_$_0,FactorialActorChannelImpEP.state := inhaleHeap#_1203_$_0[this#129_$_0,FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_55,exhaleMask#_1197_$_2);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_53 == exhaleMask#_1197_$_2[this#129_$_0,FactorialActorChannelImpEP.state := exhaleMask#_1197_$_2[this#129_$_0,FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1197_$_2[this#129_$_0,FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_53);
	assume IsGoodState(inhaleHeap#_1203_$_0[this#129_$_0,FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_55,Mask_$_53);
	assume wf(inhaleHeap#_1203_$_0,Mask_$_53);
	assume Heap_$_55[this#129_$_0,FactorialActorChannelImpEP.state] == 0;
	assume !(mo#131_$_0 == null);
	assume Heap_$_56 == Heap_$_55[mo#131_$_0,Message.type := inhaleHeap#_1203_$_0[mo#131_$_0,Message.type]];
	assume wf(Heap_$_56,Mask_$_53);
	assume true;
	assume monitorK > 0;
	assume Mask_$_54 == Mask_$_53[mo#131_$_0,Message.type := Mask_$_53[mo#131_$_0,Message.type][perm$R := Mask_$_53[mo#131_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_54);
	assume IsGoodState(inhaleHeap#_1203_$_0[mo#131_$_0,Message.type]);
	assume wf(Heap_$_56,Mask_$_54);
	assume wf(inhaleHeap#_1203_$_0,Mask_$_54);
	assume Heap_$_56[mo#131_$_0,Message.type] == 1;
	assume msg#128_$_0 == mo#131_$_0;
	assume !(mo#131_$_0 == null);
	assume Heap_$_57 == Heap_$_56[mo#131_$_0,Message.invValue := inhaleHeap#_1203_$_0[mo#131_$_0,Message.invValue]];
	assume wf(Heap_$_57,Mask_$_54);
	assume inhaleHeap#_1203_$_0[mo#131_$_0,Message.invValue] == Heap_$_57;
	assume Fractions(100) > 0;
	assume Mask_$_55 == Mask_$_54[mo#131_$_0,Message.invValue := Mask_$_54[mo#131_$_0,Message.invValue][perm$R := Mask_$_54[mo#131_$_0,Message.invValue][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_55);
	assume IsGoodState(inhaleHeap#_1203_$_0[mo#131_$_0,Message.invValue]);
	assume wf(Heap_$_57,Mask_$_55);
	assume wf(inhaleHeap#_1203_$_0,Mask_$_55);
	assume IsGoodMask(Mask_$_55);
	assume wf(Heap_$_57,Mask_$_55);
	assume ((0 < unfoldK#_1204) && (unfoldK#_1204 < Fractions(1))) && ((1000 * unfoldK#_1204) < whileK#_1176);
	assert { :msg "  754.5: The target of the fold statement might be null." } !(mo#131_$_0 == null);
	assert { :msg "  754.5: unfold might fail because the predicate Message.invValue does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  754.5: unfold might fail because the predicate Message.invValue does not hold. Insufficient fraction at <undefined position> for Message.invValue." } (Fractions(100) <= Mask_$_55[mo#131_$_0,Message.invValue][perm$R]) && ((Fractions(100) == Mask_$_55[mo#131_$_0,Message.invValue][perm$R]) ==> (0 <= Mask_$_55[mo#131_$_0,Message.invValue][perm$N]));
	assume exhaleMask#_1205_$_0 == Mask_$_55[mo#131_$_0,Message.invValue := Mask_$_55[mo#131_$_0,Message.invValue][perm$R := Mask_$_55[mo#131_$_0,Message.invValue][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_55);
	assume wf(Heap_$_57,Mask_$_55);
	assume wf(Heap_$_57,exhaleMask#_1205_$_0);
	assume wf(Heap_$_57,exhaleMask#_1205_$_0);
	assume inhaleHeap#_1207_$_0 == Heap_$_57[mo#131_$_0,Message.invValue];
	assume IsGoodInhaleState(inhaleHeap#_1207_$_0,Heap_$_57,exhaleMask#_1205_$_0);
	assume !(mo#131_$_0 == null);
	assume Heap_$_58 == Heap_$_57[mo#131_$_0,Message.sender1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.sender1]];
	assume wf(Heap_$_58,exhaleMask#_1205_$_0);
	assume (Heap_$_58[mo#131_$_0,Message.sender1] == null) || (dtype(Heap_$_58[mo#131_$_0,Message.sender1]) == Future#t);
	assume predicateK > 0;
	assume Mask_$_56 == exhaleMask#_1205_$_0[mo#131_$_0,Message.sender1 := exhaleMask#_1205_$_0[mo#131_$_0,Message.sender1][perm$R := exhaleMask#_1205_$_0[mo#131_$_0,Message.sender1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_56);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.sender1]);
	assume wf(Heap_$_58,Mask_$_56);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_56);
	assume !(mo#131_$_0 == null);
	assume Heap_$_59 == Heap_$_58[mo#131_$_0,Message.receiver1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.receiver1]];
	assume wf(Heap_$_59,Mask_$_56);
	assume (Heap_$_59[mo#131_$_0,Message.receiver1] == null) || (dtype(Heap_$_59[mo#131_$_0,Message.receiver1]) == FactorialActor#t);
	assume predicateK > 0;
	assume Mask_$_57 == Mask_$_56[mo#131_$_0,Message.receiver1 := Mask_$_56[mo#131_$_0,Message.receiver1][perm$R := Mask_$_56[mo#131_$_0,Message.receiver1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_57);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.receiver1]);
	assume wf(Heap_$_59,Mask_$_57);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_57);
	assume !(mo#131_$_0 == null);
	assume Heap_$_60 == Heap_$_59[mo#131_$_0,Message.cust1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.cust1]];
	assume wf(Heap_$_60,Mask_$_57);
	assume (Heap_$_60[mo#131_$_0,Message.cust1] == null) || (dtype(Heap_$_60[mo#131_$_0,Message.cust1]) == FactorialCont#t);
	assume predicateK > 0;
	assume Mask_$_58 == Mask_$_57[mo#131_$_0,Message.cust1 := Mask_$_57[mo#131_$_0,Message.cust1][perm$R := Mask_$_57[mo#131_$_0,Message.cust1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_58);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.cust1]);
	assume wf(Heap_$_60,Mask_$_58);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_58);
	assume !(mo#131_$_0 == null);
	assume Heap_$_61 == Heap_$_60[mo#131_$_0,Message.v1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.v1]];
	assume wf(Heap_$_61,Mask_$_58);
	assume true;
	assume predicateK > 0;
	assume Mask_$_59 == Mask_$_58[mo#131_$_0,Message.v1 := Mask_$_58[mo#131_$_0,Message.v1][perm$R := Mask_$_58[mo#131_$_0,Message.v1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_59);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.v1]);
	assume wf(Heap_$_61,Mask_$_59);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_59);
	assume !(mo#131_$_0 == null);
	assume Heap_$_62 == Heap_$_61[mo#131_$_0,Message.vo1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.vo1]];
	assume wf(Heap_$_62,Mask_$_59);
	assume true;
	assume predicateK > 0;
	assume Mask_$_60 == Mask_$_59[mo#131_$_0,Message.vo1 := Mask_$_59[mo#131_$_0,Message.vo1][perm$R := Mask_$_59[mo#131_$_0,Message.vo1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_60);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.vo1]);
	assume wf(Heap_$_62,Mask_$_60);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_60);
	assume !(Heap_$_62[mo#131_$_0,Message.sender1] == null);
	assume !(Heap_$_62[mo#131_$_0,Message.sender1] == null);
	assume Heap_$_63 == Heap_$_62[Heap_$_62[mo#131_$_0,Message.sender1],Future.q := inhaleHeap#_1207_$_0[Heap_$_62[mo#131_$_0,Message.sender1],Future.q]];
	assume wf(Heap_$_63,Mask_$_60);
	assume (Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q] == null) || (dtype(Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q]) == FutureChannel#t);
	assume predicateK > 0;
	assume Mask_$_61 == Mask_$_60[Heap_$_63[mo#131_$_0,Message.sender1],Future.q := Mask_$_60[Heap_$_63[mo#131_$_0,Message.sender1],Future.q][perm$R := Mask_$_60[Heap_$_63[mo#131_$_0,Message.sender1],Future.q][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_61);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_63[mo#131_$_0,Message.sender1],Future.q]);
	assume wf(Heap_$_63,Mask_$_61);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_61);
	assume !(Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q] == null);
	assume !(Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_64 == Heap_$_63[Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid := inhaleHeap#_1207_$_0[Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid]];
	assume wf(Heap_$_64,Mask_$_61);
	assume inhaleHeap#_1207_$_0[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid] == Heap_$_64;
	assume Fractions(100) > 0;
	assume Mask_$_62 == Mask_$_61[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid := Mask_$_61[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R := Mask_$_61[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_62);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid]);
	assume wf(Heap_$_64,Mask_$_62);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_62);
	assume !(Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_65 == Heap_$_64[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState := inhaleHeap#_1207_$_0[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState]];
	assume wf(Heap_$_65,Mask_$_62);
	assume inhaleHeap#_1207_$_0[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState] == Heap_$_65;
	assume Fractions(100) > 0;
	assume Mask_$_63 == Mask_$_62[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState := Mask_$_62[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R := Mask_$_62[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_63);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState]);
	assume wf(Heap_$_65,Mask_$_63);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_63);
	assume Heap_$_65[mo#131_$_0,Message.v1] >= 0;
	assume Heap_$_65[mo#131_$_0,Message.vo1] >= 0;
	if ($_$_condition_$2) { goto anon76_Then; } else { goto anon76_Else; }
anon75_Else:
	assume !$_$_condition_$1;
	assume $_$_condition_$1 <==> (Heap_$_45[msg#128_$_0,Message.type] == 1);
	assume !(Heap_$_45[msg#128_$_0,Message.type] == 1);
	assume Mask_$_221 == Mask_$_43;
	assume Credits_$_7 == Credits_$_4;
	assume Heap_$_134 == Heap_$_45;
	goto anon70;
anon76_Then:
	assume $_$_condition_$2;
	assume $_$_condition_$2 <==> (Heap_$_65[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_65[mo#131_$_0,Message.cust1] == null;
	assume Heap_$_65[mo#131_$_0,Message.v1] == Heap_$_65[mo#131_$_0,Message.vo1];
	goto $branchMerge_0;
anon76_Else:
	assume !$_$_condition_$2;
	assume $_$_condition_$2 <==> (Heap_$_65[mo#131_$_0,Message.cust1] == null);
	assume !(Heap_$_65[mo#131_$_0,Message.cust1] == null);
	goto $branchMerge_0;
anon70:
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The expression at 743.27 might not evaluate to true." } !(Heap_$_134[this,FactorialActor.q] == null);
	assert { :msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.13 might not evaluate to true." } Heap_$_134[this,FactorialActor.q] == Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assert { :msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.28 might not evaluate to true." } !(Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.43 might not evaluate to true." } !(Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The expression at 745.31 might not evaluate to true." } !(Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. The expression at 746.33 might not evaluate to true." } Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. The expression at 747.33 might not evaluate to true." } Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_8 == Credits_$_7[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_7[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] - 1];
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.13 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.13 for FactorialActor.q." } (monitorK <= Mask_$_221[this,FactorialActor.q][perm$R]) && ((monitorK == Mask_$_221[this,FactorialActor.q][perm$R]) ==> (0 <= Mask_$_221[this,FactorialActor.q][perm$N]));
	assume exhaleMask#_1420_$_0 == Mask_$_221[this,FactorialActor.q := Mask_$_221[this,FactorialActor.q][perm$R := Mask_$_221[this,FactorialActor.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_0);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.38 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.38 for FactorialActorChannel.imp." } (monitorK <= exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$N]));
	assume exhaleMask#_1420_$_1 == exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_1);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.56 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.56 for FactorialActorChannelImpEP.impch." } (monitorK <= exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1420_$_2 == exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_2);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.80 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.80 for mu." } (monitorK <= exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) && ((monitorK == exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) ==> (0 <= exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$N]));
	assume exhaleMask#_1420_$_3 == exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_3);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.107 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.107 for FactorialActorChannelImpEP.ch." } (monitorK <= exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$N]));
	assume exhaleMask#_1420_$_4 == exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_4);
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The permission at 745.13 might not be positive." } monitorK > 0;
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. Insufficient fraction at 745.13 for FactorialActorChannel.exp." } (monitorK <= exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$N]));
	assume exhaleMask#_1420_$_5 == exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp := exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_5);
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The permission at 745.46 might not be positive." } Fractions(100) > 0;
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. Insufficient fraction at 745.46 for FactorialActorChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1420_$_6 == exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_6);
	assert { :msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. The permission at 746.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. Insufficient fraction at 746.13 for FactorialActorChannelExpEP.state." } (Fractions(100) <= exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$N]));
	assume exhaleMask#_1420_$_7 == exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_7);
	assert { :msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. The permission at 747.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. Insufficient fraction at 747.13 for FactorialActorChannelImpEP.state." } (Fractions(100) <= exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$N]));
	assume exhaleMask#_1420_$_8 == exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_8);
	assume wf(Heap_$_134,exhaleMask#_1420_$_8);
	assert { :msg "  742.3: The loop might lock/unlock more than the lockchange clause allows." } (forall  lk#_1430 : ref :: {Heap_$_134[lk#_1430,held]} {Heap_$_134[lk#_1430,rdheld]} ( (((0 < Heap_$_134[lk#_1430,held]) <==> (0 < Heap[lk#_1430,held])) && (Heap_$_134[lk#_1430,rdheld] <==> Heap[lk#_1430,rdheld])) || false ));
	assert { :msg "  742.3: Loop body is not allowed to leave any debt." } (forall  ch_$1 : ref :: ( (ch_$1 == null) || (0 <= Credits_$_8[ch_$1]) ));
	assume false;
	goto $exit;
anon77_Then:
	assume $_$_condition_$3;
	assume $_$_condition_$3 <==> (!(Heap_$_65[mo#131_$_0,Message.cust1] == null));
	assume !(Heap_$_65[mo#131_$_0,Message.cust1] == null);
	assume !(Heap_$_65[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_66 == Heap_$_65[Heap_$_65[mo#131_$_0,Message.cust1],FactorialCont.q := inhaleHeap#_1207_$_0[Heap_$_65[mo#131_$_0,Message.cust1],FactorialCont.q]];
	assume wf(Heap_$_66,Mask_$_63);
	assume (Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q] == null) || (dtype(Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q]) == FactorialContChannel#t);
	assume predicateK > 0;
	assume Mask_$_64 == Mask_$_63[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q := Mask_$_63[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q][perm$R := Mask_$_63[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_64);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q]);
	assume wf(Heap_$_66,Mask_$_64);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_64);
	assume !(Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume !(Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_67 == Heap_$_66[Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1207_$_0[Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_67,Mask_$_64);
	assume inhaleHeap#_1207_$_0[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid] == Heap_$_67;
	assume Fractions(100) > 0;
	assume Mask_$_65 == Mask_$_64[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid := Mask_$_64[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_64[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_65);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_67,Mask_$_65);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_65);
	assume !(Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_68 == Heap_$_67[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState := inhaleHeap#_1207_$_0[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState]];
	assume wf(Heap_$_68,Mask_$_65);
	assume inhaleHeap#_1207_$_0[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState] == Heap_$_68;
	assume Fractions(100) > 0;
	assume Mask_$_66 == Mask_$_65[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState := Mask_$_65[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_65[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_66);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState]);
	assume wf(Heap_$_68,Mask_$_66);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_66);
	assume !(Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_69 == Heap_$_68[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1207_$_0[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_69,Mask_$_66);
	assume (Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume predicateK > 0;
	assume Mask_$_67 == Mask_$_66[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := Mask_$_66[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R := Mask_$_66[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_67);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_69,Mask_$_67);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_67);
	assume !(Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_70 == Heap_$_69[Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := inhaleHeap#_1207_$_0[Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]];
	assume wf(Heap_$_70,Mask_$_67);
	assume (Heap_$_70[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null) || (dtype(Heap_$_70[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]) == Channel#t);
	assume predicateK > 0;
	assume Mask_$_68 == Mask_$_67[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := Mask_$_67[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := Mask_$_67[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_68);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]);
	assume wf(Heap_$_70,Mask_$_68);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_68);
	assume !(Heap_$_70[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assume !(Heap_$_70[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_71 == Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.v := inhaleHeap#_1207_$_0[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.v]];
	assume wf(Heap_$_71,Mask_$_68);
	assume true;
	assume predicateK > 0;
	assume Mask_$_69 == Mask_$_68[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v := Mask_$_68[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v][perm$R := Mask_$_68[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_69);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v]);
	assume wf(Heap_$_71,Mask_$_69);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_69);
	assume !(Heap_$_71[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_72 == Heap_$_71[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.vo := inhaleHeap#_1207_$_0[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.vo]];
	assume wf(Heap_$_72,Mask_$_69);
	assume true;
	assume predicateK > 0;
	assume Mask_$_70 == Mask_$_69[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo := Mask_$_69[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo][perm$R := Mask_$_69[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_70);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo]);
	assume wf(Heap_$_72,Mask_$_70);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_70);
	assume Heap_$_72[mo#131_$_0,Message.v1] == (Heap_$_72[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.v] - 1);
	assume Heap_$_72[mo#131_$_0,Message.vo1] == Heap_$_72[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo];
	assume Mask_$_71 == Mask_$_70;
	assume Heap_$_73 == Heap_$_72;
	goto anon10;
anon77_Else:
	assume !$_$_condition_$3;
	assume $_$_condition_$3 <==> (!(Heap_$_65[mo#131_$_0,Message.cust1] == null));
	assume Heap_$_65[mo#131_$_0,Message.cust1] == null;
	assume Mask_$_71 == Mask_$_63;
	assume Heap_$_73 == Heap_$_65;
	goto anon10;
anon10:
	assume IsGoodMask(Mask_$_71);
	assume wf(Heap_$_73,Mask_$_71);
	assert { :msg "  755.8: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  755.8: Location might not be readable." } true ==> CanRead(Mask_$_71,mo#131_$_0,Message.v1);
	if ($_$_condition_$5) { goto anon78_Then; } else { goto anon78_Else; }
anon78_Then:
	assume $_$_condition_$5;
	assume $_$_condition_$5 <==> (Heap_$_73[mo#131_$_0,Message.v1] == 0);
	assume Heap_$_73[mo#131_$_0,Message.v1] == 0;
	assert { :msg "  756.10: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  756.10: Location might not be readable." } true ==> CanRead(Mask_$_71,mo#131_$_0,Message.cust1);
	if ($_$_condition_$6) { goto anon79_Then; } else { goto anon79_Else; }
anon78_Else:
	assume !$_$_condition_$5;
	assume $_$_condition_$5 <==> (Heap_$_73[mo#131_$_0,Message.v1] == 0);
	assume !(Heap_$_73[mo#131_$_0,Message.v1] == 0);
	assume (!(nw#_1321_$_0 == null)) && (dtype(nw#_1321_$_0) == FactorialCont#t);
	assume (((((forall  f_$13_$0 : Field (Boolean)  :: ( (Mask_$_71[nw#_1321_$_0,f_$13_$0][perm$R] == 0) && (Mask_$_71[nw#_1321_$_0,f_$13_$0][perm$N] == 0) ))) && ((forall  f_$13_$1 : Field (Integer)  :: ( (Mask_$_71[nw#_1321_$_0,f_$13_$1][perm$R] == 0) && (Mask_$_71[nw#_1321_$_0,f_$13_$1][perm$N] == 0) )))) && ((forall  f_$13_$2 : Field (ref)  :: ( (Mask_$_71[nw#_1321_$_0,f_$13_$2][perm$R] == 0) && (Mask_$_71[nw#_1321_$_0,f_$13_$2][perm$N] == 0) )))) && ((forall  f_$13_$3 : Field (HeapType)  :: ( (Mask_$_71[nw#_1321_$_0,f_$13_$3][perm$R] == 0) && (Mask_$_71[nw#_1321_$_0,f_$13_$3][perm$N] == 0) )))) && ((forall  f_$13_$4 : Field (Mu)  :: ( (Mask_$_71[nw#_1321_$_0,f_$13_$4][perm$R] == 0) && (Mask_$_71[nw#_1321_$_0,f_$13_$4][perm$N] == 0) )));
	assume Heap_$_73[nw#_1321_$_0,mu] == $LockBottom;
	assume Heap_$_73[nw#_1321_$_0,held] <= 0;
	assume Heap_$_73[nw#_1321_$_0,rdheld] <==> false;
	assume Mask_$_72 == Mask_$_71[nw#_1321_$_0,FactorialCont.q := Mask_$_71[nw#_1321_$_0,FactorialCont.q][perm$R := Mask_$_71[nw#_1321_$_0,FactorialCont.q][perm$R] + Fractions(100)]];
	assume Mask_$_73 == Mask_$_72[nw#_1321_$_0,FactorialCont.v := Mask_$_72[nw#_1321_$_0,FactorialCont.v][perm$R := Mask_$_72[nw#_1321_$_0,FactorialCont.v][perm$R] + Fractions(100)]];
	assume Mask_$_74 == Mask_$_73[nw#_1321_$_0,FactorialCont.vo := Mask_$_73[nw#_1321_$_0,FactorialCont.vo][perm$R := Mask_$_73[nw#_1321_$_0,FactorialCont.vo][perm$R] + Fractions(100)]];
	assume Mask_$_75 == Mask_$_74[nw#_1321_$_0,FactorialCont.cust := Mask_$_74[nw#_1321_$_0,FactorialCont.cust][perm$R := Mask_$_74[nw#_1321_$_0,FactorialCont.cust][perm$R] + Fractions(100)]];
	assume Mask_$_76 == Mask_$_75[nw#_1321_$_0,mu := Mask_$_75[nw#_1321_$_0,mu][perm$R := Mask_$_75[nw#_1321_$_0,mu][perm$R] + Fractions(100)]];
	assume ((0 < methodCallK#_1325) && ((1000 * methodCallK#_1325) < Fractions(1))) && ((1000 * methodCallK#_1325) < whileK#_1176);
	assert { :msg "  784.6: The target of the method call might be null." } !(nw#_1321_$_0 == null);
	assert { :msg "  784.21: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  784.21: Location might not be readable." } true ==> CanRead(Mask_$_76,mo#131_$_0,Message.v1);
	assert { :msg "  784.32: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  784.32: Location might not be readable." } true ==> CanRead(Mask_$_76,mo#131_$_0,Message.vo1);
	assert { :msg "  784.44: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  784.44: Location might not be readable." } true ==> CanRead(Mask_$_76,mo#131_$_0,Message.cust1);
	assume vp#144_$_0 == Heap_$_73[mo#131_$_0,Message.v1];
	assume vop#145_$_0 == Heap_$_73[mo#131_$_0,Message.vo1];
	assume custp#146_$_0 == Heap_$_73[mo#131_$_0,Message.cust1];
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 822.54 might not evaluate to true." } vp#144_$_0 >= 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 822.64 might not evaluate to true." } vop#145_$_0 >= 0;
	if ($_$_condition_$7) { goto anon86_Then; } else { goto anon86_Else; }
anon79_Then:
	assume $_$_condition_$6;
	assume $_$_condition_$6 <==> (Heap_$_73[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_73[mo#131_$_0,Message.cust1] == null;
	assume (!(nw#_1208_$_0 == null)) && (dtype(nw#_1208_$_0) == Message#t);
	assume (((((forall  f_$14_$0 : Field (Boolean)  :: ( (Mask_$_71[nw#_1208_$_0,f_$14_$0][perm$R] == 0) && (Mask_$_71[nw#_1208_$_0,f_$14_$0][perm$N] == 0) ))) && ((forall  f_$14_$1 : Field (Integer)  :: ( (Mask_$_71[nw#_1208_$_0,f_$14_$1][perm$R] == 0) && (Mask_$_71[nw#_1208_$_0,f_$14_$1][perm$N] == 0) )))) && ((forall  f_$14_$2 : Field (ref)  :: ( (Mask_$_71[nw#_1208_$_0,f_$14_$2][perm$R] == 0) && (Mask_$_71[nw#_1208_$_0,f_$14_$2][perm$N] == 0) )))) && ((forall  f_$14_$3 : Field (HeapType)  :: ( (Mask_$_71[nw#_1208_$_0,f_$14_$3][perm$R] == 0) && (Mask_$_71[nw#_1208_$_0,f_$14_$3][perm$N] == 0) )))) && ((forall  f_$14_$4 : Field (Mu)  :: ( (Mask_$_71[nw#_1208_$_0,f_$14_$4][perm$R] == 0) && (Mask_$_71[nw#_1208_$_0,f_$14_$4][perm$N] == 0) )));
	assume Heap_$_73[nw#_1208_$_0,mu] == $LockBottom;
	assume Heap_$_73[nw#_1208_$_0,held] <= 0;
	assume Heap_$_73[nw#_1208_$_0,rdheld] <==> false;
	assume Mask_$_139 == Mask_$_71[nw#_1208_$_0,Message.type := Mask_$_71[nw#_1208_$_0,Message.type][perm$R := Mask_$_71[nw#_1208_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_140 == Mask_$_139[nw#_1208_$_0,Message.sender1 := Mask_$_139[nw#_1208_$_0,Message.sender1][perm$R := Mask_$_139[nw#_1208_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_141 == Mask_$_140[nw#_1208_$_0,Message.sender3 := Mask_$_140[nw#_1208_$_0,Message.sender3][perm$R := Mask_$_140[nw#_1208_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_142 == Mask_$_141[nw#_1208_$_0,Message.sender2 := Mask_$_141[nw#_1208_$_0,Message.sender2][perm$R := Mask_$_141[nw#_1208_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_143 == Mask_$_142[nw#_1208_$_0,Message.sender4 := Mask_$_142[nw#_1208_$_0,Message.sender4][perm$R := Mask_$_142[nw#_1208_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_144 == Mask_$_143[nw#_1208_$_0,Message.receiver1 := Mask_$_143[nw#_1208_$_0,Message.receiver1][perm$R := Mask_$_143[nw#_1208_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_145 == Mask_$_144[nw#_1208_$_0,Message.receiver2 := Mask_$_144[nw#_1208_$_0,Message.receiver2][perm$R := Mask_$_144[nw#_1208_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_146 == Mask_$_145[nw#_1208_$_0,Message.receiver3 := Mask_$_145[nw#_1208_$_0,Message.receiver3][perm$R := Mask_$_145[nw#_1208_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_147 == Mask_$_146[nw#_1208_$_0,Message.receiver4 := Mask_$_146[nw#_1208_$_0,Message.receiver4][perm$R := Mask_$_146[nw#_1208_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_148 == Mask_$_147[nw#_1208_$_0,Message.v1 := Mask_$_147[nw#_1208_$_0,Message.v1][perm$R := Mask_$_147[nw#_1208_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_149 == Mask_$_148[nw#_1208_$_0,Message.vo1 := Mask_$_148[nw#_1208_$_0,Message.vo1][perm$R := Mask_$_148[nw#_1208_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_150 == Mask_$_149[nw#_1208_$_0,Message.cust1 := Mask_$_149[nw#_1208_$_0,Message.cust1][perm$R := Mask_$_149[nw#_1208_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_151 == Mask_$_150[nw#_1208_$_0,Message.vr1 := Mask_$_150[nw#_1208_$_0,Message.vr1][perm$R := Mask_$_150[nw#_1208_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_152 == Mask_$_151[nw#_1208_$_0,Message.old1 := Mask_$_151[nw#_1208_$_0,Message.old1][perm$R := Mask_$_151[nw#_1208_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_153 == Mask_$_152[nw#_1208_$_0,Message.vr2 := Mask_$_152[nw#_1208_$_0,Message.vr2][perm$R := Mask_$_152[nw#_1208_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_154 == Mask_$_153[nw#_1208_$_0,Message.old2 := Mask_$_153[nw#_1208_$_0,Message.old2][perm$R := Mask_$_153[nw#_1208_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_155 == Mask_$_154[nw#_1208_$_0,Message.vr3 := Mask_$_154[nw#_1208_$_0,Message.vr3][perm$R := Mask_$_154[nw#_1208_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_156 == Mask_$_155[nw#_1208_$_0,mu := Mask_$_155[nw#_1208_$_0,mu][perm$R := Mask_$_155[nw#_1208_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  759.7: Location might not be writable" } CanWrite(Mask_$_156,nw#_1208_$_0,Message.sender4);
	assume Heap_$_103 == Heap_$_73[nw#_1208_$_0,Message.sender4 := null];
	assume wf(Heap_$_103,Mask_$_156);
	assume ((0 < methodCallK#_1212) && ((1000 * methodCallK#_1212) < Fractions(1))) && ((1000 * methodCallK#_1212) < whileK#_1176);
	assert { :msg "  760.7: The target of the method call might be null." } !(nw#_1208_$_0 == null);
	assert { :msg "  760.31: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  760.31: Location might not be readable." } true ==> CanRead(Mask_$_156,mo#131_$_0,Message.sender1);
	assume receiver#134_$_0 == Heap_$_103[mo#131_$_0,Message.sender1];
	if ($_$_condition_$8) { goto anon80_Then; } else { goto anon80_Else; }
anon79_Else:
	assume !$_$_condition_$6;
	assume $_$_condition_$6 <==> (Heap_$_73[mo#131_$_0,Message.cust1] == null);
	assume !(Heap_$_73[mo#131_$_0,Message.cust1] == null);
	assume (!(nw#_1258_$_0 == null)) && (dtype(nw#_1258_$_0) == Message#t);
	assume (((((forall  f_$15_$0 : Field (Boolean)  :: ( (Mask_$_71[nw#_1258_$_0,f_$15_$0][perm$R] == 0) && (Mask_$_71[nw#_1258_$_0,f_$15_$0][perm$N] == 0) ))) && ((forall  f_$15_$1 : Field (Integer)  :: ( (Mask_$_71[nw#_1258_$_0,f_$15_$1][perm$R] == 0) && (Mask_$_71[nw#_1258_$_0,f_$15_$1][perm$N] == 0) )))) && ((forall  f_$15_$2 : Field (ref)  :: ( (Mask_$_71[nw#_1258_$_0,f_$15_$2][perm$R] == 0) && (Mask_$_71[nw#_1258_$_0,f_$15_$2][perm$N] == 0) )))) && ((forall  f_$15_$3 : Field (HeapType)  :: ( (Mask_$_71[nw#_1258_$_0,f_$15_$3][perm$R] == 0) && (Mask_$_71[nw#_1258_$_0,f_$15_$3][perm$N] == 0) )))) && ((forall  f_$15_$4 : Field (Mu)  :: ( (Mask_$_71[nw#_1258_$_0,f_$15_$4][perm$R] == 0) && (Mask_$_71[nw#_1258_$_0,f_$15_$4][perm$N] == 0) )));
	assume Heap_$_73[nw#_1258_$_0,mu] == $LockBottom;
	assume Heap_$_73[nw#_1258_$_0,held] <= 0;
	assume Heap_$_73[nw#_1258_$_0,rdheld] <==> false;
	assume Mask_$_157 == Mask_$_71[nw#_1258_$_0,Message.type := Mask_$_71[nw#_1258_$_0,Message.type][perm$R := Mask_$_71[nw#_1258_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_158 == Mask_$_157[nw#_1258_$_0,Message.sender1 := Mask_$_157[nw#_1258_$_0,Message.sender1][perm$R := Mask_$_157[nw#_1258_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_159 == Mask_$_158[nw#_1258_$_0,Message.sender3 := Mask_$_158[nw#_1258_$_0,Message.sender3][perm$R := Mask_$_158[nw#_1258_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_160 == Mask_$_159[nw#_1258_$_0,Message.sender2 := Mask_$_159[nw#_1258_$_0,Message.sender2][perm$R := Mask_$_159[nw#_1258_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_161 == Mask_$_160[nw#_1258_$_0,Message.sender4 := Mask_$_160[nw#_1258_$_0,Message.sender4][perm$R := Mask_$_160[nw#_1258_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_162 == Mask_$_161[nw#_1258_$_0,Message.receiver1 := Mask_$_161[nw#_1258_$_0,Message.receiver1][perm$R := Mask_$_161[nw#_1258_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_163 == Mask_$_162[nw#_1258_$_0,Message.receiver2 := Mask_$_162[nw#_1258_$_0,Message.receiver2][perm$R := Mask_$_162[nw#_1258_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_164 == Mask_$_163[nw#_1258_$_0,Message.receiver3 := Mask_$_163[nw#_1258_$_0,Message.receiver3][perm$R := Mask_$_163[nw#_1258_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_165 == Mask_$_164[nw#_1258_$_0,Message.receiver4 := Mask_$_164[nw#_1258_$_0,Message.receiver4][perm$R := Mask_$_164[nw#_1258_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_166 == Mask_$_165[nw#_1258_$_0,Message.v1 := Mask_$_165[nw#_1258_$_0,Message.v1][perm$R := Mask_$_165[nw#_1258_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_167 == Mask_$_166[nw#_1258_$_0,Message.vo1 := Mask_$_166[nw#_1258_$_0,Message.vo1][perm$R := Mask_$_166[nw#_1258_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_168 == Mask_$_167[nw#_1258_$_0,Message.cust1 := Mask_$_167[nw#_1258_$_0,Message.cust1][perm$R := Mask_$_167[nw#_1258_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_169 == Mask_$_168[nw#_1258_$_0,Message.vr1 := Mask_$_168[nw#_1258_$_0,Message.vr1][perm$R := Mask_$_168[nw#_1258_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_170 == Mask_$_169[nw#_1258_$_0,Message.old1 := Mask_$_169[nw#_1258_$_0,Message.old1][perm$R := Mask_$_169[nw#_1258_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_171 == Mask_$_170[nw#_1258_$_0,Message.vr2 := Mask_$_170[nw#_1258_$_0,Message.vr2][perm$R := Mask_$_170[nw#_1258_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_172 == Mask_$_171[nw#_1258_$_0,Message.old2 := Mask_$_171[nw#_1258_$_0,Message.old2][perm$R := Mask_$_171[nw#_1258_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_173 == Mask_$_172[nw#_1258_$_0,Message.vr3 := Mask_$_172[nw#_1258_$_0,Message.vr3][perm$R := Mask_$_172[nw#_1258_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_174 == Mask_$_173[nw#_1258_$_0,mu := Mask_$_173[nw#_1258_$_0,mu][perm$R := Mask_$_173[nw#_1258_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  771.7: Location might not be writable" } CanWrite(Mask_$_174,nw#_1258_$_0,Message.sender2);
	assert { :msg "  771.18: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  771.18: Location might not be readable." } true ==> CanRead(Mask_$_174,mo#131_$_0,Message.sender1);
	assume Heap_$_104 == Heap_$_73[nw#_1258_$_0,Message.sender2 := Heap_$_73[mo#131_$_0,Message.sender1]];
	assume wf(Heap_$_104,Mask_$_174);
	assume ((0 < methodCallK#_1262) && ((1000 * methodCallK#_1262) < Fractions(1))) && ((1000 * methodCallK#_1262) < whileK#_1176);
	assert { :msg "  772.7: The target of the method call might be null." } !(nw#_1258_$_0 == null);
	assert { :msg "  772.32: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  772.32: Location might not be readable." } true ==> CanRead(Mask_$_174,mo#131_$_0,Message.cust1);
	assume receiver#140_$_0 == Heap_$_104[mo#131_$_0,Message.cust1];
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 681.4 might not evaluate to true." } !(Heap_$_104[nw#_1258_$_0,Message.sender2] == null);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 681.44 might not evaluate to true." } !(Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q] == null);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.3 might not evaluate to true." } 1 == #Message.factorial(Heap_$_104,Mask_$_174,nw#_1258_$_0,0);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.45 might not evaluate to true." } !(receiver#140_$_0 == null);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.64 might not evaluate to true." } Heap_$_104[receiver#140_$_0,FactorialCont.v] == 1;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.11 for Message.type." } (Fractions(100) <= Mask_$_174[nw#_1258_$_0,Message.type][perm$R]) && ((Fractions(100) == Mask_$_174[nw#_1258_$_0,Message.type][perm$R]) ==> (0 <= Mask_$_174[nw#_1258_$_0,Message.type][perm$N]));
	assume exhaleMask#_1263_$_0 == Mask_$_174[nw#_1258_$_0,Message.type := Mask_$_174[nw#_1258_$_0,Message.type][perm$R := Mask_$_174[nw#_1258_$_0,Message.type][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_0);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.25 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.25 for Message.sender2." } (Fractions(100) <= exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R]) ==> (0 <= exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$N]));
	assume exhaleMask#_1263_$_1 == exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2 := exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R := exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_1);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.41 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.41 for Message.receiver2." } (Fractions(100) <= exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R]) ==> (0 <= exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$N]));
	assume exhaleMask#_1263_$_2 == exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2 := exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R := exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_2);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 680.3 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 680.3 for Message.vr1." } (Fractions(100) <= exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R]) ==> (0 <= exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$N]));
	assume exhaleMask#_1263_$_3 == exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1 := exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R := exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_3);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 680.15 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 680.15 for Message.old1." } (Fractions(100) <= exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R]) ==> (0 <= exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$N]));
	assume exhaleMask#_1263_$_4 == exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1 := exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R := exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_4);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.22 might not be positive." } monitorK > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.22 for Future.q." } (monitorK <= exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R]) && ((monitorK == exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R]) ==> (0 <= exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$N]));
	assume exhaleMask#_1263_$_5 == exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q := exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R := exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_5);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.63 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.63 for FutureChannel.valid." } (Fractions(100) <= exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$N]));
	assume exhaleMask#_1263_$_6 == exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid := exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R := exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_6);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.82 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.82 for FutureChannel.initExpState." } (Fractions(100) <= exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$N]));
	assume exhaleMask#_1263_$_7 == exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState := exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R := exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_7);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 682.22 might not be positive." } monitorK > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 682.22 for FactorialCont.v." } (monitorK <= exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1263_$_8 == exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v := exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R := exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_8);
	assume wf(Heap_$_104,exhaleMask#_1263_$_8);
	assume IsGoodInhaleState(inhaleHeap#_1275_$_0,Heap_$_104,exhaleMask#_1263_$_8);
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_105 == Heap_$_104[nw#_1258_$_0,Message.invResult1 := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.invResult1]];
	assume wf(Heap_$_105,exhaleMask#_1263_$_8);
	assume inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.invResult1] == Heap_$_105;
	assume Fractions(100) > 0;
	assume Mask_$_175 == exhaleMask#_1263_$_8[nw#_1258_$_0,Message.invResult1 := exhaleMask#_1263_$_8[nw#_1258_$_0,Message.invResult1][perm$R := exhaleMask#_1263_$_8[nw#_1258_$_0,Message.invResult1][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_175);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.invResult1]);
	assume wf(Heap_$_105,Mask_$_175);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_175);
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_106 == Heap_$_105[nw#_1258_$_0,Message.type := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]];
	assume wf(Heap_$_106,Mask_$_175);
	assume true;
	assume monitorK > 0;
	assume Mask_$_176 == Mask_$_175[nw#_1258_$_0,Message.type := Mask_$_175[nw#_1258_$_0,Message.type][perm$R := Mask_$_175[nw#_1258_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_176);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]);
	assume wf(Heap_$_106,Mask_$_176);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_176);
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_107 == Heap_$_106[nw#_1258_$_0,Message.type := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]];
	assume wf(Heap_$_107,Mask_$_176);
	assume true;
	assume monitorK > 0;
	assume Mask_$_177 == Mask_$_176[nw#_1258_$_0,Message.type := Mask_$_176[nw#_1258_$_0,Message.type][perm$R := Mask_$_176[nw#_1258_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_177);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]);
	assume wf(Heap_$_107,Mask_$_177);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_177);
	assume Heap_$_107[nw#_1258_$_0,Message.type] == 2;
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_108 == Heap_$_107[nw#_1258_$_0,Message.receiver2 := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.receiver2]];
	assume wf(Heap_$_108,Mask_$_177);
	assume (Heap_$_108[nw#_1258_$_0,Message.receiver2] == null) || (dtype(Heap_$_108[nw#_1258_$_0,Message.receiver2]) == FactorialCont#t);
	assume monitorK > 0;
	assume Mask_$_178 == Mask_$_177[nw#_1258_$_0,Message.receiver2 := Mask_$_177[nw#_1258_$_0,Message.receiver2][perm$R := Mask_$_177[nw#_1258_$_0,Message.receiver2][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_178);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.receiver2]);
	assume wf(Heap_$_108,Mask_$_178);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_178);
	assume Heap_$_108[nw#_1258_$_0,Message.receiver2] == receiver#140_$_0;
	assume IsGoodMask(Mask_$_178);
	assume wf(Heap_$_108,Mask_$_178);
	assume ((0 < unfoldK#_1276) && (unfoldK#_1276 < Fractions(1))) && ((1000 * unfoldK#_1276) < whileK#_1176);
	assert { :msg "  773.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  773.14: Location might not be readable." } true ==> CanRead(Mask_$_178,mo#131_$_0,Message.cust1);
	assert { :msg "  773.14: Receiver might be null." } true ==> (!(Heap_$_108[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  773.14: Location might not be readable." } true ==> CanRead(Mask_$_178,Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q);
	assert { :msg "  773.7: The target of the fold statement might be null." } !(Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assert { :msg "  773.7: unfold might fail because the predicate FactorialContChannel.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  773.7: unfold might fail because the predicate FactorialContChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.valid." } (Fractions(100) <= Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1277_$_0 == Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid := Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_178);
	assume wf(Heap_$_108,Mask_$_178);
	assume wf(Heap_$_108,exhaleMask#_1277_$_0);
	assume wf(Heap_$_108,exhaleMask#_1277_$_0);
	assume inhaleHeap#_1279_$_0 == Heap_$_108[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid];
	assume IsGoodInhaleState(inhaleHeap#_1279_$_0,Heap_$_108,exhaleMask#_1277_$_0);
	assume !(Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_109 == Heap_$_108[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1279_$_0[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_109,exhaleMask#_1277_$_0);
	assume (Heap_$_109[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_109[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_179 == exhaleMask#_1277_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := exhaleMask#_1277_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R := exhaleMask#_1277_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_179);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_109,Mask_$_179);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_179);
	assume !(Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_110 == Heap_$_109[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := inhaleHeap#_1279_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]];
	assume wf(Heap_$_110,Mask_$_179);
	assume (Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null) || (dtype(Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_180 == Mask_$_179[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := Mask_$_179[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R := Mask_$_179[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_180);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]);
	assume wf(Heap_$_110,Mask_$_180);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_180);
	assume !(Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_111 == Heap_$_110[Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch := inhaleHeap#_1279_$_0[Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch]];
	assume wf(Heap_$_111,Mask_$_180);
	assume (Heap_$_111[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch] == null) || (dtype(Heap_$_111[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
	assume monitorK > 0;
	assume Mask_$_181 == Mask_$_180[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch := Mask_$_180[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch][perm$R := Mask_$_180[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_181);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch]);
	assume wf(Heap_$_111,Mask_$_181);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_181);
	assume !(Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_112 == Heap_$_111[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch := inhaleHeap#_1279_$_0[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch]];
	assume wf(Heap_$_112,Mask_$_181);
	assume (Heap_$_112[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch] == null) || (dtype(Heap_$_112[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
	assume monitorK > 0;
	assume Mask_$_182 == Mask_$_181[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch := Mask_$_181[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch][perm$R := Mask_$_181[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_182);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch]);
	assume wf(Heap_$_112,Mask_$_182);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_182);
	assume !(Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume !(Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume !(Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_113 == Heap_$_112[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid := inhaleHeap#_1279_$_0[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid]];
	assume wf(Heap_$_113,Mask_$_182);
	assume inhaleHeap#_1279_$_0[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid] == Heap_$_113;
	assume Fractions(100) > 0;
	assume Mask_$_183 == Mask_$_182[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid := Mask_$_182[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid][perm$R := Mask_$_182[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_183);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid]);
	assume wf(Heap_$_113,Mask_$_183);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_183);
	assume !(Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_114 == Heap_$_113[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid := inhaleHeap#_1279_$_0[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid]];
	assume wf(Heap_$_114,Mask_$_183);
	assume inhaleHeap#_1279_$_0[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid] == Heap_$_114;
	assume Fractions(100) > 0;
	assume Mask_$_184 == Mask_$_183[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid := Mask_$_183[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid][perm$R := Mask_$_183[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_184);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid]);
	assume wf(Heap_$_114,Mask_$_184);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_184);
	assume Heap_$_114[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch] == Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q];
	assume Heap_$_114[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch] == Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q];
	assume IsGoodMask(Mask_$_184);
	assume wf(Heap_$_114,Mask_$_184);
	assume ((0 < unfoldK#_1280) && (unfoldK#_1280 < Fractions(1))) && ((1000 * unfoldK#_1280) < whileK#_1176);
	assert { :msg "  774.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  774.14: Location might not be readable." } true ==> CanRead(Mask_$_184,mo#131_$_0,Message.cust1);
	assert { :msg "  774.14: Receiver might be null." } true ==> (!(Heap_$_114[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  774.14: Location might not be readable." } true ==> CanRead(Mask_$_184,Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q);
	assert { :msg "  774.7: The target of the fold statement might be null." } !(Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assert { :msg "  774.7: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  774.7: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.initExpState." } (Fractions(100) <= Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1281_$_0 == Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState := Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_184);
	assume wf(Heap_$_114,Mask_$_184);
	assume wf(Heap_$_114,exhaleMask#_1281_$_0);
	assume wf(Heap_$_114,exhaleMask#_1281_$_0);
	assume inhaleHeap#_1283_$_0 == Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState];
	assume IsGoodInhaleState(inhaleHeap#_1283_$_0,Heap_$_114,exhaleMask#_1281_$_0);
	assume !(Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_115 == Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := inhaleHeap#_1283_$_0[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]];
	assume wf(Heap_$_115,exhaleMask#_1281_$_0);
	assume (Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null) || (dtype(Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_185 == exhaleMask#_1281_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := exhaleMask#_1281_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R := exhaleMask#_1281_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_185);
	assume IsGoodState(inhaleHeap#_1283_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]);
	assume wf(Heap_$_115,Mask_$_185);
	assume wf(inhaleHeap#_1283_$_0,Mask_$_185);
	assume !(Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_116 == Heap_$_115[Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state := inhaleHeap#_1283_$_0[Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state]];
	assume wf(Heap_$_116,Mask_$_185);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_186 == Mask_$_185[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state := Mask_$_185[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state][perm$R := Mask_$_185[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume IsGoodState(inhaleHeap#_1283_$_0[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state]);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(inhaleHeap#_1283_$_0,Mask_$_186);
	assume Heap_$_116[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state] == 0;
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume ((0 < methodCallK#_1287) && ((1000 * methodCallK#_1287) < Fractions(1))) && ((1000 * methodCallK#_1287) < whileK#_1176);
	assert { :msg "  775.12: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_186,mo#131_$_0,Message.cust1);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_116[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_186,Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_186,Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp);
	assert { :msg "  775.7: The target of the method call might be null." } !(Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume this#141_$_0 == Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp];
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The expression at 195.63 might not evaluate to true." } Heap_$_116[nw#_1258_$_0,Message.type] == 2;
	assert { :msg "  775.7: The precondition at 197.11 might not hold. The expression at 197.11 might not evaluate to true." } Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.11 for FactorialContChannelExpEP.state." } (Fractions(100) <= Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R]) ==> (0 <= Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$N]));
	assume exhaleMask#_1288_$_0 == Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state := Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R := Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_0);
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.25 might not be positive." } monitorK > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.25 for Message.type." } (monitorK <= exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$N]));
	assume exhaleMask#_1288_$_1 == exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type := exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R := exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_1);
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.44 might not be positive." } monitorK > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.44 for Message.type." } (monitorK <= exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$N]));
	assume exhaleMask#_1288_$_2 == exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type := exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R := exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_2);
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.76 might not be positive." } Fractions(100) > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.76 for Message.invResult1." } (Fractions(100) <= exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$N]));
	assume exhaleMask#_1288_$_3 == exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1 := exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R := exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_3);
	assert { :msg "  775.7: The precondition at 196.11 might not hold. The permission at 196.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  775.7: The precondition at 196.11 might not hold. Insufficient fraction at 196.11 for FactorialContChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1288_$_4 == exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid := exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R := exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_4);
	assume wf(Heap_$_116,exhaleMask#_1288_$_4);
	assume IsGoodInhaleState(inhaleHeap#_1296_$_0,Heap_$_116,exhaleMask#_1288_$_4);
	assume !(this#141_$_0 == null);
	assume Heap_$_117 == Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state := inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.state]];
	assume wf(Heap_$_117,exhaleMask#_1288_$_4);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_187 == exhaleMask#_1288_$_4[this#141_$_0,FactorialContChannelExpEP.state := exhaleMask#_1288_$_4[this#141_$_0,FactorialContChannelExpEP.state][perm$R := exhaleMask#_1288_$_4[this#141_$_0,FactorialContChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_187);
	assume IsGoodState(inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.state]);
	assume wf(Heap_$_117,Mask_$_187);
	assume wf(inhaleHeap#_1296_$_0,Mask_$_187);
	assume !(this#141_$_0 == null);
	assume Heap_$_118 == Heap_$_117[this#141_$_0,FactorialContChannelExpEP.valid := inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.valid]];
	assume wf(Heap_$_118,Mask_$_187);
	assume inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.valid] == Heap_$_118;
	assume Fractions(100) > 0;
	assume Mask_$_188 == Mask_$_187[this#141_$_0,FactorialContChannelExpEP.valid := Mask_$_187[this#141_$_0,FactorialContChannelExpEP.valid][perm$R := Mask_$_187[this#141_$_0,FactorialContChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_188);
	assume IsGoodState(inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.valid]);
	assume wf(Heap_$_118,Mask_$_188);
	assume wf(inhaleHeap#_1296_$_0,Mask_$_188);
	if ($_$_condition_$9) { goto anon83_Then; } else { goto anon83_Else; }
anon86_Then:
	assume $_$_condition_$7;
	assume $_$_condition_$7 <==> (!(custp#146_$_0 == null));
	assume !(custp#146_$_0 == null);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 823.41 might not evaluate to true." } !(Heap_$_73[custp#146_$_0,FactorialCont.q] == null);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 823.120 might not evaluate to true." } vop#145_$_0 == Heap_$_73[custp#146_$_0,FactorialCont.vo];
	goto anon35;
anon86_Else:
	assume !$_$_condition_$7;
	assume $_$_condition_$7 <==> (!(custp#146_$_0 == null));
	assume custp#146_$_0 == null;
	goto anon35;
anon80_Then:
	assume $_$_condition_$8;
	assume $_$_condition_$8 <==> (!(Heap_$_103[nw#_1208_$_0,Message.sender4] == null));
	assume !(Heap_$_103[nw#_1208_$_0,Message.sender4] == null);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The expression at 710.45 might not evaluate to true." } !(Heap_$_103[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q] == null);
	goto anon15;
anon80_Else:
	assume !$_$_condition_$8;
	assume $_$_condition_$8 <==> (!(Heap_$_103[nw#_1208_$_0,Message.sender4] == null));
	assume Heap_$_103[nw#_1208_$_0,Message.sender4] == null;
	goto anon15;
anon83_Then:
	assume $_$_condition_$9;
	assume $_$_condition_$9 <==> (Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0);
	assume Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0;
	assume Heap_$_118[this#141_$_0,FactorialContChannelExpEP.state] == 1;
	goto anon25;
anon83_Else:
	assume !$_$_condition_$9;
	assume $_$_condition_$9 <==> (Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0);
	assume !(Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0);
	goto anon25;
anon35:
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.11 for FactorialCont.v." } (Fractions(100) <= Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R]) && ((Fractions(100) == Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R]) ==> (0 <= Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1326_$_0 == Mask_$_76[nw#_1321_$_0,FactorialCont.v := Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R := Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_0);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.20 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.20 for FactorialCont.vo." } (Fractions(100) <= exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1326_$_1 == exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo := exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R := exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_1);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.31 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.31 for FactorialCont.cust." } (Fractions(100) <= exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$N]));
	assume exhaleMask#_1326_$_2 == exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust := exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R := exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_2);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.44 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.44 for FactorialCont.q." } (Fractions(100) <= exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1326_$_3 == exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q := exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R := exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_3);
	if ($_$_condition_$10) { goto anon87_Then; } else { goto anon87_Else; }
anon15:
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.11 for Message.type." } (Fractions(100) <= Mask_$_156[nw#_1208_$_0,Message.type][perm$R]) && ((Fractions(100) == Mask_$_156[nw#_1208_$_0,Message.type][perm$R]) ==> (0 <= Mask_$_156[nw#_1208_$_0,Message.type][perm$N]));
	assume exhaleMask#_1213_$_0 == Mask_$_156[nw#_1208_$_0,Message.type := Mask_$_156[nw#_1208_$_0,Message.type][perm$R := Mask_$_156[nw#_1208_$_0,Message.type][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_0);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.24 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.24 for Message.sender4." } (Fractions(100) <= exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R]) && ((Fractions(100) == exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$N]));
	assume exhaleMask#_1213_$_1 == exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4 := exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R := exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_1);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.40 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.40 for Message.receiver4." } (Fractions(100) <= exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R]) && ((Fractions(100) == exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$N]));
	assume exhaleMask#_1213_$_2 == exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4 := exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R := exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_2);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.58 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.58 for Message.vr3." } (Fractions(100) <= exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R]) && ((Fractions(100) == exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$N]));
	assume exhaleMask#_1213_$_3 == exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3 := exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R := exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_3);
	if ($_$_condition_$11) { goto anon81_Then; } else { goto anon81_Else; }
anon25:
	assume IsGoodMask(Mask_$_188);
	assume wf(Heap_$_118,Mask_$_188);
	assume (!(nw#_1297_$_0 == null)) && (dtype(nw#_1297_$_0) == Message#t);
	assume (((((forall  f_$16_$0 : Field (Boolean)  :: ( (Mask_$_188[nw#_1297_$_0,f_$16_$0][perm$R] == 0) && (Mask_$_188[nw#_1297_$_0,f_$16_$0][perm$N] == 0) ))) && ((forall  f_$16_$1 : Field (Integer)  :: ( (Mask_$_188[nw#_1297_$_0,f_$16_$1][perm$R] == 0) && (Mask_$_188[nw#_1297_$_0,f_$16_$1][perm$N] == 0) )))) && ((forall  f_$16_$2 : Field (ref)  :: ( (Mask_$_188[nw#_1297_$_0,f_$16_$2][perm$R] == 0) && (Mask_$_188[nw#_1297_$_0,f_$16_$2][perm$N] == 0) )))) && ((forall  f_$16_$3 : Field (HeapType)  :: ( (Mask_$_188[nw#_1297_$_0,f_$16_$3][perm$R] == 0) && (Mask_$_188[nw#_1297_$_0,f_$16_$3][perm$N] == 0) )))) && ((forall  f_$16_$4 : Field (Mu)  :: ( (Mask_$_188[nw#_1297_$_0,f_$16_$4][perm$R] == 0) && (Mask_$_188[nw#_1297_$_0,f_$16_$4][perm$N] == 0) )));
	assume Heap_$_118[nw#_1297_$_0,mu] == $LockBottom;
	assume Heap_$_118[nw#_1297_$_0,held] <= 0;
	assume Heap_$_118[nw#_1297_$_0,rdheld] <==> false;
	assume Mask_$_189 == Mask_$_188[nw#_1297_$_0,Message.type := Mask_$_188[nw#_1297_$_0,Message.type][perm$R := Mask_$_188[nw#_1297_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_190 == Mask_$_189[nw#_1297_$_0,Message.sender1 := Mask_$_189[nw#_1297_$_0,Message.sender1][perm$R := Mask_$_189[nw#_1297_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_191 == Mask_$_190[nw#_1297_$_0,Message.sender3 := Mask_$_190[nw#_1297_$_0,Message.sender3][perm$R := Mask_$_190[nw#_1297_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_192 == Mask_$_191[nw#_1297_$_0,Message.sender2 := Mask_$_191[nw#_1297_$_0,Message.sender2][perm$R := Mask_$_191[nw#_1297_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_193 == Mask_$_192[nw#_1297_$_0,Message.sender4 := Mask_$_192[nw#_1297_$_0,Message.sender4][perm$R := Mask_$_192[nw#_1297_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_194 == Mask_$_193[nw#_1297_$_0,Message.receiver1 := Mask_$_193[nw#_1297_$_0,Message.receiver1][perm$R := Mask_$_193[nw#_1297_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_195 == Mask_$_194[nw#_1297_$_0,Message.receiver2 := Mask_$_194[nw#_1297_$_0,Message.receiver2][perm$R := Mask_$_194[nw#_1297_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_196 == Mask_$_195[nw#_1297_$_0,Message.receiver3 := Mask_$_195[nw#_1297_$_0,Message.receiver3][perm$R := Mask_$_195[nw#_1297_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_197 == Mask_$_196[nw#_1297_$_0,Message.receiver4 := Mask_$_196[nw#_1297_$_0,Message.receiver4][perm$R := Mask_$_196[nw#_1297_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_198 == Mask_$_197[nw#_1297_$_0,Message.v1 := Mask_$_197[nw#_1297_$_0,Message.v1][perm$R := Mask_$_197[nw#_1297_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_199 == Mask_$_198[nw#_1297_$_0,Message.vo1 := Mask_$_198[nw#_1297_$_0,Message.vo1][perm$R := Mask_$_198[nw#_1297_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_200 == Mask_$_199[nw#_1297_$_0,Message.cust1 := Mask_$_199[nw#_1297_$_0,Message.cust1][perm$R := Mask_$_199[nw#_1297_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_201 == Mask_$_200[nw#_1297_$_0,Message.vr1 := Mask_$_200[nw#_1297_$_0,Message.vr1][perm$R := Mask_$_200[nw#_1297_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_202 == Mask_$_201[nw#_1297_$_0,Message.old1 := Mask_$_201[nw#_1297_$_0,Message.old1][perm$R := Mask_$_201[nw#_1297_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_203 == Mask_$_202[nw#_1297_$_0,Message.vr2 := Mask_$_202[nw#_1297_$_0,Message.vr2][perm$R := Mask_$_202[nw#_1297_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_204 == Mask_$_203[nw#_1297_$_0,Message.old2 := Mask_$_203[nw#_1297_$_0,Message.old2][perm$R := Mask_$_203[nw#_1297_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_205 == Mask_$_204[nw#_1297_$_0,Message.vr3 := Mask_$_204[nw#_1297_$_0,Message.vr3][perm$R := Mask_$_204[nw#_1297_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_206 == Mask_$_205[nw#_1297_$_0,mu := Mask_$_205[nw#_1297_$_0,mu][perm$R := Mask_$_205[nw#_1297_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  778.7: Location might not be writable" } CanWrite(Mask_$_206,nw#_1297_$_0,Message.type);
	assume Heap_$_119 == Heap_$_118[nw#_1297_$_0,Message.type := 4];
	assume wf(Heap_$_119,Mask_$_206);
	assert { :msg "  779.14: Receiver might be null." } true ==> (!(nw#_1297_$_0 == null));
	assert { :msg "  779.14: Location might not be readable." } true ==> CanRead(Mask_$_206,nw#_1297_$_0,Message.vr3);
	assert { :msg "  779.33: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  779.33: Location might not be readable." } true ==> CanRead(Mask_$_206,mo#131_$_0,Message.cust1);
	assert { :msg "  779.33: Receiver might be null." } true ==> (!(Heap_$_119[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  779.33: Location might not be readable." } true ==> CanRead(Mask_$_206,Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo);
	assert { :msg "  779.21: Receiver might be null." } true ==> (!(nw#_1297_$_0 == null));
	assume (0 < funcappK#_1311) && ((1000 * funcappK#_1311) < Fractions(1));
	assume true;
	assert { :msg "  779.21: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo] >= 0;
	assume wf(Heap_$_119,Mask_$_206);
	if ($_$_condition_$12) { goto anon84_Then; } else { goto anon84_Else; }
anon87_Then:
	assume $_$_condition_$10;
	assume $_$_condition_$10 <==> (!(custp#146_$_0 == null));
	assume !(custp#146_$_0 == null);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.21 might not be positive." } monitorK > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.21 for FactorialCont.q." } (monitorK <= exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1326_$_4 == exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q := exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R := exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_4);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.58 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.58 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1326_$_5 == exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_5);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.75 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.75 for FactorialContChannel.initExpState." } (Fractions(100) <= exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1326_$_6 == exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState := exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R := exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_6);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.99 might not be positive." } monitorK > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.99 for FactorialCont.vo." } (monitorK <= exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1326_$_7 == exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo := exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R := exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_7);
	assume exhaleMask#_1326_$_8 == exhaleMask#_1326_$_7;
	goto anon38;
anon87_Else:
	assume !$_$_condition_$10;
	assume $_$_condition_$10 <==> (!(custp#146_$_0 == null));
	assume custp#146_$_0 == null;
	assume exhaleMask#_1326_$_8 == exhaleMask#_1326_$_3;
	goto anon38;
anon81_Then:
	assume $_$_condition_$11;
	assume $_$_condition_$11 <==> (!(Heap_$_103[nw#_1208_$_0,Message.sender4] == null));
	assume !(Heap_$_103[nw#_1208_$_0,Message.sender4] == null);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 710.23 might not be positive." } monitorK > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 710.23 for FactorialCont.q." } (monitorK <= exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$N]));
	assume exhaleMask#_1213_$_4 == exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q := exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R := exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_4);
	assume exhaleMask#_1213_$_5 == exhaleMask#_1213_$_4;
	goto anon18;
anon81_Else:
	assume !$_$_condition_$11;
	assume $_$_condition_$11 <==> (!(Heap_$_103[nw#_1208_$_0,Message.sender4] == null));
	assume Heap_$_103[nw#_1208_$_0,Message.sender4] == null;
	assume exhaleMask#_1213_$_5 == exhaleMask#_1213_$_3;
	goto anon18;
anon84_Then:
	assume $_$_condition_$12;
	assume $_$_condition_$12 <==> (Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	assume Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]);
	assert { :msg "  779.54: Receiver might be null." } true ==> (!(nw#_1297_$_0 == null));
	assert { :msg "  779.54: Location might not be readable." } true ==> CanRead(Mask_$_206,nw#_1297_$_0,Message.vr3);
	assert { :msg "  779.73: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  779.73: Location might not be readable." } true ==> CanRead(Mask_$_206,mo#131_$_0,Message.vo1);
	assert { :msg "  779.61: Receiver might be null." } true ==> (!(nw#_1258_$_0 == null));
	assume (0 < funcappK#_1319) && ((1000 * funcappK#_1319) < Fractions(1));
	assume true;
	assert { :msg "  779.61: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_119[mo#131_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_119,Mask_$_206);
	assert { :msg "  779.7: Assertion might not hold. The expression at 779.54 might not evaluate to true." } Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1258_$_0,Heap_$_119[mo#131_$_0,Message.vo1]);
	goto $branchMerge_1;
anon84_Else:
	assume !$_$_condition_$12;
	assume $_$_condition_$12 <==> (Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	assume !(Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	goto $branchMerge_1;
anon38:
	assume wf(Heap_$_73,exhaleMask#_1326_$_8);
	assume IsGoodInhaleState(inhaleHeap#_1337_$_0,Heap_$_73,exhaleMask#_1326_$_8);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_74 == Heap_$_73[nw#_1321_$_0,FactorialCont.v := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.v]];
	assume wf(Heap_$_74,exhaleMask#_1326_$_8);
	assume true;
	assume Fractions(50) > 0;
	assume Mask_$_77 == exhaleMask#_1326_$_8[nw#_1321_$_0,FactorialCont.v := exhaleMask#_1326_$_8[nw#_1321_$_0,FactorialCont.v][perm$R := exhaleMask#_1326_$_8[nw#_1321_$_0,FactorialCont.v][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_77);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.v]);
	assume wf(Heap_$_74,Mask_$_77);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_77);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_75 == Heap_$_74[nw#_1321_$_0,FactorialCont.vo := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.vo]];
	assume wf(Heap_$_75,Mask_$_77);
	assume true;
	assume Fractions(50) > 0;
	assume Mask_$_78 == Mask_$_77[nw#_1321_$_0,FactorialCont.vo := Mask_$_77[nw#_1321_$_0,FactorialCont.vo][perm$R := Mask_$_77[nw#_1321_$_0,FactorialCont.vo][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_78);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.vo]);
	assume wf(Heap_$_75,Mask_$_78);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_78);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_76 == Heap_$_75[nw#_1321_$_0,FactorialCont.cust := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.cust]];
	assume wf(Heap_$_76,Mask_$_78);
	assume (Heap_$_76[nw#_1321_$_0,FactorialCont.cust] == null) || (dtype(Heap_$_76[nw#_1321_$_0,FactorialCont.cust]) == FactorialCont#t);
	assume Fractions(50) > 0;
	assume Mask_$_79 == Mask_$_78[nw#_1321_$_0,FactorialCont.cust := Mask_$_78[nw#_1321_$_0,FactorialCont.cust][perm$R := Mask_$_78[nw#_1321_$_0,FactorialCont.cust][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_79);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.cust]);
	assume wf(Heap_$_76,Mask_$_79);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_79);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_77 == Heap_$_76[nw#_1321_$_0,FactorialCont.q := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.q]];
	assume wf(Heap_$_77,Mask_$_79);
	assume (Heap_$_77[nw#_1321_$_0,FactorialCont.q] == null) || (dtype(Heap_$_77[nw#_1321_$_0,FactorialCont.q]) == FactorialContChannel#t);
	assume Fractions(50) > 0;
	assume Mask_$_80 == Mask_$_79[nw#_1321_$_0,FactorialCont.q := Mask_$_79[nw#_1321_$_0,FactorialCont.q][perm$R := Mask_$_79[nw#_1321_$_0,FactorialCont.q][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_80);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.q]);
	assume wf(Heap_$_77,Mask_$_80);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_80);
	assume !(Heap_$_77[nw#_1321_$_0,FactorialCont.q] == null);
	assume !(Heap_$_77[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_78 == Heap_$_77[Heap_$_77[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1337_$_0[Heap_$_77[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_78,Mask_$_80);
	assume inhaleHeap#_1337_$_0[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid] == Heap_$_78;
	assume Fractions(100) > 0;
	assume Mask_$_81 == Mask_$_80[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := Mask_$_80[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_80[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_81);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_78,Mask_$_81);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_81);
	assume !(Heap_$_78[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_79 == Heap_$_78[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1337_$_0[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_79,Mask_$_81);
	assume inhaleHeap#_1337_$_0[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid] == Heap_$_79;
	assume Fractions(100) > 0;
	assume Mask_$_82 == Mask_$_81[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := Mask_$_81[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_81[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_82);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_79,Mask_$_82);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_82);
	assume !(Heap_$_79[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_80 == Heap_$_79[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState := inhaleHeap#_1337_$_0[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState]];
	assume wf(Heap_$_80,Mask_$_82);
	assume inhaleHeap#_1337_$_0[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState] == Heap_$_80;
	assume Fractions(100) > 0;
	assume Mask_$_83 == Mask_$_82[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState := Mask_$_82[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R := Mask_$_82[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_83);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState]);
	assume wf(Heap_$_80,Mask_$_83);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_83);
	assume !(Heap_$_80[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_81 == Heap_$_80[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState := inhaleHeap#_1337_$_0[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState]];
	assume wf(Heap_$_81,Mask_$_83);
	assume inhaleHeap#_1337_$_0[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState] == Heap_$_81;
	assume Fractions(100) > 0;
	assume Mask_$_84 == Mask_$_83[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState := Mask_$_83[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_83[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_84);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState]);
	assume wf(Heap_$_81,Mask_$_84);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_84);
	assume !(Heap_$_81[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_82 == Heap_$_81[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1337_$_0[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_82,Mask_$_84);
	assume (Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_85 == Mask_$_84[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := Mask_$_84[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := Mask_$_84[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_85);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_82,Mask_$_85);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_85);
	assume !(Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_83 == Heap_$_82[Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := inhaleHeap#_1337_$_0[Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]];
	assume wf(Heap_$_83,Mask_$_85);
	assume (Heap_$_83[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null) || (dtype(Heap_$_83[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_86 == Mask_$_85[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := Mask_$_85[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := Mask_$_85[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_86);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]);
	assume wf(Heap_$_83,Mask_$_86);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_86);
	assume !(Heap_$_83[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_84 == Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1337_$_0[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_84,Mask_$_86);
	assume (Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_87 == Mask_$_86[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := Mask_$_86[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := Mask_$_86[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_87);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_84,Mask_$_87);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_87);
	assume !(Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_85 == Heap_$_84[Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := inhaleHeap#_1337_$_0[Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]];
	assume wf(Heap_$_85,Mask_$_87);
	assume (Heap_$_85[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null) || (dtype(Heap_$_85[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_88 == Mask_$_87[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := Mask_$_87[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := Mask_$_87[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_88);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]);
	assume wf(Heap_$_85,Mask_$_88);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_88);
	assume !(Heap_$_85[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assume !(Heap_$_85[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_86 == Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp := inhaleHeap#_1337_$_0[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp]];
	assume wf(Heap_$_86,Mask_$_88);
	assume (Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp] == null) || (dtype(Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_89 == Mask_$_88[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp := Mask_$_88[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp][perm$R := Mask_$_88[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_89);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp]);
	assume wf(Heap_$_86,Mask_$_89);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_89);
	assume !(Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_87 == Heap_$_86[Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch := inhaleHeap#_1337_$_0[Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch]];
	assume wf(Heap_$_87,Mask_$_89);
	assume (Heap_$_87[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch] == null) || (dtype(Heap_$_87[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_90 == Mask_$_89[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch := Mask_$_89[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch][perm$R := Mask_$_89[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_90);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch]);
	assume wf(Heap_$_87,Mask_$_90);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_90);
	assume Heap_$_87[nw#_1321_$_0,FactorialCont.v] >= 0;
	assume Heap_$_87[nw#_1321_$_0,FactorialCont.vo] >= 0;
	assume vp#144_$_0 == Heap_$_87[nw#_1321_$_0,FactorialCont.v];
	assume vop#145_$_0 == Heap_$_87[nw#_1321_$_0,FactorialCont.vo];
	if ($_$_condition_$15) { goto anon88_Then; } else { goto anon88_Else; }
anon18:
	assume wf(Heap_$_103,exhaleMask#_1213_$_5);
	assume IsGoodInhaleState(inhaleHeap#_1221_$_0,Heap_$_103,exhaleMask#_1213_$_5);
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_120 == Heap_$_103[nw#_1208_$_0,Message.invFinalResult := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.invFinalResult]];
	assume wf(Heap_$_120,exhaleMask#_1213_$_5);
	assume inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.invFinalResult] == Heap_$_120;
	assume Fractions(100) > 0;
	assume Mask_$_207 == exhaleMask#_1213_$_5[nw#_1208_$_0,Message.invFinalResult := exhaleMask#_1213_$_5[nw#_1208_$_0,Message.invFinalResult][perm$R := exhaleMask#_1213_$_5[nw#_1208_$_0,Message.invFinalResult][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_207);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.invFinalResult]);
	assume wf(Heap_$_120,Mask_$_207);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_207);
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_121 == Heap_$_120[nw#_1208_$_0,Message.type := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]];
	assume wf(Heap_$_121,Mask_$_207);
	assume true;
	assume monitorK > 0;
	assume Mask_$_208 == Mask_$_207[nw#_1208_$_0,Message.type := Mask_$_207[nw#_1208_$_0,Message.type][perm$R := Mask_$_207[nw#_1208_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_208);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]);
	assume wf(Heap_$_121,Mask_$_208);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_208);
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_122 == Heap_$_121[nw#_1208_$_0,Message.type := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]];
	assume wf(Heap_$_122,Mask_$_208);
	assume true;
	assume monitorK > 0;
	assume Mask_$_209 == Mask_$_208[nw#_1208_$_0,Message.type := Mask_$_208[nw#_1208_$_0,Message.type][perm$R := Mask_$_208[nw#_1208_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_209);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]);
	assume wf(Heap_$_122,Mask_$_209);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_209);
	assume Heap_$_122[nw#_1208_$_0,Message.type] == 4;
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_123 == Heap_$_122[nw#_1208_$_0,Message.vr3 := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.vr3]];
	assume wf(Heap_$_123,Mask_$_209);
	assume true;
	assume monitorK > 0;
	assume Mask_$_210 == Mask_$_209[nw#_1208_$_0,Message.vr3 := Mask_$_209[nw#_1208_$_0,Message.vr3][perm$R := Mask_$_209[nw#_1208_$_0,Message.vr3][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_210);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.vr3]);
	assume wf(Heap_$_123,Mask_$_210);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_210);
	assume Heap_$_123[nw#_1208_$_0,Message.vr3] == 1;
	assume IsGoodMask(Mask_$_210);
	assume wf(Heap_$_123,Mask_$_210);
	assert { :msg "  762.14: Receiver might be null." } true ==> (!(nw#_1208_$_0 == null));
	assert { :msg "  762.14: Location might not be readable." } true ==> CanRead(Mask_$_210,nw#_1208_$_0,Message.vr3);
	assert { :msg "  762.33: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  762.33: Location might not be readable." } true ==> CanRead(Mask_$_210,mo#131_$_0,Message.vo1);
	assert { :msg "  762.21: Receiver might be null." } true ==> (!(nw#_1208_$_0 == null));
	assume (0 < funcappK#_1235) && ((1000 * funcappK#_1235) < Fractions(1));
	assume true;
	assert { :msg "  762.21: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_123[mo#131_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_123,Mask_$_210);
	assert { :msg "  762.7: Assertion might not hold. The expression at 762.14 might not evaluate to true." } Heap_$_123[nw#_1208_$_0,Message.vr3] == #Message.factorial(Heap_$_123,Mask_$_210,nw#_1208_$_0,Heap_$_123[mo#131_$_0,Message.vo1]);
	assume wf(Heap_$_123,Mask_$_210);
	assume ((0 < unfoldK#_1237) && (unfoldK#_1237 < Fractions(1))) && ((1000 * unfoldK#_1237) < whileK#_1176);
	assert { :msg "  763.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  763.14: Location might not be readable." } true ==> CanRead(Mask_$_210,mo#131_$_0,Message.sender1);
	assert { :msg "  763.14: Receiver might be null." } true ==> (!(Heap_$_123[mo#131_$_0,Message.sender1] == null));
	assert { :msg "  763.14: Location might not be readable." } true ==> CanRead(Mask_$_210,Heap_$_123[mo#131_$_0,Message.sender1],Future.q);
	assert { :msg "  763.7: The target of the fold statement might be null." } !(Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q] == null);
	assert { :msg "  763.7: unfold might fail because the predicate FutureChannel.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  763.7: unfold might fail because the predicate FutureChannel.valid does not hold. Insufficient fraction at <undefined position> for FutureChannel.valid." } (Fractions(100) <= Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) && ((Fractions(100) == Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) ==> (0 <= Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$N]));
	assume exhaleMask#_1238_$_0 == Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid := Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R := Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_210);
	assume wf(Heap_$_123,Mask_$_210);
	assume wf(Heap_$_123,exhaleMask#_1238_$_0);
	assume wf(Heap_$_123,exhaleMask#_1238_$_0);
	assume inhaleHeap#_1240_$_0 == Heap_$_123[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid];
	assume IsGoodInhaleState(inhaleHeap#_1240_$_0,Heap_$_123,exhaleMask#_1238_$_0);
	assume !(Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_124 == Heap_$_123[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp := inhaleHeap#_1240_$_0[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp]];
	assume wf(Heap_$_124,exhaleMask#_1238_$_0);
	assume (Heap_$_124[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null) || (dtype(Heap_$_124[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp]) == FutureChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_211 == exhaleMask#_1238_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp := exhaleMask#_1238_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp][perm$R := exhaleMask#_1238_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_211);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp]);
	assume wf(Heap_$_124,Mask_$_211);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_211);
	assume !(Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_125 == Heap_$_124[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := inhaleHeap#_1240_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]];
	assume wf(Heap_$_125,Mask_$_211);
	assume (Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null) || (dtype(Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]) == FutureChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_212 == Mask_$_211[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := Mask_$_211[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R := Mask_$_211[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_212);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]);
	assume wf(Heap_$_125,Mask_$_212);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_212);
	assume !(Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null);
	assume Heap_$_126 == Heap_$_125[Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch := inhaleHeap#_1240_$_0[Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch]];
	assume wf(Heap_$_126,Mask_$_212);
	assume (Heap_$_126[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch] == null) || (dtype(Heap_$_126[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch]) == FutureChannel#t);
	assume monitorK > 0;
	assume Mask_$_213 == Mask_$_212[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch := Mask_$_212[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch][perm$R := Mask_$_212[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_213);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch]);
	assume wf(Heap_$_126,Mask_$_213);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_213);
	assume !(Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume Heap_$_127 == Heap_$_126[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch := inhaleHeap#_1240_$_0[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch]];
	assume wf(Heap_$_127,Mask_$_213);
	assume (Heap_$_127[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch] == null) || (dtype(Heap_$_127[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch]) == FutureChannel#t);
	assume monitorK > 0;
	assume Mask_$_214 == Mask_$_213[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch := Mask_$_213[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch][perm$R := Mask_$_213[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_214);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch]);
	assume wf(Heap_$_127,Mask_$_214);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_214);
	assume !(Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null);
	assume !(Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume !(Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null);
	assume Heap_$_128 == Heap_$_127[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid := inhaleHeap#_1240_$_0[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid]];
	assume wf(Heap_$_128,Mask_$_214);
	assume inhaleHeap#_1240_$_0[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid] == Heap_$_128;
	assume Fractions(100) > 0;
	assume Mask_$_215 == Mask_$_214[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid := Mask_$_214[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid][perm$R := Mask_$_214[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_215);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid]);
	assume wf(Heap_$_128,Mask_$_215);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_215);
	assume !(Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume Heap_$_129 == Heap_$_128[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid := inhaleHeap#_1240_$_0[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid]];
	assume wf(Heap_$_129,Mask_$_215);
	assume inhaleHeap#_1240_$_0[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid] == Heap_$_129;
	assume Fractions(100) > 0;
	assume Mask_$_216 == Mask_$_215[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid := Mask_$_215[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid][perm$R := Mask_$_215[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_216);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid]);
	assume wf(Heap_$_129,Mask_$_216);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_216);
	assume Heap_$_129[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch] == Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q];
	assume Heap_$_129[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch] == Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q];
	assume IsGoodMask(Mask_$_216);
	assume wf(Heap_$_129,Mask_$_216);
	assume ((0 < unfoldK#_1241) && (unfoldK#_1241 < Fractions(1))) && ((1000 * unfoldK#_1241) < whileK#_1176);
	assert { :msg "  764.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  764.14: Location might not be readable." } true ==> CanRead(Mask_$_216,mo#131_$_0,Message.sender1);
	assert { :msg "  764.14: Receiver might be null." } true ==> (!(Heap_$_129[mo#131_$_0,Message.sender1] == null));
	assert { :msg "  764.14: Location might not be readable." } true ==> CanRead(Mask_$_216,Heap_$_129[mo#131_$_0,Message.sender1],Future.q);
	assert { :msg "  764.7: The target of the fold statement might be null." } !(Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q] == null);
	assert { :msg "  764.7: unfold might fail because the predicate FutureChannel.initExpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  764.7: unfold might fail because the predicate FutureChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FutureChannel.initExpState." } (Fractions(100) <= Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) && ((Fractions(100) == Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) ==> (0 <= Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$N]));
	assume exhaleMask#_1242_$_0 == Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState := Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R := Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_216);
	assume wf(Heap_$_129,Mask_$_216);
	assume wf(Heap_$_129,exhaleMask#_1242_$_0);
	assume wf(Heap_$_129,exhaleMask#_1242_$_0);
	assume inhaleHeap#_1244_$_0 == Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState];
	assume IsGoodInhaleState(inhaleHeap#_1244_$_0,Heap_$_129,exhaleMask#_1242_$_0);
	assume !(Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_130 == Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := inhaleHeap#_1244_$_0[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]];
	assume wf(Heap_$_130,exhaleMask#_1242_$_0);
	assume (Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null) || (dtype(Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]) == FutureChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_217 == exhaleMask#_1242_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := exhaleMask#_1242_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R := exhaleMask#_1242_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_217);
	assume IsGoodState(inhaleHeap#_1244_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]);
	assume wf(Heap_$_130,Mask_$_217);
	assume wf(inhaleHeap#_1244_$_0,Mask_$_217);
	assume !(Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume Heap_$_131 == Heap_$_130[Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state := inhaleHeap#_1244_$_0[Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state]];
	assume wf(Heap_$_131,Mask_$_217);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_218 == Mask_$_217[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state := Mask_$_217[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state][perm$R := Mask_$_217[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume IsGoodState(inhaleHeap#_1244_$_0[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state]);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(inhaleHeap#_1244_$_0,Mask_$_218);
	assume Heap_$_131[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state] == 0;
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume ((0 < methodCallK#_1248) && ((1000 * methodCallK#_1248) < Fractions(1))) && ((1000 * methodCallK#_1248) < whileK#_1176);
	assert { :msg "  765.12: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_218,mo#131_$_0,Message.sender1);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_131[mo#131_$_0,Message.sender1] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_218,Heap_$_131[mo#131_$_0,Message.sender1],Future.q);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_218,Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp);
	assert { :msg "  765.7: The target of the method call might be null." } !(Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume this#135_$_0 == Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp];
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The expression at 400.63 might not evaluate to true." } Heap_$_131[nw#_1208_$_0,Message.type] == 4;
	assert { :msg "  765.7: The precondition at 402.11 might not hold. The expression at 402.11 might not evaluate to true." } Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.11 for FutureChannelExpEP.state." } (Fractions(100) <= Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R]) ==> (0 <= Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$N]));
	assume exhaleMask#_1249_$_0 == Mask_$_218[this#135_$_0,FutureChannelExpEP.state := Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R := Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_0);
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.25 might not be positive." } monitorK > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.25 for Message.type." } (monitorK <= exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$N]));
	assume exhaleMask#_1249_$_1 == exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type := exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R := exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_1);
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.44 might not be positive." } monitorK > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.44 for Message.type." } (monitorK <= exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$N]));
	assume exhaleMask#_1249_$_2 == exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type := exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R := exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_2);
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.76 might not be positive." } Fractions(100) > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.76 for Message.invFinalResult." } (Fractions(100) <= exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$N]));
	assume exhaleMask#_1249_$_3 == exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult := exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R := exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_3);
	assert { :msg "  765.7: The precondition at 401.11 might not hold. The permission at 401.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  765.7: The precondition at 401.11 might not hold. Insufficient fraction at 401.11 for FutureChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1249_$_4 == exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid := exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R := exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_4);
	assume wf(Heap_$_131,exhaleMask#_1249_$_4);
	assume IsGoodInhaleState(inhaleHeap#_1257_$_0,Heap_$_131,exhaleMask#_1249_$_4);
	assume !(this#135_$_0 == null);
	assume Heap_$_132 == Heap_$_131[this#135_$_0,FutureChannelExpEP.state := inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.state]];
	assume wf(Heap_$_132,exhaleMask#_1249_$_4);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_219 == exhaleMask#_1249_$_4[this#135_$_0,FutureChannelExpEP.state := exhaleMask#_1249_$_4[this#135_$_0,FutureChannelExpEP.state][perm$R := exhaleMask#_1249_$_4[this#135_$_0,FutureChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_219);
	assume IsGoodState(inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.state]);
	assume wf(Heap_$_132,Mask_$_219);
	assume wf(inhaleHeap#_1257_$_0,Mask_$_219);
	assume !(this#135_$_0 == null);
	assume Heap_$_133 == Heap_$_132[this#135_$_0,FutureChannelExpEP.valid := inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.valid]];
	assume wf(Heap_$_133,Mask_$_219);
	assume inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.valid] == Heap_$_133;
	assume Fractions(100) > 0;
	assume Mask_$_220 == Mask_$_219[this#135_$_0,FutureChannelExpEP.valid := Mask_$_219[this#135_$_0,FutureChannelExpEP.valid][perm$R := Mask_$_219[this#135_$_0,FutureChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_220);
	assume IsGoodState(inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.valid]);
	assume wf(Heap_$_133,Mask_$_220);
	assume wf(inhaleHeap#_1257_$_0,Mask_$_220);
	if ($_$_condition_$16) { goto anon82_Then; } else { goto anon82_Else; }
anon85_Then:
	assume $_$_condition_$13;
	assume $_$_condition_$13 <==> (Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	assume Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]);
	goto anon31;
anon85_Else:
	assume !$_$_condition_$13;
	assume $_$_condition_$13 <==> (Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	assume !(Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	goto anon31;
anon88_Then:
	assume $_$_condition_$15;
	assume $_$_condition_$15 <==> (!(Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null));
	assume !(Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null);
	assume !(Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null);
	assume Heap_$_88 == Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q := inhaleHeap#_1337_$_0[Heap_$_87[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q]];
	assume wf(Heap_$_88,Mask_$_90);
	assume (Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null) || (dtype(Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q]) == FactorialContChannel#t);
	assume monitorK > 0;
	assume Mask_$_91 == Mask_$_90[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q := Mask_$_90[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R := Mask_$_90[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_91);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q]);
	assume wf(Heap_$_88,Mask_$_91);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_91);
	assume !(Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assume !(Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assume Heap_$_89 == Heap_$_88[Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1337_$_0[Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_89,Mask_$_91);
	assume inhaleHeap#_1337_$_0[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid] == Heap_$_89;
	assume Fractions(100) > 0;
	assume Mask_$_92 == Mask_$_91[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid := Mask_$_91[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_91[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_92);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_89,Mask_$_92);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_92);
	assume !(Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assume Heap_$_90 == Heap_$_89[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState := inhaleHeap#_1337_$_0[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState]];
	assume wf(Heap_$_90,Mask_$_92);
	assume inhaleHeap#_1337_$_0[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState] == Heap_$_90;
	assume Fractions(100) > 0;
	assume Mask_$_93 == Mask_$_92[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState := Mask_$_92[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_92[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_93);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState]);
	assume wf(Heap_$_90,Mask_$_93);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_93);
	assume !(Heap_$_90[nw#_1321_$_0,FactorialCont.cust] == null);
	assume Heap_$_91 == Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo := inhaleHeap#_1337_$_0[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo]];
	assume wf(Heap_$_91,Mask_$_93);
	assume true;
	assume monitorK > 0;
	assume Mask_$_94 == Mask_$_93[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo := Mask_$_93[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R := Mask_$_93[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_94);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo]);
	assume wf(Heap_$_91,Mask_$_94);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_94);
	assume Heap_$_91[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo] == Heap_$_91[nw#_1321_$_0,FactorialCont.vo];
	assume Heap_$_92 == Heap_$_91;
	assume Mask_$_95 == Mask_$_94;
	goto anon41;
anon88_Else:
	assume !$_$_condition_$15;
	assume $_$_condition_$15 <==> (!(Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null));
	assume Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null;
	assume Heap_$_92 == Heap_$_87;
	assume Mask_$_95 == Mask_$_90;
	goto anon41;
anon82_Then:
	assume $_$_condition_$16;
	assume $_$_condition_$16 <==> (Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0);
	assume Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0;
	assume Heap_$_133[this#135_$_0,FutureChannelExpEP.state] == 1;
	goto anon21;
anon82_Else:
	assume !$_$_condition_$16;
	assume $_$_condition_$16 <==> (Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0);
	assume !(Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0);
	goto anon21;
anon31:
	assume wf(Heap_$_119,Mask_$_206);
	assume Mask_$_221 == Mask_$_206;
	assume Credits_$_7 == Credits_$_4;
	assume Heap_$_134 == Heap_$_119;
	goto anon70;
anon41:
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume ((0 < asyncMethodCallK#_1344) && ((1000 * asyncMethodCallK#_1344) < Fractions(1))) && ((1000 * asyncMethodCallK#_1344) < whileK#_1176);
	assert { :msg "  785.6: The target of the method call might be null." } !(nw#_1321_$_0 == null);
	assume argsSeq#_1343_$_0 == argsSeq#_1343[0 := nw#_1321_$_0];
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.54 might not evaluate to true." } !(Heap_$_92[nw#_1321_$_0,FactorialCont.q] == null);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.137 might not evaluate to true." } !(Heap_$_92[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.158 might not evaluate to true." } Heap_$_92[nw#_1321_$_0,FactorialCont.v] >= 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.166 might not evaluate to true." } Heap_$_92[nw#_1321_$_0,FactorialCont.vo] >= 0;
	if ($_$_condition_$17) { goto anon89_Then; } else { goto anon89_Else; }
anon21:
	assume IsGoodMask(Mask_$_220);
	assume wf(Heap_$_133,Mask_$_220);
	assume Mask_$_221 == Mask_$_220;
	assume Credits_$_7 == Credits_$_4;
	assume Heap_$_134 == Heap_$_133;
	goto anon70;
anon89_Then:
	assume $_$_condition_$17;
	assume $_$_condition_$17 <==> (!(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null));
	assume !(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The expression at 840.65 might not evaluate to true." } !(Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The expression at 840.140 might not evaluate to true." } Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo] == Heap_$_92[nw#_1321_$_0,FactorialCont.vo];
	goto anon44;
anon89_Else:
	assume !$_$_condition_$17;
	assume $_$_condition_$17 <==> (!(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null));
	assume Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null;
	goto anon44;
anon44:
	assume Credits_$_6 == Credits_$_4[Heap_$_92[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] := Credits_$_4[Heap_$_92[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]] - 1];
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.11 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.11 for FactorialCont.q." } (monitorK <= Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R]) && ((monitorK == Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R]) ==> (0 <= Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1345_$_0 == Mask_$_95[nw#_1321_$_0,FactorialCont.q := Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R := Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_0);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.25 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.25 for FactorialCont.v." } (monitorK <= exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1345_$_1 == exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v := exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R := exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_1);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.39 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.39 for FactorialCont.vo." } (monitorK <= exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1345_$_2 == exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo := exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R := exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_2);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.66 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.66 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1345_$_3 == exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_3);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.77 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.77 for FactorialContChannel.initImpState." } (Fractions(100) <= exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$N]));
	assume exhaleMask#_1345_$_4 == exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState := exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R := exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_4);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.95 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.95 for FactorialContChannel.imp." } (monitorK <= exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$N]));
	assume exhaleMask#_1345_$_5 == exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_5);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.113 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.113 for FactorialContChannelImpEP.impch." } (monitorK <= exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1345_$_6 == exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_6);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.11 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.11 for FactorialCont.cust." } (monitorK <= exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R]) && ((monitorK == exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$N]));
	assume exhaleMask#_1345_$_7 == exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust := exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R := exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_7);
	if ($_$_condition_$18) { goto anon90_Then; } else { goto anon90_Else; }
anon90_Then:
	assume $_$_condition_$18;
	assume $_$_condition_$18 <==> (!(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null));
	assume !(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.46 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.46 for FactorialCont.q." } (monitorK <= exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$N]));
	assume exhaleMask#_1345_$_8 == exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q := exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R := exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_8);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.81 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.81 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1345_$_9 == exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_9);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.97 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.97 for FactorialContChannel.initExpState." } (Fractions(100) <= exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1345_$_10 == exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState := exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R := exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_10);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.120 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.120 for FactorialCont.vo." } (monitorK <= exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$N]));
	assume exhaleMask#_1345_$_11 == exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo := exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R := exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_11);
	assume exhaleMask#_1345_$_12 == exhaleMask#_1345_$_11;
	goto anon47;
anon90_Else:
	assume !$_$_condition_$18;
	assume $_$_condition_$18 <==> (!(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null));
	assume Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null;
	assume exhaleMask#_1345_$_12 == exhaleMask#_1345_$_7;
	goto anon47;
anon47:
	assume wf(Heap_$_92,exhaleMask#_1345_$_12);
	assume !(token#_1338_$_0 == null);
	assume Heap_$_92[token#_1338_$_0,joinable] == 0;
	assume exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$N] == 0;
	assume exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$R] == 0;
	assume Mask_$_96 == exhaleMask#_1345_$_12[token#_1338_$_0,joinable := exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$R := exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$R] + Fractions(100)]];
	assume !(asyncstate#_1339_$_0 == 0);
	assume Heap_$_93 == Heap_$_92[token#_1338_$_0,joinable := asyncstate#_1339_$_0];
	assume Heap_$_94 == Heap_$_93[token#_1338_$_0,forkK := asyncMethodCallK#_1344];
	assume wf(Heap_$_94,Mask_$_96);
	assume (!(nw#_1358_$_0 == null)) && (dtype(nw#_1358_$_0) == Message#t);
	assume (((((forall  f_$17_$0 : Field (Boolean)  :: ( (Mask_$_96[nw#_1358_$_0,f_$17_$0][perm$R] == 0) && (Mask_$_96[nw#_1358_$_0,f_$17_$0][perm$N] == 0) ))) && ((forall  f_$17_$1 : Field (Integer)  :: ( (Mask_$_96[nw#_1358_$_0,f_$17_$1][perm$R] == 0) && (Mask_$_96[nw#_1358_$_0,f_$17_$1][perm$N] == 0) )))) && ((forall  f_$17_$2 : Field (ref)  :: ( (Mask_$_96[nw#_1358_$_0,f_$17_$2][perm$R] == 0) && (Mask_$_96[nw#_1358_$_0,f_$17_$2][perm$N] == 0) )))) && ((forall  f_$17_$3 : Field (HeapType)  :: ( (Mask_$_96[nw#_1358_$_0,f_$17_$3][perm$R] == 0) && (Mask_$_96[nw#_1358_$_0,f_$17_$3][perm$N] == 0) )))) && ((forall  f_$17_$4 : Field (Mu)  :: ( (Mask_$_96[nw#_1358_$_0,f_$17_$4][perm$R] == 0) && (Mask_$_96[nw#_1358_$_0,f_$17_$4][perm$N] == 0) )));
	assume Heap_$_94[nw#_1358_$_0,mu] == $LockBottom;
	assume Heap_$_94[nw#_1358_$_0,held] <= 0;
	assume Heap_$_94[nw#_1358_$_0,rdheld] <==> false;
	assume Mask_$_97 == Mask_$_96[nw#_1358_$_0,Message.type := Mask_$_96[nw#_1358_$_0,Message.type][perm$R := Mask_$_96[nw#_1358_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_98 == Mask_$_97[nw#_1358_$_0,Message.sender1 := Mask_$_97[nw#_1358_$_0,Message.sender1][perm$R := Mask_$_97[nw#_1358_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_99 == Mask_$_98[nw#_1358_$_0,Message.sender3 := Mask_$_98[nw#_1358_$_0,Message.sender3][perm$R := Mask_$_98[nw#_1358_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_100 == Mask_$_99[nw#_1358_$_0,Message.sender2 := Mask_$_99[nw#_1358_$_0,Message.sender2][perm$R := Mask_$_99[nw#_1358_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_101 == Mask_$_100[nw#_1358_$_0,Message.sender4 := Mask_$_100[nw#_1358_$_0,Message.sender4][perm$R := Mask_$_100[nw#_1358_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_102 == Mask_$_101[nw#_1358_$_0,Message.receiver1 := Mask_$_101[nw#_1358_$_0,Message.receiver1][perm$R := Mask_$_101[nw#_1358_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_103 == Mask_$_102[nw#_1358_$_0,Message.receiver2 := Mask_$_102[nw#_1358_$_0,Message.receiver2][perm$R := Mask_$_102[nw#_1358_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_104 == Mask_$_103[nw#_1358_$_0,Message.receiver3 := Mask_$_103[nw#_1358_$_0,Message.receiver3][perm$R := Mask_$_103[nw#_1358_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_105 == Mask_$_104[nw#_1358_$_0,Message.receiver4 := Mask_$_104[nw#_1358_$_0,Message.receiver4][perm$R := Mask_$_104[nw#_1358_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_106 == Mask_$_105[nw#_1358_$_0,Message.v1 := Mask_$_105[nw#_1358_$_0,Message.v1][perm$R := Mask_$_105[nw#_1358_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_107 == Mask_$_106[nw#_1358_$_0,Message.vo1 := Mask_$_106[nw#_1358_$_0,Message.vo1][perm$R := Mask_$_106[nw#_1358_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_108 == Mask_$_107[nw#_1358_$_0,Message.cust1 := Mask_$_107[nw#_1358_$_0,Message.cust1][perm$R := Mask_$_107[nw#_1358_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_109 == Mask_$_108[nw#_1358_$_0,Message.vr1 := Mask_$_108[nw#_1358_$_0,Message.vr1][perm$R := Mask_$_108[nw#_1358_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_110 == Mask_$_109[nw#_1358_$_0,Message.old1 := Mask_$_109[nw#_1358_$_0,Message.old1][perm$R := Mask_$_109[nw#_1358_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_111 == Mask_$_110[nw#_1358_$_0,Message.vr2 := Mask_$_110[nw#_1358_$_0,Message.vr2][perm$R := Mask_$_110[nw#_1358_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_112 == Mask_$_111[nw#_1358_$_0,Message.old2 := Mask_$_111[nw#_1358_$_0,Message.old2][perm$R := Mask_$_111[nw#_1358_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_113 == Mask_$_112[nw#_1358_$_0,Message.vr3 := Mask_$_112[nw#_1358_$_0,Message.vr3][perm$R := Mask_$_112[nw#_1358_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_114 == Mask_$_113[nw#_1358_$_0,mu := Mask_$_113[nw#_1358_$_0,mu][perm$R := Mask_$_113[nw#_1358_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  788.6: Location might not be writable" } CanWrite(Mask_$_114,nw#_1358_$_0,Message.sender1);
	assert { :msg "  788.17: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  788.17: Location might not be readable." } true ==> CanRead(Mask_$_114,mo#131_$_0,Message.sender1);
	assume Heap_$_95 == Heap_$_94[nw#_1358_$_0,Message.sender1 := Heap_$_94[mo#131_$_0,Message.sender1]];
	assume wf(Heap_$_95,Mask_$_114);
	assume ((0 < methodCallK#_1362) && ((1000 * methodCallK#_1362) < Fractions(1))) && ((1000 * methodCallK#_1362) < whileK#_1176);
	assert { :msg "  789.6: The target of the method call might be null." } !(nw#_1358_$_0 == null);
	assert { :msg "  789.22: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  789.22: Location might not be readable." } true ==> CanRead(Mask_$_114,mo#131_$_0,Message.v1);
	assert { :msg "  789.35: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  789.35: Location might not be readable." } true ==> CanRead(Mask_$_114,mo#131_$_0,Message.vo1);
	assume v#149_$_0 == (Heap_$_95[mo#131_$_0,Message.v1] - 1);
	assume vo#150_$_0 == Heap_$_95[mo#131_$_0,Message.vo1];
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 661.3 might not evaluate to true." } !(Heap_$_95[nw#_1358_$_0,Message.sender1] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 661.42 might not evaluate to true." } !(Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 662.48 might not evaluate to true." } v#149_$_0 >= 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 662.56 might not evaluate to true." } vo#150_$_0 >= 0;
	if ($_$_condition_$19) { goto anon91_Then; } else { goto anon91_Else; }
anon91_Then:
	assume $_$_condition_$19;
	assume $_$_condition_$19 <==> (nw#_1321_$_0 == null);
	assume nw#_1321_$_0 == null;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 663.19 might not evaluate to true." } v#149_$_0 == vo#150_$_0;
	goto $branchMerge_2;
anon91_Else:
	assume !$_$_condition_$19;
	assume $_$_condition_$19 <==> (nw#_1321_$_0 == null);
	assume !(nw#_1321_$_0 == null);
	goto $branchMerge_2;
anon92_Then:
	assume $_$_condition_$20;
	assume $_$_condition_$20 <==> (!(nw#_1321_$_0 == null));
	assume !(nw#_1321_$_0 == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 664.23 might not evaluate to true." } !(Heap_$_95[nw#_1321_$_0,FactorialCont.q] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 665.55 might not evaluate to true." } !(Heap_$_95[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 666.23 might not evaluate to true." } v#149_$_0 == (Heap_$_95[nw#_1321_$_0,FactorialCont.v] - 1);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 666.38 might not evaluate to true." } vo#150_$_0 == Heap_$_95[nw#_1321_$_0,FactorialCont.vo];
	goto anon53;
anon92_Else:
	assume !$_$_condition_$20;
	assume $_$_condition_$20 <==> (!(nw#_1321_$_0 == null));
	assume nw#_1321_$_0 == null;
	goto anon53;
anon53:
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.11 for Message.type." } (Fractions(100) <= Mask_$_114[nw#_1358_$_0,Message.type][perm$R]) && ((Fractions(100) == Mask_$_114[nw#_1358_$_0,Message.type][perm$R]) ==> (0 <= Mask_$_114[nw#_1358_$_0,Message.type][perm$N]));
	assume exhaleMask#_1363_$_0 == Mask_$_114[nw#_1358_$_0,Message.type := Mask_$_114[nw#_1358_$_0,Message.type][perm$R := Mask_$_114[nw#_1358_$_0,Message.type][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_0);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.24 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.24 for Message.sender1." } (Fractions(100) <= exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R]) ==> (0 <= exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$N]));
	assume exhaleMask#_1363_$_1 == exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1 := exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R := exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_1);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.40 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.40 for Message.receiver1." } (Fractions(100) <= exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R]) ==> (0 <= exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$N]));
	assume exhaleMask#_1363_$_2 == exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1 := exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R := exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_2);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.3 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.3 for Message.v1." } (Fractions(100) <= exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R]) ==> (0 <= exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$N]));
	assume exhaleMask#_1363_$_3 == exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1 := exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R := exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_3);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.14 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.14 for Message.vo1." } (Fractions(100) <= exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$N]));
	assume exhaleMask#_1363_$_4 == exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1 := exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R := exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_4);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.26 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.26 for Message.cust1." } (Fractions(100) <= exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R]) ==> (0 <= exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$N]));
	assume exhaleMask#_1363_$_5 == exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1 := exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R := exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_5);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 661.20 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 661.20 for Future.q." } (monitorK <= exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R]) && ((monitorK == exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R]) ==> (0 <= exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$N]));
	assume exhaleMask#_1363_$_6 == exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q := exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R := exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_6);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 662.3 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 662.3 for FutureChannel.valid." } (Fractions(100) <= exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$N]));
	assume exhaleMask#_1363_$_7 == exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid := exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R := exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_7);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 662.22 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 662.22 for FutureChannel.initExpState." } (Fractions(100) <= exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$N]));
	assume exhaleMask#_1363_$_8 == exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState := exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R := exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_8);
	if ($_$_condition_$22) { goto anon93_Then; } else { goto anon93_Else; }
anon93_Then:
	assume $_$_condition_$22;
	assume $_$_condition_$22 <==> (nw#_1321_$_0 == null);
	assume nw#_1321_$_0 == null;
	goto $branchMerge_3;
anon93_Else:
	assume !$_$_condition_$22;
	assume $_$_condition_$22 <==> (nw#_1321_$_0 == null);
	assume !(nw#_1321_$_0 == null);
	goto $branchMerge_3;
anon94_Then:
	assume $_$_condition_$23;
	assume $_$_condition_$23 <==> (!(nw#_1321_$_0 == null));
	assume !(nw#_1321_$_0 == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.4 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.4 for FactorialCont.q." } (monitorK <= exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1363_$_9 == exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q := exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R := exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_9);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.39 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.39 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1363_$_10 == exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_10);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.55 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.55 for FactorialContChannel.initExpState." } (Fractions(100) <= exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1363_$_11 == exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState := exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R := exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_11);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.3 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.3 for FactorialContChannel.imp." } (monitorK <= exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$N]));
	assume exhaleMask#_1363_$_12 == exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_12);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.26 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.26 for FactorialContChannelImpEP.impch." } (monitorK <= exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1363_$_13 == exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_13);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.81 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.81 for FactorialCont.v." } (monitorK <= exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1363_$_14 == exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v := exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R := exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_14);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 666.3 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 666.3 for FactorialCont.vo." } (monitorK <= exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1363_$_15 == exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo := exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R := exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_15);
	assume exhaleMask#_1363_$_16 == exhaleMask#_1363_$_15;
	goto anon59;
anon94_Else:
	assume !$_$_condition_$23;
	assume $_$_condition_$23 <==> (!(nw#_1321_$_0 == null));
	assume nw#_1321_$_0 == null;
	assume exhaleMask#_1363_$_16 == exhaleMask#_1363_$_8;
	goto anon59;
anon59:
	assume wf(Heap_$_95,exhaleMask#_1363_$_16);
	assume IsGoodInhaleState(inhaleHeap#_1382_$_0,Heap_$_95,exhaleMask#_1363_$_16);
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_96 == Heap_$_95[nw#_1358_$_0,Message.invValue := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.invValue]];
	assume wf(Heap_$_96,exhaleMask#_1363_$_16);
	assume inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.invValue] == Heap_$_96;
	assume Fractions(100) > 0;
	assume Mask_$_115 == exhaleMask#_1363_$_16[nw#_1358_$_0,Message.invValue := exhaleMask#_1363_$_16[nw#_1358_$_0,Message.invValue][perm$R := exhaleMask#_1363_$_16[nw#_1358_$_0,Message.invValue][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_115);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.invValue]);
	assume wf(Heap_$_96,Mask_$_115);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_115);
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_97 == Heap_$_96[nw#_1358_$_0,Message.type := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]];
	assume wf(Heap_$_97,Mask_$_115);
	assume true;
	assume monitorK > 0;
	assume Mask_$_116 == Mask_$_115[nw#_1358_$_0,Message.type := Mask_$_115[nw#_1358_$_0,Message.type][perm$R := Mask_$_115[nw#_1358_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_116);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]);
	assume wf(Heap_$_97,Mask_$_116);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_116);
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_98 == Heap_$_97[nw#_1358_$_0,Message.type := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]];
	assume wf(Heap_$_98,Mask_$_116);
	assume true;
	assume monitorK > 0;
	assume Mask_$_117 == Mask_$_116[nw#_1358_$_0,Message.type := Mask_$_116[nw#_1358_$_0,Message.type][perm$R := Mask_$_116[nw#_1358_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_117);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]);
	assume wf(Heap_$_98,Mask_$_117);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_117);
	assume Heap_$_98[nw#_1358_$_0,Message.type] == 1;
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_99 == Heap_$_98[nw#_1358_$_0,Message.vo1 := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.vo1]];
	assume wf(Heap_$_99,Mask_$_117);
	assume true;
	assume monitorK > 0;
	assume Mask_$_118 == Mask_$_117[nw#_1358_$_0,Message.vo1 := Mask_$_117[nw#_1358_$_0,Message.vo1][perm$R := Mask_$_117[nw#_1358_$_0,Message.vo1][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_118);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.vo1]);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_118);
	assume Heap_$_99[nw#_1358_$_0,Message.vo1] >= 0;
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume ((0 < methodCallK#_1386) && ((1000 * methodCallK#_1386) < Fractions(1))) && ((1000 * methodCallK#_1386) < whileK#_1176);
	assert { :msg "  790.11: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  790.11: Location might not be readable." } true ==> CanRead(Mask_$_118,this,FactorialActor.q);
	assert { :msg "  790.11: Receiver might be null." } true ==> (!(Heap_$_99[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_118,Heap_$_99[this,FactorialActor.q],FactorialActorChannel.exp);
	assert { :msg "  790.6: The target of the method call might be null." } !(Heap_$_99[Heap_$_99[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume this#153_$_0 == Heap_$_99[Heap_$_99[this,FactorialActor.q],FactorialActorChannel.exp];
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The expression at 34.63 might not evaluate to true." } Heap_$_99[nw#_1358_$_0,Message.type] == 1;
	assert { :msg "  790.6: The precondition at 36.11 might not hold. The expression at 36.11 might not evaluate to true." } Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.11 for FactorialActorChannelExpEP.state." } (Fractions(100) <= Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$N]));
	assume exhaleMask#_1387_$_0 == Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state := Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R := Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_0);
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.25 might not be positive." } monitorK > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.25 for Message.type." } (monitorK <= exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$N]));
	assume exhaleMask#_1387_$_1 == exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type := exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R := exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_1);
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.44 might not be positive." } monitorK > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.44 for Message.type." } (monitorK <= exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$N]));
	assume exhaleMask#_1387_$_2 == exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type := exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R := exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_2);
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.76 might not be positive." } Fractions(100) > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.76 for Message.invValue." } (Fractions(100) <= exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R]) ==> (0 <= exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$N]));
	assume exhaleMask#_1387_$_3 == exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue := exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R := exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_3);
	assert { :msg "  790.6: The precondition at 35.11 might not hold. The permission at 35.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  790.6: The precondition at 35.11 might not hold. Insufficient fraction at 35.11 for FactorialActorChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1387_$_4 == exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid := exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_4);
	assume wf(Heap_$_99,exhaleMask#_1387_$_4);
	assume IsGoodInhaleState(inhaleHeap#_1395_$_0,Heap_$_99,exhaleMask#_1387_$_4);
	assume !(this#153_$_0 == null);
	assume Heap_$_100 == Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state := inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_100,exhaleMask#_1387_$_4);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_119 == exhaleMask#_1387_$_4[this#153_$_0,FactorialActorChannelExpEP.state := exhaleMask#_1387_$_4[this#153_$_0,FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1387_$_4[this#153_$_0,FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_119);
	assume IsGoodState(inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_100,Mask_$_119);
	assume wf(inhaleHeap#_1395_$_0,Mask_$_119);
	assume !(this#153_$_0 == null);
	assume Heap_$_101 == Heap_$_100[this#153_$_0,FactorialActorChannelExpEP.valid := inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_101,Mask_$_119);
	assume inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.valid] == Heap_$_101;
	assume Fractions(100) > 0;
	assume Mask_$_120 == Mask_$_119[this#153_$_0,FactorialActorChannelExpEP.valid := Mask_$_119[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R := Mask_$_119[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_120);
	assume IsGoodState(inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_101,Mask_$_120);
	assume wf(inhaleHeap#_1395_$_0,Mask_$_120);
	if ($_$_condition_$25) { goto anon95_Then; } else { goto anon95_Else; }
anon95_Then:
	assume $_$_condition_$25;
	assume $_$_condition_$25 <==> (Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0);
	assume Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0;
	assume Heap_$_101[this#153_$_0,FactorialActorChannelExpEP.state] == 0;
	goto anon62;
anon95_Else:
	assume !$_$_condition_$25;
	assume $_$_condition_$25 <==> (Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0);
	assume !(Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0);
	goto anon62;
anon62:
	assume IsGoodMask(Mask_$_120);
	assume wf(Heap_$_101,Mask_$_120);
	assume (!(nw#_1396_$_0 == null)) && (dtype(nw#_1396_$_0) == Message#t);
	assume (((((forall  f_$18_$0 : Field (Boolean)  :: ( (Mask_$_120[nw#_1396_$_0,f_$18_$0][perm$R] == 0) && (Mask_$_120[nw#_1396_$_0,f_$18_$0][perm$N] == 0) ))) && ((forall  f_$18_$1 : Field (Integer)  :: ( (Mask_$_120[nw#_1396_$_0,f_$18_$1][perm$R] == 0) && (Mask_$_120[nw#_1396_$_0,f_$18_$1][perm$N] == 0) )))) && ((forall  f_$18_$2 : Field (ref)  :: ( (Mask_$_120[nw#_1396_$_0,f_$18_$2][perm$R] == 0) && (Mask_$_120[nw#_1396_$_0,f_$18_$2][perm$N] == 0) )))) && ((forall  f_$18_$3 : Field (HeapType)  :: ( (Mask_$_120[nw#_1396_$_0,f_$18_$3][perm$R] == 0) && (Mask_$_120[nw#_1396_$_0,f_$18_$3][perm$N] == 0) )))) && ((forall  f_$18_$4 : Field (Mu)  :: ( (Mask_$_120[nw#_1396_$_0,f_$18_$4][perm$R] == 0) && (Mask_$_120[nw#_1396_$_0,f_$18_$4][perm$N] == 0) )));
	assume Heap_$_101[nw#_1396_$_0,mu] == $LockBottom;
	assume Heap_$_101[nw#_1396_$_0,held] <= 0;
	assume Heap_$_101[nw#_1396_$_0,rdheld] <==> false;
	assume Mask_$_121 == Mask_$_120[nw#_1396_$_0,Message.type := Mask_$_120[nw#_1396_$_0,Message.type][perm$R := Mask_$_120[nw#_1396_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_122 == Mask_$_121[nw#_1396_$_0,Message.sender1 := Mask_$_121[nw#_1396_$_0,Message.sender1][perm$R := Mask_$_121[nw#_1396_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_123 == Mask_$_122[nw#_1396_$_0,Message.sender3 := Mask_$_122[nw#_1396_$_0,Message.sender3][perm$R := Mask_$_122[nw#_1396_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_124 == Mask_$_123[nw#_1396_$_0,Message.sender2 := Mask_$_123[nw#_1396_$_0,Message.sender2][perm$R := Mask_$_123[nw#_1396_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_125 == Mask_$_124[nw#_1396_$_0,Message.sender4 := Mask_$_124[nw#_1396_$_0,Message.sender4][perm$R := Mask_$_124[nw#_1396_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_126 == Mask_$_125[nw#_1396_$_0,Message.receiver1 := Mask_$_125[nw#_1396_$_0,Message.receiver1][perm$R := Mask_$_125[nw#_1396_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_127 == Mask_$_126[nw#_1396_$_0,Message.receiver2 := Mask_$_126[nw#_1396_$_0,Message.receiver2][perm$R := Mask_$_126[nw#_1396_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_128 == Mask_$_127[nw#_1396_$_0,Message.receiver3 := Mask_$_127[nw#_1396_$_0,Message.receiver3][perm$R := Mask_$_127[nw#_1396_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_129 == Mask_$_128[nw#_1396_$_0,Message.receiver4 := Mask_$_128[nw#_1396_$_0,Message.receiver4][perm$R := Mask_$_128[nw#_1396_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_130 == Mask_$_129[nw#_1396_$_0,Message.v1 := Mask_$_129[nw#_1396_$_0,Message.v1][perm$R := Mask_$_129[nw#_1396_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_131 == Mask_$_130[nw#_1396_$_0,Message.vo1 := Mask_$_130[nw#_1396_$_0,Message.vo1][perm$R := Mask_$_130[nw#_1396_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_132 == Mask_$_131[nw#_1396_$_0,Message.cust1 := Mask_$_131[nw#_1396_$_0,Message.cust1][perm$R := Mask_$_131[nw#_1396_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_133 == Mask_$_132[nw#_1396_$_0,Message.vr1 := Mask_$_132[nw#_1396_$_0,Message.vr1][perm$R := Mask_$_132[nw#_1396_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_134 == Mask_$_133[nw#_1396_$_0,Message.old1 := Mask_$_133[nw#_1396_$_0,Message.old1][perm$R := Mask_$_133[nw#_1396_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_135 == Mask_$_134[nw#_1396_$_0,Message.vr2 := Mask_$_134[nw#_1396_$_0,Message.vr2][perm$R := Mask_$_134[nw#_1396_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_136 == Mask_$_135[nw#_1396_$_0,Message.old2 := Mask_$_135[nw#_1396_$_0,Message.old2][perm$R := Mask_$_135[nw#_1396_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_137 == Mask_$_136[nw#_1396_$_0,Message.vr3 := Mask_$_136[nw#_1396_$_0,Message.vr3][perm$R := Mask_$_136[nw#_1396_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_138 == Mask_$_137[nw#_1396_$_0,mu := Mask_$_137[nw#_1396_$_0,mu][perm$R := Mask_$_137[nw#_1396_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  793.6: Location might not be writable" } CanWrite(Mask_$_138,nw#_1396_$_0,Message.type);
	assume Heap_$_102 == Heap_$_101[nw#_1396_$_0,Message.type := 4];
	assume wf(Heap_$_102,Mask_$_138);
	assert { :msg "  794.13: Receiver might be null." } true ==> (!(nw#_1396_$_0 == null));
	assert { :msg "  794.13: Location might not be readable." } true ==> CanRead(Mask_$_138,nw#_1396_$_0,Message.vr3);
	assert { :msg "  794.32: Receiver might be null." } true ==> (!(nw#_1358_$_0 == null));
	assert { :msg "  794.32: Location might not be readable." } true ==> CanRead(Mask_$_138,nw#_1358_$_0,Message.vo1);
	assert { :msg "  794.20: Receiver might be null." } true ==> (!(nw#_1358_$_0 == null));
	assume (0 < funcappK#_1410) && ((1000 * funcappK#_1410) < Fractions(1));
	assume true;
	assert { :msg "  794.20: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_102[nw#_1358_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_102,Mask_$_138);
	if ($_$_condition_$26) { goto anon96_Then; } else { goto anon96_Else; }
anon96_Then:
	assume $_$_condition_$26;
	assume $_$_condition_$26 <==> (Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	assume Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]);
	assert { :msg "  794.43: Receiver might be null." } true ==> (!(nw#_1396_$_0 == null));
	assert { :msg "  794.43: Location might not be readable." } true ==> CanRead(Mask_$_138,nw#_1396_$_0,Message.vr3);
	assert { :msg "  794.62: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  794.62: Location might not be readable." } true ==> CanRead(Mask_$_138,mo#131_$_0,Message.vo1);
	assert { :msg "  794.50: Receiver might be null." } true ==> (!(nw#_1358_$_0 == null));
	assume (0 < funcappK#_1418) && ((1000 * funcappK#_1418) < Fractions(1));
	assume true;
	assert { :msg "  794.50: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_102[mo#131_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_102,Mask_$_138);
	assert { :msg "  794.6: Assertion might not hold. The expression at 794.43 might not evaluate to true." } Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[mo#131_$_0,Message.vo1]);
	goto $branchMerge_4;
anon96_Else:
	assume !$_$_condition_$26;
	assume $_$_condition_$26 <==> (Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	assume !(Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	goto $branchMerge_4;
anon97_Then:
	assume $_$_condition_$27;
	assume $_$_condition_$27 <==> (Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	assume Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]);
	goto anon68;
anon97_Else:
	assume !$_$_condition_$27;
	assume $_$_condition_$27 <==> (Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	assume !(Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	goto anon68;
anon68:
	assume wf(Heap_$_102,Mask_$_138);
	assume Mask_$_221 == Mask_$_138;
	assume Credits_$_7 == Credits_$_6;
	assume Heap_$_134 == Heap_$_102;
	goto anon70;
$branchMerge_0:
	if ($_$_condition_$3) { goto anon77_Then; } else { goto anon77_Else; }
$branchMerge_1:
	if ($_$_condition_$13) { goto anon85_Then; } else { goto anon85_Else; }
$branchMerge_2:
	if ($_$_condition_$20) { goto anon92_Then; } else { goto anon92_Else; }
$branchMerge_3:
	if ($_$_condition_$23) { goto anon94_Then; } else { goto anon94_Else; }
$branchMerge_4:
	if ($_$_condition_$27) { goto anon97_Then; } else { goto anon97_Else; }
}
