
// Copyright (c) 2008, Microsoft

type Field a;
type HeapType = <a>[ref,Field a]a;
type MaskType = <a>[ref,Field a][PermissionComponent]int;
type CreditsType = [ref]int;
type ref;
const null: ref;

var Heap: HeapType;

type PermissionComponent;
const unique perm$R: PermissionComponent;
const unique perm$N: PermissionComponent;
var Mask: MaskType where IsGoodMask(Mask);
const Permission$denominator: int;
axiom Permission$denominator > 0;
const Permission$FullFraction: int;
const Permission$Zero: [PermissionComponent]int;
axiom Permission$Zero[perm$R] == 0 && Permission$Zero[perm$N] == 0;
const Permission$Full: [PermissionComponent]int;
axiom Permission$Full[perm$R] == Permission$FullFraction && Permission$Full[perm$N] == 0;
const ZeroMask: MaskType;
axiom (forall<T> o: ref, f: Field T, pc: PermissionComponent :: ZeroMask[o,f][pc] == 0);
axiom IsGoodMask(ZeroMask);
const unique joinable: Field int;
axiom NonPredicateField(joinable);
const unique token#t: TypeName;
const unique forkK: Field int;
axiom NonPredicateField(forkK);
const channelK: int;
const monitorK: int;
const predicateK: int;

function Fractions(n: int) returns (int)
{
  n * Permission$denominator
}
axiom (forall x,y: int :: 0 <= x && x <= y ==> Fractions(x) <= Fractions(y));

axiom Permission$FullFraction  == Fractions(100);
axiom 0 < channelK && 1000*channelK < Fractions(1);
axiom 0 < monitorK && 1000*monitorK < Fractions(1);
axiom 0 < predicateK && 1000*predicateK < Fractions(1);
axiom predicateK == channelK && channelK == monitorK;

var Credits: CreditsType;

function IsGoodState<T>(T) returns (bool);
function combine<T,U>(T, U) returns (T);
const nostate: HeapType;

axiom (forall<T,U> a: T, b: U :: {IsGoodState(combine(a, b))} IsGoodState(combine(a, b)) <==> IsGoodState(a) && IsGoodState(b));
axiom IsGoodState(nostate);

type ModuleName;
const CurrentModule: ModuleName;
type TypeName;
function dtype(ref) returns (TypeName);
const CanAssumeFunctionDefs: bool;

type Mu;
const unique mu: Field Mu;
axiom NonPredicateField(mu);
function MuBelow(Mu, Mu) returns (bool);  // strict partial order
axiom (forall m: Mu, n: Mu ::
  { MuBelow(m,n), MuBelow(n,m) }
  !(MuBelow(m,n) && MuBelow(n,m)));
axiom (forall m: Mu, n: Mu, o: Mu ::
  { MuBelow(m,n), MuBelow(n,o) }
  MuBelow(m,n) && MuBelow(n,o) ==> MuBelow(m,o));
const $LockBottom: Mu;
axiom (forall m, n: Mu :: MuBelow(m, n) ==> n != $LockBottom);

const unique held: Field int;
function Acquire$Heap(int) returns (HeapType);
function Acquire$Mask(int) returns (MaskType);
function Acquire$Credits(int) returns (CreditsType);
axiom NonPredicateField(held);

function LastSeen$Heap(Mu, int) returns (HeapType);
function LastSeen$Mask(Mu, int) returns (MaskType);
function LastSeen$Credits(Mu, int) returns (CreditsType);

const unique rdheld: Field bool;
axiom NonPredicateField(rdheld);
function wf(h: HeapType, m: MaskType) returns (bool);

function IsGoodInhaleState(ih: HeapType, h: HeapType,
                           m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T :: { ih[o, f] }  CanRead(m, o, f) ==> ih[o, f] == h[o, f]) &&
  (forall o: ref :: { ih[o, held] }  (0<ih[o, held]) == (0<h[o, held])) &&
  (forall o: ref :: { ih[o, rdheld] }  ih[o, rdheld] == h[o, rdheld]) &&
  (forall o: ref :: { h[o, held] }  (0<h[o, held]) ==> ih[o, mu] == h[o, mu]) &&
  (forall o: ref :: { h[o, rdheld] }  h[o, rdheld] ==> ih[o, mu] == h[o, mu])
}

// ---------------------------------------------------------------
// -- Permissions ------------------------------------------------
// ---------------------------------------------------------------

function {:expand false} CanRead<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  0 < m[obj,f][perm$R] || 0 < m[obj,f][perm$N]
}
function {:expand false} CanWrite<T>(m: MaskType, obj: ref, f: Field T) returns (bool)
{
  m[obj,f][perm$R] == Permission$FullFraction && m[obj,f][perm$N] == 0
}
function {:expand true} IsGoodMask(m: MaskType) returns (bool)
{
  (forall<T> o: ref, f: Field T ::
      0 <= m[o,f][perm$R] && 
      (NonPredicateField(f) ==> 
        (m[o,f][perm$R]<=Permission$FullFraction &&
        (0 < m[o,f][perm$N] ==> m[o,f][perm$R] < Permission$FullFraction))) &&
      (m[o,f][perm$N] < 0 ==> 0 < m[o,f][perm$R]))
}

axiom (forall h: HeapType, m: MaskType, o: ref, q: ref :: {wf(h, m), h[o, mu], h[q, mu]} wf(h, m) && o!=q && (0 < h[o, held] || h[o, rdheld]) && (0 < h[q, held] || h[q, rdheld]) ==> h[o, mu] != h[q, mu]);

function DecPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$R]}
      DecPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] - howMuch, m[q, g][perm$R])
);

function DecEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {DecPerm(m, o, f, howMuch)[q, g][perm$N]}
         DecEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] - howMuch, m[q, g][perm$N])
);

function IncPerm<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$R]}
         IncPerm(m, o, f, howMuch)[q, g][perm$R] == ite(o==q && f ==g, m[q, g][perm$R] + howMuch, m[q, g][perm$R])
);

function IncEpsilons<T>(m: MaskType, o: ref, f: Field T, howMuch: int) returns (MaskType);

axiom (forall<T,U> m: MaskType, o: ref, f: Field T, howMuch: int, q: ref, g: Field U :: {IncPerm(m, o, f, howMuch)[q, g][perm$N]}
         IncEpsilons(m, o, f, howMuch)[q, g][perm$N] == ite(o==q && f ==g, m[q, g][perm$N] + howMuch, m[q, g][perm$N])
);

function Havocing<T,U>(h: HeapType, o: ref, f: Field T, newValue: U) returns (HeapType);

axiom (forall<T,U> h: HeapType, o: ref, f: Field T, newValue: U, q: ref, g: Field U :: {Havocing(h, o, f, newValue)[q, g]}
         Havocing(h, o, f, newValue)[q, g] == ite(o==q && f ==g, newValue, h[q, g])
);

function Call$Heap(int) returns (HeapType);
function Call$Mask(int) returns (MaskType);
function Call$Credits(int) returns (CreditsType);
function Call$Args(int) returns (ArgSeq);
type ArgSeq = <T>[int]T;

function EmptyMask(m: MaskType) returns (bool);
axiom (forall m: MaskType :: {EmptyMask(m)} EmptyMask(m) <==> (forall<T> o: ref, f: Field T :: NonPredicateField(f) ==> m[o, f][perm$R]<=0 && m[o, f][perm$N]<=0));

const ZeroCredits: CreditsType;
axiom (forall o: ref :: ZeroCredits[o] == 0);
function EmptyCredits(c: CreditsType) returns (bool);
axiom (forall c: CreditsType :: {EmptyCredits(c)} EmptyCredits(c) <==> (forall o: ref :: o != null ==> c[o] == 0));

function NonPredicateField<T>(f: Field T) returns (bool);
function PredicateField<T>(f: Field T) returns (bool);
axiom (forall<T> f: Field T :: NonPredicateField(f) ==> ! PredicateField(f));
axiom (forall<T> f: Field T :: PredicateField(f) ==> ! NonPredicateField(f));

function submask(m1: MaskType, m2: MaskType) returns (bool);

axiom (forall m1: MaskType, m2: MaskType :: {submask(m1, m2)}
  submask(m1, m2) <==> (forall<T> o: ref, f: Field T :: (m1[o, f][perm$R] < m2[o, f][perm$R]) || (m1[o, f][perm$R] == m2[o, f][perm$R] && m1[o, f][perm$N] <= m2[o, f][perm$N]))
);

// ---------------------------------------------------------------
// -- If then else -----------------------------------------------
// ---------------------------------------------------------------

function ite<T>(bool, T, T) returns (T);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} con ==> ite(con, a, b) == a);
axiom (forall<T> con: bool, a: T, b: T :: {ite(con, a, b)} ! con ==> ite(con, a, b) == b);

// ---------------------------------------------------------------
// -- Arithmetic -------------------------------------------------
// ---------------------------------------------------------------

// the connection between % and /
//axiom (forall x:int, y:int :: {x % y} {x / y}  x % y == x - x / y * y);

// sign of denominator determines sign of remainder
//axiom (forall x:int, y:int :: {x % y}  0 < y  ==>  0 <= x % y  &&  x % y < y);
//axiom (forall x:int, y:int :: {x % y}  y < 0  ==>  y < x % y  &&  x % y <= 0);

// the following axiom has some unfortunate matching, but it does state a property about % that
// is sometime useful
//axiom (forall a: int, b: int, d: int :: { a % d, b % d } 2 <= d && a % d == b % d && a < b  ==>  a + d <= b);

// ---------------------------------------------------------------
// -- Strings ----------------------------------------------------
// ---------------------------------------------------------------

type string = int;

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

const unique Channel#t: TypeName;
const unique module#default: ModuleName;
procedure Channel$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == Channel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_7: int;
  var h0#_0: HeapType;
  var m0#_1: MaskType;
  var c0#_2: CreditsType;
  var h1#_3: HeapType;
  var m1#_4: MaskType;
  var c1#_5: CreditsType;
  var lk#_6: ref;
  assume (0 < methodK#_7) && ((1000 * methodK#_7) < Fractions(1));
  assume wf(h0#_0, m0#_1);
  assume wf(h1#_3, m1#_4);
  m1#_4 := ZeroMask;
  c1#_5 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  <undefined position>: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure Channel$whereClause$checkDefinedness(this: ref where (this == null) || (dtype(this) == Channel#t), msg#0: ref where (msg#0 == null) || (dtype(msg#0) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var whereK#_8: int;
  var inhaleHeap#_9: HeapType;
  assume (0 < whereK#_8) && ((1000 * whereK#_8) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (channel where clause)
  havoc inhaleHeap#_9;
  assume IsGoodInhaleState(inhaleHeap#_9, Heap, Mask);
  assume !(msg#0 == null);
  assume msg#0 != null;
  Heap[msg#0, Message.type] := inhaleHeap#_9[msg#0, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume channelK > 0;
  Mask[msg#0, Message.type] := Mask[msg#0, Message.type][perm$R := Mask[msg#0, Message.type][perm$R] + channelK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_9[msg#0, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_9, Mask);
  assert {:msg "  6.66: Receiver might be null."} msg#0 != null;
  assume msg#0 != null;
  Heap[msg#0, Message.inv] := inhaleHeap#_9[msg#0, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_9[msg#0, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[msg#0, Message.inv] := Mask[msg#0, Message.inv][perm$R := Mask[msg#0, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_9[msg#0, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_9, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique Queue#t: TypeName;
procedure Queue$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == Queue#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_17: int;
  var h0#_10: HeapType;
  var m0#_11: MaskType;
  var c0#_12: CreditsType;
  var h1#_13: HeapType;
  var m1#_14: MaskType;
  var c1#_15: CreditsType;
  var lk#_16: ref;
  assume (0 < methodK#_17) && ((1000 * methodK#_17) < Fractions(1));
  assume wf(h0#_10, m0#_11);
  assume wf(h1#_13, m1#_14);
  m1#_14 := ZeroMask;
  c1#_15 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  <undefined position>: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure Queue$whereClause$checkDefinedness(this: ref where (this == null) || (dtype(this) == Queue#t), msg#1: ref where (msg#1 == null) || (dtype(msg#1) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var whereK#_18: int;
  var inhaleHeap#_19: HeapType;
  assume (0 < whereK#_18) && ((1000 * whereK#_18) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (channel where clause)
  havoc inhaleHeap#_19;
  assume IsGoodInhaleState(inhaleHeap#_19, Heap, Mask);
  assume !(msg#1 == null);
  assume msg#1 != null;
  Heap[msg#1, Message.type] := inhaleHeap#_19[msg#1, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume channelK > 0;
  Mask[msg#1, Message.type] := Mask[msg#1, Message.type][perm$R := Mask[msg#1, Message.type][perm$R] + channelK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_19[msg#1, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_19, Mask);
  assert {:msg "  10.3: Receiver might be null."} true ==> (msg#1 != null);
  assert {:msg "  10.3: Location might not be readable."} true ==> CanRead(Mask, msg#1, Message.type);
  if (Heap[msg#1, Message.type] == 1) {
    assert {:msg "  10.19: Receiver might be null."} msg#1 != null;
    assume msg#1 != null;
    Heap[msg#1, Message.invValue] := inhaleHeap#_19[msg#1, Message.invValue];
    assume wf(Heap, Mask);
    assume inhaleHeap#_19[msg#1, Message.invValue] == Heap;
    assume Fractions(100) > 0;
    Mask[msg#1, Message.invValue] := Mask[msg#1, Message.invValue][perm$R := Mask[msg#1, Message.invValue][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_19[msg#1, Message.invValue]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_19, Mask);
  } else {
  }
  assert {:msg "  11.3: Receiver might be null."} true ==> (msg#1 != null);
  assert {:msg "  11.3: Location might not be readable."} true ==> CanRead(Mask, msg#1, Message.type);
  if (Heap[msg#1, Message.type] == 2) {
    assert {:msg "  11.19: Receiver might be null."} msg#1 != null;
    assume msg#1 != null;
    Heap[msg#1, Message.invResult1] := inhaleHeap#_19[msg#1, Message.invResult1];
    assume wf(Heap, Mask);
    assume inhaleHeap#_19[msg#1, Message.invResult1] == Heap;
    assume Fractions(100) > 0;
    Mask[msg#1, Message.invResult1] := Mask[msg#1, Message.invResult1][perm$R := Mask[msg#1, Message.invResult1][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_19[msg#1, Message.invResult1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_19, Mask);
  } else {
  }
  assert {:msg "  12.3: Receiver might be null."} true ==> (msg#1 != null);
  assert {:msg "  12.3: Location might not be readable."} true ==> CanRead(Mask, msg#1, Message.type);
  if (Heap[msg#1, Message.type] == 3) {
    assert {:msg "  12.19: Receiver might be null."} msg#1 != null;
    assume msg#1 != null;
    Heap[msg#1, Message.invResult2] := inhaleHeap#_19[msg#1, Message.invResult2];
    assume wf(Heap, Mask);
    assume inhaleHeap#_19[msg#1, Message.invResult2] == Heap;
    assume Fractions(100) > 0;
    Mask[msg#1, Message.invResult2] := Mask[msg#1, Message.invResult2][perm$R := Mask[msg#1, Message.invResult2][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_19[msg#1, Message.invResult2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_19, Mask);
  } else {
  }
  assert {:msg "  13.3: Receiver might be null."} true ==> (msg#1 != null);
  assert {:msg "  13.3: Location might not be readable."} true ==> CanRead(Mask, msg#1, Message.type);
  if (Heap[msg#1, Message.type] == 4) {
    assert {:msg "  13.19: Receiver might be null."} msg#1 != null;
    assume msg#1 != null;
    Heap[msg#1, Message.invFinalResult] := inhaleHeap#_19[msg#1, Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_19[msg#1, Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[msg#1, Message.invFinalResult] := Mask[msg#1, Message.invFinalResult][perm$R := Mask[msg#1, Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_19[msg#1, Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_19, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FactorialActorChannelExpEP#t: TypeName;
procedure FactorialActorChannelExpEP$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_27: int;
  var h0#_20: HeapType;
  var m0#_21: MaskType;
  var c0#_22: CreditsType;
  var h1#_23: HeapType;
  var m1#_24: MaskType;
  var c1#_25: CreditsType;
  var lk#_26: ref;
  assume (0 < methodK#_27) && ((1000 * methodK#_27) < Fractions(1));
  assume wf(h0#_20, m0#_21);
  assume wf(h1#_23, m1#_24);
  m1#_24 := ZeroMask;
  c1#_25 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  21.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActorChannelExpEP.state: Field (int);
axiom NonPredicateField(FactorialActorChannelExpEP.state);
const unique FactorialActorChannelExpEP.ch: Field (ref);
axiom NonPredicateField(FactorialActorChannelExpEP.ch);
const unique FactorialActorChannelExpEP.expch: Field (ref);
axiom NonPredicateField(FactorialActorChannelExpEP.expch);
const unique FactorialActorChannelExpEP.valid: Field (HeapType);
axiom PredicateField(FactorialActorChannelExpEP.valid);
procedure FactorialActorChannelExpEP.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_28: int;
  var inhaleHeap#_29: HeapType;
  assume (0 < predicateK#_28) && ((1000 * predicateK#_28) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_29;
  assume IsGoodInhaleState(inhaleHeap#_29, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.expch] := inhaleHeap#_29[this, FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[this, FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannelExpEP.expch] := Mask[this, FactorialActorChannelExpEP.expch][perm$R := Mask[this, FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[this, FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.ch] := inhaleHeap#_29[this, FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[this, FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannelExpEP.ch] := Mask[this, FactorialActorChannelExpEP.ch][perm$R := Mask[this, FactorialActorChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[this, FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assert {:msg "  27.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  27.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assume !(Heap[this, FactorialActorChannelExpEP.ch] == null);
  assert {:msg "  28.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  28.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assume Heap[this, FactorialActorChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := inhaleHeap#_29[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assert {:msg "  28.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  28.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  28.24: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  28.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp);
  assume !(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null);
  assert {:msg "  28.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  28.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assume Heap[this, FactorialActorChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := inhaleHeap#_29[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assert {:msg "  28.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  28.59: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  28.59: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  28.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp);
  assume !(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null);
  assert {:msg "  29.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  29.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  29.8: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp);
  assume Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_29[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assert {:msg "  29.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  29.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  29.30: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  29.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp);
  assert {:msg "  29.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] != null);
  assert {:msg "  29.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  30.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  30.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  30.8: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp);
  assume Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_29[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assert {:msg "  30.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  30.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  30.30: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  30.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp);
  assert {:msg "  30.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] != null);
  assert {:msg "  30.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  31.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  31.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  31.8: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_29[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assert {:msg "  31.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  31.36: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
  assert {:msg "  31.36: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  assume Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := inhaleHeap#_29[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_29[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_29, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelExpEP.sendValue$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t), m#2: ref where (m#2 == null) || (dtype(m#2) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_30: int;
  var inhaleHeap#_31: HeapType;
  var inhaleHeap#_32: HeapType;
  assume (0 < methodK#_30) && ((1000 * methodK#_30) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_31;
  assume IsGoodInhaleState(inhaleHeap#_31, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.state] := inhaleHeap#_31[this, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.state] := Mask[this, FactorialActorChannelExpEP.state][perm$R := Mask[this, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_31[this, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_31, Mask);
  assume m#2 != null;
  Heap[m#2, Message.type] := inhaleHeap#_31[m#2, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#2, Message.type] := Mask[m#2, Message.type][perm$R := Mask[m#2, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_31[m#2, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_31, Mask);
  assume m#2 != null;
  Heap[m#2, Message.type] := inhaleHeap#_31[m#2, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#2, Message.type] := Mask[m#2, Message.type][perm$R := Mask[m#2, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_31[m#2, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_31, Mask);
  assert {:msg "  34.63: Receiver might be null."} true ==> (m#2 != null);
  assert {:msg "  34.63: Location might not be readable."} true ==> CanRead(Mask, m#2, Message.type);
  assume Heap[m#2, Message.type] == 1;
  assert {:msg "  34.76: Receiver might be null."} m#2 != null;
  assume m#2 != null;
  Heap[m#2, Message.invValue] := inhaleHeap#_31[m#2, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_31[m#2, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[m#2, Message.invValue] := Mask[m#2, Message.invValue][perm$R := Mask[m#2, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_31[m#2, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_31, Mask);
  assert {:msg "  35.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_31[this, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_31[this, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_31[this, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_31, Mask);
  assert {:msg "  36.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  36.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.state);
  assume Heap[this, FactorialActorChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_32;
  assume IsGoodInhaleState(inhaleHeap#_32, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.state] := inhaleHeap#_32[this, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.state] := Mask[this, FactorialActorChannelExpEP.state][perm$R := Mask[this, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_32[this, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_32, Mask);
  assert {:msg "  37.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_32[this, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_32[this, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_32[this, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_32, Mask);
  assert {:msg "  37.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  37.38: Location might not be readable."} true ==> CanRead(old(Mask), this, FactorialActorChannelExpEP.state);
  if (old(Heap)[this, FactorialActorChannelExpEP.state] == 0) {
    assert {:msg "  37.52: Receiver might be null."} true ==> (this != null);
    assert {:msg "  37.52: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.state);
    assume Heap[this, FactorialActorChannelExpEP.state] == 0;
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelExpEP.sendValue(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t), m#2: ref where (m#2 == null) || (dtype(m#2) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_30: int;
  var inhaleHeap#_33: HeapType;
  var unfoldK#_34: int;
  var exhaleMask#_35: MaskType;
  var inhaleHeap#_37: HeapType;
  var foldK#_38: int;
  var exhaleMask#_39: MaskType;
  var inhaleHeap#_45: HeapType;
  var c#4: ref where (c#4 == null) || (dtype(c#4) == Channel#t);
  var foldK#_46: int;
  var exhaleMask#_47: MaskType;
  var inhaleHeap#_56: HeapType;
  var this#108: ref where (this#108 == null) || (dtype(this#108) == Channel#t);
  var msg#109: ref where (msg#109 == null) || (dtype(msg#109) == Message#t);
  var exhaleMask#_57: MaskType;
  var Heap#_63: HeapType;
  var Mask#_64: MaskType;
  var Credits#_65: CreditsType;
  var exhaleMask#_66: MaskType;
  var exhaleMask#_67: MaskType;
  assume (0 < methodK#_30) && ((1000 * methodK#_30) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_33;
  assume IsGoodInhaleState(inhaleHeap#_33, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.state] := inhaleHeap#_33[this, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.state] := Mask[this, FactorialActorChannelExpEP.state][perm$R := Mask[this, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_33[this, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_33, Mask);
  assume m#2 != null;
  Heap[m#2, Message.type] := inhaleHeap#_33[m#2, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#2, Message.type] := Mask[m#2, Message.type][perm$R := Mask[m#2, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_33[m#2, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_33, Mask);
  assume m#2 != null;
  Heap[m#2, Message.type] := inhaleHeap#_33[m#2, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#2, Message.type] := Mask[m#2, Message.type][perm$R := Mask[m#2, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_33[m#2, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_33, Mask);
  assume Heap[m#2, Message.type] == 1;
  assume m#2 != null;
  Heap[m#2, Message.invValue] := inhaleHeap#_33[m#2, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_33[m#2, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[m#2, Message.invValue] := Mask[m#2, Message.invValue][perm$R := Mask[m#2, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_33[m#2, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_33, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_33[this, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_33[this, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_33[this, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_33, Mask);
  assume Heap[this, FactorialActorChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_34) && (unfoldK#_34 < Fractions(1)) && ((1000 * unfoldK#_34) < methodK#_30);
  assert {:msg "  39.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_35 := Mask;
  assert {:msg "  39.3: unfold might fail because the predicate FactorialActorChannelExpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  39.3: unfold might fail because the predicate FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_35[this, FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_35[this, FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_35[this, FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_35[this, FactorialActorChannelExpEP.valid] := exhaleMask#_35[this, FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_35[this, FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_35);
  Mask := exhaleMask#_35;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_37 := Heap[this, FactorialActorChannelExpEP.valid];
  assume IsGoodInhaleState(inhaleHeap#_37, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.expch] := inhaleHeap#_37[this, FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[this, FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannelExpEP.expch] := Mask[this, FactorialActorChannelExpEP.expch][perm$R := Mask[this, FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[this, FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.ch] := inhaleHeap#_37[this, FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[this, FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannelExpEP.ch] := Mask[this, FactorialActorChannelExpEP.ch][perm$R := Mask[this, FactorialActorChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[this, FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume !(Heap[this, FactorialActorChannelExpEP.ch] == null);
  assume Heap[this, FactorialActorChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := inhaleHeap#_37[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume !(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null);
  assume Heap[this, FactorialActorChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := inhaleHeap#_37[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume !(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null);
  assume Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_37[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume !(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assume Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_37[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume !(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assume Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_37[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := inhaleHeap#_37[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_37[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_37, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  40.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  40.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.state);
  if (Heap[this, FactorialActorChannelExpEP.state] == 0) {
    // fold
    assume (0 < foldK#_38) && ((1000 * foldK#_38) < Fractions(1)) && ((1000 * foldK#_38) < methodK#_30);
    assert {:msg "  41.4: The target of the fold statement might be null."} m#2 != null;
    // begin exhale (fold)
    exhaleMask#_39 := Mask;
    if (Heap[m#2, Message.type] == 1) {
    } else {
    }
    if (Heap[m#2, Message.type] == 2) {
    } else {
    }
    if (Heap[m#2, Message.type] == 3) {
    } else {
    }
    if (Heap[m#2, Message.type] == 4) {
    } else {
    }
    assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. The permission at 649.3 might not be positive."} predicateK > 0;
    assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 649.3 for Message.type."} (predicateK <= exhaleMask#_39[m#2, Message.type][perm$R]) && ((predicateK == exhaleMask#_39[m#2, Message.type][perm$R]) ==> (0 <= exhaleMask#_39[m#2, Message.type][perm$N]));
    exhaleMask#_39[m#2, Message.type] := exhaleMask#_39[m#2, Message.type][perm$R := exhaleMask#_39[m#2, Message.type][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_39);
    if (Heap[m#2, Message.type] == 1) {
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. The permission at 650.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 650.16 for Message.invValue."} (Fractions(100) <= exhaleMask#_39[m#2, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_39[m#2, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_39[m#2, Message.invValue][perm$N]));
      exhaleMask#_39[m#2, Message.invValue] := exhaleMask#_39[m#2, Message.invValue][perm$R := exhaleMask#_39[m#2, Message.invValue][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_39);
    } else {
    }
    if (Heap[m#2, Message.type] == 2) {
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. The permission at 651.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 651.16 for Message.invResult1."} (Fractions(100) <= exhaleMask#_39[m#2, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_39[m#2, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_39[m#2, Message.invResult1][perm$N]));
      exhaleMask#_39[m#2, Message.invResult1] := exhaleMask#_39[m#2, Message.invResult1][perm$R := exhaleMask#_39[m#2, Message.invResult1][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_39);
    } else {
    }
    if (Heap[m#2, Message.type] == 3) {
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. The permission at 652.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 652.16 for Message.invResult2."} (Fractions(100) <= exhaleMask#_39[m#2, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_39[m#2, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_39[m#2, Message.invResult2][perm$N]));
      exhaleMask#_39[m#2, Message.invResult2] := exhaleMask#_39[m#2, Message.invResult2][perm$R := exhaleMask#_39[m#2, Message.invResult2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_39);
    } else {
    }
    if (Heap[m#2, Message.type] == 4) {
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. The permission at 653.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  41.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 653.16 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_39[m#2, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_39[m#2, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_39[m#2, Message.invFinalResult][perm$N]));
      exhaleMask#_39[m#2, Message.invFinalResult] := exhaleMask#_39[m#2, Message.invFinalResult][perm$R := exhaleMask#_39[m#2, Message.invFinalResult][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_39);
    } else {
    }
    Mask := exhaleMask#_39;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_45;
    assume IsGoodInhaleState(inhaleHeap#_45, Heap, Mask);
    assume m#2 != null;
    Heap[m#2, Message.inv] := inhaleHeap#_45[m#2, Message.inv];
    assume wf(Heap, Mask);
    assume inhaleHeap#_45[m#2, Message.inv] == Heap;
    assume Fractions(100) > 0;
    Mask[m#2, Message.inv] := Mask[m#2, Message.inv][perm$R := Mask[m#2, Message.inv][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_45[m#2, Message.inv]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_45, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[m#2, Message.inv] := Heap;
    assume wf(Heap, Mask);
    // update field state
    assert {:msg "  42.4: Location might not be writable"} CanWrite(Mask, this, FactorialActorChannelExpEP.state);
    Heap[this, FactorialActorChannelExpEP.state] := 0;
    assume wf(Heap, Mask);
    // local var c
    // assigment to c
    assert {:msg "  43.19: Receiver might be null."} true ==> (this != null);
    assert {:msg "  43.19: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.ch);
    assert {:msg "  43.19: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelExpEP.ch] != null);
    assert {:msg "  43.19: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp);
    assert {:msg "  43.19: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] != null);
    assert {:msg "  43.19: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
    c#4 := Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
    // fold
    assume (0 < foldK#_46) && ((1000 * foldK#_46) < Fractions(1)) && ((1000 * foldK#_46) < methodK#_30);
    assert {:msg "  44.4: The target of the fold statement might be null."} this != null;
    // begin exhale (fold)
    exhaleMask#_47 := Mask;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 27.38 might not evaluate to true."} !(Heap[this, FactorialActorChannelExpEP.ch] == null);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 28.24 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 28.59 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 29.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 30.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 27.5 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 27.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_47[this, FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_47[this, FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_47[this, FactorialActorChannelExpEP.expch][perm$N]));
    exhaleMask#_47[this, FactorialActorChannelExpEP.expch] := exhaleMask#_47[this, FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_47[this, FactorialActorChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 27.23 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 27.23 for FactorialActorChannelExpEP.ch."} (monitorK <= exhaleMask#_47[this, FactorialActorChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_47[this, FactorialActorChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_47[this, FactorialActorChannelExpEP.ch][perm$N]));
    exhaleMask#_47[this, FactorialActorChannelExpEP.ch] := exhaleMask#_47[this, FactorialActorChannelExpEP.ch][perm$R := exhaleMask#_47[this, FactorialActorChannelExpEP.ch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 28.5 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 28.5 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$N]));
    exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R := exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 28.40 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 28.40 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$N]));
    exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R := exhaleMask#_47[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 29.5 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 29.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
    exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 30.5 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 30.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
    exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_47[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 31.5 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 31.5 for mu."} (monitorK <= exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
    exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 31.33 might not be positive."} monitorK > 0;
    assert {:msg "  44.4: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 31.33 for mu."} (monitorK <= exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$N]));
    exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := exhaleMask#_47[Heap[Heap[Heap[this, FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_47);
    Mask := exhaleMask#_47;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_56;
    assume IsGoodInhaleState(inhaleHeap#_56, Heap, Mask);
    assume this != null;
    Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_56[this, FactorialActorChannelExpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_56[this, FactorialActorChannelExpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_56[this, FactorialActorChannelExpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_56, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[this, FactorialActorChannelExpEP.valid] := Heap;
    assume wf(Heap, Mask);
    // send
    assert {:msg "  45.9: The channel might be null."} c#4 != null;
    this#108 := c#4;
    msg#109 := m#2;
    Credits[c#4] := Credits[c#4] + 1;
    // begin exhale (channel where clause)
    exhaleMask#_57 := Mask;
    assert {:msg "  45.4: The where clause at 6.36 might not hold. The expression at 6.36 might not evaluate to true."} !(msg#109 == null);
    assert {:msg "  45.4: The where clause at 6.36 might not hold. The permission at 6.50 might not be positive."} channelK > 0;
    assert {:msg "  45.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.50 for Message.type."} (channelK <= exhaleMask#_57[msg#109, Message.type][perm$R]) && ((channelK == exhaleMask#_57[msg#109, Message.type][perm$R]) ==> (0 <= exhaleMask#_57[msg#109, Message.type][perm$N]));
    exhaleMask#_57[msg#109, Message.type] := exhaleMask#_57[msg#109, Message.type][perm$R := exhaleMask#_57[msg#109, Message.type][perm$R] - channelK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_57);
    assert {:msg "  45.4: The where clause at 6.36 might not hold. The permission at 6.66 might not be positive."} Fractions(100) > 0;
    assert {:msg "  45.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.66 for Message.inv."} (Fractions(100) <= exhaleMask#_57[msg#109, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_57[msg#109, Message.inv][perm$R]) ==> (0 <= exhaleMask#_57[msg#109, Message.inv][perm$N]));
    exhaleMask#_57[msg#109, Message.inv] := exhaleMask#_57[msg#109, Message.inv][perm$R := exhaleMask#_57[msg#109, Message.inv][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_57);
    Mask := exhaleMask#_57;
    assume wf(Heap, Mask);
    // end exhale
  } else {
    // assert
    Heap#_63 := Heap;
    Mask#_64 := Mask;
    Credits#_65 := Credits;
    // begin exhale (assert)
    exhaleMask#_66 := Mask#_64;
    assert {:msg "  48.4: Assertion might not hold. The expression at 48.11 might not evaluate to true."} false;
    Mask#_64 := exhaleMask#_66;
    assume wf(Heap#_63, Mask#_64);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_67 := Mask;
  if (old(Heap)[this, FactorialActorChannelExpEP.state] == 0) {
    assert {:msg "  33.2: The postcondition at 37.10 might not hold. The expression at 37.52 might not evaluate to true."} Heap[this, FactorialActorChannelExpEP.state] == 0;
  } else {
  }
  assert {:msg "  33.2: The postcondition at 37.10 might not hold. The permission at 37.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  33.2: The postcondition at 37.10 might not hold. Insufficient fraction at 37.10 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_67[this, FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_67[this, FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_67[this, FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_67[this, FactorialActorChannelExpEP.state] := exhaleMask#_67[this, FactorialActorChannelExpEP.state][perm$R := exhaleMask#_67[this, FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_67);
  assert {:msg "  33.2: The postcondition at 37.10 might not hold. The permission at 37.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  33.2: The postcondition at 37.10 might not hold. Insufficient fraction at 37.24 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_67[this, FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_67[this, FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_67[this, FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_67[this, FactorialActorChannelExpEP.valid] := exhaleMask#_67[this, FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_67[this, FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_67);
  if (old(Heap)[this, FactorialActorChannelExpEP.state] == 0) {
  } else {
  }
  Mask := exhaleMask#_67;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  33.2: Method might lock/unlock more than allowed."} (forall lk#_70: ref :: {Heap[lk#_70, held]} {Heap[lk#_70, rdheld]} (((0 < Heap[lk#_70, held]) == (0 < old(Heap)[lk#_70, held])) && (Heap[lk#_70, rdheld] == old(Heap)[lk#_70, rdheld])) || false);
  assert {:msg "  33.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialActorChannelExpEP.receiveValue$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t)) returns (m#5: ref where (m#5 == null) || (dtype(m#5) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_71: int;
  var inhaleHeap#_72: HeapType;
  assume (0 < methodK#_71) && ((1000 * methodK#_71) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_72;
  assume IsGoodInhaleState(inhaleHeap#_72, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FactorialActorChannelExpEP.receiveValue(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t)) returns (m#5: ref where (m#5 == null) || (dtype(m#5) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_71: int;
  var inhaleHeap#_73: HeapType;
  var Heap#_77: HeapType;
  var Mask#_78: MaskType;
  var Credits#_79: CreditsType;
  var exhaleMask#_80: MaskType;
  assume (0 < methodK#_71) && ((1000 * methodK#_71) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_73;
  assume IsGoodInhaleState(inhaleHeap#_73, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_77 := Heap;
  Mask#_78 := Mask;
  Credits#_79 := Credits;
  // begin exhale (assert)
  exhaleMask#_80 := Mask#_78;
  assert {:msg "  54.3: Assertion might not hold. The expression at 54.10 might not evaluate to true."} false;
  Mask#_78 := exhaleMask#_80;
  assume wf(Heap#_77, Mask#_78);
  // end exhale
  assert {:msg "  51.2: Method might lock/unlock more than allowed."} (forall lk#_81: ref :: {Heap[lk#_81, held]} {Heap[lk#_81, rdheld]} (((0 < Heap[lk#_81, held]) == (0 < old(Heap)[lk#_81, held])) && (Heap[lk#_81, rdheld] == old(Heap)[lk#_81, rdheld])) || false);
  assert {:msg "  51.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialActorChannelExpEP.fail$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t), m#6: ref where (m#6 == null) || (dtype(m#6) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_82: int;
  var inhaleHeap#_83: HeapType;
  var inhaleHeap#_84: HeapType;
  assume (0 < methodK#_82) && ((1000 * methodK#_82) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_83;
  assume IsGoodInhaleState(inhaleHeap#_83, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.state] := inhaleHeap#_83[this, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.state] := Mask[this, FactorialActorChannelExpEP.state][perm$R := Mask[this, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[this, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assume m#6 != null;
  Heap[m#6, Message.type] := inhaleHeap#_83[m#6, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#6, Message.type] := Mask[m#6, Message.type][perm$R := Mask[m#6, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[m#6, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assert {:msg "  58.45: Receiver might be null."} true ==> (m#6 != null);
  assert {:msg "  58.45: Location might not be readable."} true ==> CanRead(Mask, m#6, Message.type);
  assume Heap[m#6, Message.type] == 1;
  assert {:msg "  58.58: Receiver might be null."} m#6 != null;
  assume m#6 != null;
  Heap[m#6, Message.inv] := inhaleHeap#_83[m#6, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_83[m#6, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[m#6, Message.inv] := Mask[m#6, Message.inv][perm$R := Mask[m#6, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[m#6, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assert {:msg "  59.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_83[this, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_83[this, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_83[this, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_83, Mask);
  assert {:msg "  60.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  60.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.state);
  assume !(Heap[this, FactorialActorChannelExpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_84;
  assume IsGoodInhaleState(inhaleHeap#_84, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.state] := inhaleHeap#_84[this, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.state] := Mask[this, FactorialActorChannelExpEP.state][perm$R := Mask[this, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_84[this, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_84, Mask);
  assert {:msg "  61.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_84[this, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_84[this, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_84[this, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_84, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelExpEP.fail(this: ref where (this == null) || (dtype(this) == FactorialActorChannelExpEP#t), m#6: ref where (m#6 == null) || (dtype(m#6) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_82: int;
  var inhaleHeap#_85: HeapType;
  var Heap#_89: HeapType;
  var Mask#_90: MaskType;
  var Credits#_91: CreditsType;
  var exhaleMask#_92: MaskType;
  var exhaleMask#_93: MaskType;
  assume (0 < methodK#_82) && ((1000 * methodK#_82) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_85;
  assume IsGoodInhaleState(inhaleHeap#_85, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.state] := inhaleHeap#_85[this, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.state] := Mask[this, FactorialActorChannelExpEP.state][perm$R := Mask[this, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[this, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume m#6 != null;
  Heap[m#6, Message.type] := inhaleHeap#_85[m#6, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#6, Message.type] := Mask[m#6, Message.type][perm$R := Mask[m#6, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[m#6, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume Heap[m#6, Message.type] == 1;
  assume m#6 != null;
  Heap[m#6, Message.inv] := inhaleHeap#_85[m#6, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_85[m#6, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[m#6, Message.inv] := Mask[m#6, Message.inv][perm$R := Mask[m#6, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[m#6, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelExpEP.valid] := inhaleHeap#_85[this, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_85[this, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelExpEP.valid] := Mask[this, FactorialActorChannelExpEP.valid][perm$R := Mask[this, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_85[this, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_85, Mask);
  assume !(Heap[this, FactorialActorChannelExpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  63.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  63.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelExpEP.state);
  if (Heap[this, FactorialActorChannelExpEP.state] == 0) {
    // assert
    Heap#_89 := Heap;
    Mask#_90 := Mask;
    Credits#_91 := Credits;
    // begin exhale (assert)
    exhaleMask#_92 := Mask#_90;
    assert {:msg "  64.4: Assertion might not hold. The expression at 64.11 might not evaluate to true."} false;
    Mask#_90 := exhaleMask#_92;
    assume wf(Heap#_89, Mask#_90);
    // end exhale
  } else {
    // assume
    assume false;
  }
  // begin exhale (postcondition)
  exhaleMask#_93 := Mask;
  assert {:msg "  57.2: The postcondition at 61.10 might not hold. The permission at 61.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  57.2: The postcondition at 61.10 might not hold. Insufficient fraction at 61.10 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_93[this, FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_93[this, FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_93[this, FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_93[this, FactorialActorChannelExpEP.state] := exhaleMask#_93[this, FactorialActorChannelExpEP.state][perm$R := exhaleMask#_93[this, FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_93);
  assert {:msg "  57.2: The postcondition at 61.10 might not hold. The permission at 61.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  57.2: The postcondition at 61.10 might not hold. Insufficient fraction at 61.24 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_93[this, FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_93[this, FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_93[this, FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_93[this, FactorialActorChannelExpEP.valid] := exhaleMask#_93[this, FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_93[this, FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_93);
  Mask := exhaleMask#_93;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  57.2: Method might lock/unlock more than allowed."} (forall lk#_96: ref :: {Heap[lk#_96, held]} {Heap[lk#_96, rdheld]} (((0 < Heap[lk#_96, held]) == (0 < old(Heap)[lk#_96, held])) && (Heap[lk#_96, rdheld] == old(Heap)[lk#_96, rdheld])) || false);
  assert {:msg "  57.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActorChannelImpEP#t: TypeName;
procedure FactorialActorChannelImpEP$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_104: int;
  var h0#_97: HeapType;
  var m0#_98: MaskType;
  var c0#_99: CreditsType;
  var h1#_100: HeapType;
  var m1#_101: MaskType;
  var c1#_102: CreditsType;
  var lk#_103: ref;
  assume (0 < methodK#_104) && ((1000 * methodK#_104) < Fractions(1));
  assume wf(h0#_97, m0#_98);
  assume wf(h1#_100, m1#_101);
  m1#_101 := ZeroMask;
  c1#_102 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  72.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActorChannelImpEP.state: Field (int);
axiom NonPredicateField(FactorialActorChannelImpEP.state);
const unique FactorialActorChannelImpEP.ch: Field (ref);
axiom NonPredicateField(FactorialActorChannelImpEP.ch);
const unique FactorialActorChannelImpEP.impch: Field (ref);
axiom NonPredicateField(FactorialActorChannelImpEP.impch);
const unique FactorialActorChannelImpEP.valid: Field (HeapType);
axiom PredicateField(FactorialActorChannelImpEP.valid);
procedure FactorialActorChannelImpEP.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_105: int;
  var inhaleHeap#_106: HeapType;
  assume (0 < predicateK#_105) && ((1000 * predicateK#_105) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_106;
  assume IsGoodInhaleState(inhaleHeap#_106, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.impch] := inhaleHeap#_106[this, FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[this, FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannelImpEP.impch] := Mask[this, FactorialActorChannelImpEP.impch][perm$R := Mask[this, FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[this, FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.ch] := inhaleHeap#_106[this, FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[this, FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannelImpEP.ch] := Mask[this, FactorialActorChannelImpEP.ch][perm$R := Mask[this, FactorialActorChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[this, FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assert {:msg "  78.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  78.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assume !(Heap[this, FactorialActorChannelImpEP.ch] == null);
  assert {:msg "  79.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  79.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assume Heap[this, FactorialActorChannelImpEP.ch] != null;
  Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] := inhaleHeap#_106[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assert {:msg "  79.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  79.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  79.24: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  79.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp);
  assume !(Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] == null);
  assert {:msg "  79.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  79.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assume Heap[this, FactorialActorChannelImpEP.ch] != null;
  Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] := inhaleHeap#_106[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assert {:msg "  79.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  79.59: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  79.59: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  79.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp);
  assume !(Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] == null);
  assert {:msg "  80.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  80.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  80.8: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp);
  assume Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_106[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assert {:msg "  80.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  80.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  80.30: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  80.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp);
  assert {:msg "  80.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] != null);
  assert {:msg "  80.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  81.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  81.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  81.8: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp);
  assume Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_106[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assert {:msg "  81.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  81.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  81.30: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  81.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp);
  assert {:msg "  81.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] != null);
  assert {:msg "  81.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  82.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  82.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  82.8: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_106[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assert {:msg "  82.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  82.36: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.ch);
  assert {:msg "  82.36: Receiver might be null."} true ==> (Heap[this, FactorialActorChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  assume Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := inhaleHeap#_106[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_106[Heap[Heap[Heap[this, FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_106, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelImpEP.sendValue$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t), m#7: ref where (m#7 == null) || (dtype(m#7) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_107: int;
  var inhaleHeap#_108: HeapType;
  var inhaleHeap#_109: HeapType;
  assume (0 < methodK#_107) && ((1000 * methodK#_107) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_108;
  assume IsGoodInhaleState(inhaleHeap#_108, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_108[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_108[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_108, Mask);
  assume m#7 != null;
  Heap[m#7, Message.type] := inhaleHeap#_108[m#7, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#7, Message.type] := Mask[m#7, Message.type][perm$R := Mask[m#7, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_108[m#7, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_108, Mask);
  assert {:msg "  86.45: Receiver might be null."} true ==> (m#7 != null);
  assert {:msg "  86.45: Location might not be readable."} true ==> CanRead(Mask, m#7, Message.type);
  assume Heap[m#7, Message.type] == 1;
  assert {:msg "  86.58: Receiver might be null."} m#7 != null;
  assume m#7 != null;
  Heap[m#7, Message.invValue] := inhaleHeap#_108[m#7, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_108[m#7, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[m#7, Message.invValue] := Mask[m#7, Message.invValue][perm$R := Mask[m#7, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_108[m#7, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_108, Mask);
  assert {:msg "  87.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.valid] := inhaleHeap#_108[this, FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_108[this, FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.valid] := Mask[this, FactorialActorChannelImpEP.valid][perm$R := Mask[this, FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_108[this, FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_108, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_109;
  assume IsGoodInhaleState(inhaleHeap#_109, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_109[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_109[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_109, Mask);
  assert {:msg "  89.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.valid] := inhaleHeap#_109[this, FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_109[this, FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.valid] := Mask[this, FactorialActorChannelImpEP.valid][perm$R := Mask[this, FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_109[this, FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_109, Mask);
  assert {:msg "  89.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  89.38: Location might not be readable."} true ==> CanRead(old(Mask), this, FactorialActorChannelImpEP.state);
  if (old(Heap)[this, FactorialActorChannelImpEP.state] == 0) {
    assert {:msg "  89.52: Receiver might be null."} true ==> (this != null);
    assert {:msg "  89.52: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
    assume Heap[this, FactorialActorChannelImpEP.state] == 0;
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelImpEP.sendValue(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t), m#7: ref where (m#7 == null) || (dtype(m#7) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_107: int;
  var inhaleHeap#_110: HeapType;
  var Heap#_114: HeapType;
  var Mask#_115: MaskType;
  var Credits#_116: CreditsType;
  var exhaleMask#_117: MaskType;
  var exhaleMask#_118: MaskType;
  assume (0 < methodK#_107) && ((1000 * methodK#_107) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_110;
  assume IsGoodInhaleState(inhaleHeap#_110, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_110[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_110[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_110, Mask);
  assume m#7 != null;
  Heap[m#7, Message.type] := inhaleHeap#_110[m#7, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#7, Message.type] := Mask[m#7, Message.type][perm$R := Mask[m#7, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_110[m#7, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_110, Mask);
  assume Heap[m#7, Message.type] == 1;
  assume m#7 != null;
  Heap[m#7, Message.invValue] := inhaleHeap#_110[m#7, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_110[m#7, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[m#7, Message.invValue] := Mask[m#7, Message.invValue][perm$R := Mask[m#7, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_110[m#7, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_110, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.valid] := inhaleHeap#_110[this, FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_110[this, FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.valid] := Mask[this, FactorialActorChannelImpEP.valid][perm$R := Mask[this, FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_110[this, FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_110, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_114 := Heap;
  Mask#_115 := Mask;
  Credits#_116 := Credits;
  // begin exhale (assert)
  exhaleMask#_117 := Mask#_115;
  assert {:msg "  91.3: Assertion might not hold. The expression at 91.10 might not evaluate to true."} false;
  Mask#_115 := exhaleMask#_117;
  assume wf(Heap#_114, Mask#_115);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_118 := Mask;
  if (old(Heap)[this, FactorialActorChannelImpEP.state] == 0) {
    assert {:msg "  85.2: The postcondition at 89.10 might not hold. The expression at 89.52 might not evaluate to true."} Heap[this, FactorialActorChannelImpEP.state] == 0;
  } else {
  }
  assert {:msg "  85.2: The postcondition at 89.10 might not hold. The permission at 89.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  85.2: The postcondition at 89.10 might not hold. Insufficient fraction at 89.10 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_118[this, FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_118[this, FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_118[this, FactorialActorChannelImpEP.state][perm$N]));
  exhaleMask#_118[this, FactorialActorChannelImpEP.state] := exhaleMask#_118[this, FactorialActorChannelImpEP.state][perm$R := exhaleMask#_118[this, FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_118);
  assert {:msg "  85.2: The postcondition at 89.10 might not hold. The permission at 89.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  85.2: The postcondition at 89.10 might not hold. Insufficient fraction at 89.24 for FactorialActorChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_118[this, FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_118[this, FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_118[this, FactorialActorChannelImpEP.valid][perm$N]));
  exhaleMask#_118[this, FactorialActorChannelImpEP.valid] := exhaleMask#_118[this, FactorialActorChannelImpEP.valid][perm$R := exhaleMask#_118[this, FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_118);
  if (old(Heap)[this, FactorialActorChannelImpEP.state] == 0) {
  } else {
  }
  Mask := exhaleMask#_118;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  85.2: Method might lock/unlock more than allowed."} (forall lk#_121: ref :: {Heap[lk#_121, held]} {Heap[lk#_121, rdheld]} (((0 < Heap[lk#_121, held]) == (0 < old(Heap)[lk#_121, held])) && (Heap[lk#_121, rdheld] == old(Heap)[lk#_121, rdheld])) || false);
  assert {:msg "  85.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialActorChannelImpEP.receiveValue$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t), mi#8: ref where (mi#8 == null) || (dtype(mi#8) == Message#t)) returns (mo#9: ref where (mo#9 == null) || (dtype(mo#9) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_122: int;
  var inhaleHeap#_123: HeapType;
  var inhaleHeap#_124: HeapType;
  assume (0 < methodK#_122) && ((1000 * methodK#_122) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_123;
  assume IsGoodInhaleState(inhaleHeap#_123, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_123[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_123[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_123, Mask);
  assume !(mi#8 == null);
  assume mi#8 != null;
  Heap[mi#8, Message.type] := inhaleHeap#_123[mi#8, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#8, Message.type] := Mask[mi#8, Message.type][perm$R := Mask[mi#8, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_123[mi#8, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_123, Mask);
  assert {:msg "  95.57: Receiver might be null."} true ==> (mi#8 != null);
  assert {:msg "  95.57: Location might not be readable."} true ==> CanRead(Mask, mi#8, Message.type);
  assume Heap[mi#8, Message.type] == 1;
  assert {:msg "  95.71: Receiver might be null."} mi#8 != null;
  assume mi#8 != null;
  Heap[mi#8, Message.inv] := inhaleHeap#_123[mi#8, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_123[mi#8, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#8, Message.inv] := Mask[mi#8, Message.inv][perm$R := Mask[mi#8, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_123[mi#8, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_123, Mask);
  assert {:msg "  96.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  96.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
  assume Heap[this, FactorialActorChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_124;
  assume IsGoodInhaleState(inhaleHeap#_124, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_124[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_124[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_124, Mask);
  assert {:msg "  97.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  97.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
  assume Heap[this, FactorialActorChannelImpEP.state] == 0;
  assume mo#9 != null;
  Heap[mo#9, Message.type] := inhaleHeap#_124[mo#9, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mo#9, Message.type] := Mask[mo#9, Message.type][perm$R := Mask[mo#9, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_124[mo#9, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_124, Mask);
  assert {:msg "  97.56: Receiver might be null."} true ==> (mo#9 != null);
  assert {:msg "  97.56: Location might not be readable."} true ==> CanRead(Mask, mo#9, Message.type);
  assume Heap[mo#9, Message.type] == 1;
  assume mi#8 == mo#9;
  assert {:msg "  97.80: Receiver might be null."} mo#9 != null;
  assume mo#9 != null;
  Heap[mo#9, Message.invValue] := inhaleHeap#_124[mo#9, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_124[mo#9, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[mo#9, Message.invValue] := Mask[mo#9, Message.invValue][perm$R := Mask[mo#9, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_124[mo#9, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_124, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelImpEP.receiveValue(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t), mi#8: ref where (mi#8 == null) || (dtype(mi#8) == Message#t)) returns (mo#9: ref where (mo#9 == null) || (dtype(mo#9) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_122: int;
  var inhaleHeap#_125: HeapType;
  var unfoldK#_126: int;
  var exhaleMask#_127: MaskType;
  var inhaleHeap#_129: HeapType;
  var Heap#_133: HeapType;
  var Mask#_134: MaskType;
  var Credits#_135: CreditsType;
  var exhaleMask#_136: MaskType;
  var exhaleMask#_137: MaskType;
  assume (0 < methodK#_122) && ((1000 * methodK#_122) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_125;
  assume IsGoodInhaleState(inhaleHeap#_125, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_125[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_125[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_125, Mask);
  assume !(mi#8 == null);
  assume mi#8 != null;
  Heap[mi#8, Message.type] := inhaleHeap#_125[mi#8, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#8, Message.type] := Mask[mi#8, Message.type][perm$R := Mask[mi#8, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_125[mi#8, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_125, Mask);
  assume Heap[mi#8, Message.type] == 1;
  assume mi#8 != null;
  Heap[mi#8, Message.inv] := inhaleHeap#_125[mi#8, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_125[mi#8, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#8, Message.inv] := Mask[mi#8, Message.inv][perm$R := Mask[mi#8, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_125[mi#8, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_125, Mask);
  assume Heap[this, FactorialActorChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_126) && (unfoldK#_126 < Fractions(1)) && ((1000 * unfoldK#_126) < methodK#_122);
  assert {:msg "  99.3: The target of the fold statement might be null."} mi#8 != null;
  // begin exhale (unfold)
  exhaleMask#_127 := Mask;
  assert {:msg "  99.3: unfold might fail because the predicate Message.inv does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  99.3: unfold might fail because the predicate Message.inv does not hold. Insufficient fraction at <undefined position> for Message.inv."} (Fractions(100) <= exhaleMask#_127[mi#8, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_127[mi#8, Message.inv][perm$R]) ==> (0 <= exhaleMask#_127[mi#8, Message.inv][perm$N]));
  exhaleMask#_127[mi#8, Message.inv] := exhaleMask#_127[mi#8, Message.inv][perm$R := exhaleMask#_127[mi#8, Message.inv][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_127);
  Mask := exhaleMask#_127;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_129 := Heap[mi#8, Message.inv];
  assume IsGoodInhaleState(inhaleHeap#_129, Heap, Mask);
  assume mi#8 != null;
  Heap[mi#8, Message.type] := inhaleHeap#_129[mi#8, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[mi#8, Message.type] := Mask[mi#8, Message.type][perm$R := Mask[mi#8, Message.type][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_129[mi#8, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_129, Mask);
  if (Heap[mi#8, Message.type] == 1) {
    assume mi#8 != null;
    Heap[mi#8, Message.invValue] := inhaleHeap#_129[mi#8, Message.invValue];
    assume wf(Heap, Mask);
    assume inhaleHeap#_129[mi#8, Message.invValue] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#8, Message.invValue] := Mask[mi#8, Message.invValue][perm$R := Mask[mi#8, Message.invValue][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_129[mi#8, Message.invValue]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_129, Mask);
  } else {
  }
  if (Heap[mi#8, Message.type] == 2) {
    assume mi#8 != null;
    Heap[mi#8, Message.invResult1] := inhaleHeap#_129[mi#8, Message.invResult1];
    assume wf(Heap, Mask);
    assume inhaleHeap#_129[mi#8, Message.invResult1] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#8, Message.invResult1] := Mask[mi#8, Message.invResult1][perm$R := Mask[mi#8, Message.invResult1][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_129[mi#8, Message.invResult1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_129, Mask);
  } else {
  }
  if (Heap[mi#8, Message.type] == 3) {
    assume mi#8 != null;
    Heap[mi#8, Message.invResult2] := inhaleHeap#_129[mi#8, Message.invResult2];
    assume wf(Heap, Mask);
    assume inhaleHeap#_129[mi#8, Message.invResult2] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#8, Message.invResult2] := Mask[mi#8, Message.invResult2][perm$R := Mask[mi#8, Message.invResult2][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_129[mi#8, Message.invResult2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_129, Mask);
  } else {
  }
  if (Heap[mi#8, Message.type] == 4) {
    assume mi#8 != null;
    Heap[mi#8, Message.invFinalResult] := inhaleHeap#_129[mi#8, Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_129[mi#8, Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#8, Message.invFinalResult] := Mask[mi#8, Message.invFinalResult][perm$R := Mask[mi#8, Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_129[mi#8, Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_129, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  100.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  100.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
  if (Heap[this, FactorialActorChannelImpEP.state] == 0) {
    // update field state
    assert {:msg "  101.4: Location might not be writable"} CanWrite(Mask, this, FactorialActorChannelImpEP.state);
    Heap[this, FactorialActorChannelImpEP.state] := 0;
    assume wf(Heap, Mask);
  } else {
    // assert
    Heap#_133 := Heap;
    Mask#_134 := Mask;
    Credits#_135 := Credits;
    // begin exhale (assert)
    exhaleMask#_136 := Mask#_134;
    assert {:msg "  105.4: Assertion might not hold. The expression at 105.11 might not evaluate to true."} false;
    Mask#_134 := exhaleMask#_136;
    assume wf(Heap#_133, Mask#_134);
    // end exhale
  }
  // assigment to mo
  mo#9 := mi#8;
  // begin exhale (postcondition)
  exhaleMask#_137 := Mask;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. The expression at 97.24 might not evaluate to true."} Heap[this, FactorialActorChannelImpEP.state] == 0;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. The expression at 97.56 might not evaluate to true."} Heap[mo#9, Message.type] == 1;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. The expression at 97.70 might not evaluate to true."} mi#8 == mo#9;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. The permission at 97.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. Insufficient fraction at 97.10 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_137[this, FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_137[this, FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_137[this, FactorialActorChannelImpEP.state][perm$N]));
  exhaleMask#_137[this, FactorialActorChannelImpEP.state] := exhaleMask#_137[this, FactorialActorChannelImpEP.state][perm$R := exhaleMask#_137[this, FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_137);
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. The permission at 97.36 might not be positive."} monitorK > 0;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. Insufficient fraction at 97.36 for Message.type."} (monitorK <= exhaleMask#_137[mo#9, Message.type][perm$R]) && ((monitorK == exhaleMask#_137[mo#9, Message.type][perm$R]) ==> (0 <= exhaleMask#_137[mo#9, Message.type][perm$N]));
  exhaleMask#_137[mo#9, Message.type] := exhaleMask#_137[mo#9, Message.type][perm$R := exhaleMask#_137[mo#9, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_137);
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. The permission at 97.80 might not be positive."} Fractions(100) > 0;
  assert {:msg "  94.2: The postcondition at 97.10 might not hold. Insufficient fraction at 97.80 for Message.invValue."} (Fractions(100) <= exhaleMask#_137[mo#9, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_137[mo#9, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_137[mo#9, Message.invValue][perm$N]));
  exhaleMask#_137[mo#9, Message.invValue] := exhaleMask#_137[mo#9, Message.invValue][perm$R := exhaleMask#_137[mo#9, Message.invValue][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_137);
  Mask := exhaleMask#_137;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  94.2: Method might lock/unlock more than allowed."} (forall lk#_141: ref :: {Heap[lk#_141, held]} {Heap[lk#_141, rdheld]} (((0 < Heap[lk#_141, held]) == (0 < old(Heap)[lk#_141, held])) && (Heap[lk#_141, rdheld] == old(Heap)[lk#_141, rdheld])) || false);
  assert {:msg "  94.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialActorChannelImpEP.fail$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t), m#10: ref where (m#10 == null) || (dtype(m#10) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_142: int;
  var inhaleHeap#_143: HeapType;
  var inhaleHeap#_144: HeapType;
  assume (0 < methodK#_142) && ((1000 * methodK#_142) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_143;
  assume IsGoodInhaleState(inhaleHeap#_143, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_143[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assume m#10 != null;
  Heap[m#10, Message.type] := inhaleHeap#_143[m#10, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#10, Message.type] := Mask[m#10, Message.type][perm$R := Mask[m#10, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[m#10, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assert {:msg "  111.44: Receiver might be null."} true ==> (m#10 != null);
  assert {:msg "  111.44: Location might not be readable."} true ==> CanRead(Mask, m#10, Message.type);
  assume Heap[m#10, Message.type] == 1;
  assert {:msg "  111.57: Receiver might be null."} m#10 != null;
  assume m#10 != null;
  Heap[m#10, Message.inv] := inhaleHeap#_143[m#10, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_143[m#10, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[m#10, Message.inv] := Mask[m#10, Message.inv][perm$R := Mask[m#10, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[m#10, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assert {:msg "  112.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.valid] := inhaleHeap#_143[this, FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_143[this, FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.valid] := Mask[this, FactorialActorChannelImpEP.valid][perm$R := Mask[this, FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_143[this, FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_143, Mask);
  assert {:msg "  113.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  113.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
  assume !(Heap[this, FactorialActorChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_144;
  assume IsGoodInhaleState(inhaleHeap#_144, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_144[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_144[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_144, Mask);
  assert {:msg "  114.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.valid] := inhaleHeap#_144[this, FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_144[this, FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.valid] := Mask[this, FactorialActorChannelImpEP.valid][perm$R := Mask[this, FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_144[this, FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_144, Mask);
  assert {:msg "  114.33: Receiver might be null."} true ==> (this != null);
  assert {:msg "  114.33: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
  assume !(Heap[this, FactorialActorChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannelImpEP.fail(this: ref where (this == null) || (dtype(this) == FactorialActorChannelImpEP#t), m#10: ref where (m#10 == null) || (dtype(m#10) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_142: int;
  var inhaleHeap#_145: HeapType;
  var Heap#_149: HeapType;
  var Mask#_150: MaskType;
  var Credits#_151: CreditsType;
  var exhaleMask#_152: MaskType;
  var exhaleMask#_153: MaskType;
  assume (0 < methodK#_142) && ((1000 * methodK#_142) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_145;
  assume IsGoodInhaleState(inhaleHeap#_145, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.state] := inhaleHeap#_145[this, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.state] := Mask[this, FactorialActorChannelImpEP.state][perm$R := Mask[this, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume m#10 != null;
  Heap[m#10, Message.type] := inhaleHeap#_145[m#10, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#10, Message.type] := Mask[m#10, Message.type][perm$R := Mask[m#10, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[m#10, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume Heap[m#10, Message.type] == 1;
  assume m#10 != null;
  Heap[m#10, Message.inv] := inhaleHeap#_145[m#10, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_145[m#10, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[m#10, Message.inv] := Mask[m#10, Message.inv][perm$R := Mask[m#10, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[m#10, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume this != null;
  Heap[this, FactorialActorChannelImpEP.valid] := inhaleHeap#_145[this, FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_145[this, FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannelImpEP.valid] := Mask[this, FactorialActorChannelImpEP.valid][perm$R := Mask[this, FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_145[this, FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_145, Mask);
  assume !(Heap[this, FactorialActorChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  116.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  116.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannelImpEP.state);
  if (Heap[this, FactorialActorChannelImpEP.state] == 0) {
    // assert
    Heap#_149 := Heap;
    Mask#_150 := Mask;
    Credits#_151 := Credits;
    // begin exhale (assert)
    exhaleMask#_152 := Mask#_150;
    assert {:msg "  117.4: Assertion might not hold. The expression at 117.11 might not evaluate to true."} false;
    Mask#_150 := exhaleMask#_152;
    assume wf(Heap#_149, Mask#_150);
    // end exhale
  } else {
    // assume
    assume false;
  }
  // begin exhale (postcondition)
  exhaleMask#_153 := Mask;
  assert {:msg "  110.2: The postcondition at 114.10 might not hold. The expression at 114.33 might not evaluate to true."} !(Heap[this, FactorialActorChannelImpEP.state] == 0);
  assert {:msg "  110.2: The postcondition at 114.10 might not hold. The permission at 114.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  110.2: The postcondition at 114.10 might not hold. Insufficient fraction at 114.10 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_153[this, FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_153[this, FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_153[this, FactorialActorChannelImpEP.state][perm$N]));
  exhaleMask#_153[this, FactorialActorChannelImpEP.state] := exhaleMask#_153[this, FactorialActorChannelImpEP.state][perm$R := exhaleMask#_153[this, FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_153);
  assert {:msg "  110.2: The postcondition at 114.10 might not hold. The permission at 114.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  110.2: The postcondition at 114.10 might not hold. Insufficient fraction at 114.24 for FactorialActorChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_153[this, FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_153[this, FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_153[this, FactorialActorChannelImpEP.valid][perm$N]));
  exhaleMask#_153[this, FactorialActorChannelImpEP.valid] := exhaleMask#_153[this, FactorialActorChannelImpEP.valid][perm$R := exhaleMask#_153[this, FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_153);
  Mask := exhaleMask#_153;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  110.2: Method might lock/unlock more than allowed."} (forall lk#_156: ref :: {Heap[lk#_156, held]} {Heap[lk#_156, rdheld]} (((0 < Heap[lk#_156, held]) == (0 < old(Heap)[lk#_156, held])) && (Heap[lk#_156, rdheld] == old(Heap)[lk#_156, rdheld])) || false);
  assert {:msg "  110.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActorChannel#t: TypeName;
procedure FactorialActorChannel$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_164: int;
  var h0#_157: HeapType;
  var m0#_158: MaskType;
  var c0#_159: CreditsType;
  var h1#_160: HeapType;
  var m1#_161: MaskType;
  var c1#_162: CreditsType;
  var lk#_163: ref;
  assume (0 < methodK#_164) && ((1000 * methodK#_164) < Fractions(1));
  assume wf(h0#_157, m0#_158);
  assume wf(h1#_160, m1#_161);
  m1#_161 := ZeroMask;
  c1#_162 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  125.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActorChannel.imp: Field (ref);
axiom NonPredicateField(FactorialActorChannel.imp);
const unique FactorialActorChannel.exp: Field (ref);
axiom NonPredicateField(FactorialActorChannel.exp);
const unique FactorialActorChannel.valid: Field (HeapType);
axiom PredicateField(FactorialActorChannel.valid);
procedure FactorialActorChannel.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_165: int;
  var inhaleHeap#_166: HeapType;
  assume (0 < predicateK#_165) && ((1000 * predicateK#_165) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_166;
  assume IsGoodInhaleState(inhaleHeap#_166, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.imp] := inhaleHeap#_166[this, FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.imp] == null) || (dtype(Heap[this, FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannel.imp] := Mask[this, FactorialActorChannel.imp][perm$R := Mask[this, FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_166[this, FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_166, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.exp] := inhaleHeap#_166[this, FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.exp] == null) || (dtype(Heap[this, FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannel.exp] := Mask[this, FactorialActorChannel.exp][perm$R := Mask[this, FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_166[this, FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_166, Mask);
  assert {:msg "  130.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  130.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assume Heap[this, FactorialActorChannel.imp] != null;
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_166[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_166[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_166, Mask);
  assert {:msg "  130.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  130.57: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assume Heap[this, FactorialActorChannel.exp] != null;
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := inhaleHeap#_166[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_166[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_166, Mask);
  assert {:msg "  131.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assume !(Heap[this, FactorialActorChannel.imp] == null);
  assert {:msg "  131.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.16: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assume !(Heap[this, FactorialActorChannel.exp] == null);
  assert {:msg "  131.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.29: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  131.29: Receiver might be null."} Heap[this, FactorialActorChannel.imp] != null;
  assert {:msg "  131.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.29: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assume Heap[this, FactorialActorChannel.imp] != null;
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := inhaleHeap#_166[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_166[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_166[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_166, Mask);
  assert {:msg "  131.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.42: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  131.42: Receiver might be null."} Heap[this, FactorialActorChannel.exp] != null;
  assert {:msg "  131.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.42: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assume Heap[this, FactorialActorChannel.exp] != null;
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_166[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_166[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_166[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_166, Mask);
  assert {:msg "  131.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.55: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  131.55: Receiver might be null."} true ==> (Heap[this, FactorialActorChannel.imp] != null);
  assert {:msg "  131.55: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch);
  assume Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == this;
  assert {:msg "  131.70: Receiver might be null."} true ==> (this != null);
  assert {:msg "  131.70: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  131.70: Receiver might be null."} true ==> (Heap[this, FactorialActorChannel.exp] != null);
  assert {:msg "  131.70: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch);
  assume Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == this;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FactorialActorChannel.initImpState: Field (HeapType);
axiom PredicateField(FactorialActorChannel.initImpState);
procedure FactorialActorChannel.initImpState$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_167: int;
  var inhaleHeap#_168: HeapType;
  assume (0 < predicateK#_167) && ((1000 * predicateK#_167) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_168;
  assume IsGoodInhaleState(inhaleHeap#_168, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.imp] := inhaleHeap#_168[this, FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.imp] == null) || (dtype(Heap[this, FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannel.imp] := Mask[this, FactorialActorChannel.imp][perm$R := Mask[this, FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_168[this, FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_168, Mask);
  assert {:msg "  135.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  135.23: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assume Heap[this, FactorialActorChannel.imp] != null;
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := inhaleHeap#_168[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_168[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_168, Mask);
  assert {:msg "  135.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  135.37: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  135.37: Receiver might be null."} true ==> (Heap[this, FactorialActorChannel.imp] != null);
  assert {:msg "  135.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state);
  assume Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FactorialActorChannel.initExpState: Field (HeapType);
axiom PredicateField(FactorialActorChannel.initExpState);
procedure FactorialActorChannel.initExpState$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_169: int;
  var inhaleHeap#_170: HeapType;
  assume (0 < predicateK#_169) && ((1000 * predicateK#_169) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_170;
  assume IsGoodInhaleState(inhaleHeap#_170, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.exp] := inhaleHeap#_170[this, FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.exp] == null) || (dtype(Heap[this, FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannel.exp] := Mask[this, FactorialActorChannel.exp][perm$R := Mask[this, FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_170[this, FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_170, Mask);
  assert {:msg "  139.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.23: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assume Heap[this, FactorialActorChannel.exp] != null;
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := inhaleHeap#_170[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_170[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_170, Mask);
  assert {:msg "  139.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  139.37: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  139.37: Receiver might be null."} true ==> (Heap[this, FactorialActorChannel.exp] != null);
  assert {:msg "  139.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state);
  assume Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannel.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActorChannel#t), i#11: ref where (i#11 == null) || (dtype(i#11) == FactorialActorChannelImpEP#t), e#12: ref where (e#12 == null) || (dtype(e#12) == FactorialActorChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_171: int;
  var inhaleHeap#_172: HeapType;
  var inhaleHeap#_173: HeapType;
  assume (0 < methodK#_171) && ((1000 * methodK#_171) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_172;
  assume IsGoodInhaleState(inhaleHeap#_172, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.imp] := inhaleHeap#_172[this, FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.imp] == null) || (dtype(Heap[this, FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.imp] := Mask[this, FactorialActorChannel.imp][perm$R := Mask[this, FactorialActorChannel.imp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[this, FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume i#11 != null;
  Heap[i#11, FactorialActorChannelImpEP.ch] := inhaleHeap#_172[i#11, FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[i#11, FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[i#11, FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume Fractions(100) > 0;
  Mask[i#11, FactorialActorChannelImpEP.ch] := Mask[i#11, FactorialActorChannelImpEP.ch][perm$R := Mask[i#11, FactorialActorChannelImpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[i#11, FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.exp] := inhaleHeap#_172[this, FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.exp] == null) || (dtype(Heap[this, FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.exp] := Mask[this, FactorialActorChannel.exp][perm$R := Mask[this, FactorialActorChannel.exp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[this, FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume e#12 != null;
  Heap[e#12, FactorialActorChannelExpEP.ch] := inhaleHeap#_172[e#12, FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[e#12, FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[e#12, FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume Fractions(100) > 0;
  Mask[e#12, FactorialActorChannelExpEP.ch] := Mask[e#12, FactorialActorChannelExpEP.ch][perm$R := Mask[e#12, FactorialActorChannelExpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[e#12, FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume i#11 != null;
  Heap[i#11, FactorialActorChannelImpEP.impch] := inhaleHeap#_172[i#11, FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[i#11, FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[i#11, FactorialActorChannelImpEP.impch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[i#11, FactorialActorChannelImpEP.impch] := Mask[i#11, FactorialActorChannelImpEP.impch][perm$R := Mask[i#11, FactorialActorChannelImpEP.impch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[i#11, FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume e#12 != null;
  Heap[e#12, FactorialActorChannelExpEP.expch] := inhaleHeap#_172[e#12, FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[e#12, FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[e#12, FactorialActorChannelExpEP.expch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[e#12, FactorialActorChannelExpEP.expch] := Mask[e#12, FactorialActorChannelExpEP.expch][perm$R := Mask[e#12, FactorialActorChannelExpEP.expch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[e#12, FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume i#11 != null;
  Heap[i#11, FactorialActorChannelImpEP.state] := inhaleHeap#_172[i#11, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[i#11, FactorialActorChannelImpEP.state] := Mask[i#11, FactorialActorChannelImpEP.state][perm$R := Mask[i#11, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[i#11, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume e#12 != null;
  Heap[e#12, FactorialActorChannelExpEP.state] := inhaleHeap#_172[e#12, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[e#12, FactorialActorChannelExpEP.state] := Mask[e#12, FactorialActorChannelExpEP.state][perm$R := Mask[e#12, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_172[e#12, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_172, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_173;
  assume IsGoodInhaleState(inhaleHeap#_173, Heap, Mask);
  assert {:msg "  144.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannel.valid] := inhaleHeap#_173[this, FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_173[this, FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.valid] := Mask[this, FactorialActorChannel.valid][perm$R := Mask[this, FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[this, FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assert {:msg "  144.19: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannel.valid] := inhaleHeap#_173[this, FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_173[this, FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.valid] := Mask[this, FactorialActorChannel.valid][perm$R := Mask[this, FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[this, FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.imp] := inhaleHeap#_173[this, FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.imp] == null) || (dtype(Heap[this, FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannel.imp] := Mask[this, FactorialActorChannel.imp][perm$R := Mask[this, FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[this, FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assert {:msg "  145.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  145.18: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assume !(Heap[this, FactorialActorChannel.imp] == null);
  assume this != null;
  Heap[this, FactorialActorChannel.exp] := inhaleHeap#_173[this, FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.exp] == null) || (dtype(Heap[this, FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialActorChannel.exp] := Mask[this, FactorialActorChannel.exp][perm$R := Mask[this, FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[this, FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assert {:msg "  146.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  146.18: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assume !(Heap[this, FactorialActorChannel.exp] == null);
  assert {:msg "  147.5: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.5: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assume Heap[this, FactorialActorChannel.imp] != null;
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_173[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assert {:msg "  147.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  147.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  147.24: Receiver might be null."} true ==> (Heap[this, FactorialActorChannel.imp] != null);
  assert {:msg "  147.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume !(Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  148.5: Receiver might be null."} true ==> (this != null);
  assert {:msg "  148.5: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assume Heap[this, FactorialActorChannel.exp] != null;
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_173[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assert {:msg "  148.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  148.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  148.24: Receiver might be null."} true ==> (Heap[this, FactorialActorChannel.exp] != null);
  assert {:msg "  148.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  assume !(Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  149.2: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannel.initImpState] := inhaleHeap#_173[this, FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_173[this, FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.initImpState] := Mask[this, FactorialActorChannel.initImpState][perm$R := Mask[this, FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[this, FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assert {:msg "  149.18: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialActorChannel.initExpState] := inhaleHeap#_173[this, FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_173[this, FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.initExpState] := Mask[this, FactorialActorChannel.initExpState][perm$R := Mask[this, FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_173[this, FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_173, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActorChannel.init(this: ref where (this == null) || (dtype(this) == FactorialActorChannel#t), i#11: ref where (i#11 == null) || (dtype(i#11) == FactorialActorChannelImpEP#t), e#12: ref where (e#12 == null) || (dtype(e#12) == FactorialActorChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_171: int;
  var inhaleHeap#_174: HeapType;
  var nw#_175: ref;
  var mu#_176: Mu;
  var nw#_178: ref;
  var mu#_179: Mu;
  var foldK#_181: int;
  var exhaleMask#_182: MaskType;
  var inhaleHeap#_191: HeapType;
  var foldK#_192: int;
  var exhaleMask#_193: MaskType;
  var inhaleHeap#_202: HeapType;
  var foldK#_203: int;
  var exhaleMask#_204: MaskType;
  var inhaleHeap#_213: HeapType;
  var foldK#_214: int;
  var exhaleMask#_215: MaskType;
  var inhaleHeap#_224: HeapType;
  var foldK#_225: int;
  var exhaleMask#_226: MaskType;
  var inhaleHeap#_233: HeapType;
  var foldK#_234: int;
  var exhaleMask#_235: MaskType;
  var inhaleHeap#_242: HeapType;
  var foldK#_243: int;
  var exhaleMask#_244: MaskType;
  var inhaleHeap#_247: HeapType;
  var foldK#_248: int;
  var exhaleMask#_249: MaskType;
  var inhaleHeap#_252: HeapType;
  var exhaleMask#_253: MaskType;
  assume (0 < methodK#_171) && ((1000 * methodK#_171) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_174;
  assume IsGoodInhaleState(inhaleHeap#_174, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.imp] := inhaleHeap#_174[this, FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.imp] == null) || (dtype(Heap[this, FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.imp] := Mask[this, FactorialActorChannel.imp][perm$R := Mask[this, FactorialActorChannel.imp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[this, FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume i#11 != null;
  Heap[i#11, FactorialActorChannelImpEP.ch] := inhaleHeap#_174[i#11, FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[i#11, FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[i#11, FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume Fractions(100) > 0;
  Mask[i#11, FactorialActorChannelImpEP.ch] := Mask[i#11, FactorialActorChannelImpEP.ch][perm$R := Mask[i#11, FactorialActorChannelImpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[i#11, FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.exp] := inhaleHeap#_174[this, FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActorChannel.exp] == null) || (dtype(Heap[this, FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.exp] := Mask[this, FactorialActorChannel.exp][perm$R := Mask[this, FactorialActorChannel.exp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[this, FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume e#12 != null;
  Heap[e#12, FactorialActorChannelExpEP.ch] := inhaleHeap#_174[e#12, FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[e#12, FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[e#12, FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume Fractions(100) > 0;
  Mask[e#12, FactorialActorChannelExpEP.ch] := Mask[e#12, FactorialActorChannelExpEP.ch][perm$R := Mask[e#12, FactorialActorChannelExpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[e#12, FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume i#11 != null;
  Heap[i#11, FactorialActorChannelImpEP.impch] := inhaleHeap#_174[i#11, FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[i#11, FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[i#11, FactorialActorChannelImpEP.impch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[i#11, FactorialActorChannelImpEP.impch] := Mask[i#11, FactorialActorChannelImpEP.impch][perm$R := Mask[i#11, FactorialActorChannelImpEP.impch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[i#11, FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume e#12 != null;
  Heap[e#12, FactorialActorChannelExpEP.expch] := inhaleHeap#_174[e#12, FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[e#12, FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[e#12, FactorialActorChannelExpEP.expch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[e#12, FactorialActorChannelExpEP.expch] := Mask[e#12, FactorialActorChannelExpEP.expch][perm$R := Mask[e#12, FactorialActorChannelExpEP.expch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[e#12, FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume i#11 != null;
  Heap[i#11, FactorialActorChannelImpEP.state] := inhaleHeap#_174[i#11, FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[i#11, FactorialActorChannelImpEP.state] := Mask[i#11, FactorialActorChannelImpEP.state][perm$R := Mask[i#11, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[i#11, FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume e#12 != null;
  Heap[e#12, FactorialActorChannelExpEP.state] := inhaleHeap#_174[e#12, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[e#12, FactorialActorChannelExpEP.state] := Mask[e#12, FactorialActorChannelExpEP.state][perm$R := Mask[e#12, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_174[e#12, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_174, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field imp
  assert {:msg "  151.3: Location might not be writable"} CanWrite(Mask, this, FactorialActorChannel.imp);
  Heap[this, FactorialActorChannel.imp] := i#11;
  assume wf(Heap, Mask);
  // update field exp
  assert {:msg "  152.3: Location might not be writable"} CanWrite(Mask, this, FactorialActorChannel.exp);
  Heap[this, FactorialActorChannel.exp] := e#12;
  assume wf(Heap, Mask);
  // update field ch
  assert {:msg "  153.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  153.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  153.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch);
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := this;
  assume wf(Heap, Mask);
  // update field ch
  assert {:msg "  154.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  154.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  154.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch);
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := this;
  assume wf(Heap, Mask);
  // update field impch
  assert {:msg "  155.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  155.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  155.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  // new
  havoc nw#_175;
  assume (nw#_175 != null) && (dtype(nw#_175) == Channel#t);
  assume (forall<T#_0> f: Field (T#_0) :: (Mask[nw#_175, f][perm$R] == 0) && (Mask[nw#_175, f][perm$N] == 0));
  havoc mu#_176;
  assume mu#_176 != $LockBottom;
  assume (forall o#_177: ref :: (((0 < Heap[o#_177, held]) || Heap[o#_177, rdheld]) || (Credits[o#_177] < 0)) ==> MuBelow(Heap[o#_177, mu], mu#_176));
  assume Heap[nw#_175, mu] == mu#_176;
  assume Heap[nw#_175, held] <= 0;
  assume Heap[nw#_175, rdheld] == false;
  Mask[nw#_175, mu] := Mask[nw#_175, mu][perm$R := Mask[nw#_175, mu][perm$R] + Fractions(100)];
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := nw#_175;
  assume wf(Heap, Mask);
  // update field expch
  assert {:msg "  156.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  156.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  156.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  // new
  havoc nw#_178;
  assume (nw#_178 != null) && (dtype(nw#_178) == Channel#t);
  assume (forall<T#_1> f: Field (T#_1) :: (Mask[nw#_178, f][perm$R] == 0) && (Mask[nw#_178, f][perm$N] == 0));
  havoc mu#_179;
  assume mu#_179 != $LockBottom;
  assume (forall o#_180: ref :: (((0 < Heap[o#_180, held]) || Heap[o#_180, rdheld]) || (Credits[o#_180] < 0)) ==> MuBelow(Heap[o#_180, mu], mu#_179));
  assume Heap[nw#_178, mu] == mu#_179;
  assume Heap[nw#_178, held] <= 0;
  assume Heap[nw#_178, rdheld] == false;
  Mask[nw#_178, mu] := Mask[nw#_178, mu][perm$R := Mask[nw#_178, mu][perm$R] + Fractions(100)];
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := nw#_178;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_181) && ((1000 * foldK#_181) < Fractions(1)) && ((1000 * foldK#_181) < methodK#_171);
  assert {:msg "  157.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  157.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  157.3: The target of the fold statement might be null."} Heap[this, FactorialActorChannel.imp] != null;
  // begin exhale (fold)
  exhaleMask#_182 := Mask;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 78.38 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 79.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] == null);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 79.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] == null);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 80.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 81.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 78.5 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 78.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 78.23 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 78.23 for FactorialActorChannelImpEP.ch."} (monitorK <= exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$N]));
  exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_182[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 79.5 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 79.5 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] := exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R := exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 79.40 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 79.40 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] := exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R := exhaleMask#_182[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 80.5 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 80.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 81.5 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 81.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_182[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 82.5 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 82.5 for mu."} (monitorK <= exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 82.33 might not be positive."} monitorK > 0;
  assert {:msg "  157.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 82.33 for mu."} (monitorK <= exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := exhaleMask#_182[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_182);
  Mask := exhaleMask#_182;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_191;
  assume IsGoodInhaleState(inhaleHeap#_191, Heap, Mask);
  assume Heap[this, FactorialActorChannel.imp] != null;
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := inhaleHeap#_191[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_191[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_191[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_191, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_192) && ((1000 * foldK#_192) < Fractions(1)) && ((1000 * foldK#_192) < methodK#_171);
  assert {:msg "  158.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  158.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  158.3: The target of the fold statement might be null."} Heap[this, FactorialActorChannel.exp] != null;
  // begin exhale (fold)
  exhaleMask#_193 := Mask;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 27.38 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == null);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 28.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 28.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 29.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 30.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 27.5 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 27.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 27.23 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 27.23 for FactorialActorChannelExpEP.ch."} (monitorK <= exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$N]));
  exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := exhaleMask#_193[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 28.5 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 28.5 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R := exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 28.40 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 28.40 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R := exhaleMask#_193[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 29.5 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 29.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 30.5 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 30.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_193[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 31.5 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 31.5 for mu."} (monitorK <= exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 31.33 might not be positive."} monitorK > 0;
  assert {:msg "  158.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 31.33 for mu."} (monitorK <= exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := exhaleMask#_193[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_193);
  Mask := exhaleMask#_193;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_202;
  assume IsGoodInhaleState(inhaleHeap#_202, Heap, Mask);
  assume Heap[this, FactorialActorChannel.exp] != null;
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_202[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_202[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_202[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_202, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_203) && ((1000 * foldK#_203) < Fractions(1)) && ((1000 * foldK#_203) < methodK#_171);
  assert {:msg "  159.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  159.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  159.3: The target of the fold statement might be null."} Heap[this, FactorialActorChannel.imp] != null;
  // begin exhale (fold)
  exhaleMask#_204 := Mask;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 78.38 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 79.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] == null);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 79.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] == null);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 80.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The expression at 81.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 78.5 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 78.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 78.23 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 78.23 for FactorialActorChannelImpEP.ch."} (monitorK <= exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$N]));
  exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_204[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 79.5 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 79.5 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] := exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R := exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 79.40 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 79.40 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] := exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R := exhaleMask#_204[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 80.5 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 80.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 81.5 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 81.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_204[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 82.5 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 82.5 for mu."} (monitorK <= exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. The permission at 82.33 might not be positive."} monitorK > 0;
  assert {:msg "  159.3: Fold might fail because the definition of FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at 82.33 for mu."} (monitorK <= exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := exhaleMask#_204[Heap[Heap[Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_204);
  Mask := exhaleMask#_204;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_213;
  assume IsGoodInhaleState(inhaleHeap#_213, Heap, Mask);
  assume Heap[this, FactorialActorChannel.imp] != null;
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := inhaleHeap#_213[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_213[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := Mask[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_213[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_213, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_214) && ((1000 * foldK#_214) < Fractions(1)) && ((1000 * foldK#_214) < methodK#_171);
  assert {:msg "  160.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  160.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  160.3: The target of the fold statement might be null."} Heap[this, FactorialActorChannel.exp] != null;
  // begin exhale (fold)
  exhaleMask#_215 := Mask;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 27.38 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == null);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 28.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] == null);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 28.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] == null);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 29.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The expression at 30.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 27.5 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 27.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 27.23 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 27.23 for FactorialActorChannelExpEP.ch."} (monitorK <= exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$N]));
  exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := exhaleMask#_215[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 28.5 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 28.5 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp] := exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R := exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 28.40 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 28.40 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp] := exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R := exhaleMask#_215[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 29.5 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 29.5 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 30.5 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 30.5 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_215[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 31.5 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 31.5 for mu."} (monitorK <= exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. The permission at 31.33 might not be positive."} monitorK > 0;
  assert {:msg "  160.3: Fold might fail because the definition of FactorialActorChannelExpEP.valid does not hold. Insufficient fraction at 31.33 for mu."} (monitorK <= exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := exhaleMask#_215[Heap[Heap[Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_215);
  Mask := exhaleMask#_215;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_224;
  assume IsGoodInhaleState(inhaleHeap#_224, Heap, Mask);
  assume Heap[this, FactorialActorChannel.exp] != null;
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_224[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_224[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_224[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_224, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_225) && ((1000 * foldK#_225) < Fractions(1)) && ((1000 * foldK#_225) < methodK#_171);
  assert {:msg "  161.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_226 := Mask;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.3 might not evaluate to true."} !(Heap[this, FactorialActorChannel.imp] == null);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.16 might not evaluate to true."} !(Heap[this, FactorialActorChannel.exp] == null);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.55 might not evaluate to true."} Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == this;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.70 might not evaluate to true."} Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == this;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.3 might not be positive."} monitorK > 0;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.3 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_226[this, FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_226[this, FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_226[this, FactorialActorChannel.imp][perm$N]));
  exhaleMask#_226[this, FactorialActorChannel.imp] := exhaleMask#_226[this, FactorialActorChannel.imp][perm$R := exhaleMask#_226[this, FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_226);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.19 might not be positive."} monitorK > 0;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.19 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_226[this, FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_226[this, FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_226[this, FactorialActorChannel.exp][perm$N]));
  exhaleMask#_226[this, FactorialActorChannel.exp] := exhaleMask#_226[this, FactorialActorChannel.exp][perm$R := exhaleMask#_226[this, FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_226);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.35 might not be positive."} monitorK > 0;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.35 for FactorialActorChannelImpEP.ch."} (monitorK <= exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$N]));
  exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_226);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.54 might not be positive."} monitorK > 0;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.54 for FactorialActorChannelExpEP.ch."} (monitorK <= exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$N]));
  exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_226);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 131.29 might not be positive."} Fractions(100) > 0;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 131.29 for FactorialActorChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$N]));
  exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := exhaleMask#_226[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_226);
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 131.42 might not be positive."} Fractions(100) > 0;
  assert {:msg "  161.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 131.42 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_226[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_226);
  Mask := exhaleMask#_226;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_233;
  assume IsGoodInhaleState(inhaleHeap#_233, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.valid] := inhaleHeap#_233[this, FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_233[this, FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.valid] := Mask[this, FactorialActorChannel.valid][perm$R := Mask[this, FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_233[this, FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_233, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialActorChannel.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_234) && ((1000 * foldK#_234) < Fractions(1)) && ((1000 * foldK#_234) < methodK#_171);
  assert {:msg "  162.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_235 := Mask;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.3 might not evaluate to true."} !(Heap[this, FactorialActorChannel.imp] == null);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.16 might not evaluate to true."} !(Heap[this, FactorialActorChannel.exp] == null);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.55 might not evaluate to true."} Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == this;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The expression at 131.70 might not evaluate to true."} Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == this;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.3 might not be positive."} monitorK > 0;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.3 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_235[this, FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_235[this, FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_235[this, FactorialActorChannel.imp][perm$N]));
  exhaleMask#_235[this, FactorialActorChannel.imp] := exhaleMask#_235[this, FactorialActorChannel.imp][perm$R := exhaleMask#_235[this, FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_235);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.19 might not be positive."} monitorK > 0;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.19 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_235[this, FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_235[this, FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_235[this, FactorialActorChannel.exp][perm$N]));
  exhaleMask#_235[this, FactorialActorChannel.exp] := exhaleMask#_235[this, FactorialActorChannel.exp][perm$R := exhaleMask#_235[this, FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_235);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.35 might not be positive."} monitorK > 0;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.35 for FactorialActorChannelImpEP.ch."} (monitorK <= exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$N]));
  exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_235);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 130.54 might not be positive."} monitorK > 0;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 130.54 for FactorialActorChannelExpEP.ch."} (monitorK <= exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$N]));
  exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_235);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 131.29 might not be positive."} Fractions(100) > 0;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 131.29 for FactorialActorChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$N]));
  exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := exhaleMask#_235[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_235);
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. The permission at 131.42 might not be positive."} Fractions(100) > 0;
  assert {:msg "  162.3: Fold might fail because the definition of FactorialActorChannel.valid does not hold. Insufficient fraction at 131.42 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_235[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_235);
  Mask := exhaleMask#_235;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_242;
  assume IsGoodInhaleState(inhaleHeap#_242, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.valid] := inhaleHeap#_242[this, FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_242[this, FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.valid] := Mask[this, FactorialActorChannel.valid][perm$R := Mask[this, FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_242[this, FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_242, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialActorChannel.valid] := Heap;
  assume wf(Heap, Mask);
  // update field state
  assert {:msg "  164.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  164.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.imp);
  assert {:msg "  164.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state);
  Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := 0;
  assume wf(Heap, Mask);
  // update field state
  assert {:msg "  165.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  165.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActorChannel.exp);
  assert {:msg "  165.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state);
  Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := 0;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_243) && ((1000 * foldK#_243) < Fractions(1)) && ((1000 * foldK#_243) < methodK#_171);
  assert {:msg "  166.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_244 := Mask;
  assert {:msg "  166.3: Fold might fail because the definition of FactorialActorChannel.initImpState does not hold. The expression at 135.37 might not evaluate to true."} Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
  assert {:msg "  166.3: Fold might fail because the definition of FactorialActorChannel.initImpState does not hold. The permission at 135.3 might not be positive."} monitorK > 0;
  assert {:msg "  166.3: Fold might fail because the definition of FactorialActorChannel.initImpState does not hold. Insufficient fraction at 135.3 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_244[this, FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_244[this, FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_244[this, FactorialActorChannel.imp][perm$N]));
  exhaleMask#_244[this, FactorialActorChannel.imp] := exhaleMask#_244[this, FactorialActorChannel.imp][perm$R := exhaleMask#_244[this, FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_244);
  assert {:msg "  166.3: Fold might fail because the definition of FactorialActorChannel.initImpState does not hold. The permission at 135.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  166.3: Fold might fail because the definition of FactorialActorChannel.initImpState does not hold. Insufficient fraction at 135.19 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_244[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_244[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_244[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$N]));
  exhaleMask#_244[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := exhaleMask#_244[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := exhaleMask#_244[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_244);
  Mask := exhaleMask#_244;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_247;
  assume IsGoodInhaleState(inhaleHeap#_247, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.initImpState] := inhaleHeap#_247[this, FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_247[this, FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.initImpState] := Mask[this, FactorialActorChannel.initImpState][perm$R := Mask[this, FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_247[this, FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_247, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialActorChannel.initImpState] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_248) && ((1000 * foldK#_248) < Fractions(1)) && ((1000 * foldK#_248) < methodK#_171);
  assert {:msg "  167.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_249 := Mask;
  assert {:msg "  167.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. The expression at 139.37 might not evaluate to true."} Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
  assert {:msg "  167.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. The permission at 139.3 might not be positive."} monitorK > 0;
  assert {:msg "  167.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. Insufficient fraction at 139.3 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_249[this, FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_249[this, FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_249[this, FactorialActorChannel.exp][perm$N]));
  exhaleMask#_249[this, FactorialActorChannel.exp] := exhaleMask#_249[this, FactorialActorChannel.exp][perm$R := exhaleMask#_249[this, FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_249);
  assert {:msg "  167.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. The permission at 139.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  167.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. Insufficient fraction at 139.19 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_249[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_249[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_249[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_249[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := exhaleMask#_249[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := exhaleMask#_249[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_249);
  Mask := exhaleMask#_249;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_252;
  assume IsGoodInhaleState(inhaleHeap#_252, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActorChannel.initExpState] := inhaleHeap#_252[this, FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_252[this, FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialActorChannel.initExpState] := Mask[this, FactorialActorChannel.initExpState][perm$R := Mask[this, FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_252[this, FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_252, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialActorChannel.initExpState] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_253 := Mask;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The expression at 145.18 might not evaluate to true."} !(Heap[this, FactorialActorChannel.imp] == null);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The expression at 146.18 might not evaluate to true."} !(Heap[this, FactorialActorChannel.exp] == null);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The expression at 147.24 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The expression at 148.24 might not evaluate to true."} !(Heap[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 144.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 144.10 for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_253[this, FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_253[this, FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_253[this, FactorialActorChannel.valid][perm$N]));
  exhaleMask#_253[this, FactorialActorChannel.valid] := exhaleMask#_253[this, FactorialActorChannel.valid][perm$R := exhaleMask#_253[this, FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 144.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 144.19 for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_253[this, FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_253[this, FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_253[this, FactorialActorChannel.valid][perm$N]));
  exhaleMask#_253[this, FactorialActorChannel.valid] := exhaleMask#_253[this, FactorialActorChannel.valid][perm$R := exhaleMask#_253[this, FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 145.2 might not be positive."} monitorK > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 145.2 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_253[this, FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_253[this, FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_253[this, FactorialActorChannel.imp][perm$N]));
  exhaleMask#_253[this, FactorialActorChannel.imp] := exhaleMask#_253[this, FactorialActorChannel.imp][perm$R := exhaleMask#_253[this, FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 146.2 might not be positive."} monitorK > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 146.2 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_253[this, FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_253[this, FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_253[this, FactorialActorChannel.exp][perm$N]));
  exhaleMask#_253[this, FactorialActorChannel.exp] := exhaleMask#_253[this, FactorialActorChannel.exp][perm$R := exhaleMask#_253[this, FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 147.2 might not be positive."} monitorK > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 147.2 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_253[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_253[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_253[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_253[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_253[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_253[Heap[this, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 148.2 might not be positive."} monitorK > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 148.2 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_253[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_253[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_253[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_253[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_253[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_253[Heap[this, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 149.2 might not be positive."} Fractions(100) > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 149.2 for FactorialActorChannel.initImpState."} (Fractions(100) <= exhaleMask#_253[this, FactorialActorChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_253[this, FactorialActorChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_253[this, FactorialActorChannel.initImpState][perm$N]));
  exhaleMask#_253[this, FactorialActorChannel.initImpState] := exhaleMask#_253[this, FactorialActorChannel.initImpState][perm$R := exhaleMask#_253[this, FactorialActorChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. The permission at 149.18 might not be positive."} Fractions(100) > 0;
  assert {:msg "  142.2: The postcondition at 144.10 might not hold. Insufficient fraction at 149.18 for FactorialActorChannel.initExpState."} (Fractions(100) <= exhaleMask#_253[this, FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_253[this, FactorialActorChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_253[this, FactorialActorChannel.initExpState][perm$N]));
  exhaleMask#_253[this, FactorialActorChannel.initExpState] := exhaleMask#_253[this, FactorialActorChannel.initExpState][perm$R := exhaleMask#_253[this, FactorialActorChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_253);
  Mask := exhaleMask#_253;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  142.2: Method might lock/unlock more than allowed."} (forall lk#_262: ref :: {Heap[lk#_262, held]} {Heap[lk#_262, rdheld]} (((0 < Heap[lk#_262, held]) == (0 < old(Heap)[lk#_262, held])) && (Heap[lk#_262, rdheld] == old(Heap)[lk#_262, rdheld])) || false);
  assert {:msg "  142.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialContChannelExpEP#t: TypeName;
procedure FactorialContChannelExpEP$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_270: int;
  var h0#_263: HeapType;
  var m0#_264: MaskType;
  var c0#_265: CreditsType;
  var h1#_266: HeapType;
  var m1#_267: MaskType;
  var c1#_268: CreditsType;
  var lk#_269: ref;
  assume (0 < methodK#_270) && ((1000 * methodK#_270) < Fractions(1));
  assume wf(h0#_263, m0#_264);
  assume wf(h1#_266, m1#_267);
  m1#_267 := ZeroMask;
  c1#_268 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  181.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialContChannelExpEP.state: Field (int);
axiom NonPredicateField(FactorialContChannelExpEP.state);
const unique FactorialContChannelExpEP.ch: Field (ref);
axiom NonPredicateField(FactorialContChannelExpEP.ch);
const unique FactorialContChannelExpEP.expch: Field (ref);
axiom NonPredicateField(FactorialContChannelExpEP.expch);
const unique FactorialContChannelExpEP.valid: Field (HeapType);
axiom PredicateField(FactorialContChannelExpEP.valid);
procedure FactorialContChannelExpEP.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_271: int;
  var inhaleHeap#_272: HeapType;
  assume (0 < predicateK#_271) && ((1000 * predicateK#_271) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_272;
  assume IsGoodInhaleState(inhaleHeap#_272, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.expch] := inhaleHeap#_272[this, FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelExpEP.expch] == null) || (dtype(Heap[this, FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelExpEP.expch] := Mask[this, FactorialContChannelExpEP.expch][perm$R := Mask[this, FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[this, FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.ch] := inhaleHeap#_272[this, FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelExpEP.ch] == null) || (dtype(Heap[this, FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelExpEP.ch] := Mask[this, FactorialContChannelExpEP.ch][perm$R := Mask[this, FactorialContChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[this, FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assert {:msg "  187.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  187.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assume !(Heap[this, FactorialContChannelExpEP.ch] == null);
  assert {:msg "  188.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  188.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assume Heap[this, FactorialContChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := inhaleHeap#_272[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assert {:msg "  188.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  188.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  188.24: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  188.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp);
  assume !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
  assert {:msg "  188.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  188.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assume Heap[this, FactorialContChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := inhaleHeap#_272[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assert {:msg "  188.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  188.59: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  188.59: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  188.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp);
  assume !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
  assert {:msg "  189.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  189.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  189.8: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp);
  assume Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_272[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assert {:msg "  189.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  189.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  189.30: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  189.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp);
  assert {:msg "  189.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null);
  assert {:msg "  189.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  190.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  190.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  190.8: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp);
  assume Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_272[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assert {:msg "  190.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  190.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  190.30: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  190.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp);
  assert {:msg "  190.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] != null);
  assert {:msg "  190.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  191.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  191.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  191.8: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := inhaleHeap#_272[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assert {:msg "  191.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  191.36: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
  assert {:msg "  191.36: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch);
  assume Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := inhaleHeap#_272[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_272[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_272, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelExpEP.sendResult1$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t), m#13: ref where (m#13 == null) || (dtype(m#13) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_273: int;
  var inhaleHeap#_274: HeapType;
  var inhaleHeap#_275: HeapType;
  assume (0 < methodK#_273) && ((1000 * methodK#_273) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_274;
  assume IsGoodInhaleState(inhaleHeap#_274, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_274[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_274[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_274, Mask);
  assume m#13 != null;
  Heap[m#13, Message.type] := inhaleHeap#_274[m#13, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#13, Message.type] := Mask[m#13, Message.type][perm$R := Mask[m#13, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_274[m#13, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_274, Mask);
  assume m#13 != null;
  Heap[m#13, Message.type] := inhaleHeap#_274[m#13, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#13, Message.type] := Mask[m#13, Message.type][perm$R := Mask[m#13, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_274[m#13, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_274, Mask);
  assert {:msg "  195.63: Receiver might be null."} true ==> (m#13 != null);
  assert {:msg "  195.63: Location might not be readable."} true ==> CanRead(Mask, m#13, Message.type);
  assume Heap[m#13, Message.type] == 2;
  assert {:msg "  195.76: Receiver might be null."} m#13 != null;
  assume m#13 != null;
  Heap[m#13, Message.invResult1] := inhaleHeap#_274[m#13, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_274[m#13, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[m#13, Message.invResult1] := Mask[m#13, Message.invResult1][perm$R := Mask[m#13, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_274[m#13, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_274, Mask);
  assert {:msg "  196.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_274[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_274[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_274[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_274, Mask);
  assert {:msg "  197.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  197.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
  assume Heap[this, FactorialContChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_275;
  assume IsGoodInhaleState(inhaleHeap#_275, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_275[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_275[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_275, Mask);
  assert {:msg "  198.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_275[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_275[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_275[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_275, Mask);
  assert {:msg "  198.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  198.38: Location might not be readable."} true ==> CanRead(old(Mask), this, FactorialContChannelExpEP.state);
  if (old(Heap)[this, FactorialContChannelExpEP.state] == 0) {
    assert {:msg "  198.52: Receiver might be null."} true ==> (this != null);
    assert {:msg "  198.52: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
    assume Heap[this, FactorialContChannelExpEP.state] == 1;
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelExpEP.sendResult1(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t), m#13: ref where (m#13 == null) || (dtype(m#13) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_273: int;
  var inhaleHeap#_276: HeapType;
  var unfoldK#_277: int;
  var exhaleMask#_278: MaskType;
  var inhaleHeap#_280: HeapType;
  var foldK#_281: int;
  var exhaleMask#_282: MaskType;
  var inhaleHeap#_288: HeapType;
  var c#15: ref where (c#15 == null) || (dtype(c#15) == Channel#t);
  var foldK#_289: int;
  var exhaleMask#_290: MaskType;
  var inhaleHeap#_299: HeapType;
  var this#110: ref where (this#110 == null) || (dtype(this#110) == Channel#t);
  var msg#111: ref where (msg#111 == null) || (dtype(msg#111) == Message#t);
  var exhaleMask#_300: MaskType;
  var Heap#_306: HeapType;
  var Mask#_307: MaskType;
  var Credits#_308: CreditsType;
  var exhaleMask#_309: MaskType;
  var exhaleMask#_310: MaskType;
  assume (0 < methodK#_273) && ((1000 * methodK#_273) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_276;
  assume IsGoodInhaleState(inhaleHeap#_276, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_276[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_276[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_276, Mask);
  assume m#13 != null;
  Heap[m#13, Message.type] := inhaleHeap#_276[m#13, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#13, Message.type] := Mask[m#13, Message.type][perm$R := Mask[m#13, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_276[m#13, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_276, Mask);
  assume m#13 != null;
  Heap[m#13, Message.type] := inhaleHeap#_276[m#13, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#13, Message.type] := Mask[m#13, Message.type][perm$R := Mask[m#13, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_276[m#13, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_276, Mask);
  assume Heap[m#13, Message.type] == 2;
  assume m#13 != null;
  Heap[m#13, Message.invResult1] := inhaleHeap#_276[m#13, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_276[m#13, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[m#13, Message.invResult1] := Mask[m#13, Message.invResult1][perm$R := Mask[m#13, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_276[m#13, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_276, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_276[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_276[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_276[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_276, Mask);
  assume Heap[this, FactorialContChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_277) && (unfoldK#_277 < Fractions(1)) && ((1000 * unfoldK#_277) < methodK#_273);
  assert {:msg "  200.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_278 := Mask;
  assert {:msg "  200.3: unfold might fail because the predicate FactorialContChannelExpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  200.3: unfold might fail because the predicate FactorialContChannelExpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_278[this, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_278[this, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_278[this, FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_278[this, FactorialContChannelExpEP.valid] := exhaleMask#_278[this, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_278[this, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_278);
  Mask := exhaleMask#_278;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_280 := Heap[this, FactorialContChannelExpEP.valid];
  assume IsGoodInhaleState(inhaleHeap#_280, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.expch] := inhaleHeap#_280[this, FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelExpEP.expch] == null) || (dtype(Heap[this, FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelExpEP.expch] := Mask[this, FactorialContChannelExpEP.expch][perm$R := Mask[this, FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[this, FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.ch] := inhaleHeap#_280[this, FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelExpEP.ch] == null) || (dtype(Heap[this, FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelExpEP.ch] := Mask[this, FactorialContChannelExpEP.ch][perm$R := Mask[this, FactorialContChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[this, FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume !(Heap[this, FactorialContChannelExpEP.ch] == null);
  assume Heap[this, FactorialContChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := inhaleHeap#_280[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
  assume Heap[this, FactorialContChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := inhaleHeap#_280[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
  assume Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_280[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assume Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_280[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assume Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := inhaleHeap#_280[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := inhaleHeap#_280[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_280[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_280, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  201.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  201.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
  if (Heap[this, FactorialContChannelExpEP.state] == 0) {
    // fold
    assume (0 < foldK#_281) && ((1000 * foldK#_281) < Fractions(1)) && ((1000 * foldK#_281) < methodK#_273);
    assert {:msg "  202.4: The target of the fold statement might be null."} m#13 != null;
    // begin exhale (fold)
    exhaleMask#_282 := Mask;
    if (Heap[m#13, Message.type] == 1) {
    } else {
    }
    if (Heap[m#13, Message.type] == 2) {
    } else {
    }
    if (Heap[m#13, Message.type] == 3) {
    } else {
    }
    if (Heap[m#13, Message.type] == 4) {
    } else {
    }
    assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. The permission at 649.3 might not be positive."} predicateK > 0;
    assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 649.3 for Message.type."} (predicateK <= exhaleMask#_282[m#13, Message.type][perm$R]) && ((predicateK == exhaleMask#_282[m#13, Message.type][perm$R]) ==> (0 <= exhaleMask#_282[m#13, Message.type][perm$N]));
    exhaleMask#_282[m#13, Message.type] := exhaleMask#_282[m#13, Message.type][perm$R := exhaleMask#_282[m#13, Message.type][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_282);
    if (Heap[m#13, Message.type] == 1) {
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. The permission at 650.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 650.16 for Message.invValue."} (Fractions(100) <= exhaleMask#_282[m#13, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_282[m#13, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_282[m#13, Message.invValue][perm$N]));
      exhaleMask#_282[m#13, Message.invValue] := exhaleMask#_282[m#13, Message.invValue][perm$R := exhaleMask#_282[m#13, Message.invValue][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_282);
    } else {
    }
    if (Heap[m#13, Message.type] == 2) {
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. The permission at 651.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 651.16 for Message.invResult1."} (Fractions(100) <= exhaleMask#_282[m#13, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_282[m#13, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_282[m#13, Message.invResult1][perm$N]));
      exhaleMask#_282[m#13, Message.invResult1] := exhaleMask#_282[m#13, Message.invResult1][perm$R := exhaleMask#_282[m#13, Message.invResult1][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_282);
    } else {
    }
    if (Heap[m#13, Message.type] == 3) {
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. The permission at 652.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 652.16 for Message.invResult2."} (Fractions(100) <= exhaleMask#_282[m#13, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_282[m#13, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_282[m#13, Message.invResult2][perm$N]));
      exhaleMask#_282[m#13, Message.invResult2] := exhaleMask#_282[m#13, Message.invResult2][perm$R := exhaleMask#_282[m#13, Message.invResult2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_282);
    } else {
    }
    if (Heap[m#13, Message.type] == 4) {
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. The permission at 653.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  202.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 653.16 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_282[m#13, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_282[m#13, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_282[m#13, Message.invFinalResult][perm$N]));
      exhaleMask#_282[m#13, Message.invFinalResult] := exhaleMask#_282[m#13, Message.invFinalResult][perm$R := exhaleMask#_282[m#13, Message.invFinalResult][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_282);
    } else {
    }
    Mask := exhaleMask#_282;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_288;
    assume IsGoodInhaleState(inhaleHeap#_288, Heap, Mask);
    assume m#13 != null;
    Heap[m#13, Message.inv] := inhaleHeap#_288[m#13, Message.inv];
    assume wf(Heap, Mask);
    assume inhaleHeap#_288[m#13, Message.inv] == Heap;
    assume Fractions(100) > 0;
    Mask[m#13, Message.inv] := Mask[m#13, Message.inv][perm$R := Mask[m#13, Message.inv][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_288[m#13, Message.inv]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_288, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[m#13, Message.inv] := Heap;
    assume wf(Heap, Mask);
    // update field state
    assert {:msg "  203.4: Location might not be writable"} CanWrite(Mask, this, FactorialContChannelExpEP.state);
    Heap[this, FactorialContChannelExpEP.state] := 1;
    assume wf(Heap, Mask);
    // local var c
    // assigment to c
    assert {:msg "  204.19: Receiver might be null."} true ==> (this != null);
    assert {:msg "  204.19: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
    assert {:msg "  204.19: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
    assert {:msg "  204.19: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp);
    assert {:msg "  204.19: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null);
    assert {:msg "  204.19: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
    c#15 := Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
    // fold
    assume (0 < foldK#_289) && ((1000 * foldK#_289) < Fractions(1)) && ((1000 * foldK#_289) < methodK#_273);
    assert {:msg "  205.4: The target of the fold statement might be null."} this != null;
    // begin exhale (fold)
    exhaleMask#_290 := Mask;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 187.38 might not evaluate to true."} !(Heap[this, FactorialContChannelExpEP.ch] == null);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.24 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.59 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 189.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 190.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.5 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_290[this, FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_290[this, FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_290[this, FactorialContChannelExpEP.expch][perm$N]));
    exhaleMask#_290[this, FactorialContChannelExpEP.expch] := exhaleMask#_290[this, FactorialContChannelExpEP.expch][perm$R := exhaleMask#_290[this, FactorialContChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.23 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.23 for FactorialContChannelExpEP.ch."} (monitorK <= exhaleMask#_290[this, FactorialContChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_290[this, FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_290[this, FactorialContChannelExpEP.ch][perm$N]));
    exhaleMask#_290[this, FactorialContChannelExpEP.ch] := exhaleMask#_290[this, FactorialContChannelExpEP.ch][perm$R := exhaleMask#_290[this, FactorialContChannelExpEP.ch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.5 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.5 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$N]));
    exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.40 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.40 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$N]));
    exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := exhaleMask#_290[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 189.5 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 189.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
    exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 190.5 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 190.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
    exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_290[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.5 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.5 for mu."} (monitorK <= exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$N]));
    exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.33 might not be positive."} monitorK > 0;
    assert {:msg "  205.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.33 for mu."} (monitorK <= exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$N]));
    exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := exhaleMask#_290[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_290);
    Mask := exhaleMask#_290;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_299;
    assume IsGoodInhaleState(inhaleHeap#_299, Heap, Mask);
    assume this != null;
    Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_299[this, FactorialContChannelExpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_299[this, FactorialContChannelExpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_299[this, FactorialContChannelExpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_299, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[this, FactorialContChannelExpEP.valid] := Heap;
    assume wf(Heap, Mask);
    // send
    assert {:msg "  206.9: The channel might be null."} c#15 != null;
    this#110 := c#15;
    msg#111 := m#13;
    Credits[c#15] := Credits[c#15] + 1;
    // begin exhale (channel where clause)
    exhaleMask#_300 := Mask;
    assert {:msg "  206.4: The where clause at 6.36 might not hold. The expression at 6.36 might not evaluate to true."} !(msg#111 == null);
    assert {:msg "  206.4: The where clause at 6.36 might not hold. The permission at 6.50 might not be positive."} channelK > 0;
    assert {:msg "  206.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.50 for Message.type."} (channelK <= exhaleMask#_300[msg#111, Message.type][perm$R]) && ((channelK == exhaleMask#_300[msg#111, Message.type][perm$R]) ==> (0 <= exhaleMask#_300[msg#111, Message.type][perm$N]));
    exhaleMask#_300[msg#111, Message.type] := exhaleMask#_300[msg#111, Message.type][perm$R := exhaleMask#_300[msg#111, Message.type][perm$R] - channelK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_300);
    assert {:msg "  206.4: The where clause at 6.36 might not hold. The permission at 6.66 might not be positive."} Fractions(100) > 0;
    assert {:msg "  206.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.66 for Message.inv."} (Fractions(100) <= exhaleMask#_300[msg#111, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_300[msg#111, Message.inv][perm$R]) ==> (0 <= exhaleMask#_300[msg#111, Message.inv][perm$N]));
    exhaleMask#_300[msg#111, Message.inv] := exhaleMask#_300[msg#111, Message.inv][perm$R := exhaleMask#_300[msg#111, Message.inv][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_300);
    Mask := exhaleMask#_300;
    assume wf(Heap, Mask);
    // end exhale
  } else {
    // assert
    Heap#_306 := Heap;
    Mask#_307 := Mask;
    Credits#_308 := Credits;
    // begin exhale (assert)
    exhaleMask#_309 := Mask#_307;
    assert {:msg "  209.4: Assertion might not hold. The expression at 209.11 might not evaluate to true."} false;
    Mask#_307 := exhaleMask#_309;
    assume wf(Heap#_306, Mask#_307);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_310 := Mask;
  if (old(Heap)[this, FactorialContChannelExpEP.state] == 0) {
    assert {:msg "  194.2: The postcondition at 198.10 might not hold. The expression at 198.52 might not evaluate to true."} Heap[this, FactorialContChannelExpEP.state] == 1;
  } else {
  }
  assert {:msg "  194.2: The postcondition at 198.10 might not hold. The permission at 198.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  194.2: The postcondition at 198.10 might not hold. Insufficient fraction at 198.10 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_310[this, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_310[this, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_310[this, FactorialContChannelExpEP.state][perm$N]));
  exhaleMask#_310[this, FactorialContChannelExpEP.state] := exhaleMask#_310[this, FactorialContChannelExpEP.state][perm$R := exhaleMask#_310[this, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_310);
  assert {:msg "  194.2: The postcondition at 198.10 might not hold. The permission at 198.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  194.2: The postcondition at 198.10 might not hold. Insufficient fraction at 198.24 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_310[this, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_310[this, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_310[this, FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_310[this, FactorialContChannelExpEP.valid] := exhaleMask#_310[this, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_310[this, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_310);
  if (old(Heap)[this, FactorialContChannelExpEP.state] == 0) {
  } else {
  }
  Mask := exhaleMask#_310;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  194.2: Method might lock/unlock more than allowed."} (forall lk#_313: ref :: {Heap[lk#_313, held]} {Heap[lk#_313, rdheld]} (((0 < Heap[lk#_313, held]) == (0 < old(Heap)[lk#_313, held])) && (Heap[lk#_313, rdheld] == old(Heap)[lk#_313, rdheld])) || false);
  assert {:msg "  194.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelExpEP.sendResult2$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t), m#16: ref where (m#16 == null) || (dtype(m#16) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_314: int;
  var inhaleHeap#_315: HeapType;
  var inhaleHeap#_316: HeapType;
  assume (0 < methodK#_314) && ((1000 * methodK#_314) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_315;
  assume IsGoodInhaleState(inhaleHeap#_315, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_315[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assume m#16 != null;
  Heap[m#16, Message.type] := inhaleHeap#_315[m#16, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#16, Message.type] := Mask[m#16, Message.type][perm$R := Mask[m#16, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[m#16, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assume m#16 != null;
  Heap[m#16, Message.type] := inhaleHeap#_315[m#16, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#16, Message.type] := Mask[m#16, Message.type][perm$R := Mask[m#16, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[m#16, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assert {:msg "  214.63: Receiver might be null."} true ==> (m#16 != null);
  assert {:msg "  214.63: Location might not be readable."} true ==> CanRead(Mask, m#16, Message.type);
  assume Heap[m#16, Message.type] == 3;
  assert {:msg "  214.76: Receiver might be null."} m#16 != null;
  assume m#16 != null;
  Heap[m#16, Message.invResult2] := inhaleHeap#_315[m#16, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_315[m#16, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[m#16, Message.invResult2] := Mask[m#16, Message.invResult2][perm$R := Mask[m#16, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[m#16, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assert {:msg "  215.12: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_315[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_315[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_315[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_315, Mask);
  assert {:msg "  216.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  216.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
  assume Heap[this, FactorialContChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_316;
  assume IsGoodInhaleState(inhaleHeap#_316, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_316[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_316[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_316, Mask);
  assert {:msg "  217.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_316[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_316[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_316[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_316, Mask);
  assert {:msg "  217.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  217.38: Location might not be readable."} true ==> CanRead(old(Mask), this, FactorialContChannelExpEP.state);
  if (old(Heap)[this, FactorialContChannelExpEP.state] == 0) {
    assert {:msg "  217.52: Receiver might be null."} true ==> (this != null);
    assert {:msg "  217.52: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
    assume Heap[this, FactorialContChannelExpEP.state] == 1;
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelExpEP.sendResult2(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t), m#16: ref where (m#16 == null) || (dtype(m#16) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_314: int;
  var inhaleHeap#_317: HeapType;
  var unfoldK#_318: int;
  var exhaleMask#_319: MaskType;
  var inhaleHeap#_321: HeapType;
  var foldK#_322: int;
  var exhaleMask#_323: MaskType;
  var inhaleHeap#_329: HeapType;
  var c#18: ref where (c#18 == null) || (dtype(c#18) == Channel#t);
  var foldK#_330: int;
  var exhaleMask#_331: MaskType;
  var inhaleHeap#_340: HeapType;
  var this#112: ref where (this#112 == null) || (dtype(this#112) == Channel#t);
  var msg#113: ref where (msg#113 == null) || (dtype(msg#113) == Message#t);
  var exhaleMask#_341: MaskType;
  var Heap#_347: HeapType;
  var Mask#_348: MaskType;
  var Credits#_349: CreditsType;
  var exhaleMask#_350: MaskType;
  var exhaleMask#_351: MaskType;
  assume (0 < methodK#_314) && ((1000 * methodK#_314) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_317;
  assume IsGoodInhaleState(inhaleHeap#_317, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_317[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_317[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_317, Mask);
  assume m#16 != null;
  Heap[m#16, Message.type] := inhaleHeap#_317[m#16, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#16, Message.type] := Mask[m#16, Message.type][perm$R := Mask[m#16, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_317[m#16, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_317, Mask);
  assume m#16 != null;
  Heap[m#16, Message.type] := inhaleHeap#_317[m#16, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#16, Message.type] := Mask[m#16, Message.type][perm$R := Mask[m#16, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_317[m#16, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_317, Mask);
  assume Heap[m#16, Message.type] == 3;
  assume m#16 != null;
  Heap[m#16, Message.invResult2] := inhaleHeap#_317[m#16, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_317[m#16, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[m#16, Message.invResult2] := Mask[m#16, Message.invResult2][perm$R := Mask[m#16, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_317[m#16, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_317, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_317[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_317[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_317[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_317, Mask);
  assume Heap[this, FactorialContChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_318) && (unfoldK#_318 < Fractions(1)) && ((1000 * unfoldK#_318) < methodK#_314);
  assert {:msg "  219.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_319 := Mask;
  assert {:msg "  219.3: unfold might fail because the predicate FactorialContChannelExpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  219.3: unfold might fail because the predicate FactorialContChannelExpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_319[this, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_319[this, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_319[this, FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_319[this, FactorialContChannelExpEP.valid] := exhaleMask#_319[this, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_319[this, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_319);
  Mask := exhaleMask#_319;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_321 := Heap[this, FactorialContChannelExpEP.valid];
  assume IsGoodInhaleState(inhaleHeap#_321, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.expch] := inhaleHeap#_321[this, FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelExpEP.expch] == null) || (dtype(Heap[this, FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelExpEP.expch] := Mask[this, FactorialContChannelExpEP.expch][perm$R := Mask[this, FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[this, FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.ch] := inhaleHeap#_321[this, FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelExpEP.ch] == null) || (dtype(Heap[this, FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelExpEP.ch] := Mask[this, FactorialContChannelExpEP.ch][perm$R := Mask[this, FactorialContChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[this, FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume !(Heap[this, FactorialContChannelExpEP.ch] == null);
  assume Heap[this, FactorialContChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := inhaleHeap#_321[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
  assume Heap[this, FactorialContChannelExpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := inhaleHeap#_321[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := Mask[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
  assume Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_321[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assume Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_321[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assume Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := inhaleHeap#_321[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := inhaleHeap#_321[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_321[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_321, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  220.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  220.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
  if (Heap[this, FactorialContChannelExpEP.state] == 0) {
    // fold
    assume (0 < foldK#_322) && ((1000 * foldK#_322) < Fractions(1)) && ((1000 * foldK#_322) < methodK#_314);
    assert {:msg "  221.4: The target of the fold statement might be null."} m#16 != null;
    // begin exhale (fold)
    exhaleMask#_323 := Mask;
    if (Heap[m#16, Message.type] == 1) {
    } else {
    }
    if (Heap[m#16, Message.type] == 2) {
    } else {
    }
    if (Heap[m#16, Message.type] == 3) {
    } else {
    }
    if (Heap[m#16, Message.type] == 4) {
    } else {
    }
    assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. The permission at 649.3 might not be positive."} predicateK > 0;
    assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 649.3 for Message.type."} (predicateK <= exhaleMask#_323[m#16, Message.type][perm$R]) && ((predicateK == exhaleMask#_323[m#16, Message.type][perm$R]) ==> (0 <= exhaleMask#_323[m#16, Message.type][perm$N]));
    exhaleMask#_323[m#16, Message.type] := exhaleMask#_323[m#16, Message.type][perm$R := exhaleMask#_323[m#16, Message.type][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_323);
    if (Heap[m#16, Message.type] == 1) {
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. The permission at 650.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 650.16 for Message.invValue."} (Fractions(100) <= exhaleMask#_323[m#16, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_323[m#16, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_323[m#16, Message.invValue][perm$N]));
      exhaleMask#_323[m#16, Message.invValue] := exhaleMask#_323[m#16, Message.invValue][perm$R := exhaleMask#_323[m#16, Message.invValue][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_323);
    } else {
    }
    if (Heap[m#16, Message.type] == 2) {
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. The permission at 651.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 651.16 for Message.invResult1."} (Fractions(100) <= exhaleMask#_323[m#16, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_323[m#16, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_323[m#16, Message.invResult1][perm$N]));
      exhaleMask#_323[m#16, Message.invResult1] := exhaleMask#_323[m#16, Message.invResult1][perm$R := exhaleMask#_323[m#16, Message.invResult1][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_323);
    } else {
    }
    if (Heap[m#16, Message.type] == 3) {
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. The permission at 652.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 652.16 for Message.invResult2."} (Fractions(100) <= exhaleMask#_323[m#16, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_323[m#16, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_323[m#16, Message.invResult2][perm$N]));
      exhaleMask#_323[m#16, Message.invResult2] := exhaleMask#_323[m#16, Message.invResult2][perm$R := exhaleMask#_323[m#16, Message.invResult2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_323);
    } else {
    }
    if (Heap[m#16, Message.type] == 4) {
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. The permission at 653.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  221.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 653.16 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_323[m#16, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_323[m#16, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_323[m#16, Message.invFinalResult][perm$N]));
      exhaleMask#_323[m#16, Message.invFinalResult] := exhaleMask#_323[m#16, Message.invFinalResult][perm$R := exhaleMask#_323[m#16, Message.invFinalResult][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_323);
    } else {
    }
    Mask := exhaleMask#_323;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_329;
    assume IsGoodInhaleState(inhaleHeap#_329, Heap, Mask);
    assume m#16 != null;
    Heap[m#16, Message.inv] := inhaleHeap#_329[m#16, Message.inv];
    assume wf(Heap, Mask);
    assume inhaleHeap#_329[m#16, Message.inv] == Heap;
    assume Fractions(100) > 0;
    Mask[m#16, Message.inv] := Mask[m#16, Message.inv][perm$R := Mask[m#16, Message.inv][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_329[m#16, Message.inv]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_329, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[m#16, Message.inv] := Heap;
    assume wf(Heap, Mask);
    // update field state
    assert {:msg "  222.4: Location might not be writable"} CanWrite(Mask, this, FactorialContChannelExpEP.state);
    Heap[this, FactorialContChannelExpEP.state] := 1;
    assume wf(Heap, Mask);
    // local var c
    // assigment to c
    assert {:msg "  223.19: Receiver might be null."} true ==> (this != null);
    assert {:msg "  223.19: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.ch);
    assert {:msg "  223.19: Receiver might be null."} true ==> (Heap[this, FactorialContChannelExpEP.ch] != null);
    assert {:msg "  223.19: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp);
    assert {:msg "  223.19: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] != null);
    assert {:msg "  223.19: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
    c#18 := Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
    // fold
    assume (0 < foldK#_330) && ((1000 * foldK#_330) < Fractions(1)) && ((1000 * foldK#_330) < methodK#_314);
    assert {:msg "  224.4: The target of the fold statement might be null."} this != null;
    // begin exhale (fold)
    exhaleMask#_331 := Mask;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 187.38 might not evaluate to true."} !(Heap[this, FactorialContChannelExpEP.ch] == null);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.24 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.59 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 189.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 190.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.5 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_331[this, FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_331[this, FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_331[this, FactorialContChannelExpEP.expch][perm$N]));
    exhaleMask#_331[this, FactorialContChannelExpEP.expch] := exhaleMask#_331[this, FactorialContChannelExpEP.expch][perm$R := exhaleMask#_331[this, FactorialContChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.23 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.23 for FactorialContChannelExpEP.ch."} (monitorK <= exhaleMask#_331[this, FactorialContChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_331[this, FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_331[this, FactorialContChannelExpEP.ch][perm$N]));
    exhaleMask#_331[this, FactorialContChannelExpEP.ch] := exhaleMask#_331[this, FactorialContChannelExpEP.ch][perm$R := exhaleMask#_331[this, FactorialContChannelExpEP.ch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.5 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.5 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$N]));
    exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp] := exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.40 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.40 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$N]));
    exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp] := exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := exhaleMask#_331[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 189.5 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 189.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
    exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 190.5 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 190.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
    exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_331[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.5 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.5 for mu."} (monitorK <= exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$N]));
    exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.33 might not be positive."} monitorK > 0;
    assert {:msg "  224.4: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.33 for mu."} (monitorK <= exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$N]));
    exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := exhaleMask#_331[Heap[Heap[Heap[this, FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_331);
    Mask := exhaleMask#_331;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_340;
    assume IsGoodInhaleState(inhaleHeap#_340, Heap, Mask);
    assume this != null;
    Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_340[this, FactorialContChannelExpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_340[this, FactorialContChannelExpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_340[this, FactorialContChannelExpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_340, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[this, FactorialContChannelExpEP.valid] := Heap;
    assume wf(Heap, Mask);
    // send
    assert {:msg "  225.9: The channel might be null."} c#18 != null;
    this#112 := c#18;
    msg#113 := m#16;
    Credits[c#18] := Credits[c#18] + 1;
    // begin exhale (channel where clause)
    exhaleMask#_341 := Mask;
    assert {:msg "  225.4: The where clause at 6.36 might not hold. The expression at 6.36 might not evaluate to true."} !(msg#113 == null);
    assert {:msg "  225.4: The where clause at 6.36 might not hold. The permission at 6.50 might not be positive."} channelK > 0;
    assert {:msg "  225.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.50 for Message.type."} (channelK <= exhaleMask#_341[msg#113, Message.type][perm$R]) && ((channelK == exhaleMask#_341[msg#113, Message.type][perm$R]) ==> (0 <= exhaleMask#_341[msg#113, Message.type][perm$N]));
    exhaleMask#_341[msg#113, Message.type] := exhaleMask#_341[msg#113, Message.type][perm$R := exhaleMask#_341[msg#113, Message.type][perm$R] - channelK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_341);
    assert {:msg "  225.4: The where clause at 6.36 might not hold. The permission at 6.66 might not be positive."} Fractions(100) > 0;
    assert {:msg "  225.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.66 for Message.inv."} (Fractions(100) <= exhaleMask#_341[msg#113, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_341[msg#113, Message.inv][perm$R]) ==> (0 <= exhaleMask#_341[msg#113, Message.inv][perm$N]));
    exhaleMask#_341[msg#113, Message.inv] := exhaleMask#_341[msg#113, Message.inv][perm$R := exhaleMask#_341[msg#113, Message.inv][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_341);
    Mask := exhaleMask#_341;
    assume wf(Heap, Mask);
    // end exhale
  } else {
    // assert
    Heap#_347 := Heap;
    Mask#_348 := Mask;
    Credits#_349 := Credits;
    // begin exhale (assert)
    exhaleMask#_350 := Mask#_348;
    assert {:msg "  228.4: Assertion might not hold. The expression at 228.11 might not evaluate to true."} false;
    Mask#_348 := exhaleMask#_350;
    assume wf(Heap#_347, Mask#_348);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_351 := Mask;
  if (old(Heap)[this, FactorialContChannelExpEP.state] == 0) {
    assert {:msg "  213.2: The postcondition at 217.10 might not hold. The expression at 217.52 might not evaluate to true."} Heap[this, FactorialContChannelExpEP.state] == 1;
  } else {
  }
  assert {:msg "  213.2: The postcondition at 217.10 might not hold. The permission at 217.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  213.2: The postcondition at 217.10 might not hold. Insufficient fraction at 217.10 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_351[this, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_351[this, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_351[this, FactorialContChannelExpEP.state][perm$N]));
  exhaleMask#_351[this, FactorialContChannelExpEP.state] := exhaleMask#_351[this, FactorialContChannelExpEP.state][perm$R := exhaleMask#_351[this, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_351);
  assert {:msg "  213.2: The postcondition at 217.10 might not hold. The permission at 217.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  213.2: The postcondition at 217.10 might not hold. Insufficient fraction at 217.24 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_351[this, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_351[this, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_351[this, FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_351[this, FactorialContChannelExpEP.valid] := exhaleMask#_351[this, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_351[this, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_351);
  if (old(Heap)[this, FactorialContChannelExpEP.state] == 0) {
  } else {
  }
  Mask := exhaleMask#_351;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  213.2: Method might lock/unlock more than allowed."} (forall lk#_354: ref :: {Heap[lk#_354, held]} {Heap[lk#_354, rdheld]} (((0 < Heap[lk#_354, held]) == (0 < old(Heap)[lk#_354, held])) && (Heap[lk#_354, rdheld] == old(Heap)[lk#_354, rdheld])) || false);
  assert {:msg "  213.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelExpEP.receiveResult1$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t)) returns (m#19: ref where (m#19 == null) || (dtype(m#19) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_355: int;
  var inhaleHeap#_356: HeapType;
  assume (0 < methodK#_355) && ((1000 * methodK#_355) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_356;
  assume IsGoodInhaleState(inhaleHeap#_356, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FactorialContChannelExpEP.receiveResult1(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t)) returns (m#19: ref where (m#19 == null) || (dtype(m#19) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_355: int;
  var inhaleHeap#_357: HeapType;
  var Heap#_361: HeapType;
  var Mask#_362: MaskType;
  var Credits#_363: CreditsType;
  var exhaleMask#_364: MaskType;
  assume (0 < methodK#_355) && ((1000 * methodK#_355) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_357;
  assume IsGoodInhaleState(inhaleHeap#_357, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_361 := Heap;
  Mask#_362 := Mask;
  Credits#_363 := Credits;
  // begin exhale (assert)
  exhaleMask#_364 := Mask#_362;
  assert {:msg "  234.3: Assertion might not hold. The expression at 234.10 might not evaluate to true."} false;
  Mask#_362 := exhaleMask#_364;
  assume wf(Heap#_361, Mask#_362);
  // end exhale
  assert {:msg "  231.2: Method might lock/unlock more than allowed."} (forall lk#_365: ref :: {Heap[lk#_365, held]} {Heap[lk#_365, rdheld]} (((0 < Heap[lk#_365, held]) == (0 < old(Heap)[lk#_365, held])) && (Heap[lk#_365, rdheld] == old(Heap)[lk#_365, rdheld])) || false);
  assert {:msg "  231.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelExpEP.receiveResult2$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t)) returns (m#20: ref where (m#20 == null) || (dtype(m#20) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_366: int;
  var inhaleHeap#_367: HeapType;
  assume (0 < methodK#_366) && ((1000 * methodK#_366) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_367;
  assume IsGoodInhaleState(inhaleHeap#_367, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FactorialContChannelExpEP.receiveResult2(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t)) returns (m#20: ref where (m#20 == null) || (dtype(m#20) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_366: int;
  var inhaleHeap#_368: HeapType;
  var Heap#_372: HeapType;
  var Mask#_373: MaskType;
  var Credits#_374: CreditsType;
  var exhaleMask#_375: MaskType;
  assume (0 < methodK#_366) && ((1000 * methodK#_366) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_368;
  assume IsGoodInhaleState(inhaleHeap#_368, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_372 := Heap;
  Mask#_373 := Mask;
  Credits#_374 := Credits;
  // begin exhale (assert)
  exhaleMask#_375 := Mask#_373;
  assert {:msg "  239.3: Assertion might not hold. The expression at 239.10 might not evaluate to true."} false;
  Mask#_373 := exhaleMask#_375;
  assume wf(Heap#_372, Mask#_373);
  // end exhale
  assert {:msg "  236.2: Method might lock/unlock more than allowed."} (forall lk#_376: ref :: {Heap[lk#_376, held]} {Heap[lk#_376, rdheld]} (((0 < Heap[lk#_376, held]) == (0 < old(Heap)[lk#_376, held])) && (Heap[lk#_376, rdheld] == old(Heap)[lk#_376, rdheld])) || false);
  assert {:msg "  236.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelExpEP.fail$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t), m#21: ref where (m#21 == null) || (dtype(m#21) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_377: int;
  var inhaleHeap#_378: HeapType;
  var inhaleHeap#_379: HeapType;
  assume (0 < methodK#_377) && ((1000 * methodK#_377) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_378;
  assume IsGoodInhaleState(inhaleHeap#_378, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_378[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_378[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_378, Mask);
  assume m#21 != null;
  Heap[m#21, Message.type] := inhaleHeap#_378[m#21, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#21, Message.type] := Mask[m#21, Message.type][perm$R := Mask[m#21, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_378[m#21, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_378, Mask);
  assert {:msg "  243.46: Receiver might be null."} true ==> (m#21 != null);
  assert {:msg "  243.46: Location might not be readable."} true ==> CanRead(Mask, m#21, Message.type);
  assert {:msg "  243.59: Receiver might be null."} true && (!(Heap[m#21, Message.type] == 2)) ==> (m#21 != null);
  assert {:msg "  243.59: Location might not be readable."} true && (!(Heap[m#21, Message.type] == 2)) ==> CanRead(Mask, m#21, Message.type);
  assume (Heap[m#21, Message.type] == 2) || (Heap[m#21, Message.type] == 3);
  assert {:msg "  244.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_378[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_378[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_378[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_378, Mask);
  assert {:msg "  245.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  245.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
  assume !(Heap[this, FactorialContChannelExpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_379;
  assume IsGoodInhaleState(inhaleHeap#_379, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_379[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_379[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_379, Mask);
  assert {:msg "  246.25: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_379[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_379[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_379[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_379, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelExpEP.fail(this: ref where (this == null) || (dtype(this) == FactorialContChannelExpEP#t), m#21: ref where (m#21 == null) || (dtype(m#21) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_377: int;
  var inhaleHeap#_380: HeapType;
  var Heap#_384: HeapType;
  var Mask#_385: MaskType;
  var Credits#_386: CreditsType;
  var exhaleMask#_387: MaskType;
  var exhaleMask#_388: MaskType;
  assume (0 < methodK#_377) && ((1000 * methodK#_377) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_380;
  assume IsGoodInhaleState(inhaleHeap#_380, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.state] := inhaleHeap#_380[this, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.state] := Mask[this, FactorialContChannelExpEP.state][perm$R := Mask[this, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_380[this, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_380, Mask);
  assume m#21 != null;
  Heap[m#21, Message.type] := inhaleHeap#_380[m#21, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#21, Message.type] := Mask[m#21, Message.type][perm$R := Mask[m#21, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_380[m#21, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_380, Mask);
  assume (Heap[m#21, Message.type] == 2) || (Heap[m#21, Message.type] == 3);
  assume this != null;
  Heap[this, FactorialContChannelExpEP.valid] := inhaleHeap#_380[this, FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_380[this, FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelExpEP.valid] := Mask[this, FactorialContChannelExpEP.valid][perm$R := Mask[this, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_380[this, FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_380, Mask);
  assume !(Heap[this, FactorialContChannelExpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  248.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  248.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelExpEP.state);
  if (Heap[this, FactorialContChannelExpEP.state] == 0) {
    // assert
    Heap#_384 := Heap;
    Mask#_385 := Mask;
    Credits#_386 := Credits;
    // begin exhale (assert)
    exhaleMask#_387 := Mask#_385;
    assert {:msg "  249.4: Assertion might not hold. The expression at 249.11 might not evaluate to true."} false;
    Mask#_385 := exhaleMask#_387;
    assume wf(Heap#_384, Mask#_385);
    // end exhale
  } else {
    // assume
    assume false;
  }
  // begin exhale (postcondition)
  exhaleMask#_388 := Mask;
  assert {:msg "  242.2: The postcondition at 246.11 might not hold. The permission at 246.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  242.2: The postcondition at 246.11 might not hold. Insufficient fraction at 246.11 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_388[this, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_388[this, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_388[this, FactorialContChannelExpEP.state][perm$N]));
  exhaleMask#_388[this, FactorialContChannelExpEP.state] := exhaleMask#_388[this, FactorialContChannelExpEP.state][perm$R := exhaleMask#_388[this, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_388);
  assert {:msg "  242.2: The postcondition at 246.11 might not hold. The permission at 246.25 might not be positive."} Fractions(100) > 0;
  assert {:msg "  242.2: The postcondition at 246.11 might not hold. Insufficient fraction at 246.25 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_388[this, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_388[this, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_388[this, FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_388[this, FactorialContChannelExpEP.valid] := exhaleMask#_388[this, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_388[this, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_388);
  Mask := exhaleMask#_388;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  242.2: Method might lock/unlock more than allowed."} (forall lk#_391: ref :: {Heap[lk#_391, held]} {Heap[lk#_391, rdheld]} (((0 < Heap[lk#_391, held]) == (0 < old(Heap)[lk#_391, held])) && (Heap[lk#_391, rdheld] == old(Heap)[lk#_391, rdheld])) || false);
  assert {:msg "  242.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialContChannelImpEP#t: TypeName;
procedure FactorialContChannelImpEP$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_399: int;
  var h0#_392: HeapType;
  var m0#_393: MaskType;
  var c0#_394: CreditsType;
  var h1#_395: HeapType;
  var m1#_396: MaskType;
  var c1#_397: CreditsType;
  var lk#_398: ref;
  assume (0 < methodK#_399) && ((1000 * methodK#_399) < Fractions(1));
  assume wf(h0#_392, m0#_393);
  assume wf(h1#_395, m1#_396);
  m1#_396 := ZeroMask;
  c1#_397 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  256.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialContChannelImpEP.state: Field (int);
axiom NonPredicateField(FactorialContChannelImpEP.state);
const unique FactorialContChannelImpEP.ch: Field (ref);
axiom NonPredicateField(FactorialContChannelImpEP.ch);
const unique FactorialContChannelImpEP.impch: Field (ref);
axiom NonPredicateField(FactorialContChannelImpEP.impch);
const unique FactorialContChannelImpEP.valid: Field (HeapType);
axiom PredicateField(FactorialContChannelImpEP.valid);
procedure FactorialContChannelImpEP.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_400: int;
  var inhaleHeap#_401: HeapType;
  assume (0 < predicateK#_400) && ((1000 * predicateK#_400) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_401;
  assume IsGoodInhaleState(inhaleHeap#_401, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.impch] := inhaleHeap#_401[this, FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelImpEP.impch] == null) || (dtype(Heap[this, FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelImpEP.impch] := Mask[this, FactorialContChannelImpEP.impch][perm$R := Mask[this, FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[this, FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.ch] := inhaleHeap#_401[this, FactorialContChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannelImpEP.ch] == null) || (dtype(Heap[this, FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannelImpEP.ch] := Mask[this, FactorialContChannelImpEP.ch][perm$R := Mask[this, FactorialContChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[this, FactorialContChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assert {:msg "  262.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  262.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assume !(Heap[this, FactorialContChannelImpEP.ch] == null);
  assert {:msg "  263.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  263.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assume Heap[this, FactorialContChannelImpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] := inhaleHeap#_401[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] := Mask[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assert {:msg "  263.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  263.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  263.24: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  263.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp);
  assume !(Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] == null);
  assert {:msg "  263.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  263.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assume Heap[this, FactorialContChannelImpEP.ch] != null;
  Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] := inhaleHeap#_401[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] := Mask[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R := Mask[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assert {:msg "  263.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  263.59: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  263.59: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  263.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp);
  assume !(Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] == null);
  assert {:msg "  264.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  264.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  264.8: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp);
  assume Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_401[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assert {:msg "  264.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  264.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  264.30: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  264.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp);
  assert {:msg "  264.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] != null);
  assert {:msg "  264.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  265.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  265.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  265.8: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp);
  assume Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_401[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assert {:msg "  265.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  265.30: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  265.30: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  265.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp);
  assert {:msg "  265.30: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] != null);
  assert {:msg "  265.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  266.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  266.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  266.8: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := inhaleHeap#_401[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assert {:msg "  266.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  266.36: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.ch);
  assert {:msg "  266.36: Receiver might be null."} true ==> (Heap[this, FactorialContChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch);
  assume Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := inhaleHeap#_401[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_401[Heap[Heap[Heap[this, FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_401, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelImpEP.sendResult1$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), m#22: ref where (m#22 == null) || (dtype(m#22) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_402: int;
  var inhaleHeap#_403: HeapType;
  var inhaleHeap#_404: HeapType;
  assume (0 < methodK#_402) && ((1000 * methodK#_402) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_403;
  assume IsGoodInhaleState(inhaleHeap#_403, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_403[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_403[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_403, Mask);
  assume m#22 != null;
  Heap[m#22, Message.type] := inhaleHeap#_403[m#22, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#22, Message.type] := Mask[m#22, Message.type][perm$R := Mask[m#22, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_403[m#22, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_403, Mask);
  assert {:msg "  270.45: Receiver might be null."} true ==> (m#22 != null);
  assert {:msg "  270.45: Location might not be readable."} true ==> CanRead(Mask, m#22, Message.type);
  assume Heap[m#22, Message.type] == 2;
  assert {:msg "  270.58: Receiver might be null."} m#22 != null;
  assume m#22 != null;
  Heap[m#22, Message.invResult1] := inhaleHeap#_403[m#22, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_403[m#22, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[m#22, Message.invResult1] := Mask[m#22, Message.invResult1][perm$R := Mask[m#22, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_403[m#22, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_403, Mask);
  assert {:msg "  271.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_403[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_403[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_403[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_403, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_404;
  assume IsGoodInhaleState(inhaleHeap#_404, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_404[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_404[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_404, Mask);
  assert {:msg "  273.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_404[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_404[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_404[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_404, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelImpEP.sendResult1(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), m#22: ref where (m#22 == null) || (dtype(m#22) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_402: int;
  var inhaleHeap#_405: HeapType;
  var Heap#_409: HeapType;
  var Mask#_410: MaskType;
  var Credits#_411: CreditsType;
  var exhaleMask#_412: MaskType;
  var exhaleMask#_413: MaskType;
  assume (0 < methodK#_402) && ((1000 * methodK#_402) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_405;
  assume IsGoodInhaleState(inhaleHeap#_405, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_405[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_405[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_405, Mask);
  assume m#22 != null;
  Heap[m#22, Message.type] := inhaleHeap#_405[m#22, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#22, Message.type] := Mask[m#22, Message.type][perm$R := Mask[m#22, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_405[m#22, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_405, Mask);
  assume Heap[m#22, Message.type] == 2;
  assume m#22 != null;
  Heap[m#22, Message.invResult1] := inhaleHeap#_405[m#22, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_405[m#22, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[m#22, Message.invResult1] := Mask[m#22, Message.invResult1][perm$R := Mask[m#22, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_405[m#22, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_405, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_405[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_405[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_405[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_405, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_409 := Heap;
  Mask#_410 := Mask;
  Credits#_411 := Credits;
  // begin exhale (assert)
  exhaleMask#_412 := Mask#_410;
  assert {:msg "  275.3: Assertion might not hold. The expression at 275.10 might not evaluate to true."} false;
  Mask#_410 := exhaleMask#_412;
  assume wf(Heap#_409, Mask#_410);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_413 := Mask;
  assert {:msg "  269.2: The postcondition at 273.10 might not hold. The permission at 273.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  269.2: The postcondition at 273.10 might not hold. Insufficient fraction at 273.10 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_413[this, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_413[this, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_413[this, FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_413[this, FactorialContChannelImpEP.state] := exhaleMask#_413[this, FactorialContChannelImpEP.state][perm$R := exhaleMask#_413[this, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_413);
  assert {:msg "  269.2: The postcondition at 273.10 might not hold. The permission at 273.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  269.2: The postcondition at 273.10 might not hold. Insufficient fraction at 273.24 for FactorialContChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_413[this, FactorialContChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_413[this, FactorialContChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_413[this, FactorialContChannelImpEP.valid][perm$N]));
  exhaleMask#_413[this, FactorialContChannelImpEP.valid] := exhaleMask#_413[this, FactorialContChannelImpEP.valid][perm$R := exhaleMask#_413[this, FactorialContChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_413);
  Mask := exhaleMask#_413;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  269.2: Method might lock/unlock more than allowed."} (forall lk#_416: ref :: {Heap[lk#_416, held]} {Heap[lk#_416, rdheld]} (((0 < Heap[lk#_416, held]) == (0 < old(Heap)[lk#_416, held])) && (Heap[lk#_416, rdheld] == old(Heap)[lk#_416, rdheld])) || false);
  assert {:msg "  269.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelImpEP.sendResult2$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), m#23: ref where (m#23 == null) || (dtype(m#23) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_417: int;
  var inhaleHeap#_418: HeapType;
  var inhaleHeap#_419: HeapType;
  assume (0 < methodK#_417) && ((1000 * methodK#_417) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_418;
  assume IsGoodInhaleState(inhaleHeap#_418, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_418[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_418[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_418, Mask);
  assume m#23 != null;
  Heap[m#23, Message.type] := inhaleHeap#_418[m#23, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#23, Message.type] := Mask[m#23, Message.type][perm$R := Mask[m#23, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_418[m#23, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_418, Mask);
  assert {:msg "  278.45: Receiver might be null."} true ==> (m#23 != null);
  assert {:msg "  278.45: Location might not be readable."} true ==> CanRead(Mask, m#23, Message.type);
  assume Heap[m#23, Message.type] == 3;
  assert {:msg "  278.58: Receiver might be null."} m#23 != null;
  assume m#23 != null;
  Heap[m#23, Message.invResult2] := inhaleHeap#_418[m#23, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_418[m#23, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[m#23, Message.invResult2] := Mask[m#23, Message.invResult2][perm$R := Mask[m#23, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_418[m#23, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_418, Mask);
  assert {:msg "  279.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_418[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_418[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_418[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_418, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_419;
  assume IsGoodInhaleState(inhaleHeap#_419, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_419[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_419[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_419, Mask);
  assert {:msg "  281.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_419[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_419[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_419[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_419, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelImpEP.sendResult2(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), m#23: ref where (m#23 == null) || (dtype(m#23) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_417: int;
  var inhaleHeap#_420: HeapType;
  var Heap#_424: HeapType;
  var Mask#_425: MaskType;
  var Credits#_426: CreditsType;
  var exhaleMask#_427: MaskType;
  var exhaleMask#_428: MaskType;
  assume (0 < methodK#_417) && ((1000 * methodK#_417) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_420;
  assume IsGoodInhaleState(inhaleHeap#_420, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_420[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_420[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_420, Mask);
  assume m#23 != null;
  Heap[m#23, Message.type] := inhaleHeap#_420[m#23, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#23, Message.type] := Mask[m#23, Message.type][perm$R := Mask[m#23, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_420[m#23, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_420, Mask);
  assume Heap[m#23, Message.type] == 3;
  assume m#23 != null;
  Heap[m#23, Message.invResult2] := inhaleHeap#_420[m#23, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_420[m#23, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[m#23, Message.invResult2] := Mask[m#23, Message.invResult2][perm$R := Mask[m#23, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_420[m#23, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_420, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_420[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_420[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_420[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_420, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_424 := Heap;
  Mask#_425 := Mask;
  Credits#_426 := Credits;
  // begin exhale (assert)
  exhaleMask#_427 := Mask#_425;
  assert {:msg "  283.3: Assertion might not hold. The expression at 283.10 might not evaluate to true."} false;
  Mask#_425 := exhaleMask#_427;
  assume wf(Heap#_424, Mask#_425);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_428 := Mask;
  assert {:msg "  277.2: The postcondition at 281.10 might not hold. The permission at 281.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  277.2: The postcondition at 281.10 might not hold. Insufficient fraction at 281.10 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_428[this, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_428[this, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_428[this, FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_428[this, FactorialContChannelImpEP.state] := exhaleMask#_428[this, FactorialContChannelImpEP.state][perm$R := exhaleMask#_428[this, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_428);
  assert {:msg "  277.2: The postcondition at 281.10 might not hold. The permission at 281.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  277.2: The postcondition at 281.10 might not hold. Insufficient fraction at 281.24 for FactorialContChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_428[this, FactorialContChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_428[this, FactorialContChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_428[this, FactorialContChannelImpEP.valid][perm$N]));
  exhaleMask#_428[this, FactorialContChannelImpEP.valid] := exhaleMask#_428[this, FactorialContChannelImpEP.valid][perm$R := exhaleMask#_428[this, FactorialContChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_428);
  Mask := exhaleMask#_428;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  277.2: Method might lock/unlock more than allowed."} (forall lk#_431: ref :: {Heap[lk#_431, held]} {Heap[lk#_431, rdheld]} (((0 < Heap[lk#_431, held]) == (0 < old(Heap)[lk#_431, held])) && (Heap[lk#_431, rdheld] == old(Heap)[lk#_431, rdheld])) || false);
  assert {:msg "  277.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelImpEP.receiveResult1$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), mi#24: ref where (mi#24 == null) || (dtype(mi#24) == Message#t)) returns (mo#25: ref where (mo#25 == null) || (dtype(mo#25) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_432: int;
  var inhaleHeap#_433: HeapType;
  var inhaleHeap#_434: HeapType;
  assume (0 < methodK#_432) && ((1000 * methodK#_432) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_433;
  assume IsGoodInhaleState(inhaleHeap#_433, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_433[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_433[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_433, Mask);
  assume !(mi#24 == null);
  assume mi#24 != null;
  Heap[mi#24, Message.type] := inhaleHeap#_433[mi#24, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#24, Message.type] := Mask[mi#24, Message.type][perm$R := Mask[mi#24, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_433[mi#24, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_433, Mask);
  assert {:msg "  289.57: Receiver might be null."} true ==> (mi#24 != null);
  assert {:msg "  289.57: Location might not be readable."} true ==> CanRead(Mask, mi#24, Message.type);
  assume Heap[mi#24, Message.type] == 2;
  assert {:msg "  289.71: Receiver might be null."} mi#24 != null;
  assume mi#24 != null;
  Heap[mi#24, Message.inv] := inhaleHeap#_433[mi#24, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_433[mi#24, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#24, Message.inv] := Mask[mi#24, Message.inv][perm$R := Mask[mi#24, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_433[mi#24, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_433, Mask);
  assert {:msg "  290.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  290.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  assume Heap[this, FactorialContChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_434;
  assume IsGoodInhaleState(inhaleHeap#_434, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_434[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_434[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_434, Mask);
  assert {:msg "  291.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  291.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  assume Heap[this, FactorialContChannelImpEP.state] == 1;
  assume mo#25 != null;
  Heap[mo#25, Message.type] := inhaleHeap#_434[mo#25, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mo#25, Message.type] := Mask[mo#25, Message.type][perm$R := Mask[mo#25, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_434[mo#25, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_434, Mask);
  assume mo#25 == mi#24;
  assert {:msg "  291.67: Receiver might be null."} true ==> (mo#25 != null);
  assert {:msg "  291.67: Location might not be readable."} true ==> CanRead(Mask, mo#25, Message.type);
  assume Heap[mo#25, Message.type] == 2;
  assert {:msg "  291.81: Receiver might be null."} mo#25 != null;
  assume mo#25 != null;
  Heap[mo#25, Message.invResult1] := inhaleHeap#_434[mo#25, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_434[mo#25, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[mo#25, Message.invResult1] := Mask[mo#25, Message.invResult1][perm$R := Mask[mo#25, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_434[mo#25, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_434, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelImpEP.receiveResult1(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), mi#24: ref where (mi#24 == null) || (dtype(mi#24) == Message#t)) returns (mo#25: ref where (mo#25 == null) || (dtype(mo#25) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_432: int;
  var inhaleHeap#_435: HeapType;
  var unfoldK#_436: int;
  var exhaleMask#_437: MaskType;
  var inhaleHeap#_439: HeapType;
  var Heap#_443: HeapType;
  var Mask#_444: MaskType;
  var Credits#_445: CreditsType;
  var exhaleMask#_446: MaskType;
  var exhaleMask#_447: MaskType;
  assume (0 < methodK#_432) && ((1000 * methodK#_432) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_435;
  assume IsGoodInhaleState(inhaleHeap#_435, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_435[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_435[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_435, Mask);
  assume !(mi#24 == null);
  assume mi#24 != null;
  Heap[mi#24, Message.type] := inhaleHeap#_435[mi#24, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#24, Message.type] := Mask[mi#24, Message.type][perm$R := Mask[mi#24, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_435[mi#24, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_435, Mask);
  assume Heap[mi#24, Message.type] == 2;
  assume mi#24 != null;
  Heap[mi#24, Message.inv] := inhaleHeap#_435[mi#24, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_435[mi#24, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#24, Message.inv] := Mask[mi#24, Message.inv][perm$R := Mask[mi#24, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_435[mi#24, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_435, Mask);
  assume Heap[this, FactorialContChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_436) && (unfoldK#_436 < Fractions(1)) && ((1000 * unfoldK#_436) < methodK#_432);
  assert {:msg "  293.3: The target of the fold statement might be null."} mi#24 != null;
  // begin exhale (unfold)
  exhaleMask#_437 := Mask;
  assert {:msg "  293.3: unfold might fail because the predicate Message.inv does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  293.3: unfold might fail because the predicate Message.inv does not hold. Insufficient fraction at <undefined position> for Message.inv."} (Fractions(100) <= exhaleMask#_437[mi#24, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_437[mi#24, Message.inv][perm$R]) ==> (0 <= exhaleMask#_437[mi#24, Message.inv][perm$N]));
  exhaleMask#_437[mi#24, Message.inv] := exhaleMask#_437[mi#24, Message.inv][perm$R := exhaleMask#_437[mi#24, Message.inv][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_437);
  Mask := exhaleMask#_437;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_439 := Heap[mi#24, Message.inv];
  assume IsGoodInhaleState(inhaleHeap#_439, Heap, Mask);
  assume mi#24 != null;
  Heap[mi#24, Message.type] := inhaleHeap#_439[mi#24, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[mi#24, Message.type] := Mask[mi#24, Message.type][perm$R := Mask[mi#24, Message.type][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_439[mi#24, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_439, Mask);
  if (Heap[mi#24, Message.type] == 1) {
    assume mi#24 != null;
    Heap[mi#24, Message.invValue] := inhaleHeap#_439[mi#24, Message.invValue];
    assume wf(Heap, Mask);
    assume inhaleHeap#_439[mi#24, Message.invValue] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#24, Message.invValue] := Mask[mi#24, Message.invValue][perm$R := Mask[mi#24, Message.invValue][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_439[mi#24, Message.invValue]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_439, Mask);
  } else {
  }
  if (Heap[mi#24, Message.type] == 2) {
    assume mi#24 != null;
    Heap[mi#24, Message.invResult1] := inhaleHeap#_439[mi#24, Message.invResult1];
    assume wf(Heap, Mask);
    assume inhaleHeap#_439[mi#24, Message.invResult1] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#24, Message.invResult1] := Mask[mi#24, Message.invResult1][perm$R := Mask[mi#24, Message.invResult1][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_439[mi#24, Message.invResult1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_439, Mask);
  } else {
  }
  if (Heap[mi#24, Message.type] == 3) {
    assume mi#24 != null;
    Heap[mi#24, Message.invResult2] := inhaleHeap#_439[mi#24, Message.invResult2];
    assume wf(Heap, Mask);
    assume inhaleHeap#_439[mi#24, Message.invResult2] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#24, Message.invResult2] := Mask[mi#24, Message.invResult2][perm$R := Mask[mi#24, Message.invResult2][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_439[mi#24, Message.invResult2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_439, Mask);
  } else {
  }
  if (Heap[mi#24, Message.type] == 4) {
    assume mi#24 != null;
    Heap[mi#24, Message.invFinalResult] := inhaleHeap#_439[mi#24, Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_439[mi#24, Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#24, Message.invFinalResult] := Mask[mi#24, Message.invFinalResult][perm$R := Mask[mi#24, Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_439[mi#24, Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_439, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  294.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  294.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  if (Heap[this, FactorialContChannelImpEP.state] == 0) {
    // update field state
    assert {:msg "  295.4: Location might not be writable"} CanWrite(Mask, this, FactorialContChannelImpEP.state);
    Heap[this, FactorialContChannelImpEP.state] := 1;
    assume wf(Heap, Mask);
  } else {
    // assert
    Heap#_443 := Heap;
    Mask#_444 := Mask;
    Credits#_445 := Credits;
    // begin exhale (assert)
    exhaleMask#_446 := Mask#_444;
    assert {:msg "  299.4: Assertion might not hold. The expression at 299.11 might not evaluate to true."} false;
    Mask#_444 := exhaleMask#_446;
    assume wf(Heap#_443, Mask#_444);
    // end exhale
  }
  // assigment to mo
  mo#25 := mi#24;
  // begin exhale (postcondition)
  exhaleMask#_447 := Mask;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. The expression at 291.24 might not evaluate to true."} Heap[this, FactorialContChannelImpEP.state] == 1;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. The expression at 291.56 might not evaluate to true."} mo#25 == mi#24;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. The expression at 291.67 might not evaluate to true."} Heap[mo#25, Message.type] == 2;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. The permission at 291.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. Insufficient fraction at 291.10 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_447[this, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_447[this, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_447[this, FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_447[this, FactorialContChannelImpEP.state] := exhaleMask#_447[this, FactorialContChannelImpEP.state][perm$R := exhaleMask#_447[this, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_447);
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. The permission at 291.36 might not be positive."} monitorK > 0;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. Insufficient fraction at 291.36 for Message.type."} (monitorK <= exhaleMask#_447[mo#25, Message.type][perm$R]) && ((monitorK == exhaleMask#_447[mo#25, Message.type][perm$R]) ==> (0 <= exhaleMask#_447[mo#25, Message.type][perm$N]));
  exhaleMask#_447[mo#25, Message.type] := exhaleMask#_447[mo#25, Message.type][perm$R := exhaleMask#_447[mo#25, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_447);
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. The permission at 291.81 might not be positive."} Fractions(100) > 0;
  assert {:msg "  288.2: The postcondition at 291.10 might not hold. Insufficient fraction at 291.81 for Message.invResult1."} (Fractions(100) <= exhaleMask#_447[mo#25, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_447[mo#25, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_447[mo#25, Message.invResult1][perm$N]));
  exhaleMask#_447[mo#25, Message.invResult1] := exhaleMask#_447[mo#25, Message.invResult1][perm$R := exhaleMask#_447[mo#25, Message.invResult1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_447);
  Mask := exhaleMask#_447;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  288.2: Method might lock/unlock more than allowed."} (forall lk#_451: ref :: {Heap[lk#_451, held]} {Heap[lk#_451, rdheld]} (((0 < Heap[lk#_451, held]) == (0 < old(Heap)[lk#_451, held])) && (Heap[lk#_451, rdheld] == old(Heap)[lk#_451, rdheld])) || false);
  assert {:msg "  288.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelImpEP.receiveResult2$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), mi#26: ref where (mi#26 == null) || (dtype(mi#26) == Message#t)) returns (mo#27: ref where (mo#27 == null) || (dtype(mo#27) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_452: int;
  var inhaleHeap#_453: HeapType;
  var inhaleHeap#_454: HeapType;
  assume (0 < methodK#_452) && ((1000 * methodK#_452) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_453;
  assume IsGoodInhaleState(inhaleHeap#_453, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_453[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_453[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_453, Mask);
  assume !(mi#26 == null);
  assume mi#26 != null;
  Heap[mi#26, Message.type] := inhaleHeap#_453[mi#26, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#26, Message.type] := Mask[mi#26, Message.type][perm$R := Mask[mi#26, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_453[mi#26, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_453, Mask);
  assert {:msg "  306.57: Receiver might be null."} true ==> (mi#26 != null);
  assert {:msg "  306.57: Location might not be readable."} true ==> CanRead(Mask, mi#26, Message.type);
  assume Heap[mi#26, Message.type] == 3;
  assert {:msg "  306.71: Receiver might be null."} mi#26 != null;
  assume mi#26 != null;
  Heap[mi#26, Message.inv] := inhaleHeap#_453[mi#26, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_453[mi#26, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#26, Message.inv] := Mask[mi#26, Message.inv][perm$R := Mask[mi#26, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_453[mi#26, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_453, Mask);
  assert {:msg "  307.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  307.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  assume Heap[this, FactorialContChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_454;
  assume IsGoodInhaleState(inhaleHeap#_454, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_454[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_454[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_454, Mask);
  assert {:msg "  308.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  308.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  assume Heap[this, FactorialContChannelImpEP.state] == 1;
  assume mo#27 != null;
  Heap[mo#27, Message.type] := inhaleHeap#_454[mo#27, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mo#27, Message.type] := Mask[mo#27, Message.type][perm$R := Mask[mo#27, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_454[mo#27, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_454, Mask);
  assume mo#27 == mi#26;
  assert {:msg "  308.67: Receiver might be null."} true ==> (mo#27 != null);
  assert {:msg "  308.67: Location might not be readable."} true ==> CanRead(Mask, mo#27, Message.type);
  assume Heap[mo#27, Message.type] == 3;
  assert {:msg "  308.81: Receiver might be null."} mo#27 != null;
  assume mo#27 != null;
  Heap[mo#27, Message.invResult2] := inhaleHeap#_454[mo#27, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_454[mo#27, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[mo#27, Message.invResult2] := Mask[mo#27, Message.invResult2][perm$R := Mask[mo#27, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_454[mo#27, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_454, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelImpEP.receiveResult2(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), mi#26: ref where (mi#26 == null) || (dtype(mi#26) == Message#t)) returns (mo#27: ref where (mo#27 == null) || (dtype(mo#27) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_452: int;
  var inhaleHeap#_455: HeapType;
  var unfoldK#_456: int;
  var exhaleMask#_457: MaskType;
  var inhaleHeap#_459: HeapType;
  var Heap#_463: HeapType;
  var Mask#_464: MaskType;
  var Credits#_465: CreditsType;
  var exhaleMask#_466: MaskType;
  var exhaleMask#_467: MaskType;
  assume (0 < methodK#_452) && ((1000 * methodK#_452) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_455;
  assume IsGoodInhaleState(inhaleHeap#_455, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_455[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_455[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_455, Mask);
  assume !(mi#26 == null);
  assume mi#26 != null;
  Heap[mi#26, Message.type] := inhaleHeap#_455[mi#26, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#26, Message.type] := Mask[mi#26, Message.type][perm$R := Mask[mi#26, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_455[mi#26, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_455, Mask);
  assume Heap[mi#26, Message.type] == 3;
  assume mi#26 != null;
  Heap[mi#26, Message.inv] := inhaleHeap#_455[mi#26, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_455[mi#26, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#26, Message.inv] := Mask[mi#26, Message.inv][perm$R := Mask[mi#26, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_455[mi#26, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_455, Mask);
  assume Heap[this, FactorialContChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_456) && (unfoldK#_456 < Fractions(1)) && ((1000 * unfoldK#_456) < methodK#_452);
  assert {:msg "  310.3: The target of the fold statement might be null."} mi#26 != null;
  // begin exhale (unfold)
  exhaleMask#_457 := Mask;
  assert {:msg "  310.3: unfold might fail because the predicate Message.inv does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  310.3: unfold might fail because the predicate Message.inv does not hold. Insufficient fraction at <undefined position> for Message.inv."} (Fractions(100) <= exhaleMask#_457[mi#26, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_457[mi#26, Message.inv][perm$R]) ==> (0 <= exhaleMask#_457[mi#26, Message.inv][perm$N]));
  exhaleMask#_457[mi#26, Message.inv] := exhaleMask#_457[mi#26, Message.inv][perm$R := exhaleMask#_457[mi#26, Message.inv][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_457);
  Mask := exhaleMask#_457;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_459 := Heap[mi#26, Message.inv];
  assume IsGoodInhaleState(inhaleHeap#_459, Heap, Mask);
  assume mi#26 != null;
  Heap[mi#26, Message.type] := inhaleHeap#_459[mi#26, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[mi#26, Message.type] := Mask[mi#26, Message.type][perm$R := Mask[mi#26, Message.type][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_459[mi#26, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_459, Mask);
  if (Heap[mi#26, Message.type] == 1) {
    assume mi#26 != null;
    Heap[mi#26, Message.invValue] := inhaleHeap#_459[mi#26, Message.invValue];
    assume wf(Heap, Mask);
    assume inhaleHeap#_459[mi#26, Message.invValue] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#26, Message.invValue] := Mask[mi#26, Message.invValue][perm$R := Mask[mi#26, Message.invValue][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_459[mi#26, Message.invValue]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_459, Mask);
  } else {
  }
  if (Heap[mi#26, Message.type] == 2) {
    assume mi#26 != null;
    Heap[mi#26, Message.invResult1] := inhaleHeap#_459[mi#26, Message.invResult1];
    assume wf(Heap, Mask);
    assume inhaleHeap#_459[mi#26, Message.invResult1] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#26, Message.invResult1] := Mask[mi#26, Message.invResult1][perm$R := Mask[mi#26, Message.invResult1][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_459[mi#26, Message.invResult1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_459, Mask);
  } else {
  }
  if (Heap[mi#26, Message.type] == 3) {
    assume mi#26 != null;
    Heap[mi#26, Message.invResult2] := inhaleHeap#_459[mi#26, Message.invResult2];
    assume wf(Heap, Mask);
    assume inhaleHeap#_459[mi#26, Message.invResult2] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#26, Message.invResult2] := Mask[mi#26, Message.invResult2][perm$R := Mask[mi#26, Message.invResult2][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_459[mi#26, Message.invResult2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_459, Mask);
  } else {
  }
  if (Heap[mi#26, Message.type] == 4) {
    assume mi#26 != null;
    Heap[mi#26, Message.invFinalResult] := inhaleHeap#_459[mi#26, Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_459[mi#26, Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[mi#26, Message.invFinalResult] := Mask[mi#26, Message.invFinalResult][perm$R := Mask[mi#26, Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_459[mi#26, Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_459, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  311.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  311.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  if (Heap[this, FactorialContChannelImpEP.state] == 0) {
    // update field state
    assert {:msg "  312.4: Location might not be writable"} CanWrite(Mask, this, FactorialContChannelImpEP.state);
    Heap[this, FactorialContChannelImpEP.state] := 1;
    assume wf(Heap, Mask);
  } else {
    // assert
    Heap#_463 := Heap;
    Mask#_464 := Mask;
    Credits#_465 := Credits;
    // begin exhale (assert)
    exhaleMask#_466 := Mask#_464;
    assert {:msg "  316.4: Assertion might not hold. The expression at 316.11 might not evaluate to true."} false;
    Mask#_464 := exhaleMask#_466;
    assume wf(Heap#_463, Mask#_464);
    // end exhale
  }
  // assigment to mo
  mo#27 := mi#26;
  // begin exhale (postcondition)
  exhaleMask#_467 := Mask;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. The expression at 308.24 might not evaluate to true."} Heap[this, FactorialContChannelImpEP.state] == 1;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. The expression at 308.56 might not evaluate to true."} mo#27 == mi#26;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. The expression at 308.67 might not evaluate to true."} Heap[mo#27, Message.type] == 3;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. The permission at 308.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. Insufficient fraction at 308.10 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_467[this, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_467[this, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_467[this, FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_467[this, FactorialContChannelImpEP.state] := exhaleMask#_467[this, FactorialContChannelImpEP.state][perm$R := exhaleMask#_467[this, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_467);
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. The permission at 308.36 might not be positive."} monitorK > 0;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. Insufficient fraction at 308.36 for Message.type."} (monitorK <= exhaleMask#_467[mo#27, Message.type][perm$R]) && ((monitorK == exhaleMask#_467[mo#27, Message.type][perm$R]) ==> (0 <= exhaleMask#_467[mo#27, Message.type][perm$N]));
  exhaleMask#_467[mo#27, Message.type] := exhaleMask#_467[mo#27, Message.type][perm$R := exhaleMask#_467[mo#27, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_467);
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. The permission at 308.81 might not be positive."} Fractions(100) > 0;
  assert {:msg "  305.2: The postcondition at 308.10 might not hold. Insufficient fraction at 308.81 for Message.invResult2."} (Fractions(100) <= exhaleMask#_467[mo#27, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_467[mo#27, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_467[mo#27, Message.invResult2][perm$N]));
  exhaleMask#_467[mo#27, Message.invResult2] := exhaleMask#_467[mo#27, Message.invResult2][perm$R := exhaleMask#_467[mo#27, Message.invResult2][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_467);
  Mask := exhaleMask#_467;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  305.2: Method might lock/unlock more than allowed."} (forall lk#_471: ref :: {Heap[lk#_471, held]} {Heap[lk#_471, rdheld]} (((0 < Heap[lk#_471, held]) == (0 < old(Heap)[lk#_471, held])) && (Heap[lk#_471, rdheld] == old(Heap)[lk#_471, rdheld])) || false);
  assert {:msg "  305.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialContChannelImpEP.fail$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), m#28: ref where (m#28 == null) || (dtype(m#28) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_472: int;
  var inhaleHeap#_473: HeapType;
  var inhaleHeap#_474: HeapType;
  assume (0 < methodK#_472) && ((1000 * methodK#_472) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_473;
  assume IsGoodInhaleState(inhaleHeap#_473, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_473[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_473[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_473, Mask);
  assume m#28 != null;
  Heap[m#28, Message.type] := inhaleHeap#_473[m#28, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#28, Message.type] := Mask[m#28, Message.type][perm$R := Mask[m#28, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_473[m#28, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_473, Mask);
  assert {:msg "  322.45: Receiver might be null."} true ==> (m#28 != null);
  assert {:msg "  322.45: Location might not be readable."} true ==> CanRead(Mask, m#28, Message.type);
  assert {:msg "  322.58: Receiver might be null."} true && (!(Heap[m#28, Message.type] == 2)) ==> (m#28 != null);
  assert {:msg "  322.58: Location might not be readable."} true && (!(Heap[m#28, Message.type] == 2)) ==> CanRead(Mask, m#28, Message.type);
  assume (Heap[m#28, Message.type] == 2) || (Heap[m#28, Message.type] == 3);
  assert {:msg "  323.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_473[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_473[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_473[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_473, Mask);
  assert {:msg "  324.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  324.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  assume !(Heap[this, FactorialContChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_474;
  assume IsGoodInhaleState(inhaleHeap#_474, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_474[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_474[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_474, Mask);
  assert {:msg "  325.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_474[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_474[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_474[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_474, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannelImpEP.fail(this: ref where (this == null) || (dtype(this) == FactorialContChannelImpEP#t), m#28: ref where (m#28 == null) || (dtype(m#28) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_472: int;
  var inhaleHeap#_475: HeapType;
  var Heap#_479: HeapType;
  var Mask#_480: MaskType;
  var Credits#_481: CreditsType;
  var exhaleMask#_482: MaskType;
  var exhaleMask#_483: MaskType;
  assume (0 < methodK#_472) && ((1000 * methodK#_472) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_475;
  assume IsGoodInhaleState(inhaleHeap#_475, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.state] := inhaleHeap#_475[this, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.state] := Mask[this, FactorialContChannelImpEP.state][perm$R := Mask[this, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_475[this, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_475, Mask);
  assume m#28 != null;
  Heap[m#28, Message.type] := inhaleHeap#_475[m#28, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#28, Message.type] := Mask[m#28, Message.type][perm$R := Mask[m#28, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_475[m#28, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_475, Mask);
  assume (Heap[m#28, Message.type] == 2) || (Heap[m#28, Message.type] == 3);
  assume this != null;
  Heap[this, FactorialContChannelImpEP.valid] := inhaleHeap#_475[this, FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_475[this, FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannelImpEP.valid] := Mask[this, FactorialContChannelImpEP.valid][perm$R := Mask[this, FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_475[this, FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_475, Mask);
  assume !(Heap[this, FactorialContChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  327.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  327.6: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannelImpEP.state);
  if (Heap[this, FactorialContChannelImpEP.state] == 0) {
    // assert
    Heap#_479 := Heap;
    Mask#_480 := Mask;
    Credits#_481 := Credits;
    // begin exhale (assert)
    exhaleMask#_482 := Mask#_480;
    assert {:msg "  328.4: Assertion might not hold. The expression at 328.11 might not evaluate to true."} false;
    Mask#_480 := exhaleMask#_482;
    assume wf(Heap#_479, Mask#_480);
    // end exhale
  } else {
    // assume
    assume false;
  }
  // begin exhale (postcondition)
  exhaleMask#_483 := Mask;
  assert {:msg "  321.2: The postcondition at 325.10 might not hold. The permission at 325.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  321.2: The postcondition at 325.10 might not hold. Insufficient fraction at 325.10 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_483[this, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_483[this, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_483[this, FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_483[this, FactorialContChannelImpEP.state] := exhaleMask#_483[this, FactorialContChannelImpEP.state][perm$R := exhaleMask#_483[this, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_483);
  assert {:msg "  321.2: The postcondition at 325.10 might not hold. The permission at 325.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  321.2: The postcondition at 325.10 might not hold. Insufficient fraction at 325.24 for FactorialContChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_483[this, FactorialContChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_483[this, FactorialContChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_483[this, FactorialContChannelImpEP.valid][perm$N]));
  exhaleMask#_483[this, FactorialContChannelImpEP.valid] := exhaleMask#_483[this, FactorialContChannelImpEP.valid][perm$R := exhaleMask#_483[this, FactorialContChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_483);
  Mask := exhaleMask#_483;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  321.2: Method might lock/unlock more than allowed."} (forall lk#_486: ref :: {Heap[lk#_486, held]} {Heap[lk#_486, rdheld]} (((0 < Heap[lk#_486, held]) == (0 < old(Heap)[lk#_486, held])) && (Heap[lk#_486, rdheld] == old(Heap)[lk#_486, rdheld])) || false);
  assert {:msg "  321.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialContChannel#t: TypeName;
procedure FactorialContChannel$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_494: int;
  var h0#_487: HeapType;
  var m0#_488: MaskType;
  var c0#_489: CreditsType;
  var h1#_490: HeapType;
  var m1#_491: MaskType;
  var c1#_492: CreditsType;
  var lk#_493: ref;
  assume (0 < methodK#_494) && ((1000 * methodK#_494) < Fractions(1));
  assume wf(h0#_487, m0#_488);
  assume wf(h1#_490, m1#_491);
  m1#_491 := ZeroMask;
  c1#_492 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  336.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialContChannel.imp: Field (ref);
axiom NonPredicateField(FactorialContChannel.imp);
const unique FactorialContChannel.exp: Field (ref);
axiom NonPredicateField(FactorialContChannel.exp);
const unique FactorialContChannel.valid: Field (HeapType);
axiom PredicateField(FactorialContChannel.valid);
procedure FactorialContChannel.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_495: int;
  var inhaleHeap#_496: HeapType;
  assume (0 < predicateK#_495) && ((1000 * predicateK#_495) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_496;
  assume IsGoodInhaleState(inhaleHeap#_496, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.imp] := inhaleHeap#_496[this, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.imp] == null) || (dtype(Heap[this, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.imp] := Mask[this, FactorialContChannel.imp][perm$R := Mask[this, FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_496[this, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_496, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.exp] := inhaleHeap#_496[this, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.exp] == null) || (dtype(Heap[this, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.exp] := Mask[this, FactorialContChannel.exp][perm$R := Mask[this, FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_496[this, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_496, Mask);
  assert {:msg "  341.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  341.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := inhaleHeap#_496[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null) || (dtype(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_496[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_496, Mask);
  assert {:msg "  341.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  341.57: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := inhaleHeap#_496[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] == null) || (dtype(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_496[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_496, Mask);
  assert {:msg "  342.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assume !(Heap[this, FactorialContChannel.imp] == null);
  assert {:msg "  342.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.16: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assume !(Heap[this, FactorialContChannel.exp] == null);
  assert {:msg "  342.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.29: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  342.29: Receiver might be null."} Heap[this, FactorialContChannel.imp] != null;
  assert {:msg "  342.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.29: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := inhaleHeap#_496[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_496[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_496[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_496, Mask);
  assert {:msg "  342.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.42: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  342.42: Receiver might be null."} Heap[this, FactorialContChannel.exp] != null;
  assert {:msg "  342.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.42: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := inhaleHeap#_496[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_496[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_496[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_496, Mask);
  assert {:msg "  342.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.55: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  342.55: Receiver might be null."} true ==> (Heap[this, FactorialContChannel.imp] != null);
  assert {:msg "  342.55: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch);
  assume Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] == this;
  assert {:msg "  342.70: Receiver might be null."} true ==> (this != null);
  assert {:msg "  342.70: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  342.70: Receiver might be null."} true ==> (Heap[this, FactorialContChannel.exp] != null);
  assert {:msg "  342.70: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch);
  assume Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] == this;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FactorialContChannel.initImpState: Field (HeapType);
axiom PredicateField(FactorialContChannel.initImpState);
procedure FactorialContChannel.initImpState$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_497: int;
  var inhaleHeap#_498: HeapType;
  assume (0 < predicateK#_497) && ((1000 * predicateK#_497) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_498;
  assume IsGoodInhaleState(inhaleHeap#_498, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.imp] := inhaleHeap#_498[this, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.imp] == null) || (dtype(Heap[this, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.imp] := Mask[this, FactorialContChannel.imp][perm$R := Mask[this, FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_498[this, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_498, Mask);
  assert {:msg "  346.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  346.23: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state] := inhaleHeap#_498[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_498[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_498, Mask);
  assert {:msg "  346.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  346.37: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  346.37: Receiver might be null."} true ==> (Heap[this, FactorialContChannel.imp] != null);
  assert {:msg "  346.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state);
  assume Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FactorialContChannel.initExpState: Field (HeapType);
axiom PredicateField(FactorialContChannel.initExpState);
procedure FactorialContChannel.initExpState$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_499: int;
  var inhaleHeap#_500: HeapType;
  assume (0 < predicateK#_499) && ((1000 * predicateK#_499) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_500;
  assume IsGoodInhaleState(inhaleHeap#_500, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.exp] := inhaleHeap#_500[this, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.exp] == null) || (dtype(Heap[this, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.exp] := Mask[this, FactorialContChannel.exp][perm$R := Mask[this, FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_500[this, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_500, Mask);
  assert {:msg "  349.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  349.23: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state] := inhaleHeap#_500[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_500[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_500, Mask);
  assert {:msg "  349.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  349.37: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  349.37: Receiver might be null."} true ==> (Heap[this, FactorialContChannel.exp] != null);
  assert {:msg "  349.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state);
  assume Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannel.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialContChannel#t), i#29: ref where (i#29 == null) || (dtype(i#29) == FactorialContChannelImpEP#t), e#30: ref where (e#30 == null) || (dtype(e#30) == FactorialContChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_501: int;
  var inhaleHeap#_502: HeapType;
  var inhaleHeap#_503: HeapType;
  assume (0 < methodK#_501) && ((1000 * methodK#_501) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_502;
  assume IsGoodInhaleState(inhaleHeap#_502, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.imp] := inhaleHeap#_502[this, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.imp] == null) || (dtype(Heap[this, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.imp] := Mask[this, FactorialContChannel.imp][perm$R := Mask[this, FactorialContChannel.imp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[this, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume i#29 != null;
  Heap[i#29, FactorialContChannelImpEP.ch] := inhaleHeap#_502[i#29, FactorialContChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[i#29, FactorialContChannelImpEP.ch] == null) || (dtype(Heap[i#29, FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
  assume Fractions(100) > 0;
  Mask[i#29, FactorialContChannelImpEP.ch] := Mask[i#29, FactorialContChannelImpEP.ch][perm$R := Mask[i#29, FactorialContChannelImpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[i#29, FactorialContChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.exp] := inhaleHeap#_502[this, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.exp] == null) || (dtype(Heap[this, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.exp] := Mask[this, FactorialContChannel.exp][perm$R := Mask[this, FactorialContChannel.exp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[this, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume e#30 != null;
  Heap[e#30, FactorialContChannelExpEP.ch] := inhaleHeap#_502[e#30, FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[e#30, FactorialContChannelExpEP.ch] == null) || (dtype(Heap[e#30, FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume Fractions(100) > 0;
  Mask[e#30, FactorialContChannelExpEP.ch] := Mask[e#30, FactorialContChannelExpEP.ch][perm$R := Mask[e#30, FactorialContChannelExpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[e#30, FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume e#30 != null;
  Heap[e#30, FactorialContChannelExpEP.expch] := inhaleHeap#_502[e#30, FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[e#30, FactorialContChannelExpEP.expch] == null) || (dtype(Heap[e#30, FactorialContChannelExpEP.expch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[e#30, FactorialContChannelExpEP.expch] := Mask[e#30, FactorialContChannelExpEP.expch][perm$R := Mask[e#30, FactorialContChannelExpEP.expch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[e#30, FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume i#29 != null;
  Heap[i#29, FactorialContChannelImpEP.impch] := inhaleHeap#_502[i#29, FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[i#29, FactorialContChannelImpEP.impch] == null) || (dtype(Heap[i#29, FactorialContChannelImpEP.impch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[i#29, FactorialContChannelImpEP.impch] := Mask[i#29, FactorialContChannelImpEP.impch][perm$R := Mask[i#29, FactorialContChannelImpEP.impch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[i#29, FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume i#29 != null;
  Heap[i#29, FactorialContChannelImpEP.state] := inhaleHeap#_502[i#29, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[i#29, FactorialContChannelImpEP.state] := Mask[i#29, FactorialContChannelImpEP.state][perm$R := Mask[i#29, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[i#29, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume e#30 != null;
  Heap[e#30, FactorialContChannelExpEP.state] := inhaleHeap#_502[e#30, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[e#30, FactorialContChannelExpEP.state] := Mask[e#30, FactorialContChannelExpEP.state][perm$R := Mask[e#30, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_502[e#30, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_502, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_503;
  assume IsGoodInhaleState(inhaleHeap#_503, Heap, Mask);
  assert {:msg "  354.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannel.valid] := inhaleHeap#_503[this, FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_503[this, FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.valid] := Mask[this, FactorialContChannel.valid][perm$R := Mask[this, FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  354.20: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannel.valid] := inhaleHeap#_503[this, FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_503[this, FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.valid] := Mask[this, FactorialContChannel.valid][perm$R := Mask[this, FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.exp] := inhaleHeap#_503[this, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.exp] == null) || (dtype(Heap[this, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.exp] := Mask[this, FactorialContChannel.exp][perm$R := Mask[this, FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.imp] := inhaleHeap#_503[this, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.imp] == null) || (dtype(Heap[this, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.imp] := Mask[this, FactorialContChannel.imp][perm$R := Mask[this, FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  354.64: Receiver might be null."} true ==> (this != null);
  assert {:msg "  354.64: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_503[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  354.86: Receiver might be null."} true ==> (this != null);
  assert {:msg "  354.86: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_503[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.exp] := inhaleHeap#_503[this, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.exp] == null) || (dtype(Heap[this, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.exp] := Mask[this, FactorialContChannel.exp][perm$R := Mask[this, FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.imp] := inhaleHeap#_503[this, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.imp] == null) || (dtype(Heap[this, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FactorialContChannel.imp] := Mask[this, FactorialContChannel.imp][perm$R := Mask[this, FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  355.41: Receiver might be null."} true ==> (this != null);
  assert {:msg "  355.41: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_503[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  355.63: Receiver might be null."} true ==> (this != null);
  assert {:msg "  355.63: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_503[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  355.81: Receiver might be null."} true ==> (this != null);
  assert {:msg "  355.81: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  355.81: Receiver might be null."} true ==> (Heap[this, FactorialContChannel.exp] != null);
  assert {:msg "  355.81: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch);
  assume !(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  355.100: Receiver might be null."} true ==> (this != null);
  assert {:msg "  355.100: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  355.100: Receiver might be null."} true ==> (Heap[this, FactorialContChannel.imp] != null);
  assert {:msg "  355.100: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume !(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  356.3: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannel.initImpState] := inhaleHeap#_503[this, FactorialContChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_503[this, FactorialContChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.initImpState] := Mask[this, FactorialContChannel.initImpState][perm$R := Mask[this, FactorialContChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assert {:msg "  356.19: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FactorialContChannel.initExpState] := inhaleHeap#_503[this, FactorialContChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_503[this, FactorialContChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.initExpState] := Mask[this, FactorialContChannel.initExpState][perm$R := Mask[this, FactorialContChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_503[this, FactorialContChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_503, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialContChannel.init(this: ref where (this == null) || (dtype(this) == FactorialContChannel#t), i#29: ref where (i#29 == null) || (dtype(i#29) == FactorialContChannelImpEP#t), e#30: ref where (e#30 == null) || (dtype(e#30) == FactorialContChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_501: int;
  var inhaleHeap#_504: HeapType;
  var nw#_505: ref;
  var mu#_506: Mu;
  var nw#_508: ref;
  var mu#_509: Mu;
  var foldK#_511: int;
  var exhaleMask#_512: MaskType;
  var inhaleHeap#_521: HeapType;
  var foldK#_522: int;
  var exhaleMask#_523: MaskType;
  var inhaleHeap#_532: HeapType;
  var foldK#_533: int;
  var exhaleMask#_534: MaskType;
  var inhaleHeap#_543: HeapType;
  var foldK#_544: int;
  var exhaleMask#_545: MaskType;
  var inhaleHeap#_554: HeapType;
  var foldK#_555: int;
  var exhaleMask#_556: MaskType;
  var inhaleHeap#_563: HeapType;
  var foldK#_564: int;
  var exhaleMask#_565: MaskType;
  var inhaleHeap#_572: HeapType;
  var foldK#_573: int;
  var exhaleMask#_574: MaskType;
  var inhaleHeap#_577: HeapType;
  var foldK#_578: int;
  var exhaleMask#_579: MaskType;
  var inhaleHeap#_582: HeapType;
  var exhaleMask#_583: MaskType;
  assume (0 < methodK#_501) && ((1000 * methodK#_501) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_504;
  assume IsGoodInhaleState(inhaleHeap#_504, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.imp] := inhaleHeap#_504[this, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.imp] == null) || (dtype(Heap[this, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.imp] := Mask[this, FactorialContChannel.imp][perm$R := Mask[this, FactorialContChannel.imp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[this, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume i#29 != null;
  Heap[i#29, FactorialContChannelImpEP.ch] := inhaleHeap#_504[i#29, FactorialContChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[i#29, FactorialContChannelImpEP.ch] == null) || (dtype(Heap[i#29, FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
  assume Fractions(100) > 0;
  Mask[i#29, FactorialContChannelImpEP.ch] := Mask[i#29, FactorialContChannelImpEP.ch][perm$R := Mask[i#29, FactorialContChannelImpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[i#29, FactorialContChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.exp] := inhaleHeap#_504[this, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialContChannel.exp] == null) || (dtype(Heap[this, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.exp] := Mask[this, FactorialContChannel.exp][perm$R := Mask[this, FactorialContChannel.exp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[this, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume e#30 != null;
  Heap[e#30, FactorialContChannelExpEP.ch] := inhaleHeap#_504[e#30, FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[e#30, FactorialContChannelExpEP.ch] == null) || (dtype(Heap[e#30, FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume Fractions(100) > 0;
  Mask[e#30, FactorialContChannelExpEP.ch] := Mask[e#30, FactorialContChannelExpEP.ch][perm$R := Mask[e#30, FactorialContChannelExpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[e#30, FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume e#30 != null;
  Heap[e#30, FactorialContChannelExpEP.expch] := inhaleHeap#_504[e#30, FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[e#30, FactorialContChannelExpEP.expch] == null) || (dtype(Heap[e#30, FactorialContChannelExpEP.expch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[e#30, FactorialContChannelExpEP.expch] := Mask[e#30, FactorialContChannelExpEP.expch][perm$R := Mask[e#30, FactorialContChannelExpEP.expch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[e#30, FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume i#29 != null;
  Heap[i#29, FactorialContChannelImpEP.impch] := inhaleHeap#_504[i#29, FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[i#29, FactorialContChannelImpEP.impch] == null) || (dtype(Heap[i#29, FactorialContChannelImpEP.impch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[i#29, FactorialContChannelImpEP.impch] := Mask[i#29, FactorialContChannelImpEP.impch][perm$R := Mask[i#29, FactorialContChannelImpEP.impch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[i#29, FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume i#29 != null;
  Heap[i#29, FactorialContChannelImpEP.state] := inhaleHeap#_504[i#29, FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[i#29, FactorialContChannelImpEP.state] := Mask[i#29, FactorialContChannelImpEP.state][perm$R := Mask[i#29, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[i#29, FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume e#30 != null;
  Heap[e#30, FactorialContChannelExpEP.state] := inhaleHeap#_504[e#30, FactorialContChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[e#30, FactorialContChannelExpEP.state] := Mask[e#30, FactorialContChannelExpEP.state][perm$R := Mask[e#30, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_504[e#30, FactorialContChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_504, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field imp
  assert {:msg "  358.3: Location might not be writable"} CanWrite(Mask, this, FactorialContChannel.imp);
  Heap[this, FactorialContChannel.imp] := i#29;
  assume wf(Heap, Mask);
  // update field exp
  assert {:msg "  359.3: Location might not be writable"} CanWrite(Mask, this, FactorialContChannel.exp);
  Heap[this, FactorialContChannel.exp] := e#30;
  assume wf(Heap, Mask);
  // update field ch
  assert {:msg "  360.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  360.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  360.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch);
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := this;
  assume wf(Heap, Mask);
  // update field ch
  assert {:msg "  361.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  361.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  361.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch);
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := this;
  assume wf(Heap, Mask);
  // update field impch
  assert {:msg "  362.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  362.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  362.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  // new
  havoc nw#_505;
  assume (nw#_505 != null) && (dtype(nw#_505) == Channel#t);
  assume (forall<T#_2> f: Field (T#_2) :: (Mask[nw#_505, f][perm$R] == 0) && (Mask[nw#_505, f][perm$N] == 0));
  havoc mu#_506;
  assume mu#_506 != $LockBottom;
  assume (forall o#_507: ref :: (((0 < Heap[o#_507, held]) || Heap[o#_507, rdheld]) || (Credits[o#_507] < 0)) ==> MuBelow(Heap[o#_507, mu], mu#_506));
  assume Heap[nw#_505, mu] == mu#_506;
  assume Heap[nw#_505, held] <= 0;
  assume Heap[nw#_505, rdheld] == false;
  Mask[nw#_505, mu] := Mask[nw#_505, mu][perm$R := Mask[nw#_505, mu][perm$R] + Fractions(100)];
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := nw#_505;
  assume wf(Heap, Mask);
  // update field expch
  assert {:msg "  363.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  363.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  363.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch);
  // new
  havoc nw#_508;
  assume (nw#_508 != null) && (dtype(nw#_508) == Channel#t);
  assume (forall<T#_3> f: Field (T#_3) :: (Mask[nw#_508, f][perm$R] == 0) && (Mask[nw#_508, f][perm$N] == 0));
  havoc mu#_509;
  assume mu#_509 != $LockBottom;
  assume (forall o#_510: ref :: (((0 < Heap[o#_510, held]) || Heap[o#_510, rdheld]) || (Credits[o#_510] < 0)) ==> MuBelow(Heap[o#_510, mu], mu#_509));
  assume Heap[nw#_508, mu] == mu#_509;
  assume Heap[nw#_508, held] <= 0;
  assume Heap[nw#_508, rdheld] == false;
  Mask[nw#_508, mu] := Mask[nw#_508, mu][perm$R := Mask[nw#_508, mu][perm$R] + Fractions(100)];
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := nw#_508;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_511) && ((1000 * foldK#_511) < Fractions(1)) && ((1000 * foldK#_511) < methodK#_501);
  assert {:msg "  364.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  364.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  364.3: The target of the fold statement might be null."} Heap[this, FactorialContChannel.imp] != null;
  // begin exhale (fold)
  exhaleMask#_512 := Mask;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 262.38 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 263.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] == null);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 263.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] == null);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 264.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 265.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 262.5 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 262.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 262.23 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 262.23 for FactorialContChannelImpEP.ch."} (monitorK <= exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$N]));
  exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := exhaleMask#_512[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 263.5 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 263.5 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$N]));
  exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] := exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R := exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 263.40 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 263.40 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$N]));
  exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] := exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R := exhaleMask#_512[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 264.5 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 264.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 265.5 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 265.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_512[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 266.5 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 266.5 for mu."} (monitorK <= exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 266.33 might not be positive."} monitorK > 0;
  assert {:msg "  364.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 266.33 for mu."} (monitorK <= exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := exhaleMask#_512[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_512);
  Mask := exhaleMask#_512;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_521;
  assume IsGoodInhaleState(inhaleHeap#_521, Heap, Mask);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := inhaleHeap#_521[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_521[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_521[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_521, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_522) && ((1000 * foldK#_522) < Fractions(1)) && ((1000 * foldK#_522) < methodK#_501);
  assert {:msg "  365.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  365.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  365.3: The target of the fold statement might be null."} Heap[this, FactorialContChannel.exp] != null;
  // begin exhale (fold)
  exhaleMask#_523 := Mask;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 187.38 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] == null);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 189.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 190.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.5 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.23 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.23 for FactorialContChannelExpEP.ch."} (monitorK <= exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$N]));
  exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := exhaleMask#_523[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.5 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.5 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$N]));
  exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp] := exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.40 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.40 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$N]));
  exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp] := exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := exhaleMask#_523[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 189.5 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 189.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 190.5 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 190.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_523[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.5 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.5 for mu."} (monitorK <= exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.33 might not be positive."} monitorK > 0;
  assert {:msg "  365.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.33 for mu."} (monitorK <= exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := exhaleMask#_523[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_523);
  Mask := exhaleMask#_523;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_532;
  assume IsGoodInhaleState(inhaleHeap#_532, Heap, Mask);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := inhaleHeap#_532[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_532[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_532[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_532, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_533) && ((1000 * foldK#_533) < Fractions(1)) && ((1000 * foldK#_533) < methodK#_501);
  assert {:msg "  366.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  366.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  366.3: The target of the fold statement might be null."} Heap[this, FactorialContChannel.imp] != null;
  // begin exhale (fold)
  exhaleMask#_534 := Mask;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 262.38 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 263.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] == null);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 263.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] == null);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 264.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The expression at 265.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 262.5 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 262.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 262.23 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 262.23 for FactorialContChannelImpEP.ch."} (monitorK <= exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$N]));
  exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := exhaleMask#_534[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 263.5 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 263.5 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$N]));
  exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] := exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R := exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 263.40 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 263.40 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$N]));
  exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] := exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R := exhaleMask#_534[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 264.5 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 264.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 265.5 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 265.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_534[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 266.5 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 266.5 for mu."} (monitorK <= exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. The permission at 266.33 might not be positive."} monitorK > 0;
  assert {:msg "  366.3: Fold might fail because the definition of FactorialContChannelImpEP.valid does not hold. Insufficient fraction at 266.33 for mu."} (monitorK <= exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := exhaleMask#_534[Heap[Heap[Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_534);
  Mask := exhaleMask#_534;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_543;
  assume IsGoodInhaleState(inhaleHeap#_543, Heap, Mask);
  assume Heap[this, FactorialContChannel.imp] != null;
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := inhaleHeap#_543[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_543[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := Mask[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_543[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_543, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_544) && ((1000 * foldK#_544) < Fractions(1)) && ((1000 * foldK#_544) < methodK#_501);
  assert {:msg "  367.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  367.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  367.3: The target of the fold statement might be null."} Heap[this, FactorialContChannel.exp] != null;
  // begin exhale (fold)
  exhaleMask#_545 := Mask;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 187.38 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] == null);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp] == null);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 188.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp] == null);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 189.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The expression at 190.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.5 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 187.23 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 187.23 for FactorialContChannelExpEP.ch."} (monitorK <= exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$N]));
  exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := exhaleMask#_545[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.5 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.5 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$N]));
  exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp] := exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R := exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 188.40 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 188.40 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$N]));
  exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp] := exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R := exhaleMask#_545[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 189.5 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 189.5 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 190.5 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 190.5 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_545[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.5 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.5 for mu."} (monitorK <= exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. The permission at 191.33 might not be positive."} monitorK > 0;
  assert {:msg "  367.3: Fold might fail because the definition of FactorialContChannelExpEP.valid does not hold. Insufficient fraction at 191.33 for mu."} (monitorK <= exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := exhaleMask#_545[Heap[Heap[Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_545);
  Mask := exhaleMask#_545;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_554;
  assume IsGoodInhaleState(inhaleHeap#_554, Heap, Mask);
  assume Heap[this, FactorialContChannel.exp] != null;
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := inhaleHeap#_554[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_554[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := Mask[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_554[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_554, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_555) && ((1000 * foldK#_555) < Fractions(1)) && ((1000 * foldK#_555) < methodK#_501);
  assert {:msg "  368.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_556 := Mask;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.3 might not evaluate to true."} !(Heap[this, FactorialContChannel.imp] == null);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.16 might not evaluate to true."} !(Heap[this, FactorialContChannel.exp] == null);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.55 might not evaluate to true."} Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] == this;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.70 might not evaluate to true."} Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] == this;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.3 might not be positive."} monitorK > 0;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.3 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_556[this, FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_556[this, FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_556[this, FactorialContChannel.imp][perm$N]));
  exhaleMask#_556[this, FactorialContChannel.imp] := exhaleMask#_556[this, FactorialContChannel.imp][perm$R := exhaleMask#_556[this, FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_556);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.19 might not be positive."} monitorK > 0;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.19 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_556[this, FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_556[this, FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_556[this, FactorialContChannel.exp][perm$N]));
  exhaleMask#_556[this, FactorialContChannel.exp] := exhaleMask#_556[this, FactorialContChannel.exp][perm$R := exhaleMask#_556[this, FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_556);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.35 might not be positive."} monitorK > 0;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.35 for FactorialContChannelImpEP.ch."} (monitorK <= exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$N]));
  exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_556);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.54 might not be positive."} monitorK > 0;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.54 for FactorialContChannelExpEP.ch."} (monitorK <= exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$N]));
  exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_556);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 342.29 might not be positive."} Fractions(100) > 0;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 342.29 for FactorialContChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$N]));
  exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := exhaleMask#_556[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_556);
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 342.42 might not be positive."} Fractions(100) > 0;
  assert {:msg "  368.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 342.42 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := exhaleMask#_556[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_556);
  Mask := exhaleMask#_556;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_563;
  assume IsGoodInhaleState(inhaleHeap#_563, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.valid] := inhaleHeap#_563[this, FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_563[this, FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.valid] := Mask[this, FactorialContChannel.valid][perm$R := Mask[this, FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_563[this, FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_563, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialContChannel.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_564) && ((1000 * foldK#_564) < Fractions(1)) && ((1000 * foldK#_564) < methodK#_501);
  assert {:msg "  369.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_565 := Mask;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.3 might not evaluate to true."} !(Heap[this, FactorialContChannel.imp] == null);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.16 might not evaluate to true."} !(Heap[this, FactorialContChannel.exp] == null);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.55 might not evaluate to true."} Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] == this;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The expression at 342.70 might not evaluate to true."} Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] == this;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.3 might not be positive."} monitorK > 0;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.3 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_565[this, FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_565[this, FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_565[this, FactorialContChannel.imp][perm$N]));
  exhaleMask#_565[this, FactorialContChannel.imp] := exhaleMask#_565[this, FactorialContChannel.imp][perm$R := exhaleMask#_565[this, FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_565);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.19 might not be positive."} monitorK > 0;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.19 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_565[this, FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_565[this, FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_565[this, FactorialContChannel.exp][perm$N]));
  exhaleMask#_565[this, FactorialContChannel.exp] := exhaleMask#_565[this, FactorialContChannel.exp][perm$R := exhaleMask#_565[this, FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_565);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.35 might not be positive."} monitorK > 0;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.35 for FactorialContChannelImpEP.ch."} (monitorK <= exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$N]));
  exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch] := exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_565);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 341.54 might not be positive."} monitorK > 0;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 341.54 for FactorialContChannelExpEP.ch."} (monitorK <= exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$N]));
  exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch] := exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_565);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 342.29 might not be positive."} Fractions(100) > 0;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 342.29 for FactorialContChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$N]));
  exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid] := exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := exhaleMask#_565[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_565);
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. The permission at 342.42 might not be positive."} Fractions(100) > 0;
  assert {:msg "  369.3: Fold might fail because the definition of FactorialContChannel.valid does not hold. Insufficient fraction at 342.42 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$N]));
  exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid] := exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := exhaleMask#_565[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_565);
  Mask := exhaleMask#_565;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_572;
  assume IsGoodInhaleState(inhaleHeap#_572, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.valid] := inhaleHeap#_572[this, FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_572[this, FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.valid] := Mask[this, FactorialContChannel.valid][perm$R := Mask[this, FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_572[this, FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_572, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialContChannel.valid] := Heap;
  assume wf(Heap, Mask);
  // update field state
  assert {:msg "  371.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  371.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.imp);
  assert {:msg "  371.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state);
  Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state] := 0;
  assume wf(Heap, Mask);
  // update field state
  assert {:msg "  372.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  372.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialContChannel.exp);
  assert {:msg "  372.3: Location might not be writable"} CanWrite(Mask, Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state);
  Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state] := 0;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_573) && ((1000 * foldK#_573) < Fractions(1)) && ((1000 * foldK#_573) < methodK#_501);
  assert {:msg "  373.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_574 := Mask;
  assert {:msg "  373.3: Fold might fail because the definition of FactorialContChannel.initExpState does not hold. The expression at 349.37 might not evaluate to true."} Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state] == 0;
  assert {:msg "  373.3: Fold might fail because the definition of FactorialContChannel.initExpState does not hold. The permission at 349.3 might not be positive."} monitorK > 0;
  assert {:msg "  373.3: Fold might fail because the definition of FactorialContChannel.initExpState does not hold. Insufficient fraction at 349.3 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_574[this, FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_574[this, FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_574[this, FactorialContChannel.exp][perm$N]));
  exhaleMask#_574[this, FactorialContChannel.exp] := exhaleMask#_574[this, FactorialContChannel.exp][perm$R := exhaleMask#_574[this, FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_574);
  assert {:msg "  373.3: Fold might fail because the definition of FactorialContChannel.initExpState does not hold. The permission at 349.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  373.3: Fold might fail because the definition of FactorialContChannel.initExpState does not hold. Insufficient fraction at 349.19 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_574[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_574[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_574[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$N]));
  exhaleMask#_574[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state] := exhaleMask#_574[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R := exhaleMask#_574[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_574);
  Mask := exhaleMask#_574;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_577;
  assume IsGoodInhaleState(inhaleHeap#_577, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.initExpState] := inhaleHeap#_577[this, FactorialContChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_577[this, FactorialContChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.initExpState] := Mask[this, FactorialContChannel.initExpState][perm$R := Mask[this, FactorialContChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_577[this, FactorialContChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_577, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialContChannel.initExpState] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_578) && ((1000 * foldK#_578) < Fractions(1)) && ((1000 * foldK#_578) < methodK#_501);
  assert {:msg "  374.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_579 := Mask;
  assert {:msg "  374.3: Fold might fail because the definition of FactorialContChannel.initImpState does not hold. The expression at 346.37 might not evaluate to true."} Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state] == 0;
  assert {:msg "  374.3: Fold might fail because the definition of FactorialContChannel.initImpState does not hold. The permission at 346.3 might not be positive."} monitorK > 0;
  assert {:msg "  374.3: Fold might fail because the definition of FactorialContChannel.initImpState does not hold. Insufficient fraction at 346.3 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_579[this, FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_579[this, FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_579[this, FactorialContChannel.imp][perm$N]));
  exhaleMask#_579[this, FactorialContChannel.imp] := exhaleMask#_579[this, FactorialContChannel.imp][perm$R := exhaleMask#_579[this, FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_579);
  assert {:msg "  374.3: Fold might fail because the definition of FactorialContChannel.initImpState does not hold. The permission at 346.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  374.3: Fold might fail because the definition of FactorialContChannel.initImpState does not hold. Insufficient fraction at 346.19 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_579[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_579[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_579[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_579[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state] := exhaleMask#_579[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R := exhaleMask#_579[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_579);
  Mask := exhaleMask#_579;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_582;
  assume IsGoodInhaleState(inhaleHeap#_582, Heap, Mask);
  assume this != null;
  Heap[this, FactorialContChannel.initImpState] := inhaleHeap#_582[this, FactorialContChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_582[this, FactorialContChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FactorialContChannel.initImpState] := Mask[this, FactorialContChannel.initImpState][perm$R := Mask[this, FactorialContChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_582[this, FactorialContChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_582, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FactorialContChannel.initImpState] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_583 := Mask;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The expression at 355.81 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The expression at 355.100 might not evaluate to true."} !(Heap[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 354.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 354.10 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_583[this, FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_583[this, FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.valid][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.valid] := exhaleMask#_583[this, FactorialContChannel.valid][perm$R := exhaleMask#_583[this, FactorialContChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 354.20 might not be positive."} Fractions(100) > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 354.20 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_583[this, FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_583[this, FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.valid][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.valid] := exhaleMask#_583[this, FactorialContChannel.valid][perm$R := exhaleMask#_583[this, FactorialContChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 354.29 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 354.29 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_583[this, FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_583[this, FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.exp][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.exp] := exhaleMask#_583[this, FactorialContChannel.exp][perm$R := exhaleMask#_583[this, FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 354.45 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 354.45 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_583[this, FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_583[this, FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.imp][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.imp] := exhaleMask#_583[this, FactorialContChannel.imp][perm$R := exhaleMask#_583[this, FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 354.61 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 354.61 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 354.83 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 354.83 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 355.6 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 355.6 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_583[this, FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_583[this, FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.exp][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.exp] := exhaleMask#_583[this, FactorialContChannel.exp][perm$R := exhaleMask#_583[this, FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 355.22 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 355.22 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_583[this, FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_583[this, FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.imp][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.imp] := exhaleMask#_583[this, FactorialContChannel.imp][perm$R := exhaleMask#_583[this, FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 355.38 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 355.38 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_583[Heap[this, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 355.60 might not be positive."} monitorK > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 355.60 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_583[Heap[this, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 356.3 might not be positive."} Fractions(100) > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 356.3 for FactorialContChannel.initImpState."} (Fractions(100) <= exhaleMask#_583[this, FactorialContChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_583[this, FactorialContChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.initImpState][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.initImpState] := exhaleMask#_583[this, FactorialContChannel.initImpState][perm$R := exhaleMask#_583[this, FactorialContChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. The permission at 356.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  352.2: The postcondition at 354.10 might not hold. Insufficient fraction at 356.19 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_583[this, FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_583[this, FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_583[this, FactorialContChannel.initExpState][perm$N]));
  exhaleMask#_583[this, FactorialContChannel.initExpState] := exhaleMask#_583[this, FactorialContChannel.initExpState][perm$R := exhaleMask#_583[this, FactorialContChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_583);
  Mask := exhaleMask#_583;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  352.2: Method might lock/unlock more than allowed."} (forall lk#_596: ref :: {Heap[lk#_596, held]} {Heap[lk#_596, rdheld]} (((0 < Heap[lk#_596, held]) == (0 < old(Heap)[lk#_596, held])) && (Heap[lk#_596, rdheld] == old(Heap)[lk#_596, rdheld])) || false);
  assert {:msg "  352.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FutureChannelExpEP#t: TypeName;
procedure FutureChannelExpEP$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_604: int;
  var h0#_597: HeapType;
  var m0#_598: MaskType;
  var c0#_599: CreditsType;
  var h1#_600: HeapType;
  var m1#_601: MaskType;
  var c1#_602: CreditsType;
  var lk#_603: ref;
  assume (0 < methodK#_604) && ((1000 * methodK#_604) < Fractions(1));
  assume wf(h0#_597, m0#_598);
  assume wf(h1#_600, m1#_601);
  m1#_601 := ZeroMask;
  c1#_602 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  386.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FutureChannelExpEP.state: Field (int);
axiom NonPredicateField(FutureChannelExpEP.state);
const unique FutureChannelExpEP.ch: Field (ref);
axiom NonPredicateField(FutureChannelExpEP.ch);
const unique FutureChannelExpEP.expch: Field (ref);
axiom NonPredicateField(FutureChannelExpEP.expch);
const unique FutureChannelExpEP.valid: Field (HeapType);
axiom PredicateField(FutureChannelExpEP.valid);
procedure FutureChannelExpEP.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_605: int;
  var inhaleHeap#_606: HeapType;
  assume (0 < predicateK#_605) && ((1000 * predicateK#_605) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_606;
  assume IsGoodInhaleState(inhaleHeap#_606, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.expch] := inhaleHeap#_606[this, FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannelExpEP.expch] == null) || (dtype(Heap[this, FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FutureChannelExpEP.expch] := Mask[this, FutureChannelExpEP.expch][perm$R := Mask[this, FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[this, FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.ch] := inhaleHeap#_606[this, FutureChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannelExpEP.ch] == null) || (dtype(Heap[this, FutureChannelExpEP.ch]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, FutureChannelExpEP.ch] := Mask[this, FutureChannelExpEP.ch][perm$R := Mask[this, FutureChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[this, FutureChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assert {:msg "  392.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  392.38: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assume !(Heap[this, FutureChannelExpEP.ch] == null);
  assert {:msg "  393.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  393.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assume Heap[this, FutureChannelExpEP.ch] != null;
  Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] := inhaleHeap#_606[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] == null) || (dtype(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assert {:msg "  393.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  393.24: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  393.24: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  393.24: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.imp);
  assume !(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] == null);
  assert {:msg "  393.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  393.43: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assume Heap[this, FutureChannelExpEP.ch] != null;
  Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] := inhaleHeap#_606[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] == null) || (dtype(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assert {:msg "  393.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  393.59: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  393.59: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  393.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.exp);
  assume !(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] == null);
  assert {:msg "  394.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  394.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  394.8: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.imp);
  assume Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] != null;
  Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_606[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assert {:msg "  394.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  394.30: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  394.30: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  394.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.imp);
  assert {:msg "  394.30: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] != null);
  assert {:msg "  394.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assert {:msg "  395.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  395.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  395.8: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.exp);
  assume Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] != null;
  Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_606[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assert {:msg "  395.30: Receiver might be null."} true ==> (this != null);
  assert {:msg "  395.30: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  395.30: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  395.30: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.exp);
  assert {:msg "  395.30: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] != null);
  assert {:msg "  395.30: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assert {:msg "  396.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  396.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  396.8: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.imp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch);
  assume Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := inhaleHeap#_606[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assert {:msg "  396.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  396.36: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
  assert {:msg "  396.36: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.exp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch);
  assume Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := inhaleHeap#_606[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_606[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_606, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelExpEP.sendFinalResult$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t), m#31: ref where (m#31 == null) || (dtype(m#31) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_607: int;
  var inhaleHeap#_608: HeapType;
  var inhaleHeap#_609: HeapType;
  assume (0 < methodK#_607) && ((1000 * methodK#_607) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_608;
  assume IsGoodInhaleState(inhaleHeap#_608, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.state] := inhaleHeap#_608[this, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.state] := Mask[this, FutureChannelExpEP.state][perm$R := Mask[this, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_608[this, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_608, Mask);
  assume m#31 != null;
  Heap[m#31, Message.type] := inhaleHeap#_608[m#31, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#31, Message.type] := Mask[m#31, Message.type][perm$R := Mask[m#31, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_608[m#31, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_608, Mask);
  assume m#31 != null;
  Heap[m#31, Message.type] := inhaleHeap#_608[m#31, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#31, Message.type] := Mask[m#31, Message.type][perm$R := Mask[m#31, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_608[m#31, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_608, Mask);
  assert {:msg "  400.63: Receiver might be null."} true ==> (m#31 != null);
  assert {:msg "  400.63: Location might not be readable."} true ==> CanRead(Mask, m#31, Message.type);
  assume Heap[m#31, Message.type] == 4;
  assert {:msg "  400.76: Receiver might be null."} m#31 != null;
  assume m#31 != null;
  Heap[m#31, Message.invFinalResult] := inhaleHeap#_608[m#31, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_608[m#31, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[m#31, Message.invFinalResult] := Mask[m#31, Message.invFinalResult][perm$R := Mask[m#31, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_608[m#31, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_608, Mask);
  assert {:msg "  401.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_608[this, FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_608[this, FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_608[this, FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_608, Mask);
  assert {:msg "  402.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  402.11: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.state);
  assume Heap[this, FutureChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_609;
  assume IsGoodInhaleState(inhaleHeap#_609, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.state] := inhaleHeap#_609[this, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.state] := Mask[this, FutureChannelExpEP.state][perm$R := Mask[this, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_609[this, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_609, Mask);
  assert {:msg "  403.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_609[this, FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_609[this, FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_609[this, FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_609, Mask);
  assert {:msg "  403.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  403.38: Location might not be readable."} true ==> CanRead(old(Mask), this, FutureChannelExpEP.state);
  if (old(Heap)[this, FutureChannelExpEP.state] == 0) {
    assert {:msg "  403.52: Receiver might be null."} true ==> (this != null);
    assert {:msg "  403.52: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.state);
    assume Heap[this, FutureChannelExpEP.state] == 1;
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelExpEP.sendFinalResult(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t), m#31: ref where (m#31 == null) || (dtype(m#31) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_607: int;
  var inhaleHeap#_610: HeapType;
  var unfoldK#_611: int;
  var exhaleMask#_612: MaskType;
  var inhaleHeap#_614: HeapType;
  var foldK#_615: int;
  var exhaleMask#_616: MaskType;
  var inhaleHeap#_622: HeapType;
  var c#33: ref where (c#33 == null) || (dtype(c#33) == Channel#t);
  var foldK#_623: int;
  var exhaleMask#_624: MaskType;
  var inhaleHeap#_633: HeapType;
  var this#114: ref where (this#114 == null) || (dtype(this#114) == Channel#t);
  var msg#115: ref where (msg#115 == null) || (dtype(msg#115) == Message#t);
  var exhaleMask#_634: MaskType;
  var Heap#_640: HeapType;
  var Mask#_641: MaskType;
  var Credits#_642: CreditsType;
  var exhaleMask#_643: MaskType;
  var exhaleMask#_644: MaskType;
  assume (0 < methodK#_607) && ((1000 * methodK#_607) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_610;
  assume IsGoodInhaleState(inhaleHeap#_610, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.state] := inhaleHeap#_610[this, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.state] := Mask[this, FutureChannelExpEP.state][perm$R := Mask[this, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_610[this, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_610, Mask);
  assume m#31 != null;
  Heap[m#31, Message.type] := inhaleHeap#_610[m#31, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#31, Message.type] := Mask[m#31, Message.type][perm$R := Mask[m#31, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_610[m#31, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_610, Mask);
  assume m#31 != null;
  Heap[m#31, Message.type] := inhaleHeap#_610[m#31, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#31, Message.type] := Mask[m#31, Message.type][perm$R := Mask[m#31, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_610[m#31, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_610, Mask);
  assume Heap[m#31, Message.type] == 4;
  assume m#31 != null;
  Heap[m#31, Message.invFinalResult] := inhaleHeap#_610[m#31, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_610[m#31, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[m#31, Message.invFinalResult] := Mask[m#31, Message.invFinalResult][perm$R := Mask[m#31, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_610[m#31, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_610, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_610[this, FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_610[this, FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_610[this, FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_610, Mask);
  assume Heap[this, FutureChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_611) && (unfoldK#_611 < Fractions(1)) && ((1000 * unfoldK#_611) < methodK#_607);
  assert {:msg "  405.3: The target of the fold statement might be null."} this != null;
  // begin exhale (unfold)
  exhaleMask#_612 := Mask;
  assert {:msg "  405.3: unfold might fail because the predicate FutureChannelExpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  405.3: unfold might fail because the predicate FutureChannelExpEP.valid does not hold. Insufficient fraction at <undefined position> for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_612[this, FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_612[this, FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_612[this, FutureChannelExpEP.valid][perm$N]));
  exhaleMask#_612[this, FutureChannelExpEP.valid] := exhaleMask#_612[this, FutureChannelExpEP.valid][perm$R := exhaleMask#_612[this, FutureChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_612);
  Mask := exhaleMask#_612;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_614 := Heap[this, FutureChannelExpEP.valid];
  assume IsGoodInhaleState(inhaleHeap#_614, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.expch] := inhaleHeap#_614[this, FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannelExpEP.expch] == null) || (dtype(Heap[this, FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FutureChannelExpEP.expch] := Mask[this, FutureChannelExpEP.expch][perm$R := Mask[this, FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[this, FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.ch] := inhaleHeap#_614[this, FutureChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannelExpEP.ch] == null) || (dtype(Heap[this, FutureChannelExpEP.ch]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, FutureChannelExpEP.ch] := Mask[this, FutureChannelExpEP.ch][perm$R := Mask[this, FutureChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[this, FutureChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume !(Heap[this, FutureChannelExpEP.ch] == null);
  assume Heap[this, FutureChannelExpEP.ch] != null;
  Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] := inhaleHeap#_614[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] == null) || (dtype(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume !(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] == null);
  assume Heap[this, FutureChannelExpEP.ch] != null;
  Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] := inhaleHeap#_614[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] == null) || (dtype(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R := Mask[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume !(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] == null);
  assume Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] != null;
  Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_614[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume !(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assume Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] != null;
  Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_614[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume !(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assume Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := inhaleHeap#_614[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := inhaleHeap#_614[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_614[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_614, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // if
  assert {:msg "  406.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  406.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.state);
  if (Heap[this, FutureChannelExpEP.state] == 0) {
    // fold
    assume (0 < foldK#_615) && ((1000 * foldK#_615) < Fractions(1)) && ((1000 * foldK#_615) < methodK#_607);
    assert {:msg "  407.4: The target of the fold statement might be null."} m#31 != null;
    // begin exhale (fold)
    exhaleMask#_616 := Mask;
    if (Heap[m#31, Message.type] == 1) {
    } else {
    }
    if (Heap[m#31, Message.type] == 2) {
    } else {
    }
    if (Heap[m#31, Message.type] == 3) {
    } else {
    }
    if (Heap[m#31, Message.type] == 4) {
    } else {
    }
    assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. The permission at 649.3 might not be positive."} predicateK > 0;
    assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 649.3 for Message.type."} (predicateK <= exhaleMask#_616[m#31, Message.type][perm$R]) && ((predicateK == exhaleMask#_616[m#31, Message.type][perm$R]) ==> (0 <= exhaleMask#_616[m#31, Message.type][perm$N]));
    exhaleMask#_616[m#31, Message.type] := exhaleMask#_616[m#31, Message.type][perm$R := exhaleMask#_616[m#31, Message.type][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_616);
    if (Heap[m#31, Message.type] == 1) {
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. The permission at 650.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 650.16 for Message.invValue."} (Fractions(100) <= exhaleMask#_616[m#31, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_616[m#31, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_616[m#31, Message.invValue][perm$N]));
      exhaleMask#_616[m#31, Message.invValue] := exhaleMask#_616[m#31, Message.invValue][perm$R := exhaleMask#_616[m#31, Message.invValue][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_616);
    } else {
    }
    if (Heap[m#31, Message.type] == 2) {
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. The permission at 651.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 651.16 for Message.invResult1."} (Fractions(100) <= exhaleMask#_616[m#31, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_616[m#31, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_616[m#31, Message.invResult1][perm$N]));
      exhaleMask#_616[m#31, Message.invResult1] := exhaleMask#_616[m#31, Message.invResult1][perm$R := exhaleMask#_616[m#31, Message.invResult1][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_616);
    } else {
    }
    if (Heap[m#31, Message.type] == 3) {
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. The permission at 652.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 652.16 for Message.invResult2."} (Fractions(100) <= exhaleMask#_616[m#31, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_616[m#31, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_616[m#31, Message.invResult2][perm$N]));
      exhaleMask#_616[m#31, Message.invResult2] := exhaleMask#_616[m#31, Message.invResult2][perm$R := exhaleMask#_616[m#31, Message.invResult2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_616);
    } else {
    }
    if (Heap[m#31, Message.type] == 4) {
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. The permission at 653.16 might not be positive."} Fractions(100) > 0;
      assert {:msg "  407.4: Fold might fail because the definition of Message.inv does not hold. Insufficient fraction at 653.16 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_616[m#31, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_616[m#31, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_616[m#31, Message.invFinalResult][perm$N]));
      exhaleMask#_616[m#31, Message.invFinalResult] := exhaleMask#_616[m#31, Message.invFinalResult][perm$R := exhaleMask#_616[m#31, Message.invFinalResult][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_616);
    } else {
    }
    Mask := exhaleMask#_616;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_622;
    assume IsGoodInhaleState(inhaleHeap#_622, Heap, Mask);
    assume m#31 != null;
    Heap[m#31, Message.inv] := inhaleHeap#_622[m#31, Message.inv];
    assume wf(Heap, Mask);
    assume inhaleHeap#_622[m#31, Message.inv] == Heap;
    assume Fractions(100) > 0;
    Mask[m#31, Message.inv] := Mask[m#31, Message.inv][perm$R := Mask[m#31, Message.inv][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_622[m#31, Message.inv]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_622, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[m#31, Message.inv] := Heap;
    assume wf(Heap, Mask);
    // update field state
    assert {:msg "  408.4: Location might not be writable"} CanWrite(Mask, this, FutureChannelExpEP.state);
    Heap[this, FutureChannelExpEP.state] := 1;
    assume wf(Heap, Mask);
    // local var c
    // assigment to c
    assert {:msg "  409.19: Receiver might be null."} true ==> (this != null);
    assert {:msg "  409.19: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.ch);
    assert {:msg "  409.19: Receiver might be null."} true ==> (Heap[this, FutureChannelExpEP.ch] != null);
    assert {:msg "  409.19: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelExpEP.ch], FutureChannel.imp);
    assert {:msg "  409.19: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] != null);
    assert {:msg "  409.19: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch);
    c#33 := Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch];
    // fold
    assume (0 < foldK#_623) && ((1000 * foldK#_623) < Fractions(1)) && ((1000 * foldK#_623) < methodK#_607);
    assert {:msg "  410.4: The target of the fold statement might be null."} this != null;
    // begin exhale (fold)
    exhaleMask#_624 := Mask;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 392.38 might not evaluate to true."} !(Heap[this, FutureChannelExpEP.ch] == null);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 393.24 might not evaluate to true."} !(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] == null);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 393.59 might not evaluate to true."} !(Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] == null);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 394.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 395.30 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 392.5 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 392.5 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_624[this, FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_624[this, FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_624[this, FutureChannelExpEP.expch][perm$N]));
    exhaleMask#_624[this, FutureChannelExpEP.expch] := exhaleMask#_624[this, FutureChannelExpEP.expch][perm$R := exhaleMask#_624[this, FutureChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 392.23 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 392.23 for FutureChannelExpEP.ch."} (monitorK <= exhaleMask#_624[this, FutureChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_624[this, FutureChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_624[this, FutureChannelExpEP.ch][perm$N]));
    exhaleMask#_624[this, FutureChannelExpEP.ch] := exhaleMask#_624[this, FutureChannelExpEP.ch][perm$R := exhaleMask#_624[this, FutureChannelExpEP.ch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 393.5 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 393.5 for FutureChannel.imp."} (monitorK <= exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$N]));
    exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp] := exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R := exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 393.40 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 393.40 for FutureChannel.exp."} (monitorK <= exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$N]));
    exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp] := exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R := exhaleMask#_624[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 394.5 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 394.5 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
    exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 395.5 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 395.5 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
    exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_624[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 396.5 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 396.5 for mu."} (monitorK <= exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$N]));
    exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 396.33 might not be positive."} monitorK > 0;
    assert {:msg "  410.4: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 396.33 for mu."} (monitorK <= exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$N]));
    exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := exhaleMask#_624[Heap[Heap[Heap[this, FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_624);
    Mask := exhaleMask#_624;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (fold)
    havoc inhaleHeap#_633;
    assume IsGoodInhaleState(inhaleHeap#_633, Heap, Mask);
    assume this != null;
    Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_633[this, FutureChannelExpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_633[this, FutureChannelExpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_633[this, FutureChannelExpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_633, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    Heap[this, FutureChannelExpEP.valid] := Heap;
    assume wf(Heap, Mask);
    // send
    assert {:msg "  411.9: The channel might be null."} c#33 != null;
    this#114 := c#33;
    msg#115 := m#31;
    Credits[c#33] := Credits[c#33] + 1;
    // begin exhale (channel where clause)
    exhaleMask#_634 := Mask;
    assert {:msg "  411.4: The where clause at 6.36 might not hold. The expression at 6.36 might not evaluate to true."} !(msg#115 == null);
    assert {:msg "  411.4: The where clause at 6.36 might not hold. The permission at 6.50 might not be positive."} channelK > 0;
    assert {:msg "  411.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.50 for Message.type."} (channelK <= exhaleMask#_634[msg#115, Message.type][perm$R]) && ((channelK == exhaleMask#_634[msg#115, Message.type][perm$R]) ==> (0 <= exhaleMask#_634[msg#115, Message.type][perm$N]));
    exhaleMask#_634[msg#115, Message.type] := exhaleMask#_634[msg#115, Message.type][perm$R := exhaleMask#_634[msg#115, Message.type][perm$R] - channelK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_634);
    assert {:msg "  411.4: The where clause at 6.36 might not hold. The permission at 6.66 might not be positive."} Fractions(100) > 0;
    assert {:msg "  411.4: The where clause at 6.36 might not hold. Insufficient fraction at 6.66 for Message.inv."} (Fractions(100) <= exhaleMask#_634[msg#115, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_634[msg#115, Message.inv][perm$R]) ==> (0 <= exhaleMask#_634[msg#115, Message.inv][perm$N]));
    exhaleMask#_634[msg#115, Message.inv] := exhaleMask#_634[msg#115, Message.inv][perm$R := exhaleMask#_634[msg#115, Message.inv][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_634);
    Mask := exhaleMask#_634;
    assume wf(Heap, Mask);
    // end exhale
  } else {
    // assert
    Heap#_640 := Heap;
    Mask#_641 := Mask;
    Credits#_642 := Credits;
    // begin exhale (assert)
    exhaleMask#_643 := Mask#_641;
    assert {:msg "  414.4: Assertion might not hold. The expression at 414.11 might not evaluate to true."} false;
    Mask#_641 := exhaleMask#_643;
    assume wf(Heap#_640, Mask#_641);
    // end exhale
  }
  // begin exhale (postcondition)
  exhaleMask#_644 := Mask;
  if (old(Heap)[this, FutureChannelExpEP.state] == 0) {
    assert {:msg "  399.2: The postcondition at 403.10 might not hold. The expression at 403.52 might not evaluate to true."} Heap[this, FutureChannelExpEP.state] == 1;
  } else {
  }
  assert {:msg "  399.2: The postcondition at 403.10 might not hold. The permission at 403.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  399.2: The postcondition at 403.10 might not hold. Insufficient fraction at 403.10 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_644[this, FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_644[this, FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_644[this, FutureChannelExpEP.state][perm$N]));
  exhaleMask#_644[this, FutureChannelExpEP.state] := exhaleMask#_644[this, FutureChannelExpEP.state][perm$R := exhaleMask#_644[this, FutureChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_644);
  assert {:msg "  399.2: The postcondition at 403.10 might not hold. The permission at 403.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  399.2: The postcondition at 403.10 might not hold. Insufficient fraction at 403.24 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_644[this, FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_644[this, FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_644[this, FutureChannelExpEP.valid][perm$N]));
  exhaleMask#_644[this, FutureChannelExpEP.valid] := exhaleMask#_644[this, FutureChannelExpEP.valid][perm$R := exhaleMask#_644[this, FutureChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_644);
  if (old(Heap)[this, FutureChannelExpEP.state] == 0) {
  } else {
  }
  Mask := exhaleMask#_644;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  399.2: Method might lock/unlock more than allowed."} (forall lk#_647: ref :: {Heap[lk#_647, held]} {Heap[lk#_647, rdheld]} (((0 < Heap[lk#_647, held]) == (0 < old(Heap)[lk#_647, held])) && (Heap[lk#_647, rdheld] == old(Heap)[lk#_647, rdheld])) || false);
  assert {:msg "  399.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FutureChannelExpEP.receiveFinalResult$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t)) returns (m#34: ref where (m#34 == null) || (dtype(m#34) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_648: int;
  var inhaleHeap#_649: HeapType;
  assume (0 < methodK#_648) && ((1000 * methodK#_648) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_649;
  assume IsGoodInhaleState(inhaleHeap#_649, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FutureChannelExpEP.receiveFinalResult(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t)) returns (m#34: ref where (m#34 == null) || (dtype(m#34) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_648: int;
  var inhaleHeap#_650: HeapType;
  var Heap#_654: HeapType;
  var Mask#_655: MaskType;
  var Credits#_656: CreditsType;
  var exhaleMask#_657: MaskType;
  assume (0 < methodK#_648) && ((1000 * methodK#_648) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_650;
  assume IsGoodInhaleState(inhaleHeap#_650, Heap, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_654 := Heap;
  Mask#_655 := Mask;
  Credits#_656 := Credits;
  // begin exhale (assert)
  exhaleMask#_657 := Mask#_655;
  assert {:msg "  422.3: Assertion might not hold. The expression at 422.10 might not evaluate to true."} false;
  Mask#_655 := exhaleMask#_657;
  assume wf(Heap#_654, Mask#_655);
  // end exhale
  assert {:msg "  419.2: Method might lock/unlock more than allowed."} (forall lk#_658: ref :: {Heap[lk#_658, held]} {Heap[lk#_658, rdheld]} (((0 < Heap[lk#_658, held]) == (0 < old(Heap)[lk#_658, held])) && (Heap[lk#_658, rdheld] == old(Heap)[lk#_658, rdheld])) || false);
  assert {:msg "  419.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FutureChannelExpEP.fail$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t), m#35: ref where (m#35 == null) || (dtype(m#35) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_659: int;
  var inhaleHeap#_660: HeapType;
  var inhaleHeap#_661: HeapType;
  assume (0 < methodK#_659) && ((1000 * methodK#_659) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_660;
  assume IsGoodInhaleState(inhaleHeap#_660, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.state] := inhaleHeap#_660[this, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.state] := Mask[this, FutureChannelExpEP.state][perm$R := Mask[this, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_660[this, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_660, Mask);
  assume m#35 != null;
  Heap[m#35, Message.type] := inhaleHeap#_660[m#35, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#35, Message.type] := Mask[m#35, Message.type][perm$R := Mask[m#35, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_660[m#35, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_660, Mask);
  assert {:msg "  427.45: Receiver might be null."} true ==> (m#35 != null);
  assert {:msg "  427.45: Location might not be readable."} true ==> CanRead(Mask, m#35, Message.type);
  assume Heap[m#35, Message.type] == 4;
  assert {:msg "  428.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_660[this, FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_660[this, FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_660[this, FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_660, Mask);
  assert {:msg "  429.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  429.11: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.state);
  assume !(Heap[this, FutureChannelExpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_661;
  assume IsGoodInhaleState(inhaleHeap#_661, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.state] := inhaleHeap#_661[this, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.state] := Mask[this, FutureChannelExpEP.state][perm$R := Mask[this, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_661[this, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_661, Mask);
  assert {:msg "  430.25: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_661[this, FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_661[this, FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_661[this, FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_661, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelExpEP.fail(this: ref where (this == null) || (dtype(this) == FutureChannelExpEP#t), m#35: ref where (m#35 == null) || (dtype(m#35) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_659: int;
  var inhaleHeap#_662: HeapType;
  var Heap#_666: HeapType;
  var Mask#_667: MaskType;
  var Credits#_668: CreditsType;
  var exhaleMask#_669: MaskType;
  var exhaleMask#_670: MaskType;
  assume (0 < methodK#_659) && ((1000 * methodK#_659) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_662;
  assume IsGoodInhaleState(inhaleHeap#_662, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelExpEP.state] := inhaleHeap#_662[this, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.state] := Mask[this, FutureChannelExpEP.state][perm$R := Mask[this, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_662[this, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_662, Mask);
  assume m#35 != null;
  Heap[m#35, Message.type] := inhaleHeap#_662[m#35, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#35, Message.type] := Mask[m#35, Message.type][perm$R := Mask[m#35, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_662[m#35, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_662, Mask);
  assume Heap[m#35, Message.type] == 4;
  assume this != null;
  Heap[this, FutureChannelExpEP.valid] := inhaleHeap#_662[this, FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_662[this, FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelExpEP.valid] := Mask[this, FutureChannelExpEP.valid][perm$R := Mask[this, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_662[this, FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_662, Mask);
  assume !(Heap[this, FutureChannelExpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  432.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  432.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelExpEP.state);
  if (Heap[this, FutureChannelExpEP.state] == 0) {
    // assert
    Heap#_666 := Heap;
    Mask#_667 := Mask;
    Credits#_668 := Credits;
    // begin exhale (assert)
    exhaleMask#_669 := Mask#_667;
    assert {:msg "  433.4: Assertion might not hold. The expression at 433.11 might not evaluate to true."} false;
    Mask#_667 := exhaleMask#_669;
    assume wf(Heap#_666, Mask#_667);
    // end exhale
  } else {
    // assume
    assume false;
  }
  // begin exhale (postcondition)
  exhaleMask#_670 := Mask;
  assert {:msg "  426.2: The postcondition at 430.11 might not hold. The permission at 430.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  426.2: The postcondition at 430.11 might not hold. Insufficient fraction at 430.11 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_670[this, FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_670[this, FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_670[this, FutureChannelExpEP.state][perm$N]));
  exhaleMask#_670[this, FutureChannelExpEP.state] := exhaleMask#_670[this, FutureChannelExpEP.state][perm$R := exhaleMask#_670[this, FutureChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_670);
  assert {:msg "  426.2: The postcondition at 430.11 might not hold. The permission at 430.25 might not be positive."} Fractions(100) > 0;
  assert {:msg "  426.2: The postcondition at 430.11 might not hold. Insufficient fraction at 430.25 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_670[this, FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_670[this, FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_670[this, FutureChannelExpEP.valid][perm$N]));
  exhaleMask#_670[this, FutureChannelExpEP.valid] := exhaleMask#_670[this, FutureChannelExpEP.valid][perm$R := exhaleMask#_670[this, FutureChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_670);
  Mask := exhaleMask#_670;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  426.2: Method might lock/unlock more than allowed."} (forall lk#_673: ref :: {Heap[lk#_673, held]} {Heap[lk#_673, rdheld]} (((0 < Heap[lk#_673, held]) == (0 < old(Heap)[lk#_673, held])) && (Heap[lk#_673, rdheld] == old(Heap)[lk#_673, rdheld])) || false);
  assert {:msg "  426.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FutureChannelImpEP#t: TypeName;
procedure FutureChannelImpEP$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_681: int;
  var h0#_674: HeapType;
  var m0#_675: MaskType;
  var c0#_676: CreditsType;
  var h1#_677: HeapType;
  var m1#_678: MaskType;
  var c1#_679: CreditsType;
  var lk#_680: ref;
  assume (0 < methodK#_681) && ((1000 * methodK#_681) < Fractions(1));
  assume wf(h0#_674, m0#_675);
  assume wf(h1#_677, m1#_678);
  m1#_678 := ZeroMask;
  c1#_679 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  440.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FutureChannelImpEP.state: Field (int);
axiom NonPredicateField(FutureChannelImpEP.state);
const unique FutureChannelImpEP.ch: Field (ref);
axiom NonPredicateField(FutureChannelImpEP.ch);
const unique FutureChannelImpEP.impch: Field (ref);
axiom NonPredicateField(FutureChannelImpEP.impch);
const unique FutureChannelImpEP.valid: Field (HeapType);
axiom PredicateField(FutureChannelImpEP.valid);
procedure FutureChannelImpEP.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_682: int;
  var inhaleHeap#_683: HeapType;
  assume (0 < predicateK#_682) && ((1000 * predicateK#_682) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_683;
  assume IsGoodInhaleState(inhaleHeap#_683, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.impch] := inhaleHeap#_683[this, FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannelImpEP.impch] == null) || (dtype(Heap[this, FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[this, FutureChannelImpEP.impch] := Mask[this, FutureChannelImpEP.impch][perm$R := Mask[this, FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[this, FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.ch] := inhaleHeap#_683[this, FutureChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannelImpEP.ch] == null) || (dtype(Heap[this, FutureChannelImpEP.ch]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, FutureChannelImpEP.ch] := Mask[this, FutureChannelImpEP.ch][perm$R := Mask[this, FutureChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[this, FutureChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assert {:msg "  446.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  446.36: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assume !(Heap[this, FutureChannelImpEP.ch] == null);
  assert {:msg "  447.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  447.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assume Heap[this, FutureChannelImpEP.ch] != null;
  Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] := inhaleHeap#_683[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] == null) || (dtype(Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] := Mask[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp][perm$R := Mask[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assert {:msg "  447.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  447.22: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  447.22: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  447.22: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.imp);
  assume !(Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] == null);
  assert {:msg "  447.41: Receiver might be null."} true ==> (this != null);
  assert {:msg "  447.41: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assume Heap[this, FutureChannelImpEP.ch] != null;
  Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] := inhaleHeap#_683[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] == null) || (dtype(Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] := Mask[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp][perm$R := Mask[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assert {:msg "  447.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  447.57: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  447.57: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  447.57: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.exp);
  assume !(Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] == null);
  assert {:msg "  448.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  448.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  448.6: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.imp);
  assume Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] != null;
  Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_683[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assert {:msg "  448.28: Receiver might be null."} true ==> (this != null);
  assert {:msg "  448.28: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  448.28: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  448.28: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.imp);
  assert {:msg "  448.28: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] != null);
  assert {:msg "  448.28: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assert {:msg "  449.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  449.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  449.6: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.exp);
  assume Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] != null;
  Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_683[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assert {:msg "  449.28: Receiver might be null."} true ==> (this != null);
  assert {:msg "  449.28: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  449.28: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  449.28: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.exp);
  assert {:msg "  449.28: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] != null);
  assert {:msg "  449.28: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assert {:msg "  450.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  450.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  450.6: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.imp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch);
  assume Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := inhaleHeap#_683[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assert {:msg "  450.34: Receiver might be null."} true ==> (this != null);
  assert {:msg "  450.34: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.ch);
  assert {:msg "  450.34: Receiver might be null."} true ==> (Heap[this, FutureChannelImpEP.ch] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannelImpEP.ch], FutureChannel.exp);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch);
  assume Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := inhaleHeap#_683[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_683[Heap[Heap[Heap[this, FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_683, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelImpEP.sendFinalResult$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t), m#36: ref where (m#36 == null) || (dtype(m#36) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_684: int;
  var inhaleHeap#_685: HeapType;
  var inhaleHeap#_686: HeapType;
  assume (0 < methodK#_684) && ((1000 * methodK#_684) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_685;
  assume IsGoodInhaleState(inhaleHeap#_685, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_685[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_685[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_685, Mask);
  assume m#36 != null;
  Heap[m#36, Message.type] := inhaleHeap#_685[m#36, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#36, Message.type] := Mask[m#36, Message.type][perm$R := Mask[m#36, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_685[m#36, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_685, Mask);
  assert {:msg "  454.45: Receiver might be null."} true ==> (m#36 != null);
  assert {:msg "  454.45: Location might not be readable."} true ==> CanRead(Mask, m#36, Message.type);
  assume Heap[m#36, Message.type] == 4;
  assert {:msg "  454.58: Receiver might be null."} m#36 != null;
  assume m#36 != null;
  Heap[m#36, Message.invFinalResult] := inhaleHeap#_685[m#36, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_685[m#36, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[m#36, Message.invFinalResult] := Mask[m#36, Message.invFinalResult][perm$R := Mask[m#36, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_685[m#36, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_685, Mask);
  assert {:msg "  455.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelImpEP.valid] := inhaleHeap#_685[this, FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_685[this, FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.valid] := Mask[this, FutureChannelImpEP.valid][perm$R := Mask[this, FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_685[this, FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_685, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_686;
  assume IsGoodInhaleState(inhaleHeap#_686, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_686[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_686[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_686, Mask);
  assert {:msg "  457.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelImpEP.valid] := inhaleHeap#_686[this, FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_686[this, FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.valid] := Mask[this, FutureChannelImpEP.valid][perm$R := Mask[this, FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_686[this, FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_686, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelImpEP.sendFinalResult(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t), m#36: ref where (m#36 == null) || (dtype(m#36) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_684: int;
  var inhaleHeap#_687: HeapType;
  var Heap#_691: HeapType;
  var Mask#_692: MaskType;
  var Credits#_693: CreditsType;
  var exhaleMask#_694: MaskType;
  var exhaleMask#_695: MaskType;
  assume (0 < methodK#_684) && ((1000 * methodK#_684) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_687;
  assume IsGoodInhaleState(inhaleHeap#_687, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_687[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_687[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_687, Mask);
  assume m#36 != null;
  Heap[m#36, Message.type] := inhaleHeap#_687[m#36, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#36, Message.type] := Mask[m#36, Message.type][perm$R := Mask[m#36, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_687[m#36, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_687, Mask);
  assume Heap[m#36, Message.type] == 4;
  assume m#36 != null;
  Heap[m#36, Message.invFinalResult] := inhaleHeap#_687[m#36, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_687[m#36, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[m#36, Message.invFinalResult] := Mask[m#36, Message.invFinalResult][perm$R := Mask[m#36, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_687[m#36, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_687, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.valid] := inhaleHeap#_687[this, FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_687[this, FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.valid] := Mask[this, FutureChannelImpEP.valid][perm$R := Mask[this, FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_687[this, FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_687, Mask);
  assume false;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // assert
  Heap#_691 := Heap;
  Mask#_692 := Mask;
  Credits#_693 := Credits;
  // begin exhale (assert)
  exhaleMask#_694 := Mask#_692;
  assert {:msg "  459.3: Assertion might not hold. The expression at 459.10 might not evaluate to true."} false;
  Mask#_692 := exhaleMask#_694;
  assume wf(Heap#_691, Mask#_692);
  // end exhale
  // begin exhale (postcondition)
  exhaleMask#_695 := Mask;
  assert {:msg "  453.2: The postcondition at 457.10 might not hold. The permission at 457.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  453.2: The postcondition at 457.10 might not hold. Insufficient fraction at 457.10 for FutureChannelImpEP.state."} (Fractions(100) <= exhaleMask#_695[this, FutureChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_695[this, FutureChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_695[this, FutureChannelImpEP.state][perm$N]));
  exhaleMask#_695[this, FutureChannelImpEP.state] := exhaleMask#_695[this, FutureChannelImpEP.state][perm$R := exhaleMask#_695[this, FutureChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_695);
  assert {:msg "  453.2: The postcondition at 457.10 might not hold. The permission at 457.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  453.2: The postcondition at 457.10 might not hold. Insufficient fraction at 457.24 for FutureChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_695[this, FutureChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_695[this, FutureChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_695[this, FutureChannelImpEP.valid][perm$N]));
  exhaleMask#_695[this, FutureChannelImpEP.valid] := exhaleMask#_695[this, FutureChannelImpEP.valid][perm$R := exhaleMask#_695[this, FutureChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_695);
  Mask := exhaleMask#_695;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  453.2: Method might lock/unlock more than allowed."} (forall lk#_698: ref :: {Heap[lk#_698, held]} {Heap[lk#_698, rdheld]} (((0 < Heap[lk#_698, held]) == (0 < old(Heap)[lk#_698, held])) && (Heap[lk#_698, rdheld] == old(Heap)[lk#_698, rdheld])) || false);
  assert {:msg "  453.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FutureChannelImpEP.receiveFinalResult$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t), mi#37: ref where (mi#37 == null) || (dtype(mi#37) == Message#t)) returns (mo#38: ref where (mo#38 == null) || (dtype(mo#38) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_699: int;
  var inhaleHeap#_700: HeapType;
  var inhaleHeap#_701: HeapType;
  assume (0 < methodK#_699) && ((1000 * methodK#_699) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_700;
  assume IsGoodInhaleState(inhaleHeap#_700, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_700[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_700[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_700, Mask);
  assume !(mi#37 == null);
  assume mi#37 != null;
  Heap[mi#37, Message.type] := inhaleHeap#_700[mi#37, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#37, Message.type] := Mask[mi#37, Message.type][perm$R := Mask[mi#37, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_700[mi#37, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_700, Mask);
  assert {:msg "  466.57: Receiver might be null."} true ==> (mi#37 != null);
  assert {:msg "  466.57: Location might not be readable."} true ==> CanRead(Mask, mi#37, Message.type);
  assume Heap[mi#37, Message.type] == 4;
  assert {:msg "  466.71: Receiver might be null."} mi#37 != null;
  assume mi#37 != null;
  Heap[mi#37, Message.inv] := inhaleHeap#_700[mi#37, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_700[mi#37, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#37, Message.inv] := Mask[mi#37, Message.inv][perm$R := Mask[mi#37, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_700[mi#37, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_700, Mask);
  assert {:msg "  467.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  467.11: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.state);
  assume Heap[this, FutureChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_701;
  assume IsGoodInhaleState(inhaleHeap#_701, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_701[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_701[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_701, Mask);
  assert {:msg "  468.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  468.24: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.state);
  assume Heap[this, FutureChannelImpEP.state] == 1;
  assume mo#38 != null;
  Heap[mo#38, Message.type] := inhaleHeap#_701[mo#38, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mo#38, Message.type] := Mask[mo#38, Message.type][perm$R := Mask[mo#38, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_701[mo#38, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_701, Mask);
  assume mo#38 == mi#37;
  assert {:msg "  468.66: Receiver might be null."} true ==> (mo#38 != null);
  assert {:msg "  468.66: Location might not be readable."} true ==> CanRead(Mask, mo#38, Message.type);
  assume Heap[mo#38, Message.type] == 4;
  assert {:msg "  468.80: Receiver might be null."} mo#38 != null;
  assume mo#38 != null;
  Heap[mo#38, Message.invFinalResult] := inhaleHeap#_701[mo#38, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_701[mo#38, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[mo#38, Message.invFinalResult] := Mask[mo#38, Message.invFinalResult][perm$R := Mask[mo#38, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_701[mo#38, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_701, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelImpEP.receiveFinalResult(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t), mi#37: ref where (mi#37 == null) || (dtype(mi#37) == Message#t)) returns (mo#38: ref where (mo#38 == null) || (dtype(mo#38) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_699: int;
  var inhaleHeap#_702: HeapType;
  var unfoldK#_703: int;
  var exhaleMask#_704: MaskType;
  var inhaleHeap#_706: HeapType;
  var Heap#_710: HeapType;
  var Mask#_711: MaskType;
  var Credits#_712: CreditsType;
  var exhaleMask#_713: MaskType;
  var exhaleMask#_714: MaskType;
  assume (0 < methodK#_699) && ((1000 * methodK#_699) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_702;
  assume IsGoodInhaleState(inhaleHeap#_702, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_702[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_702[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_702, Mask);
  assume !(mi#37 == null);
  assume mi#37 != null;
  Heap[mi#37, Message.type] := inhaleHeap#_702[mi#37, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[mi#37, Message.type] := Mask[mi#37, Message.type][perm$R := Mask[mi#37, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_702[mi#37, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_702, Mask);
  assume Heap[mi#37, Message.type] == 4;
  assume mi#37 != null;
  Heap[mi#37, Message.inv] := inhaleHeap#_702[mi#37, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_702[mi#37, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[mi#37, Message.inv] := Mask[mi#37, Message.inv][perm$R := Mask[mi#37, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_702[mi#37, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_702, Mask);
  assume Heap[this, FutureChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  470.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  470.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.state);
  if (Heap[this, FutureChannelImpEP.state] == 0) {
    // unfold
    assume (0 < unfoldK#_703) && (unfoldK#_703 < Fractions(1)) && ((1000 * unfoldK#_703) < methodK#_699);
    assert {:msg "  471.4: The target of the fold statement might be null."} mi#37 != null;
    // begin exhale (unfold)
    exhaleMask#_704 := Mask;
    assert {:msg "  471.4: unfold might fail because the predicate Message.inv does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
    assert {:msg "  471.4: unfold might fail because the predicate Message.inv does not hold. Insufficient fraction at <undefined position> for Message.inv."} (Fractions(100) <= exhaleMask#_704[mi#37, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_704[mi#37, Message.inv][perm$R]) ==> (0 <= exhaleMask#_704[mi#37, Message.inv][perm$N]));
    exhaleMask#_704[mi#37, Message.inv] := exhaleMask#_704[mi#37, Message.inv][perm$R := exhaleMask#_704[mi#37, Message.inv][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_704);
    Mask := exhaleMask#_704;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (unfold)
    inhaleHeap#_706 := Heap[mi#37, Message.inv];
    assume IsGoodInhaleState(inhaleHeap#_706, Heap, Mask);
    assume mi#37 != null;
    Heap[mi#37, Message.type] := inhaleHeap#_706[mi#37, Message.type];
    assume wf(Heap, Mask);
    assume true;
    assume predicateK > 0;
    Mask[mi#37, Message.type] := Mask[mi#37, Message.type][perm$R := Mask[mi#37, Message.type][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_706[mi#37, Message.type]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_706, Mask);
    if (Heap[mi#37, Message.type] == 1) {
      assume mi#37 != null;
      Heap[mi#37, Message.invValue] := inhaleHeap#_706[mi#37, Message.invValue];
      assume wf(Heap, Mask);
      assume inhaleHeap#_706[mi#37, Message.invValue] == Heap;
      assume Fractions(100) > 0;
      Mask[mi#37, Message.invValue] := Mask[mi#37, Message.invValue][perm$R := Mask[mi#37, Message.invValue][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_706[mi#37, Message.invValue]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_706, Mask);
    } else {
    }
    if (Heap[mi#37, Message.type] == 2) {
      assume mi#37 != null;
      Heap[mi#37, Message.invResult1] := inhaleHeap#_706[mi#37, Message.invResult1];
      assume wf(Heap, Mask);
      assume inhaleHeap#_706[mi#37, Message.invResult1] == Heap;
      assume Fractions(100) > 0;
      Mask[mi#37, Message.invResult1] := Mask[mi#37, Message.invResult1][perm$R := Mask[mi#37, Message.invResult1][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_706[mi#37, Message.invResult1]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_706, Mask);
    } else {
    }
    if (Heap[mi#37, Message.type] == 3) {
      assume mi#37 != null;
      Heap[mi#37, Message.invResult2] := inhaleHeap#_706[mi#37, Message.invResult2];
      assume wf(Heap, Mask);
      assume inhaleHeap#_706[mi#37, Message.invResult2] == Heap;
      assume Fractions(100) > 0;
      Mask[mi#37, Message.invResult2] := Mask[mi#37, Message.invResult2][perm$R := Mask[mi#37, Message.invResult2][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_706[mi#37, Message.invResult2]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_706, Mask);
    } else {
    }
    if (Heap[mi#37, Message.type] == 4) {
      assume mi#37 != null;
      Heap[mi#37, Message.invFinalResult] := inhaleHeap#_706[mi#37, Message.invFinalResult];
      assume wf(Heap, Mask);
      assume inhaleHeap#_706[mi#37, Message.invFinalResult] == Heap;
      assume Fractions(100) > 0;
      Mask[mi#37, Message.invFinalResult] := Mask[mi#37, Message.invFinalResult][perm$R := Mask[mi#37, Message.invFinalResult][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_706[mi#37, Message.invFinalResult]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_706, Mask);
    } else {
    }
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // update field state
    assert {:msg "  472.4: Location might not be writable"} CanWrite(Mask, this, FutureChannelImpEP.state);
    Heap[this, FutureChannelImpEP.state] := 1;
    assume wf(Heap, Mask);
  } else {
    // assert
    Heap#_710 := Heap;
    Mask#_711 := Mask;
    Credits#_712 := Credits;
    // begin exhale (assert)
    exhaleMask#_713 := Mask#_711;
    assert {:msg "  476.4: Assertion might not hold. The expression at 476.11 might not evaluate to true."} false;
    Mask#_711 := exhaleMask#_713;
    assume wf(Heap#_710, Mask#_711);
    // end exhale
  }
  // assigment to mo
  mo#38 := mi#37;
  // begin exhale (postcondition)
  exhaleMask#_714 := Mask;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. The expression at 468.24 might not evaluate to true."} Heap[this, FutureChannelImpEP.state] == 1;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. The expression at 468.56 might not evaluate to true."} mo#38 == mi#37;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. The expression at 468.66 might not evaluate to true."} Heap[mo#38, Message.type] == 4;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. The permission at 468.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. Insufficient fraction at 468.10 for FutureChannelImpEP.state."} (Fractions(100) <= exhaleMask#_714[this, FutureChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_714[this, FutureChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_714[this, FutureChannelImpEP.state][perm$N]));
  exhaleMask#_714[this, FutureChannelImpEP.state] := exhaleMask#_714[this, FutureChannelImpEP.state][perm$R := exhaleMask#_714[this, FutureChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_714);
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. The permission at 468.36 might not be positive."} monitorK > 0;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. Insufficient fraction at 468.36 for Message.type."} (monitorK <= exhaleMask#_714[mo#38, Message.type][perm$R]) && ((monitorK == exhaleMask#_714[mo#38, Message.type][perm$R]) ==> (0 <= exhaleMask#_714[mo#38, Message.type][perm$N]));
  exhaleMask#_714[mo#38, Message.type] := exhaleMask#_714[mo#38, Message.type][perm$R := exhaleMask#_714[mo#38, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_714);
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. The permission at 468.80 might not be positive."} Fractions(100) > 0;
  assert {:msg "  465.2: The postcondition at 468.10 might not hold. Insufficient fraction at 468.80 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_714[mo#38, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_714[mo#38, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_714[mo#38, Message.invFinalResult][perm$N]));
  exhaleMask#_714[mo#38, Message.invFinalResult] := exhaleMask#_714[mo#38, Message.invFinalResult][perm$R := exhaleMask#_714[mo#38, Message.invFinalResult][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_714);
  Mask := exhaleMask#_714;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  465.2: Method might lock/unlock more than allowed."} (forall lk#_718: ref :: {Heap[lk#_718, held]} {Heap[lk#_718, rdheld]} (((0 < Heap[lk#_718, held]) == (0 < old(Heap)[lk#_718, held])) && (Heap[lk#_718, rdheld] == old(Heap)[lk#_718, rdheld])) || false);
  assert {:msg "  465.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FutureChannelImpEP.fail$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t), m#39: ref where (m#39 == null) || (dtype(m#39) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_719: int;
  var inhaleHeap#_720: HeapType;
  var inhaleHeap#_721: HeapType;
  assume (0 < methodK#_719) && ((1000 * methodK#_719) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_720;
  assume IsGoodInhaleState(inhaleHeap#_720, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_720[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_720[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_720, Mask);
  assume m#39 != null;
  Heap[m#39, Message.type] := inhaleHeap#_720[m#39, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#39, Message.type] := Mask[m#39, Message.type][perm$R := Mask[m#39, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_720[m#39, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_720, Mask);
  assert {:msg "  483.44: Receiver might be null."} true ==> (m#39 != null);
  assert {:msg "  483.44: Location might not be readable."} true ==> CanRead(Mask, m#39, Message.type);
  assume Heap[m#39, Message.type] == 4;
  assert {:msg "  484.11: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelImpEP.valid] := inhaleHeap#_720[this, FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_720[this, FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.valid] := Mask[this, FutureChannelImpEP.valid][perm$R := Mask[this, FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_720[this, FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_720, Mask);
  assert {:msg "  485.11: Receiver might be null."} true ==> (this != null);
  assert {:msg "  485.11: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.state);
  assume !(Heap[this, FutureChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_721;
  assume IsGoodInhaleState(inhaleHeap#_721, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_721[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_721[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_721, Mask);
  assert {:msg "  486.24: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannelImpEP.valid] := inhaleHeap#_721[this, FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_721[this, FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.valid] := Mask[this, FutureChannelImpEP.valid][perm$R := Mask[this, FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_721[this, FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_721, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannelImpEP.fail(this: ref where (this == null) || (dtype(this) == FutureChannelImpEP#t), m#39: ref where (m#39 == null) || (dtype(m#39) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_719: int;
  var inhaleHeap#_722: HeapType;
  var Heap#_726: HeapType;
  var Mask#_727: MaskType;
  var Credits#_728: CreditsType;
  var exhaleMask#_729: MaskType;
  var exhaleMask#_730: MaskType;
  assume (0 < methodK#_719) && ((1000 * methodK#_719) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_722;
  assume IsGoodInhaleState(inhaleHeap#_722, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannelImpEP.state] := inhaleHeap#_722[this, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.state] := Mask[this, FutureChannelImpEP.state][perm$R := Mask[this, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_722[this, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_722, Mask);
  assume m#39 != null;
  Heap[m#39, Message.type] := inhaleHeap#_722[m#39, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[m#39, Message.type] := Mask[m#39, Message.type][perm$R := Mask[m#39, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_722[m#39, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_722, Mask);
  assume Heap[m#39, Message.type] == 4;
  assume this != null;
  Heap[this, FutureChannelImpEP.valid] := inhaleHeap#_722[this, FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_722[this, FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannelImpEP.valid] := Mask[this, FutureChannelImpEP.valid][perm$R := Mask[this, FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_722[this, FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_722, Mask);
  assume !(Heap[this, FutureChannelImpEP.state] == 0);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  488.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  488.6: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannelImpEP.state);
  if (Heap[this, FutureChannelImpEP.state] == 0) {
    // assert
    Heap#_726 := Heap;
    Mask#_727 := Mask;
    Credits#_728 := Credits;
    // begin exhale (assert)
    exhaleMask#_729 := Mask#_727;
    assert {:msg "  489.4: Assertion might not hold. The expression at 489.11 might not evaluate to true."} false;
    Mask#_727 := exhaleMask#_729;
    assume wf(Heap#_726, Mask#_727);
    // end exhale
  } else {
    // assume
    assume false;
  }
  // begin exhale (postcondition)
  exhaleMask#_730 := Mask;
  assert {:msg "  482.2: The postcondition at 486.10 might not hold. The permission at 486.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  482.2: The postcondition at 486.10 might not hold. Insufficient fraction at 486.10 for FutureChannelImpEP.state."} (Fractions(100) <= exhaleMask#_730[this, FutureChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_730[this, FutureChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_730[this, FutureChannelImpEP.state][perm$N]));
  exhaleMask#_730[this, FutureChannelImpEP.state] := exhaleMask#_730[this, FutureChannelImpEP.state][perm$R := exhaleMask#_730[this, FutureChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_730);
  assert {:msg "  482.2: The postcondition at 486.10 might not hold. The permission at 486.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  482.2: The postcondition at 486.10 might not hold. Insufficient fraction at 486.24 for FutureChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_730[this, FutureChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_730[this, FutureChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_730[this, FutureChannelImpEP.valid][perm$N]));
  exhaleMask#_730[this, FutureChannelImpEP.valid] := exhaleMask#_730[this, FutureChannelImpEP.valid][perm$R := exhaleMask#_730[this, FutureChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_730);
  Mask := exhaleMask#_730;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  482.2: Method might lock/unlock more than allowed."} (forall lk#_733: ref :: {Heap[lk#_733, held]} {Heap[lk#_733, rdheld]} (((0 < Heap[lk#_733, held]) == (0 < old(Heap)[lk#_733, held])) && (Heap[lk#_733, rdheld] == old(Heap)[lk#_733, rdheld])) || false);
  assert {:msg "  482.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FutureChannel#t: TypeName;
procedure FutureChannel$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_741: int;
  var h0#_734: HeapType;
  var m0#_735: MaskType;
  var c0#_736: CreditsType;
  var h1#_737: HeapType;
  var m1#_738: MaskType;
  var c1#_739: CreditsType;
  var lk#_740: ref;
  assume (0 < methodK#_741) && ((1000 * methodK#_741) < Fractions(1));
  assume wf(h0#_734, m0#_735);
  assume wf(h1#_737, m1#_738);
  m1#_738 := ZeroMask;
  c1#_739 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  497.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FutureChannel.imp: Field (ref);
axiom NonPredicateField(FutureChannel.imp);
const unique FutureChannel.exp: Field (ref);
axiom NonPredicateField(FutureChannel.exp);
const unique FutureChannel.valid: Field (HeapType);
axiom PredicateField(FutureChannel.valid);
procedure FutureChannel.valid$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_742: int;
  var inhaleHeap#_743: HeapType;
  assume (0 < predicateK#_742) && ((1000 * predicateK#_742) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_743;
  assume IsGoodInhaleState(inhaleHeap#_743, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.imp] := inhaleHeap#_743[this, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.imp] == null) || (dtype(Heap[this, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.imp] := Mask[this, FutureChannel.imp][perm$R := Mask[this, FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_743[this, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_743, Mask);
  assume this != null;
  Heap[this, FutureChannel.exp] := inhaleHeap#_743[this, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.exp] == null) || (dtype(Heap[this, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.exp] := Mask[this, FutureChannel.exp][perm$R := Mask[this, FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_743[this, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_743, Mask);
  assert {:msg "  502.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  502.38: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := inhaleHeap#_743[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] == null) || (dtype(Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_743[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_743, Mask);
  assert {:msg "  502.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  502.57: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := inhaleHeap#_743[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] == null) || (dtype(Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_743[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_743, Mask);
  assert {:msg "  503.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assume !(Heap[this, FutureChannel.imp] == null);
  assert {:msg "  503.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.16: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assume !(Heap[this, FutureChannel.exp] == null);
  assert {:msg "  503.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.29: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  503.29: Receiver might be null."} Heap[this, FutureChannel.imp] != null;
  assert {:msg "  503.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.29: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := inhaleHeap#_743[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_743[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_743[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_743, Mask);
  assert {:msg "  503.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.42: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  503.42: Receiver might be null."} Heap[this, FutureChannel.exp] != null;
  assert {:msg "  503.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.42: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := inhaleHeap#_743[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_743[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_743[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_743, Mask);
  assert {:msg "  503.55: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.55: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  503.55: Receiver might be null."} true ==> (Heap[this, FutureChannel.imp] != null);
  assert {:msg "  503.55: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannel.imp], FutureChannelImpEP.ch);
  assume Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] == this;
  assert {:msg "  503.70: Receiver might be null."} true ==> (this != null);
  assert {:msg "  503.70: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  503.70: Receiver might be null."} true ==> (Heap[this, FutureChannel.exp] != null);
  assert {:msg "  503.70: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannel.exp], FutureChannelExpEP.ch);
  assume Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] == this;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FutureChannel.initImpState: Field (HeapType);
axiom PredicateField(FutureChannel.initImpState);
procedure FutureChannel.initImpState$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_744: int;
  var inhaleHeap#_745: HeapType;
  assume (0 < predicateK#_744) && ((1000 * predicateK#_744) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_745;
  assume IsGoodInhaleState(inhaleHeap#_745, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.imp] := inhaleHeap#_745[this, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.imp] == null) || (dtype(Heap[this, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.imp] := Mask[this, FutureChannel.imp][perm$R := Mask[this, FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_745[this, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_745, Mask);
  assert {:msg "  507.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  507.23: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.state] := inhaleHeap#_745[Heap[this, FutureChannel.imp], FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.state] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_745[Heap[this, FutureChannel.imp], FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_745, Mask);
  assert {:msg "  507.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  507.37: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  507.37: Receiver might be null."} true ==> (Heap[this, FutureChannel.imp] != null);
  assert {:msg "  507.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannel.imp], FutureChannelImpEP.state);
  assume Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique FutureChannel.initExpState: Field (HeapType);
axiom PredicateField(FutureChannel.initExpState);
procedure FutureChannel.initExpState$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannel#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_746: int;
  var inhaleHeap#_747: HeapType;
  assume (0 < predicateK#_746) && ((1000 * predicateK#_746) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_747;
  assume IsGoodInhaleState(inhaleHeap#_747, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.exp] := inhaleHeap#_747[this, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.exp] == null) || (dtype(Heap[this, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.exp] := Mask[this, FutureChannel.exp][perm$R := Mask[this, FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_747[this, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_747, Mask);
  assert {:msg "  510.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  510.23: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.state] := inhaleHeap#_747[Heap[this, FutureChannel.exp], FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.state] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_747[Heap[this, FutureChannel.exp], FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_747, Mask);
  assert {:msg "  510.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  510.37: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  510.37: Receiver might be null."} true ==> (Heap[this, FutureChannel.exp] != null);
  assert {:msg "  510.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FutureChannel.exp], FutureChannelExpEP.state);
  assume Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannel.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == FutureChannel#t), i#40: ref where (i#40 == null) || (dtype(i#40) == FutureChannelImpEP#t), e#41: ref where (e#41 == null) || (dtype(e#41) == FutureChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_748: int;
  var inhaleHeap#_749: HeapType;
  var inhaleHeap#_750: HeapType;
  assume (0 < methodK#_748) && ((1000 * methodK#_748) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_749;
  assume IsGoodInhaleState(inhaleHeap#_749, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.imp] := inhaleHeap#_749[this, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.imp] == null) || (dtype(Heap[this, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.imp] := Mask[this, FutureChannel.imp][perm$R := Mask[this, FutureChannel.imp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[this, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume i#40 != null;
  Heap[i#40, FutureChannelImpEP.ch] := inhaleHeap#_749[i#40, FutureChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[i#40, FutureChannelImpEP.ch] == null) || (dtype(Heap[i#40, FutureChannelImpEP.ch]) == FutureChannel#t);
  assume Fractions(100) > 0;
  Mask[i#40, FutureChannelImpEP.ch] := Mask[i#40, FutureChannelImpEP.ch][perm$R := Mask[i#40, FutureChannelImpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[i#40, FutureChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume this != null;
  Heap[this, FutureChannel.exp] := inhaleHeap#_749[this, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.exp] == null) || (dtype(Heap[this, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.exp] := Mask[this, FutureChannel.exp][perm$R := Mask[this, FutureChannel.exp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[this, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume e#41 != null;
  Heap[e#41, FutureChannelExpEP.ch] := inhaleHeap#_749[e#41, FutureChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[e#41, FutureChannelExpEP.ch] == null) || (dtype(Heap[e#41, FutureChannelExpEP.ch]) == FutureChannel#t);
  assume Fractions(100) > 0;
  Mask[e#41, FutureChannelExpEP.ch] := Mask[e#41, FutureChannelExpEP.ch][perm$R := Mask[e#41, FutureChannelExpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[e#41, FutureChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume e#41 != null;
  Heap[e#41, FutureChannelExpEP.expch] := inhaleHeap#_749[e#41, FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[e#41, FutureChannelExpEP.expch] == null) || (dtype(Heap[e#41, FutureChannelExpEP.expch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[e#41, FutureChannelExpEP.expch] := Mask[e#41, FutureChannelExpEP.expch][perm$R := Mask[e#41, FutureChannelExpEP.expch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[e#41, FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume i#40 != null;
  Heap[i#40, FutureChannelImpEP.impch] := inhaleHeap#_749[i#40, FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[i#40, FutureChannelImpEP.impch] == null) || (dtype(Heap[i#40, FutureChannelImpEP.impch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[i#40, FutureChannelImpEP.impch] := Mask[i#40, FutureChannelImpEP.impch][perm$R := Mask[i#40, FutureChannelImpEP.impch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[i#40, FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume i#40 != null;
  Heap[i#40, FutureChannelImpEP.state] := inhaleHeap#_749[i#40, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[i#40, FutureChannelImpEP.state] := Mask[i#40, FutureChannelImpEP.state][perm$R := Mask[i#40, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[i#40, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume e#41 != null;
  Heap[e#41, FutureChannelExpEP.state] := inhaleHeap#_749[e#41, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[e#41, FutureChannelExpEP.state] := Mask[e#41, FutureChannelExpEP.state][perm$R := Mask[e#41, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_749[e#41, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_749, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_750;
  assume IsGoodInhaleState(inhaleHeap#_750, Heap, Mask);
  assert {:msg "  516.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannel.valid] := inhaleHeap#_750[this, FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_750[this, FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.valid] := Mask[this, FutureChannel.valid][perm$R := Mask[this, FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  516.19: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannel.valid] := inhaleHeap#_750[this, FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_750[this, FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.valid] := Mask[this, FutureChannel.valid][perm$R := Mask[this, FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assume this != null;
  Heap[this, FutureChannel.exp] := inhaleHeap#_750[this, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.exp] == null) || (dtype(Heap[this, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.exp] := Mask[this, FutureChannel.exp][perm$R := Mask[this, FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assume this != null;
  Heap[this, FutureChannel.imp] := inhaleHeap#_750[this, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.imp] == null) || (dtype(Heap[this, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.imp] := Mask[this, FutureChannel.imp][perm$R := Mask[this, FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  516.63: Receiver might be null."} true ==> (this != null);
  assert {:msg "  516.63: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_750[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  516.85: Receiver might be null."} true ==> (this != null);
  assert {:msg "  516.85: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_750[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assume this != null;
  Heap[this, FutureChannel.exp] := inhaleHeap#_750[this, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.exp] == null) || (dtype(Heap[this, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.exp] := Mask[this, FutureChannel.exp][perm$R := Mask[this, FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assume this != null;
  Heap[this, FutureChannel.imp] := inhaleHeap#_750[this, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.imp] == null) || (dtype(Heap[this, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[this, FutureChannel.imp] := Mask[this, FutureChannel.imp][perm$R := Mask[this, FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  517.41: Receiver might be null."} true ==> (this != null);
  assert {:msg "  517.41: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_750[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  517.63: Receiver might be null."} true ==> (this != null);
  assert {:msg "  517.63: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_750[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  517.82: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannel.initImpState] := inhaleHeap#_750[this, FutureChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_750[this, FutureChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.initImpState] := Mask[this, FutureChannel.initImpState][perm$R := Mask[this, FutureChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assert {:msg "  517.98: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, FutureChannel.initExpState] := inhaleHeap#_750[this, FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_750[this, FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.initExpState] := Mask[this, FutureChannel.initExpState][perm$R := Mask[this, FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_750[this, FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_750, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FutureChannel.init(this: ref where (this == null) || (dtype(this) == FutureChannel#t), i#40: ref where (i#40 == null) || (dtype(i#40) == FutureChannelImpEP#t), e#41: ref where (e#41 == null) || (dtype(e#41) == FutureChannelExpEP#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_748: int;
  var inhaleHeap#_751: HeapType;
  var nw#_752: ref;
  var mu#_753: Mu;
  var nw#_755: ref;
  var mu#_756: Mu;
  var foldK#_758: int;
  var exhaleMask#_759: MaskType;
  var inhaleHeap#_768: HeapType;
  var foldK#_769: int;
  var exhaleMask#_770: MaskType;
  var inhaleHeap#_779: HeapType;
  var foldK#_780: int;
  var exhaleMask#_781: MaskType;
  var inhaleHeap#_790: HeapType;
  var foldK#_791: int;
  var exhaleMask#_792: MaskType;
  var inhaleHeap#_801: HeapType;
  var foldK#_802: int;
  var exhaleMask#_803: MaskType;
  var inhaleHeap#_810: HeapType;
  var foldK#_811: int;
  var exhaleMask#_812: MaskType;
  var inhaleHeap#_819: HeapType;
  var foldK#_820: int;
  var exhaleMask#_821: MaskType;
  var inhaleHeap#_824: HeapType;
  var foldK#_825: int;
  var exhaleMask#_826: MaskType;
  var inhaleHeap#_829: HeapType;
  var exhaleMask#_830: MaskType;
  assume (0 < methodK#_748) && ((1000 * methodK#_748) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_751;
  assume IsGoodInhaleState(inhaleHeap#_751, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.imp] := inhaleHeap#_751[this, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.imp] == null) || (dtype(Heap[this, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.imp] := Mask[this, FutureChannel.imp][perm$R := Mask[this, FutureChannel.imp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[this, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume i#40 != null;
  Heap[i#40, FutureChannelImpEP.ch] := inhaleHeap#_751[i#40, FutureChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[i#40, FutureChannelImpEP.ch] == null) || (dtype(Heap[i#40, FutureChannelImpEP.ch]) == FutureChannel#t);
  assume Fractions(100) > 0;
  Mask[i#40, FutureChannelImpEP.ch] := Mask[i#40, FutureChannelImpEP.ch][perm$R := Mask[i#40, FutureChannelImpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[i#40, FutureChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume this != null;
  Heap[this, FutureChannel.exp] := inhaleHeap#_751[this, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this, FutureChannel.exp] == null) || (dtype(Heap[this, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.exp] := Mask[this, FutureChannel.exp][perm$R := Mask[this, FutureChannel.exp][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[this, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume e#41 != null;
  Heap[e#41, FutureChannelExpEP.ch] := inhaleHeap#_751[e#41, FutureChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[e#41, FutureChannelExpEP.ch] == null) || (dtype(Heap[e#41, FutureChannelExpEP.ch]) == FutureChannel#t);
  assume Fractions(100) > 0;
  Mask[e#41, FutureChannelExpEP.ch] := Mask[e#41, FutureChannelExpEP.ch][perm$R := Mask[e#41, FutureChannelExpEP.ch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[e#41, FutureChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume e#41 != null;
  Heap[e#41, FutureChannelExpEP.expch] := inhaleHeap#_751[e#41, FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[e#41, FutureChannelExpEP.expch] == null) || (dtype(Heap[e#41, FutureChannelExpEP.expch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[e#41, FutureChannelExpEP.expch] := Mask[e#41, FutureChannelExpEP.expch][perm$R := Mask[e#41, FutureChannelExpEP.expch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[e#41, FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume i#40 != null;
  Heap[i#40, FutureChannelImpEP.impch] := inhaleHeap#_751[i#40, FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[i#40, FutureChannelImpEP.impch] == null) || (dtype(Heap[i#40, FutureChannelImpEP.impch]) == Channel#t);
  assume Fractions(100) > 0;
  Mask[i#40, FutureChannelImpEP.impch] := Mask[i#40, FutureChannelImpEP.impch][perm$R := Mask[i#40, FutureChannelImpEP.impch][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[i#40, FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume i#40 != null;
  Heap[i#40, FutureChannelImpEP.state] := inhaleHeap#_751[i#40, FutureChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[i#40, FutureChannelImpEP.state] := Mask[i#40, FutureChannelImpEP.state][perm$R := Mask[i#40, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[i#40, FutureChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume e#41 != null;
  Heap[e#41, FutureChannelExpEP.state] := inhaleHeap#_751[e#41, FutureChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[e#41, FutureChannelExpEP.state] := Mask[e#41, FutureChannelExpEP.state][perm$R := Mask[e#41, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_751[e#41, FutureChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_751, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field imp
  assert {:msg "  519.3: Location might not be writable"} CanWrite(Mask, this, FutureChannel.imp);
  Heap[this, FutureChannel.imp] := i#40;
  assume wf(Heap, Mask);
  // update field exp
  assert {:msg "  520.3: Location might not be writable"} CanWrite(Mask, this, FutureChannel.exp);
  Heap[this, FutureChannel.exp] := e#41;
  assume wf(Heap, Mask);
  // update field ch
  assert {:msg "  521.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  521.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  521.3: Location might not be writable"} CanWrite(Mask, Heap[this, FutureChannel.imp], FutureChannelImpEP.ch);
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := this;
  assume wf(Heap, Mask);
  // update field ch
  assert {:msg "  522.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  522.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  522.3: Location might not be writable"} CanWrite(Mask, Heap[this, FutureChannel.exp], FutureChannelExpEP.ch);
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := this;
  assume wf(Heap, Mask);
  // update field impch
  assert {:msg "  523.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  523.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  523.3: Location might not be writable"} CanWrite(Mask, Heap[this, FutureChannel.imp], FutureChannelImpEP.impch);
  // new
  havoc nw#_752;
  assume (nw#_752 != null) && (dtype(nw#_752) == Channel#t);
  assume (forall<T#_4> f: Field (T#_4) :: (Mask[nw#_752, f][perm$R] == 0) && (Mask[nw#_752, f][perm$N] == 0));
  havoc mu#_753;
  assume mu#_753 != $LockBottom;
  assume (forall o#_754: ref :: (((0 < Heap[o#_754, held]) || Heap[o#_754, rdheld]) || (Credits[o#_754] < 0)) ==> MuBelow(Heap[o#_754, mu], mu#_753));
  assume Heap[nw#_752, mu] == mu#_753;
  assume Heap[nw#_752, held] <= 0;
  assume Heap[nw#_752, rdheld] == false;
  Mask[nw#_752, mu] := Mask[nw#_752, mu][perm$R := Mask[nw#_752, mu][perm$R] + Fractions(100)];
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := nw#_752;
  assume wf(Heap, Mask);
  // update field expch
  assert {:msg "  524.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  524.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  524.3: Location might not be writable"} CanWrite(Mask, Heap[this, FutureChannel.exp], FutureChannelExpEP.expch);
  // new
  havoc nw#_755;
  assume (nw#_755 != null) && (dtype(nw#_755) == Channel#t);
  assume (forall<T#_5> f: Field (T#_5) :: (Mask[nw#_755, f][perm$R] == 0) && (Mask[nw#_755, f][perm$N] == 0));
  havoc mu#_756;
  assume mu#_756 != $LockBottom;
  assume (forall o#_757: ref :: (((0 < Heap[o#_757, held]) || Heap[o#_757, rdheld]) || (Credits[o#_757] < 0)) ==> MuBelow(Heap[o#_757, mu], mu#_756));
  assume Heap[nw#_755, mu] == mu#_756;
  assume Heap[nw#_755, held] <= 0;
  assume Heap[nw#_755, rdheld] == false;
  Mask[nw#_755, mu] := Mask[nw#_755, mu][perm$R := Mask[nw#_755, mu][perm$R] + Fractions(100)];
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := nw#_755;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_758) && ((1000 * foldK#_758) < Fractions(1)) && ((1000 * foldK#_758) < methodK#_748);
  assert {:msg "  525.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  525.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  525.3: The target of the fold statement might be null."} Heap[this, FutureChannel.imp] != null;
  // begin exhale (fold)
  exhaleMask#_759 := Mask;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 446.36 might not evaluate to true."} !(Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] == null);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 447.22 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] == null);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 447.57 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] == null);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 448.28 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 449.28 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 446.3 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 446.3 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 446.21 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 446.21 for FutureChannelImpEP.ch."} (monitorK <= exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$N]));
  exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R := exhaleMask#_759[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 447.3 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 447.3 for FutureChannel.imp."} (monitorK <= exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$N]));
  exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] := exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R := exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 447.38 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 447.38 for FutureChannel.exp."} (monitorK <= exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$N]));
  exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] := exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R := exhaleMask#_759[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 448.3 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 448.3 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 449.3 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 449.3 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_759[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 450.3 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 450.3 for mu."} (monitorK <= exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 450.31 might not be positive."} monitorK > 0;
  assert {:msg "  525.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 450.31 for mu."} (monitorK <= exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := exhaleMask#_759[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_759);
  Mask := exhaleMask#_759;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_768;
  assume IsGoodInhaleState(inhaleHeap#_768, Heap, Mask);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := inhaleHeap#_768[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_768[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_768[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_768, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_769) && ((1000 * foldK#_769) < Fractions(1)) && ((1000 * foldK#_769) < methodK#_748);
  assert {:msg "  526.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  526.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  526.3: The target of the fold statement might be null."} Heap[this, FutureChannel.exp] != null;
  // begin exhale (fold)
  exhaleMask#_770 := Mask;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 392.38 might not evaluate to true."} !(Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] == null);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 393.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp] == null);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 393.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp] == null);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 394.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 395.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 392.5 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 392.5 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 392.23 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 392.23 for FutureChannelExpEP.ch."} (monitorK <= exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$N]));
  exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R := exhaleMask#_770[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 393.5 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 393.5 for FutureChannel.imp."} (monitorK <= exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$N]));
  exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp] := exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R := exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 393.40 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 393.40 for FutureChannel.exp."} (monitorK <= exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$N]));
  exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp] := exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R := exhaleMask#_770[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 394.5 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 394.5 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 395.5 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 395.5 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_770[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 396.5 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 396.5 for mu."} (monitorK <= exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 396.33 might not be positive."} monitorK > 0;
  assert {:msg "  526.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 396.33 for mu."} (monitorK <= exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := exhaleMask#_770[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_770);
  Mask := exhaleMask#_770;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_779;
  assume IsGoodInhaleState(inhaleHeap#_779, Heap, Mask);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := inhaleHeap#_779[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_779[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_779[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_779, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_780) && ((1000 * foldK#_780) < Fractions(1)) && ((1000 * foldK#_780) < methodK#_748);
  assert {:msg "  527.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  527.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  527.3: The target of the fold statement might be null."} Heap[this, FutureChannel.imp] != null;
  // begin exhale (fold)
  exhaleMask#_781 := Mask;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 446.36 might not evaluate to true."} !(Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] == null);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 447.22 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] == null);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 447.57 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] == null);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 448.28 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The expression at 449.28 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 446.3 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 446.3 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 446.21 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 446.21 for FutureChannelImpEP.ch."} (monitorK <= exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$N]));
  exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R := exhaleMask#_781[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 447.3 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 447.3 for FutureChannel.imp."} (monitorK <= exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$N]));
  exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] := exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R := exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 447.38 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 447.38 for FutureChannel.exp."} (monitorK <= exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$N]));
  exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] := exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R := exhaleMask#_781[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 448.3 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 448.3 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 449.3 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 449.3 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_781[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 450.3 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 450.3 for mu."} (monitorK <= exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. The permission at 450.31 might not be positive."} monitorK > 0;
  assert {:msg "  527.3: Fold might fail because the definition of FutureChannelImpEP.valid does not hold. Insufficient fraction at 450.31 for mu."} (monitorK <= exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := exhaleMask#_781[Heap[Heap[Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_781);
  Mask := exhaleMask#_781;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_790;
  assume IsGoodInhaleState(inhaleHeap#_790, Heap, Mask);
  assume Heap[this, FutureChannel.imp] != null;
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := inhaleHeap#_790[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_790[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R := Mask[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_790[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_790, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_791) && ((1000 * foldK#_791) < Fractions(1)) && ((1000 * foldK#_791) < methodK#_748);
  assert {:msg "  528.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  528.8: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  528.3: The target of the fold statement might be null."} Heap[this, FutureChannel.exp] != null;
  // begin exhale (fold)
  exhaleMask#_792 := Mask;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 392.38 might not evaluate to true."} !(Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] == null);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 393.24 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp] == null);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 393.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp] == null);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 394.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The expression at 395.30 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 392.5 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 392.5 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 392.23 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 392.23 for FutureChannelExpEP.ch."} (monitorK <= exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$N]));
  exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R := exhaleMask#_792[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 393.5 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 393.5 for FutureChannel.imp."} (monitorK <= exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$N]));
  exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp] := exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R := exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 393.40 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 393.40 for FutureChannel.exp."} (monitorK <= exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$N]));
  exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp] := exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R := exhaleMask#_792[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 394.5 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 394.5 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 395.5 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 395.5 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_792[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 396.5 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 396.5 for mu."} (monitorK <= exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. The permission at 396.33 might not be positive."} monitorK > 0;
  assert {:msg "  528.3: Fold might fail because the definition of FutureChannelExpEP.valid does not hold. Insufficient fraction at 396.33 for mu."} (monitorK <= exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) && ((monitorK == exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R]) ==> (0 <= exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$N]));
  exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := exhaleMask#_792[Heap[Heap[Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_792);
  Mask := exhaleMask#_792;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_801;
  assume IsGoodInhaleState(inhaleHeap#_801, Heap, Mask);
  assume Heap[this, FutureChannel.exp] != null;
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := inhaleHeap#_801[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_801[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R := Mask[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_801[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_801, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_802) && ((1000 * foldK#_802) < Fractions(1)) && ((1000 * foldK#_802) < methodK#_748);
  assert {:msg "  529.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_803 := Mask;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.3 might not evaluate to true."} !(Heap[this, FutureChannel.imp] == null);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.16 might not evaluate to true."} !(Heap[this, FutureChannel.exp] == null);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.55 might not evaluate to true."} Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] == this;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.70 might not evaluate to true."} Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] == this;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.3 might not be positive."} monitorK > 0;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.3 for FutureChannel.imp."} (monitorK <= exhaleMask#_803[this, FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_803[this, FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_803[this, FutureChannel.imp][perm$N]));
  exhaleMask#_803[this, FutureChannel.imp] := exhaleMask#_803[this, FutureChannel.imp][perm$R := exhaleMask#_803[this, FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_803);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.19 might not be positive."} monitorK > 0;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.19 for FutureChannel.exp."} (monitorK <= exhaleMask#_803[this, FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_803[this, FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_803[this, FutureChannel.exp][perm$N]));
  exhaleMask#_803[this, FutureChannel.exp] := exhaleMask#_803[this, FutureChannel.exp][perm$R := exhaleMask#_803[this, FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_803);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.35 might not be positive."} monitorK > 0;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.35 for FutureChannelImpEP.ch."} (monitorK <= exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$N]));
  exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R := exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_803);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.54 might not be positive."} monitorK > 0;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.54 for FutureChannelExpEP.ch."} (monitorK <= exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$N]));
  exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R := exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_803);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 503.29 might not be positive."} Fractions(100) > 0;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 503.29 for FutureChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$N]));
  exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R := exhaleMask#_803[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_803);
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 503.42 might not be positive."} Fractions(100) > 0;
  assert {:msg "  529.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 503.42 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$N]));
  exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R := exhaleMask#_803[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_803);
  Mask := exhaleMask#_803;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_810;
  assume IsGoodInhaleState(inhaleHeap#_810, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.valid] := inhaleHeap#_810[this, FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_810[this, FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.valid] := Mask[this, FutureChannel.valid][perm$R := Mask[this, FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_810[this, FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_810, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FutureChannel.valid] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_811) && ((1000 * foldK#_811) < Fractions(1)) && ((1000 * foldK#_811) < methodK#_748);
  assert {:msg "  530.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_812 := Mask;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.3 might not evaluate to true."} !(Heap[this, FutureChannel.imp] == null);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.16 might not evaluate to true."} !(Heap[this, FutureChannel.exp] == null);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.55 might not evaluate to true."} Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] == this;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The expression at 503.70 might not evaluate to true."} Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] == this;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.3 might not be positive."} monitorK > 0;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.3 for FutureChannel.imp."} (monitorK <= exhaleMask#_812[this, FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_812[this, FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_812[this, FutureChannel.imp][perm$N]));
  exhaleMask#_812[this, FutureChannel.imp] := exhaleMask#_812[this, FutureChannel.imp][perm$R := exhaleMask#_812[this, FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_812);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.19 might not be positive."} monitorK > 0;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.19 for FutureChannel.exp."} (monitorK <= exhaleMask#_812[this, FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_812[this, FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_812[this, FutureChannel.exp][perm$N]));
  exhaleMask#_812[this, FutureChannel.exp] := exhaleMask#_812[this, FutureChannel.exp][perm$R := exhaleMask#_812[this, FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_812);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.35 might not be positive."} monitorK > 0;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.35 for FutureChannelImpEP.ch."} (monitorK <= exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$N]));
  exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch] := exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R := exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_812);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 502.54 might not be positive."} monitorK > 0;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 502.54 for FutureChannelExpEP.ch."} (monitorK <= exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) && ((monitorK == exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$N]));
  exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch] := exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R := exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_812);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 503.29 might not be positive."} Fractions(100) > 0;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 503.29 for FutureChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$N]));
  exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid] := exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R := exhaleMask#_812[Heap[this, FutureChannel.imp], FutureChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_812);
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. The permission at 503.42 might not be positive."} Fractions(100) > 0;
  assert {:msg "  530.3: Fold might fail because the definition of FutureChannel.valid does not hold. Insufficient fraction at 503.42 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$N]));
  exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid] := exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R := exhaleMask#_812[Heap[this, FutureChannel.exp], FutureChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_812);
  Mask := exhaleMask#_812;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_819;
  assume IsGoodInhaleState(inhaleHeap#_819, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.valid] := inhaleHeap#_819[this, FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_819[this, FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.valid] := Mask[this, FutureChannel.valid][perm$R := Mask[this, FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_819[this, FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_819, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FutureChannel.valid] := Heap;
  assume wf(Heap, Mask);
  // update field state
  assert {:msg "  532.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  532.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.imp);
  assert {:msg "  532.3: Location might not be writable"} CanWrite(Mask, Heap[this, FutureChannel.imp], FutureChannelImpEP.state);
  Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.state] := 0;
  assume wf(Heap, Mask);
  // update field state
  assert {:msg "  533.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  533.3: Location might not be readable."} true ==> CanRead(Mask, this, FutureChannel.exp);
  assert {:msg "  533.3: Location might not be writable"} CanWrite(Mask, Heap[this, FutureChannel.exp], FutureChannelExpEP.state);
  Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.state] := 0;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_820) && ((1000 * foldK#_820) < Fractions(1)) && ((1000 * foldK#_820) < methodK#_748);
  assert {:msg "  534.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_821 := Mask;
  assert {:msg "  534.3: Fold might fail because the definition of FutureChannel.initImpState does not hold. The expression at 507.37 might not evaluate to true."} Heap[Heap[this, FutureChannel.imp], FutureChannelImpEP.state] == 0;
  assert {:msg "  534.3: Fold might fail because the definition of FutureChannel.initImpState does not hold. The permission at 507.3 might not be positive."} monitorK > 0;
  assert {:msg "  534.3: Fold might fail because the definition of FutureChannel.initImpState does not hold. Insufficient fraction at 507.3 for FutureChannel.imp."} (monitorK <= exhaleMask#_821[this, FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_821[this, FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_821[this, FutureChannel.imp][perm$N]));
  exhaleMask#_821[this, FutureChannel.imp] := exhaleMask#_821[this, FutureChannel.imp][perm$R := exhaleMask#_821[this, FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_821);
  assert {:msg "  534.3: Fold might fail because the definition of FutureChannel.initImpState does not hold. The permission at 507.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  534.3: Fold might fail because the definition of FutureChannel.initImpState does not hold. Insufficient fraction at 507.19 for FutureChannelImpEP.state."} (Fractions(100) <= exhaleMask#_821[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_821[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_821[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$N]));
  exhaleMask#_821[Heap[this, FutureChannel.imp], FutureChannelImpEP.state] := exhaleMask#_821[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$R := exhaleMask#_821[Heap[this, FutureChannel.imp], FutureChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_821);
  Mask := exhaleMask#_821;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_824;
  assume IsGoodInhaleState(inhaleHeap#_824, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.initImpState] := inhaleHeap#_824[this, FutureChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_824[this, FutureChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.initImpState] := Mask[this, FutureChannel.initImpState][perm$R := Mask[this, FutureChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_824[this, FutureChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_824, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FutureChannel.initImpState] := Heap;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_825) && ((1000 * foldK#_825) < Fractions(1)) && ((1000 * foldK#_825) < methodK#_748);
  assert {:msg "  535.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_826 := Mask;
  assert {:msg "  535.3: Fold might fail because the definition of FutureChannel.initExpState does not hold. The expression at 510.37 might not evaluate to true."} Heap[Heap[this, FutureChannel.exp], FutureChannelExpEP.state] == 0;
  assert {:msg "  535.3: Fold might fail because the definition of FutureChannel.initExpState does not hold. The permission at 510.3 might not be positive."} monitorK > 0;
  assert {:msg "  535.3: Fold might fail because the definition of FutureChannel.initExpState does not hold. Insufficient fraction at 510.3 for FutureChannel.exp."} (monitorK <= exhaleMask#_826[this, FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_826[this, FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_826[this, FutureChannel.exp][perm$N]));
  exhaleMask#_826[this, FutureChannel.exp] := exhaleMask#_826[this, FutureChannel.exp][perm$R := exhaleMask#_826[this, FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_826);
  assert {:msg "  535.3: Fold might fail because the definition of FutureChannel.initExpState does not hold. The permission at 510.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  535.3: Fold might fail because the definition of FutureChannel.initExpState does not hold. Insufficient fraction at 510.19 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_826[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_826[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_826[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$N]));
  exhaleMask#_826[Heap[this, FutureChannel.exp], FutureChannelExpEP.state] := exhaleMask#_826[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$R := exhaleMask#_826[Heap[this, FutureChannel.exp], FutureChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_826);
  Mask := exhaleMask#_826;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_829;
  assume IsGoodInhaleState(inhaleHeap#_829, Heap, Mask);
  assume this != null;
  Heap[this, FutureChannel.initExpState] := inhaleHeap#_829[this, FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_829[this, FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this, FutureChannel.initExpState] := Mask[this, FutureChannel.initExpState][perm$R := Mask[this, FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_829[this, FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_829, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, FutureChannel.initExpState] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_830 := Mask;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 516.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 516.10 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_830[this, FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_830[this, FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.valid][perm$N]));
  exhaleMask#_830[this, FutureChannel.valid] := exhaleMask#_830[this, FutureChannel.valid][perm$R := exhaleMask#_830[this, FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 516.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 516.19 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_830[this, FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_830[this, FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.valid][perm$N]));
  exhaleMask#_830[this, FutureChannel.valid] := exhaleMask#_830[this, FutureChannel.valid][perm$R := exhaleMask#_830[this, FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 516.28 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 516.28 for FutureChannel.exp."} (monitorK <= exhaleMask#_830[this, FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_830[this, FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.exp][perm$N]));
  exhaleMask#_830[this, FutureChannel.exp] := exhaleMask#_830[this, FutureChannel.exp][perm$R := exhaleMask#_830[this, FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 516.44 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 516.44 for FutureChannel.imp."} (monitorK <= exhaleMask#_830[this, FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_830[this, FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.imp][perm$N]));
  exhaleMask#_830[this, FutureChannel.imp] := exhaleMask#_830[this, FutureChannel.imp][perm$R := exhaleMask#_830[this, FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 516.60 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 516.60 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 516.82 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 516.82 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 517.6 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 517.6 for FutureChannel.exp."} (monitorK <= exhaleMask#_830[this, FutureChannel.exp][perm$R]) && ((monitorK == exhaleMask#_830[this, FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.exp][perm$N]));
  exhaleMask#_830[this, FutureChannel.exp] := exhaleMask#_830[this, FutureChannel.exp][perm$R := exhaleMask#_830[this, FutureChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 517.22 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 517.22 for FutureChannel.imp."} (monitorK <= exhaleMask#_830[this, FutureChannel.imp][perm$R]) && ((monitorK == exhaleMask#_830[this, FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.imp][perm$N]));
  exhaleMask#_830[this, FutureChannel.imp] := exhaleMask#_830[this, FutureChannel.imp][perm$R := exhaleMask#_830[this, FutureChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 517.38 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 517.38 for FutureChannelExpEP.expch."} (monitorK <= exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch] := exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := exhaleMask#_830[Heap[this, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 517.60 might not be positive."} monitorK > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 517.60 for FutureChannelImpEP.impch."} (monitorK <= exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch] := exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := exhaleMask#_830[Heap[this, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 517.82 might not be positive."} Fractions(100) > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 517.82 for FutureChannel.initImpState."} (Fractions(100) <= exhaleMask#_830[this, FutureChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_830[this, FutureChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.initImpState][perm$N]));
  exhaleMask#_830[this, FutureChannel.initImpState] := exhaleMask#_830[this, FutureChannel.initImpState][perm$R := exhaleMask#_830[this, FutureChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. The permission at 517.98 might not be positive."} Fractions(100) > 0;
  assert {:msg "  514.2: The postcondition at 516.10 might not hold. Insufficient fraction at 517.98 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_830[this, FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_830[this, FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_830[this, FutureChannel.initExpState][perm$N]));
  exhaleMask#_830[this, FutureChannel.initExpState] := exhaleMask#_830[this, FutureChannel.initExpState][perm$R := exhaleMask#_830[this, FutureChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_830);
  Mask := exhaleMask#_830;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  514.2: Method might lock/unlock more than allowed."} (forall lk#_843: ref :: {Heap[lk#_843, held]} {Heap[lk#_843, rdheld]} (((0 < Heap[lk#_843, held]) == (0 < old(Heap)[lk#_843, held])) && (Heap[lk#_843, rdheld] == old(Heap)[lk#_843, rdheld])) || false);
  assert {:msg "  514.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique Future#t: TypeName;
procedure Future$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == Future#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_851: int;
  var h0#_844: HeapType;
  var m0#_845: MaskType;
  var c0#_846: CreditsType;
  var h1#_847: HeapType;
  var m1#_848: MaskType;
  var c1#_849: CreditsType;
  var lk#_850: ref;
  assume (0 < methodK#_851) && ((1000 * methodK#_851) < Fractions(1));
  assume wf(h0#_844, m0#_845);
  assume wf(h1#_847, m1#_848);
  m1#_848 := ZeroMask;
  c1#_849 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  544.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique Future.sent: Field (ref);
axiom NonPredicateField(Future.sent);
const unique Future.value: Field (ref);
axiom NonPredicateField(Future.value);
const unique Future.q: Field (ref);
axiom NonPredicateField(Future.q);
procedure Future.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == Future#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_852: int;
  var inhaleHeap#_853: HeapType;
  var inhaleHeap#_854: HeapType;
  assume (0 < methodK#_852) && ((1000 * methodK#_852) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_853;
  assume IsGoodInhaleState(inhaleHeap#_853, Heap, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_853[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume Fractions(100) > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_853[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_853, Mask);
  assume this != null;
  Heap[this, Future.value] := inhaleHeap#_853[this, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.value] == null) || (dtype(Heap[this, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this, Future.value] := Mask[this, Future.value][perm$R := Mask[this, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_853[this, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_853, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_854;
  assume IsGoodInhaleState(inhaleHeap#_854, Heap, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_854[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_854[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_854, Mask);
  assume this != null;
  Heap[this, Future.value] := inhaleHeap#_854[this, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.value] == null) || (dtype(Heap[this, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this, Future.value] := Mask[this, Future.value][perm$R := Mask[this, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_854[this, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_854, Mask);
  assert {:msg "  551.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  551.38: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume !(Heap[this, Future.q] == null);
  assert {:msg "  552.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.10: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assert {:msg "  552.10: Receiver might be null."} Heap[this, Future.q] != null;
  assert {:msg "  552.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.10: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume Heap[this, Future.q] != null;
  Heap[Heap[this, Future.q], FutureChannel.valid] := inhaleHeap#_854[Heap[this, Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_854[Heap[this, Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.q], FutureChannel.valid] := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_854[Heap[this, Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_854, Mask);
  assert {:msg "  552.21: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.21: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assert {:msg "  552.21: Receiver might be null."} Heap[this, Future.q] != null;
  assert {:msg "  552.21: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.21: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume Heap[this, Future.q] != null;
  Heap[Heap[this, Future.q], FutureChannel.initExpState] := inhaleHeap#_854[Heap[this, Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_854[Heap[this, Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.q], FutureChannel.initExpState] := Mask[Heap[this, Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[this, Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_854[Heap[this, Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_854, Mask);
  assert {:msg "  552.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.39: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assert {:msg "  552.39: Receiver might be null."} Heap[this, Future.q] != null;
  assert {:msg "  552.39: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.39: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume Heap[this, Future.q] != null;
  Heap[Heap[this, Future.q], FutureChannel.initImpState] := inhaleHeap#_854[Heap[this, Future.q], FutureChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_854[Heap[this, Future.q], FutureChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.q], FutureChannel.initImpState] := Mask[Heap[this, Future.q], FutureChannel.initImpState][perm$R := Mask[Heap[this, Future.q], FutureChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_854[Heap[this, Future.q], FutureChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_854, Mask);
  assert {:msg "  552.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  552.57: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume Heap[this, Future.value] == null;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Future.init(this: ref where (this == null) || (dtype(this) == Future#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_852: int;
  var inhaleHeap#_855: HeapType;
  var imp#43: ref where (imp#43 == null) || (dtype(imp#43) == FutureChannelImpEP#t);
  var nw#_856: ref;
  var exp#45: ref where (exp#45 == null) || (dtype(exp#45) == FutureChannelExpEP#t);
  var nw#_857: ref;
  var nw#_858: ref;
  var methodCallK#_862: int;
  var this#116: ref where (this#116 == null) || (dtype(this#116) == FutureChannel#t);
  var i#117: ref where (i#117 == null) || (dtype(i#117) == FutureChannelImpEP#t);
  var e#118: ref where (e#118 == null) || (dtype(e#118) == FutureChannelExpEP#t);
  var callHeap#_859: HeapType;
  var callMask#_860: MaskType;
  var callCredits#_861: CreditsType;
  var exhaleMask#_863: MaskType;
  var isHeld#_872: int;
  var isRdHeld#_873: bool;
  var inhaleHeap#_874: HeapType;
  var exhaleMask#_875: MaskType;
  assume (0 < methodK#_852) && ((1000 * methodK#_852) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_855;
  assume IsGoodInhaleState(inhaleHeap#_855, Heap, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_855[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume Fractions(100) > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_855[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_855, Mask);
  assume this != null;
  Heap[this, Future.value] := inhaleHeap#_855[this, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.value] == null) || (dtype(Heap[this, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this, Future.value] := Mask[this, Future.value][perm$R := Mask[this, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_855[this, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_855, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var imp
  // assigment to imp
  // new
  havoc nw#_856;
  assume (nw#_856 != null) && (dtype(nw#_856) == FutureChannelImpEP#t);
  assume (forall<T#_6> f: Field (T#_6) :: (Mask[nw#_856, f][perm$R] == 0) && (Mask[nw#_856, f][perm$N] == 0));
  assume Heap[nw#_856, mu] == $LockBottom;
  assume Heap[nw#_856, held] <= 0;
  assume Heap[nw#_856, rdheld] == false;
  Mask[nw#_856, FutureChannelImpEP.state] := Mask[nw#_856, FutureChannelImpEP.state][perm$R := Mask[nw#_856, FutureChannelImpEP.state][perm$R] + Fractions(100)];
  Mask[nw#_856, FutureChannelImpEP.ch] := Mask[nw#_856, FutureChannelImpEP.ch][perm$R := Mask[nw#_856, FutureChannelImpEP.ch][perm$R] + Fractions(100)];
  Mask[nw#_856, FutureChannelImpEP.impch] := Mask[nw#_856, FutureChannelImpEP.impch][perm$R := Mask[nw#_856, FutureChannelImpEP.impch][perm$R] + Fractions(100)];
  Mask[nw#_856, mu] := Mask[nw#_856, mu][perm$R := Mask[nw#_856, mu][perm$R] + Fractions(100)];
  imp#43 := nw#_856;
  // local var exp
  // assigment to exp
  // new
  havoc nw#_857;
  assume (nw#_857 != null) && (dtype(nw#_857) == FutureChannelExpEP#t);
  assume (forall<T#_7> f: Field (T#_7) :: (Mask[nw#_857, f][perm$R] == 0) && (Mask[nw#_857, f][perm$N] == 0));
  assume Heap[nw#_857, mu] == $LockBottom;
  assume Heap[nw#_857, held] <= 0;
  assume Heap[nw#_857, rdheld] == false;
  Mask[nw#_857, FutureChannelExpEP.state] := Mask[nw#_857, FutureChannelExpEP.state][perm$R := Mask[nw#_857, FutureChannelExpEP.state][perm$R] + Fractions(100)];
  Mask[nw#_857, FutureChannelExpEP.ch] := Mask[nw#_857, FutureChannelExpEP.ch][perm$R := Mask[nw#_857, FutureChannelExpEP.ch][perm$R] + Fractions(100)];
  Mask[nw#_857, FutureChannelExpEP.expch] := Mask[nw#_857, FutureChannelExpEP.expch][perm$R := Mask[nw#_857, FutureChannelExpEP.expch][perm$R] + Fractions(100)];
  Mask[nw#_857, mu] := Mask[nw#_857, mu][perm$R := Mask[nw#_857, mu][perm$R] + Fractions(100)];
  exp#45 := nw#_857;
  // update field q
  assert {:msg "  556.3: Location might not be writable"} CanWrite(Mask, this, Future.q);
  // new
  havoc nw#_858;
  assume (nw#_858 != null) && (dtype(nw#_858) == FutureChannel#t);
  assume (forall<T#_8> f: Field (T#_8) :: (Mask[nw#_858, f][perm$R] == 0) && (Mask[nw#_858, f][perm$N] == 0));
  assume Heap[nw#_858, mu] == $LockBottom;
  assume Heap[nw#_858, held] <= 0;
  assume Heap[nw#_858, rdheld] == false;
  Mask[nw#_858, FutureChannel.imp] := Mask[nw#_858, FutureChannel.imp][perm$R := Mask[nw#_858, FutureChannel.imp][perm$R] + Fractions(100)];
  Mask[nw#_858, FutureChannel.exp] := Mask[nw#_858, FutureChannel.exp][perm$R := Mask[nw#_858, FutureChannel.exp][perm$R] + Fractions(100)];
  Mask[nw#_858, mu] := Mask[nw#_858, mu][perm$R := Mask[nw#_858, mu][perm$R] + Fractions(100)];
  Heap[this, Future.q] := nw#_858;
  assume wf(Heap, Mask);
  assume (0 < methodCallK#_862) && ((1000 * methodCallK#_862) < Fractions(1)) && ((1000 * methodCallK#_862) < methodK#_852);
  // call init
  callHeap#_859 := Heap;
  callMask#_860 := Mask;
  callCredits#_861 := Credits;
  assert {:msg "  557.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  557.8: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assert {:msg "  557.3: The target of the method call might be null."} Heap[this, Future.q] != null;
  this#116 := Heap[this, Future.q];
  i#117 := imp#43;
  e#118 := exp#45;
  // begin exhale (precondition)
  exhaleMask#_863 := Mask;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.11 for FutureChannel.imp."} (Fractions(100) <= exhaleMask#_863[this#116, FutureChannel.imp][perm$R]) && ((Fractions(100) == exhaleMask#_863[this#116, FutureChannel.imp][perm$R]) ==> (0 <= exhaleMask#_863[this#116, FutureChannel.imp][perm$N]));
  exhaleMask#_863[this#116, FutureChannel.imp] := exhaleMask#_863[this#116, FutureChannel.imp][perm$R := exhaleMask#_863[this#116, FutureChannel.imp][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.23 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.23 for FutureChannelImpEP.ch."} (Fractions(100) <= exhaleMask#_863[i#117, FutureChannelImpEP.ch][perm$R]) && ((Fractions(100) == exhaleMask#_863[i#117, FutureChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_863[i#117, FutureChannelImpEP.ch][perm$N]));
  exhaleMask#_863[i#117, FutureChannelImpEP.ch] := exhaleMask#_863[i#117, FutureChannelImpEP.ch][perm$R := exhaleMask#_863[i#117, FutureChannelImpEP.ch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.36 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.36 for FutureChannel.exp."} (Fractions(100) <= exhaleMask#_863[this#116, FutureChannel.exp][perm$R]) && ((Fractions(100) == exhaleMask#_863[this#116, FutureChannel.exp][perm$R]) ==> (0 <= exhaleMask#_863[this#116, FutureChannel.exp][perm$N]));
  exhaleMask#_863[this#116, FutureChannel.exp] := exhaleMask#_863[this#116, FutureChannel.exp][perm$R := exhaleMask#_863[this#116, FutureChannel.exp][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.48 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.48 for FutureChannelExpEP.ch."} (Fractions(100) <= exhaleMask#_863[e#118, FutureChannelExpEP.ch][perm$R]) && ((Fractions(100) == exhaleMask#_863[e#118, FutureChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_863[e#118, FutureChannelExpEP.ch][perm$N]));
  exhaleMask#_863[e#118, FutureChannelExpEP.ch] := exhaleMask#_863[e#118, FutureChannelExpEP.ch][perm$R := exhaleMask#_863[e#118, FutureChannelExpEP.ch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.61 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.61 for FutureChannelExpEP.expch."} (Fractions(100) <= exhaleMask#_863[e#118, FutureChannelExpEP.expch][perm$R]) && ((Fractions(100) == exhaleMask#_863[e#118, FutureChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_863[e#118, FutureChannelExpEP.expch][perm$N]));
  exhaleMask#_863[e#118, FutureChannelExpEP.expch] := exhaleMask#_863[e#118, FutureChannelExpEP.expch][perm$R := exhaleMask#_863[e#118, FutureChannelExpEP.expch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.77 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.77 for FutureChannelImpEP.impch."} (Fractions(100) <= exhaleMask#_863[i#117, FutureChannelImpEP.impch][perm$R]) && ((Fractions(100) == exhaleMask#_863[i#117, FutureChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_863[i#117, FutureChannelImpEP.impch][perm$N]));
  exhaleMask#_863[i#117, FutureChannelImpEP.impch] := exhaleMask#_863[i#117, FutureChannelImpEP.impch][perm$R := exhaleMask#_863[i#117, FutureChannelImpEP.impch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.93 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.93 for FutureChannelImpEP.state."} (Fractions(100) <= exhaleMask#_863[i#117, FutureChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_863[i#117, FutureChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_863[i#117, FutureChannelImpEP.state][perm$N]));
  exhaleMask#_863[i#117, FutureChannelImpEP.state] := exhaleMask#_863[i#117, FutureChannelImpEP.state][perm$R := exhaleMask#_863[i#117, FutureChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  assert {:msg "  557.3: The precondition at 515.11 might not hold. The permission at 515.109 might not be positive."} Fractions(100) > 0;
  assert {:msg "  557.3: The precondition at 515.11 might not hold. Insufficient fraction at 515.109 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_863[e#118, FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_863[e#118, FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_863[e#118, FutureChannelExpEP.state][perm$N]));
  exhaleMask#_863[e#118, FutureChannelExpEP.state] := exhaleMask#_863[e#118, FutureChannelExpEP.state][perm$R := exhaleMask#_863[e#118, FutureChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_863);
  Mask := exhaleMask#_863;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_874;
  assume IsGoodInhaleState(inhaleHeap#_874, Heap, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.valid] := inhaleHeap#_874[this#116, FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_874[this#116, FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#116, FutureChannel.valid] := Mask[this#116, FutureChannel.valid][perm$R := Mask[this#116, FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.valid] := inhaleHeap#_874[this#116, FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_874[this#116, FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#116, FutureChannel.valid] := Mask[this#116, FutureChannel.valid][perm$R := Mask[this#116, FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.exp] := inhaleHeap#_874[this#116, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this#116, FutureChannel.exp] == null) || (dtype(Heap[this#116, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[this#116, FutureChannel.exp] := Mask[this#116, FutureChannel.exp][perm$R := Mask[this#116, FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.imp] := inhaleHeap#_874[this#116, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this#116, FutureChannel.imp] == null) || (dtype(Heap[this#116, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[this#116, FutureChannel.imp] := Mask[this#116, FutureChannel.imp][perm$R := Mask[this#116, FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume Heap[this#116, FutureChannel.exp] != null;
  Heap[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_874[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume Heap[this#116, FutureChannel.imp] != null;
  Heap[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_874[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.exp] := inhaleHeap#_874[this#116, FutureChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this#116, FutureChannel.exp] == null) || (dtype(Heap[this#116, FutureChannel.exp]) == FutureChannelExpEP#t);
  assume monitorK > 0;
  Mask[this#116, FutureChannel.exp] := Mask[this#116, FutureChannel.exp][perm$R := Mask[this#116, FutureChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.imp] := inhaleHeap#_874[this#116, FutureChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this#116, FutureChannel.imp] == null) || (dtype(Heap[this#116, FutureChannel.imp]) == FutureChannelImpEP#t);
  assume monitorK > 0;
  Mask[this#116, FutureChannel.imp] := Mask[this#116, FutureChannel.imp][perm$R := Mask[this#116, FutureChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume Heap[this#116, FutureChannel.exp] != null;
  Heap[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_874[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[Heap[this#116, FutureChannel.exp], FutureChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume Heap[this#116, FutureChannel.imp] != null;
  Heap[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_874[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[Heap[this#116, FutureChannel.imp], FutureChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.initImpState] := inhaleHeap#_874[this#116, FutureChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_874[this#116, FutureChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this#116, FutureChannel.initImpState] := Mask[this#116, FutureChannel.initImpState][perm$R := Mask[this#116, FutureChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume this#116 != null;
  Heap[this#116, FutureChannel.initExpState] := inhaleHeap#_874[this#116, FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_874[this#116, FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this#116, FutureChannel.initExpState] := Mask[this#116, FutureChannel.initExpState][perm$R := Mask[this#116, FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_874[this#116, FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_874, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field value
  assert {:msg "  558.3: Location might not be writable"} CanWrite(Mask, this, Future.value);
  Heap[this, Future.value] := null;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_875 := Mask;
  assert {:msg "  549.2: The postcondition at 551.10 might not hold. The expression at 551.38 might not evaluate to true."} !(Heap[this, Future.q] == null);
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. The expression at 552.57 might not evaluate to true."} Heap[this, Future.value] == null;
  assert {:msg "  549.2: The postcondition at 551.10 might not hold. The permission at 551.10 might not be positive."} monitorK > 0;
  assert {:msg "  549.2: The postcondition at 551.10 might not hold. Insufficient fraction at 551.10 for Future.q."} (monitorK <= exhaleMask#_875[this, Future.q][perm$R]) && ((monitorK == exhaleMask#_875[this, Future.q][perm$R]) ==> (0 <= exhaleMask#_875[this, Future.q][perm$N]));
  exhaleMask#_875[this, Future.q] := exhaleMask#_875[this, Future.q][perm$R := exhaleMask#_875[this, Future.q][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_875);
  assert {:msg "  549.2: The postcondition at 551.10 might not hold. The permission at 551.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  549.2: The postcondition at 551.10 might not hold. Insufficient fraction at 551.24 for Future.value."} (Fractions(100) <= exhaleMask#_875[this, Future.value][perm$R]) && ((Fractions(100) == exhaleMask#_875[this, Future.value][perm$R]) ==> (0 <= exhaleMask#_875[this, Future.value][perm$N]));
  exhaleMask#_875[this, Future.value] := exhaleMask#_875[this, Future.value][perm$R := exhaleMask#_875[this, Future.value][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_875);
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. The permission at 552.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. Insufficient fraction at 552.10 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_875[Heap[this, Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_875[Heap[this, Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_875[Heap[this, Future.q], FutureChannel.valid][perm$N]));
  exhaleMask#_875[Heap[this, Future.q], FutureChannel.valid] := exhaleMask#_875[Heap[this, Future.q], FutureChannel.valid][perm$R := exhaleMask#_875[Heap[this, Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_875);
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. The permission at 552.21 might not be positive."} Fractions(100) > 0;
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. Insufficient fraction at 552.21 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_875[Heap[this, Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_875[Heap[this, Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_875[Heap[this, Future.q], FutureChannel.initExpState][perm$N]));
  exhaleMask#_875[Heap[this, Future.q], FutureChannel.initExpState] := exhaleMask#_875[Heap[this, Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_875[Heap[this, Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_875);
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. The permission at 552.39 might not be positive."} Fractions(100) > 0;
  assert {:msg "  549.2: The postcondition at 552.10 might not hold. Insufficient fraction at 552.39 for FutureChannel.initImpState."} (Fractions(100) <= exhaleMask#_875[Heap[this, Future.q], FutureChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_875[Heap[this, Future.q], FutureChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_875[Heap[this, Future.q], FutureChannel.initImpState][perm$N]));
  exhaleMask#_875[Heap[this, Future.q], FutureChannel.initImpState] := exhaleMask#_875[Heap[this, Future.q], FutureChannel.initImpState][perm$R := exhaleMask#_875[Heap[this, Future.q], FutureChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_875);
  Mask := exhaleMask#_875;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  549.2: Method might lock/unlock more than allowed."} (forall lk#_881: ref :: {Heap[lk#_881, held]} {Heap[lk#_881, rdheld]} (((0 < Heap[lk#_881, held]) == (0 < old(Heap)[lk#_881, held])) && (Heap[lk#_881, rdheld] == old(Heap)[lk#_881, rdheld])) || false);
  assert {:msg "  549.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure Future.get$checkDefinedness(this: ref where (this == null) || (dtype(this) == Future#t)) returns (m#46: ref where (m#46 == null) || (dtype(m#46) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_882: int;
  var inhaleHeap#_883: HeapType;
  var funcappK#_890: int;
  var Heap#_887: HeapType;
  var Mask#_888: MaskType;
  var Credits#_889: CreditsType;
  var exhaleMask#_891: MaskType;
  var inhaleHeap#_893: HeapType;
  var funcappK#_900: int;
  var Heap#_897: HeapType;
  var Mask#_898: MaskType;
  var Credits#_899: CreditsType;
  var exhaleMask#_901: MaskType;
  assume (0 < methodK#_882) && ((1000 * methodK#_882) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_883;
  assume IsGoodInhaleState(inhaleHeap#_883, Heap, Mask);
  assume this != null;
  Heap[this, Future.value] := inhaleHeap#_883[this, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.value] == null) || (dtype(Heap[this, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this, Future.value] := Mask[this, Future.value][perm$R := Mask[this, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[this, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assume this != null;
  Heap[this, Future.sent] := inhaleHeap#_883[this, Future.sent];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.sent] == null) || (dtype(Heap[this, Future.sent]) == Message#t);
  assume monitorK > 0;
  Mask[this, Future.sent] := Mask[this, Future.sent][perm$R := Mask[this, Future.sent][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[this, Future.sent]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assert {:msg "  563.45: Receiver might be null."} true ==> (this != null);
  assert {:msg "  563.45: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assume Heap[this, Future.sent] != null;
  Heap[Heap[this, Future.sent], Message.type] := inhaleHeap#_883[Heap[this, Future.sent], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.sent], Message.type] := Mask[Heap[this, Future.sent], Message.type][perm$R := Mask[Heap[this, Future.sent], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[Heap[this, Future.sent], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assert {:msg "  563.65: Receiver might be null."} true ==> (this != null);
  assert {:msg "  563.65: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assert {:msg "  563.65: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
  assert {:msg "  563.65: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.sent], Message.type);
  assume Heap[Heap[this, Future.sent], Message.type] == 1;
  assert {:msg "  563.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  563.84: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assume Heap[this, Future.sent] != null;
  Heap[Heap[this, Future.sent], Message.vo1] := inhaleHeap#_883[Heap[this, Future.sent], Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.sent], Message.vo1] := Mask[Heap[this, Future.sent], Message.vo1][perm$R := Mask[Heap[this, Future.sent], Message.vo1][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[Heap[this, Future.sent], Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assert {:msg "  563.103: Receiver might be null."} true ==> (this != null);
  assert {:msg "  563.103: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assert {:msg "  563.103: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
  assert {:msg "  563.103: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.sent], Message.vo1);
  assume Heap[Heap[this, Future.sent], Message.vo1] >= 0;
  assert {:msg "  564.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.6: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume Heap[this, Future.value] != null;
  Heap[Heap[this, Future.value], Message.type] := inhaleHeap#_883[Heap[this, Future.value], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.value], Message.type] := Mask[Heap[this, Future.value], Message.type][perm$R := Mask[Heap[this, Future.value], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[Heap[this, Future.value], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_883[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assert {:msg "  564.40: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.40: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume !(Heap[this, Future.q] == null);
  assert {:msg "  564.51: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.51: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assume !(Heap[this, Future.sent] == null);
  assert {:msg "  564.66: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.66: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assert {:msg "  564.66: Receiver might be null."} Heap[this, Future.q] != null;
  assert {:msg "  564.66: Receiver might be null."} true ==> (this != null);
  assert {:msg "  564.66: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume Heap[this, Future.q] != null;
  Heap[Heap[this, Future.q], FutureChannel.valid] := inhaleHeap#_883[Heap[this, Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_883[Heap[this, Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.q], FutureChannel.valid] := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_883[Heap[this, Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_883, Mask);
  assert {:msg "  565.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  565.12: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  if (!(Heap[this, Future.value] == null)) {
    assert {:msg "  566.4: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.4: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
    assert {:msg "  566.4: Receiver might be null."} true ==> (Heap[this, Future.value] != null);
    assert {:msg "  566.4: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.value], Message.type);
    assume Heap[Heap[this, Future.value], Message.type] == 4;
    assert {:msg "  566.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.21: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
    assert {:msg "  566.21: Receiver might be null."} Heap[this, Future.value] != null;
    assert {:msg "  566.21: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.21: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
    assume Heap[this, Future.value] != null;
    Heap[Heap[this, Future.value], Message.invFinalResult] := inhaleHeap#_883[Heap[this, Future.value], Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_883[Heap[this, Future.value], Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[this, Future.value], Message.invFinalResult] := Mask[Heap[this, Future.value], Message.invFinalResult][perm$R := Mask[Heap[this, Future.value], Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_883[Heap[this, Future.value], Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_883, Mask);
    assert {:msg "  566.49: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.49: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
    assume Heap[this, Future.value] != null;
    Heap[Heap[this, Future.value], Message.vr3] := inhaleHeap#_883[Heap[this, Future.value], Message.vr3];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[this, Future.value], Message.vr3] := Mask[Heap[this, Future.value], Message.vr3][perm$R := Mask[Heap[this, Future.value], Message.vr3][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_883[Heap[this, Future.value], Message.vr3]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_883, Mask);
    assert {:msg "  566.68: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.68: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
    assert {:msg "  566.68: Receiver might be null."} true ==> (Heap[this, Future.value] != null);
    assert {:msg "  566.68: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.value], Message.vr3);
    assert {:msg "  566.79: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.79: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
    assert {:msg "  566.94: Receiver might be null."} true ==> (this != null);
    assert {:msg "  566.94: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
    assert {:msg "  566.94: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
    assert {:msg "  566.94: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.sent], Message.vo1);
    assert {:msg "  566.79: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
    // check precondition of call
    assume (0 < funcappK#_890) && ((1000 * funcappK#_890) < Fractions(1));
    assume true;
    Heap#_887 := Heap;
    Mask#_888 := Mask;
    Credits#_889 := Credits;
    // begin exhale (function call)
    exhaleMask#_891 := Mask#_888;
    assert {:msg "  566.79: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_887[Heap#_887[this, Future.sent], Message.vo1] >= 0;
    Mask#_888 := exhaleMask#_891;
    assume wf(Heap#_887, Mask#_888);
    // end exhale
    assume Heap[Heap[this, Future.value], Message.vr3] == #Message.factorial(Heap, Mask, Heap[this, Future.sent], Heap[Heap[this, Future.sent], Message.vo1]);
  } else {
  }
  assert {:msg "  567.12: Receiver might be null."} true ==> (this != null);
  assert {:msg "  567.12: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  if (Heap[this, Future.value] == null) {
    assert {:msg "  567.35: Receiver might be null."} true ==> (this != null);
    assert {:msg "  567.35: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
    assert {:msg "  567.35: Receiver might be null."} true ==> (Heap[this, Future.q] != null);
    assert {:msg "  567.35: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.q], FutureChannel.imp);
    assert {:msg "  567.35: Receiver might be null."} true ==> (Heap[Heap[this, Future.q], FutureChannel.imp] != null);
    assert {:msg "  567.35: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch);
    assert {:msg "  567.35: The target of the credit predicate might be null."} Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch] != null;
    Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] + 1;
    assert {:msg "  567.64: Receiver might be null."} true ==> (this != null);
    assert {:msg "  567.64: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
    assert {:msg "  567.64: Receiver might be null."} true ==> (Heap[this, Future.q] != null);
    assert {:msg "  567.64: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.q], FutureChannel.imp);
    assert {:msg "  567.64: Receiver might be null."} true ==> (Heap[Heap[this, Future.q], FutureChannel.imp] != null);
    assert {:msg "  567.64: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch);
    assert {:msg "  567.64: Receiver might be null."} true ==> (Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch] != null);
    assert {:msg "  567.64: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch], mu);
    assume (forall o#_892: ref :: (((0 < Heap[o#_892, held]) || Heap[o#_892, rdheld]) || (Credits[o#_892] < 0)) ==> MuBelow(Heap[o#_892, mu], Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch], mu]));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_893;
  assume IsGoodInhaleState(inhaleHeap#_893, Heap, Mask);
  assume this != null;
  Heap[this, Future.value] := inhaleHeap#_893[this, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.value] == null) || (dtype(Heap[this, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this, Future.value] := Mask[this, Future.value][perm$R := Mask[this, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[this, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assume this != null;
  Heap[this, Future.sent] := inhaleHeap#_893[this, Future.sent];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.sent] == null) || (dtype(Heap[this, Future.sent]) == Message#t);
  assume monitorK > 0;
  Mask[this, Future.sent] := Mask[this, Future.sent][perm$R := Mask[this, Future.sent][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[this, Future.sent]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assert {:msg "  568.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  568.44: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assume Heap[this, Future.sent] != null;
  Heap[Heap[this, Future.sent], Message.type] := inhaleHeap#_893[Heap[this, Future.sent], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.sent], Message.type] := Mask[Heap[this, Future.sent], Message.type][perm$R := Mask[Heap[this, Future.sent], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[Heap[this, Future.sent], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assert {:msg "  568.64: Receiver might be null."} true ==> (this != null);
  assert {:msg "  568.64: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assert {:msg "  568.64: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
  assert {:msg "  568.64: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.sent], Message.type);
  assume Heap[Heap[this, Future.sent], Message.type] == 1;
  assert {:msg "  568.83: Receiver might be null."} true ==> (this != null);
  assert {:msg "  568.83: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assume Heap[this, Future.sent] != null;
  Heap[Heap[this, Future.sent], Message.vo1] := inhaleHeap#_893[Heap[this, Future.sent], Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.sent], Message.vo1] := Mask[Heap[this, Future.sent], Message.vo1][perm$R := Mask[Heap[this, Future.sent], Message.vo1][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[Heap[this, Future.sent], Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assert {:msg "  568.102: Receiver might be null."} true ==> (this != null);
  assert {:msg "  568.102: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assert {:msg "  568.102: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
  assert {:msg "  568.102: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.sent], Message.vo1);
  assume Heap[Heap[this, Future.sent], Message.vo1] >= 0;
  assert {:msg "  569.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  569.6: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume Heap[this, Future.value] != null;
  Heap[Heap[this, Future.value], Message.vr3] := inhaleHeap#_893[Heap[this, Future.value], Message.vr3];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.value], Message.vr3] := Mask[Heap[this, Future.value], Message.vr3][perm$R := Mask[Heap[this, Future.value], Message.vr3][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[Heap[this, Future.value], Message.vr3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assert {:msg "  569.28: Receiver might be null."} true ==> (this != null);
  assert {:msg "  569.28: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume Heap[this, Future.value] != null;
  Heap[Heap[this, Future.value], Message.type] := inhaleHeap#_893[Heap[this, Future.value], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.value], Message.type] := Mask[Heap[this, Future.value], Message.type][perm$R := Mask[Heap[this, Future.value], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[Heap[this, Future.value], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_893[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assert {:msg "  569.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  569.62: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume !(Heap[this, Future.value] == null);
  assert {:msg "  569.81: Receiver might be null."} true ==> (this != null);
  assert {:msg "  569.81: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume m#46 == Heap[this, Future.value];
  assert {:msg "  570.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.4: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assert {:msg "  570.4: Receiver might be null."} true ==> (Heap[this, Future.value] != null);
  assert {:msg "  570.4: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.value], Message.type);
  assume Heap[Heap[this, Future.value], Message.type] == 4;
  assert {:msg "  570.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.22: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assert {:msg "  570.22: Receiver might be null."} Heap[this, Future.value] != null;
  assert {:msg "  570.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.22: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assume Heap[this, Future.value] != null;
  Heap[Heap[this, Future.value], Message.invFinalResult] := inhaleHeap#_893[Heap[this, Future.value], Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_893[Heap[this, Future.value], Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.value], Message.invFinalResult] := Mask[Heap[this, Future.value], Message.invFinalResult][perm$R := Mask[Heap[this, Future.value], Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_893[Heap[this, Future.value], Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_893, Mask);
  assert {:msg "  570.46: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.46: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  assert {:msg "  570.46: Receiver might be null."} true ==> (Heap[this, Future.value] != null);
  assert {:msg "  570.46: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.value], Message.vr3);
  assert {:msg "  570.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.57: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assert {:msg "  570.72: Receiver might be null."} true ==> (this != null);
  assert {:msg "  570.72: Location might not be readable."} true ==> CanRead(Mask, this, Future.sent);
  assert {:msg "  570.72: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
  assert {:msg "  570.72: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.sent], Message.vo1);
  assert {:msg "  570.57: Receiver might be null."} true ==> (Heap[this, Future.sent] != null);
  // check precondition of call
  assume (0 < funcappK#_900) && ((1000 * funcappK#_900) < Fractions(1));
  assume true;
  Heap#_897 := Heap;
  Mask#_898 := Mask;
  Credits#_899 := Credits;
  // begin exhale (function call)
  exhaleMask#_901 := Mask#_898;
  assert {:msg "  570.57: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_897[Heap#_897[this, Future.sent], Message.vo1] >= 0;
  Mask#_898 := exhaleMask#_901;
  assume wf(Heap#_897, Mask#_898);
  // end exhale
  assume Heap[Heap[this, Future.value], Message.vr3] == #Message.factorial(Heap, Mask, Heap[this, Future.sent], Heap[Heap[this, Future.sent], Message.vo1]);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Future.get(this: ref where (this == null) || (dtype(this) == Future#t)) returns (m#46: ref where (m#46 == null) || (dtype(m#46) == Message#t))
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_882: int;
  var inhaleHeap#_902: HeapType;
  var unfoldK#_904: int;
  var exhaleMask#_905: MaskType;
  var inhaleHeap#_907: HeapType;
  var unfoldK#_908: int;
  var exhaleMask#_909: MaskType;
  var inhaleHeap#_911: HeapType;
  var v#48: ref where (v#48 == null) || (dtype(v#48) == Message#t);
  var this#119: ref where (this#119 == null) || (dtype(this#119) == Channel#t);
  var msg#120: ref where (msg#120 == null) || (dtype(msg#120) == Message#t);
  var inhaleHeap#_913: HeapType;
  var methodCallK#_917: int;
  var this#121: ref where (this#121 == null) || (dtype(this#121) == FutureChannelImpEP#t);
  var mi#122: ref where (mi#122 == null) || (dtype(mi#122) == Message#t);
  var mo#123: ref where (mo#123 == null) || (dtype(mo#123) == Message#t);
  var callHeap#_914: HeapType;
  var callMask#_915: MaskType;
  var callCredits#_916: CreditsType;
  var exhaleMask#_918: MaskType;
  var isHeld#_922: int;
  var isRdHeld#_923: bool;
  var inhaleHeap#_924: HeapType;
  var value#107: ref where (value#107 == null) || (dtype(value#107) == Message#t);
  var exhaleMask#_925: MaskType;
  assume (0 < methodK#_882) && ((1000 * methodK#_882) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_902;
  assume IsGoodInhaleState(inhaleHeap#_902, Heap, Mask);
  assume this != null;
  Heap[this, Future.value] := inhaleHeap#_902[this, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.value] == null) || (dtype(Heap[this, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this, Future.value] := Mask[this, Future.value][perm$R := Mask[this, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[this, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  assume this != null;
  Heap[this, Future.sent] := inhaleHeap#_902[this, Future.sent];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.sent] == null) || (dtype(Heap[this, Future.sent]) == Message#t);
  assume monitorK > 0;
  Mask[this, Future.sent] := Mask[this, Future.sent][perm$R := Mask[this, Future.sent][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[this, Future.sent]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  assume Heap[this, Future.sent] != null;
  Heap[Heap[this, Future.sent], Message.type] := inhaleHeap#_902[Heap[this, Future.sent], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.sent], Message.type] := Mask[Heap[this, Future.sent], Message.type][perm$R := Mask[Heap[this, Future.sent], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[Heap[this, Future.sent], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  assume Heap[Heap[this, Future.sent], Message.type] == 1;
  assume Heap[this, Future.sent] != null;
  Heap[Heap[this, Future.sent], Message.vo1] := inhaleHeap#_902[Heap[this, Future.sent], Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.sent], Message.vo1] := Mask[Heap[this, Future.sent], Message.vo1][perm$R := Mask[Heap[this, Future.sent], Message.vo1][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[Heap[this, Future.sent], Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  assume Heap[Heap[this, Future.sent], Message.vo1] >= 0;
  assume Heap[this, Future.value] != null;
  Heap[Heap[this, Future.value], Message.type] := inhaleHeap#_902[Heap[this, Future.value], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this, Future.value], Message.type] := Mask[Heap[this, Future.value], Message.type][perm$R := Mask[Heap[this, Future.value], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[Heap[this, Future.value], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_902[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  assume !(Heap[this, Future.q] == null);
  assume !(Heap[this, Future.sent] == null);
  assume Heap[this, Future.q] != null;
  Heap[Heap[this, Future.q], FutureChannel.valid] := inhaleHeap#_902[Heap[this, Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_902[Heap[this, Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.q], FutureChannel.valid] := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_902[Heap[this, Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_902, Mask);
  if (!(Heap[this, Future.value] == null)) {
    assume Heap[Heap[this, Future.value], Message.type] == 4;
    assume Heap[this, Future.value] != null;
    Heap[Heap[this, Future.value], Message.invFinalResult] := inhaleHeap#_902[Heap[this, Future.value], Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_902[Heap[this, Future.value], Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[this, Future.value], Message.invFinalResult] := Mask[Heap[this, Future.value], Message.invFinalResult][perm$R := Mask[Heap[this, Future.value], Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_902[Heap[this, Future.value], Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_902, Mask);
    assume Heap[this, Future.value] != null;
    Heap[Heap[this, Future.value], Message.vr3] := inhaleHeap#_902[Heap[this, Future.value], Message.vr3];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[this, Future.value], Message.vr3] := Mask[Heap[this, Future.value], Message.vr3][perm$R := Mask[Heap[this, Future.value], Message.vr3][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_902[Heap[this, Future.value], Message.vr3]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_902, Mask);
    assume Heap[Heap[this, Future.value], Message.vr3] == #Message.factorial(Heap, Mask, Heap[this, Future.sent], Heap[Heap[this, Future.sent], Message.vo1]);
  } else {
  }
  if (Heap[this, Future.value] == null) {
    Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] + 1;
    assume (forall o#_903: ref :: (((0 < Heap[o#_903, held]) || Heap[o#_903, rdheld]) || (Credits[o#_903] < 0)) ==> MuBelow(Heap[o#_903, mu], Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch], mu]));
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // if
  assert {:msg "  572.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  572.6: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  if (Heap[this, Future.value] == null) {
    // unfold
    assume (0 < unfoldK#_904) && (unfoldK#_904 < Fractions(1)) && ((1000 * unfoldK#_904) < methodK#_882);
    assert {:msg "  573.11: Receiver might be null."} true ==> (this != null);
    assert {:msg "  573.11: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
    assert {:msg "  573.4: The target of the fold statement might be null."} Heap[this, Future.q] != null;
    // begin exhale (unfold)
    exhaleMask#_905 := Mask;
    assert {:msg "  573.4: unfold might fail because the predicate FutureChannel.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
    assert {:msg "  573.4: unfold might fail because the predicate FutureChannel.valid does not hold. Insufficient fraction at <undefined position> for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_905[Heap[this, Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_905[Heap[this, Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_905[Heap[this, Future.q], FutureChannel.valid][perm$N]));
    exhaleMask#_905[Heap[this, Future.q], FutureChannel.valid] := exhaleMask#_905[Heap[this, Future.q], FutureChannel.valid][perm$R := exhaleMask#_905[Heap[this, Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_905);
    Mask := exhaleMask#_905;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (unfold)
    inhaleHeap#_907 := Heap[Heap[this, Future.q], FutureChannel.valid];
    assume IsGoodInhaleState(inhaleHeap#_907, Heap, Mask);
    assume Heap[this, Future.q] != null;
    Heap[Heap[this, Future.q], FutureChannel.imp] := inhaleHeap#_907[Heap[this, Future.q], FutureChannel.imp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, Future.q], FutureChannel.imp] == null) || (dtype(Heap[Heap[this, Future.q], FutureChannel.imp]) == FutureChannelImpEP#t);
    assume monitorK > 0;
    Mask[Heap[this, Future.q], FutureChannel.imp] := Mask[Heap[this, Future.q], FutureChannel.imp][perm$R := Mask[Heap[this, Future.q], FutureChannel.imp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_907[Heap[this, Future.q], FutureChannel.imp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_907, Mask);
    assume Heap[this, Future.q] != null;
    Heap[Heap[this, Future.q], FutureChannel.exp] := inhaleHeap#_907[Heap[this, Future.q], FutureChannel.exp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, Future.q], FutureChannel.exp] == null) || (dtype(Heap[Heap[this, Future.q], FutureChannel.exp]) == FutureChannelExpEP#t);
    assume monitorK > 0;
    Mask[Heap[this, Future.q], FutureChannel.exp] := Mask[Heap[this, Future.q], FutureChannel.exp][perm$R := Mask[Heap[this, Future.q], FutureChannel.exp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_907[Heap[this, Future.q], FutureChannel.exp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_907, Mask);
    assume Heap[Heap[this, Future.q], FutureChannel.imp] != null;
    Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] := inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch]) == FutureChannel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_907, Mask);
    assume Heap[Heap[this, Future.q], FutureChannel.exp] != null;
    Heap[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch] := inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch]) == FutureChannel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch] := Mask[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch][perm$R := Mask[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_907, Mask);
    assume !(Heap[Heap[this, Future.q], FutureChannel.imp] == null);
    assume !(Heap[Heap[this, Future.q], FutureChannel.exp] == null);
    assume Heap[Heap[this, Future.q], FutureChannel.imp] != null;
    Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid] := inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid] := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_907, Mask);
    assume Heap[Heap[this, Future.q], FutureChannel.exp] != null;
    Heap[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid] := inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid] := Mask[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid][perm$R := Mask[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_907[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_907, Mask);
    assume Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] == Heap[this, Future.q];
    assume Heap[Heap[Heap[this, Future.q], FutureChannel.exp], FutureChannelExpEP.ch] == Heap[this, Future.q];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // unfold
    assume (0 < unfoldK#_908) && (unfoldK#_908 < Fractions(1)) && ((1000 * unfoldK#_908) < methodK#_882);
    assert {:msg "  574.11: Receiver might be null."} true ==> (this != null);
    assert {:msg "  574.11: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
    assert {:msg "  574.11: Receiver might be null."} true ==> (Heap[this, Future.q] != null);
    assert {:msg "  574.11: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.q], FutureChannel.imp);
    assert {:msg "  574.4: The target of the fold statement might be null."} Heap[Heap[this, Future.q], FutureChannel.imp] != null;
    // begin exhale (unfold)
    exhaleMask#_909 := Mask;
    assert {:msg "  574.4: unfold might fail because the predicate FutureChannelImpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
    assert {:msg "  574.4: unfold might fail because the predicate FutureChannelImpEP.valid does not hold. Insufficient fraction at <undefined position> for FutureChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_909[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_909[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_909[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$N]));
    exhaleMask#_909[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid] := exhaleMask#_909[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R := exhaleMask#_909[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_909);
    Mask := exhaleMask#_909;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (unfold)
    inhaleHeap#_911 := Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.valid];
    assume IsGoodInhaleState(inhaleHeap#_911, Heap, Mask);
    assume Heap[Heap[this, Future.q], FutureChannel.imp] != null;
    Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_911[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume Heap[Heap[this, Future.q], FutureChannel.imp] != null;
    Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] := inhaleHeap#_911[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch]) == FutureChannel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume !(Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] == null);
    assume Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] != null;
    Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] := inhaleHeap#_911[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] == null) || (dtype(Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp]) == FutureChannelImpEP#t);
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] := Mask[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R := Mask[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume !(Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] == null);
    assume Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch] != null;
    Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] := inhaleHeap#_911[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] == null) || (dtype(Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp]) == FutureChannelExpEP#t);
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] := Mask[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R := Mask[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume !(Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] == null);
    assume Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp] != null;
    Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := inhaleHeap#_911[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]) == Channel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] := Mask[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R := Mask[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume !(Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] == null);
    assume Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp] != null;
    Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := inhaleHeap#_911[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]) == Channel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] := Mask[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R := Mask[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume !(Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] == null);
    assume Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch] != null;
    Heap[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := inhaleHeap#_911[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.imp], FutureChannelImpEP.impch], mu]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch] != null;
    Heap[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := inhaleHeap#_911[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_911[Heap[Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.ch], FutureChannel.exp], FutureChannelExpEP.expch], mu]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_911, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // local var v
    // receive
    assert {:msg "  576.15: Receiver might be null."} true ==> (this != null);
    assert {:msg "  576.15: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
    assert {:msg "  576.15: Receiver might be null."} true ==> (Heap[this, Future.q] != null);
    assert {:msg "  576.15: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.q], FutureChannel.imp);
    assert {:msg "  576.15: Receiver might be null."} true ==> (Heap[Heap[this, Future.q], FutureChannel.imp] != null);
    assert {:msg "  576.15: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch);
    assert {:msg "  576.15: The channel might be null."} Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch] != null;
    assert {:msg "  576.4: receive operation requires a credit"} 0 < Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]];
    assert {:msg "  576.4: The mu field of the channel in the receive statement might not be readable."} CanRead(Mask, Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch], mu);
    assert {:msg "  576.4: The channel must lie above waitlevel in the wait order"} (forall o#_912: ref :: (((0 < Heap[o#_912, held]) || Heap[o#_912, rdheld]) || (Credits[o#_912] < 0)) ==> MuBelow(Heap[o#_912, mu], Heap[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch], mu]));
    this#119 := Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch];
    havoc msg#120;
    // inhale (channel where clause)
    havoc inhaleHeap#_913;
    assume IsGoodInhaleState(inhaleHeap#_913, Heap, Mask);
    assume !(msg#120 == null);
    assume msg#120 != null;
    Heap[msg#120, Message.type] := inhaleHeap#_913[msg#120, Message.type];
    assume wf(Heap, Mask);
    assume true;
    assume channelK > 0;
    Mask[msg#120, Message.type] := Mask[msg#120, Message.type][perm$R := Mask[msg#120, Message.type][perm$R] + channelK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_913[msg#120, Message.type]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_913, Mask);
    assume msg#120 != null;
    Heap[msg#120, Message.inv] := inhaleHeap#_913[msg#120, Message.inv];
    assume wf(Heap, Mask);
    assume inhaleHeap#_913[msg#120, Message.inv] == Heap;
    assume Fractions(100) > 0;
    Mask[msg#120, Message.inv] := Mask[msg#120, Message.inv][perm$R := Mask[msg#120, Message.inv][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_913[msg#120, Message.inv]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_913, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    v#48 := msg#120;
    Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] - 1;
    // if
    assert {:msg "  577.7: Receiver might be null."} true ==> (v#48 != null);
    assert {:msg "  577.7: Location might not be readable."} true ==> CanRead(Mask, v#48, Message.type);
    if (Heap[v#48, Message.type] == 4) {
      assume (0 < methodCallK#_917) && ((1000 * methodCallK#_917) < Fractions(1)) && ((1000 * methodCallK#_917) < methodK#_882);
      // call receiveFinalResult
      callHeap#_914 := Heap;
      callMask#_915 := Mask;
      callCredits#_916 := Credits;
      assert {:msg "  578.17: Receiver might be null."} true ==> (this != null);
      assert {:msg "  578.17: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
      assert {:msg "  578.17: Receiver might be null."} true ==> (Heap[this, Future.q] != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Future.q], FutureChannel.imp);
      assert {:msg "  578.5: The target of the method call might be null."} Heap[Heap[this, Future.q], FutureChannel.imp] != null;
      this#121 := Heap[Heap[this, Future.q], FutureChannel.imp];
      mi#122 := v#48;
      // begin exhale (precondition)
      exhaleMask#_918 := Mask;
      assert {:msg "  578.5: The precondition at 466.11 might not hold. The expression at 466.25 might not evaluate to true."} !(mi#122 == null);
      assert {:msg "  578.5: The precondition at 466.11 might not hold. The expression at 466.57 might not evaluate to true."} Heap[mi#122, Message.type] == 4;
      assert {:msg "  578.5: The precondition at 467.11 might not hold. The expression at 467.11 might not evaluate to true."} Heap[this#121, FutureChannelImpEP.state] == 0;
      assert {:msg "  578.5: The precondition at 466.11 might not hold. The permission at 466.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  578.5: The precondition at 466.11 might not hold. Insufficient fraction at 466.11 for FutureChannelImpEP.state."} (Fractions(100) <= exhaleMask#_918[this#121, FutureChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_918[this#121, FutureChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_918[this#121, FutureChannelImpEP.state][perm$N]));
      exhaleMask#_918[this#121, FutureChannelImpEP.state] := exhaleMask#_918[this#121, FutureChannelImpEP.state][perm$R := exhaleMask#_918[this#121, FutureChannelImpEP.state][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_918);
      assert {:msg "  578.5: The precondition at 466.11 might not hold. The permission at 466.37 might not be positive."} monitorK > 0;
      assert {:msg "  578.5: The precondition at 466.11 might not hold. Insufficient fraction at 466.37 for Message.type."} (monitorK <= exhaleMask#_918[mi#122, Message.type][perm$R]) && ((monitorK == exhaleMask#_918[mi#122, Message.type][perm$R]) ==> (0 <= exhaleMask#_918[mi#122, Message.type][perm$N]));
      exhaleMask#_918[mi#122, Message.type] := exhaleMask#_918[mi#122, Message.type][perm$R := exhaleMask#_918[mi#122, Message.type][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_918);
      assert {:msg "  578.5: The precondition at 466.11 might not hold. The permission at 466.71 might not be positive."} Fractions(100) > 0;
      assert {:msg "  578.5: The precondition at 466.11 might not hold. Insufficient fraction at 466.71 for Message.inv."} (Fractions(100) <= exhaleMask#_918[mi#122, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_918[mi#122, Message.inv][perm$R]) ==> (0 <= exhaleMask#_918[mi#122, Message.inv][perm$N]));
      exhaleMask#_918[mi#122, Message.inv] := exhaleMask#_918[mi#122, Message.inv][perm$R := exhaleMask#_918[mi#122, Message.inv][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_918);
      Mask := exhaleMask#_918;
      assume wf(Heap, Mask);
      // end exhale
      havoc mo#123;
      // inhale (postcondition)
      havoc inhaleHeap#_924;
      assume IsGoodInhaleState(inhaleHeap#_924, Heap, Mask);
      assume this#121 != null;
      Heap[this#121, FutureChannelImpEP.state] := inhaleHeap#_924[this#121, FutureChannelImpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[this#121, FutureChannelImpEP.state] := Mask[this#121, FutureChannelImpEP.state][perm$R := Mask[this#121, FutureChannelImpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_924[this#121, FutureChannelImpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_924, Mask);
      assume Heap[this#121, FutureChannelImpEP.state] == 1;
      assume mo#123 != null;
      Heap[mo#123, Message.type] := inhaleHeap#_924[mo#123, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[mo#123, Message.type] := Mask[mo#123, Message.type][perm$R := Mask[mo#123, Message.type][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_924[mo#123, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_924, Mask);
      assume mo#123 == mi#122;
      assume Heap[mo#123, Message.type] == 4;
      assume mo#123 != null;
      Heap[mo#123, Message.invFinalResult] := inhaleHeap#_924[mo#123, Message.invFinalResult];
      assume wf(Heap, Mask);
      assume inhaleHeap#_924[mo#123, Message.invFinalResult] == Heap;
      assume Fractions(100) > 0;
      Mask[mo#123, Message.invFinalResult] := Mask[mo#123, Message.invFinalResult][perm$R := Mask[mo#123, Message.invFinalResult][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_924[mo#123, Message.invFinalResult]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_924, Mask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      value#107 := mo#123;
    } else {
      // assume
      assume false;
    }
  } else {
  }
  // assigment to m
  assert {:msg "  584.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  584.6: Location might not be readable."} true ==> CanRead(Mask, this, Future.value);
  m#46 := Heap[this, Future.value];
  // begin exhale (postcondition)
  exhaleMask#_925 := Mask;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The expression at 568.64 might not evaluate to true."} Heap[Heap[this, Future.sent], Message.type] == 1;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The expression at 568.102 might not evaluate to true."} Heap[Heap[this, Future.sent], Message.vo1] >= 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The expression at 569.62 might not evaluate to true."} !(Heap[this, Future.value] == null);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The expression at 569.78 might not evaluate to true."} m#46 == Heap[this, Future.value];
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The expression at 570.4 might not evaluate to true."} Heap[Heap[this, Future.value], Message.type] == 4;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The expression at 570.46 might not evaluate to true."} Heap[Heap[this, Future.value], Message.vr3] == #Message.factorial(Heap, Mask, Heap[this, Future.sent], Heap[Heap[this, Future.sent], Message.vo1]);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 568.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 568.10 for Future.value."} (Fractions(100) <= exhaleMask#_925[this, Future.value][perm$R]) && ((Fractions(100) == exhaleMask#_925[this, Future.value][perm$R]) ==> (0 <= exhaleMask#_925[this, Future.value][perm$N]));
  exhaleMask#_925[this, Future.value] := exhaleMask#_925[this, Future.value][perm$R := exhaleMask#_925[this, Future.value][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 568.24 might not be positive."} monitorK > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 568.24 for Future.sent."} (monitorK <= exhaleMask#_925[this, Future.sent][perm$R]) && ((monitorK == exhaleMask#_925[this, Future.sent][perm$R]) ==> (0 <= exhaleMask#_925[this, Future.sent][perm$N]));
  exhaleMask#_925[this, Future.sent] := exhaleMask#_925[this, Future.sent][perm$R := exhaleMask#_925[this, Future.sent][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 568.41 might not be positive."} monitorK > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 568.41 for Message.type."} (monitorK <= exhaleMask#_925[Heap[this, Future.sent], Message.type][perm$R]) && ((monitorK == exhaleMask#_925[Heap[this, Future.sent], Message.type][perm$R]) ==> (0 <= exhaleMask#_925[Heap[this, Future.sent], Message.type][perm$N]));
  exhaleMask#_925[Heap[this, Future.sent], Message.type] := exhaleMask#_925[Heap[this, Future.sent], Message.type][perm$R := exhaleMask#_925[Heap[this, Future.sent], Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 568.80 might not be positive."} monitorK > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 568.80 for Message.vo1."} (monitorK <= exhaleMask#_925[Heap[this, Future.sent], Message.vo1][perm$R]) && ((monitorK == exhaleMask#_925[Heap[this, Future.sent], Message.vo1][perm$R]) ==> (0 <= exhaleMask#_925[Heap[this, Future.sent], Message.vo1][perm$N]));
  exhaleMask#_925[Heap[this, Future.sent], Message.vo1] := exhaleMask#_925[Heap[this, Future.sent], Message.vo1][perm$R := exhaleMask#_925[Heap[this, Future.sent], Message.vo1][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 569.3 might not be positive."} monitorK > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 569.3 for Message.vr3."} (monitorK <= exhaleMask#_925[Heap[this, Future.value], Message.vr3][perm$R]) && ((monitorK == exhaleMask#_925[Heap[this, Future.value], Message.vr3][perm$R]) ==> (0 <= exhaleMask#_925[Heap[this, Future.value], Message.vr3][perm$N]));
  exhaleMask#_925[Heap[this, Future.value], Message.vr3] := exhaleMask#_925[Heap[this, Future.value], Message.vr3][perm$R := exhaleMask#_925[Heap[this, Future.value], Message.vr3][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 569.25 might not be positive."} monitorK > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 569.25 for Message.type."} (monitorK <= exhaleMask#_925[Heap[this, Future.value], Message.type][perm$R]) && ((monitorK == exhaleMask#_925[Heap[this, Future.value], Message.type][perm$R]) ==> (0 <= exhaleMask#_925[Heap[this, Future.value], Message.type][perm$N]));
  exhaleMask#_925[Heap[this, Future.value], Message.type] := exhaleMask#_925[Heap[this, Future.value], Message.type][perm$R := exhaleMask#_925[Heap[this, Future.value], Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 569.48 might not be positive."} monitorK > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 569.48 for Future.q."} (monitorK <= exhaleMask#_925[this, Future.q][perm$R]) && ((monitorK == exhaleMask#_925[this, Future.q][perm$R]) ==> (0 <= exhaleMask#_925[this, Future.q][perm$N]));
  exhaleMask#_925[this, Future.q] := exhaleMask#_925[this, Future.q][perm$R := exhaleMask#_925[this, Future.q][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. The permission at 570.22 might not be positive."} Fractions(100) > 0;
  assert {:msg "  562.2: The postcondition at 568.10 might not hold. Insufficient fraction at 570.22 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_925[Heap[this, Future.value], Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_925[Heap[this, Future.value], Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_925[Heap[this, Future.value], Message.invFinalResult][perm$N]));
  exhaleMask#_925[Heap[this, Future.value], Message.invFinalResult] := exhaleMask#_925[Heap[this, Future.value], Message.invFinalResult][perm$R := exhaleMask#_925[Heap[this, Future.value], Message.invFinalResult][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_925);
  Mask := exhaleMask#_925;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  562.2: Method might lock/unlock more than allowed."} (forall lk#_934: ref :: {Heap[lk#_934, held]} {Heap[lk#_934, rdheld]} (((0 < Heap[lk#_934, held]) == (0 < old(Heap)[lk#_934, held])) && (Heap[lk#_934, rdheld] == old(Heap)[lk#_934, rdheld])) || false);
  assert {:msg "  562.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
function #Future.getQ(heap: HeapType, mask: MaskType, this: ref) returns ($myresult: ref);
procedure Future.getQ$checkDefinedness(this: ref where (this == null) || (dtype(this) == Future#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var functionK#_935: int;
  var inhaleHeap#_936: HeapType;
  var result: ref;
  assume (0 < functionK#_935) && ((1000 * functionK#_935) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_936;
  assume IsGoodInhaleState(inhaleHeap#_936, Heap, Mask);
  assume this != null;
  Heap[this, Future.q] := inhaleHeap#_936[this, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this, Future.q] == null) || (dtype(Heap[this, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this, Future.q] := Mask[this, Future.q][perm$R := Mask[this, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[this, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assert {:msg "  589.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  589.25: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume !(Heap[this, Future.q] == null);
  assert {:msg "  589.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  589.36: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assert {:msg "  589.36: Receiver might be null."} Heap[this, Future.q] != null;
  assert {:msg "  589.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  589.36: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  assume Heap[this, Future.q] != null;
  Heap[Heap[this, Future.q], FutureChannel.valid] := inhaleHeap#_936[Heap[this, Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_936[Heap[this, Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, Future.q], FutureChannel.valid] := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R := Mask[Heap[this, Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_936[Heap[this, Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_936, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  assume CurrentModule == module#default;
  assert {:msg "  591.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  591.3: Location might not be readable."} true ==> CanRead(Mask, this, Future.q);
  result := Heap[this, Future.q];
}
axiom (forall Heap: HeapType, Mask: MaskType, this: ref :: {#Future.getQ(Heap, Mask, this)} wf(Heap, Mask) && (CurrentModule == module#default) ==> (#Future.getQ(Heap, Mask, this) == Heap[this, Future.q]));
function ##Future.getQ(state: HeapType, this: ref) returns ($myresult: ref);
axiom (forall Heap: HeapType, Mask: MaskType, this: ref :: {#Future.getQ(Heap, Mask, this)} wf(Heap, Mask) && IsGoodState(combine(nostate, combine(Heap[this, Future.q], Heap[Heap[this, Future.q], FutureChannel.valid]))) && CanAssumeFunctionDefs ==> (#Future.getQ(Heap, Mask, this) == ##Future.getQ(combine(nostate, combine(Heap[this, Future.q], Heap[Heap[this, Future.q], FutureChannel.valid])), this)));
const unique Message#t: TypeName;
procedure Message$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_944: int;
  var h0#_937: HeapType;
  var m0#_938: MaskType;
  var c0#_939: CreditsType;
  var h1#_940: HeapType;
  var m1#_941: MaskType;
  var c1#_942: CreditsType;
  var lk#_943: ref;
  assume (0 < methodK#_944) && ((1000 * methodK#_944) < Fractions(1));
  assume wf(h0#_937, m0#_938);
  assume wf(h1#_940, m1#_941);
  m1#_941 := ZeroMask;
  c1#_942 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  597.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique Message.type: Field (int);
axiom NonPredicateField(Message.type);
const unique Message.sender1: Field (ref);
axiom NonPredicateField(Message.sender1);
const unique Message.sender3: Field (ref);
axiom NonPredicateField(Message.sender3);
const unique Message.sender2: Field (ref);
axiom NonPredicateField(Message.sender2);
const unique Message.sender4: Field (ref);
axiom NonPredicateField(Message.sender4);
const unique Message.receiver1: Field (ref);
axiom NonPredicateField(Message.receiver1);
const unique Message.receiver2: Field (ref);
axiom NonPredicateField(Message.receiver2);
const unique Message.receiver3: Field (ref);
axiom NonPredicateField(Message.receiver3);
const unique Message.receiver4: Field (ref);
axiom NonPredicateField(Message.receiver4);
const unique Message.v1: Field (int);
axiom NonPredicateField(Message.v1);
const unique Message.vo1: Field (int);
axiom NonPredicateField(Message.vo1);
const unique Message.cust1: Field (ref);
axiom NonPredicateField(Message.cust1);
const unique Message.vr1: Field (int);
axiom NonPredicateField(Message.vr1);
const unique Message.old1: Field (ref);
axiom NonPredicateField(Message.old1);
const unique Message.vr2: Field (int);
axiom NonPredicateField(Message.vr2);
const unique Message.old2: Field (ref);
axiom NonPredicateField(Message.old2);
const unique Message.vr3: Field (int);
axiom NonPredicateField(Message.vr3);
function #Message.factorial(heap: HeapType, mask: MaskType, this: ref, v#49: int) returns ($myresult: int);
procedure Message.factorial$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t), v#49: int where true) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var functionK#_953: int;
  var inhaleHeap#_954: HeapType;
  var funcappK#_951: int;
  var Heap#_948: HeapType;
  var Mask#_949: MaskType;
  var Credits#_950: CreditsType;
  var exhaleMask#_952: MaskType;
  var result: int;
  var exhaleMask#_955: MaskType;
  var funcappK#_962: int;
  var Heap#_959: HeapType;
  var Mask#_960: MaskType;
  var Credits#_961: CreditsType;
  var exhaleMask#_963: MaskType;
  var funcappK#_970: int;
  var Heap#_967: HeapType;
  var Mask#_968: MaskType;
  var Credits#_969: CreditsType;
  var exhaleMask#_971: MaskType;
  var funcappK#_978: int;
  var Heap#_975: HeapType;
  var Mask#_976: MaskType;
  var Credits#_977: CreditsType;
  var exhaleMask#_979: MaskType;
  assume (0 < functionK#_953) && ((1000 * functionK#_953) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_954;
  assume IsGoodInhaleState(inhaleHeap#_954, Heap, Mask);
  assume v#49 >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  assume CurrentModule == module#default;
  if (v#49 == 0) {
  } else {
    assert {:msg "  621.18: Receiver might be null."} true ==> (this != null);
    // check precondition of call
    assume (0 < funcappK#_951) && ((1000 * funcappK#_951) < Fractions(1));
    assume true;
    Heap#_948 := Heap;
    Mask#_949 := Mask;
    Credits#_950 := Credits;
    // begin exhale (function call)
    exhaleMask#_952 := Mask#_949;
    assert {:msg "  621.18: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} (v#49 - 1) >= 0;
    Mask#_949 := exhaleMask#_952;
    assume wf(Heap#_948, Mask#_949);
    // end exhale
    assert {:msg "  621.18: The heap of the callee might not be strictly smaller than the heap of the caller."} true ==> (!EmptyMask(Mask#_949));
  }
  result := ite(v#49 == 0, 1, v#49 * #Message.factorial(Heap, Mask, this, v#49 - 1));
  // begin exhale (function postcondition)
  exhaleMask#_955 := Mask;
  if (v#49 == 0) {
    assert {:msg "  618.19: Receiver might be null."} true ==> (this != null);
    // check precondition of call
    assume (0 < funcappK#_962) && ((1000 * funcappK#_962) < Fractions(1));
    assume true;
    Heap#_959 := Heap;
    Mask#_960 := Mask;
    Credits#_961 := Credits;
    // begin exhale (function call)
    exhaleMask#_963 := Mask#_960;
    assert {:msg "  618.19: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} v#49 >= 0;
    Mask#_960 := exhaleMask#_963;
    assume wf(Heap#_959, Mask#_960);
    // end exhale
    assert {:msg "  616.2: Postcondition at 618.10 might not hold. The expression at 618.19 might not evaluate to true."} #Message.factorial(Heap, Mask, this, v#49) == 1;
  } else {
  }
  if (v#49 > 0) {
    assert {:msg "  619.18: Receiver might be null."} true ==> (this != null);
    // check precondition of call
    assume (0 < funcappK#_970) && ((1000 * funcappK#_970) < Fractions(1));
    assume true;
    Heap#_967 := Heap;
    Mask#_968 := Mask;
    Credits#_969 := Credits;
    // begin exhale (function call)
    exhaleMask#_971 := Mask#_968;
    assert {:msg "  619.18: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} v#49 >= 0;
    Mask#_968 := exhaleMask#_971;
    assume wf(Heap#_967, Mask#_968);
    // end exhale
    assert {:msg "  619.34: Receiver might be null."} true ==> (this != null);
    // check precondition of call
    assume (0 < funcappK#_978) && ((1000 * funcappK#_978) < Fractions(1));
    assume true;
    Heap#_975 := Heap;
    Mask#_976 := Mask;
    Credits#_977 := Credits;
    // begin exhale (function call)
    exhaleMask#_979 := Mask#_976;
    assert {:msg "  619.34: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} (v#49 - 1) >= 0;
    Mask#_976 := exhaleMask#_979;
    assume wf(Heap#_975, Mask#_976);
    // end exhale
    assert {:msg "  616.2: Postcondition at 619.10 might not hold. The expression at 619.18 might not evaluate to true."} #Message.factorial(Heap, Mask, this, v#49) == (v#49 * #Message.factorial(Heap, Mask, this, v#49 - 1));
  } else {
  }
  if (v#49 == 0) {
  } else {
  }
  if (v#49 > 0) {
  } else {
  }
  Mask := exhaleMask#_955;
  assume wf(Heap, Mask);
  // end exhale
}
axiom (forall Heap: HeapType, Mask: MaskType, this: ref, v#49: int :: {#Message.factorial(Heap, Mask, this, v#49)} wf(Heap, Mask) && (CurrentModule == module#default) ==> (#Message.factorial(Heap, Mask, this, v#49) == ite(v#49 == 0, 1, v#49 * #Message.factorial(Heap, Mask, this, v#49 - 1))));
function #Message.factorial#limited(Heap: HeapType, Mask: MaskType, this: ref, v#49: int) returns ($myresult: int);
axiom (forall Heap: HeapType, Mask: MaskType, this: ref, v#49: int :: {#Message.factorial(Heap, Mask, this, v#49)} #Message.factorial(Heap, Mask, this, v#49) == #Message.factorial#limited(Heap, Mask, this, v#49));
function ##Message.factorial(state: HeapType, this: ref, v#49: int) returns ($myresult: int);
axiom (forall Heap: HeapType, Mask: MaskType, this: ref, v#49: int :: {#Message.factorial#limited(Heap, Mask, this, v#49)} wf(Heap, Mask) && IsGoodState(combine(nostate, nostate)) && CanAssumeFunctionDefs ==> (#Message.factorial#limited(Heap, Mask, this, v#49) == ##Message.factorial(combine(nostate, nostate), this, v#49)));
axiom (forall Heap: HeapType, Mask: MaskType, this: ref, v#49: int :: {#Message.factorial(Heap, Mask, this, v#49)} wf(Heap, Mask) && CanAssumeFunctionDefs ==> ((v#49 == 0) ==> (#Message.factorial(Heap, Mask, this, v#49) == 1)));
axiom (forall Heap: HeapType, Mask: MaskType, this: ref, v#49: int :: {#Message.factorial(Heap, Mask, this, v#49)} wf(Heap, Mask) && CanAssumeFunctionDefs ==> ((v#49 > 0) ==> (#Message.factorial(Heap, Mask, this, v#49) == (v#49 * #Message.factorial(Heap, Mask, this, v#49 - 1)))));
const unique Message.invValue: Field (HeapType);
axiom PredicateField(Message.invValue);
procedure Message.invValue$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_980: int;
  var inhaleHeap#_981: HeapType;
  assume (0 < predicateK#_980) && ((1000 * predicateK#_980) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_981;
  assume IsGoodInhaleState(inhaleHeap#_981, Heap, Mask);
  assume this != null;
  Heap[this, Message.sender1] := inhaleHeap#_981[this, Message.sender1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender1] == null) || (dtype(Heap[this, Message.sender1]) == Future#t);
  assume predicateK > 0;
  Mask[this, Message.sender1] := Mask[this, Message.sender1][perm$R := Mask[this, Message.sender1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[this, Message.sender1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assume this != null;
  Heap[this, Message.receiver1] := inhaleHeap#_981[this, Message.receiver1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver1] == null) || (dtype(Heap[this, Message.receiver1]) == FactorialActor#t);
  assume predicateK > 0;
  Mask[this, Message.receiver1] := Mask[this, Message.receiver1][perm$R := Mask[this, Message.receiver1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[this, Message.receiver1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assume this != null;
  Heap[this, Message.cust1] := inhaleHeap#_981[this, Message.cust1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.cust1] == null) || (dtype(Heap[this, Message.cust1]) == FactorialCont#t);
  assume predicateK > 0;
  Mask[this, Message.cust1] := Mask[this, Message.cust1][perm$R := Mask[this, Message.cust1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[this, Message.cust1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assume this != null;
  Heap[this, Message.v1] := inhaleHeap#_981[this, Message.v1];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[this, Message.v1] := Mask[this, Message.v1][perm$R := Mask[this, Message.v1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[this, Message.v1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assume this != null;
  Heap[this, Message.vo1] := inhaleHeap#_981[this, Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[this, Message.vo1] := Mask[this, Message.vo1][perm$R := Mask[this, Message.vo1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[this, Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assert {:msg "  627.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assume !(Heap[this, Message.sender1] == null);
  assert {:msg "  627.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.23: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assume Heap[this, Message.sender1] != null;
  Heap[Heap[this, Message.sender1], Future.q] := inhaleHeap#_981[Heap[this, Message.sender1], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender1], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender1], Future.q]) == FutureChannel#t);
  assume predicateK > 0;
  Mask[Heap[this, Message.sender1], Future.q] := Mask[Heap[this, Message.sender1], Future.q][perm$R := Mask[Heap[this, Message.sender1], Future.q][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[Heap[this, Message.sender1], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assert {:msg "  627.37: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.37: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  627.37: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  627.37: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assume !(Heap[Heap[this, Message.sender1], Future.q] == null);
  assert {:msg "  627.56: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.56: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  627.56: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  627.56: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assert {:msg "  627.56: Receiver might be null."} Heap[Heap[this, Message.sender1], Future.q] != null;
  assert {:msg "  627.56: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.56: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  627.56: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  627.56: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assume Heap[Heap[this, Message.sender1], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := inhaleHeap#_981[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_981[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assert {:msg "  627.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.75: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  627.75: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  627.75: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assert {:msg "  627.75: Receiver might be null."} Heap[Heap[this, Message.sender1], Future.q] != null;
  assert {:msg "  627.75: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.75: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  627.75: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  627.75: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assume Heap[Heap[this, Message.sender1], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := inhaleHeap#_981[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_981[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_981[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_981, Mask);
  assert {:msg "  627.101: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.101: Location might not be readable."} true ==> CanRead(Mask, this, Message.v1);
  assume Heap[this, Message.v1] >= 0;
  assert {:msg "  627.110: Receiver might be null."} true ==> (this != null);
  assert {:msg "  627.110: Location might not be readable."} true ==> CanRead(Mask, this, Message.vo1);
  assume Heap[this, Message.vo1] >= 0;
  assert {:msg "  628.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  628.7: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
  if (Heap[this, Message.cust1] == null) {
    assert {:msg "  628.23: Receiver might be null."} true ==> (this != null);
    assert {:msg "  628.23: Location might not be readable."} true ==> CanRead(Mask, this, Message.v1);
    assert {:msg "  628.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  628.27: Location might not be readable."} true ==> CanRead(Mask, this, Message.vo1);
    assume Heap[this, Message.v1] == Heap[this, Message.vo1];
  } else {
  }
  assert {:msg "  628.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  628.36: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
  if (!(Heap[this, Message.cust1] == null)) {
    assert {:msg "  628.56: Receiver might be null."} true ==> (this != null);
    assert {:msg "  628.56: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assume Heap[this, Message.cust1] != null;
    Heap[Heap[this, Message.cust1], FactorialCont.q] := inhaleHeap#_981[Heap[this, Message.cust1], FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, Message.cust1], FactorialCont.q] == null) || (dtype(Heap[Heap[this, Message.cust1], FactorialCont.q]) == FactorialContChannel#t);
    assume predicateK > 0;
    Mask[Heap[this, Message.cust1], FactorialCont.q] := Mask[Heap[this, Message.cust1], FactorialCont.q][perm$R := Mask[Heap[this, Message.cust1], FactorialCont.q][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[this, Message.cust1], FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  628.68: Receiver might be null."} true ==> (this != null);
    assert {:msg "  628.68: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  628.68: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  628.68: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assume !(Heap[Heap[this, Message.cust1], FactorialCont.q] == null);
    assert {:msg "  629.3: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.3: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.3: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assert {:msg "  629.3: Receiver might be null."} Heap[Heap[this, Message.cust1], FactorialCont.q] != null;
    assert {:msg "  629.3: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.3: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.3: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assume Heap[Heap[this, Message.cust1], FactorialCont.q] != null;
    Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  629.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.20: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.20: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.20: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assert {:msg "  629.20: Receiver might be null."} Heap[Heap[this, Message.cust1], FactorialCont.q] != null;
    assert {:msg "  629.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.20: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.20: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.20: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assume Heap[Heap[this, Message.cust1], FactorialCont.q] != null;
    Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  629.47: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.47: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.47: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assume Heap[Heap[this, Message.cust1], FactorialCont.q] != null;
    Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
    assume predicateK > 0;
    Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  629.66: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.66: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.66: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, Message.cust1], FactorialCont.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp);
    assume Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp] != null;
    Heap[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_981[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
    assume predicateK > 0;
    Mask[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  629.88: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.88: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.88: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.88: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.q);
    assert {:msg "  629.88: Receiver might be null."} true ==> (Heap[Heap[this, Message.cust1], FactorialCont.q] != null);
    assert {:msg "  629.88: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp);
    assert {:msg "  629.88: Receiver might be null."} true ==> (Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp] != null);
    assert {:msg "  629.88: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
    assume !(Heap[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assert {:msg "  629.118: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.118: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assume Heap[this, Message.cust1] != null;
    Heap[Heap[this, Message.cust1], FactorialCont.v] := inhaleHeap#_981[Heap[this, Message.cust1], FactorialCont.v];
    assume wf(Heap, Mask);
    assume true;
    assume predicateK > 0;
    Mask[Heap[this, Message.cust1], FactorialCont.v] := Mask[Heap[this, Message.cust1], FactorialCont.v][perm$R := Mask[Heap[this, Message.cust1], FactorialCont.v][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[this, Message.cust1], FactorialCont.v]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  629.135: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.135: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assume Heap[this, Message.cust1] != null;
    Heap[Heap[this, Message.cust1], FactorialCont.vo] := inhaleHeap#_981[Heap[this, Message.cust1], FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume predicateK > 0;
    Mask[Heap[this, Message.cust1], FactorialCont.vo] := Mask[Heap[this, Message.cust1], FactorialCont.vo][perm$R := Mask[Heap[this, Message.cust1], FactorialCont.vo][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_981[Heap[this, Message.cust1], FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_981, Mask);
    assert {:msg "  629.149: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.149: Location might not be readable."} true ==> CanRead(Mask, this, Message.v1);
    assert {:msg "  629.153: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.153: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.153: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.153: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.v);
    assume Heap[this, Message.v1] == (Heap[Heap[this, Message.cust1], FactorialCont.v] - 1);
    assert {:msg "  629.166: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.166: Location might not be readable."} true ==> CanRead(Mask, this, Message.vo1);
    assert {:msg "  629.171: Receiver might be null."} true ==> (this != null);
    assert {:msg "  629.171: Location might not be readable."} true ==> CanRead(Mask, this, Message.cust1);
    assert {:msg "  629.171: Receiver might be null."} true ==> (Heap[this, Message.cust1] != null);
    assert {:msg "  629.171: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.cust1], FactorialCont.vo);
    assume Heap[this, Message.vo1] == Heap[Heap[this, Message.cust1], FactorialCont.vo];
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique Message.invResult1: Field (HeapType);
axiom PredicateField(Message.invResult1);
procedure Message.invResult1$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_982: int;
  var inhaleHeap#_983: HeapType;
  var funcappK#_990: int;
  var Heap#_987: HeapType;
  var Mask#_988: MaskType;
  var Credits#_989: CreditsType;
  var exhaleMask#_991: MaskType;
  assume (0 < predicateK#_982) && ((1000 * predicateK#_982) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_983;
  assume IsGoodInhaleState(inhaleHeap#_983, Heap, Mask);
  assume this != null;
  Heap[this, Message.sender2] := inhaleHeap#_983[this, Message.sender2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender2] == null) || (dtype(Heap[this, Message.sender2]) == Future#t);
  assume predicateK > 0;
  Mask[this, Message.sender2] := Mask[this, Message.sender2][perm$R := Mask[this, Message.sender2][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[this, Message.sender2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assume this != null;
  Heap[this, Message.receiver2] := inhaleHeap#_983[this, Message.receiver2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver2] == null) || (dtype(Heap[this, Message.receiver2]) == FactorialCont#t);
  assume predicateK > 0;
  Mask[this, Message.receiver2] := Mask[this, Message.receiver2][perm$R := Mask[this, Message.receiver2][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[this, Message.receiver2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assume this != null;
  Heap[this, Message.vr1] := inhaleHeap#_983[this, Message.vr1];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[this, Message.vr1] := Mask[this, Message.vr1][perm$R := Mask[this, Message.vr1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[this, Message.vr1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assume this != null;
  Heap[this, Message.old1] := inhaleHeap#_983[this, Message.old1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.old1] == null) || (dtype(Heap[this, Message.old1]) == FactorialActor#t);
  assume predicateK > 0;
  Mask[this, Message.old1] := Mask[this, Message.old1][perm$R := Mask[this, Message.old1][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[this, Message.old1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assert {:msg "  634.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assume !(Heap[this, Message.sender2] == null);
  assert {:msg "  634.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.24: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assume Heap[this, Message.sender2] != null;
  Heap[Heap[this, Message.sender2], Future.q] := inhaleHeap#_983[Heap[this, Message.sender2], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender2], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender2], Future.q]) == FutureChannel#t);
  assume predicateK > 0;
  Mask[Heap[this, Message.sender2], Future.q] := Mask[Heap[this, Message.sender2], Future.q][perm$R := Mask[Heap[this, Message.sender2], Future.q][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[Heap[this, Message.sender2], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assert {:msg "  634.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.38: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  634.38: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  634.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assume !(Heap[Heap[this, Message.sender2], Future.q] == null);
  assert {:msg "  634.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.57: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  634.57: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  634.57: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assert {:msg "  634.57: Receiver might be null."} Heap[Heap[this, Message.sender2], Future.q] != null;
  assert {:msg "  634.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.57: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  634.57: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  634.57: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assume Heap[Heap[this, Message.sender2], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := inhaleHeap#_983[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_983[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assert {:msg "  634.77: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.77: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  634.77: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  634.77: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assert {:msg "  634.77: Receiver might be null."} Heap[Heap[this, Message.sender2], Future.q] != null;
  assert {:msg "  634.77: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.77: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  634.77: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  634.77: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assume Heap[Heap[this, Message.sender2], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := inhaleHeap#_983[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_983[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assert {:msg "  634.103: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.103: Location might not be readable."} true ==> CanRead(Mask, this, Message.vr1);
  assert {:msg "  634.108: Receiver might be null."} true ==> (this != null);
  // check precondition of call
  assume (0 < funcappK#_990) && ((1000 * funcappK#_990) < Fractions(1));
  assume true;
  Heap#_987 := Heap;
  Mask#_988 := Mask;
  Credits#_989 := Credits;
  // begin exhale (function call)
  exhaleMask#_991 := Mask#_988;
  assert {:msg "  634.108: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} 0 >= 0;
  Mask#_988 := exhaleMask#_991;
  assume wf(Heap#_987, Mask#_988);
  // end exhale
  assume Heap[this, Message.vr1] == #Message.factorial(Heap, Mask, this, 0);
  assert {:msg "  634.127: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.127: Location might not be readable."} true ==> CanRead(Mask, this, Message.receiver2);
  assume Heap[this, Message.receiver2] != null;
  Heap[Heap[this, Message.receiver2], FactorialCont.v] := inhaleHeap#_983[Heap[this, Message.receiver2], FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[Heap[this, Message.receiver2], FactorialCont.v] := Mask[Heap[this, Message.receiver2], FactorialCont.v][perm$R := Mask[Heap[this, Message.receiver2], FactorialCont.v][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_983[Heap[this, Message.receiver2], FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_983, Mask);
  assert {:msg "  634.143: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.143: Location might not be readable."} true ==> CanRead(Mask, this, Message.receiver2);
  assume !(Heap[this, Message.receiver2] == null);
  assert {:msg "  634.162: Receiver might be null."} true ==> (this != null);
  assert {:msg "  634.162: Location might not be readable."} true ==> CanRead(Mask, this, Message.receiver2);
  assert {:msg "  634.162: Receiver might be null."} true ==> (Heap[this, Message.receiver2] != null);
  assert {:msg "  634.162: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.receiver2], FactorialCont.v);
  assume Heap[Heap[this, Message.receiver2], FactorialCont.v] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique Message.invResult2: Field (HeapType);
axiom PredicateField(Message.invResult2);
procedure Message.invResult2$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_992: int;
  var inhaleHeap#_993: HeapType;
  var funcappK#_1000: int;
  var Heap#_997: HeapType;
  var Mask#_998: MaskType;
  var Credits#_999: CreditsType;
  var exhaleMask#_1001: MaskType;
  assume (0 < predicateK#_992) && ((1000 * predicateK#_992) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_993;
  assume IsGoodInhaleState(inhaleHeap#_993, Heap, Mask);
  assume this != null;
  Heap[this, Message.sender3] := inhaleHeap#_993[this, Message.sender3];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender3] == null) || (dtype(Heap[this, Message.sender3]) == Future#t);
  assume predicateK > 0;
  Mask[this, Message.sender3] := Mask[this, Message.sender3][perm$R := Mask[this, Message.sender3][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, Message.sender3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assume this != null;
  Heap[this, Message.receiver3] := inhaleHeap#_993[this, Message.receiver3];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver3] == null) || (dtype(Heap[this, Message.receiver3]) == FactorialCont#t);
  assume predicateK > 0;
  Mask[this, Message.receiver3] := Mask[this, Message.receiver3][perm$R := Mask[this, Message.receiver3][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, Message.receiver3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assume this != null;
  Heap[this, Message.vr2] := inhaleHeap#_993[this, Message.vr2];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[this, Message.vr2] := Mask[this, Message.vr2][perm$R := Mask[this, Message.vr2][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, Message.vr2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assume this != null;
  Heap[this, Message.old2] := inhaleHeap#_993[this, Message.old2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.old2] == null) || (dtype(Heap[this, Message.old2]) == FactorialCont#t);
  assume predicateK > 0;
  Mask[this, Message.old2] := Mask[this, Message.old2][perm$R := Mask[this, Message.old2][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[this, Message.old2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  639.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assume !(Heap[this, Message.sender3] == null);
  assert {:msg "  639.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.24: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assume Heap[this, Message.sender3] != null;
  Heap[Heap[this, Message.sender3], Future.q] := inhaleHeap#_993[Heap[this, Message.sender3], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender3], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender3], Future.q]) == FutureChannel#t);
  assume predicateK > 0;
  Mask[Heap[this, Message.sender3], Future.q] := Mask[Heap[this, Message.sender3], Future.q][perm$R := Mask[Heap[this, Message.sender3], Future.q][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, Message.sender3], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  639.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.38: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  639.38: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  639.38: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assume !(Heap[Heap[this, Message.sender3], Future.q] == null);
  assert {:msg "  639.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.57: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  639.57: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  639.57: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assert {:msg "  639.57: Receiver might be null."} Heap[Heap[this, Message.sender3], Future.q] != null;
  assert {:msg "  639.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.57: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  639.57: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  639.57: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assume Heap[Heap[this, Message.sender3], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := inhaleHeap#_993[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_993[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  639.77: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.77: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  639.77: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  639.77: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assert {:msg "  639.77: Receiver might be null."} Heap[Heap[this, Message.sender3], Future.q] != null;
  assert {:msg "  639.77: Receiver might be null."} true ==> (this != null);
  assert {:msg "  639.77: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  639.77: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  639.77: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assume Heap[Heap[this, Message.sender3], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := inhaleHeap#_993[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_993[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  640.6: Receiver might be null."} true ==> (this != null);
  assert {:msg "  640.6: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assume Heap[this, Message.old2] != null;
  Heap[Heap[this, Message.old2], FactorialCont.v] := inhaleHeap#_993[Heap[this, Message.old2], FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[Heap[this, Message.old2], FactorialCont.v] := Mask[Heap[this, Message.old2], FactorialCont.v][perm$R := Mask[Heap[this, Message.old2], FactorialCont.v][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, Message.old2], FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  640.19: Receiver might be null."} true ==> (this != null);
  assert {:msg "  640.19: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assume Heap[this, Message.old2] != null;
  Heap[Heap[this, Message.old2], FactorialCont.vo] := inhaleHeap#_993[Heap[this, Message.old2], FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[Heap[this, Message.old2], FactorialCont.vo] := Mask[Heap[this, Message.old2], FactorialCont.vo][perm$R := Mask[Heap[this, Message.old2], FactorialCont.vo][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, Message.old2], FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  640.33: Receiver might be null."} true ==> (this != null);
  assert {:msg "  640.33: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assume Heap[this, Message.old2] != null;
  Heap[Heap[this, Message.old2], FactorialCont.cust] := inhaleHeap#_993[Heap[this, Message.old2], FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.old2], FactorialCont.cust] == null) || (dtype(Heap[Heap[this, Message.old2], FactorialCont.cust]) == FactorialCont#t);
  assume predicateK > 0;
  Mask[Heap[this, Message.old2], FactorialCont.cust] := Mask[Heap[this, Message.old2], FactorialCont.cust][perm$R := Mask[Heap[this, Message.old2], FactorialCont.cust][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_993[Heap[this, Message.old2], FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_993, Mask);
  assert {:msg "  641.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  641.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assert {:msg "  641.3: Receiver might be null."} true ==> (Heap[this, Message.old2] != null);
  assert {:msg "  641.3: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.old2], FactorialCont.v);
  assume Heap[Heap[this, Message.old2], FactorialCont.v] >= 0;
  assert {:msg "  641.16: Receiver might be null."} true ==> (this != null);
  assert {:msg "  641.16: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assert {:msg "  641.16: Receiver might be null."} true ==> (Heap[this, Message.old2] != null);
  assert {:msg "  641.16: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.old2], FactorialCont.vo);
  assume Heap[Heap[this, Message.old2], FactorialCont.vo] >= 0;
  assert {:msg "  641.31: Receiver might be null."} true ==> (this != null);
  assert {:msg "  641.31: Location might not be readable."} true ==> CanRead(Mask, this, Message.vr2);
  assert {:msg "  641.46: Receiver might be null."} true ==> (this != null);
  assert {:msg "  641.46: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assert {:msg "  641.46: Receiver might be null."} true ==> (Heap[this, Message.old2] != null);
  assert {:msg "  641.46: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.old2], FactorialCont.v);
  assert {:msg "  641.36: Receiver might be null."} true ==> (this != null);
  // check precondition of call
  assume (0 < funcappK#_1000) && ((1000 * funcappK#_1000) < Fractions(1));
  assume true;
  Heap#_997 := Heap;
  Mask#_998 := Mask;
  Credits#_999 := Credits;
  // begin exhale (function call)
  exhaleMask#_1001 := Mask#_998;
  assert {:msg "  641.36: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_997[Heap#_997[this, Message.old2], FactorialCont.v] >= 0;
  Mask#_998 := exhaleMask#_1001;
  assume wf(Heap#_997, Mask#_998);
  // end exhale
  assume Heap[this, Message.vr2] == #Message.factorial(Heap, Mask, this, Heap[Heap[this, Message.old2], FactorialCont.v]);
  assert {:msg "  641.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  641.57: Location might not be readable."} true ==> CanRead(Mask, this, Message.old2);
  assert {:msg "  641.57: Receiver might be null."} true ==> (Heap[this, Message.old2] != null);
  assert {:msg "  641.57: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.old2], FactorialCont.cust);
  assert {:msg "  641.68: Receiver might be null."} true ==> (this != null);
  assert {:msg "  641.68: Location might not be readable."} true ==> CanRead(Mask, this, Message.receiver3);
  assume Heap[Heap[this, Message.old2], FactorialCont.cust] == Heap[this, Message.receiver3];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique Message.invFinalResult: Field (HeapType);
axiom PredicateField(Message.invFinalResult);
procedure Message.invFinalResult$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_1002: int;
  var inhaleHeap#_1003: HeapType;
  assume (0 < predicateK#_1002) && ((1000 * predicateK#_1002) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_1003;
  assume IsGoodInhaleState(inhaleHeap#_1003, Heap, Mask);
  assume this != null;
  Heap[this, Message.sender4] := inhaleHeap#_1003[this, Message.sender4];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender4] == null) || (dtype(Heap[this, Message.sender4]) == FactorialCont#t);
  assume predicateK > 0;
  Mask[this, Message.sender4] := Mask[this, Message.sender4][perm$R := Mask[this, Message.sender4][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1003[this, Message.sender4]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1003, Mask);
  assume this != null;
  Heap[this, Message.receiver4] := inhaleHeap#_1003[this, Message.receiver4];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver4] == null) || (dtype(Heap[this, Message.receiver4]) == Future#t);
  assume predicateK > 0;
  Mask[this, Message.receiver4] := Mask[this, Message.receiver4][perm$R := Mask[this, Message.receiver4][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1003[this, Message.receiver4]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1003, Mask);
  assume this != null;
  Heap[this, Message.vr3] := inhaleHeap#_1003[this, Message.vr3];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[this, Message.vr3] := Mask[this, Message.vr3][perm$R := Mask[this, Message.vr3][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1003[this, Message.vr3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1003, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
const unique Message.inv: Field (HeapType);
axiom PredicateField(Message.inv);
procedure Message.inv$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var predicateK#_1004: int;
  var inhaleHeap#_1005: HeapType;
  assume (0 < predicateK#_1004) && ((1000 * predicateK#_1004) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (predicate definition)
  havoc inhaleHeap#_1005;
  assume IsGoodInhaleState(inhaleHeap#_1005, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1005[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume predicateK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + predicateK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1005[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1005, Mask);
  assert {:msg "  650.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  650.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  if (Heap[this, Message.type] == 1) {
    assert {:msg "  650.16: Receiver might be null."} this != null;
    assume this != null;
    Heap[this, Message.invValue] := inhaleHeap#_1005[this, Message.invValue];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1005[this, Message.invValue] == Heap;
    assume Fractions(100) > 0;
    Mask[this, Message.invValue] := Mask[this, Message.invValue][perm$R := Mask[this, Message.invValue][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1005[this, Message.invValue]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1005, Mask);
  } else {
  }
  assert {:msg "  651.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  651.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  if (Heap[this, Message.type] == 2) {
    assert {:msg "  651.16: Receiver might be null."} this != null;
    assume this != null;
    Heap[this, Message.invResult1] := inhaleHeap#_1005[this, Message.invResult1];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1005[this, Message.invResult1] == Heap;
    assume Fractions(100) > 0;
    Mask[this, Message.invResult1] := Mask[this, Message.invResult1][perm$R := Mask[this, Message.invResult1][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1005[this, Message.invResult1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1005, Mask);
  } else {
  }
  assert {:msg "  652.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  652.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  if (Heap[this, Message.type] == 3) {
    assert {:msg "  652.16: Receiver might be null."} this != null;
    assume this != null;
    Heap[this, Message.invResult2] := inhaleHeap#_1005[this, Message.invResult2];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1005[this, Message.invResult2] == Heap;
    assume Fractions(100) > 0;
    Mask[this, Message.invResult2] := Mask[this, Message.invResult2][perm$R := Mask[this, Message.invResult2][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1005[this, Message.invResult2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1005, Mask);
  } else {
  }
  assert {:msg "  653.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  653.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  if (Heap[this, Message.type] == 4) {
    assert {:msg "  653.16: Receiver might be null."} this != null;
    assume this != null;
    Heap[this, Message.invFinalResult] := inhaleHeap#_1005[this, Message.invFinalResult];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1005[this, Message.invFinalResult] == Heap;
    assume Fractions(100) > 0;
    Mask[this, Message.invFinalResult] := Mask[this, Message.invFinalResult][perm$R := Mask[this, Message.invFinalResult][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1005[this, Message.invFinalResult]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1005, Mask);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Message.setValue$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t), v#50: int where true, vo#51: int where true, cust#52: ref where (cust#52 == null) || (dtype(cust#52) == FactorialCont#t), receiver#53: ref where (receiver#53 == null) || (dtype(receiver#53) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1006: int;
  var inhaleHeap#_1007: HeapType;
  var inhaleHeap#_1008: HeapType;
  assume (0 < methodK#_1006) && ((1000 * methodK#_1006) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1007;
  assume IsGoodInhaleState(inhaleHeap#_1007, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1007[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assume this != null;
  Heap[this, Message.sender1] := inhaleHeap#_1007[this, Message.sender1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender1] == null) || (dtype(Heap[this, Message.sender1]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender1] := Mask[this, Message.sender1][perm$R := Mask[this, Message.sender1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[this, Message.sender1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assume this != null;
  Heap[this, Message.receiver1] := inhaleHeap#_1007[this, Message.receiver1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver1] == null) || (dtype(Heap[this, Message.receiver1]) == FactorialActor#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver1] := Mask[this, Message.receiver1][perm$R := Mask[this, Message.receiver1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[this, Message.receiver1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assume this != null;
  Heap[this, Message.v1] := inhaleHeap#_1007[this, Message.v1];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.v1] := Mask[this, Message.v1][perm$R := Mask[this, Message.v1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[this, Message.v1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assume this != null;
  Heap[this, Message.vo1] := inhaleHeap#_1007[this, Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vo1] := Mask[this, Message.vo1][perm$R := Mask[this, Message.vo1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[this, Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assume this != null;
  Heap[this, Message.cust1] := inhaleHeap#_1007[this, Message.cust1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.cust1] == null) || (dtype(Heap[this, Message.cust1]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.cust1] := Mask[this, Message.cust1][perm$R := Mask[this, Message.cust1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[this, Message.cust1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assert {:msg "  661.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  661.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assume !(Heap[this, Message.sender1] == null);
  assert {:msg "  661.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  661.23: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assume Heap[this, Message.sender1] != null;
  Heap[Heap[this, Message.sender1], Future.q] := inhaleHeap#_1007[Heap[this, Message.sender1], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender1], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender1], Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, Message.sender1], Future.q] := Mask[Heap[this, Message.sender1], Future.q][perm$R := Mask[Heap[this, Message.sender1], Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[Heap[this, Message.sender1], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assert {:msg "  661.42: Receiver might be null."} true ==> (this != null);
  assert {:msg "  661.42: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  661.42: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  661.42: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assume !(Heap[Heap[this, Message.sender1], Future.q] == null);
  assert {:msg "  662.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  662.3: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  662.3: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assert {:msg "  662.3: Receiver might be null."} Heap[Heap[this, Message.sender1], Future.q] != null;
  assert {:msg "  662.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.3: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  662.3: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  662.3: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assume Heap[Heap[this, Message.sender1], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := inhaleHeap#_1007[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1007[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assert {:msg "  662.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.22: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  662.22: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  662.22: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assert {:msg "  662.22: Receiver might be null."} Heap[Heap[this, Message.sender1], Future.q] != null;
  assert {:msg "  662.22: Receiver might be null."} true ==> (this != null);
  assert {:msg "  662.22: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender1);
  assert {:msg "  662.22: Receiver might be null."} true ==> (Heap[this, Message.sender1] != null);
  assert {:msg "  662.22: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender1], Future.q);
  assume Heap[Heap[this, Message.sender1], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := inhaleHeap#_1007[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1007[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1007[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1007, Mask);
  assume v#50 >= 0;
  assume vo#51 >= 0;
  if (cust#52 == null) {
    assume v#50 == vo#51;
  } else {
  }
  if (!(cust#52 == null)) {
    assume cust#52 != null;
    Heap[cust#52, FactorialCont.q] := inhaleHeap#_1007[cust#52, FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[cust#52, FactorialCont.q] == null) || (dtype(Heap[cust#52, FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[cust#52, FactorialCont.q] := Mask[cust#52, FactorialCont.q][perm$R := Mask[cust#52, FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[cust#52, FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assert {:msg "  664.23: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  664.23: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assume !(Heap[cust#52, FactorialCont.q] == null);
    assert {:msg "  664.39: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  664.39: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assert {:msg "  664.39: Receiver might be null."} Heap[cust#52, FactorialCont.q] != null;
    assert {:msg "  664.39: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  664.39: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assume Heap[cust#52, FactorialCont.q] != null;
    Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assert {:msg "  664.55: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  664.55: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assert {:msg "  664.55: Receiver might be null."} Heap[cust#52, FactorialCont.q] != null;
    assert {:msg "  664.55: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  664.55: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assume Heap[cust#52, FactorialCont.q] != null;
    Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assert {:msg "  665.6: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assume Heap[cust#52, FactorialCont.q] != null;
    Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
    assume monitorK > 0;
    Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assert {:msg "  665.29: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[cust#52, FactorialCont.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[cust#52, FactorialCont.q], FactorialContChannel.imp);
    assume Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] != null;
    Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1007[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assert {:msg "  665.55: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  665.55: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.q);
    assert {:msg "  665.55: Receiver might be null."} true ==> (Heap[cust#52, FactorialCont.q] != null);
    assert {:msg "  665.55: Location might not be readable."} true ==> CanRead(Mask, Heap[cust#52, FactorialCont.q], FactorialContChannel.imp);
    assert {:msg "  665.55: Receiver might be null."} true ==> (Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] != null);
    assert {:msg "  665.55: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
    assume !(Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assume cust#52 != null;
    Heap[cust#52, FactorialCont.v] := inhaleHeap#_1007[cust#52, FactorialCont.v];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[cust#52, FactorialCont.v] := Mask[cust#52, FactorialCont.v][perm$R := Mask[cust#52, FactorialCont.v][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[cust#52, FactorialCont.v]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assume cust#52 != null;
    Heap[cust#52, FactorialCont.vo] := inhaleHeap#_1007[cust#52, FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[cust#52, FactorialCont.vo] := Mask[cust#52, FactorialCont.vo][perm$R := Mask[cust#52, FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1007[cust#52, FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1007, Mask);
    assert {:msg "  666.26: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  666.26: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.v);
    assume v#50 == (Heap[cust#52, FactorialCont.v] - 1);
    assert {:msg "  666.42: Receiver might be null."} true ==> (cust#52 != null);
    assert {:msg "  666.42: Location might not be readable."} true ==> CanRead(Mask, cust#52, FactorialCont.vo);
    assume vo#51 == Heap[cust#52, FactorialCont.vo];
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1008;
  assume IsGoodInhaleState(inhaleHeap#_1008, Heap, Mask);
  assert {:msg "  668.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, Message.invValue] := inhaleHeap#_1008[this, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1008[this, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invValue] := Mask[this, Message.invValue][perm$R := Mask[this, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1008[this, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1008, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1008[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1008[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1008, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1008[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1008[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1008, Mask);
  assert {:msg "  668.57: Receiver might be null."} true ==> (this != null);
  assert {:msg "  668.57: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  assume Heap[this, Message.type] == 1;
  assume this != null;
  Heap[this, Message.vo1] := inhaleHeap#_1008[this, Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.vo1] := Mask[this, Message.vo1][perm$R := Mask[this, Message.vo1][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1008[this, Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1008, Mask);
  assert {:msg "  668.84: Receiver might be null."} true ==> (this != null);
  assert {:msg "  668.84: Location might not be readable."} true ==> CanRead(Mask, this, Message.vo1);
  assume Heap[this, Message.vo1] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Message.setValue(this: ref where (this == null) || (dtype(this) == Message#t), v#50: int where true, vo#51: int where true, cust#52: ref where (cust#52 == null) || (dtype(cust#52) == FactorialCont#t), receiver#53: ref where (receiver#53 == null) || (dtype(receiver#53) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1006: int;
  var inhaleHeap#_1009: HeapType;
  var foldK#_1010: int;
  var exhaleMask#_1011: MaskType;
  var inhaleHeap#_1027: HeapType;
  var exhaleMask#_1028: MaskType;
  assume (0 < methodK#_1006) && ((1000 * methodK#_1006) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1009;
  assume IsGoodInhaleState(inhaleHeap#_1009, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1009[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume this != null;
  Heap[this, Message.sender1] := inhaleHeap#_1009[this, Message.sender1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender1] == null) || (dtype(Heap[this, Message.sender1]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender1] := Mask[this, Message.sender1][perm$R := Mask[this, Message.sender1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[this, Message.sender1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume this != null;
  Heap[this, Message.receiver1] := inhaleHeap#_1009[this, Message.receiver1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver1] == null) || (dtype(Heap[this, Message.receiver1]) == FactorialActor#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver1] := Mask[this, Message.receiver1][perm$R := Mask[this, Message.receiver1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[this, Message.receiver1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume this != null;
  Heap[this, Message.v1] := inhaleHeap#_1009[this, Message.v1];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.v1] := Mask[this, Message.v1][perm$R := Mask[this, Message.v1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[this, Message.v1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume this != null;
  Heap[this, Message.vo1] := inhaleHeap#_1009[this, Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vo1] := Mask[this, Message.vo1][perm$R := Mask[this, Message.vo1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[this, Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume this != null;
  Heap[this, Message.cust1] := inhaleHeap#_1009[this, Message.cust1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.cust1] == null) || (dtype(Heap[this, Message.cust1]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.cust1] := Mask[this, Message.cust1][perm$R := Mask[this, Message.cust1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[this, Message.cust1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume !(Heap[this, Message.sender1] == null);
  assume Heap[this, Message.sender1] != null;
  Heap[Heap[this, Message.sender1], Future.q] := inhaleHeap#_1009[Heap[this, Message.sender1], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender1], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender1], Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, Message.sender1], Future.q] := Mask[Heap[this, Message.sender1], Future.q][perm$R := Mask[Heap[this, Message.sender1], Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[Heap[this, Message.sender1], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume !(Heap[Heap[this, Message.sender1], Future.q] == null);
  assume Heap[Heap[this, Message.sender1], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := inhaleHeap#_1009[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1009[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume Heap[Heap[this, Message.sender1], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := inhaleHeap#_1009[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1009[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1009[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1009, Mask);
  assume v#50 >= 0;
  assume vo#51 >= 0;
  if (cust#52 == null) {
    assume v#50 == vo#51;
  } else {
  }
  if (!(cust#52 == null)) {
    assume cust#52 != null;
    Heap[cust#52, FactorialCont.q] := inhaleHeap#_1009[cust#52, FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[cust#52, FactorialCont.q] == null) || (dtype(Heap[cust#52, FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[cust#52, FactorialCont.q] := Mask[cust#52, FactorialCont.q][perm$R := Mask[cust#52, FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[cust#52, FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume !(Heap[cust#52, FactorialCont.q] == null);
    assume Heap[cust#52, FactorialCont.q] != null;
    Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume Heap[cust#52, FactorialCont.q] != null;
    Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume Heap[cust#52, FactorialCont.q] != null;
    Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
    assume monitorK > 0;
    Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp] != null;
    Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1009[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume !(Heap[Heap[Heap[cust#52, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assume cust#52 != null;
    Heap[cust#52, FactorialCont.v] := inhaleHeap#_1009[cust#52, FactorialCont.v];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[cust#52, FactorialCont.v] := Mask[cust#52, FactorialCont.v][perm$R := Mask[cust#52, FactorialCont.v][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[cust#52, FactorialCont.v]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume cust#52 != null;
    Heap[cust#52, FactorialCont.vo] := inhaleHeap#_1009[cust#52, FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[cust#52, FactorialCont.vo] := Mask[cust#52, FactorialCont.vo][perm$R := Mask[cust#52, FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1009[cust#52, FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1009, Mask);
    assume v#50 == (Heap[cust#52, FactorialCont.v] - 1);
    assume vo#51 == Heap[cust#52, FactorialCont.vo];
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field type
  assert {:msg "  670.3: Location might not be writable"} CanWrite(Mask, this, Message.type);
  Heap[this, Message.type] := 1;
  assume wf(Heap, Mask);
  // update field v1
  assert {:msg "  671.3: Location might not be writable"} CanWrite(Mask, this, Message.v1);
  Heap[this, Message.v1] := v#50;
  assume wf(Heap, Mask);
  // update field vo1
  assert {:msg "  672.3: Location might not be writable"} CanWrite(Mask, this, Message.vo1);
  Heap[this, Message.vo1] := vo#51;
  assume wf(Heap, Mask);
  // update field cust1
  assert {:msg "  673.3: Location might not be writable"} CanWrite(Mask, this, Message.cust1);
  Heap[this, Message.cust1] := cust#52;
  assume wf(Heap, Mask);
  // update field receiver1
  assert {:msg "  674.3: Location might not be writable"} CanWrite(Mask, this, Message.receiver1);
  Heap[this, Message.receiver1] := receiver#53;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_1010) && ((1000 * foldK#_1010) < Fractions(1)) && ((1000 * foldK#_1010) < methodK#_1006);
  assert {:msg "  675.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1011 := Mask;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 627.3 might not evaluate to true."} !(Heap[this, Message.sender1] == null);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 627.37 might not evaluate to true."} !(Heap[Heap[this, Message.sender1], Future.q] == null);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 627.101 might not evaluate to true."} Heap[this, Message.v1] >= 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 627.110 might not evaluate to true."} Heap[this, Message.vo1] >= 0;
  if (Heap[this, Message.cust1] == null) {
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 628.23 might not evaluate to true."} Heap[this, Message.v1] == Heap[this, Message.vo1];
  } else {
  }
  if (!(Heap[this, Message.cust1] == null)) {
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 628.68 might not evaluate to true."} !(Heap[Heap[this, Message.cust1], FactorialCont.q] == null);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 629.88 might not evaluate to true."} !(Heap[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 629.149 might not evaluate to true."} Heap[this, Message.v1] == (Heap[Heap[this, Message.cust1], FactorialCont.v] - 1);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The expression at 629.166 might not evaluate to true."} Heap[this, Message.vo1] == Heap[Heap[this, Message.cust1], FactorialCont.vo];
  } else {
  }
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 626.3 might not be positive."} predicateK > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 626.3 for Message.sender1."} (predicateK <= exhaleMask#_1011[this, Message.sender1][perm$R]) && ((predicateK == exhaleMask#_1011[this, Message.sender1][perm$R]) ==> (0 <= exhaleMask#_1011[this, Message.sender1][perm$N]));
  exhaleMask#_1011[this, Message.sender1] := exhaleMask#_1011[this, Message.sender1][perm$R := exhaleMask#_1011[this, Message.sender1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 626.18 might not be positive."} predicateK > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 626.18 for Message.receiver1."} (predicateK <= exhaleMask#_1011[this, Message.receiver1][perm$R]) && ((predicateK == exhaleMask#_1011[this, Message.receiver1][perm$R]) ==> (0 <= exhaleMask#_1011[this, Message.receiver1][perm$N]));
  exhaleMask#_1011[this, Message.receiver1] := exhaleMask#_1011[this, Message.receiver1][perm$R := exhaleMask#_1011[this, Message.receiver1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 626.35 might not be positive."} predicateK > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 626.35 for Message.cust1."} (predicateK <= exhaleMask#_1011[this, Message.cust1][perm$R]) && ((predicateK == exhaleMask#_1011[this, Message.cust1][perm$R]) ==> (0 <= exhaleMask#_1011[this, Message.cust1][perm$N]));
  exhaleMask#_1011[this, Message.cust1] := exhaleMask#_1011[this, Message.cust1][perm$R := exhaleMask#_1011[this, Message.cust1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 626.48 might not be positive."} predicateK > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 626.48 for Message.v1."} (predicateK <= exhaleMask#_1011[this, Message.v1][perm$R]) && ((predicateK == exhaleMask#_1011[this, Message.v1][perm$R]) ==> (0 <= exhaleMask#_1011[this, Message.v1][perm$N]));
  exhaleMask#_1011[this, Message.v1] := exhaleMask#_1011[this, Message.v1][perm$R := exhaleMask#_1011[this, Message.v1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 626.58 might not be positive."} predicateK > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 626.58 for Message.vo1."} (predicateK <= exhaleMask#_1011[this, Message.vo1][perm$R]) && ((predicateK == exhaleMask#_1011[this, Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1011[this, Message.vo1][perm$N]));
  exhaleMask#_1011[this, Message.vo1] := exhaleMask#_1011[this, Message.vo1][perm$R := exhaleMask#_1011[this, Message.vo1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 627.20 might not be positive."} predicateK > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 627.20 for Future.q."} (predicateK <= exhaleMask#_1011[Heap[this, Message.sender1], Future.q][perm$R]) && ((predicateK == exhaleMask#_1011[Heap[this, Message.sender1], Future.q][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this, Message.sender1], Future.q][perm$N]));
  exhaleMask#_1011[Heap[this, Message.sender1], Future.q] := exhaleMask#_1011[Heap[this, Message.sender1], Future.q][perm$R := exhaleMask#_1011[Heap[this, Message.sender1], Future.q][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 627.56 might not be positive."} Fractions(100) > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 627.56 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$N]));
  exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid] := exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 627.75 might not be positive."} Fractions(100) > 0;
  assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 627.75 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$N]));
  exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState] := exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1011[Heap[Heap[this, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1011);
  if (Heap[this, Message.cust1] == null) {
  } else {
  }
  if (!(Heap[this, Message.cust1] == null)) {
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 628.53 might not be positive."} predicateK > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 628.53 for FactorialCont.q."} (predicateK <= exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.q][perm$R]) && ((predicateK == exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.q][perm$N]));
    exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.q] := exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.q][perm$R := exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.q][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 629.3 might not be positive."} Fractions(100) > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 629.3 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$N]));
    exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 629.20 might not be positive."} Fractions(100) > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 629.20 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
    exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 629.44 might not be positive."} predicateK > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 629.44 for FactorialContChannel.imp."} (predicateK <= exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R]) && ((predicateK == exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$N]));
    exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R := exhaleMask#_1011[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 629.63 might not be positive."} predicateK > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 629.63 for FactorialContChannelImpEP.impch."} (predicateK <= exhaleMask#_1011[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((predicateK == exhaleMask#_1011[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
    exhaleMask#_1011[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_1011[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1011[Heap[Heap[Heap[this, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 629.115 might not be positive."} predicateK > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 629.115 for FactorialCont.v."} (predicateK <= exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.v][perm$R]) && ((predicateK == exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.v][perm$N]));
    exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.v] := exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.v][perm$R := exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.v][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. The permission at 629.132 might not be positive."} predicateK > 0;
    assert {:msg "  675.3: Fold might fail because the definition of Message.invValue does not hold. Insufficient fraction at 629.132 for FactorialCont.vo."} (predicateK <= exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.vo][perm$R]) && ((predicateK == exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.vo][perm$N]));
    exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.vo] := exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.vo][perm$R := exhaleMask#_1011[Heap[this, Message.cust1], FactorialCont.vo][perm$R] - predicateK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1011);
  } else {
  }
  Mask := exhaleMask#_1011;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_1027;
  assume IsGoodInhaleState(inhaleHeap#_1027, Heap, Mask);
  assume this != null;
  Heap[this, Message.invValue] := inhaleHeap#_1027[this, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1027[this, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invValue] := Mask[this, Message.invValue][perm$R := Mask[this, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1027[this, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1027, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, Message.invValue] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_1028 := Mask;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. The expression at 668.57 might not evaluate to true."} Heap[this, Message.type] == 1;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. The expression at 668.84 might not evaluate to true."} Heap[this, Message.vo1] >= 0;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. The permission at 668.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. Insufficient fraction at 668.10 for Message.invValue."} (Fractions(100) <= exhaleMask#_1028[this, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_1028[this, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_1028[this, Message.invValue][perm$N]));
  exhaleMask#_1028[this, Message.invValue] := exhaleMask#_1028[this, Message.invValue][perm$R := exhaleMask#_1028[this, Message.invValue][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1028);
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. The permission at 668.23 might not be positive."} monitorK > 0;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. Insufficient fraction at 668.23 for Message.type."} (monitorK <= exhaleMask#_1028[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1028[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1028[this, Message.type][perm$N]));
  exhaleMask#_1028[this, Message.type] := exhaleMask#_1028[this, Message.type][perm$R := exhaleMask#_1028[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1028);
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. The permission at 668.40 might not be positive."} monitorK > 0;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. Insufficient fraction at 668.40 for Message.type."} (monitorK <= exhaleMask#_1028[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1028[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1028[this, Message.type][perm$N]));
  exhaleMask#_1028[this, Message.type] := exhaleMask#_1028[this, Message.type][perm$R := exhaleMask#_1028[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1028);
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. The permission at 668.68 might not be positive."} monitorK > 0;
  assert {:msg "  658.2: The postcondition at 668.10 might not hold. Insufficient fraction at 668.68 for Message.vo1."} (monitorK <= exhaleMask#_1028[this, Message.vo1][perm$R]) && ((monitorK == exhaleMask#_1028[this, Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1028[this, Message.vo1][perm$N]));
  exhaleMask#_1028[this, Message.vo1] := exhaleMask#_1028[this, Message.vo1][perm$R := exhaleMask#_1028[this, Message.vo1][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1028);
  Mask := exhaleMask#_1028;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  658.2: Method might lock/unlock more than allowed."} (forall lk#_1033: ref :: {Heap[lk#_1033, held]} {Heap[lk#_1033, rdheld]} (((0 < Heap[lk#_1033, held]) == (0 < old(Heap)[lk#_1033, held])) && (Heap[lk#_1033, rdheld] == old(Heap)[lk#_1033, rdheld])) || false);
  assert {:msg "  658.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure Message.setResult1$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t), v#54: int where true, oldv#55: ref where (oldv#55 == null) || (dtype(oldv#55) == FactorialActor#t), receiver#56: ref where (receiver#56 == null) || (dtype(receiver#56) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1034: int;
  var inhaleHeap#_1035: HeapType;
  var funcappK#_1042: int;
  var Heap#_1039: HeapType;
  var Mask#_1040: MaskType;
  var Credits#_1041: CreditsType;
  var exhaleMask#_1043: MaskType;
  var inhaleHeap#_1044: HeapType;
  assume (0 < methodK#_1034) && ((1000 * methodK#_1034) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1035;
  assume IsGoodInhaleState(inhaleHeap#_1035, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1035[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assume this != null;
  Heap[this, Message.sender2] := inhaleHeap#_1035[this, Message.sender2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender2] == null) || (dtype(Heap[this, Message.sender2]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender2] := Mask[this, Message.sender2][perm$R := Mask[this, Message.sender2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[this, Message.sender2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assume this != null;
  Heap[this, Message.receiver2] := inhaleHeap#_1035[this, Message.receiver2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver2] == null) || (dtype(Heap[this, Message.receiver2]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver2] := Mask[this, Message.receiver2][perm$R := Mask[this, Message.receiver2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[this, Message.receiver2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assume this != null;
  Heap[this, Message.vr1] := inhaleHeap#_1035[this, Message.vr1];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vr1] := Mask[this, Message.vr1][perm$R := Mask[this, Message.vr1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[this, Message.vr1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assume this != null;
  Heap[this, Message.old1] := inhaleHeap#_1035[this, Message.old1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.old1] == null) || (dtype(Heap[this, Message.old1]) == FactorialActor#t);
  assume Fractions(100) > 0;
  Mask[this, Message.old1] := Mask[this, Message.old1][perm$R := Mask[this, Message.old1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[this, Message.old1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assert {:msg "  681.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assume !(Heap[this, Message.sender2] == null);
  assert {:msg "  681.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.25: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assume Heap[this, Message.sender2] != null;
  Heap[Heap[this, Message.sender2], Future.q] := inhaleHeap#_1035[Heap[this, Message.sender2], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender2], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender2], Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, Message.sender2], Future.q] := Mask[Heap[this, Message.sender2], Future.q][perm$R := Mask[Heap[this, Message.sender2], Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[Heap[this, Message.sender2], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assert {:msg "  681.44: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.44: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  681.44: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  681.44: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assume !(Heap[Heap[this, Message.sender2], Future.q] == null);
  assert {:msg "  681.63: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.63: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  681.63: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  681.63: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assert {:msg "  681.63: Receiver might be null."} Heap[Heap[this, Message.sender2], Future.q] != null;
  assert {:msg "  681.63: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.63: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  681.63: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  681.63: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assume Heap[Heap[this, Message.sender2], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := inhaleHeap#_1035[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1035[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assert {:msg "  681.82: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.82: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  681.82: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  681.82: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assert {:msg "  681.82: Receiver might be null."} Heap[Heap[this, Message.sender2], Future.q] != null;
  assert {:msg "  681.82: Receiver might be null."} true ==> (this != null);
  assert {:msg "  681.82: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender2);
  assert {:msg "  681.82: Receiver might be null."} true ==> (Heap[this, Message.sender2] != null);
  assert {:msg "  681.82: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender2], Future.q);
  assume Heap[Heap[this, Message.sender2], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := inhaleHeap#_1035[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1035[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assert {:msg "  682.6: Receiver might be null."} true ==> (this != null);
  // check precondition of call
  assume (0 < funcappK#_1042) && ((1000 * funcappK#_1042) < Fractions(1));
  assume true;
  Heap#_1039 := Heap;
  Mask#_1040 := Mask;
  Credits#_1041 := Credits;
  // begin exhale (function call)
  exhaleMask#_1043 := Mask#_1040;
  assert {:msg "  682.6: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} 0 >= 0;
  Mask#_1040 := exhaleMask#_1043;
  assume wf(Heap#_1039, Mask#_1040);
  // end exhale
  assume v#54 == #Message.factorial(Heap, Mask, this, 0);
  assume receiver#56 != null;
  Heap[receiver#56, FactorialCont.v] := inhaleHeap#_1035[receiver#56, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[receiver#56, FactorialCont.v] := Mask[receiver#56, FactorialCont.v][perm$R := Mask[receiver#56, FactorialCont.v][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1035[receiver#56, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1035, Mask);
  assume !(receiver#56 == null);
  assert {:msg "  682.64: Receiver might be null."} true ==> (receiver#56 != null);
  assert {:msg "  682.64: Location might not be readable."} true ==> CanRead(Mask, receiver#56, FactorialCont.v);
  assume Heap[receiver#56, FactorialCont.v] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1044;
  assume IsGoodInhaleState(inhaleHeap#_1044, Heap, Mask);
  assert {:msg "  683.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, Message.invResult1] := inhaleHeap#_1044[this, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1044[this, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invResult1] := Mask[this, Message.invResult1][perm$R := Mask[this, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1044[this, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1044, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1044[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1044[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1044, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1044[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1044[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1044, Mask);
  assert {:msg "  683.58: Receiver might be null."} true ==> (this != null);
  assert {:msg "  683.58: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  assume Heap[this, Message.type] == 2;
  assume this != null;
  Heap[this, Message.receiver2] := inhaleHeap#_1044[this, Message.receiver2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver2] == null) || (dtype(Heap[this, Message.receiver2]) == FactorialCont#t);
  assume monitorK > 0;
  Mask[this, Message.receiver2] := Mask[this, Message.receiver2][perm$R := Mask[this, Message.receiver2][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1044[this, Message.receiver2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1044, Mask);
  assert {:msg "  683.91: Receiver might be null."} true ==> (this != null);
  assert {:msg "  683.91: Location might not be readable."} true ==> CanRead(Mask, this, Message.receiver2);
  assume Heap[this, Message.receiver2] == receiver#56;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Message.setResult1(this: ref where (this == null) || (dtype(this) == Message#t), v#54: int where true, oldv#55: ref where (oldv#55 == null) || (dtype(oldv#55) == FactorialActor#t), receiver#56: ref where (receiver#56 == null) || (dtype(receiver#56) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1034: int;
  var inhaleHeap#_1045: HeapType;
  var foldK#_1046: int;
  var exhaleMask#_1047: MaskType;
  var inhaleHeap#_1056: HeapType;
  var exhaleMask#_1057: MaskType;
  assume (0 < methodK#_1034) && ((1000 * methodK#_1034) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1045;
  assume IsGoodInhaleState(inhaleHeap#_1045, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1045[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume this != null;
  Heap[this, Message.sender2] := inhaleHeap#_1045[this, Message.sender2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender2] == null) || (dtype(Heap[this, Message.sender2]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender2] := Mask[this, Message.sender2][perm$R := Mask[this, Message.sender2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[this, Message.sender2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume this != null;
  Heap[this, Message.receiver2] := inhaleHeap#_1045[this, Message.receiver2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver2] == null) || (dtype(Heap[this, Message.receiver2]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver2] := Mask[this, Message.receiver2][perm$R := Mask[this, Message.receiver2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[this, Message.receiver2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume this != null;
  Heap[this, Message.vr1] := inhaleHeap#_1045[this, Message.vr1];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vr1] := Mask[this, Message.vr1][perm$R := Mask[this, Message.vr1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[this, Message.vr1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume this != null;
  Heap[this, Message.old1] := inhaleHeap#_1045[this, Message.old1];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.old1] == null) || (dtype(Heap[this, Message.old1]) == FactorialActor#t);
  assume Fractions(100) > 0;
  Mask[this, Message.old1] := Mask[this, Message.old1][perm$R := Mask[this, Message.old1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[this, Message.old1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume !(Heap[this, Message.sender2] == null);
  assume Heap[this, Message.sender2] != null;
  Heap[Heap[this, Message.sender2], Future.q] := inhaleHeap#_1045[Heap[this, Message.sender2], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender2], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender2], Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, Message.sender2], Future.q] := Mask[Heap[this, Message.sender2], Future.q][perm$R := Mask[Heap[this, Message.sender2], Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[Heap[this, Message.sender2], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume !(Heap[Heap[this, Message.sender2], Future.q] == null);
  assume Heap[Heap[this, Message.sender2], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := inhaleHeap#_1045[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1045[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume Heap[Heap[this, Message.sender2], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := inhaleHeap#_1045[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1045[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume v#54 == #Message.factorial(Heap, Mask, this, 0);
  assume receiver#56 != null;
  Heap[receiver#56, FactorialCont.v] := inhaleHeap#_1045[receiver#56, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[receiver#56, FactorialCont.v] := Mask[receiver#56, FactorialCont.v][perm$R := Mask[receiver#56, FactorialCont.v][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1045[receiver#56, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1045, Mask);
  assume !(receiver#56 == null);
  assume Heap[receiver#56, FactorialCont.v] == 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field type
  assert {:msg "  685.3: Location might not be writable"} CanWrite(Mask, this, Message.type);
  Heap[this, Message.type] := 2;
  assume wf(Heap, Mask);
  // update field vr1
  assert {:msg "  686.3: Location might not be writable"} CanWrite(Mask, this, Message.vr1);
  Heap[this, Message.vr1] := v#54;
  assume wf(Heap, Mask);
  // update field old1
  assert {:msg "  687.3: Location might not be writable"} CanWrite(Mask, this, Message.old1);
  Heap[this, Message.old1] := oldv#55;
  assume wf(Heap, Mask);
  // update field receiver2
  assert {:msg "  688.3: Location might not be writable"} CanWrite(Mask, this, Message.receiver2);
  Heap[this, Message.receiver2] := receiver#56;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_1046) && ((1000 * foldK#_1046) < Fractions(1)) && ((1000 * foldK#_1046) < methodK#_1034);
  assert {:msg "  689.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1047 := Mask;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The expression at 634.4 might not evaluate to true."} !(Heap[this, Message.sender2] == null);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The expression at 634.38 might not evaluate to true."} !(Heap[Heap[this, Message.sender2], Future.q] == null);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The expression at 634.103 might not evaluate to true."} Heap[this, Message.vr1] == #Message.factorial(Heap, Mask, this, 0);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The expression at 634.143 might not evaluate to true."} !(Heap[this, Message.receiver2] == null);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The expression at 634.162 might not evaluate to true."} Heap[Heap[this, Message.receiver2], FactorialCont.v] == 1;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 633.3 might not be positive."} predicateK > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 633.3 for Message.sender2."} (predicateK <= exhaleMask#_1047[this, Message.sender2][perm$R]) && ((predicateK == exhaleMask#_1047[this, Message.sender2][perm$R]) ==> (0 <= exhaleMask#_1047[this, Message.sender2][perm$N]));
  exhaleMask#_1047[this, Message.sender2] := exhaleMask#_1047[this, Message.sender2][perm$R := exhaleMask#_1047[this, Message.sender2][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 633.18 might not be positive."} predicateK > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 633.18 for Message.receiver2."} (predicateK <= exhaleMask#_1047[this, Message.receiver2][perm$R]) && ((predicateK == exhaleMask#_1047[this, Message.receiver2][perm$R]) ==> (0 <= exhaleMask#_1047[this, Message.receiver2][perm$N]));
  exhaleMask#_1047[this, Message.receiver2] := exhaleMask#_1047[this, Message.receiver2][perm$R := exhaleMask#_1047[this, Message.receiver2][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 633.35 might not be positive."} predicateK > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 633.35 for Message.vr1."} (predicateK <= exhaleMask#_1047[this, Message.vr1][perm$R]) && ((predicateK == exhaleMask#_1047[this, Message.vr1][perm$R]) ==> (0 <= exhaleMask#_1047[this, Message.vr1][perm$N]));
  exhaleMask#_1047[this, Message.vr1] := exhaleMask#_1047[this, Message.vr1][perm$R := exhaleMask#_1047[this, Message.vr1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 633.46 might not be positive."} predicateK > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 633.46 for Message.old1."} (predicateK <= exhaleMask#_1047[this, Message.old1][perm$R]) && ((predicateK == exhaleMask#_1047[this, Message.old1][perm$R]) ==> (0 <= exhaleMask#_1047[this, Message.old1][perm$N]));
  exhaleMask#_1047[this, Message.old1] := exhaleMask#_1047[this, Message.old1][perm$R := exhaleMask#_1047[this, Message.old1][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 634.21 might not be positive."} predicateK > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 634.21 for Future.q."} (predicateK <= exhaleMask#_1047[Heap[this, Message.sender2], Future.q][perm$R]) && ((predicateK == exhaleMask#_1047[Heap[this, Message.sender2], Future.q][perm$R]) ==> (0 <= exhaleMask#_1047[Heap[this, Message.sender2], Future.q][perm$N]));
  exhaleMask#_1047[Heap[this, Message.sender2], Future.q] := exhaleMask#_1047[Heap[this, Message.sender2], Future.q][perm$R := exhaleMask#_1047[Heap[this, Message.sender2], Future.q][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 634.57 might not be positive."} Fractions(100) > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 634.57 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$N]));
  exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid] := exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 634.77 might not be positive."} Fractions(100) > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 634.77 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$N]));
  exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState] := exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1047[Heap[Heap[this, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. The permission at 634.124 might not be positive."} predicateK > 0;
  assert {:msg "  689.3: Fold might fail because the definition of Message.invResult1 does not hold. Insufficient fraction at 634.124 for FactorialCont.v."} (predicateK <= exhaleMask#_1047[Heap[this, Message.receiver2], FactorialCont.v][perm$R]) && ((predicateK == exhaleMask#_1047[Heap[this, Message.receiver2], FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1047[Heap[this, Message.receiver2], FactorialCont.v][perm$N]));
  exhaleMask#_1047[Heap[this, Message.receiver2], FactorialCont.v] := exhaleMask#_1047[Heap[this, Message.receiver2], FactorialCont.v][perm$R := exhaleMask#_1047[Heap[this, Message.receiver2], FactorialCont.v][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1047);
  Mask := exhaleMask#_1047;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_1056;
  assume IsGoodInhaleState(inhaleHeap#_1056, Heap, Mask);
  assume this != null;
  Heap[this, Message.invResult1] := inhaleHeap#_1056[this, Message.invResult1];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1056[this, Message.invResult1] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invResult1] := Mask[this, Message.invResult1][perm$R := Mask[this, Message.invResult1][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1056[this, Message.invResult1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1056, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, Message.invResult1] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_1057 := Mask;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. The expression at 683.58 might not evaluate to true."} Heap[this, Message.type] == 2;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. The expression at 683.91 might not evaluate to true."} Heap[this, Message.receiver2] == receiver#56;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. The permission at 683.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. Insufficient fraction at 683.10 for Message.invResult1."} (Fractions(100) <= exhaleMask#_1057[this, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_1057[this, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_1057[this, Message.invResult1][perm$N]));
  exhaleMask#_1057[this, Message.invResult1] := exhaleMask#_1057[this, Message.invResult1][perm$R := exhaleMask#_1057[this, Message.invResult1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1057);
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. The permission at 683.24 might not be positive."} monitorK > 0;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. Insufficient fraction at 683.24 for Message.type."} (monitorK <= exhaleMask#_1057[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1057[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1057[this, Message.type][perm$N]));
  exhaleMask#_1057[this, Message.type] := exhaleMask#_1057[this, Message.type][perm$R := exhaleMask#_1057[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1057);
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. The permission at 683.41 might not be positive."} monitorK > 0;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. Insufficient fraction at 683.41 for Message.type."} (monitorK <= exhaleMask#_1057[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1057[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1057[this, Message.type][perm$N]));
  exhaleMask#_1057[this, Message.type] := exhaleMask#_1057[this, Message.type][perm$R := exhaleMask#_1057[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1057);
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. The permission at 683.69 might not be positive."} monitorK > 0;
  assert {:msg "  678.2: The postcondition at 683.10 might not hold. Insufficient fraction at 683.69 for Message.receiver2."} (monitorK <= exhaleMask#_1057[this, Message.receiver2][perm$R]) && ((monitorK == exhaleMask#_1057[this, Message.receiver2][perm$R]) ==> (0 <= exhaleMask#_1057[this, Message.receiver2][perm$N]));
  exhaleMask#_1057[this, Message.receiver2] := exhaleMask#_1057[this, Message.receiver2][perm$R := exhaleMask#_1057[this, Message.receiver2][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1057);
  Mask := exhaleMask#_1057;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  678.2: Method might lock/unlock more than allowed."} (forall lk#_1062: ref :: {Heap[lk#_1062, held]} {Heap[lk#_1062, rdheld]} (((0 < Heap[lk#_1062, held]) == (0 < old(Heap)[lk#_1062, held])) && (Heap[lk#_1062, rdheld] == old(Heap)[lk#_1062, rdheld])) || false);
  assert {:msg "  678.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure Message.setResult2$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t), v#57: int where true, oldv#58: ref where (oldv#58 == null) || (dtype(oldv#58) == FactorialCont#t), receiver#59: ref where (receiver#59 == null) || (dtype(receiver#59) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1063: int;
  var inhaleHeap#_1064: HeapType;
  var funcappK#_1071: int;
  var Heap#_1068: HeapType;
  var Mask#_1069: MaskType;
  var Credits#_1070: CreditsType;
  var exhaleMask#_1072: MaskType;
  var inhaleHeap#_1073: HeapType;
  assume (0 < methodK#_1063) && ((1000 * methodK#_1063) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1064;
  assume IsGoodInhaleState(inhaleHeap#_1064, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1064[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume this != null;
  Heap[this, Message.sender3] := inhaleHeap#_1064[this, Message.sender3];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender3] == null) || (dtype(Heap[this, Message.sender3]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender3] := Mask[this, Message.sender3][perm$R := Mask[this, Message.sender3][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[this, Message.sender3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume this != null;
  Heap[this, Message.receiver3] := inhaleHeap#_1064[this, Message.receiver3];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver3] == null) || (dtype(Heap[this, Message.receiver3]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver3] := Mask[this, Message.receiver3][perm$R := Mask[this, Message.receiver3][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[this, Message.receiver3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume this != null;
  Heap[this, Message.vr2] := inhaleHeap#_1064[this, Message.vr2];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vr2] := Mask[this, Message.vr2][perm$R := Mask[this, Message.vr2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[this, Message.vr2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume this != null;
  Heap[this, Message.old2] := inhaleHeap#_1064[this, Message.old2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.old2] == null) || (dtype(Heap[this, Message.old2]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.old2] := Mask[this, Message.old2][perm$R := Mask[this, Message.old2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[this, Message.old2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume !(oldv#58 == null);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.v] := inhaleHeap#_1064[oldv#58, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume methodK#_1063 > 0;
  Mask[oldv#58, FactorialCont.v] := Mask[oldv#58, FactorialCont.v][perm$R := Mask[oldv#58, FactorialCont.v][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[oldv#58, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.cust] := inhaleHeap#_1064[oldv#58, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[oldv#58, FactorialCont.cust] == null) || (dtype(Heap[oldv#58, FactorialCont.cust]) == FactorialCont#t);
  assume methodK#_1063 > 0;
  Mask[oldv#58, FactorialCont.cust] := Mask[oldv#58, FactorialCont.cust][perm$R := Mask[oldv#58, FactorialCont.cust][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[oldv#58, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assert {:msg "  695.6: Receiver might be null."} true ==> (oldv#58 != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, oldv#58, FactorialCont.cust);
  assume Heap[oldv#58, FactorialCont.cust] != null;
  Heap[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo] := inhaleHeap#_1064[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume methodK#_1063 > 0;
  Mask[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo] := Mask[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo][perm$R := Mask[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume receiver#59 != null;
  Heap[receiver#59, FactorialCont.vo] := inhaleHeap#_1064[receiver#59, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume methodK#_1063 > 0;
  Mask[receiver#59, FactorialCont.vo] := Mask[receiver#59, FactorialCont.vo][perm$R := Mask[receiver#59, FactorialCont.vo][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[receiver#59, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assert {:msg "  696.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assume !(Heap[this, Message.sender3] == null);
  assert {:msg "  696.24: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.24: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assume Heap[this, Message.sender3] != null;
  Heap[Heap[this, Message.sender3], Future.q] := inhaleHeap#_1064[Heap[this, Message.sender3], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender3], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender3], Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, Message.sender3], Future.q] := Mask[Heap[this, Message.sender3], Future.q][perm$R := Mask[Heap[this, Message.sender3], Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[Heap[this, Message.sender3], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assert {:msg "  696.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.43: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  696.43: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  696.43: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assume !(Heap[Heap[this, Message.sender3], Future.q] == null);
  assert {:msg "  696.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.62: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  696.62: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  696.62: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assert {:msg "  696.62: Receiver might be null."} Heap[Heap[this, Message.sender3], Future.q] != null;
  assert {:msg "  696.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.62: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  696.62: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  696.62: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assume Heap[Heap[this, Message.sender3], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := inhaleHeap#_1064[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1064[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assert {:msg "  696.82: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.82: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  696.82: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  696.82: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assert {:msg "  696.82: Receiver might be null."} Heap[Heap[this, Message.sender3], Future.q] != null;
  assert {:msg "  696.82: Receiver might be null."} true ==> (this != null);
  assert {:msg "  696.82: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender3);
  assert {:msg "  696.82: Receiver might be null."} true ==> (Heap[this, Message.sender3] != null);
  assert {:msg "  696.82: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender3], Future.q);
  assume Heap[Heap[this, Message.sender3], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := inhaleHeap#_1064[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1064[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.v] := inhaleHeap#_1064[oldv#58, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[oldv#58, FactorialCont.v] := Mask[oldv#58, FactorialCont.v][perm$R := Mask[oldv#58, FactorialCont.v][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[oldv#58, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.vo] := inhaleHeap#_1064[oldv#58, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[oldv#58, FactorialCont.vo] := Mask[oldv#58, FactorialCont.vo][perm$R := Mask[oldv#58, FactorialCont.vo][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[oldv#58, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.cust] := inhaleHeap#_1064[oldv#58, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[oldv#58, FactorialCont.cust] == null) || (dtype(Heap[oldv#58, FactorialCont.cust]) == FactorialCont#t);
  assume monitorK > 0;
  Mask[oldv#58, FactorialCont.cust] := Mask[oldv#58, FactorialCont.cust][perm$R := Mask[oldv#58, FactorialCont.cust][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1064[oldv#58, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1064, Mask);
  assert {:msg "  698.25: Receiver might be null."} true ==> (oldv#58 != null);
  assert {:msg "  698.25: Location might not be readable."} true ==> CanRead(Mask, oldv#58, FactorialCont.v);
  assume Heap[oldv#58, FactorialCont.v] >= 0;
  assert {:msg "  698.38: Receiver might be null."} true ==> (oldv#58 != null);
  assert {:msg "  698.38: Location might not be readable."} true ==> CanRead(Mask, oldv#58, FactorialCont.vo);
  assume Heap[oldv#58, FactorialCont.vo] >= 0;
  assert {:msg "  698.65: Receiver might be null."} true ==> (oldv#58 != null);
  assert {:msg "  698.65: Location might not be readable."} true ==> CanRead(Mask, oldv#58, FactorialCont.v);
  assert {:msg "  698.55: Receiver might be null."} true ==> (this != null);
  // check precondition of call
  assume (0 < funcappK#_1071) && ((1000 * funcappK#_1071) < Fractions(1));
  assume true;
  Heap#_1068 := Heap;
  Mask#_1069 := Mask;
  Credits#_1070 := Credits;
  // begin exhale (function call)
  exhaleMask#_1072 := Mask#_1069;
  assert {:msg "  698.55: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1068[oldv#58, FactorialCont.v] >= 0;
  Mask#_1069 := exhaleMask#_1072;
  assume wf(Heap#_1068, Mask#_1069);
  // end exhale
  assume v#57 == #Message.factorial(Heap, Mask, this, Heap[oldv#58, FactorialCont.v]);
  assert {:msg "  698.76: Receiver might be null."} true ==> (oldv#58 != null);
  assert {:msg "  698.76: Location might not be readable."} true ==> CanRead(Mask, oldv#58, FactorialCont.cust);
  assume Heap[oldv#58, FactorialCont.cust] == receiver#59;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1073;
  assume IsGoodInhaleState(inhaleHeap#_1073, Heap, Mask);
  assert {:msg "  699.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, Message.invResult2] := inhaleHeap#_1073[this, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1073[this, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invResult2] := Mask[this, Message.invResult2][perm$R := Mask[this, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1073[this, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1073, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1073[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1073[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1073, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1073[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1073[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1073, Mask);
  assert {:msg "  699.58: Receiver might be null."} true ==> (this != null);
  assert {:msg "  699.58: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  assume Heap[this, Message.type] == 3;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Message.setResult2(this: ref where (this == null) || (dtype(this) == Message#t), v#57: int where true, oldv#58: ref where (oldv#58 == null) || (dtype(oldv#58) == FactorialCont#t), receiver#59: ref where (receiver#59 == null) || (dtype(receiver#59) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1063: int;
  var inhaleHeap#_1074: HeapType;
  var foldK#_1075: int;
  var exhaleMask#_1076: MaskType;
  var inhaleHeap#_1087: HeapType;
  var exhaleMask#_1088: MaskType;
  assume (0 < methodK#_1063) && ((1000 * methodK#_1063) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1074;
  assume IsGoodInhaleState(inhaleHeap#_1074, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1074[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume this != null;
  Heap[this, Message.sender3] := inhaleHeap#_1074[this, Message.sender3];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender3] == null) || (dtype(Heap[this, Message.sender3]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender3] := Mask[this, Message.sender3][perm$R := Mask[this, Message.sender3][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this, Message.sender3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume this != null;
  Heap[this, Message.receiver3] := inhaleHeap#_1074[this, Message.receiver3];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver3] == null) || (dtype(Heap[this, Message.receiver3]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver3] := Mask[this, Message.receiver3][perm$R := Mask[this, Message.receiver3][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this, Message.receiver3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume this != null;
  Heap[this, Message.vr2] := inhaleHeap#_1074[this, Message.vr2];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vr2] := Mask[this, Message.vr2][perm$R := Mask[this, Message.vr2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this, Message.vr2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume this != null;
  Heap[this, Message.old2] := inhaleHeap#_1074[this, Message.old2];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.old2] == null) || (dtype(Heap[this, Message.old2]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.old2] := Mask[this, Message.old2][perm$R := Mask[this, Message.old2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[this, Message.old2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume !(oldv#58 == null);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.v] := inhaleHeap#_1074[oldv#58, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume methodK#_1063 > 0;
  Mask[oldv#58, FactorialCont.v] := Mask[oldv#58, FactorialCont.v][perm$R := Mask[oldv#58, FactorialCont.v][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[oldv#58, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.cust] := inhaleHeap#_1074[oldv#58, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[oldv#58, FactorialCont.cust] == null) || (dtype(Heap[oldv#58, FactorialCont.cust]) == FactorialCont#t);
  assume methodK#_1063 > 0;
  Mask[oldv#58, FactorialCont.cust] := Mask[oldv#58, FactorialCont.cust][perm$R := Mask[oldv#58, FactorialCont.cust][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[oldv#58, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume Heap[oldv#58, FactorialCont.cust] != null;
  Heap[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo] := inhaleHeap#_1074[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume methodK#_1063 > 0;
  Mask[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo] := Mask[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo][perm$R := Mask[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[Heap[oldv#58, FactorialCont.cust], FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume receiver#59 != null;
  Heap[receiver#59, FactorialCont.vo] := inhaleHeap#_1074[receiver#59, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume methodK#_1063 > 0;
  Mask[receiver#59, FactorialCont.vo] := Mask[receiver#59, FactorialCont.vo][perm$R := Mask[receiver#59, FactorialCont.vo][perm$R] + methodK#_1063];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[receiver#59, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume !(Heap[this, Message.sender3] == null);
  assume Heap[this, Message.sender3] != null;
  Heap[Heap[this, Message.sender3], Future.q] := inhaleHeap#_1074[Heap[this, Message.sender3], Future.q];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, Message.sender3], Future.q] == null) || (dtype(Heap[Heap[this, Message.sender3], Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[Heap[this, Message.sender3], Future.q] := Mask[Heap[this, Message.sender3], Future.q][perm$R := Mask[Heap[this, Message.sender3], Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[Heap[this, Message.sender3], Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume !(Heap[Heap[this, Message.sender3], Future.q] == null);
  assume Heap[Heap[this, Message.sender3], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := inhaleHeap#_1074[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1074[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume Heap[Heap[this, Message.sender3], Future.q] != null;
  Heap[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := inhaleHeap#_1074[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1074[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.v] := inhaleHeap#_1074[oldv#58, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[oldv#58, FactorialCont.v] := Mask[oldv#58, FactorialCont.v][perm$R := Mask[oldv#58, FactorialCont.v][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[oldv#58, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.vo] := inhaleHeap#_1074[oldv#58, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[oldv#58, FactorialCont.vo] := Mask[oldv#58, FactorialCont.vo][perm$R := Mask[oldv#58, FactorialCont.vo][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[oldv#58, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume oldv#58 != null;
  Heap[oldv#58, FactorialCont.cust] := inhaleHeap#_1074[oldv#58, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[oldv#58, FactorialCont.cust] == null) || (dtype(Heap[oldv#58, FactorialCont.cust]) == FactorialCont#t);
  assume monitorK > 0;
  Mask[oldv#58, FactorialCont.cust] := Mask[oldv#58, FactorialCont.cust][perm$R := Mask[oldv#58, FactorialCont.cust][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1074[oldv#58, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1074, Mask);
  assume Heap[oldv#58, FactorialCont.v] >= 0;
  assume Heap[oldv#58, FactorialCont.vo] >= 0;
  assume v#57 == #Message.factorial(Heap, Mask, this, Heap[oldv#58, FactorialCont.v]);
  assume Heap[oldv#58, FactorialCont.cust] == receiver#59;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field type
  assert {:msg "  701.3: Location might not be writable"} CanWrite(Mask, this, Message.type);
  Heap[this, Message.type] := 3;
  assume wf(Heap, Mask);
  // update field vr2
  assert {:msg "  702.3: Location might not be writable"} CanWrite(Mask, this, Message.vr2);
  Heap[this, Message.vr2] := v#57;
  assume wf(Heap, Mask);
  // update field old2
  assert {:msg "  703.3: Location might not be writable"} CanWrite(Mask, this, Message.old2);
  Heap[this, Message.old2] := oldv#58;
  assume wf(Heap, Mask);
  // update field receiver3
  assert {:msg "  704.3: Location might not be writable"} CanWrite(Mask, this, Message.receiver3);
  Heap[this, Message.receiver3] := receiver#59;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_1075) && ((1000 * foldK#_1075) < Fractions(1)) && ((1000 * foldK#_1075) < methodK#_1063);
  assert {:msg "  705.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1076 := Mask;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The expression at 639.4 might not evaluate to true."} !(Heap[this, Message.sender3] == null);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The expression at 639.38 might not evaluate to true."} !(Heap[Heap[this, Message.sender3], Future.q] == null);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The expression at 641.3 might not evaluate to true."} Heap[Heap[this, Message.old2], FactorialCont.v] >= 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The expression at 641.16 might not evaluate to true."} Heap[Heap[this, Message.old2], FactorialCont.vo] >= 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The expression at 641.31 might not evaluate to true."} Heap[this, Message.vr2] == #Message.factorial(Heap, Mask, this, Heap[Heap[this, Message.old2], FactorialCont.v]);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The expression at 641.57 might not evaluate to true."} Heap[Heap[this, Message.old2], FactorialCont.cust] == Heap[this, Message.receiver3];
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 638.3 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 638.3 for Message.sender3."} (predicateK <= exhaleMask#_1076[this, Message.sender3][perm$R]) && ((predicateK == exhaleMask#_1076[this, Message.sender3][perm$R]) ==> (0 <= exhaleMask#_1076[this, Message.sender3][perm$N]));
  exhaleMask#_1076[this, Message.sender3] := exhaleMask#_1076[this, Message.sender3][perm$R := exhaleMask#_1076[this, Message.sender3][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 638.18 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 638.18 for Message.receiver3."} (predicateK <= exhaleMask#_1076[this, Message.receiver3][perm$R]) && ((predicateK == exhaleMask#_1076[this, Message.receiver3][perm$R]) ==> (0 <= exhaleMask#_1076[this, Message.receiver3][perm$N]));
  exhaleMask#_1076[this, Message.receiver3] := exhaleMask#_1076[this, Message.receiver3][perm$R := exhaleMask#_1076[this, Message.receiver3][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 638.35 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 638.35 for Message.vr2."} (predicateK <= exhaleMask#_1076[this, Message.vr2][perm$R]) && ((predicateK == exhaleMask#_1076[this, Message.vr2][perm$R]) ==> (0 <= exhaleMask#_1076[this, Message.vr2][perm$N]));
  exhaleMask#_1076[this, Message.vr2] := exhaleMask#_1076[this, Message.vr2][perm$R := exhaleMask#_1076[this, Message.vr2][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 638.46 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 638.46 for Message.old2."} (predicateK <= exhaleMask#_1076[this, Message.old2][perm$R]) && ((predicateK == exhaleMask#_1076[this, Message.old2][perm$R]) ==> (0 <= exhaleMask#_1076[this, Message.old2][perm$N]));
  exhaleMask#_1076[this, Message.old2] := exhaleMask#_1076[this, Message.old2][perm$R := exhaleMask#_1076[this, Message.old2][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 639.21 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 639.21 for Future.q."} (predicateK <= exhaleMask#_1076[Heap[this, Message.sender3], Future.q][perm$R]) && ((predicateK == exhaleMask#_1076[Heap[this, Message.sender3], Future.q][perm$R]) ==> (0 <= exhaleMask#_1076[Heap[this, Message.sender3], Future.q][perm$N]));
  exhaleMask#_1076[Heap[this, Message.sender3], Future.q] := exhaleMask#_1076[Heap[this, Message.sender3], Future.q][perm$R := exhaleMask#_1076[Heap[this, Message.sender3], Future.q][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 639.57 might not be positive."} Fractions(100) > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 639.57 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$N]));
  exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid] := exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 639.77 might not be positive."} Fractions(100) > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 639.77 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$N]));
  exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState] := exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1076[Heap[Heap[this, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 640.3 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 640.3 for FactorialCont.v."} (predicateK <= exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.v][perm$R]) && ((predicateK == exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.v][perm$N]));
  exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.v] := exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.v][perm$R := exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.v][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 640.16 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 640.16 for FactorialCont.vo."} (predicateK <= exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.vo][perm$R]) && ((predicateK == exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.vo][perm$N]));
  exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.vo] := exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.vo][perm$R := exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.vo][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. The permission at 640.30 might not be positive."} predicateK > 0;
  assert {:msg "  705.3: Fold might fail because the definition of Message.invResult2 does not hold. Insufficient fraction at 640.30 for FactorialCont.cust."} (predicateK <= exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.cust][perm$R]) && ((predicateK == exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.cust][perm$N]));
  exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.cust] := exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.cust][perm$R := exhaleMask#_1076[Heap[this, Message.old2], FactorialCont.cust][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1076);
  Mask := exhaleMask#_1076;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_1087;
  assume IsGoodInhaleState(inhaleHeap#_1087, Heap, Mask);
  assume this != null;
  Heap[this, Message.invResult2] := inhaleHeap#_1087[this, Message.invResult2];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1087[this, Message.invResult2] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invResult2] := Mask[this, Message.invResult2][perm$R := Mask[this, Message.invResult2][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1087[this, Message.invResult2]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1087, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, Message.invResult2] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_1088 := Mask;
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. The expression at 699.58 might not evaluate to true."} Heap[this, Message.type] == 3;
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. The permission at 699.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. Insufficient fraction at 699.10 for Message.invResult2."} (Fractions(100) <= exhaleMask#_1088[this, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_1088[this, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_1088[this, Message.invResult2][perm$N]));
  exhaleMask#_1088[this, Message.invResult2] := exhaleMask#_1088[this, Message.invResult2][perm$R := exhaleMask#_1088[this, Message.invResult2][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. The permission at 699.24 might not be positive."} monitorK > 0;
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. Insufficient fraction at 699.24 for Message.type."} (monitorK <= exhaleMask#_1088[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1088[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1088[this, Message.type][perm$N]));
  exhaleMask#_1088[this, Message.type] := exhaleMask#_1088[this, Message.type][perm$R := exhaleMask#_1088[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. The permission at 699.41 might not be positive."} monitorK > 0;
  assert {:msg "  692.2: The postcondition at 699.10 might not hold. Insufficient fraction at 699.41 for Message.type."} (monitorK <= exhaleMask#_1088[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1088[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1088[this, Message.type][perm$N]));
  exhaleMask#_1088[this, Message.type] := exhaleMask#_1088[this, Message.type][perm$R := exhaleMask#_1088[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1088);
  Mask := exhaleMask#_1088;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  692.2: Method might lock/unlock more than allowed."} (forall lk#_1092: ref :: {Heap[lk#_1092, held]} {Heap[lk#_1092, rdheld]} (((0 < Heap[lk#_1092, held]) == (0 < old(Heap)[lk#_1092, held])) && (Heap[lk#_1092, rdheld] == old(Heap)[lk#_1092, rdheld])) || false);
  assert {:msg "  692.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure Message.setFinalResult$checkDefinedness(this: ref where (this == null) || (dtype(this) == Message#t), vr#60: int where true, receiver#61: ref where (receiver#61 == null) || (dtype(receiver#61) == Future#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1093: int;
  var inhaleHeap#_1094: HeapType;
  var inhaleHeap#_1095: HeapType;
  assume (0 < methodK#_1093) && ((1000 * methodK#_1093) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1094;
  assume IsGoodInhaleState(inhaleHeap#_1094, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1094[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1094[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1094, Mask);
  assume this != null;
  Heap[this, Message.sender4] := inhaleHeap#_1094[this, Message.sender4];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender4] == null) || (dtype(Heap[this, Message.sender4]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender4] := Mask[this, Message.sender4][perm$R := Mask[this, Message.sender4][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1094[this, Message.sender4]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1094, Mask);
  assume this != null;
  Heap[this, Message.receiver4] := inhaleHeap#_1094[this, Message.receiver4];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver4] == null) || (dtype(Heap[this, Message.receiver4]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver4] := Mask[this, Message.receiver4][perm$R := Mask[this, Message.receiver4][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1094[this, Message.receiver4]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1094, Mask);
  assume this != null;
  Heap[this, Message.vr3] := inhaleHeap#_1094[this, Message.vr3];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vr3] := Mask[this, Message.vr3][perm$R := Mask[this, Message.vr3][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1094[this, Message.vr3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1094, Mask);
  assert {:msg "  710.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  710.4: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender4);
  if (!(Heap[this, Message.sender4] == null)) {
    assert {:msg "  710.26: Receiver might be null."} true ==> (this != null);
    assert {:msg "  710.26: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender4);
    assume Heap[this, Message.sender4] != null;
    Heap[Heap[this, Message.sender4], FactorialCont.q] := inhaleHeap#_1094[Heap[this, Message.sender4], FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, Message.sender4], FactorialCont.q] == null) || (dtype(Heap[Heap[this, Message.sender4], FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[Heap[this, Message.sender4], FactorialCont.q] := Mask[Heap[this, Message.sender4], FactorialCont.q][perm$R := Mask[Heap[this, Message.sender4], FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1094[Heap[this, Message.sender4], FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1094, Mask);
    assert {:msg "  710.45: Receiver might be null."} true ==> (this != null);
    assert {:msg "  710.45: Location might not be readable."} true ==> CanRead(Mask, this, Message.sender4);
    assert {:msg "  710.45: Receiver might be null."} true ==> (Heap[this, Message.sender4] != null);
    assert {:msg "  710.45: Location might not be readable."} true ==> CanRead(Mask, Heap[this, Message.sender4], FactorialCont.q);
    assume !(Heap[Heap[this, Message.sender4], FactorialCont.q] == null);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1095;
  assume IsGoodInhaleState(inhaleHeap#_1095, Heap, Mask);
  assert {:msg "  711.10: Receiver might be null."} this != null;
  assume this != null;
  Heap[this, Message.invFinalResult] := inhaleHeap#_1095[this, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1095[this, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invFinalResult] := Mask[this, Message.invFinalResult][perm$R := Mask[this, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1095[this, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1095, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1095[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1095[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1095, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1095[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1095[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1095, Mask);
  assert {:msg "  711.62: Receiver might be null."} true ==> (this != null);
  assert {:msg "  711.62: Location might not be readable."} true ==> CanRead(Mask, this, Message.type);
  assume Heap[this, Message.type] == 4;
  assume this != null;
  Heap[this, Message.vr3] := inhaleHeap#_1095[this, Message.vr3];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, Message.vr3] := Mask[this, Message.vr3][perm$R := Mask[this, Message.vr3][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1095[this, Message.vr3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1095, Mask);
  assert {:msg "  711.89: Receiver might be null."} true ==> (this != null);
  assert {:msg "  711.89: Location might not be readable."} true ==> CanRead(Mask, this, Message.vr3);
  assume Heap[this, Message.vr3] == vr#60;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure Message.setFinalResult(this: ref where (this == null) || (dtype(this) == Message#t), vr#60: int where true, receiver#61: ref where (receiver#61 == null) || (dtype(receiver#61) == Future#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1093: int;
  var inhaleHeap#_1096: HeapType;
  var foldK#_1097: int;
  var exhaleMask#_1098: MaskType;
  var inhaleHeap#_1102: HeapType;
  var exhaleMask#_1103: MaskType;
  assume (0 < methodK#_1093) && ((1000 * methodK#_1093) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1096;
  assume IsGoodInhaleState(inhaleHeap#_1096, Heap, Mask);
  assume this != null;
  Heap[this, Message.type] := inhaleHeap#_1096[this, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.type] := Mask[this, Message.type][perm$R := Mask[this, Message.type][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1096[this, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1096, Mask);
  assume this != null;
  Heap[this, Message.sender4] := inhaleHeap#_1096[this, Message.sender4];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.sender4] == null) || (dtype(Heap[this, Message.sender4]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, Message.sender4] := Mask[this, Message.sender4][perm$R := Mask[this, Message.sender4][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1096[this, Message.sender4]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1096, Mask);
  assume this != null;
  Heap[this, Message.receiver4] := inhaleHeap#_1096[this, Message.receiver4];
  assume wf(Heap, Mask);
  assume (Heap[this, Message.receiver4] == null) || (dtype(Heap[this, Message.receiver4]) == Future#t);
  assume Fractions(100) > 0;
  Mask[this, Message.receiver4] := Mask[this, Message.receiver4][perm$R := Mask[this, Message.receiver4][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1096[this, Message.receiver4]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1096, Mask);
  assume this != null;
  Heap[this, Message.vr3] := inhaleHeap#_1096[this, Message.vr3];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, Message.vr3] := Mask[this, Message.vr3][perm$R := Mask[this, Message.vr3][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1096[this, Message.vr3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1096, Mask);
  if (!(Heap[this, Message.sender4] == null)) {
    assume Heap[this, Message.sender4] != null;
    Heap[Heap[this, Message.sender4], FactorialCont.q] := inhaleHeap#_1096[Heap[this, Message.sender4], FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, Message.sender4], FactorialCont.q] == null) || (dtype(Heap[Heap[this, Message.sender4], FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[Heap[this, Message.sender4], FactorialCont.q] := Mask[Heap[this, Message.sender4], FactorialCont.q][perm$R := Mask[Heap[this, Message.sender4], FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1096[Heap[this, Message.sender4], FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1096, Mask);
    assume !(Heap[Heap[this, Message.sender4], FactorialCont.q] == null);
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field type
  assert {:msg "  713.3: Location might not be writable"} CanWrite(Mask, this, Message.type);
  Heap[this, Message.type] := 4;
  assume wf(Heap, Mask);
  // update field vr3
  assert {:msg "  714.3: Location might not be writable"} CanWrite(Mask, this, Message.vr3);
  Heap[this, Message.vr3] := vr#60;
  assume wf(Heap, Mask);
  // update field receiver4
  assert {:msg "  715.3: Location might not be writable"} CanWrite(Mask, this, Message.receiver4);
  Heap[this, Message.receiver4] := receiver#61;
  assume wf(Heap, Mask);
  // fold
  assume (0 < foldK#_1097) && ((1000 * foldK#_1097) < Fractions(1)) && ((1000 * foldK#_1097) < methodK#_1093);
  assert {:msg "  716.3: The target of the fold statement might be null."} this != null;
  // begin exhale (fold)
  exhaleMask#_1098 := Mask;
  assert {:msg "  716.3: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.3 might not be positive."} predicateK > 0;
  assert {:msg "  716.3: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.3 for Message.sender4."} (predicateK <= exhaleMask#_1098[this, Message.sender4][perm$R]) && ((predicateK == exhaleMask#_1098[this, Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1098[this, Message.sender4][perm$N]));
  exhaleMask#_1098[this, Message.sender4] := exhaleMask#_1098[this, Message.sender4][perm$R := exhaleMask#_1098[this, Message.sender4][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1098);
  assert {:msg "  716.3: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.18 might not be positive."} predicateK > 0;
  assert {:msg "  716.3: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.18 for Message.receiver4."} (predicateK <= exhaleMask#_1098[this, Message.receiver4][perm$R]) && ((predicateK == exhaleMask#_1098[this, Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1098[this, Message.receiver4][perm$N]));
  exhaleMask#_1098[this, Message.receiver4] := exhaleMask#_1098[this, Message.receiver4][perm$R := exhaleMask#_1098[this, Message.receiver4][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1098);
  assert {:msg "  716.3: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.35 might not be positive."} predicateK > 0;
  assert {:msg "  716.3: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.35 for Message.vr3."} (predicateK <= exhaleMask#_1098[this, Message.vr3][perm$R]) && ((predicateK == exhaleMask#_1098[this, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1098[this, Message.vr3][perm$N]));
  exhaleMask#_1098[this, Message.vr3] := exhaleMask#_1098[this, Message.vr3][perm$R := exhaleMask#_1098[this, Message.vr3][perm$R] - predicateK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1098);
  Mask := exhaleMask#_1098;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_1102;
  assume IsGoodInhaleState(inhaleHeap#_1102, Heap, Mask);
  assume this != null;
  Heap[this, Message.invFinalResult] := inhaleHeap#_1102[this, Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1102[this, Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[this, Message.invFinalResult] := Mask[this, Message.invFinalResult][perm$R := Mask[this, Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1102[this, Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1102, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[this, Message.invFinalResult] := Heap;
  assume wf(Heap, Mask);
  // begin exhale (postcondition)
  exhaleMask#_1103 := Mask;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. The expression at 711.62 might not evaluate to true."} Heap[this, Message.type] == 4;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. The expression at 711.89 might not evaluate to true."} Heap[this, Message.vr3] == vr#60;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. The permission at 711.10 might not be positive."} Fractions(100) > 0;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. Insufficient fraction at 711.10 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1103[this, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1103[this, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1103[this, Message.invFinalResult][perm$N]));
  exhaleMask#_1103[this, Message.invFinalResult] := exhaleMask#_1103[this, Message.invFinalResult][perm$R := exhaleMask#_1103[this, Message.invFinalResult][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. The permission at 711.28 might not be positive."} monitorK > 0;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. Insufficient fraction at 711.28 for Message.type."} (monitorK <= exhaleMask#_1103[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1103[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1103[this, Message.type][perm$N]));
  exhaleMask#_1103[this, Message.type] := exhaleMask#_1103[this, Message.type][perm$R := exhaleMask#_1103[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. The permission at 711.45 might not be positive."} monitorK > 0;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. Insufficient fraction at 711.45 for Message.type."} (monitorK <= exhaleMask#_1103[this, Message.type][perm$R]) && ((monitorK == exhaleMask#_1103[this, Message.type][perm$R]) ==> (0 <= exhaleMask#_1103[this, Message.type][perm$N]));
  exhaleMask#_1103[this, Message.type] := exhaleMask#_1103[this, Message.type][perm$R := exhaleMask#_1103[this, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. The permission at 711.73 might not be positive."} monitorK > 0;
  assert {:msg "  708.2: The postcondition at 711.10 might not hold. Insufficient fraction at 711.73 for Message.vr3."} (monitorK <= exhaleMask#_1103[this, Message.vr3][perm$R]) && ((monitorK == exhaleMask#_1103[this, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1103[this, Message.vr3][perm$N]));
  exhaleMask#_1103[this, Message.vr3] := exhaleMask#_1103[this, Message.vr3][perm$R := exhaleMask#_1103[this, Message.vr3][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1103);
  Mask := exhaleMask#_1103;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  708.2: Method might lock/unlock more than allowed."} (forall lk#_1108: ref :: {Heap[lk#_1108, held]} {Heap[lk#_1108, rdheld]} (((0 < Heap[lk#_1108, held]) == (0 < old(Heap)[lk#_1108, held])) && (Heap[lk#_1108, rdheld] == old(Heap)[lk#_1108, rdheld])) || false);
  assert {:msg "  708.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActor#t: TypeName;
procedure FactorialActor$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1116: int;
  var h0#_1109: HeapType;
  var m0#_1110: MaskType;
  var c0#_1111: CreditsType;
  var h1#_1112: HeapType;
  var m1#_1113: MaskType;
  var c1#_1114: CreditsType;
  var lk#_1115: ref;
  assume (0 < methodK#_1116) && ((1000 * methodK#_1116) < Fractions(1));
  assume wf(h0#_1109, m0#_1110);
  assume wf(h1#_1112, m1#_1113);
  m1#_1113 := ZeroMask;
  c1#_1114 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  721.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialActor.q: Field (ref);
axiom NonPredicateField(FactorialActor.q);
procedure FactorialActor.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1117: int;
  var inhaleHeap#_1118: HeapType;
  var inhaleHeap#_1119: HeapType;
  assume (0 < methodK#_1117) && ((1000 * methodK#_1117) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1118;
  assume IsGoodInhaleState(inhaleHeap#_1118, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActor.q] := inhaleHeap#_1118[this, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1118[this, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1118, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1119;
  assume IsGoodInhaleState(inhaleHeap#_1119, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActor.q] := inhaleHeap#_1119[this, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
  assume Fractions(50) > 0;
  Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[this, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  726.23: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.23: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume !(Heap[this, FactorialActor.q] == null);
  assert {:msg "  726.34: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.34: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  726.34: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  726.34: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.34: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  726.45: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.45: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  726.45: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  726.45: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.45: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  726.56: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.56: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  726.56: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  726.56: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.56: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  726.74: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.74: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  726.74: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  726.74: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.74: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  726.95: Receiver might be null."} true ==> (this != null);
  assert {:msg "  726.95: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  727.2: Receiver might be null."} true ==> (this != null);
  assert {:msg "  727.2: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  727.2: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  727.2: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
  assert {:msg "  727.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  727.20: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[this, FactorialActor.q], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  727.38: Receiver might be null."} true ==> (this != null);
  assert {:msg "  727.38: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  727.38: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1119[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  727.59: Receiver might be null."} true ==> (this != null);
  assert {:msg "  727.59: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  727.59: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  727.59: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assert {:msg "  727.59: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
  assert {:msg "  727.59: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  727.83: Receiver might be null."} true ==> (this != null);
  assert {:msg "  727.83: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  727.83: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_1119[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1119[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1119, Mask);
  assert {:msg "  727.104: Receiver might be null."} true ==> (this != null);
  assert {:msg "  727.104: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  727.104: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  727.104: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
  assert {:msg "  727.104: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null);
  assert {:msg "  727.104: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch);
  assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialActor.init(this: ref where (this == null) || (dtype(this) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1117: int;
  var inhaleHeap#_1120: HeapType;
  var nw#_1121: ref;
  var exp#63: ref where (exp#63 == null) || (dtype(exp#63) == FactorialActorChannelExpEP#t);
  var nw#_1122: ref;
  var imp#65: ref where (imp#65 == null) || (dtype(imp#65) == FactorialActorChannelImpEP#t);
  var nw#_1123: ref;
  var methodCallK#_1127: int;
  var this#124: ref where (this#124 == null) || (dtype(this#124) == FactorialActorChannel#t);
  var i#125: ref where (i#125 == null) || (dtype(i#125) == FactorialActorChannelImpEP#t);
  var e#126: ref where (e#126 == null) || (dtype(e#126) == FactorialActorChannelExpEP#t);
  var callHeap#_1124: HeapType;
  var callMask#_1125: MaskType;
  var callCredits#_1126: CreditsType;
  var exhaleMask#_1128: MaskType;
  var isHeld#_1137: int;
  var isRdHeld#_1138: bool;
  var inhaleHeap#_1139: HeapType;
  var exhaleMask#_1140: MaskType;
  assume (0 < methodK#_1117) && ((1000 * methodK#_1117) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1120;
  assume IsGoodInhaleState(inhaleHeap#_1120, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActor.q] := inhaleHeap#_1120[this, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1120[this, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1120, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field q
  assert {:msg "  729.3: Location might not be writable"} CanWrite(Mask, this, FactorialActor.q);
  // new
  havoc nw#_1121;
  assume (nw#_1121 != null) && (dtype(nw#_1121) == FactorialActorChannel#t);
  assume (forall<T#_9> f: Field (T#_9) :: (Mask[nw#_1121, f][perm$R] == 0) && (Mask[nw#_1121, f][perm$N] == 0));
  assume Heap[nw#_1121, mu] == $LockBottom;
  assume Heap[nw#_1121, held] <= 0;
  assume Heap[nw#_1121, rdheld] == false;
  Mask[nw#_1121, FactorialActorChannel.imp] := Mask[nw#_1121, FactorialActorChannel.imp][perm$R := Mask[nw#_1121, FactorialActorChannel.imp][perm$R] + Fractions(100)];
  Mask[nw#_1121, FactorialActorChannel.exp] := Mask[nw#_1121, FactorialActorChannel.exp][perm$R := Mask[nw#_1121, FactorialActorChannel.exp][perm$R] + Fractions(100)];
  Mask[nw#_1121, mu] := Mask[nw#_1121, mu][perm$R := Mask[nw#_1121, mu][perm$R] + Fractions(100)];
  Heap[this, FactorialActor.q] := nw#_1121;
  assume wf(Heap, Mask);
  // local var exp
  // assigment to exp
  // new
  havoc nw#_1122;
  assume (nw#_1122 != null) && (dtype(nw#_1122) == FactorialActorChannelExpEP#t);
  assume (forall<T#_10> f: Field (T#_10) :: (Mask[nw#_1122, f][perm$R] == 0) && (Mask[nw#_1122, f][perm$N] == 0));
  assume Heap[nw#_1122, mu] == $LockBottom;
  assume Heap[nw#_1122, held] <= 0;
  assume Heap[nw#_1122, rdheld] == false;
  Mask[nw#_1122, FactorialActorChannelExpEP.state] := Mask[nw#_1122, FactorialActorChannelExpEP.state][perm$R := Mask[nw#_1122, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  Mask[nw#_1122, FactorialActorChannelExpEP.ch] := Mask[nw#_1122, FactorialActorChannelExpEP.ch][perm$R := Mask[nw#_1122, FactorialActorChannelExpEP.ch][perm$R] + Fractions(100)];
  Mask[nw#_1122, FactorialActorChannelExpEP.expch] := Mask[nw#_1122, FactorialActorChannelExpEP.expch][perm$R := Mask[nw#_1122, FactorialActorChannelExpEP.expch][perm$R] + Fractions(100)];
  Mask[nw#_1122, mu] := Mask[nw#_1122, mu][perm$R := Mask[nw#_1122, mu][perm$R] + Fractions(100)];
  exp#63 := nw#_1122;
  // local var imp
  // assigment to imp
  // new
  havoc nw#_1123;
  assume (nw#_1123 != null) && (dtype(nw#_1123) == FactorialActorChannelImpEP#t);
  assume (forall<T#_11> f: Field (T#_11) :: (Mask[nw#_1123, f][perm$R] == 0) && (Mask[nw#_1123, f][perm$N] == 0));
  assume Heap[nw#_1123, mu] == $LockBottom;
  assume Heap[nw#_1123, held] <= 0;
  assume Heap[nw#_1123, rdheld] == false;
  Mask[nw#_1123, FactorialActorChannelImpEP.state] := Mask[nw#_1123, FactorialActorChannelImpEP.state][perm$R := Mask[nw#_1123, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  Mask[nw#_1123, FactorialActorChannelImpEP.ch] := Mask[nw#_1123, FactorialActorChannelImpEP.ch][perm$R := Mask[nw#_1123, FactorialActorChannelImpEP.ch][perm$R] + Fractions(100)];
  Mask[nw#_1123, FactorialActorChannelImpEP.impch] := Mask[nw#_1123, FactorialActorChannelImpEP.impch][perm$R := Mask[nw#_1123, FactorialActorChannelImpEP.impch][perm$R] + Fractions(100)];
  Mask[nw#_1123, mu] := Mask[nw#_1123, mu][perm$R := Mask[nw#_1123, mu][perm$R] + Fractions(100)];
  imp#65 := nw#_1123;
  assume (0 < methodCallK#_1127) && ((1000 * methodCallK#_1127) < Fractions(1)) && ((1000 * methodCallK#_1127) < methodK#_1117);
  // call init
  callHeap#_1124 := Heap;
  callMask#_1125 := Mask;
  callCredits#_1126 := Credits;
  assert {:msg "  732.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  732.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  732.3: The target of the method call might be null."} Heap[this, FactorialActor.q] != null;
  this#124 := Heap[this, FactorialActor.q];
  i#125 := imp#65;
  e#126 := exp#63;
  // begin exhale (precondition)
  exhaleMask#_1128 := Mask;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.11 for FactorialActorChannel.imp."} (Fractions(100) <= exhaleMask#_1128[this#124, FactorialActorChannel.imp][perm$R]) && ((Fractions(100) == exhaleMask#_1128[this#124, FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1128[this#124, FactorialActorChannel.imp][perm$N]));
  exhaleMask#_1128[this#124, FactorialActorChannel.imp] := exhaleMask#_1128[this#124, FactorialActorChannel.imp][perm$R := exhaleMask#_1128[this#124, FactorialActorChannel.imp][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.23 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.23 for FactorialActorChannelImpEP.ch."} (Fractions(100) <= exhaleMask#_1128[i#125, FactorialActorChannelImpEP.ch][perm$R]) && ((Fractions(100) == exhaleMask#_1128[i#125, FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1128[i#125, FactorialActorChannelImpEP.ch][perm$N]));
  exhaleMask#_1128[i#125, FactorialActorChannelImpEP.ch] := exhaleMask#_1128[i#125, FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1128[i#125, FactorialActorChannelImpEP.ch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.36 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.36 for FactorialActorChannel.exp."} (Fractions(100) <= exhaleMask#_1128[this#124, FactorialActorChannel.exp][perm$R]) && ((Fractions(100) == exhaleMask#_1128[this#124, FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1128[this#124, FactorialActorChannel.exp][perm$N]));
  exhaleMask#_1128[this#124, FactorialActorChannel.exp] := exhaleMask#_1128[this#124, FactorialActorChannel.exp][perm$R := exhaleMask#_1128[this#124, FactorialActorChannel.exp][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.48 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.48 for FactorialActorChannelExpEP.ch."} (Fractions(100) <= exhaleMask#_1128[e#126, FactorialActorChannelExpEP.ch][perm$R]) && ((Fractions(100) == exhaleMask#_1128[e#126, FactorialActorChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1128[e#126, FactorialActorChannelExpEP.ch][perm$N]));
  exhaleMask#_1128[e#126, FactorialActorChannelExpEP.ch] := exhaleMask#_1128[e#126, FactorialActorChannelExpEP.ch][perm$R := exhaleMask#_1128[e#126, FactorialActorChannelExpEP.ch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.61 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.61 for FactorialActorChannelImpEP.impch."} (Fractions(100) <= exhaleMask#_1128[i#125, FactorialActorChannelImpEP.impch][perm$R]) && ((Fractions(100) == exhaleMask#_1128[i#125, FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1128[i#125, FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_1128[i#125, FactorialActorChannelImpEP.impch] := exhaleMask#_1128[i#125, FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1128[i#125, FactorialActorChannelImpEP.impch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.77 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.77 for FactorialActorChannelExpEP.expch."} (Fractions(100) <= exhaleMask#_1128[e#126, FactorialActorChannelExpEP.expch][perm$R]) && ((Fractions(100) == exhaleMask#_1128[e#126, FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_1128[e#126, FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_1128[e#126, FactorialActorChannelExpEP.expch] := exhaleMask#_1128[e#126, FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_1128[e#126, FactorialActorChannelExpEP.expch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.93 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.93 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1128[i#125, FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1128[i#125, FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1128[i#125, FactorialActorChannelImpEP.state][perm$N]));
  exhaleMask#_1128[i#125, FactorialActorChannelImpEP.state] := exhaleMask#_1128[i#125, FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1128[i#125, FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  assert {:msg "  732.3: The precondition at 143.11 might not hold. The permission at 143.109 might not be positive."} Fractions(100) > 0;
  assert {:msg "  732.3: The precondition at 143.11 might not hold. Insufficient fraction at 143.109 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1128[e#126, FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1128[e#126, FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1128[e#126, FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_1128[e#126, FactorialActorChannelExpEP.state] := exhaleMask#_1128[e#126, FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1128[e#126, FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1128);
  Mask := exhaleMask#_1128;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1139;
  assume IsGoodInhaleState(inhaleHeap#_1139, Heap, Mask);
  assume this#124 != null;
  Heap[this#124, FactorialActorChannel.valid] := inhaleHeap#_1139[this#124, FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1139[this#124, FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#124, FactorialActorChannel.valid] := Mask[this#124, FactorialActorChannel.valid][perm$R := Mask[this#124, FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[this#124, FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume this#124 != null;
  Heap[this#124, FactorialActorChannel.valid] := inhaleHeap#_1139[this#124, FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1139[this#124, FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#124, FactorialActorChannel.valid] := Mask[this#124, FactorialActorChannel.valid][perm$R := Mask[this#124, FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[this#124, FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume this#124 != null;
  Heap[this#124, FactorialActorChannel.imp] := inhaleHeap#_1139[this#124, FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this#124, FactorialActorChannel.imp] == null) || (dtype(Heap[this#124, FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[this#124, FactorialActorChannel.imp] := Mask[this#124, FactorialActorChannel.imp][perm$R := Mask[this#124, FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[this#124, FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume !(Heap[this#124, FactorialActorChannel.imp] == null);
  assume this#124 != null;
  Heap[this#124, FactorialActorChannel.exp] := inhaleHeap#_1139[this#124, FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this#124, FactorialActorChannel.exp] == null) || (dtype(Heap[this#124, FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[this#124, FactorialActorChannel.exp] := Mask[this#124, FactorialActorChannel.exp][perm$R := Mask[this#124, FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[this#124, FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume !(Heap[this#124, FactorialActorChannel.exp] == null);
  assume Heap[this#124, FactorialActorChannel.imp] != null;
  Heap[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1139[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume !(Heap[Heap[this#124, FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assume Heap[this#124, FactorialActorChannel.exp] != null;
  Heap[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_1139[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume !(Heap[Heap[this#124, FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assume this#124 != null;
  Heap[this#124, FactorialActorChannel.initImpState] := inhaleHeap#_1139[this#124, FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1139[this#124, FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this#124, FactorialActorChannel.initImpState] := Mask[this#124, FactorialActorChannel.initImpState][perm$R := Mask[this#124, FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[this#124, FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume this#124 != null;
  Heap[this#124, FactorialActorChannel.initExpState] := inhaleHeap#_1139[this#124, FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1139[this#124, FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this#124, FactorialActorChannel.initExpState] := Mask[this#124, FactorialActorChannel.initExpState][perm$R := Mask[this#124, FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1139[this#124, FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1139, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1140 := Mask;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The expression at 726.23 might not evaluate to true."} !(Heap[this, FactorialActor.q] == null);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The expression at 727.2 might not evaluate to true."} !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The expression at 727.59 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The expression at 727.104 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 726.10 might not be positive."} Fractions(50) > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 726.10 for FactorialActor.q."} (Fractions(50) <= exhaleMask#_1140[this, FactorialActor.q][perm$R]) && ((Fractions(50) == exhaleMask#_1140[this, FactorialActor.q][perm$R]) ==> (0 <= exhaleMask#_1140[this, FactorialActor.q][perm$N]));
  exhaleMask#_1140[this, FactorialActor.q] := exhaleMask#_1140[this, FactorialActor.q][perm$R := exhaleMask#_1140[this, FactorialActor.q][perm$R] - Fractions(50)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 726.34 might not be positive."} Fractions(100) > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 726.34 for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$N]));
  exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 726.45 might not be positive."} Fractions(100) > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 726.45 for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$N]));
  exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 726.56 might not be positive."} Fractions(100) > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 726.56 for FactorialActorChannel.initImpState."} (Fractions(100) <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$N]));
  exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 726.74 might not be positive."} Fractions(100) > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 726.74 for FactorialActorChannel.initExpState."} (Fractions(100) <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$N]));
  exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 726.92 might not be positive."} monitorK > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 726.92 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 727.17 might not be positive."} monitorK > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 727.17 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := exhaleMask#_1140[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 727.35 might not be positive."} monitorK > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 727.35 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. The permission at 727.80 might not be positive."} monitorK > 0;
  assert {:msg "  724.2: The postcondition at 726.10 might not hold. Insufficient fraction at 727.80 for FactorialActorChannelExpEP.expch."} (monitorK <= exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$N]));
  exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := exhaleMask#_1140[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1140);
  Mask := exhaleMask#_1140;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  724.2: Method might lock/unlock more than allowed."} (forall lk#_1150: ref :: {Heap[lk#_1150, held]} {Heap[lk#_1150, rdheld]} (((0 < Heap[lk#_1150, held]) == (0 < old(Heap)[lk#_1150, held])) && (Heap[lk#_1150, rdheld] == old(Heap)[lk#_1150, rdheld])) || false);
  assert {:msg "  724.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialActor.act$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1151: int;
  var inhaleHeap#_1152: HeapType;
  assume (0 < methodK#_1151) && ((1000 * methodK#_1151) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1152;
  assume IsGoodInhaleState(inhaleHeap#_1152, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActor.q] := inhaleHeap#_1152[this, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1152[this, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1152, Mask);
  assert {:msg "  735.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.25: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume !(Heap[this, FactorialActor.q] == null);
  assert {:msg "  735.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.36: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  735.36: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  735.36: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.36: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1152, Mask);
  assert {:msg "  735.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.47: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  735.47: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  735.47: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.47: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1152, Mask);
  assert {:msg "  735.65: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.65: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  735.65: Receiver might be null."} Heap[this, FactorialActor.q] != null;
  assert {:msg "  735.65: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.65: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1152, Mask);
  assert {:msg "  735.86: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.86: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1152[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1152, Mask);
  assert {:msg "  735.101: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.101: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  735.101: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  735.101: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
  assert {:msg "  735.119: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.119: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  735.119: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1152[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1152[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1152, Mask);
  assert {:msg "  735.140: Receiver might be null."} true ==> (this != null);
  assert {:msg "  735.140: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  735.140: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  735.140: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assert {:msg "  735.140: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
  assert {:msg "  735.140: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  736.19: Receiver might be null."} true ==> (this != null);
  assert {:msg "  736.19: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  736.19: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  736.19: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assert {:msg "  736.19: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
  assert {:msg "  736.19: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
  assert {:msg "  736.19: The target of the credit predicate might be null."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
  Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] + 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FactorialActor.act(this: ref where (this == null) || (dtype(this) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1151: int;
  var inhaleHeap#_1153: HeapType;
  var unfoldK#_1154: int;
  var exhaleMask#_1155: MaskType;
  var inhaleHeap#_1157: HeapType;
  var unfoldK#_1158: int;
  var exhaleMask#_1159: MaskType;
  var inhaleHeap#_1161: HeapType;
  var unfoldK#_1162: int;
  var exhaleMask#_1163: MaskType;
  var inhaleHeap#_1165: HeapType;
  var unfoldK#_1166: int;
  var exhaleMask#_1167: MaskType;
  var inhaleHeap#_1169: HeapType;
  var whileK#_1176: int;
  var whileHeap#_1170: HeapType;
  var whileMask#_1171: MaskType;
  var whileCredits#_1172: CreditsType;
  var exhaleMask#_1177: MaskType;
  var inhaleHeap#_1188: HeapType;
  var inhaleHeap#_1189: HeapType;
  var iterStartHeap#_1173: HeapType;
  var iterStartMask#_1174: MaskType;
  var iterStartCredits#_1175: CreditsType;
  var current#67: ref where (current#67 == null) || (dtype(current#67) == Message#t);
  var this#127: ref where (this#127 == null) || (dtype(this#127) == Channel#t);
  var msg#128: ref where (msg#128 == null) || (dtype(msg#128) == Message#t);
  var inhaleHeap#_1192: HeapType;
  var methodCallK#_1196: int;
  var this#129: ref where (this#129 == null) || (dtype(this#129) == FactorialActorChannelImpEP#t);
  var mi#130: ref where (mi#130 == null) || (dtype(mi#130) == Message#t);
  var mo#131: ref where (mo#131 == null) || (dtype(mo#131) == Message#t);
  var callHeap#_1193: HeapType;
  var callMask#_1194: MaskType;
  var callCredits#_1195: CreditsType;
  var exhaleMask#_1197: MaskType;
  var isHeld#_1201: int;
  var isRdHeld#_1202: bool;
  var inhaleHeap#_1203: HeapType;
  var unfoldK#_1204: int;
  var exhaleMask#_1205: MaskType;
  var inhaleHeap#_1207: HeapType;
  var m#69: ref where (m#69 == null) || (dtype(m#69) == Message#t);
  var nw#_1208: ref;
  var methodCallK#_1212: int;
  var this#132: ref where (this#132 == null) || (dtype(this#132) == Message#t);
  var vr#133: int where true;
  var receiver#134: ref where (receiver#134 == null) || (dtype(receiver#134) == Future#t);
  var callHeap#_1209: HeapType;
  var callMask#_1210: MaskType;
  var callCredits#_1211: CreditsType;
  var exhaleMask#_1213: MaskType;
  var isHeld#_1219: int;
  var isRdHeld#_1220: bool;
  var inhaleHeap#_1221: HeapType;
  var Heap#_1225: HeapType;
  var Mask#_1226: MaskType;
  var Credits#_1227: CreditsType;
  var exhaleMask#_1228: MaskType;
  var funcappK#_1235: int;
  var Heap#_1232: HeapType;
  var Mask#_1233: MaskType;
  var Credits#_1234: CreditsType;
  var exhaleMask#_1236: MaskType;
  var unfoldK#_1237: int;
  var exhaleMask#_1238: MaskType;
  var inhaleHeap#_1240: HeapType;
  var unfoldK#_1241: int;
  var exhaleMask#_1242: MaskType;
  var inhaleHeap#_1244: HeapType;
  var methodCallK#_1248: int;
  var this#135: ref where (this#135 == null) || (dtype(this#135) == FutureChannelExpEP#t);
  var m#136: ref where (m#136 == null) || (dtype(m#136) == Message#t);
  var callHeap#_1245: HeapType;
  var callMask#_1246: MaskType;
  var callCredits#_1247: CreditsType;
  var exhaleMask#_1249: MaskType;
  var isHeld#_1255: int;
  var isRdHeld#_1256: bool;
  var inhaleHeap#_1257: HeapType;
  var m#71: ref where (m#71 == null) || (dtype(m#71) == Message#t);
  var nw#_1258: ref;
  var methodCallK#_1262: int;
  var this#137: ref where (this#137 == null) || (dtype(this#137) == Message#t);
  var v#138: int where true;
  var oldv#139: ref where (oldv#139 == null) || (dtype(oldv#139) == FactorialActor#t);
  var receiver#140: ref where (receiver#140 == null) || (dtype(receiver#140) == FactorialCont#t);
  var callHeap#_1259: HeapType;
  var callMask#_1260: MaskType;
  var callCredits#_1261: CreditsType;
  var exhaleMask#_1263: MaskType;
  var isHeld#_1273: int;
  var isRdHeld#_1274: bool;
  var inhaleHeap#_1275: HeapType;
  var unfoldK#_1276: int;
  var exhaleMask#_1277: MaskType;
  var inhaleHeap#_1279: HeapType;
  var unfoldK#_1280: int;
  var exhaleMask#_1281: MaskType;
  var inhaleHeap#_1283: HeapType;
  var methodCallK#_1287: int;
  var this#141: ref where (this#141 == null) || (dtype(this#141) == FactorialContChannelExpEP#t);
  var m#142: ref where (m#142 == null) || (dtype(m#142) == Message#t);
  var callHeap#_1284: HeapType;
  var callMask#_1285: MaskType;
  var callCredits#_1286: CreditsType;
  var exhaleMask#_1288: MaskType;
  var isHeld#_1294: int;
  var isRdHeld#_1295: bool;
  var inhaleHeap#_1296: HeapType;
  var r#73: ref where (r#73 == null) || (dtype(r#73) == Message#t);
  var nw#_1297: ref;
  var Heap#_1301: HeapType;
  var Mask#_1302: MaskType;
  var Credits#_1303: CreditsType;
  var exhaleMask#_1304: MaskType;
  var funcappK#_1311: int;
  var Heap#_1308: HeapType;
  var Mask#_1309: MaskType;
  var Credits#_1310: CreditsType;
  var exhaleMask#_1312: MaskType;
  var funcappK#_1319: int;
  var Heap#_1316: HeapType;
  var Mask#_1317: MaskType;
  var Credits#_1318: CreditsType;
  var exhaleMask#_1320: MaskType;
  var cont#75: ref where (cont#75 == null) || (dtype(cont#75) == FactorialCont#t);
  var nw#_1321: ref;
  var methodCallK#_1325: int;
  var this#143: ref where (this#143 == null) || (dtype(this#143) == FactorialCont#t);
  var vp#144: int where true;
  var vop#145: int where true;
  var custp#146: ref where (custp#146 == null) || (dtype(custp#146) == FactorialCont#t);
  var callHeap#_1322: HeapType;
  var callMask#_1323: MaskType;
  var callCredits#_1324: CreditsType;
  var exhaleMask#_1326: MaskType;
  var isHeld#_1335: int;
  var isRdHeld#_1336: bool;
  var inhaleHeap#_1337: HeapType;
  var asyncMethodCallK#_1344: int;
  var preCallHeap#_1340: HeapType;
  var preCallMask#_1341: MaskType;
  var preCallCredits#_1342: CreditsType;
  var argsSeq#_1343: ArgSeq;
  var this#147: ref where (this#147 == null) || (dtype(this#147) == FactorialCont#t);
  var exhaleMask#_1345: MaskType;
  var token#_1338: ref;
  var asyncstate#_1339: int;
  var m#77: ref where (m#77 == null) || (dtype(m#77) == Message#t);
  var nw#_1358: ref;
  var methodCallK#_1362: int;
  var this#148: ref where (this#148 == null) || (dtype(this#148) == Message#t);
  var v#149: int where true;
  var vo#150: int where true;
  var cust#151: ref where (cust#151 == null) || (dtype(cust#151) == FactorialCont#t);
  var receiver#152: ref where (receiver#152 == null) || (dtype(receiver#152) == FactorialActor#t);
  var callHeap#_1359: HeapType;
  var callMask#_1360: MaskType;
  var callCredits#_1361: CreditsType;
  var exhaleMask#_1363: MaskType;
  var isHeld#_1380: int;
  var isRdHeld#_1381: bool;
  var inhaleHeap#_1382: HeapType;
  var methodCallK#_1386: int;
  var this#153: ref where (this#153 == null) || (dtype(this#153) == FactorialActorChannelExpEP#t);
  var m#154: ref where (m#154 == null) || (dtype(m#154) == Message#t);
  var callHeap#_1383: HeapType;
  var callMask#_1384: MaskType;
  var callCredits#_1385: CreditsType;
  var exhaleMask#_1387: MaskType;
  var isHeld#_1393: int;
  var isRdHeld#_1394: bool;
  var inhaleHeap#_1395: HeapType;
  var r#79: ref where (r#79 == null) || (dtype(r#79) == Message#t);
  var nw#_1396: ref;
  var Heap#_1400: HeapType;
  var Mask#_1401: MaskType;
  var Credits#_1402: CreditsType;
  var exhaleMask#_1403: MaskType;
  var funcappK#_1410: int;
  var Heap#_1407: HeapType;
  var Mask#_1408: MaskType;
  var Credits#_1409: CreditsType;
  var exhaleMask#_1411: MaskType;
  var funcappK#_1418: int;
  var Heap#_1415: HeapType;
  var Mask#_1416: MaskType;
  var Credits#_1417: CreditsType;
  var exhaleMask#_1419: MaskType;
  var exhaleMask#_1420: MaskType;
  var isHeld#_1431: int;
  var isRdHeld#_1432: bool;
  var inhaleHeap#_1434: HeapType;
  assume (0 < methodK#_1151) && ((1000 * methodK#_1151) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1153;
  assume IsGoodInhaleState(inhaleHeap#_1153, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActor.q] := inhaleHeap#_1153[this, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1153[this, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1153, Mask);
  assume !(Heap[this, FactorialActor.q] == null);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1153, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1153, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1153, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1153[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1153, Mask);
  assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1153[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1153[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1153, Mask);
  assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] + 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_1154) && (unfoldK#_1154 < Fractions(1)) && ((1000 * unfoldK#_1154) < methodK#_1151);
  assert {:msg "  738.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  738.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  738.3: The target of the fold statement might be null."} Heap[this, FactorialActor.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1155 := Mask;
  assert {:msg "  738.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  738.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_1155[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1155[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1155[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$N]));
  exhaleMask#_1155[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := exhaleMask#_1155[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := exhaleMask#_1155[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1155);
  Mask := exhaleMask#_1155;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1157 := Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid];
  assume IsGoodInhaleState(inhaleHeap#_1157, Heap, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1157[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1157[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1157, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1157[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1157[Heap[this, FactorialActor.q], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1157, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1157, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1157, Mask);
  assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
  assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1157, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1157[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1157, Mask);
  assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == Heap[this, FactorialActor.q];
  assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == Heap[this, FactorialActor.q];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1158) && (unfoldK#_1158 < Fractions(1)) && ((1000 * unfoldK#_1158) < methodK#_1151);
  assert {:msg "  739.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  739.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  739.10: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
  assert {:msg "  739.10: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
  assert {:msg "  739.3: The target of the fold statement might be null."} Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  // begin exhale (unfold)
  exhaleMask#_1159 := Mask;
  assert {:msg "  739.3: unfold might fail because the predicate FactorialActorChannelImpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  739.3: unfold might fail because the predicate FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_1159[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1159[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1159[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$N]));
  exhaleMask#_1159[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := exhaleMask#_1159[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := exhaleMask#_1159[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1159);
  Mask := exhaleMask#_1159;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1161 := Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid];
  assume IsGoodInhaleState(inhaleHeap#_1161, Heap, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1161[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_1161[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null);
  assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] := inhaleHeap#_1161[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume !(Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] == null);
  assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] != null;
  Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] := inhaleHeap#_1161[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume !(Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] == null);
  assume Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1161[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume !(Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assume Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_1161[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume !(Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assume Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_1161[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := inhaleHeap#_1161[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1161[Heap[Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1161, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1162) && (unfoldK#_1162 < Fractions(1)) && ((1000 * unfoldK#_1162) < methodK#_1151);
  assert {:msg "  740.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  740.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  740.3: The target of the fold statement might be null."} Heap[this, FactorialActor.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1163 := Mask;
  assert {:msg "  740.3: unfold might fail because the predicate FactorialActorChannel.initImpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  740.3: unfold might fail because the predicate FactorialActorChannel.initImpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initImpState."} (Fractions(100) <= exhaleMask#_1163[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1163[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1163[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$N]));
  exhaleMask#_1163[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState] := exhaleMask#_1163[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := exhaleMask#_1163[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1163);
  Mask := exhaleMask#_1163;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1165 := Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initImpState];
  assume IsGoodInhaleState(inhaleHeap#_1165, Heap, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1165[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1165[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1165, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := inhaleHeap#_1165[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1165[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1165, Mask);
  assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1166) && (unfoldK#_1166 < Fractions(1)) && ((1000 * unfoldK#_1166) < methodK#_1151);
  assert {:msg "  741.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  741.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assert {:msg "  741.3: The target of the fold statement might be null."} Heap[this, FactorialActor.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1167 := Mask;
  assert {:msg "  741.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  741.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initExpState."} (Fractions(100) <= exhaleMask#_1167[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1167[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1167[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$N]));
  exhaleMask#_1167[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState] := exhaleMask#_1167[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := exhaleMask#_1167[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1167);
  Mask := exhaleMask#_1167;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1169 := Heap[Heap[this, FactorialActor.q], FactorialActorChannel.initExpState];
  assume IsGoodInhaleState(inhaleHeap#_1169, Heap, Mask);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1169[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1169[Heap[this, FactorialActor.q], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1169, Mask);
  assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := inhaleHeap#_1169[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1169[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1169, Mask);
  assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // while
  assume (0 < whileK#_1176) && ((1000 * whileK#_1176) < Fractions(1)) && ((1000 * whileK#_1176) < methodK#_1151);
  whileHeap#_1170 := Heap;
  whileMask#_1171 := Mask;
  whileCredits#_1172 := Credits;
  // begin exhale (loop invariant, initially)
  exhaleMask#_1177 := Mask;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. The expression at 743.27 might not evaluate to true."} !(Heap[this, FactorialActor.q] == null);
  assert {:msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.13 might not evaluate to true."} Heap[this, FactorialActor.q] == Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
  assert {:msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.28 might not evaluate to true."} !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
  assert {:msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.43 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assert {:msg "  745.13: The loop invariant might not hold on entry to the loop. The expression at 745.31 might not evaluate to true."} !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null);
  assert {:msg "  746.13: The loop invariant might not hold on entry to the loop. The expression at 746.33 might not evaluate to true."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
  assert {:msg "  747.13: The loop invariant might not hold on entry to the loop. The expression at 747.33 might not evaluate to true."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
  Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] - 1;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.13 might not be positive."} monitorK > 0;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.13 for FactorialActor.q."} (monitorK <= exhaleMask#_1177[this, FactorialActor.q][perm$R]) && ((monitorK == exhaleMask#_1177[this, FactorialActor.q][perm$R]) ==> (0 <= exhaleMask#_1177[this, FactorialActor.q][perm$N]));
  exhaleMask#_1177[this, FactorialActor.q] := exhaleMask#_1177[this, FactorialActor.q][perm$R := exhaleMask#_1177[this, FactorialActor.q][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.38 might not be positive."} monitorK > 0;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.38 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.56 might not be positive."} monitorK > 0;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.56 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.80 might not be positive."} monitorK > 0;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.80 for mu."} (monitorK <= exhaleMask#_1177[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_1177[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
  exhaleMask#_1177[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_1177[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_1177[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.107 might not be positive."} monitorK > 0;
  assert {:msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.107 for FactorialActorChannelImpEP.ch."} (monitorK <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$N]));
  exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  745.13: The loop invariant might not hold on entry to the loop. The permission at 745.13 might not be positive."} monitorK > 0;
  assert {:msg "  745.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 745.13 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := exhaleMask#_1177[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  745.13: The loop invariant might not hold on entry to the loop. The permission at 745.46 might not be positive."} Fractions(100) > 0;
  assert {:msg "  745.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 745.46 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  746.13: The loop invariant might not hold on entry to the loop. The permission at 746.13 might not be positive."} Fractions(100) > 0;
  assert {:msg "  746.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 746.13 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  assert {:msg "  747.13: The loop invariant might not hold on entry to the loop. The permission at 747.13 might not be positive."} Fractions(100) > 0;
  assert {:msg "  747.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 747.13 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$N]));
  exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1177[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1177);
  Mask := exhaleMask#_1177;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  742.3: Loop invariant must consume all debt on entry to the loop."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
  // check lockchange on entry to the loop
  assert {:msg "  742.3: Method execution before loop might lock/unlock more than allowed by lockchange clause of loop."} (forall lk#_1187: ref :: {Heap[lk#_1187, held]} {Heap[lk#_1187, rdheld]} (((0 < Heap[lk#_1187, held]) == (0 < old(Heap)[lk#_1187, held])) && (Heap[lk#_1187, rdheld] == old(Heap)[lk#_1187, rdheld])) || false);
  if (*) {
    // check loop invariant definedness
    havoc Heap;
    Mask := ZeroMask;
    Credits := ZeroCredits;
    // inhale (loop invariant definedness)
    havoc inhaleHeap#_1188;
    assume IsGoodInhaleState(inhaleHeap#_1188, Heap, Mask);
    assume this != null;
    Heap[this, FactorialActor.q] := inhaleHeap#_1188[this, FactorialActor.q];
    assume wf(Heap, Mask);
    assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
    assume monitorK > 0;
    Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[this, FactorialActor.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  743.27: Receiver might be null."} true ==> (this != null);
    assert {:msg "  743.27: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assume !(Heap[this, FactorialActor.q] == null);
    assert {:msg "  743.41: Receiver might be null."} true ==> (this != null);
    assert {:msg "  743.41: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assume Heap[this, FactorialActor.q] != null;
    Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1188[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
    assume monitorK > 0;
    Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  743.59: Receiver might be null."} true ==> (this != null);
    assert {:msg "  743.59: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  743.59: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
    Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  743.83: Receiver might be null."} true ==> (this != null);
    assert {:msg "  743.83: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  743.83: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
    assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
    Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_1188[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  743.110: Receiver might be null."} true ==> (this != null);
    assert {:msg "  743.110: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  743.110: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
    Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
    assume wf(Heap, Mask);
    assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
    assume monitorK > 0;
    Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  744.13: Receiver might be null."} true ==> (this != null);
    assert {:msg "  744.13: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  744.16: Receiver might be null."} true ==> (this != null);
    assert {:msg "  744.16: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  744.16: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  744.16: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assert {:msg "  744.16: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
    assert {:msg "  744.16: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch);
    assume Heap[this, FactorialActor.q] == Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
    assert {:msg "  744.28: Receiver might be null."} true ==> (this != null);
    assert {:msg "  744.28: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  744.28: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  744.28: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
    assert {:msg "  744.43: Receiver might be null."} true ==> (this != null);
    assert {:msg "  744.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  744.43: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  744.43: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assert {:msg "  744.43: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
    assert {:msg "  744.43: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
    assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
    assert {:msg "  745.16: Receiver might be null."} true ==> (this != null);
    assert {:msg "  745.16: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assume Heap[this, FactorialActor.q] != null;
    Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1188[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
    assume monitorK > 0;
    Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[this, FactorialActor.q], FactorialActorChannel.exp]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  745.31: Receiver might be null."} true ==> (this != null);
    assert {:msg "  745.31: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  745.31: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  745.31: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
    assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null);
    assert {:msg "  745.46: Receiver might be null."} true ==> (this != null);
    assert {:msg "  745.46: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  745.46: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  745.46: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
    assert {:msg "  745.46: Receiver might be null."} Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
    assert {:msg "  745.46: Receiver might be null."} true ==> (this != null);
    assert {:msg "  745.46: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  745.46: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  745.46: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
    assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
    Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  746.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  746.17: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  746.17: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
    assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
    Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state];
    assume wf(Heap, Mask);
    assume true;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  746.33: Receiver might be null."} true ==> (this != null);
    assert {:msg "  746.33: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  746.33: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  746.33: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
    assert {:msg "  746.33: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null);
    assert {:msg "  746.33: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state);
    assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
    assert {:msg "  747.17: Receiver might be null."} true ==> (this != null);
    assert {:msg "  747.17: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  747.17: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
    Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state];
    assume wf(Heap, Mask);
    assume true;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1188[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1188, Mask);
    assert {:msg "  747.33: Receiver might be null."} true ==> (this != null);
    assert {:msg "  747.33: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  747.33: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  747.33: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assert {:msg "  747.33: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
    assert {:msg "  747.33: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state);
    assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
    assert {:msg "  748.20: Receiver might be null."} true ==> (this != null);
    assert {:msg "  748.20: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
    assert {:msg "  748.20: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
    assert {:msg "  748.20: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
    assert {:msg "  748.20: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
    assert {:msg "  748.20: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
    assert {:msg "  748.20: The target of the credit predicate might be null."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
    Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] + 1;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    assume false;
  } else {
    if (*) {
      havoc Heap;
      Mask := ZeroMask;
      Credits := ZeroCredits;
      // inhale (loop invariant, body)
      havoc inhaleHeap#_1189;
      assume IsGoodInhaleState(inhaleHeap#_1189, Heap, Mask);
      assume this != null;
      Heap[this, FactorialActor.q] := inhaleHeap#_1189[this, FactorialActor.q];
      assume wf(Heap, Mask);
      assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
      assume monitorK > 0;
      Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[this, FactorialActor.q]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume !(Heap[this, FactorialActor.q] == null);
      assume Heap[this, FactorialActor.q] != null;
      Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1189[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
      assume wf(Heap, Mask);
      assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
      assume monitorK > 0;
      Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
      assume wf(Heap, Mask);
      assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
      assume monitorK > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
      Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_1189[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
      assume wf(Heap, Mask);
      assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
      assume monitorK > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[this, FactorialActor.q] == Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
      assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
      assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
      assume Heap[this, FactorialActor.q] != null;
      Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1189[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
      assume wf(Heap, Mask);
      assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
      assume monitorK > 0;
      Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[this, FactorialActor.q], FactorialActorChannel.exp]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1189[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1189, Mask);
      assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
      Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] + 1;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // assume lockchange at the beginning of the loop iteration
      assume (forall lk#_1190: ref :: {Heap[lk#_1190, held]} {Heap[lk#_1190, rdheld]} (((0 < Heap[lk#_1190, held]) == (0 < old(Heap)[lk#_1190, held])) && (Heap[lk#_1190, rdheld] == old(Heap)[lk#_1190, rdheld])) || false);
      iterStartHeap#_1173 := Heap;
      iterStartMask#_1174 := Mask;
      iterStartCredits#_1175 := Credits;
      assume true;
      // local var current
      // assigment to current
      current#67 := null;
      // receive
      assert {:msg "  751.21: Receiver might be null."} true ==> (this != null);
      assert {:msg "  751.21: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
      assert {:msg "  751.21: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
      assert {:msg "  751.21: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
      assert {:msg "  751.21: Receiver might be null."} true ==> (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null);
      assert {:msg "  751.21: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch);
      assert {:msg "  751.21: The channel might be null."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
      assert {:msg "  751.4: receive operation requires a credit"} 0 < Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]];
      assert {:msg "  751.4: The mu field of the channel in the receive statement might not be readable."} CanRead(Mask, Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu);
      assert {:msg "  751.4: The channel must lie above waitlevel in the wait order"} (forall o#_1191: ref :: (((0 < Heap[o#_1191, held]) || Heap[o#_1191, rdheld]) || (Credits[o#_1191] < 0)) ==> MuBelow(Heap[o#_1191, mu], Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]));
      this#127 := Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
      havoc msg#128;
      // inhale (channel where clause)
      havoc inhaleHeap#_1192;
      assume IsGoodInhaleState(inhaleHeap#_1192, Heap, Mask);
      assume !(msg#128 == null);
      assume msg#128 != null;
      Heap[msg#128, Message.type] := inhaleHeap#_1192[msg#128, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume channelK > 0;
      Mask[msg#128, Message.type] := Mask[msg#128, Message.type][perm$R := Mask[msg#128, Message.type][perm$R] + channelK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1192[msg#128, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1192, Mask);
      assume msg#128 != null;
      Heap[msg#128, Message.inv] := inhaleHeap#_1192[msg#128, Message.inv];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1192[msg#128, Message.inv] == Heap;
      assume Fractions(100) > 0;
      Mask[msg#128, Message.inv] := Mask[msg#128, Message.inv][perm$R := Mask[msg#128, Message.inv][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1192[msg#128, Message.inv]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1192, Mask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      current#67 := msg#128;
      Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] - 1;
      // if
      assert {:msg "  752.7: Receiver might be null."} true ==> (current#67 != null);
      assert {:msg "  752.7: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.type);
      if (Heap[current#67, Message.type] == 1) {
        assume (0 < methodCallK#_1196) && ((1000 * methodCallK#_1196) < Fractions(1)) && ((1000 * methodCallK#_1196) < whileK#_1176);
        // call receiveValue
        callHeap#_1193 := Heap;
        callMask#_1194 := Mask;
        callCredits#_1195 := Credits;
        assert {:msg "  753.19: Receiver might be null."} true ==> (this != null);
        assert {:msg "  753.19: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
        assert {:msg "  753.19: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
        assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.imp);
        assert {:msg "  753.5: The target of the method call might be null."} Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
        this#129 := Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
        mi#130 := current#67;
        // begin exhale (precondition)
        exhaleMask#_1197 := Mask;
        assert {:msg "  753.5: The precondition at 95.11 might not hold. The expression at 95.25 might not evaluate to true."} !(mi#130 == null);
        assert {:msg "  753.5: The precondition at 95.11 might not hold. The expression at 95.57 might not evaluate to true."} Heap[mi#130, Message.type] == 1;
        assert {:msg "  753.5: The precondition at 96.11 might not hold. The expression at 96.11 might not evaluate to true."} Heap[this#129, FactorialActorChannelImpEP.state] == 0;
        assert {:msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.11 might not be positive."} Fractions(100) > 0;
        assert {:msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.11 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1197[this#129, FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1197[this#129, FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1197[this#129, FactorialActorChannelImpEP.state][perm$N]));
        exhaleMask#_1197[this#129, FactorialActorChannelImpEP.state] := exhaleMask#_1197[this#129, FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1197[this#129, FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1197);
        assert {:msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.37 might not be positive."} monitorK > 0;
        assert {:msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.37 for Message.type."} (monitorK <= exhaleMask#_1197[mi#130, Message.type][perm$R]) && ((monitorK == exhaleMask#_1197[mi#130, Message.type][perm$R]) ==> (0 <= exhaleMask#_1197[mi#130, Message.type][perm$N]));
        exhaleMask#_1197[mi#130, Message.type] := exhaleMask#_1197[mi#130, Message.type][perm$R := exhaleMask#_1197[mi#130, Message.type][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1197);
        assert {:msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.71 might not be positive."} Fractions(100) > 0;
        assert {:msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.71 for Message.inv."} (Fractions(100) <= exhaleMask#_1197[mi#130, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_1197[mi#130, Message.inv][perm$R]) ==> (0 <= exhaleMask#_1197[mi#130, Message.inv][perm$N]));
        exhaleMask#_1197[mi#130, Message.inv] := exhaleMask#_1197[mi#130, Message.inv][perm$R := exhaleMask#_1197[mi#130, Message.inv][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1197);
        Mask := exhaleMask#_1197;
        assume wf(Heap, Mask);
        // end exhale
        havoc mo#131;
        // inhale (postcondition)
        havoc inhaleHeap#_1203;
        assume IsGoodInhaleState(inhaleHeap#_1203, Heap, Mask);
        assume this#129 != null;
        Heap[this#129, FactorialActorChannelImpEP.state] := inhaleHeap#_1203[this#129, FactorialActorChannelImpEP.state];
        assume wf(Heap, Mask);
        assume true;
        assume Fractions(100) > 0;
        Mask[this#129, FactorialActorChannelImpEP.state] := Mask[this#129, FactorialActorChannelImpEP.state][perm$R := Mask[this#129, FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1203[this#129, FactorialActorChannelImpEP.state]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1203, Mask);
        assume Heap[this#129, FactorialActorChannelImpEP.state] == 0;
        assume mo#131 != null;
        Heap[mo#131, Message.type] := inhaleHeap#_1203[mo#131, Message.type];
        assume wf(Heap, Mask);
        assume true;
        assume monitorK > 0;
        Mask[mo#131, Message.type] := Mask[mo#131, Message.type][perm$R := Mask[mo#131, Message.type][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1203[mo#131, Message.type]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1203, Mask);
        assume Heap[mo#131, Message.type] == 1;
        assume mi#130 == mo#131;
        assume mo#131 != null;
        Heap[mo#131, Message.invValue] := inhaleHeap#_1203[mo#131, Message.invValue];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1203[mo#131, Message.invValue] == Heap;
        assume Fractions(100) > 0;
        Mask[mo#131, Message.invValue] := Mask[mo#131, Message.invValue][perm$R := Mask[mo#131, Message.invValue][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1203[mo#131, Message.invValue]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1203, Mask);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        current#67 := mo#131;
        // unfold
        assume (0 < unfoldK#_1204) && (unfoldK#_1204 < Fractions(1)) && ((1000 * unfoldK#_1204) < whileK#_1176);
        assert {:msg "  754.5: The target of the fold statement might be null."} current#67 != null;
        // begin exhale (unfold)
        exhaleMask#_1205 := Mask;
        assert {:msg "  754.5: unfold might fail because the predicate Message.invValue does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
        assert {:msg "  754.5: unfold might fail because the predicate Message.invValue does not hold. Insufficient fraction at <undefined position> for Message.invValue."} (Fractions(100) <= exhaleMask#_1205[current#67, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_1205[current#67, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_1205[current#67, Message.invValue][perm$N]));
        exhaleMask#_1205[current#67, Message.invValue] := exhaleMask#_1205[current#67, Message.invValue][perm$R := exhaleMask#_1205[current#67, Message.invValue][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1205);
        Mask := exhaleMask#_1205;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (unfold)
        inhaleHeap#_1207 := Heap[current#67, Message.invValue];
        assume IsGoodInhaleState(inhaleHeap#_1207, Heap, Mask);
        assume current#67 != null;
        Heap[current#67, Message.sender1] := inhaleHeap#_1207[current#67, Message.sender1];
        assume wf(Heap, Mask);
        assume (Heap[current#67, Message.sender1] == null) || (dtype(Heap[current#67, Message.sender1]) == Future#t);
        assume predicateK > 0;
        Mask[current#67, Message.sender1] := Mask[current#67, Message.sender1][perm$R := Mask[current#67, Message.sender1][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[current#67, Message.sender1]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume current#67 != null;
        Heap[current#67, Message.receiver1] := inhaleHeap#_1207[current#67, Message.receiver1];
        assume wf(Heap, Mask);
        assume (Heap[current#67, Message.receiver1] == null) || (dtype(Heap[current#67, Message.receiver1]) == FactorialActor#t);
        assume predicateK > 0;
        Mask[current#67, Message.receiver1] := Mask[current#67, Message.receiver1][perm$R := Mask[current#67, Message.receiver1][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[current#67, Message.receiver1]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume current#67 != null;
        Heap[current#67, Message.cust1] := inhaleHeap#_1207[current#67, Message.cust1];
        assume wf(Heap, Mask);
        assume (Heap[current#67, Message.cust1] == null) || (dtype(Heap[current#67, Message.cust1]) == FactorialCont#t);
        assume predicateK > 0;
        Mask[current#67, Message.cust1] := Mask[current#67, Message.cust1][perm$R := Mask[current#67, Message.cust1][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[current#67, Message.cust1]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume current#67 != null;
        Heap[current#67, Message.v1] := inhaleHeap#_1207[current#67, Message.v1];
        assume wf(Heap, Mask);
        assume true;
        assume predicateK > 0;
        Mask[current#67, Message.v1] := Mask[current#67, Message.v1][perm$R := Mask[current#67, Message.v1][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[current#67, Message.v1]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume current#67 != null;
        Heap[current#67, Message.vo1] := inhaleHeap#_1207[current#67, Message.vo1];
        assume wf(Heap, Mask);
        assume true;
        assume predicateK > 0;
        Mask[current#67, Message.vo1] := Mask[current#67, Message.vo1][perm$R := Mask[current#67, Message.vo1][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[current#67, Message.vo1]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume !(Heap[current#67, Message.sender1] == null);
        assume Heap[current#67, Message.sender1] != null;
        Heap[Heap[current#67, Message.sender1], Future.q] := inhaleHeap#_1207[Heap[current#67, Message.sender1], Future.q];
        assume wf(Heap, Mask);
        assume (Heap[Heap[current#67, Message.sender1], Future.q] == null) || (dtype(Heap[Heap[current#67, Message.sender1], Future.q]) == FutureChannel#t);
        assume predicateK > 0;
        Mask[Heap[current#67, Message.sender1], Future.q] := Mask[Heap[current#67, Message.sender1], Future.q][perm$R := Mask[Heap[current#67, Message.sender1], Future.q][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[Heap[current#67, Message.sender1], Future.q]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume !(Heap[Heap[current#67, Message.sender1], Future.q] == null);
        assume Heap[Heap[current#67, Message.sender1], Future.q] != null;
        Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid] := inhaleHeap#_1207[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1207[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid] == Heap;
        assume Fractions(100) > 0;
        Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid] := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume Heap[Heap[current#67, Message.sender1], Future.q] != null;
        Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState] := inhaleHeap#_1207[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1207[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState] == Heap;
        assume Fractions(100) > 0;
        Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1207[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1207, Mask);
        assume Heap[current#67, Message.v1] >= 0;
        assume Heap[current#67, Message.vo1] >= 0;
        if (Heap[current#67, Message.cust1] == null) {
          assume Heap[current#67, Message.v1] == Heap[current#67, Message.vo1];
        } else {
        }
        if (!(Heap[current#67, Message.cust1] == null)) {
          assume Heap[current#67, Message.cust1] != null;
          Heap[Heap[current#67, Message.cust1], FactorialCont.q] := inhaleHeap#_1207[Heap[current#67, Message.cust1], FactorialCont.q];
          assume wf(Heap, Mask);
          assume (Heap[Heap[current#67, Message.cust1], FactorialCont.q] == null) || (dtype(Heap[Heap[current#67, Message.cust1], FactorialCont.q]) == FactorialContChannel#t);
          assume predicateK > 0;
          Mask[Heap[current#67, Message.cust1], FactorialCont.q] := Mask[Heap[current#67, Message.cust1], FactorialCont.q][perm$R := Mask[Heap[current#67, Message.cust1], FactorialCont.q][perm$R] + predicateK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[current#67, Message.cust1], FactorialCont.q]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume !(Heap[Heap[current#67, Message.cust1], FactorialCont.q] == null);
          assume Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
          Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid] == Heap;
          assume Fractions(100) > 0;
          Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
          Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] == Heap;
          assume Fractions(100) > 0;
          Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
          Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp];
          assume wf(Heap, Mask);
          assume (Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
          assume predicateK > 0;
          Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R] + predicateK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] != null;
          Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1207[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
          assume wf(Heap, Mask);
          assume (Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
          assume predicateK > 0;
          Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + predicateK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume !(Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
          assume Heap[current#67, Message.cust1] != null;
          Heap[Heap[current#67, Message.cust1], FactorialCont.v] := inhaleHeap#_1207[Heap[current#67, Message.cust1], FactorialCont.v];
          assume wf(Heap, Mask);
          assume true;
          assume predicateK > 0;
          Mask[Heap[current#67, Message.cust1], FactorialCont.v] := Mask[Heap[current#67, Message.cust1], FactorialCont.v][perm$R := Mask[Heap[current#67, Message.cust1], FactorialCont.v][perm$R] + predicateK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[current#67, Message.cust1], FactorialCont.v]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume Heap[current#67, Message.cust1] != null;
          Heap[Heap[current#67, Message.cust1], FactorialCont.vo] := inhaleHeap#_1207[Heap[current#67, Message.cust1], FactorialCont.vo];
          assume wf(Heap, Mask);
          assume true;
          assume predicateK > 0;
          Mask[Heap[current#67, Message.cust1], FactorialCont.vo] := Mask[Heap[current#67, Message.cust1], FactorialCont.vo][perm$R := Mask[Heap[current#67, Message.cust1], FactorialCont.vo][perm$R] + predicateK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1207[Heap[current#67, Message.cust1], FactorialCont.vo]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1207, Mask);
          assume Heap[current#67, Message.v1] == (Heap[Heap[current#67, Message.cust1], FactorialCont.v] - 1);
          assume Heap[current#67, Message.vo1] == Heap[Heap[current#67, Message.cust1], FactorialCont.vo];
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        // if
        assert {:msg "  755.8: Receiver might be null."} true ==> (current#67 != null);
        assert {:msg "  755.8: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.v1);
        if (Heap[current#67, Message.v1] == 0) {
          // if
          assert {:msg "  756.10: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  756.10: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.cust1);
          if (Heap[current#67, Message.cust1] == null) {
            // local var m
            // assigment to m
            // new
            havoc nw#_1208;
            assume (nw#_1208 != null) && (dtype(nw#_1208) == Message#t);
            assume (forall<T#_12> f: Field (T#_12) :: (Mask[nw#_1208, f][perm$R] == 0) && (Mask[nw#_1208, f][perm$N] == 0));
            assume Heap[nw#_1208, mu] == $LockBottom;
            assume Heap[nw#_1208, held] <= 0;
            assume Heap[nw#_1208, rdheld] == false;
            Mask[nw#_1208, Message.type] := Mask[nw#_1208, Message.type][perm$R := Mask[nw#_1208, Message.type][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.sender1] := Mask[nw#_1208, Message.sender1][perm$R := Mask[nw#_1208, Message.sender1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.sender3] := Mask[nw#_1208, Message.sender3][perm$R := Mask[nw#_1208, Message.sender3][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.sender2] := Mask[nw#_1208, Message.sender2][perm$R := Mask[nw#_1208, Message.sender2][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.sender4] := Mask[nw#_1208, Message.sender4][perm$R := Mask[nw#_1208, Message.sender4][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.receiver1] := Mask[nw#_1208, Message.receiver1][perm$R := Mask[nw#_1208, Message.receiver1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.receiver2] := Mask[nw#_1208, Message.receiver2][perm$R := Mask[nw#_1208, Message.receiver2][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.receiver3] := Mask[nw#_1208, Message.receiver3][perm$R := Mask[nw#_1208, Message.receiver3][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.receiver4] := Mask[nw#_1208, Message.receiver4][perm$R := Mask[nw#_1208, Message.receiver4][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.v1] := Mask[nw#_1208, Message.v1][perm$R := Mask[nw#_1208, Message.v1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.vo1] := Mask[nw#_1208, Message.vo1][perm$R := Mask[nw#_1208, Message.vo1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.cust1] := Mask[nw#_1208, Message.cust1][perm$R := Mask[nw#_1208, Message.cust1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.vr1] := Mask[nw#_1208, Message.vr1][perm$R := Mask[nw#_1208, Message.vr1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.old1] := Mask[nw#_1208, Message.old1][perm$R := Mask[nw#_1208, Message.old1][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.vr2] := Mask[nw#_1208, Message.vr2][perm$R := Mask[nw#_1208, Message.vr2][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.old2] := Mask[nw#_1208, Message.old2][perm$R := Mask[nw#_1208, Message.old2][perm$R] + Fractions(100)];
            Mask[nw#_1208, Message.vr3] := Mask[nw#_1208, Message.vr3][perm$R := Mask[nw#_1208, Message.vr3][perm$R] + Fractions(100)];
            Mask[nw#_1208, mu] := Mask[nw#_1208, mu][perm$R := Mask[nw#_1208, mu][perm$R] + Fractions(100)];
            m#69 := nw#_1208;
            // update field sender4
            assert {:msg "  759.7: Location might not be writable"} CanWrite(Mask, m#69, Message.sender4);
            Heap[m#69, Message.sender4] := null;
            assume wf(Heap, Mask);
            assume (0 < methodCallK#_1212) && ((1000 * methodCallK#_1212) < Fractions(1)) && ((1000 * methodCallK#_1212) < whileK#_1176);
            // call setFinalResult
            callHeap#_1209 := Heap;
            callMask#_1210 := Mask;
            callCredits#_1211 := Credits;
            assert {:msg "  760.7: The target of the method call might be null."} m#69 != null;
            assert {:msg "  760.31: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  760.31: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.sender1);
            this#132 := m#69;
            vr#133 := 1;
            receiver#134 := Heap[current#67, Message.sender1];
            // begin exhale (precondition)
            exhaleMask#_1213 := Mask;
            if (!(Heap[this#132, Message.sender4] == null)) {
              assert {:msg "  760.7: The precondition at 709.11 might not hold. The expression at 710.45 might not evaluate to true."} !(Heap[Heap[this#132, Message.sender4], FactorialCont.q] == null);
            } else {
            }
            assert {:msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.11 might not be positive."} Fractions(100) > 0;
            assert {:msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.11 for Message.type."} (Fractions(100) <= exhaleMask#_1213[this#132, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1213[this#132, Message.type][perm$R]) ==> (0 <= exhaleMask#_1213[this#132, Message.type][perm$N]));
            exhaleMask#_1213[this#132, Message.type] := exhaleMask#_1213[this#132, Message.type][perm$R := exhaleMask#_1213[this#132, Message.type][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1213);
            assert {:msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.24 might not be positive."} Fractions(100) > 0;
            assert {:msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.24 for Message.sender4."} (Fractions(100) <= exhaleMask#_1213[this#132, Message.sender4][perm$R]) && ((Fractions(100) == exhaleMask#_1213[this#132, Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1213[this#132, Message.sender4][perm$N]));
            exhaleMask#_1213[this#132, Message.sender4] := exhaleMask#_1213[this#132, Message.sender4][perm$R := exhaleMask#_1213[this#132, Message.sender4][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1213);
            assert {:msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.40 might not be positive."} Fractions(100) > 0;
            assert {:msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.40 for Message.receiver4."} (Fractions(100) <= exhaleMask#_1213[this#132, Message.receiver4][perm$R]) && ((Fractions(100) == exhaleMask#_1213[this#132, Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1213[this#132, Message.receiver4][perm$N]));
            exhaleMask#_1213[this#132, Message.receiver4] := exhaleMask#_1213[this#132, Message.receiver4][perm$R := exhaleMask#_1213[this#132, Message.receiver4][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1213);
            assert {:msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.58 might not be positive."} Fractions(100) > 0;
            assert {:msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.58 for Message.vr3."} (Fractions(100) <= exhaleMask#_1213[this#132, Message.vr3][perm$R]) && ((Fractions(100) == exhaleMask#_1213[this#132, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1213[this#132, Message.vr3][perm$N]));
            exhaleMask#_1213[this#132, Message.vr3] := exhaleMask#_1213[this#132, Message.vr3][perm$R := exhaleMask#_1213[this#132, Message.vr3][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1213);
            if (!(Heap[this#132, Message.sender4] == null)) {
              assert {:msg "  760.7: The precondition at 709.11 might not hold. The permission at 710.23 might not be positive."} monitorK > 0;
              assert {:msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 710.23 for FactorialCont.q."} (monitorK <= exhaleMask#_1213[Heap[this#132, Message.sender4], FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1213[Heap[this#132, Message.sender4], FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1213[Heap[this#132, Message.sender4], FactorialCont.q][perm$N]));
              exhaleMask#_1213[Heap[this#132, Message.sender4], FactorialCont.q] := exhaleMask#_1213[Heap[this#132, Message.sender4], FactorialCont.q][perm$R := exhaleMask#_1213[Heap[this#132, Message.sender4], FactorialCont.q][perm$R] - monitorK];
              assume IsGoodMask(Mask);
              assume wf(Heap, Mask);
              assume wf(Heap, exhaleMask#_1213);
            } else {
            }
            Mask := exhaleMask#_1213;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (postcondition)
            havoc inhaleHeap#_1221;
            assume IsGoodInhaleState(inhaleHeap#_1221, Heap, Mask);
            assume this#132 != null;
            Heap[this#132, Message.invFinalResult] := inhaleHeap#_1221[this#132, Message.invFinalResult];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1221[this#132, Message.invFinalResult] == Heap;
            assume Fractions(100) > 0;
            Mask[this#132, Message.invFinalResult] := Mask[this#132, Message.invFinalResult][perm$R := Mask[this#132, Message.invFinalResult][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1221[this#132, Message.invFinalResult]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1221, Mask);
            assume this#132 != null;
            Heap[this#132, Message.type] := inhaleHeap#_1221[this#132, Message.type];
            assume wf(Heap, Mask);
            assume true;
            assume monitorK > 0;
            Mask[this#132, Message.type] := Mask[this#132, Message.type][perm$R := Mask[this#132, Message.type][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1221[this#132, Message.type]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1221, Mask);
            assume this#132 != null;
            Heap[this#132, Message.type] := inhaleHeap#_1221[this#132, Message.type];
            assume wf(Heap, Mask);
            assume true;
            assume monitorK > 0;
            Mask[this#132, Message.type] := Mask[this#132, Message.type][perm$R := Mask[this#132, Message.type][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1221[this#132, Message.type]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1221, Mask);
            assume Heap[this#132, Message.type] == 4;
            assume this#132 != null;
            Heap[this#132, Message.vr3] := inhaleHeap#_1221[this#132, Message.vr3];
            assume wf(Heap, Mask);
            assume true;
            assume monitorK > 0;
            Mask[this#132, Message.vr3] := Mask[this#132, Message.vr3][perm$R := Mask[this#132, Message.vr3][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1221[this#132, Message.vr3]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1221, Mask);
            assume Heap[this#132, Message.vr3] == vr#133;
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            // assert
            Heap#_1225 := Heap;
            Mask#_1226 := Mask;
            Credits#_1227 := Credits;
            // begin exhale (assert)
            exhaleMask#_1228 := Mask#_1226;
            assert {:msg "  762.14: Receiver might be null."} true ==> (m#69 != null);
            assert {:msg "  762.14: Location might not be readable."} true ==> CanRead(Mask#_1226, m#69, Message.vr3);
            assert {:msg "  762.33: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  762.33: Location might not be readable."} true ==> CanRead(Mask#_1226, current#67, Message.vo1);
            assert {:msg "  762.21: Receiver might be null."} true ==> (m#69 != null);
            // check precondition of call
            assume (0 < funcappK#_1235) && ((1000 * funcappK#_1235) < Fractions(1));
            assume true;
            Heap#_1232 := Heap#_1225;
            Mask#_1233 := Mask#_1226;
            Credits#_1234 := Credits#_1227;
            // begin exhale (function call)
            exhaleMask#_1236 := Mask#_1233;
            assert {:msg "  762.21: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1232[current#67, Message.vo1] >= 0;
            Mask#_1233 := exhaleMask#_1236;
            assume wf(Heap#_1232, Mask#_1233);
            // end exhale
            assert {:msg "  762.7: Assertion might not hold. The expression at 762.14 might not evaluate to true."} Heap#_1225[m#69, Message.vr3] == #Message.factorial(Heap#_1225, Mask#_1226, m#69, Heap#_1225[current#67, Message.vo1]);
            Mask#_1226 := exhaleMask#_1228;
            assume wf(Heap#_1225, Mask#_1226);
            // end exhale
            // unfold
            assume (0 < unfoldK#_1237) && (unfoldK#_1237 < Fractions(1)) && ((1000 * unfoldK#_1237) < whileK#_1176);
            assert {:msg "  763.14: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  763.14: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.sender1);
            assert {:msg "  763.14: Receiver might be null."} true ==> (Heap[current#67, Message.sender1] != null);
            assert {:msg "  763.14: Location might not be readable."} true ==> CanRead(Mask, Heap[current#67, Message.sender1], Future.q);
            assert {:msg "  763.7: The target of the fold statement might be null."} Heap[Heap[current#67, Message.sender1], Future.q] != null;
            // begin exhale (unfold)
            exhaleMask#_1238 := Mask;
            assert {:msg "  763.7: unfold might fail because the predicate FutureChannel.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
            assert {:msg "  763.7: unfold might fail because the predicate FutureChannel.valid does not hold. Insufficient fraction at <undefined position> for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1238[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1238[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1238[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$N]));
            exhaleMask#_1238[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid] := exhaleMask#_1238[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1238[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1238);
            Mask := exhaleMask#_1238;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (unfold)
            inhaleHeap#_1240 := Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.valid];
            assume IsGoodInhaleState(inhaleHeap#_1240, Heap, Mask);
            assume Heap[Heap[current#67, Message.sender1], Future.q] != null;
            Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp] := inhaleHeap#_1240[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp]) == FutureChannelImpEP#t);
            assume monitorK > 0;
            Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp] := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp][perm$R := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1240[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1240, Mask);
            assume Heap[Heap[current#67, Message.sender1], Future.q] != null;
            Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] := inhaleHeap#_1240[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp]) == FutureChannelExpEP#t);
            assume monitorK > 0;
            Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp][perm$R := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1240[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1240, Mask);
            assume Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch] := inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch]) == FutureChannel#t);
            assume monitorK > 0;
            Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch] := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch][perm$R := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1240, Mask);
            assume Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch] := inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch] == null) || (dtype(Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch]) == FutureChannel#t);
            assume monitorK > 0;
            Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch] := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch][perm$R := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1240, Mask);
            assume !(Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp] == null);
            assume !(Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] == null);
            assume Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid] := inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid] := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1240, Mask);
            assume Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid] := inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid] := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid][perm$R := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1240[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1240, Mask);
            assume Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.imp], FutureChannelImpEP.ch] == Heap[Heap[current#67, Message.sender1], Future.q];
            assume Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.ch] == Heap[Heap[current#67, Message.sender1], Future.q];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            // unfold
            assume (0 < unfoldK#_1241) && (unfoldK#_1241 < Fractions(1)) && ((1000 * unfoldK#_1241) < whileK#_1176);
            assert {:msg "  764.14: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  764.14: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.sender1);
            assert {:msg "  764.14: Receiver might be null."} true ==> (Heap[current#67, Message.sender1] != null);
            assert {:msg "  764.14: Location might not be readable."} true ==> CanRead(Mask, Heap[current#67, Message.sender1], Future.q);
            assert {:msg "  764.7: The target of the fold statement might be null."} Heap[Heap[current#67, Message.sender1], Future.q] != null;
            // begin exhale (unfold)
            exhaleMask#_1242 := Mask;
            assert {:msg "  764.7: unfold might fail because the predicate FutureChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
            assert {:msg "  764.7: unfold might fail because the predicate FutureChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1242[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1242[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1242[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$N]));
            exhaleMask#_1242[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState] := exhaleMask#_1242[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1242[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1242);
            Mask := exhaleMask#_1242;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (unfold)
            inhaleHeap#_1244 := Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.initExpState];
            assume IsGoodInhaleState(inhaleHeap#_1244, Heap, Mask);
            assume Heap[Heap[current#67, Message.sender1], Future.q] != null;
            Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] := inhaleHeap#_1244[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp]) == FutureChannelExpEP#t);
            assume monitorK > 0;
            Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp][perm$R := Mask[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1244[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1244, Mask);
            assume Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state] := inhaleHeap#_1244[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state];
            assume wf(Heap, Mask);
            assume true;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state] := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state][perm$R := Mask[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1244[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1244, Mask);
            assume Heap[Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp], FutureChannelExpEP.state] == 0;
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            assume (0 < methodCallK#_1248) && ((1000 * methodCallK#_1248) < Fractions(1)) && ((1000 * methodCallK#_1248) < whileK#_1176);
            // call sendFinalResult
            callHeap#_1245 := Heap;
            callMask#_1246 := Mask;
            callCredits#_1247 := Credits;
            assert {:msg "  765.12: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.sender1);
            assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[current#67, Message.sender1] != null);
            assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[current#67, Message.sender1], Future.q);
            assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[current#67, Message.sender1], Future.q] != null);
            assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp);
            assert {:msg "  765.7: The target of the method call might be null."} Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp] != null;
            this#135 := Heap[Heap[Heap[current#67, Message.sender1], Future.q], FutureChannel.exp];
            m#136 := m#69;
            // begin exhale (precondition)
            exhaleMask#_1249 := Mask;
            assert {:msg "  765.7: The precondition at 400.11 might not hold. The expression at 400.63 might not evaluate to true."} Heap[m#136, Message.type] == 4;
            assert {:msg "  765.7: The precondition at 402.11 might not hold. The expression at 402.11 might not evaluate to true."} Heap[this#135, FutureChannelExpEP.state] == 0;
            assert {:msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.11 might not be positive."} Fractions(100) > 0;
            assert {:msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.11 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1249[this#135, FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1249[this#135, FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1249[this#135, FutureChannelExpEP.state][perm$N]));
            exhaleMask#_1249[this#135, FutureChannelExpEP.state] := exhaleMask#_1249[this#135, FutureChannelExpEP.state][perm$R := exhaleMask#_1249[this#135, FutureChannelExpEP.state][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1249);
            assert {:msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.25 might not be positive."} monitorK > 0;
            assert {:msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.25 for Message.type."} (monitorK <= exhaleMask#_1249[m#136, Message.type][perm$R]) && ((monitorK == exhaleMask#_1249[m#136, Message.type][perm$R]) ==> (0 <= exhaleMask#_1249[m#136, Message.type][perm$N]));
            exhaleMask#_1249[m#136, Message.type] := exhaleMask#_1249[m#136, Message.type][perm$R := exhaleMask#_1249[m#136, Message.type][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1249);
            assert {:msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.44 might not be positive."} monitorK > 0;
            assert {:msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.44 for Message.type."} (monitorK <= exhaleMask#_1249[m#136, Message.type][perm$R]) && ((monitorK == exhaleMask#_1249[m#136, Message.type][perm$R]) ==> (0 <= exhaleMask#_1249[m#136, Message.type][perm$N]));
            exhaleMask#_1249[m#136, Message.type] := exhaleMask#_1249[m#136, Message.type][perm$R := exhaleMask#_1249[m#136, Message.type][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1249);
            assert {:msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.76 might not be positive."} Fractions(100) > 0;
            assert {:msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.76 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1249[m#136, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1249[m#136, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1249[m#136, Message.invFinalResult][perm$N]));
            exhaleMask#_1249[m#136, Message.invFinalResult] := exhaleMask#_1249[m#136, Message.invFinalResult][perm$R := exhaleMask#_1249[m#136, Message.invFinalResult][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1249);
            assert {:msg "  765.7: The precondition at 401.11 might not hold. The permission at 401.11 might not be positive."} Fractions(100) > 0;
            assert {:msg "  765.7: The precondition at 401.11 might not hold. Insufficient fraction at 401.11 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1249[this#135, FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1249[this#135, FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1249[this#135, FutureChannelExpEP.valid][perm$N]));
            exhaleMask#_1249[this#135, FutureChannelExpEP.valid] := exhaleMask#_1249[this#135, FutureChannelExpEP.valid][perm$R := exhaleMask#_1249[this#135, FutureChannelExpEP.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1249);
            Mask := exhaleMask#_1249;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (postcondition)
            havoc inhaleHeap#_1257;
            assume IsGoodInhaleState(inhaleHeap#_1257, Heap, Mask);
            assume this#135 != null;
            Heap[this#135, FutureChannelExpEP.state] := inhaleHeap#_1257[this#135, FutureChannelExpEP.state];
            assume wf(Heap, Mask);
            assume true;
            assume Fractions(100) > 0;
            Mask[this#135, FutureChannelExpEP.state] := Mask[this#135, FutureChannelExpEP.state][perm$R := Mask[this#135, FutureChannelExpEP.state][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1257[this#135, FutureChannelExpEP.state]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1257, Mask);
            assume this#135 != null;
            Heap[this#135, FutureChannelExpEP.valid] := inhaleHeap#_1257[this#135, FutureChannelExpEP.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1257[this#135, FutureChannelExpEP.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[this#135, FutureChannelExpEP.valid] := Mask[this#135, FutureChannelExpEP.valid][perm$R := Mask[this#135, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1257[this#135, FutureChannelExpEP.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1257, Mask);
            if (callHeap#_1245[this#135, FutureChannelExpEP.state] == 0) {
              assume Heap[this#135, FutureChannelExpEP.state] == 1;
            } else {
            }
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
          } else {
            // local var m
            // assigment to m
            // new
            havoc nw#_1258;
            assume (nw#_1258 != null) && (dtype(nw#_1258) == Message#t);
            assume (forall<T#_13> f: Field (T#_13) :: (Mask[nw#_1258, f][perm$R] == 0) && (Mask[nw#_1258, f][perm$N] == 0));
            assume Heap[nw#_1258, mu] == $LockBottom;
            assume Heap[nw#_1258, held] <= 0;
            assume Heap[nw#_1258, rdheld] == false;
            Mask[nw#_1258, Message.type] := Mask[nw#_1258, Message.type][perm$R := Mask[nw#_1258, Message.type][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.sender1] := Mask[nw#_1258, Message.sender1][perm$R := Mask[nw#_1258, Message.sender1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.sender3] := Mask[nw#_1258, Message.sender3][perm$R := Mask[nw#_1258, Message.sender3][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.sender2] := Mask[nw#_1258, Message.sender2][perm$R := Mask[nw#_1258, Message.sender2][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.sender4] := Mask[nw#_1258, Message.sender4][perm$R := Mask[nw#_1258, Message.sender4][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.receiver1] := Mask[nw#_1258, Message.receiver1][perm$R := Mask[nw#_1258, Message.receiver1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.receiver2] := Mask[nw#_1258, Message.receiver2][perm$R := Mask[nw#_1258, Message.receiver2][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.receiver3] := Mask[nw#_1258, Message.receiver3][perm$R := Mask[nw#_1258, Message.receiver3][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.receiver4] := Mask[nw#_1258, Message.receiver4][perm$R := Mask[nw#_1258, Message.receiver4][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.v1] := Mask[nw#_1258, Message.v1][perm$R := Mask[nw#_1258, Message.v1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.vo1] := Mask[nw#_1258, Message.vo1][perm$R := Mask[nw#_1258, Message.vo1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.cust1] := Mask[nw#_1258, Message.cust1][perm$R := Mask[nw#_1258, Message.cust1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.vr1] := Mask[nw#_1258, Message.vr1][perm$R := Mask[nw#_1258, Message.vr1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.old1] := Mask[nw#_1258, Message.old1][perm$R := Mask[nw#_1258, Message.old1][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.vr2] := Mask[nw#_1258, Message.vr2][perm$R := Mask[nw#_1258, Message.vr2][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.old2] := Mask[nw#_1258, Message.old2][perm$R := Mask[nw#_1258, Message.old2][perm$R] + Fractions(100)];
            Mask[nw#_1258, Message.vr3] := Mask[nw#_1258, Message.vr3][perm$R := Mask[nw#_1258, Message.vr3][perm$R] + Fractions(100)];
            Mask[nw#_1258, mu] := Mask[nw#_1258, mu][perm$R := Mask[nw#_1258, mu][perm$R] + Fractions(100)];
            m#71 := nw#_1258;
            // update field sender2
            assert {:msg "  771.7: Location might not be writable"} CanWrite(Mask, m#71, Message.sender2);
            assert {:msg "  771.18: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  771.18: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.sender1);
            Heap[m#71, Message.sender2] := Heap[current#67, Message.sender1];
            assume wf(Heap, Mask);
            assume (0 < methodCallK#_1262) && ((1000 * methodCallK#_1262) < Fractions(1)) && ((1000 * methodCallK#_1262) < whileK#_1176);
            // call setResult1
            callHeap#_1259 := Heap;
            callMask#_1260 := Mask;
            callCredits#_1261 := Credits;
            assert {:msg "  772.7: The target of the method call might be null."} m#71 != null;
            assert {:msg "  772.32: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  772.32: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.cust1);
            this#137 := m#71;
            v#138 := 1;
            oldv#139 := this;
            receiver#140 := Heap[current#67, Message.cust1];
            // begin exhale (precondition)
            exhaleMask#_1263 := Mask;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The expression at 681.4 might not evaluate to true."} !(Heap[this#137, Message.sender2] == null);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The expression at 681.44 might not evaluate to true."} !(Heap[Heap[this#137, Message.sender2], Future.q] == null);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.3 might not evaluate to true."} v#138 == #Message.factorial(Heap, Mask, this#137, 0);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.45 might not evaluate to true."} !(receiver#140 == null);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.64 might not evaluate to true."} Heap[receiver#140, FactorialCont.v] == 1;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.11 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.11 for Message.type."} (Fractions(100) <= exhaleMask#_1263[this#137, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1263[this#137, Message.type][perm$R]) ==> (0 <= exhaleMask#_1263[this#137, Message.type][perm$N]));
            exhaleMask#_1263[this#137, Message.type] := exhaleMask#_1263[this#137, Message.type][perm$R := exhaleMask#_1263[this#137, Message.type][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.25 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.25 for Message.sender2."} (Fractions(100) <= exhaleMask#_1263[this#137, Message.sender2][perm$R]) && ((Fractions(100) == exhaleMask#_1263[this#137, Message.sender2][perm$R]) ==> (0 <= exhaleMask#_1263[this#137, Message.sender2][perm$N]));
            exhaleMask#_1263[this#137, Message.sender2] := exhaleMask#_1263[this#137, Message.sender2][perm$R := exhaleMask#_1263[this#137, Message.sender2][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.41 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.41 for Message.receiver2."} (Fractions(100) <= exhaleMask#_1263[this#137, Message.receiver2][perm$R]) && ((Fractions(100) == exhaleMask#_1263[this#137, Message.receiver2][perm$R]) ==> (0 <= exhaleMask#_1263[this#137, Message.receiver2][perm$N]));
            exhaleMask#_1263[this#137, Message.receiver2] := exhaleMask#_1263[this#137, Message.receiver2][perm$R := exhaleMask#_1263[this#137, Message.receiver2][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 680.3 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 680.3 for Message.vr1."} (Fractions(100) <= exhaleMask#_1263[this#137, Message.vr1][perm$R]) && ((Fractions(100) == exhaleMask#_1263[this#137, Message.vr1][perm$R]) ==> (0 <= exhaleMask#_1263[this#137, Message.vr1][perm$N]));
            exhaleMask#_1263[this#137, Message.vr1] := exhaleMask#_1263[this#137, Message.vr1][perm$R := exhaleMask#_1263[this#137, Message.vr1][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 680.15 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 680.15 for Message.old1."} (Fractions(100) <= exhaleMask#_1263[this#137, Message.old1][perm$R]) && ((Fractions(100) == exhaleMask#_1263[this#137, Message.old1][perm$R]) ==> (0 <= exhaleMask#_1263[this#137, Message.old1][perm$N]));
            exhaleMask#_1263[this#137, Message.old1] := exhaleMask#_1263[this#137, Message.old1][perm$R := exhaleMask#_1263[this#137, Message.old1][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.22 might not be positive."} monitorK > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.22 for Future.q."} (monitorK <= exhaleMask#_1263[Heap[this#137, Message.sender2], Future.q][perm$R]) && ((monitorK == exhaleMask#_1263[Heap[this#137, Message.sender2], Future.q][perm$R]) ==> (0 <= exhaleMask#_1263[Heap[this#137, Message.sender2], Future.q][perm$N]));
            exhaleMask#_1263[Heap[this#137, Message.sender2], Future.q] := exhaleMask#_1263[Heap[this#137, Message.sender2], Future.q][perm$R := exhaleMask#_1263[Heap[this#137, Message.sender2], Future.q][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.63 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.63 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.valid][perm$N]));
            exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.valid] := exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.82 might not be positive."} Fractions(100) > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.82 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.initExpState][perm$N]));
            exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.initExpState] := exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1263[Heap[Heap[this#137, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            assert {:msg "  772.7: The precondition at 679.11 might not hold. The permission at 682.22 might not be positive."} monitorK > 0;
            assert {:msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 682.22 for FactorialCont.v."} (monitorK <= exhaleMask#_1263[receiver#140, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1263[receiver#140, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1263[receiver#140, FactorialCont.v][perm$N]));
            exhaleMask#_1263[receiver#140, FactorialCont.v] := exhaleMask#_1263[receiver#140, FactorialCont.v][perm$R := exhaleMask#_1263[receiver#140, FactorialCont.v][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1263);
            Mask := exhaleMask#_1263;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (postcondition)
            havoc inhaleHeap#_1275;
            assume IsGoodInhaleState(inhaleHeap#_1275, Heap, Mask);
            assume this#137 != null;
            Heap[this#137, Message.invResult1] := inhaleHeap#_1275[this#137, Message.invResult1];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1275[this#137, Message.invResult1] == Heap;
            assume Fractions(100) > 0;
            Mask[this#137, Message.invResult1] := Mask[this#137, Message.invResult1][perm$R := Mask[this#137, Message.invResult1][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1275[this#137, Message.invResult1]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1275, Mask);
            assume this#137 != null;
            Heap[this#137, Message.type] := inhaleHeap#_1275[this#137, Message.type];
            assume wf(Heap, Mask);
            assume true;
            assume monitorK > 0;
            Mask[this#137, Message.type] := Mask[this#137, Message.type][perm$R := Mask[this#137, Message.type][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1275[this#137, Message.type]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1275, Mask);
            assume this#137 != null;
            Heap[this#137, Message.type] := inhaleHeap#_1275[this#137, Message.type];
            assume wf(Heap, Mask);
            assume true;
            assume monitorK > 0;
            Mask[this#137, Message.type] := Mask[this#137, Message.type][perm$R := Mask[this#137, Message.type][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1275[this#137, Message.type]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1275, Mask);
            assume Heap[this#137, Message.type] == 2;
            assume this#137 != null;
            Heap[this#137, Message.receiver2] := inhaleHeap#_1275[this#137, Message.receiver2];
            assume wf(Heap, Mask);
            assume (Heap[this#137, Message.receiver2] == null) || (dtype(Heap[this#137, Message.receiver2]) == FactorialCont#t);
            assume monitorK > 0;
            Mask[this#137, Message.receiver2] := Mask[this#137, Message.receiver2][perm$R := Mask[this#137, Message.receiver2][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1275[this#137, Message.receiver2]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1275, Mask);
            assume Heap[this#137, Message.receiver2] == receiver#140;
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            // unfold
            assume (0 < unfoldK#_1276) && (unfoldK#_1276 < Fractions(1)) && ((1000 * unfoldK#_1276) < whileK#_1176);
            assert {:msg "  773.14: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  773.14: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.cust1);
            assert {:msg "  773.14: Receiver might be null."} true ==> (Heap[current#67, Message.cust1] != null);
            assert {:msg "  773.14: Location might not be readable."} true ==> CanRead(Mask, Heap[current#67, Message.cust1], FactorialCont.q);
            assert {:msg "  773.7: The target of the fold statement might be null."} Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
            // begin exhale (unfold)
            exhaleMask#_1277 := Mask;
            assert {:msg "  773.7: unfold might fail because the predicate FactorialContChannel.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
            assert {:msg "  773.7: unfold might fail because the predicate FactorialContChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1277[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1277[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1277[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$N]));
            exhaleMask#_1277[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1277[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1277[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1277);
            Mask := exhaleMask#_1277;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (unfold)
            inhaleHeap#_1279 := Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.valid];
            assume IsGoodInhaleState(inhaleHeap#_1279, Heap, Mask);
            assume Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
            Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1279[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
            assume monitorK > 0;
            Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1279[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1279, Mask);
            assume Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
            Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1279[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
            assume monitorK > 0;
            Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1279[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1279, Mask);
            assume Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] := inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
            assume monitorK > 0;
            Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1279, Mask);
            assume Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] := inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] == null) || (dtype(Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
            assume monitorK > 0;
            Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1279, Mask);
            assume !(Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] == null);
            assume !(Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] == null);
            assume Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] := inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1279, Mask);
            assume Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid] := inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1279[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1279, Mask);
            assume Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] == Heap[Heap[current#67, Message.cust1], FactorialCont.q];
            assume Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] == Heap[Heap[current#67, Message.cust1], FactorialCont.q];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            // unfold
            assume (0 < unfoldK#_1280) && (unfoldK#_1280 < Fractions(1)) && ((1000 * unfoldK#_1280) < whileK#_1176);
            assert {:msg "  774.14: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  774.14: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.cust1);
            assert {:msg "  774.14: Receiver might be null."} true ==> (Heap[current#67, Message.cust1] != null);
            assert {:msg "  774.14: Location might not be readable."} true ==> CanRead(Mask, Heap[current#67, Message.cust1], FactorialCont.q);
            assert {:msg "  774.7: The target of the fold statement might be null."} Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
            // begin exhale (unfold)
            exhaleMask#_1281 := Mask;
            assert {:msg "  774.7: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
            assert {:msg "  774.7: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1281[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1281[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1281[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
            exhaleMask#_1281[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1281[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1281[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1281);
            Mask := exhaleMask#_1281;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (unfold)
            inhaleHeap#_1283 := Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.initExpState];
            assume IsGoodInhaleState(inhaleHeap#_1283, Heap, Mask);
            assume Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null;
            Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1283[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp];
            assume wf(Heap, Mask);
            assume (Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
            assume monitorK > 0;
            Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1283[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1283, Mask);
            assume Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] != null;
            Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] := inhaleHeap#_1283[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state];
            assume wf(Heap, Mask);
            assume true;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R := Mask[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1283[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1283, Mask);
            assume Heap[Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] == 0;
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            assume (0 < methodCallK#_1287) && ((1000 * methodCallK#_1287) < Fractions(1)) && ((1000 * methodCallK#_1287) < whileK#_1176);
            // call sendResult1
            callHeap#_1284 := Heap;
            callMask#_1285 := Mask;
            callCredits#_1286 := Credits;
            assert {:msg "  775.12: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.cust1);
            assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[current#67, Message.cust1] != null);
            assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[current#67, Message.cust1], FactorialCont.q);
            assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[current#67, Message.cust1], FactorialCont.q] != null);
            assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp);
            assert {:msg "  775.7: The target of the method call might be null."} Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp] != null;
            this#141 := Heap[Heap[Heap[current#67, Message.cust1], FactorialCont.q], FactorialContChannel.exp];
            m#142 := m#71;
            // begin exhale (precondition)
            exhaleMask#_1288 := Mask;
            assert {:msg "  775.7: The precondition at 195.11 might not hold. The expression at 195.63 might not evaluate to true."} Heap[m#142, Message.type] == 2;
            assert {:msg "  775.7: The precondition at 197.11 might not hold. The expression at 197.11 might not evaluate to true."} Heap[this#141, FactorialContChannelExpEP.state] == 0;
            assert {:msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.11 might not be positive."} Fractions(100) > 0;
            assert {:msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.11 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1288[this#141, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1288[this#141, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1288[this#141, FactorialContChannelExpEP.state][perm$N]));
            exhaleMask#_1288[this#141, FactorialContChannelExpEP.state] := exhaleMask#_1288[this#141, FactorialContChannelExpEP.state][perm$R := exhaleMask#_1288[this#141, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1288);
            assert {:msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.25 might not be positive."} monitorK > 0;
            assert {:msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.25 for Message.type."} (monitorK <= exhaleMask#_1288[m#142, Message.type][perm$R]) && ((monitorK == exhaleMask#_1288[m#142, Message.type][perm$R]) ==> (0 <= exhaleMask#_1288[m#142, Message.type][perm$N]));
            exhaleMask#_1288[m#142, Message.type] := exhaleMask#_1288[m#142, Message.type][perm$R := exhaleMask#_1288[m#142, Message.type][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1288);
            assert {:msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.44 might not be positive."} monitorK > 0;
            assert {:msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.44 for Message.type."} (monitorK <= exhaleMask#_1288[m#142, Message.type][perm$R]) && ((monitorK == exhaleMask#_1288[m#142, Message.type][perm$R]) ==> (0 <= exhaleMask#_1288[m#142, Message.type][perm$N]));
            exhaleMask#_1288[m#142, Message.type] := exhaleMask#_1288[m#142, Message.type][perm$R := exhaleMask#_1288[m#142, Message.type][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1288);
            assert {:msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.76 might not be positive."} Fractions(100) > 0;
            assert {:msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.76 for Message.invResult1."} (Fractions(100) <= exhaleMask#_1288[m#142, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_1288[m#142, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_1288[m#142, Message.invResult1][perm$N]));
            exhaleMask#_1288[m#142, Message.invResult1] := exhaleMask#_1288[m#142, Message.invResult1][perm$R := exhaleMask#_1288[m#142, Message.invResult1][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1288);
            assert {:msg "  775.7: The precondition at 196.11 might not hold. The permission at 196.11 might not be positive."} Fractions(100) > 0;
            assert {:msg "  775.7: The precondition at 196.11 might not hold. Insufficient fraction at 196.11 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1288[this#141, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1288[this#141, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1288[this#141, FactorialContChannelExpEP.valid][perm$N]));
            exhaleMask#_1288[this#141, FactorialContChannelExpEP.valid] := exhaleMask#_1288[this#141, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_1288[this#141, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1288);
            Mask := exhaleMask#_1288;
            assume wf(Heap, Mask);
            // end exhale
            // inhale (postcondition)
            havoc inhaleHeap#_1296;
            assume IsGoodInhaleState(inhaleHeap#_1296, Heap, Mask);
            assume this#141 != null;
            Heap[this#141, FactorialContChannelExpEP.state] := inhaleHeap#_1296[this#141, FactorialContChannelExpEP.state];
            assume wf(Heap, Mask);
            assume true;
            assume Fractions(100) > 0;
            Mask[this#141, FactorialContChannelExpEP.state] := Mask[this#141, FactorialContChannelExpEP.state][perm$R := Mask[this#141, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1296[this#141, FactorialContChannelExpEP.state]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1296, Mask);
            assume this#141 != null;
            Heap[this#141, FactorialContChannelExpEP.valid] := inhaleHeap#_1296[this#141, FactorialContChannelExpEP.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1296[this#141, FactorialContChannelExpEP.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[this#141, FactorialContChannelExpEP.valid] := Mask[this#141, FactorialContChannelExpEP.valid][perm$R := Mask[this#141, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1296[this#141, FactorialContChannelExpEP.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1296, Mask);
            if (callHeap#_1284[this#141, FactorialContChannelExpEP.state] == 0) {
              assume Heap[this#141, FactorialContChannelExpEP.state] == 1;
            } else {
            }
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            // end inhale
            // local var r
            // assigment to r
            // new
            havoc nw#_1297;
            assume (nw#_1297 != null) && (dtype(nw#_1297) == Message#t);
            assume (forall<T#_14> f: Field (T#_14) :: (Mask[nw#_1297, f][perm$R] == 0) && (Mask[nw#_1297, f][perm$N] == 0));
            assume Heap[nw#_1297, mu] == $LockBottom;
            assume Heap[nw#_1297, held] <= 0;
            assume Heap[nw#_1297, rdheld] == false;
            Mask[nw#_1297, Message.type] := Mask[nw#_1297, Message.type][perm$R := Mask[nw#_1297, Message.type][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.sender1] := Mask[nw#_1297, Message.sender1][perm$R := Mask[nw#_1297, Message.sender1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.sender3] := Mask[nw#_1297, Message.sender3][perm$R := Mask[nw#_1297, Message.sender3][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.sender2] := Mask[nw#_1297, Message.sender2][perm$R := Mask[nw#_1297, Message.sender2][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.sender4] := Mask[nw#_1297, Message.sender4][perm$R := Mask[nw#_1297, Message.sender4][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.receiver1] := Mask[nw#_1297, Message.receiver1][perm$R := Mask[nw#_1297, Message.receiver1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.receiver2] := Mask[nw#_1297, Message.receiver2][perm$R := Mask[nw#_1297, Message.receiver2][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.receiver3] := Mask[nw#_1297, Message.receiver3][perm$R := Mask[nw#_1297, Message.receiver3][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.receiver4] := Mask[nw#_1297, Message.receiver4][perm$R := Mask[nw#_1297, Message.receiver4][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.v1] := Mask[nw#_1297, Message.v1][perm$R := Mask[nw#_1297, Message.v1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.vo1] := Mask[nw#_1297, Message.vo1][perm$R := Mask[nw#_1297, Message.vo1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.cust1] := Mask[nw#_1297, Message.cust1][perm$R := Mask[nw#_1297, Message.cust1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.vr1] := Mask[nw#_1297, Message.vr1][perm$R := Mask[nw#_1297, Message.vr1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.old1] := Mask[nw#_1297, Message.old1][perm$R := Mask[nw#_1297, Message.old1][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.vr2] := Mask[nw#_1297, Message.vr2][perm$R := Mask[nw#_1297, Message.vr2][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.old2] := Mask[nw#_1297, Message.old2][perm$R := Mask[nw#_1297, Message.old2][perm$R] + Fractions(100)];
            Mask[nw#_1297, Message.vr3] := Mask[nw#_1297, Message.vr3][perm$R := Mask[nw#_1297, Message.vr3][perm$R] + Fractions(100)];
            Mask[nw#_1297, mu] := Mask[nw#_1297, mu][perm$R := Mask[nw#_1297, mu][perm$R] + Fractions(100)];
            r#73 := nw#_1297;
            // update field type
            assert {:msg "  778.7: Location might not be writable"} CanWrite(Mask, r#73, Message.type);
            Heap[r#73, Message.type] := 4;
            assume wf(Heap, Mask);
            // assert
            Heap#_1301 := Heap;
            Mask#_1302 := Mask;
            Credits#_1303 := Credits;
            // begin exhale (assert)
            exhaleMask#_1304 := Mask#_1302;
            assert {:msg "  779.14: Receiver might be null."} true ==> (r#73 != null);
            assert {:msg "  779.14: Location might not be readable."} true ==> CanRead(Mask#_1302, r#73, Message.vr3);
            assert {:msg "  779.33: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  779.33: Location might not be readable."} true ==> CanRead(Mask#_1302, current#67, Message.cust1);
            assert {:msg "  779.33: Receiver might be null."} true ==> (Heap#_1301[current#67, Message.cust1] != null);
            assert {:msg "  779.33: Location might not be readable."} true ==> CanRead(Mask#_1302, Heap#_1301[current#67, Message.cust1], FactorialCont.vo);
            assert {:msg "  779.21: Receiver might be null."} true ==> (r#73 != null);
            // check precondition of call
            assume (0 < funcappK#_1311) && ((1000 * funcappK#_1311) < Fractions(1));
            assume true;
            Heap#_1308 := Heap#_1301;
            Mask#_1309 := Mask#_1302;
            Credits#_1310 := Credits#_1303;
            // begin exhale (function call)
            exhaleMask#_1312 := Mask#_1309;
            assert {:msg "  779.21: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1308[Heap#_1308[current#67, Message.cust1], FactorialCont.vo] >= 0;
            Mask#_1309 := exhaleMask#_1312;
            assume wf(Heap#_1308, Mask#_1309);
            // end exhale
            if (Heap#_1301[r#73, Message.vr3] == #Message.factorial(Heap#_1301, Mask#_1302, r#73, Heap#_1301[Heap#_1301[current#67, Message.cust1], FactorialCont.vo])) {
              assert {:msg "  779.54: Receiver might be null."} true ==> (r#73 != null);
              assert {:msg "  779.54: Location might not be readable."} true ==> CanRead(Mask#_1302, r#73, Message.vr3);
              assert {:msg "  779.73: Receiver might be null."} true ==> (current#67 != null);
              assert {:msg "  779.73: Location might not be readable."} true ==> CanRead(Mask#_1302, current#67, Message.vo1);
              assert {:msg "  779.61: Receiver might be null."} true ==> (m#71 != null);
              // check precondition of call
              assume (0 < funcappK#_1319) && ((1000 * funcappK#_1319) < Fractions(1));
              assume true;
              Heap#_1316 := Heap#_1301;
              Mask#_1317 := Mask#_1302;
              Credits#_1318 := Credits#_1303;
              // begin exhale (function call)
              exhaleMask#_1320 := Mask#_1317;
              assert {:msg "  779.61: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1316[current#67, Message.vo1] >= 0;
              Mask#_1317 := exhaleMask#_1320;
              assume wf(Heap#_1316, Mask#_1317);
              // end exhale
              assert {:msg "  779.7: Assertion might not hold. The expression at 779.54 might not evaluate to true."} Heap#_1301[r#73, Message.vr3] == #Message.factorial(Heap#_1301, Mask#_1302, m#71, Heap#_1301[current#67, Message.vo1]);
            } else {
            }
            if (Heap#_1301[r#73, Message.vr3] == #Message.factorial(Heap#_1301, Mask#_1302, r#73, Heap#_1301[Heap#_1301[current#67, Message.cust1], FactorialCont.vo])) {
            } else {
            }
            Mask#_1302 := exhaleMask#_1304;
            assume wf(Heap#_1301, Mask#_1302);
            // end exhale
          }
        } else {
          // local var cont
          // assigment to cont
          // new
          havoc nw#_1321;
          assume (nw#_1321 != null) && (dtype(nw#_1321) == FactorialCont#t);
          assume (forall<T#_15> f: Field (T#_15) :: (Mask[nw#_1321, f][perm$R] == 0) && (Mask[nw#_1321, f][perm$N] == 0));
          assume Heap[nw#_1321, mu] == $LockBottom;
          assume Heap[nw#_1321, held] <= 0;
          assume Heap[nw#_1321, rdheld] == false;
          Mask[nw#_1321, FactorialCont.q] := Mask[nw#_1321, FactorialCont.q][perm$R := Mask[nw#_1321, FactorialCont.q][perm$R] + Fractions(100)];
          Mask[nw#_1321, FactorialCont.v] := Mask[nw#_1321, FactorialCont.v][perm$R := Mask[nw#_1321, FactorialCont.v][perm$R] + Fractions(100)];
          Mask[nw#_1321, FactorialCont.vo] := Mask[nw#_1321, FactorialCont.vo][perm$R := Mask[nw#_1321, FactorialCont.vo][perm$R] + Fractions(100)];
          Mask[nw#_1321, FactorialCont.cust] := Mask[nw#_1321, FactorialCont.cust][perm$R := Mask[nw#_1321, FactorialCont.cust][perm$R] + Fractions(100)];
          Mask[nw#_1321, mu] := Mask[nw#_1321, mu][perm$R := Mask[nw#_1321, mu][perm$R] + Fractions(100)];
          cont#75 := nw#_1321;
          assume (0 < methodCallK#_1325) && ((1000 * methodCallK#_1325) < Fractions(1)) && ((1000 * methodCallK#_1325) < whileK#_1176);
          // call init
          callHeap#_1322 := Heap;
          callMask#_1323 := Mask;
          callCredits#_1324 := Credits;
          assert {:msg "  784.6: The target of the method call might be null."} cont#75 != null;
          assert {:msg "  784.21: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  784.21: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.v1);
          assert {:msg "  784.32: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  784.32: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.vo1);
          assert {:msg "  784.44: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  784.44: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.cust1);
          this#143 := cont#75;
          vp#144 := Heap[current#67, Message.v1];
          vop#145 := Heap[current#67, Message.vo1];
          custp#146 := Heap[current#67, Message.cust1];
          // begin exhale (precondition)
          exhaleMask#_1326 := Mask;
          assert {:msg "  784.6: The precondition at 822.11 might not hold. The expression at 822.54 might not evaluate to true."} vp#144 >= 0;
          assert {:msg "  784.6: The precondition at 822.11 might not hold. The expression at 822.64 might not evaluate to true."} vop#145 >= 0;
          if (!(custp#146 == null)) {
            assert {:msg "  784.6: The precondition at 822.11 might not hold. The expression at 823.41 might not evaluate to true."} !(Heap[custp#146, FactorialCont.q] == null);
            assert {:msg "  784.6: The precondition at 822.11 might not hold. The expression at 823.120 might not evaluate to true."} vop#145 == Heap[custp#146, FactorialCont.vo];
          } else {
          }
          assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.11 might not be positive."} Fractions(100) > 0;
          assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.11 for FactorialCont.v."} (Fractions(100) <= exhaleMask#_1326[this#143, FactorialCont.v][perm$R]) && ((Fractions(100) == exhaleMask#_1326[this#143, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1326[this#143, FactorialCont.v][perm$N]));
          exhaleMask#_1326[this#143, FactorialCont.v] := exhaleMask#_1326[this#143, FactorialCont.v][perm$R := exhaleMask#_1326[this#143, FactorialCont.v][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1326);
          assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.20 might not be positive."} Fractions(100) > 0;
          assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.20 for FactorialCont.vo."} (Fractions(100) <= exhaleMask#_1326[this#143, FactorialCont.vo][perm$R]) && ((Fractions(100) == exhaleMask#_1326[this#143, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1326[this#143, FactorialCont.vo][perm$N]));
          exhaleMask#_1326[this#143, FactorialCont.vo] := exhaleMask#_1326[this#143, FactorialCont.vo][perm$R := exhaleMask#_1326[this#143, FactorialCont.vo][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1326);
          assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.31 might not be positive."} Fractions(100) > 0;
          assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.31 for FactorialCont.cust."} (Fractions(100) <= exhaleMask#_1326[this#143, FactorialCont.cust][perm$R]) && ((Fractions(100) == exhaleMask#_1326[this#143, FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1326[this#143, FactorialCont.cust][perm$N]));
          exhaleMask#_1326[this#143, FactorialCont.cust] := exhaleMask#_1326[this#143, FactorialCont.cust][perm$R := exhaleMask#_1326[this#143, FactorialCont.cust][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1326);
          assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.44 might not be positive."} Fractions(100) > 0;
          assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.44 for FactorialCont.q."} (Fractions(100) <= exhaleMask#_1326[this#143, FactorialCont.q][perm$R]) && ((Fractions(100) == exhaleMask#_1326[this#143, FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1326[this#143, FactorialCont.q][perm$N]));
          exhaleMask#_1326[this#143, FactorialCont.q] := exhaleMask#_1326[this#143, FactorialCont.q][perm$R := exhaleMask#_1326[this#143, FactorialCont.q][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1326);
          if (!(custp#146 == null)) {
            assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.21 might not be positive."} monitorK > 0;
            assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.21 for FactorialCont.q."} (monitorK <= exhaleMask#_1326[custp#146, FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1326[custp#146, FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1326[custp#146, FactorialCont.q][perm$N]));
            exhaleMask#_1326[custp#146, FactorialCont.q] := exhaleMask#_1326[custp#146, FactorialCont.q][perm$R := exhaleMask#_1326[custp#146, FactorialCont.q][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1326);
            assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.58 might not be positive."} Fractions(100) > 0;
            assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.58 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.valid][perm$N]));
            exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1326);
            assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.75 might not be positive."} Fractions(100) > 0;
            assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.75 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
            exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1326[Heap[custp#146, FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1326);
            assert {:msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.99 might not be positive."} monitorK > 0;
            assert {:msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.99 for FactorialCont.vo."} (monitorK <= exhaleMask#_1326[custp#146, FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1326[custp#146, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1326[custp#146, FactorialCont.vo][perm$N]));
            exhaleMask#_1326[custp#146, FactorialCont.vo] := exhaleMask#_1326[custp#146, FactorialCont.vo][perm$R := exhaleMask#_1326[custp#146, FactorialCont.vo][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1326);
          } else {
          }
          Mask := exhaleMask#_1326;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_1337;
          assume IsGoodInhaleState(inhaleHeap#_1337, Heap, Mask);
          assume this#143 != null;
          Heap[this#143, FactorialCont.v] := inhaleHeap#_1337[this#143, FactorialCont.v];
          assume wf(Heap, Mask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#143, FactorialCont.v] := Mask[this#143, FactorialCont.v][perm$R := Mask[this#143, FactorialCont.v][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[this#143, FactorialCont.v]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume this#143 != null;
          Heap[this#143, FactorialCont.vo] := inhaleHeap#_1337[this#143, FactorialCont.vo];
          assume wf(Heap, Mask);
          assume true;
          assume Fractions(50) > 0;
          Mask[this#143, FactorialCont.vo] := Mask[this#143, FactorialCont.vo][perm$R := Mask[this#143, FactorialCont.vo][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[this#143, FactorialCont.vo]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume this#143 != null;
          Heap[this#143, FactorialCont.cust] := inhaleHeap#_1337[this#143, FactorialCont.cust];
          assume wf(Heap, Mask);
          assume (Heap[this#143, FactorialCont.cust] == null) || (dtype(Heap[this#143, FactorialCont.cust]) == FactorialCont#t);
          assume Fractions(50) > 0;
          Mask[this#143, FactorialCont.cust] := Mask[this#143, FactorialCont.cust][perm$R := Mask[this#143, FactorialCont.cust][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[this#143, FactorialCont.cust]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume this#143 != null;
          Heap[this#143, FactorialCont.q] := inhaleHeap#_1337[this#143, FactorialCont.q];
          assume wf(Heap, Mask);
          assume (Heap[this#143, FactorialCont.q] == null) || (dtype(Heap[this#143, FactorialCont.q]) == FactorialContChannel#t);
          assume Fractions(50) > 0;
          Mask[this#143, FactorialCont.q] := Mask[this#143, FactorialCont.q][perm$R := Mask[this#143, FactorialCont.q][perm$R] + Fractions(50)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[this#143, FactorialCont.q]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume !(Heap[this#143, FactorialCont.q] == null);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.valid] == Heap;
          assume Fractions(100) > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.valid] == Heap;
          assume Fractions(100) > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState] == Heap;
          assume Fractions(100) > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.initImpState]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState] == Heap;
          assume Fractions(100) > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.initExpState]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.imp];
          assume wf(Heap, Mask);
          assume (Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
          assume monitorK > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.imp]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] != null;
          Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
          assume wf(Heap, Mask);
          assume (Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
          assume monitorK > 0;
          Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.imp];
          assume wf(Heap, Mask);
          assume (Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
          assume monitorK > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.imp]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp] != null;
          Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
          assume wf(Heap, Mask);
          assume (Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
          assume monitorK > 0;
          Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume !(Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
          assume Heap[this#143, FactorialCont.q] != null;
          Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.exp];
          assume wf(Heap, Mask);
          assume (Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
          assume monitorK > 0;
          Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[this#143, FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.q], FactorialContChannel.exp]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp] != null;
          Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
          assume wf(Heap, Mask);
          assume (Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
          assume monitorK > 0;
          Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1337, Mask);
          assume Heap[this#143, FactorialCont.v] >= 0;
          assume Heap[this#143, FactorialCont.vo] >= 0;
          assume vp#144 == Heap[this#143, FactorialCont.v];
          assume vop#145 == Heap[this#143, FactorialCont.vo];
          if (!(Heap[this#143, FactorialCont.cust] == null)) {
            assume Heap[this#143, FactorialCont.cust] != null;
            Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q] := inhaleHeap#_1337[Heap[this#143, FactorialCont.cust], FactorialCont.q];
            assume wf(Heap, Mask);
            assume (Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q] == null) || (dtype(Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q]) == FactorialContChannel#t);
            assume monitorK > 0;
            Mask[Heap[this#143, FactorialCont.cust], FactorialCont.q] := Mask[Heap[this#143, FactorialCont.cust], FactorialCont.q][perm$R := Mask[Heap[this#143, FactorialCont.cust], FactorialCont.q][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.cust], FactorialCont.q]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1337, Mask);
            assume !(Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q] == null);
            assume Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q] != null;
            Heap[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] == Heap;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1337, Mask);
            assume Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q] != null;
            Heap[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState];
            assume wf(Heap, Mask);
            assume inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] == Heap;
            assume Fractions(100) > 0;
            Mask[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1337[Heap[Heap[this#143, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1337, Mask);
            assume Heap[this#143, FactorialCont.cust] != null;
            Heap[Heap[this#143, FactorialCont.cust], FactorialCont.vo] := inhaleHeap#_1337[Heap[this#143, FactorialCont.cust], FactorialCont.vo];
            assume wf(Heap, Mask);
            assume true;
            assume monitorK > 0;
            Mask[Heap[this#143, FactorialCont.cust], FactorialCont.vo] := Mask[Heap[this#143, FactorialCont.cust], FactorialCont.vo][perm$R := Mask[Heap[this#143, FactorialCont.cust], FactorialCont.vo][perm$R] + monitorK];
            assume IsGoodMask(Mask);
            assume IsGoodState(inhaleHeap#_1337[Heap[this#143, FactorialCont.cust], FactorialCont.vo]);
            assume wf(Heap, Mask);
            assume wf(inhaleHeap#_1337, Mask);
            assume Heap[Heap[this#143, FactorialCont.cust], FactorialCont.vo] == Heap[this#143, FactorialCont.vo];
          } else {
          }
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          assume (0 < asyncMethodCallK#_1344) && ((1000 * asyncMethodCallK#_1344) < Fractions(1)) && ((1000 * asyncMethodCallK#_1344) < whileK#_1176);
          // call act
          preCallHeap#_1340 := Heap;
          preCallMask#_1341 := Mask;
          preCallCredits#_1342 := Credits;
          assert {:msg "  785.6: The target of the method call might be null."} cont#75 != null;
          this#147 := cont#75;
          argsSeq#_1343[0] := this#147;
          // begin exhale (precondition)
          exhaleMask#_1345 := Mask;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.54 might not evaluate to true."} !(Heap[this#147, FactorialCont.q] == null);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.137 might not evaluate to true."} !(Heap[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.158 might not evaluate to true."} Heap[this#147, FactorialCont.v] >= 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.166 might not evaluate to true."} Heap[this#147, FactorialCont.vo] >= 0;
          if (!(Heap[this#147, FactorialCont.cust] == null)) {
            assert {:msg "  785.6: The precondition at 840.11 might not hold. The expression at 840.65 might not evaluate to true."} !(Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q] == null);
            assert {:msg "  785.6: The precondition at 840.11 might not hold. The expression at 840.140 might not evaluate to true."} Heap[Heap[this#147, FactorialCont.cust], FactorialCont.vo] == Heap[this#147, FactorialCont.vo];
          } else {
          }
          Credits[Heap[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] - 1;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.11 might not be positive."} monitorK > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.11 for FactorialCont.q."} (monitorK <= exhaleMask#_1345[this#147, FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1345[this#147, FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1345[this#147, FactorialCont.q][perm$N]));
          exhaleMask#_1345[this#147, FactorialCont.q] := exhaleMask#_1345[this#147, FactorialCont.q][perm$R := exhaleMask#_1345[this#147, FactorialCont.q][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.25 might not be positive."} monitorK > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.25 for FactorialCont.v."} (monitorK <= exhaleMask#_1345[this#147, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1345[this#147, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1345[this#147, FactorialCont.v][perm$N]));
          exhaleMask#_1345[this#147, FactorialCont.v] := exhaleMask#_1345[this#147, FactorialCont.v][perm$R := exhaleMask#_1345[this#147, FactorialCont.v][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.39 might not be positive."} monitorK > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.39 for FactorialCont.vo."} (monitorK <= exhaleMask#_1345[this#147, FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1345[this#147, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1345[this#147, FactorialCont.vo][perm$N]));
          exhaleMask#_1345[this#147, FactorialCont.vo] := exhaleMask#_1345[this#147, FactorialCont.vo][perm$R := exhaleMask#_1345[this#147, FactorialCont.vo][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.66 might not be positive."} Fractions(100) > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.66 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.valid][perm$N]));
          exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.77 might not be positive."} Fractions(100) > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.77 for FactorialContChannel.initImpState."} (Fractions(100) <= exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.initImpState][perm$N]));
          exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.initImpState] := exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.initImpState][perm$R := exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.initImpState][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.95 might not be positive."} monitorK > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.95 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.imp][perm$N]));
          exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.imp] := exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.imp][perm$R := exhaleMask#_1345[Heap[this#147, FactorialCont.q], FactorialContChannel.imp][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.113 might not be positive."} monitorK > 0;
          assert {:msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.113 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
          exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          assert {:msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.11 might not be positive."} monitorK > 0;
          assert {:msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.11 for FactorialCont.cust."} (monitorK <= exhaleMask#_1345[this#147, FactorialCont.cust][perm$R]) && ((monitorK == exhaleMask#_1345[this#147, FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1345[this#147, FactorialCont.cust][perm$N]));
          exhaleMask#_1345[this#147, FactorialCont.cust] := exhaleMask#_1345[this#147, FactorialCont.cust][perm$R := exhaleMask#_1345[this#147, FactorialCont.cust][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1345);
          if (!(Heap[this#147, FactorialCont.cust] == null)) {
            assert {:msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.46 might not be positive."} monitorK > 0;
            assert {:msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.46 for FactorialCont.q."} (monitorK <= exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.q][perm$N]));
            exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.q] := exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.q][perm$R := exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.q][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1345);
            assert {:msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.81 might not be positive."} Fractions(100) > 0;
            assert {:msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.81 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$N]));
            exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1345);
            assert {:msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.97 might not be positive."} Fractions(100) > 0;
            assert {:msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.97 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
            exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1345[Heap[Heap[this#147, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1345);
            assert {:msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.120 might not be positive."} monitorK > 0;
            assert {:msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.120 for FactorialCont.vo."} (monitorK <= exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.vo][perm$N]));
            exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.vo] := exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.vo][perm$R := exhaleMask#_1345[Heap[this#147, FactorialCont.cust], FactorialCont.vo][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1345);
          } else {
          }
          Mask := exhaleMask#_1345;
          assume wf(Heap, Mask);
          // end exhale
          havoc token#_1338;
          assume token#_1338 != null;
          assume Heap[token#_1338, joinable] == 0;
          assume Mask[token#_1338, joinable][perm$N] == 0;
          assume Mask[token#_1338, joinable][perm$R] == 0;
          Mask[token#_1338, joinable] := Mask[token#_1338, joinable][perm$R := Mask[token#_1338, joinable][perm$R] + Fractions(100)];
          havoc asyncstate#_1339;
          assume asyncstate#_1339 != 0;
          Heap[token#_1338, joinable] := asyncstate#_1339;
          Heap[token#_1338, forkK] := asyncMethodCallK#_1344;
          assume Call$Heap(asyncstate#_1339) == preCallHeap#_1340;
          assume Call$Mask(asyncstate#_1339) == preCallMask#_1341;
          assume Call$Credits(asyncstate#_1339) == preCallCredits#_1342;
          assume Call$Args(asyncstate#_1339) == argsSeq#_1343;
          assume wf(Heap, Mask);
          // local var m
          // assigment to m
          // new
          havoc nw#_1358;
          assume (nw#_1358 != null) && (dtype(nw#_1358) == Message#t);
          assume (forall<T#_16> f: Field (T#_16) :: (Mask[nw#_1358, f][perm$R] == 0) && (Mask[nw#_1358, f][perm$N] == 0));
          assume Heap[nw#_1358, mu] == $LockBottom;
          assume Heap[nw#_1358, held] <= 0;
          assume Heap[nw#_1358, rdheld] == false;
          Mask[nw#_1358, Message.type] := Mask[nw#_1358, Message.type][perm$R := Mask[nw#_1358, Message.type][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.sender1] := Mask[nw#_1358, Message.sender1][perm$R := Mask[nw#_1358, Message.sender1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.sender3] := Mask[nw#_1358, Message.sender3][perm$R := Mask[nw#_1358, Message.sender3][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.sender2] := Mask[nw#_1358, Message.sender2][perm$R := Mask[nw#_1358, Message.sender2][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.sender4] := Mask[nw#_1358, Message.sender4][perm$R := Mask[nw#_1358, Message.sender4][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.receiver1] := Mask[nw#_1358, Message.receiver1][perm$R := Mask[nw#_1358, Message.receiver1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.receiver2] := Mask[nw#_1358, Message.receiver2][perm$R := Mask[nw#_1358, Message.receiver2][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.receiver3] := Mask[nw#_1358, Message.receiver3][perm$R := Mask[nw#_1358, Message.receiver3][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.receiver4] := Mask[nw#_1358, Message.receiver4][perm$R := Mask[nw#_1358, Message.receiver4][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.v1] := Mask[nw#_1358, Message.v1][perm$R := Mask[nw#_1358, Message.v1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.vo1] := Mask[nw#_1358, Message.vo1][perm$R := Mask[nw#_1358, Message.vo1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.cust1] := Mask[nw#_1358, Message.cust1][perm$R := Mask[nw#_1358, Message.cust1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.vr1] := Mask[nw#_1358, Message.vr1][perm$R := Mask[nw#_1358, Message.vr1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.old1] := Mask[nw#_1358, Message.old1][perm$R := Mask[nw#_1358, Message.old1][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.vr2] := Mask[nw#_1358, Message.vr2][perm$R := Mask[nw#_1358, Message.vr2][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.old2] := Mask[nw#_1358, Message.old2][perm$R := Mask[nw#_1358, Message.old2][perm$R] + Fractions(100)];
          Mask[nw#_1358, Message.vr3] := Mask[nw#_1358, Message.vr3][perm$R := Mask[nw#_1358, Message.vr3][perm$R] + Fractions(100)];
          Mask[nw#_1358, mu] := Mask[nw#_1358, mu][perm$R := Mask[nw#_1358, mu][perm$R] + Fractions(100)];
          m#77 := nw#_1358;
          // update field sender1
          assert {:msg "  788.6: Location might not be writable"} CanWrite(Mask, m#77, Message.sender1);
          assert {:msg "  788.17: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  788.17: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.sender1);
          Heap[m#77, Message.sender1] := Heap[current#67, Message.sender1];
          assume wf(Heap, Mask);
          assume (0 < methodCallK#_1362) && ((1000 * methodCallK#_1362) < Fractions(1)) && ((1000 * methodCallK#_1362) < whileK#_1176);
          // call setValue
          callHeap#_1359 := Heap;
          callMask#_1360 := Mask;
          callCredits#_1361 := Credits;
          assert {:msg "  789.6: The target of the method call might be null."} m#77 != null;
          assert {:msg "  789.22: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  789.22: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.v1);
          assert {:msg "  789.35: Receiver might be null."} true ==> (current#67 != null);
          assert {:msg "  789.35: Location might not be readable."} true ==> CanRead(Mask, current#67, Message.vo1);
          this#148 := m#77;
          v#149 := Heap[current#67, Message.v1] - 1;
          vo#150 := Heap[current#67, Message.vo1];
          cust#151 := cont#75;
          receiver#152 := this;
          // begin exhale (precondition)
          exhaleMask#_1363 := Mask;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 661.3 might not evaluate to true."} !(Heap[this#148, Message.sender1] == null);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 661.42 might not evaluate to true."} !(Heap[Heap[this#148, Message.sender1], Future.q] == null);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 662.48 might not evaluate to true."} v#149 >= 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 662.56 might not evaluate to true."} vo#150 >= 0;
          if (cust#151 == null) {
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 663.19 might not evaluate to true."} v#149 == vo#150;
          } else {
          }
          if (!(cust#151 == null)) {
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 664.23 might not evaluate to true."} !(Heap[cust#151, FactorialCont.q] == null);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 665.55 might not evaluate to true."} !(Heap[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 666.23 might not evaluate to true."} v#149 == (Heap[cust#151, FactorialCont.v] - 1);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The expression at 666.38 might not evaluate to true."} vo#150 == Heap[cust#151, FactorialCont.vo];
          } else {
          }
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.11 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.11 for Message.type."} (Fractions(100) <= exhaleMask#_1363[this#148, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1363[this#148, Message.type][perm$R]) ==> (0 <= exhaleMask#_1363[this#148, Message.type][perm$N]));
          exhaleMask#_1363[this#148, Message.type] := exhaleMask#_1363[this#148, Message.type][perm$R := exhaleMask#_1363[this#148, Message.type][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.24 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.24 for Message.sender1."} (Fractions(100) <= exhaleMask#_1363[this#148, Message.sender1][perm$R]) && ((Fractions(100) == exhaleMask#_1363[this#148, Message.sender1][perm$R]) ==> (0 <= exhaleMask#_1363[this#148, Message.sender1][perm$N]));
          exhaleMask#_1363[this#148, Message.sender1] := exhaleMask#_1363[this#148, Message.sender1][perm$R := exhaleMask#_1363[this#148, Message.sender1][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.40 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.40 for Message.receiver1."} (Fractions(100) <= exhaleMask#_1363[this#148, Message.receiver1][perm$R]) && ((Fractions(100) == exhaleMask#_1363[this#148, Message.receiver1][perm$R]) ==> (0 <= exhaleMask#_1363[this#148, Message.receiver1][perm$N]));
          exhaleMask#_1363[this#148, Message.receiver1] := exhaleMask#_1363[this#148, Message.receiver1][perm$R := exhaleMask#_1363[this#148, Message.receiver1][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.3 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.3 for Message.v1."} (Fractions(100) <= exhaleMask#_1363[this#148, Message.v1][perm$R]) && ((Fractions(100) == exhaleMask#_1363[this#148, Message.v1][perm$R]) ==> (0 <= exhaleMask#_1363[this#148, Message.v1][perm$N]));
          exhaleMask#_1363[this#148, Message.v1] := exhaleMask#_1363[this#148, Message.v1][perm$R := exhaleMask#_1363[this#148, Message.v1][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.14 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.14 for Message.vo1."} (Fractions(100) <= exhaleMask#_1363[this#148, Message.vo1][perm$R]) && ((Fractions(100) == exhaleMask#_1363[this#148, Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1363[this#148, Message.vo1][perm$N]));
          exhaleMask#_1363[this#148, Message.vo1] := exhaleMask#_1363[this#148, Message.vo1][perm$R := exhaleMask#_1363[this#148, Message.vo1][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.26 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.26 for Message.cust1."} (Fractions(100) <= exhaleMask#_1363[this#148, Message.cust1][perm$R]) && ((Fractions(100) == exhaleMask#_1363[this#148, Message.cust1][perm$R]) ==> (0 <= exhaleMask#_1363[this#148, Message.cust1][perm$N]));
          exhaleMask#_1363[this#148, Message.cust1] := exhaleMask#_1363[this#148, Message.cust1][perm$R := exhaleMask#_1363[this#148, Message.cust1][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 661.20 might not be positive."} monitorK > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 661.20 for Future.q."} (monitorK <= exhaleMask#_1363[Heap[this#148, Message.sender1], Future.q][perm$R]) && ((monitorK == exhaleMask#_1363[Heap[this#148, Message.sender1], Future.q][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[this#148, Message.sender1], Future.q][perm$N]));
          exhaleMask#_1363[Heap[this#148, Message.sender1], Future.q] := exhaleMask#_1363[Heap[this#148, Message.sender1], Future.q][perm$R := exhaleMask#_1363[Heap[this#148, Message.sender1], Future.q][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 662.3 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 662.3 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.valid][perm$N]));
          exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.valid] := exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 662.22 might not be positive."} Fractions(100) > 0;
          assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 662.22 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.initExpState][perm$N]));
          exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.initExpState] := exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1363[Heap[Heap[this#148, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1363);
          if (cust#151 == null) {
          } else {
          }
          if (!(cust#151 == null)) {
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.4 might not be positive."} monitorK > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.4 for FactorialCont.q."} (monitorK <= exhaleMask#_1363[cust#151, FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1363[cust#151, FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1363[cust#151, FactorialCont.q][perm$N]));
            exhaleMask#_1363[cust#151, FactorialCont.q] := exhaleMask#_1363[cust#151, FactorialCont.q][perm$R := exhaleMask#_1363[cust#151, FactorialCont.q][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.39 might not be positive."} Fractions(100) > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.39 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.valid][perm$N]));
            exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.55 might not be positive."} Fractions(100) > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.55 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
            exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.3 might not be positive."} monitorK > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.3 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp][perm$N]));
            exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp] := exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp][perm$R := exhaleMask#_1363[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.26 might not be positive."} monitorK > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.26 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_1363[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1363[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1363[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
            exhaleMask#_1363[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_1363[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1363[Heap[Heap[cust#151, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.81 might not be positive."} monitorK > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.81 for FactorialCont.v."} (monitorK <= exhaleMask#_1363[cust#151, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1363[cust#151, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1363[cust#151, FactorialCont.v][perm$N]));
            exhaleMask#_1363[cust#151, FactorialCont.v] := exhaleMask#_1363[cust#151, FactorialCont.v][perm$R := exhaleMask#_1363[cust#151, FactorialCont.v][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
            assert {:msg "  789.6: The precondition at 659.11 might not hold. The permission at 666.3 might not be positive."} monitorK > 0;
            assert {:msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 666.3 for FactorialCont.vo."} (monitorK <= exhaleMask#_1363[cust#151, FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1363[cust#151, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1363[cust#151, FactorialCont.vo][perm$N]));
            exhaleMask#_1363[cust#151, FactorialCont.vo] := exhaleMask#_1363[cust#151, FactorialCont.vo][perm$R := exhaleMask#_1363[cust#151, FactorialCont.vo][perm$R] - monitorK];
            assume IsGoodMask(Mask);
            assume wf(Heap, Mask);
            assume wf(Heap, exhaleMask#_1363);
          } else {
          }
          Mask := exhaleMask#_1363;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_1382;
          assume IsGoodInhaleState(inhaleHeap#_1382, Heap, Mask);
          assume this#148 != null;
          Heap[this#148, Message.invValue] := inhaleHeap#_1382[this#148, Message.invValue];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1382[this#148, Message.invValue] == Heap;
          assume Fractions(100) > 0;
          Mask[this#148, Message.invValue] := Mask[this#148, Message.invValue][perm$R := Mask[this#148, Message.invValue][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1382[this#148, Message.invValue]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1382, Mask);
          assume this#148 != null;
          Heap[this#148, Message.type] := inhaleHeap#_1382[this#148, Message.type];
          assume wf(Heap, Mask);
          assume true;
          assume monitorK > 0;
          Mask[this#148, Message.type] := Mask[this#148, Message.type][perm$R := Mask[this#148, Message.type][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1382[this#148, Message.type]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1382, Mask);
          assume this#148 != null;
          Heap[this#148, Message.type] := inhaleHeap#_1382[this#148, Message.type];
          assume wf(Heap, Mask);
          assume true;
          assume monitorK > 0;
          Mask[this#148, Message.type] := Mask[this#148, Message.type][perm$R := Mask[this#148, Message.type][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1382[this#148, Message.type]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1382, Mask);
          assume Heap[this#148, Message.type] == 1;
          assume this#148 != null;
          Heap[this#148, Message.vo1] := inhaleHeap#_1382[this#148, Message.vo1];
          assume wf(Heap, Mask);
          assume true;
          assume monitorK > 0;
          Mask[this#148, Message.vo1] := Mask[this#148, Message.vo1][perm$R := Mask[this#148, Message.vo1][perm$R] + monitorK];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1382[this#148, Message.vo1]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1382, Mask);
          assume Heap[this#148, Message.vo1] >= 0;
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          assume (0 < methodCallK#_1386) && ((1000 * methodCallK#_1386) < Fractions(1)) && ((1000 * methodCallK#_1386) < whileK#_1176);
          // call sendValue
          callHeap#_1383 := Heap;
          callMask#_1384 := Mask;
          callCredits#_1385 := Credits;
          assert {:msg "  790.11: Receiver might be null."} true ==> (this != null);
          assert {:msg "  790.11: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
          assert {:msg "  790.11: Receiver might be null."} true ==> (Heap[this, FactorialActor.q] != null);
          assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialActor.q], FactorialActorChannel.exp);
          assert {:msg "  790.6: The target of the method call might be null."} Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
          this#153 := Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
          m#154 := m#77;
          // begin exhale (precondition)
          exhaleMask#_1387 := Mask;
          assert {:msg "  790.6: The precondition at 34.11 might not hold. The expression at 34.63 might not evaluate to true."} Heap[m#154, Message.type] == 1;
          assert {:msg "  790.6: The precondition at 36.11 might not hold. The expression at 36.11 might not evaluate to true."} Heap[this#153, FactorialActorChannelExpEP.state] == 0;
          assert {:msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.11 might not be positive."} Fractions(100) > 0;
          assert {:msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.11 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1387[this#153, FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1387[this#153, FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1387[this#153, FactorialActorChannelExpEP.state][perm$N]));
          exhaleMask#_1387[this#153, FactorialActorChannelExpEP.state] := exhaleMask#_1387[this#153, FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1387[this#153, FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1387);
          assert {:msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.25 might not be positive."} monitorK > 0;
          assert {:msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.25 for Message.type."} (monitorK <= exhaleMask#_1387[m#154, Message.type][perm$R]) && ((monitorK == exhaleMask#_1387[m#154, Message.type][perm$R]) ==> (0 <= exhaleMask#_1387[m#154, Message.type][perm$N]));
          exhaleMask#_1387[m#154, Message.type] := exhaleMask#_1387[m#154, Message.type][perm$R := exhaleMask#_1387[m#154, Message.type][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1387);
          assert {:msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.44 might not be positive."} monitorK > 0;
          assert {:msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.44 for Message.type."} (monitorK <= exhaleMask#_1387[m#154, Message.type][perm$R]) && ((monitorK == exhaleMask#_1387[m#154, Message.type][perm$R]) ==> (0 <= exhaleMask#_1387[m#154, Message.type][perm$N]));
          exhaleMask#_1387[m#154, Message.type] := exhaleMask#_1387[m#154, Message.type][perm$R := exhaleMask#_1387[m#154, Message.type][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1387);
          assert {:msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.76 might not be positive."} Fractions(100) > 0;
          assert {:msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.76 for Message.invValue."} (Fractions(100) <= exhaleMask#_1387[m#154, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_1387[m#154, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_1387[m#154, Message.invValue][perm$N]));
          exhaleMask#_1387[m#154, Message.invValue] := exhaleMask#_1387[m#154, Message.invValue][perm$R := exhaleMask#_1387[m#154, Message.invValue][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1387);
          assert {:msg "  790.6: The precondition at 35.11 might not hold. The permission at 35.11 might not be positive."} Fractions(100) > 0;
          assert {:msg "  790.6: The precondition at 35.11 might not hold. Insufficient fraction at 35.11 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1387[this#153, FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1387[this#153, FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1387[this#153, FactorialActorChannelExpEP.valid][perm$N]));
          exhaleMask#_1387[this#153, FactorialActorChannelExpEP.valid] := exhaleMask#_1387[this#153, FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1387[this#153, FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1387);
          Mask := exhaleMask#_1387;
          assume wf(Heap, Mask);
          // end exhale
          // inhale (postcondition)
          havoc inhaleHeap#_1395;
          assume IsGoodInhaleState(inhaleHeap#_1395, Heap, Mask);
          assume this#153 != null;
          Heap[this#153, FactorialActorChannelExpEP.state] := inhaleHeap#_1395[this#153, FactorialActorChannelExpEP.state];
          assume wf(Heap, Mask);
          assume true;
          assume Fractions(100) > 0;
          Mask[this#153, FactorialActorChannelExpEP.state] := Mask[this#153, FactorialActorChannelExpEP.state][perm$R := Mask[this#153, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1395[this#153, FactorialActorChannelExpEP.state]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1395, Mask);
          assume this#153 != null;
          Heap[this#153, FactorialActorChannelExpEP.valid] := inhaleHeap#_1395[this#153, FactorialActorChannelExpEP.valid];
          assume wf(Heap, Mask);
          assume inhaleHeap#_1395[this#153, FactorialActorChannelExpEP.valid] == Heap;
          assume Fractions(100) > 0;
          Mask[this#153, FactorialActorChannelExpEP.valid] := Mask[this#153, FactorialActorChannelExpEP.valid][perm$R := Mask[this#153, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
          assume IsGoodMask(Mask);
          assume IsGoodState(inhaleHeap#_1395[this#153, FactorialActorChannelExpEP.valid]);
          assume wf(Heap, Mask);
          assume wf(inhaleHeap#_1395, Mask);
          if (callHeap#_1383[this#153, FactorialActorChannelExpEP.state] == 0) {
            assume Heap[this#153, FactorialActorChannelExpEP.state] == 0;
          } else {
          }
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          // end inhale
          // local var r
          // assigment to r
          // new
          havoc nw#_1396;
          assume (nw#_1396 != null) && (dtype(nw#_1396) == Message#t);
          assume (forall<T#_17> f: Field (T#_17) :: (Mask[nw#_1396, f][perm$R] == 0) && (Mask[nw#_1396, f][perm$N] == 0));
          assume Heap[nw#_1396, mu] == $LockBottom;
          assume Heap[nw#_1396, held] <= 0;
          assume Heap[nw#_1396, rdheld] == false;
          Mask[nw#_1396, Message.type] := Mask[nw#_1396, Message.type][perm$R := Mask[nw#_1396, Message.type][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.sender1] := Mask[nw#_1396, Message.sender1][perm$R := Mask[nw#_1396, Message.sender1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.sender3] := Mask[nw#_1396, Message.sender3][perm$R := Mask[nw#_1396, Message.sender3][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.sender2] := Mask[nw#_1396, Message.sender2][perm$R := Mask[nw#_1396, Message.sender2][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.sender4] := Mask[nw#_1396, Message.sender4][perm$R := Mask[nw#_1396, Message.sender4][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.receiver1] := Mask[nw#_1396, Message.receiver1][perm$R := Mask[nw#_1396, Message.receiver1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.receiver2] := Mask[nw#_1396, Message.receiver2][perm$R := Mask[nw#_1396, Message.receiver2][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.receiver3] := Mask[nw#_1396, Message.receiver3][perm$R := Mask[nw#_1396, Message.receiver3][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.receiver4] := Mask[nw#_1396, Message.receiver4][perm$R := Mask[nw#_1396, Message.receiver4][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.v1] := Mask[nw#_1396, Message.v1][perm$R := Mask[nw#_1396, Message.v1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.vo1] := Mask[nw#_1396, Message.vo1][perm$R := Mask[nw#_1396, Message.vo1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.cust1] := Mask[nw#_1396, Message.cust1][perm$R := Mask[nw#_1396, Message.cust1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.vr1] := Mask[nw#_1396, Message.vr1][perm$R := Mask[nw#_1396, Message.vr1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.old1] := Mask[nw#_1396, Message.old1][perm$R := Mask[nw#_1396, Message.old1][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.vr2] := Mask[nw#_1396, Message.vr2][perm$R := Mask[nw#_1396, Message.vr2][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.old2] := Mask[nw#_1396, Message.old2][perm$R := Mask[nw#_1396, Message.old2][perm$R] + Fractions(100)];
          Mask[nw#_1396, Message.vr3] := Mask[nw#_1396, Message.vr3][perm$R := Mask[nw#_1396, Message.vr3][perm$R] + Fractions(100)];
          Mask[nw#_1396, mu] := Mask[nw#_1396, mu][perm$R := Mask[nw#_1396, mu][perm$R] + Fractions(100)];
          r#79 := nw#_1396;
          // update field type
          assert {:msg "  793.6: Location might not be writable"} CanWrite(Mask, r#79, Message.type);
          Heap[r#79, Message.type] := 4;
          assume wf(Heap, Mask);
          // assert
          Heap#_1400 := Heap;
          Mask#_1401 := Mask;
          Credits#_1402 := Credits;
          // begin exhale (assert)
          exhaleMask#_1403 := Mask#_1401;
          assert {:msg "  794.13: Receiver might be null."} true ==> (r#79 != null);
          assert {:msg "  794.13: Location might not be readable."} true ==> CanRead(Mask#_1401, r#79, Message.vr3);
          assert {:msg "  794.32: Receiver might be null."} true ==> (m#77 != null);
          assert {:msg "  794.32: Location might not be readable."} true ==> CanRead(Mask#_1401, m#77, Message.vo1);
          assert {:msg "  794.20: Receiver might be null."} true ==> (m#77 != null);
          // check precondition of call
          assume (0 < funcappK#_1410) && ((1000 * funcappK#_1410) < Fractions(1));
          assume true;
          Heap#_1407 := Heap#_1400;
          Mask#_1408 := Mask#_1401;
          Credits#_1409 := Credits#_1402;
          // begin exhale (function call)
          exhaleMask#_1411 := Mask#_1408;
          assert {:msg "  794.20: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1407[m#77, Message.vo1] >= 0;
          Mask#_1408 := exhaleMask#_1411;
          assume wf(Heap#_1407, Mask#_1408);
          // end exhale
          if (Heap#_1400[r#79, Message.vr3] == #Message.factorial(Heap#_1400, Mask#_1401, m#77, Heap#_1400[m#77, Message.vo1])) {
            assert {:msg "  794.43: Receiver might be null."} true ==> (r#79 != null);
            assert {:msg "  794.43: Location might not be readable."} true ==> CanRead(Mask#_1401, r#79, Message.vr3);
            assert {:msg "  794.62: Receiver might be null."} true ==> (current#67 != null);
            assert {:msg "  794.62: Location might not be readable."} true ==> CanRead(Mask#_1401, current#67, Message.vo1);
            assert {:msg "  794.50: Receiver might be null."} true ==> (m#77 != null);
            // check precondition of call
            assume (0 < funcappK#_1418) && ((1000 * funcappK#_1418) < Fractions(1));
            assume true;
            Heap#_1415 := Heap#_1400;
            Mask#_1416 := Mask#_1401;
            Credits#_1417 := Credits#_1402;
            // begin exhale (function call)
            exhaleMask#_1419 := Mask#_1416;
            assert {:msg "  794.50: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1415[current#67, Message.vo1] >= 0;
            Mask#_1416 := exhaleMask#_1419;
            assume wf(Heap#_1415, Mask#_1416);
            // end exhale
            assert {:msg "  794.6: Assertion might not hold. The expression at 794.43 might not evaluate to true."} Heap#_1400[r#79, Message.vr3] == #Message.factorial(Heap#_1400, Mask#_1401, m#77, Heap#_1400[current#67, Message.vo1]);
          } else {
          }
          if (Heap#_1400[r#79, Message.vr3] == #Message.factorial(Heap#_1400, Mask#_1401, m#77, Heap#_1400[m#77, Message.vo1])) {
          } else {
          }
          Mask#_1401 := exhaleMask#_1403;
          assume wf(Heap#_1400, Mask#_1401);
          // end exhale
        }
      } else {
      }
      // begin exhale (loop invariant, maintained)
      exhaleMask#_1420 := Mask;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The expression at 743.27 might not evaluate to true."} !(Heap[this, FactorialActor.q] == null);
      assert {:msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.13 might not evaluate to true."} Heap[this, FactorialActor.q] == Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
      assert {:msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.28 might not evaluate to true."} !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
      assert {:msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.43 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
      assert {:msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The expression at 745.31 might not evaluate to true."} !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null);
      assert {:msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. The expression at 746.33 might not evaluate to true."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
      assert {:msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. The expression at 747.33 might not evaluate to true."} Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
      Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] - 1;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.13 might not be positive."} monitorK > 0;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.13 for FactorialActor.q."} (monitorK <= exhaleMask#_1420[this, FactorialActor.q][perm$R]) && ((monitorK == exhaleMask#_1420[this, FactorialActor.q][perm$R]) ==> (0 <= exhaleMask#_1420[this, FactorialActor.q][perm$N]));
      exhaleMask#_1420[this, FactorialActor.q] := exhaleMask#_1420[this, FactorialActor.q][perm$R := exhaleMask#_1420[this, FactorialActor.q][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.38 might not be positive."} monitorK > 0;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.38 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$N]));
      exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.56 might not be positive."} monitorK > 0;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.56 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
      exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.80 might not be positive."} monitorK > 0;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.80 for mu."} (monitorK <= exhaleMask#_1420[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) && ((monitorK == exhaleMask#_1420[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$N]));
      exhaleMask#_1420[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := exhaleMask#_1420[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := exhaleMask#_1420[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.107 might not be positive."} monitorK > 0;
      assert {:msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.107 for FactorialActorChannelImpEP.ch."} (monitorK <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$N]));
      exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The permission at 745.13 might not be positive."} monitorK > 0;
      assert {:msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. Insufficient fraction at 745.13 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$N]));
      exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := exhaleMask#_1420[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The permission at 745.46 might not be positive."} Fractions(100) > 0;
      assert {:msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. Insufficient fraction at 745.46 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$N]));
      exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. The permission at 746.13 might not be positive."} Fractions(100) > 0;
      assert {:msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. Insufficient fraction at 746.13 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$N]));
      exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      assert {:msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. The permission at 747.13 might not be positive."} Fractions(100) > 0;
      assert {:msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. Insufficient fraction at 747.13 for FactorialActorChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$N]));
      exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1420[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1420);
      Mask := exhaleMask#_1420;
      assume wf(Heap, Mask);
      // end exhale
      // check lockchange after loop iteration
      assert {:msg "  742.3: The loop might lock/unlock more than the lockchange clause allows."} (forall lk#_1430: ref :: {Heap[lk#_1430, held]} {Heap[lk#_1430, rdheld]} (((0 < Heap[lk#_1430, held]) == (0 < old(Heap)[lk#_1430, held])) && (Heap[lk#_1430, rdheld] == old(Heap)[lk#_1430, rdheld])) || false);
      assert {:msg "  742.3: Loop body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
      assume false;
    } else {
      // assume lockchange after the loop
      assume (forall lk#_1433: ref :: {Heap[lk#_1433, held]} {Heap[lk#_1433, rdheld]} (((0 < Heap[lk#_1433, held]) == (0 < old(Heap)[lk#_1433, held])) && (Heap[lk#_1433, rdheld] == old(Heap)[lk#_1433, rdheld])) || false);
      // inhale (loop invariant, after loop)
      havoc inhaleHeap#_1434;
      assume IsGoodInhaleState(inhaleHeap#_1434, Heap, Mask);
      assume this != null;
      Heap[this, FactorialActor.q] := inhaleHeap#_1434[this, FactorialActor.q];
      assume wf(Heap, Mask);
      assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
      assume monitorK > 0;
      Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[this, FactorialActor.q]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume !(Heap[this, FactorialActor.q] == null);
      assume Heap[this, FactorialActor.q] != null;
      Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1434[Heap[this, FactorialActor.q], FactorialActorChannel.imp];
      assume wf(Heap, Mask);
      assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
      assume monitorK > 0;
      Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[this, FactorialActor.q], FactorialActorChannel.imp]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
      assume wf(Heap, Mask);
      assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
      assume monitorK > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] != null;
      Heap[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := inhaleHeap#_1434[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch], mu]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
      assume wf(Heap, Mask);
      assume (Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
      assume monitorK > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[this, FactorialActor.q] == Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
      assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] == null);
      assume !(Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
      assume Heap[this, FactorialActor.q] != null;
      Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1434[Heap[this, FactorialActor.q], FactorialActorChannel.exp];
      assume wf(Heap, Mask);
      assume (Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
      assume monitorK > 0;
      Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[this, FactorialActor.q], FactorialActorChannel.exp]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume !(Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] == null);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
      assume Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp] != null;
      Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R := Mask[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1434[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1434, Mask);
      assume Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.state] == 0;
      Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] + 1;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      assume !true;
    }
  }
  assert {:msg "  734.2: Method might lock/unlock more than allowed."} (forall lk#_1435: ref :: {Heap[lk#_1435, held]} {Heap[lk#_1435, rdheld]} (((0 < Heap[lk#_1435, held]) == (0 < old(Heap)[lk#_1435, held])) && (Heap[lk#_1435, rdheld] == old(Heap)[lk#_1435, rdheld])) || false);
  assert {:msg "  734.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
function #FactorialActor.getQ(heap: HeapType, mask: MaskType, this: ref) returns ($myresult: ref);
procedure FactorialActor.getQ$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialActor#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var functionK#_1436: int;
  var inhaleHeap#_1437: HeapType;
  var result: ref;
  assume (0 < functionK#_1436) && ((1000 * functionK#_1436) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1437;
  assume IsGoodInhaleState(inhaleHeap#_1437, Heap, Mask);
  assume this != null;
  Heap[this, FactorialActor.q] := inhaleHeap#_1437[this, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialActor.q] == null) || (dtype(Heap[this, FactorialActor.q]) == FactorialActorChannel#t);
  assume functionK#_1436 > 0;
  Mask[this, FactorialActor.q] := Mask[this, FactorialActor.q][perm$R := Mask[this, FactorialActor.q][perm$R] + functionK#_1436];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1437[this, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1437, Mask);
  assert {:msg "  806.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.20: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume !(Heap[this, FactorialActor.q] == null);
  assert {:msg "  806.34: Receiver might be null."} true ==> (this != null);
  assert {:msg "  806.34: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  assume Heap[this, FactorialActor.q] != null;
  Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1437[Heap[this, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1437[Heap[this, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume functionK#_1436 > 0;
  Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this, FactorialActor.q], FactorialActorChannel.valid][perm$R] + functionK#_1436];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1437[Heap[this, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1437, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  assume CurrentModule == module#default;
  assert {:msg "  808.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  808.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialActor.q);
  result := Heap[this, FactorialActor.q];
}
axiom (forall Heap: HeapType, Mask: MaskType, this: ref :: {#FactorialActor.getQ(Heap, Mask, this)} wf(Heap, Mask) && (CurrentModule == module#default) ==> (#FactorialActor.getQ(Heap, Mask, this) == Heap[this, FactorialActor.q]));
function ##FactorialActor.getQ(state: HeapType, this: ref) returns ($myresult: ref);
axiom (forall Heap: HeapType, Mask: MaskType, this: ref :: {#FactorialActor.getQ(Heap, Mask, this)} wf(Heap, Mask) && IsGoodState(combine(nostate, combine(Heap[this, FactorialActor.q], Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid]))) && CanAssumeFunctionDefs ==> (#FactorialActor.getQ(Heap, Mask, this) == ##FactorialActor.getQ(combine(nostate, combine(Heap[this, FactorialActor.q], Heap[Heap[this, FactorialActor.q], FactorialActorChannel.valid])), this)));
const unique FactorialCont#t: TypeName;
procedure FactorialCont$monitorinvariant$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1445: int;
  var h0#_1438: HeapType;
  var m0#_1439: MaskType;
  var c0#_1440: CreditsType;
  var h1#_1441: HeapType;
  var m1#_1442: MaskType;
  var c1#_1443: CreditsType;
  var lk#_1444: ref;
  assume (0 < methodK#_1445) && ((1000 * methodK#_1445) < Fractions(1));
  assume wf(h0#_1438, m0#_1439);
  assume wf(h1#_1441, m1#_1442);
  m1#_1442 := ZeroMask;
  c1#_1443 := ZeroCredits;
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  assert {:msg "  815.1: Monitor invariant is not allowed to contain debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
const unique FactorialCont.q: Field (ref);
axiom NonPredicateField(FactorialCont.q);
const unique FactorialCont.v: Field (int);
axiom NonPredicateField(FactorialCont.v);
const unique FactorialCont.vo: Field (int);
axiom NonPredicateField(FactorialCont.vo);
const unique FactorialCont.cust: Field (ref);
axiom NonPredicateField(FactorialCont.cust);
procedure FactorialCont.init$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialCont#t), vp#80: int where true, vop#81: int where true, custp#82: ref where (custp#82 == null) || (dtype(custp#82) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1446: int;
  var inhaleHeap#_1447: HeapType;
  var inhaleHeap#_1448: HeapType;
  assume (0 < methodK#_1446) && ((1000 * methodK#_1446) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1447;
  assume IsGoodInhaleState(inhaleHeap#_1447, Heap, Mask);
  assume this != null;
  Heap[this, FactorialCont.v] := inhaleHeap#_1447[this, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.v] := Mask[this, FactorialCont.v][perm$R := Mask[this, FactorialCont.v][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1447[this, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1447, Mask);
  assume this != null;
  Heap[this, FactorialCont.vo] := inhaleHeap#_1447[this, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.vo] := Mask[this, FactorialCont.vo][perm$R := Mask[this, FactorialCont.vo][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1447[this, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1447, Mask);
  assume this != null;
  Heap[this, FactorialCont.cust] := inhaleHeap#_1447[this, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.cust] == null) || (dtype(Heap[this, FactorialCont.cust]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.cust] := Mask[this, FactorialCont.cust][perm$R := Mask[this, FactorialCont.cust][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1447[this, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1447, Mask);
  assume this != null;
  Heap[this, FactorialCont.q] := inhaleHeap#_1447[this, FactorialCont.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.q] == null) || (dtype(Heap[this, FactorialCont.q]) == FactorialContChannel#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.q] := Mask[this, FactorialCont.q][perm$R := Mask[this, FactorialCont.q][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1447[this, FactorialCont.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1447, Mask);
  assume vp#80 >= 0;
  assume vop#81 >= 0;
  if (!(custp#82 == null)) {
    assume custp#82 != null;
    Heap[custp#82, FactorialCont.q] := inhaleHeap#_1447[custp#82, FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[custp#82, FactorialCont.q] == null) || (dtype(Heap[custp#82, FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[custp#82, FactorialCont.q] := Mask[custp#82, FactorialCont.q][perm$R := Mask[custp#82, FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1447[custp#82, FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1447, Mask);
    assert {:msg "  823.41: Receiver might be null."} true ==> (custp#82 != null);
    assert {:msg "  823.41: Location might not be readable."} true ==> CanRead(Mask, custp#82, FactorialCont.q);
    assume !(Heap[custp#82, FactorialCont.q] == null);
    assert {:msg "  823.58: Receiver might be null."} true ==> (custp#82 != null);
    assert {:msg "  823.58: Location might not be readable."} true ==> CanRead(Mask, custp#82, FactorialCont.q);
    assert {:msg "  823.58: Receiver might be null."} Heap[custp#82, FactorialCont.q] != null;
    assert {:msg "  823.58: Receiver might be null."} true ==> (custp#82 != null);
    assert {:msg "  823.58: Location might not be readable."} true ==> CanRead(Mask, custp#82, FactorialCont.q);
    assume Heap[custp#82, FactorialCont.q] != null;
    Heap[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1447[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1447[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1447[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1447, Mask);
    assert {:msg "  823.75: Receiver might be null."} true ==> (custp#82 != null);
    assert {:msg "  823.75: Location might not be readable."} true ==> CanRead(Mask, custp#82, FactorialCont.q);
    assert {:msg "  823.75: Receiver might be null."} Heap[custp#82, FactorialCont.q] != null;
    assert {:msg "  823.75: Receiver might be null."} true ==> (custp#82 != null);
    assert {:msg "  823.75: Location might not be readable."} true ==> CanRead(Mask, custp#82, FactorialCont.q);
    assume Heap[custp#82, FactorialCont.q] != null;
    Heap[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1447[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1447[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1447[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1447, Mask);
    assume custp#82 != null;
    Heap[custp#82, FactorialCont.vo] := inhaleHeap#_1447[custp#82, FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[custp#82, FactorialCont.vo] := Mask[custp#82, FactorialCont.vo][perm$R := Mask[custp#82, FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1447[custp#82, FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1447, Mask);
    assert {:msg "  823.125: Receiver might be null."} true ==> (custp#82 != null);
    assert {:msg "  823.125: Location might not be readable."} true ==> CanRead(Mask, custp#82, FactorialCont.vo);
    assume vop#81 == Heap[custp#82, FactorialCont.vo];
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
  // inhale (postcondition)
  havoc inhaleHeap#_1448;
  assume IsGoodInhaleState(inhaleHeap#_1448, Heap, Mask);
  assume this != null;
  Heap[this, FactorialCont.v] := inhaleHeap#_1448[this, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, FactorialCont.v] := Mask[this, FactorialCont.v][perm$R := Mask[this, FactorialCont.v][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[this, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assume this != null;
  Heap[this, FactorialCont.vo] := inhaleHeap#_1448[this, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(50) > 0;
  Mask[this, FactorialCont.vo] := Mask[this, FactorialCont.vo][perm$R := Mask[this, FactorialCont.vo][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[this, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assume this != null;
  Heap[this, FactorialCont.cust] := inhaleHeap#_1448[this, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.cust] == null) || (dtype(Heap[this, FactorialCont.cust]) == FactorialCont#t);
  assume Fractions(50) > 0;
  Mask[this, FactorialCont.cust] := Mask[this, FactorialCont.cust][perm$R := Mask[this, FactorialCont.cust][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[this, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assume this != null;
  Heap[this, FactorialCont.q] := inhaleHeap#_1448[this, FactorialCont.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.q] == null) || (dtype(Heap[this, FactorialCont.q]) == FactorialContChannel#t);
  assume Fractions(50) > 0;
  Mask[this, FactorialCont.q] := Mask[this, FactorialCont.q][perm$R := Mask[this, FactorialCont.q][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[this, FactorialCont.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  824.66: Receiver might be null."} true ==> (this != null);
  assert {:msg "  824.66: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume !(Heap[this, FactorialCont.q] == null);
  assert {:msg "  825.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.3: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  825.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.14: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.14: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  825.14: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.14: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.25: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.25: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  825.25: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.25: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.43: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  825.43: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.64: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.64: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.82: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.82: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.82: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1448[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.106: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.106: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.124: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.124: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.124: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1448[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.145: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.145: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.145: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  825.145: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assert {:msg "  825.145: Receiver might be null."} true ==> (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null);
  assert {:msg "  825.145: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  825.169: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.169: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.q], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.187: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.187: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  825.187: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.exp);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_1448[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1448[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1448, Mask);
  assert {:msg "  825.208: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.208: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
  assume Heap[this, FactorialCont.v] >= 0;
  assert {:msg "  825.216: Receiver might be null."} true ==> (this != null);
  assert {:msg "  825.216: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.vo);
  assume Heap[this, FactorialCont.vo] >= 0;
  assert {:msg "  826.7: Receiver might be null."} true ==> (this != null);
  assert {:msg "  826.7: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
  assume vp#80 == Heap[this, FactorialCont.v];
  assert {:msg "  826.17: Receiver might be null."} true ==> (this != null);
  assert {:msg "  826.17: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.vo);
  assume vop#81 == Heap[this, FactorialCont.vo];
  assert {:msg "  827.4: Receiver might be null."} true ==> (this != null);
  assert {:msg "  827.4: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
  if (!(Heap[this, FactorialCont.cust] == null)) {
    assert {:msg "  827.24: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.24: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assume Heap[this, FactorialCont.cust] != null;
    Heap[Heap[this, FactorialCont.cust], FactorialCont.q] := inhaleHeap#_1448[Heap[this, FactorialCont.cust], FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null) || (dtype(Heap[Heap[this, FactorialCont.cust], FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[Heap[this, FactorialCont.cust], FactorialCont.q] := Mask[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R := Mask[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.cust], FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1448, Mask);
    assert {:msg "  827.40: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.40: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  827.40: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  827.40: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assume !(Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null);
    assert {:msg "  827.56: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.56: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  827.56: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  827.56: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assert {:msg "  827.56: Receiver might be null."} Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    assert {:msg "  827.56: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.56: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  827.56: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  827.56: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1448[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1448[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1448[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1448, Mask);
    assert {:msg "  827.72: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.72: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  827.72: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  827.72: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assert {:msg "  827.72: Receiver might be null."} Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    assert {:msg "  827.72: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.72: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  827.72: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  827.72: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1448[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1448[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1448[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1448, Mask);
    assert {:msg "  827.98: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.98: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assume Heap[this, FactorialCont.cust] != null;
    Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] := inhaleHeap#_1448[Heap[this, FactorialCont.cust], FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[this, FactorialCont.cust], FactorialCont.vo] := Mask[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R := Mask[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1448[Heap[this, FactorialCont.cust], FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1448, Mask);
    assert {:msg "  827.115: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.115: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  827.115: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  827.115: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.vo);
    assert {:msg "  827.124: Receiver might be null."} true ==> (this != null);
    assert {:msg "  827.124: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.vo);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] == Heap[this, FactorialCont.vo];
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
}
procedure FactorialCont.init(this: ref where (this == null) || (dtype(this) == FactorialCont#t), vp#80: int where true, vop#81: int where true, custp#82: ref where (custp#82 == null) || (dtype(custp#82) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1446: int;
  var inhaleHeap#_1449: HeapType;
  var imp#84: ref where (imp#84 == null) || (dtype(imp#84) == FactorialContChannelImpEP#t);
  var nw#_1450: ref;
  var exp#86: ref where (exp#86 == null) || (dtype(exp#86) == FactorialContChannelExpEP#t);
  var nw#_1451: ref;
  var nw#_1452: ref;
  var methodCallK#_1456: int;
  var this#155: ref where (this#155 == null) || (dtype(this#155) == FactorialContChannel#t);
  var i#156: ref where (i#156 == null) || (dtype(i#156) == FactorialContChannelImpEP#t);
  var e#157: ref where (e#157 == null) || (dtype(e#157) == FactorialContChannelExpEP#t);
  var callHeap#_1453: HeapType;
  var callMask#_1454: MaskType;
  var callCredits#_1455: CreditsType;
  var exhaleMask#_1457: MaskType;
  var isHeld#_1466: int;
  var isRdHeld#_1467: bool;
  var inhaleHeap#_1468: HeapType;
  var exhaleMask#_1469: MaskType;
  assume (0 < methodK#_1446) && ((1000 * methodK#_1446) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1449;
  assume IsGoodInhaleState(inhaleHeap#_1449, Heap, Mask);
  assume this != null;
  Heap[this, FactorialCont.v] := inhaleHeap#_1449[this, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.v] := Mask[this, FactorialCont.v][perm$R := Mask[this, FactorialCont.v][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1449[this, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1449, Mask);
  assume this != null;
  Heap[this, FactorialCont.vo] := inhaleHeap#_1449[this, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.vo] := Mask[this, FactorialCont.vo][perm$R := Mask[this, FactorialCont.vo][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1449[this, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1449, Mask);
  assume this != null;
  Heap[this, FactorialCont.cust] := inhaleHeap#_1449[this, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.cust] == null) || (dtype(Heap[this, FactorialCont.cust]) == FactorialCont#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.cust] := Mask[this, FactorialCont.cust][perm$R := Mask[this, FactorialCont.cust][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1449[this, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1449, Mask);
  assume this != null;
  Heap[this, FactorialCont.q] := inhaleHeap#_1449[this, FactorialCont.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.q] == null) || (dtype(Heap[this, FactorialCont.q]) == FactorialContChannel#t);
  assume Fractions(100) > 0;
  Mask[this, FactorialCont.q] := Mask[this, FactorialCont.q][perm$R := Mask[this, FactorialCont.q][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1449[this, FactorialCont.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1449, Mask);
  assume vp#80 >= 0;
  assume vop#81 >= 0;
  if (!(custp#82 == null)) {
    assume custp#82 != null;
    Heap[custp#82, FactorialCont.q] := inhaleHeap#_1449[custp#82, FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[custp#82, FactorialCont.q] == null) || (dtype(Heap[custp#82, FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[custp#82, FactorialCont.q] := Mask[custp#82, FactorialCont.q][perm$R := Mask[custp#82, FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1449[custp#82, FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1449, Mask);
    assume !(Heap[custp#82, FactorialCont.q] == null);
    assume Heap[custp#82, FactorialCont.q] != null;
    Heap[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1449[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1449[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1449[Heap[custp#82, FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1449, Mask);
    assume Heap[custp#82, FactorialCont.q] != null;
    Heap[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1449[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1449[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1449[Heap[custp#82, FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1449, Mask);
    assume custp#82 != null;
    Heap[custp#82, FactorialCont.vo] := inhaleHeap#_1449[custp#82, FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[custp#82, FactorialCont.vo] := Mask[custp#82, FactorialCont.vo][perm$R := Mask[custp#82, FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1449[custp#82, FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1449, Mask);
    assume vop#81 == Heap[custp#82, FactorialCont.vo];
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // update field v
  assert {:msg "  829.3: Location might not be writable"} CanWrite(Mask, this, FactorialCont.v);
  Heap[this, FactorialCont.v] := vp#80;
  assume wf(Heap, Mask);
  // update field vo
  assert {:msg "  830.3: Location might not be writable"} CanWrite(Mask, this, FactorialCont.vo);
  Heap[this, FactorialCont.vo] := vop#81;
  assume wf(Heap, Mask);
  // update field cust
  assert {:msg "  831.3: Location might not be writable"} CanWrite(Mask, this, FactorialCont.cust);
  Heap[this, FactorialCont.cust] := custp#82;
  assume wf(Heap, Mask);
  // local var imp
  // assigment to imp
  // new
  havoc nw#_1450;
  assume (nw#_1450 != null) && (dtype(nw#_1450) == FactorialContChannelImpEP#t);
  assume (forall<T#_18> f: Field (T#_18) :: (Mask[nw#_1450, f][perm$R] == 0) && (Mask[nw#_1450, f][perm$N] == 0));
  assume Heap[nw#_1450, mu] == $LockBottom;
  assume Heap[nw#_1450, held] <= 0;
  assume Heap[nw#_1450, rdheld] == false;
  Mask[nw#_1450, FactorialContChannelImpEP.state] := Mask[nw#_1450, FactorialContChannelImpEP.state][perm$R := Mask[nw#_1450, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  Mask[nw#_1450, FactorialContChannelImpEP.ch] := Mask[nw#_1450, FactorialContChannelImpEP.ch][perm$R := Mask[nw#_1450, FactorialContChannelImpEP.ch][perm$R] + Fractions(100)];
  Mask[nw#_1450, FactorialContChannelImpEP.impch] := Mask[nw#_1450, FactorialContChannelImpEP.impch][perm$R := Mask[nw#_1450, FactorialContChannelImpEP.impch][perm$R] + Fractions(100)];
  Mask[nw#_1450, mu] := Mask[nw#_1450, mu][perm$R := Mask[nw#_1450, mu][perm$R] + Fractions(100)];
  imp#84 := nw#_1450;
  // local var exp
  // assigment to exp
  // new
  havoc nw#_1451;
  assume (nw#_1451 != null) && (dtype(nw#_1451) == FactorialContChannelExpEP#t);
  assume (forall<T#_19> f: Field (T#_19) :: (Mask[nw#_1451, f][perm$R] == 0) && (Mask[nw#_1451, f][perm$N] == 0));
  assume Heap[nw#_1451, mu] == $LockBottom;
  assume Heap[nw#_1451, held] <= 0;
  assume Heap[nw#_1451, rdheld] == false;
  Mask[nw#_1451, FactorialContChannelExpEP.state] := Mask[nw#_1451, FactorialContChannelExpEP.state][perm$R := Mask[nw#_1451, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
  Mask[nw#_1451, FactorialContChannelExpEP.ch] := Mask[nw#_1451, FactorialContChannelExpEP.ch][perm$R := Mask[nw#_1451, FactorialContChannelExpEP.ch][perm$R] + Fractions(100)];
  Mask[nw#_1451, FactorialContChannelExpEP.expch] := Mask[nw#_1451, FactorialContChannelExpEP.expch][perm$R := Mask[nw#_1451, FactorialContChannelExpEP.expch][perm$R] + Fractions(100)];
  Mask[nw#_1451, mu] := Mask[nw#_1451, mu][perm$R := Mask[nw#_1451, mu][perm$R] + Fractions(100)];
  exp#86 := nw#_1451;
  // update field q
  assert {:msg "  834.3: Location might not be writable"} CanWrite(Mask, this, FactorialCont.q);
  // new
  havoc nw#_1452;
  assume (nw#_1452 != null) && (dtype(nw#_1452) == FactorialContChannel#t);
  assume (forall<T#_20> f: Field (T#_20) :: (Mask[nw#_1452, f][perm$R] == 0) && (Mask[nw#_1452, f][perm$N] == 0));
  assume Heap[nw#_1452, mu] == $LockBottom;
  assume Heap[nw#_1452, held] <= 0;
  assume Heap[nw#_1452, rdheld] == false;
  Mask[nw#_1452, FactorialContChannel.imp] := Mask[nw#_1452, FactorialContChannel.imp][perm$R := Mask[nw#_1452, FactorialContChannel.imp][perm$R] + Fractions(100)];
  Mask[nw#_1452, FactorialContChannel.exp] := Mask[nw#_1452, FactorialContChannel.exp][perm$R := Mask[nw#_1452, FactorialContChannel.exp][perm$R] + Fractions(100)];
  Mask[nw#_1452, mu] := Mask[nw#_1452, mu][perm$R := Mask[nw#_1452, mu][perm$R] + Fractions(100)];
  Heap[this, FactorialCont.q] := nw#_1452;
  assume wf(Heap, Mask);
  assume (0 < methodCallK#_1456) && ((1000 * methodCallK#_1456) < Fractions(1)) && ((1000 * methodCallK#_1456) < methodK#_1446);
  // call init
  callHeap#_1453 := Heap;
  callMask#_1454 := Mask;
  callCredits#_1455 := Credits;
  assert {:msg "  835.8: Receiver might be null."} true ==> (this != null);
  assert {:msg "  835.8: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  835.3: The target of the method call might be null."} Heap[this, FactorialCont.q] != null;
  this#155 := Heap[this, FactorialCont.q];
  i#156 := imp#84;
  e#157 := exp#86;
  // begin exhale (precondition)
  exhaleMask#_1457 := Mask;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.11 for FactorialContChannel.imp."} (Fractions(100) <= exhaleMask#_1457[this#155, FactorialContChannel.imp][perm$R]) && ((Fractions(100) == exhaleMask#_1457[this#155, FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1457[this#155, FactorialContChannel.imp][perm$N]));
  exhaleMask#_1457[this#155, FactorialContChannel.imp] := exhaleMask#_1457[this#155, FactorialContChannel.imp][perm$R := exhaleMask#_1457[this#155, FactorialContChannel.imp][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.23 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.23 for FactorialContChannelImpEP.ch."} (Fractions(100) <= exhaleMask#_1457[i#156, FactorialContChannelImpEP.ch][perm$R]) && ((Fractions(100) == exhaleMask#_1457[i#156, FactorialContChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1457[i#156, FactorialContChannelImpEP.ch][perm$N]));
  exhaleMask#_1457[i#156, FactorialContChannelImpEP.ch] := exhaleMask#_1457[i#156, FactorialContChannelImpEP.ch][perm$R := exhaleMask#_1457[i#156, FactorialContChannelImpEP.ch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.36 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.36 for FactorialContChannel.exp."} (Fractions(100) <= exhaleMask#_1457[this#155, FactorialContChannel.exp][perm$R]) && ((Fractions(100) == exhaleMask#_1457[this#155, FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1457[this#155, FactorialContChannel.exp][perm$N]));
  exhaleMask#_1457[this#155, FactorialContChannel.exp] := exhaleMask#_1457[this#155, FactorialContChannel.exp][perm$R := exhaleMask#_1457[this#155, FactorialContChannel.exp][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.48 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.48 for FactorialContChannelExpEP.ch."} (Fractions(100) <= exhaleMask#_1457[e#157, FactorialContChannelExpEP.ch][perm$R]) && ((Fractions(100) == exhaleMask#_1457[e#157, FactorialContChannelExpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1457[e#157, FactorialContChannelExpEP.ch][perm$N]));
  exhaleMask#_1457[e#157, FactorialContChannelExpEP.ch] := exhaleMask#_1457[e#157, FactorialContChannelExpEP.ch][perm$R := exhaleMask#_1457[e#157, FactorialContChannelExpEP.ch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.61 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.61 for FactorialContChannelExpEP.expch."} (Fractions(100) <= exhaleMask#_1457[e#157, FactorialContChannelExpEP.expch][perm$R]) && ((Fractions(100) == exhaleMask#_1457[e#157, FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_1457[e#157, FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_1457[e#157, FactorialContChannelExpEP.expch] := exhaleMask#_1457[e#157, FactorialContChannelExpEP.expch][perm$R := exhaleMask#_1457[e#157, FactorialContChannelExpEP.expch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.77 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.77 for FactorialContChannelImpEP.impch."} (Fractions(100) <= exhaleMask#_1457[i#156, FactorialContChannelImpEP.impch][perm$R]) && ((Fractions(100) == exhaleMask#_1457[i#156, FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1457[i#156, FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_1457[i#156, FactorialContChannelImpEP.impch] := exhaleMask#_1457[i#156, FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1457[i#156, FactorialContChannelImpEP.impch][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.93 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.93 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1457[i#156, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1457[i#156, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1457[i#156, FactorialContChannelImpEP.state][perm$N]));
  exhaleMask#_1457[i#156, FactorialContChannelImpEP.state] := exhaleMask#_1457[i#156, FactorialContChannelImpEP.state][perm$R := exhaleMask#_1457[i#156, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  assert {:msg "  835.3: The precondition at 353.11 might not hold. The permission at 353.109 might not be positive."} Fractions(100) > 0;
  assert {:msg "  835.3: The precondition at 353.11 might not hold. Insufficient fraction at 353.109 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1457[e#157, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1457[e#157, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1457[e#157, FactorialContChannelExpEP.state][perm$N]));
  exhaleMask#_1457[e#157, FactorialContChannelExpEP.state] := exhaleMask#_1457[e#157, FactorialContChannelExpEP.state][perm$R := exhaleMask#_1457[e#157, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1457);
  Mask := exhaleMask#_1457;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1468;
  assume IsGoodInhaleState(inhaleHeap#_1468, Heap, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.valid] := inhaleHeap#_1468[this#155, FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1468[this#155, FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#155, FactorialContChannel.valid] := Mask[this#155, FactorialContChannel.valid][perm$R := Mask[this#155, FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.valid] := inhaleHeap#_1468[this#155, FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1468[this#155, FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#155, FactorialContChannel.valid] := Mask[this#155, FactorialContChannel.valid][perm$R := Mask[this#155, FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.exp] := inhaleHeap#_1468[this#155, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this#155, FactorialContChannel.exp] == null) || (dtype(Heap[this#155, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[this#155, FactorialContChannel.exp] := Mask[this#155, FactorialContChannel.exp][perm$R := Mask[this#155, FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.imp] := inhaleHeap#_1468[this#155, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this#155, FactorialContChannel.imp] == null) || (dtype(Heap[this#155, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[this#155, FactorialContChannel.imp] := Mask[this#155, FactorialContChannel.imp][perm$R := Mask[this#155, FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume Heap[this#155, FactorialContChannel.exp] != null;
  Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_1468[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume Heap[this#155, FactorialContChannel.imp] != null;
  Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1468[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.exp] := inhaleHeap#_1468[this#155, FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[this#155, FactorialContChannel.exp] == null) || (dtype(Heap[this#155, FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[this#155, FactorialContChannel.exp] := Mask[this#155, FactorialContChannel.exp][perm$R := Mask[this#155, FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.imp] := inhaleHeap#_1468[this#155, FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[this#155, FactorialContChannel.imp] == null) || (dtype(Heap[this#155, FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[this#155, FactorialContChannel.imp] := Mask[this#155, FactorialContChannel.imp][perm$R := Mask[this#155, FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume Heap[this#155, FactorialContChannel.exp] != null;
  Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_1468[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume Heap[this#155, FactorialContChannel.imp] != null;
  Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1468[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume !(Heap[Heap[this#155, FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assume !(Heap[Heap[this#155, FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.initImpState] := inhaleHeap#_1468[this#155, FactorialContChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1468[this#155, FactorialContChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this#155, FactorialContChannel.initImpState] := Mask[this#155, FactorialContChannel.initImpState][perm$R := Mask[this#155, FactorialContChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume this#155 != null;
  Heap[this#155, FactorialContChannel.initExpState] := inhaleHeap#_1468[this#155, FactorialContChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1468[this#155, FactorialContChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[this#155, FactorialContChannel.initExpState] := Mask[this#155, FactorialContChannel.initExpState][perm$R := Mask[this#155, FactorialContChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1468[this#155, FactorialContChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1468, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // begin exhale (postcondition)
  exhaleMask#_1469 := Mask;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 824.66 might not evaluate to true."} !(Heap[this, FactorialCont.q] == null);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 825.145 might not evaluate to true."} !(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 825.208 might not evaluate to true."} Heap[this, FactorialCont.v] >= 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 825.216 might not evaluate to true."} Heap[this, FactorialCont.vo] >= 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 826.3 might not evaluate to true."} vp#80 == Heap[this, FactorialCont.v];
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 826.12 might not evaluate to true."} vop#81 == Heap[this, FactorialCont.vo];
  if (!(Heap[this, FactorialCont.cust] == null)) {
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 827.40 might not evaluate to true."} !(Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null);
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. The expression at 827.115 might not evaluate to true."} Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] == Heap[this, FactorialCont.vo];
  } else {
  }
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 824.10 might not be positive."} Fractions(50) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 824.10 for FactorialCont.v."} (Fractions(50) <= exhaleMask#_1469[this, FactorialCont.v][perm$R]) && ((Fractions(50) == exhaleMask#_1469[this, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1469[this, FactorialCont.v][perm$N]));
  exhaleMask#_1469[this, FactorialCont.v] := exhaleMask#_1469[this, FactorialCont.v][perm$R := exhaleMask#_1469[this, FactorialCont.v][perm$R] - Fractions(50)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 824.23 might not be positive."} Fractions(50) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 824.23 for FactorialCont.vo."} (Fractions(50) <= exhaleMask#_1469[this, FactorialCont.vo][perm$R]) && ((Fractions(50) == exhaleMask#_1469[this, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1469[this, FactorialCont.vo][perm$N]));
  exhaleMask#_1469[this, FactorialCont.vo] := exhaleMask#_1469[this, FactorialCont.vo][perm$R := exhaleMask#_1469[this, FactorialCont.vo][perm$R] - Fractions(50)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 824.37 might not be positive."} Fractions(50) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 824.37 for FactorialCont.cust."} (Fractions(50) <= exhaleMask#_1469[this, FactorialCont.cust][perm$R]) && ((Fractions(50) == exhaleMask#_1469[this, FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1469[this, FactorialCont.cust][perm$N]));
  exhaleMask#_1469[this, FactorialCont.cust] := exhaleMask#_1469[this, FactorialCont.cust][perm$R := exhaleMask#_1469[this, FactorialCont.cust][perm$R] - Fractions(50)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 824.53 might not be positive."} Fractions(50) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 824.53 for FactorialCont.q."} (Fractions(50) <= exhaleMask#_1469[this, FactorialCont.q][perm$R]) && ((Fractions(50) == exhaleMask#_1469[this, FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1469[this, FactorialCont.q][perm$N]));
  exhaleMask#_1469[this, FactorialCont.q] := exhaleMask#_1469[this, FactorialCont.q][perm$R := exhaleMask#_1469[this, FactorialCont.q][perm$R] - Fractions(50)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.3 might not be positive."} Fractions(100) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.3 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.14 might not be positive."} Fractions(100) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.14 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.25 might not be positive."} Fractions(100) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.25 for FactorialContChannel.initImpState."} (Fractions(100) <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.43 might not be positive."} Fractions(100) > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.43 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.61 might not be positive."} monitorK > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.61 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.79 might not be positive."} monitorK > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.79 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.103 might not be positive."} monitorK > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.103 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.121 might not be positive."} monitorK > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.121 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
  exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.166 might not be positive."} monitorK > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.166 for FactorialContChannel.exp."} (monitorK <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$N]));
  exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.exp] := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 825.184 might not be positive."} monitorK > 0;
  assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 825.184 for FactorialContChannelExpEP.expch."} (monitorK <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$N]));
  exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := exhaleMask#_1469[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1469);
  if (!(Heap[this, FactorialCont.cust] == null)) {
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 827.21 might not be positive."} monitorK > 0;
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 827.21 for FactorialCont.q."} (monitorK <= exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.q][perm$N]));
    exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.q] := exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1469);
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 827.56 might not be positive."} Fractions(100) > 0;
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 827.56 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$N]));
    exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1469);
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 827.72 might not be positive."} Fractions(100) > 0;
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 827.72 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
    exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1469[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1469);
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. The permission at 827.95 might not be positive."} monitorK > 0;
    assert {:msg "  821.2: The postcondition at 824.10 might not hold. Insufficient fraction at 827.95 for FactorialCont.vo."} (monitorK <= exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$N]));
    exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.vo] := exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R := exhaleMask#_1469[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1469);
  } else {
  }
  Mask := exhaleMask#_1469;
  assume wf(Heap, Mask);
  // end exhale
  assert {:msg "  821.2: Method might lock/unlock more than allowed."} (forall lk#_1488: ref :: {Heap[lk#_1488, held]} {Heap[lk#_1488, rdheld]} (((0 < Heap[lk#_1488, held]) == (0 < old(Heap)[lk#_1488, held])) && (Heap[lk#_1488, rdheld] == old(Heap)[lk#_1488, rdheld])) || false);
  assert {:msg "  821.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
procedure FactorialCont.act$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1489: int;
  var inhaleHeap#_1490: HeapType;
  assume (0 < methodK#_1489) && ((1000 * methodK#_1489) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // inhale (precondition)
  havoc inhaleHeap#_1490;
  assume IsGoodInhaleState(inhaleHeap#_1490, Heap, Mask);
  assume this != null;
  Heap[this, FactorialCont.q] := inhaleHeap#_1490[this, FactorialCont.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.q] == null) || (dtype(Heap[this, FactorialCont.q]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialCont.q] := Mask[this, FactorialCont.q][perm$R := Mask[this, FactorialCont.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[this, FactorialCont.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assume this != null;
  Heap[this, FactorialCont.v] := inhaleHeap#_1490[this, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, FactorialCont.v] := Mask[this, FactorialCont.v][perm$R := Mask[this, FactorialCont.v][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[this, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assume this != null;
  Heap[this, FactorialCont.vo] := inhaleHeap#_1490[this, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, FactorialCont.vo] := Mask[this, FactorialCont.vo][perm$R := Mask[this, FactorialCont.vo][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[this, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assert {:msg "  839.54: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.54: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume !(Heap[this, FactorialCont.q] == null);
  assert {:msg "  839.66: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.66: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  839.66: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  839.66: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.66: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assert {:msg "  839.77: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.77: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  839.77: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  839.77: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.77: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assert {:msg "  839.98: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.98: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[Heap[this, FactorialCont.q], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assert {:msg "  839.116: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.116: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  839.116: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1490[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assert {:msg "  839.137: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.137: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  839.137: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  839.137: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assert {:msg "  839.137: Receiver might be null."} true ==> (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null);
  assert {:msg "  839.137: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assume !(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assert {:msg "  839.158: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.158: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
  assume Heap[this, FactorialCont.v] >= 0;
  assert {:msg "  839.166: Receiver might be null."} true ==> (this != null);
  assert {:msg "  839.166: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.vo);
  assume Heap[this, FactorialCont.vo] >= 0;
  assume this != null;
  Heap[this, FactorialCont.cust] := inhaleHeap#_1490[this, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.cust] == null) || (dtype(Heap[this, FactorialCont.cust]) == FactorialCont#t);
  assume monitorK > 0;
  Mask[this, FactorialCont.cust] := Mask[this, FactorialCont.cust][perm$R := Mask[this, FactorialCont.cust][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1490[this, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1490, Mask);
  assert {:msg "  840.29: Receiver might be null."} true ==> (this != null);
  assert {:msg "  840.29: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
  if (!(Heap[this, FactorialCont.cust] == null)) {
    assert {:msg "  840.49: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.49: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assume Heap[this, FactorialCont.cust] != null;
    Heap[Heap[this, FactorialCont.cust], FactorialCont.q] := inhaleHeap#_1490[Heap[this, FactorialCont.cust], FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null) || (dtype(Heap[Heap[this, FactorialCont.cust], FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[Heap[this, FactorialCont.cust], FactorialCont.q] := Mask[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R := Mask[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1490[Heap[this, FactorialCont.cust], FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1490, Mask);
    assert {:msg "  840.65: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.65: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  840.65: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  840.65: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assume !(Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null);
    assert {:msg "  840.81: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.81: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  840.81: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  840.81: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assert {:msg "  840.81: Receiver might be null."} Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    assert {:msg "  840.81: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.81: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  840.81: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  840.81: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1490[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1490[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1490[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1490, Mask);
    assert {:msg "  840.97: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.97: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  840.97: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  840.97: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assert {:msg "  840.97: Receiver might be null."} Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    assert {:msg "  840.97: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.97: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  840.97: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  840.97: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1490[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1490[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1490[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1490, Mask);
    assert {:msg "  840.123: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.123: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assume Heap[this, FactorialCont.cust] != null;
    Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] := inhaleHeap#_1490[Heap[this, FactorialCont.cust], FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[this, FactorialCont.cust], FactorialCont.vo] := Mask[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R := Mask[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1490[Heap[this, FactorialCont.cust], FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1490, Mask);
    assert {:msg "  840.140: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.140: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    assert {:msg "  840.140: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
    assert {:msg "  840.140: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.vo);
    assert {:msg "  840.149: Receiver might be null."} true ==> (this != null);
    assert {:msg "  840.149: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.vo);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] == Heap[this, FactorialCont.vo];
  } else {
  }
  assert {:msg "  841.18: Receiver might be null."} true ==> (this != null);
  assert {:msg "  841.18: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  841.18: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  841.18: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assert {:msg "  841.18: Receiver might be null."} true ==> (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null);
  assert {:msg "  841.18: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assert {:msg "  841.18: The target of the credit predicate might be null."} Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] + 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FactorialCont.act(this: ref where (this == null) || (dtype(this) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1489: int;
  var inhaleHeap#_1491: HeapType;
  var unfoldK#_1492: int;
  var exhaleMask#_1493: MaskType;
  var inhaleHeap#_1495: HeapType;
  var unfoldK#_1496: int;
  var exhaleMask#_1497: MaskType;
  var inhaleHeap#_1499: HeapType;
  var unfoldK#_1500: int;
  var exhaleMask#_1501: MaskType;
  var inhaleHeap#_1503: HeapType;
  var current#88: ref where (current#88 == null) || (dtype(current#88) == Message#t);
  var this#158: ref where (this#158 == null) || (dtype(this#158) == Channel#t);
  var msg#159: ref where (msg#159 == null) || (dtype(msg#159) == Message#t);
  var inhaleHeap#_1505: HeapType;
  var methodCallK#_1509: int;
  var this#160: ref where (this#160 == null) || (dtype(this#160) == FactorialContChannelImpEP#t);
  var mi#161: ref where (mi#161 == null) || (dtype(mi#161) == Message#t);
  var mo#162: ref where (mo#162 == null) || (dtype(mo#162) == Message#t);
  var callHeap#_1506: HeapType;
  var callMask#_1507: MaskType;
  var callCredits#_1508: CreditsType;
  var exhaleMask#_1510: MaskType;
  var isHeld#_1514: int;
  var isRdHeld#_1515: bool;
  var inhaleHeap#_1516: HeapType;
  var unfoldK#_1517: int;
  var exhaleMask#_1518: MaskType;
  var inhaleHeap#_1520: HeapType;
  var m#90: ref where (m#90 == null) || (dtype(m#90) == Message#t);
  var nw#_1521: ref;
  var methodCallK#_1525: int;
  var this#163: ref where (this#163 == null) || (dtype(this#163) == Message#t);
  var vr#164: int where true;
  var receiver#165: ref where (receiver#165 == null) || (dtype(receiver#165) == Future#t);
  var callHeap#_1522: HeapType;
  var callMask#_1523: MaskType;
  var callCredits#_1524: CreditsType;
  var exhaleMask#_1526: MaskType;
  var isHeld#_1532: int;
  var isRdHeld#_1533: bool;
  var inhaleHeap#_1534: HeapType;
  var unfoldK#_1535: int;
  var exhaleMask#_1536: MaskType;
  var inhaleHeap#_1538: HeapType;
  var Heap#_1542: HeapType;
  var Mask#_1543: MaskType;
  var Credits#_1544: CreditsType;
  var exhaleMask#_1545: MaskType;
  var funcappK#_1552: int;
  var Heap#_1549: HeapType;
  var Mask#_1550: MaskType;
  var Credits#_1551: CreditsType;
  var exhaleMask#_1553: MaskType;
  var foldK#_1554: int;
  var exhaleMask#_1555: MaskType;
  var inhaleHeap#_1559: HeapType;
  var unfoldK#_1560: int;
  var exhaleMask#_1561: MaskType;
  var inhaleHeap#_1563: HeapType;
  var methodCallK#_1567: int;
  var this#166: ref where (this#166 == null) || (dtype(this#166) == FutureChannelExpEP#t);
  var m#167: ref where (m#167 == null) || (dtype(m#167) == Message#t);
  var callHeap#_1564: HeapType;
  var callMask#_1565: MaskType;
  var callCredits#_1566: CreditsType;
  var exhaleMask#_1568: MaskType;
  var isHeld#_1574: int;
  var isRdHeld#_1575: bool;
  var inhaleHeap#_1576: HeapType;
  var m#92: ref where (m#92 == null) || (dtype(m#92) == Message#t);
  var nw#_1577: ref;
  var Heap#_1581: HeapType;
  var Mask#_1582: MaskType;
  var Credits#_1583: CreditsType;
  var exhaleMask#_1584: MaskType;
  var Heap#_1589: HeapType;
  var Mask#_1590: MaskType;
  var Credits#_1591: CreditsType;
  var exhaleMask#_1592: MaskType;
  var methodCallK#_1597: int;
  var this#168: ref where (this#168 == null) || (dtype(this#168) == Message#t);
  var v#169: int where true;
  var oldv#170: ref where (oldv#170 == null) || (dtype(oldv#170) == FactorialCont#t);
  var receiver#171: ref where (receiver#171 == null) || (dtype(receiver#171) == FactorialCont#t);
  var callHeap#_1594: HeapType;
  var callMask#_1595: MaskType;
  var callCredits#_1596: CreditsType;
  var exhaleMask#_1598: MaskType;
  var isHeld#_1614: int;
  var isRdHeld#_1615: bool;
  var inhaleHeap#_1616: HeapType;
  var unfoldK#_1617: int;
  var exhaleMask#_1618: MaskType;
  var inhaleHeap#_1620: HeapType;
  var methodCallK#_1624: int;
  var this#172: ref where (this#172 == null) || (dtype(this#172) == FactorialContChannelExpEP#t);
  var m#173: ref where (m#173 == null) || (dtype(m#173) == Message#t);
  var callHeap#_1621: HeapType;
  var callMask#_1622: MaskType;
  var callCredits#_1623: CreditsType;
  var exhaleMask#_1625: MaskType;
  var isHeld#_1631: int;
  var isRdHeld#_1632: bool;
  var inhaleHeap#_1633: HeapType;
  var r#94: ref where (r#94 == null) || (dtype(r#94) == Message#t);
  var nw#_1634: ref;
  var Heap#_1638: HeapType;
  var Mask#_1639: MaskType;
  var Credits#_1640: CreditsType;
  var exhaleMask#_1641: MaskType;
  var funcappK#_1648: int;
  var Heap#_1645: HeapType;
  var Mask#_1646: MaskType;
  var Credits#_1647: CreditsType;
  var exhaleMask#_1649: MaskType;
  var funcappK#_1656: int;
  var Heap#_1653: HeapType;
  var Mask#_1654: MaskType;
  var Credits#_1655: CreditsType;
  var exhaleMask#_1657: MaskType;
  var methodCallK#_1661: int;
  var this#174: ref where (this#174 == null) || (dtype(this#174) == FactorialContChannelImpEP#t);
  var mi#175: ref where (mi#175 == null) || (dtype(mi#175) == Message#t);
  var mo#176: ref where (mo#176 == null) || (dtype(mo#176) == Message#t);
  var callHeap#_1658: HeapType;
  var callMask#_1659: MaskType;
  var callCredits#_1660: CreditsType;
  var exhaleMask#_1662: MaskType;
  var isHeld#_1666: int;
  var isRdHeld#_1667: bool;
  var inhaleHeap#_1668: HeapType;
  var unfoldK#_1669: int;
  var exhaleMask#_1670: MaskType;
  var inhaleHeap#_1672: HeapType;
  var m#96: ref where (m#96 == null) || (dtype(m#96) == Message#t);
  var nw#_1673: ref;
  var methodCallK#_1677: int;
  var this#177: ref where (this#177 == null) || (dtype(this#177) == Message#t);
  var vr#178: int where true;
  var receiver#179: ref where (receiver#179 == null) || (dtype(receiver#179) == Future#t);
  var callHeap#_1674: HeapType;
  var callMask#_1675: MaskType;
  var callCredits#_1676: CreditsType;
  var exhaleMask#_1678: MaskType;
  var isHeld#_1684: int;
  var isRdHeld#_1685: bool;
  var inhaleHeap#_1686: HeapType;
  var unfoldK#_1687: int;
  var exhaleMask#_1688: MaskType;
  var inhaleHeap#_1690: HeapType;
  var Heap#_1694: HeapType;
  var Mask#_1695: MaskType;
  var Credits#_1696: CreditsType;
  var exhaleMask#_1697: MaskType;
  var funcappK#_1704: int;
  var Heap#_1701: HeapType;
  var Mask#_1702: MaskType;
  var Credits#_1703: CreditsType;
  var exhaleMask#_1705: MaskType;
  var foldK#_1706: int;
  var exhaleMask#_1707: MaskType;
  var inhaleHeap#_1711: HeapType;
  var unfoldK#_1712: int;
  var exhaleMask#_1713: MaskType;
  var inhaleHeap#_1715: HeapType;
  var methodCallK#_1719: int;
  var this#180: ref where (this#180 == null) || (dtype(this#180) == FutureChannelExpEP#t);
  var m#181: ref where (m#181 == null) || (dtype(m#181) == Message#t);
  var callHeap#_1716: HeapType;
  var callMask#_1717: MaskType;
  var callCredits#_1718: CreditsType;
  var exhaleMask#_1720: MaskType;
  var isHeld#_1726: int;
  var isRdHeld#_1727: bool;
  var inhaleHeap#_1728: HeapType;
  var methodCallK#_1732: int;
  var this#182: ref where (this#182 == null) || (dtype(this#182) == Message#t);
  var v#183: int where true;
  var oldv#184: ref where (oldv#184 == null) || (dtype(oldv#184) == FactorialCont#t);
  var receiver#185: ref where (receiver#185 == null) || (dtype(receiver#185) == FactorialCont#t);
  var callHeap#_1729: HeapType;
  var callMask#_1730: MaskType;
  var callCredits#_1731: CreditsType;
  var exhaleMask#_1733: MaskType;
  var isHeld#_1749: int;
  var isRdHeld#_1750: bool;
  var inhaleHeap#_1751: HeapType;
  var unfoldK#_1752: int;
  var exhaleMask#_1753: MaskType;
  var inhaleHeap#_1755: HeapType;
  var methodCallK#_1759: int;
  var this#186: ref where (this#186 == null) || (dtype(this#186) == FactorialContChannelExpEP#t);
  var m#187: ref where (m#187 == null) || (dtype(m#187) == Message#t);
  var callHeap#_1756: HeapType;
  var callMask#_1757: MaskType;
  var callCredits#_1758: CreditsType;
  var exhaleMask#_1760: MaskType;
  var isHeld#_1766: int;
  var isRdHeld#_1767: bool;
  var inhaleHeap#_1768: HeapType;
  var r#98: ref where (r#98 == null) || (dtype(r#98) == Message#t);
  var nw#_1769: ref;
  var Heap#_1773: HeapType;
  var Mask#_1774: MaskType;
  var Credits#_1775: CreditsType;
  var exhaleMask#_1776: MaskType;
  var funcappK#_1783: int;
  var Heap#_1780: HeapType;
  var Mask#_1781: MaskType;
  var Credits#_1782: CreditsType;
  var exhaleMask#_1784: MaskType;
  var funcappK#_1791: int;
  var Heap#_1788: HeapType;
  var Mask#_1789: MaskType;
  var Credits#_1790: CreditsType;
  var exhaleMask#_1792: MaskType;
  assume (0 < methodK#_1489) && ((1000 * methodK#_1489) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1491;
  assume IsGoodInhaleState(inhaleHeap#_1491, Heap, Mask);
  assume this != null;
  Heap[this, FactorialCont.q] := inhaleHeap#_1491[this, FactorialCont.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.q] == null) || (dtype(Heap[this, FactorialCont.q]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[this, FactorialCont.q] := Mask[this, FactorialCont.q][perm$R := Mask[this, FactorialCont.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[this, FactorialCont.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume this != null;
  Heap[this, FactorialCont.v] := inhaleHeap#_1491[this, FactorialCont.v];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, FactorialCont.v] := Mask[this, FactorialCont.v][perm$R := Mask[this, FactorialCont.v][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[this, FactorialCont.v]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume this != null;
  Heap[this, FactorialCont.vo] := inhaleHeap#_1491[this, FactorialCont.vo];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this, FactorialCont.vo] := Mask[this, FactorialCont.vo][perm$R := Mask[this, FactorialCont.vo][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[this, FactorialCont.vo]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume !(Heap[this, FactorialCont.q] == null);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[Heap[this, FactorialCont.q], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1491[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  assume !(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assume Heap[this, FactorialCont.v] >= 0;
  assume Heap[this, FactorialCont.vo] >= 0;
  assume this != null;
  Heap[this, FactorialCont.cust] := inhaleHeap#_1491[this, FactorialCont.cust];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.cust] == null) || (dtype(Heap[this, FactorialCont.cust]) == FactorialCont#t);
  assume monitorK > 0;
  Mask[this, FactorialCont.cust] := Mask[this, FactorialCont.cust][perm$R := Mask[this, FactorialCont.cust][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1491[this, FactorialCont.cust]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1491, Mask);
  if (!(Heap[this, FactorialCont.cust] == null)) {
    assume Heap[this, FactorialCont.cust] != null;
    Heap[Heap[this, FactorialCont.cust], FactorialCont.q] := inhaleHeap#_1491[Heap[this, FactorialCont.cust], FactorialCont.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null) || (dtype(Heap[Heap[this, FactorialCont.cust], FactorialCont.q]) == FactorialContChannel#t);
    assume monitorK > 0;
    Mask[Heap[this, FactorialCont.cust], FactorialCont.q] := Mask[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R := Mask[Heap[this, FactorialCont.cust], FactorialCont.q][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1491[Heap[this, FactorialCont.cust], FactorialCont.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1491, Mask);
    assume !(Heap[Heap[this, FactorialCont.cust], FactorialCont.q] == null);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1491[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1491[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1491[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1491, Mask);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
    Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := inhaleHeap#_1491[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1491[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1491[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1491, Mask);
    assume Heap[this, FactorialCont.cust] != null;
    Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] := inhaleHeap#_1491[Heap[this, FactorialCont.cust], FactorialCont.vo];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[Heap[this, FactorialCont.cust], FactorialCont.vo] := Mask[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R := Mask[Heap[this, FactorialCont.cust], FactorialCont.vo][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1491[Heap[this, FactorialCont.cust], FactorialCont.vo]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1491, Mask);
    assume Heap[Heap[this, FactorialCont.cust], FactorialCont.vo] == Heap[this, FactorialCont.vo];
  } else {
  }
  Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] + 1;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // unfold
  assume (0 < unfoldK#_1492) && (unfoldK#_1492 < Fractions(1)) && ((1000 * unfoldK#_1492) < methodK#_1489);
  assert {:msg "  843.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  843.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  843.3: The target of the fold statement might be null."} Heap[this, FactorialCont.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1493 := Mask;
  assert {:msg "  843.3: unfold might fail because the predicate FactorialContChannel.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  843.3: unfold might fail because the predicate FactorialContChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1493[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1493[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1493[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$N]));
  exhaleMask#_1493[Heap[this, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1493[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1493[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1493);
  Mask := exhaleMask#_1493;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1495 := Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid];
  assume IsGoodInhaleState(inhaleHeap#_1495, Heap, Mask);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1495[Heap[this, FactorialCont.q], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1495[Heap[this, FactorialCont.q], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1495, Mask);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1495[Heap[this, FactorialCont.q], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1495[Heap[this, FactorialCont.q], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1495, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] := inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1495, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] := inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1495, Mask);
  assume !(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null);
  assume !(Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] == null);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] := inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1495, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid] := inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1495[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1495, Mask);
  assume Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] == Heap[this, FactorialCont.q];
  assume Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.ch] == Heap[this, FactorialCont.q];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1496) && (unfoldK#_1496 < Fractions(1)) && ((1000 * unfoldK#_1496) < methodK#_1489);
  assert {:msg "  844.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  844.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  844.10: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  844.10: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assert {:msg "  844.3: The target of the fold statement might be null."} Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  // begin exhale (unfold)
  exhaleMask#_1497 := Mask;
  assert {:msg "  844.3: unfold might fail because the predicate FactorialContChannelImpEP.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  844.3: unfold might fail because the predicate FactorialContChannelImpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannelImpEP.valid."} (Fractions(100) <= exhaleMask#_1497[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1497[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1497[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$N]));
  exhaleMask#_1497[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid] := exhaleMask#_1497[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R := exhaleMask#_1497[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1497);
  Mask := exhaleMask#_1497;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1499 := Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.valid];
  assume IsGoodInhaleState(inhaleHeap#_1499, Heap, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1499[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] := inhaleHeap#_1499[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume !(Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] == null);
  assume Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] != null;
  Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] := inhaleHeap#_1499[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] := Mask[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R := Mask[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume !(Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] == null);
  assume Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch] != null;
  Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] := inhaleHeap#_1499[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] := Mask[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R := Mask[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume !(Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] == null);
  assume Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := inhaleHeap#_1499[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := Mask[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := Mask[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume !(Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
  assume Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp] != null;
  Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := inhaleHeap#_1499[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] := Mask[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R := Mask[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume !(Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] == null);
  assume Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  Heap[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := inhaleHeap#_1499[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu] := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch] != null;
  Heap[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := inhaleHeap#_1499[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu] := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R := Mask[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1499[Heap[Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.ch], FactorialContChannel.exp], FactorialContChannelExpEP.expch], mu]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1499, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1500) && (unfoldK#_1500 < Fractions(1)) && ((1000 * unfoldK#_1500) < methodK#_1489);
  assert {:msg "  845.10: Receiver might be null."} true ==> (this != null);
  assert {:msg "  845.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  845.3: The target of the fold statement might be null."} Heap[this, FactorialCont.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1501 := Mask;
  assert {:msg "  845.3: unfold might fail because the predicate FactorialContChannel.initImpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  845.3: unfold might fail because the predicate FactorialContChannel.initImpState does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.initImpState."} (Fractions(100) <= exhaleMask#_1501[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1501[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1501[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$N]));
  exhaleMask#_1501[Heap[this, FactorialCont.q], FactorialContChannel.initImpState] := exhaleMask#_1501[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R := exhaleMask#_1501[Heap[this, FactorialCont.q], FactorialContChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1501);
  Mask := exhaleMask#_1501;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1503 := Heap[Heap[this, FactorialCont.q], FactorialContChannel.initImpState];
  assume IsGoodInhaleState(inhaleHeap#_1503, Heap, Mask);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] := inhaleHeap#_1503[Heap[this, FactorialCont.q], FactorialContChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] == null) || (dtype(Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1503[Heap[this, FactorialCont.q], FactorialContChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1503, Mask);
  assume Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
  Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state] := inhaleHeap#_1503[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state] := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R := Mask[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1503[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1503, Mask);
  assume Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // local var current
  // assigment to current
  current#88 := null;
  // receive
  assert {:msg "  847.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  847.20: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  847.20: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
  assert {:msg "  847.20: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
  assert {:msg "  847.20: Receiver might be null."} true ==> (Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null);
  assert {:msg "  847.20: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch);
  assert {:msg "  847.20: The channel might be null."} Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] != null;
  assert {:msg "  847.3: receive operation requires a credit"} 0 < Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]];
  assert {:msg "  847.3: The mu field of the channel in the receive statement might not be readable."} CanRead(Mask, Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu);
  assert {:msg "  847.3: The channel must lie above waitlevel in the wait order"} (forall o#_1504: ref :: (((0 < Heap[o#_1504, held]) || Heap[o#_1504, rdheld]) || (Credits[o#_1504] < 0)) ==> MuBelow(Heap[o#_1504, mu], Heap[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch], mu]));
  this#158 := Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch];
  havoc msg#159;
  // inhale (channel where clause)
  havoc inhaleHeap#_1505;
  assume IsGoodInhaleState(inhaleHeap#_1505, Heap, Mask);
  assume !(msg#159 == null);
  assume msg#159 != null;
  Heap[msg#159, Message.type] := inhaleHeap#_1505[msg#159, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume channelK > 0;
  Mask[msg#159, Message.type] := Mask[msg#159, Message.type][perm$R := Mask[msg#159, Message.type][perm$R] + channelK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1505[msg#159, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1505, Mask);
  assume msg#159 != null;
  Heap[msg#159, Message.inv] := inhaleHeap#_1505[msg#159, Message.inv];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1505[msg#159, Message.inv] == Heap;
  assume Fractions(100) > 0;
  Mask[msg#159, Message.inv] := Mask[msg#159, Message.inv][perm$R := Mask[msg#159, Message.inv][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1505[msg#159, Message.inv]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1505, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  current#88 := msg#159;
  Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch]] - 1;
  // if
  assert {:msg "  849.6: Receiver might be null."} true ==> (current#88 != null);
  assert {:msg "  849.6: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.type);
  if (Heap[current#88, Message.type] == 2) {
    assume (0 < methodCallK#_1509) && ((1000 * methodCallK#_1509) < Fractions(1)) && ((1000 * methodCallK#_1509) < methodK#_1489);
    // call receiveResult1
    callHeap#_1506 := Heap;
    callMask#_1507 := Mask;
    callCredits#_1508 := Credits;
    assert {:msg "  850.19: Receiver might be null."} true ==> (this != null);
    assert {:msg "  850.19: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
    assert {:msg "  850.19: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
    assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
    assert {:msg "  850.4: The target of the method call might be null."} Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
    this#160 := Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp];
    mi#161 := current#88;
    // begin exhale (precondition)
    exhaleMask#_1510 := Mask;
    assert {:msg "  850.4: The precondition at 289.11 might not hold. The expression at 289.25 might not evaluate to true."} !(mi#161 == null);
    assert {:msg "  850.4: The precondition at 289.11 might not hold. The expression at 289.57 might not evaluate to true."} Heap[mi#161, Message.type] == 2;
    assert {:msg "  850.4: The precondition at 290.11 might not hold. The expression at 290.11 might not evaluate to true."} Heap[this#160, FactorialContChannelImpEP.state] == 0;
    assert {:msg "  850.4: The precondition at 289.11 might not hold. The permission at 289.11 might not be positive."} Fractions(100) > 0;
    assert {:msg "  850.4: The precondition at 289.11 might not hold. Insufficient fraction at 289.11 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1510[this#160, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1510[this#160, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1510[this#160, FactorialContChannelImpEP.state][perm$N]));
    exhaleMask#_1510[this#160, FactorialContChannelImpEP.state] := exhaleMask#_1510[this#160, FactorialContChannelImpEP.state][perm$R := exhaleMask#_1510[this#160, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1510);
    assert {:msg "  850.4: The precondition at 289.11 might not hold. The permission at 289.37 might not be positive."} monitorK > 0;
    assert {:msg "  850.4: The precondition at 289.11 might not hold. Insufficient fraction at 289.37 for Message.type."} (monitorK <= exhaleMask#_1510[mi#161, Message.type][perm$R]) && ((monitorK == exhaleMask#_1510[mi#161, Message.type][perm$R]) ==> (0 <= exhaleMask#_1510[mi#161, Message.type][perm$N]));
    exhaleMask#_1510[mi#161, Message.type] := exhaleMask#_1510[mi#161, Message.type][perm$R := exhaleMask#_1510[mi#161, Message.type][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1510);
    assert {:msg "  850.4: The precondition at 289.11 might not hold. The permission at 289.71 might not be positive."} Fractions(100) > 0;
    assert {:msg "  850.4: The precondition at 289.11 might not hold. Insufficient fraction at 289.71 for Message.inv."} (Fractions(100) <= exhaleMask#_1510[mi#161, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_1510[mi#161, Message.inv][perm$R]) ==> (0 <= exhaleMask#_1510[mi#161, Message.inv][perm$N]));
    exhaleMask#_1510[mi#161, Message.inv] := exhaleMask#_1510[mi#161, Message.inv][perm$R := exhaleMask#_1510[mi#161, Message.inv][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1510);
    Mask := exhaleMask#_1510;
    assume wf(Heap, Mask);
    // end exhale
    havoc mo#162;
    // inhale (postcondition)
    havoc inhaleHeap#_1516;
    assume IsGoodInhaleState(inhaleHeap#_1516, Heap, Mask);
    assume this#160 != null;
    Heap[this#160, FactorialContChannelImpEP.state] := inhaleHeap#_1516[this#160, FactorialContChannelImpEP.state];
    assume wf(Heap, Mask);
    assume true;
    assume Fractions(100) > 0;
    Mask[this#160, FactorialContChannelImpEP.state] := Mask[this#160, FactorialContChannelImpEP.state][perm$R := Mask[this#160, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1516[this#160, FactorialContChannelImpEP.state]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1516, Mask);
    assume Heap[this#160, FactorialContChannelImpEP.state] == 1;
    assume mo#162 != null;
    Heap[mo#162, Message.type] := inhaleHeap#_1516[mo#162, Message.type];
    assume wf(Heap, Mask);
    assume true;
    assume monitorK > 0;
    Mask[mo#162, Message.type] := Mask[mo#162, Message.type][perm$R := Mask[mo#162, Message.type][perm$R] + monitorK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1516[mo#162, Message.type]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1516, Mask);
    assume mo#162 == mi#161;
    assume Heap[mo#162, Message.type] == 2;
    assume mo#162 != null;
    Heap[mo#162, Message.invResult1] := inhaleHeap#_1516[mo#162, Message.invResult1];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1516[mo#162, Message.invResult1] == Heap;
    assume Fractions(100) > 0;
    Mask[mo#162, Message.invResult1] := Mask[mo#162, Message.invResult1][perm$R := Mask[mo#162, Message.invResult1][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1516[mo#162, Message.invResult1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1516, Mask);
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    current#88 := mo#162;
    // unfold
    assume (0 < unfoldK#_1517) && (unfoldK#_1517 < Fractions(1)) && ((1000 * unfoldK#_1517) < methodK#_1489);
    assert {:msg "  851.4: The target of the fold statement might be null."} current#88 != null;
    // begin exhale (unfold)
    exhaleMask#_1518 := Mask;
    assert {:msg "  851.4: unfold might fail because the predicate Message.invResult1 does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
    assert {:msg "  851.4: unfold might fail because the predicate Message.invResult1 does not hold. Insufficient fraction at <undefined position> for Message.invResult1."} (Fractions(100) <= exhaleMask#_1518[current#88, Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_1518[current#88, Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_1518[current#88, Message.invResult1][perm$N]));
    exhaleMask#_1518[current#88, Message.invResult1] := exhaleMask#_1518[current#88, Message.invResult1][perm$R := exhaleMask#_1518[current#88, Message.invResult1][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1518);
    Mask := exhaleMask#_1518;
    assume wf(Heap, Mask);
    // end exhale
    // inhale (unfold)
    inhaleHeap#_1520 := Heap[current#88, Message.invResult1];
    assume IsGoodInhaleState(inhaleHeap#_1520, Heap, Mask);
    assume current#88 != null;
    Heap[current#88, Message.sender2] := inhaleHeap#_1520[current#88, Message.sender2];
    assume wf(Heap, Mask);
    assume (Heap[current#88, Message.sender2] == null) || (dtype(Heap[current#88, Message.sender2]) == Future#t);
    assume predicateK > 0;
    Mask[current#88, Message.sender2] := Mask[current#88, Message.sender2][perm$R := Mask[current#88, Message.sender2][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[current#88, Message.sender2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume current#88 != null;
    Heap[current#88, Message.receiver2] := inhaleHeap#_1520[current#88, Message.receiver2];
    assume wf(Heap, Mask);
    assume (Heap[current#88, Message.receiver2] == null) || (dtype(Heap[current#88, Message.receiver2]) == FactorialCont#t);
    assume predicateK > 0;
    Mask[current#88, Message.receiver2] := Mask[current#88, Message.receiver2][perm$R := Mask[current#88, Message.receiver2][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[current#88, Message.receiver2]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume current#88 != null;
    Heap[current#88, Message.vr1] := inhaleHeap#_1520[current#88, Message.vr1];
    assume wf(Heap, Mask);
    assume true;
    assume predicateK > 0;
    Mask[current#88, Message.vr1] := Mask[current#88, Message.vr1][perm$R := Mask[current#88, Message.vr1][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[current#88, Message.vr1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume current#88 != null;
    Heap[current#88, Message.old1] := inhaleHeap#_1520[current#88, Message.old1];
    assume wf(Heap, Mask);
    assume (Heap[current#88, Message.old1] == null) || (dtype(Heap[current#88, Message.old1]) == FactorialActor#t);
    assume predicateK > 0;
    Mask[current#88, Message.old1] := Mask[current#88, Message.old1][perm$R := Mask[current#88, Message.old1][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[current#88, Message.old1]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume !(Heap[current#88, Message.sender2] == null);
    assume Heap[current#88, Message.sender2] != null;
    Heap[Heap[current#88, Message.sender2], Future.q] := inhaleHeap#_1520[Heap[current#88, Message.sender2], Future.q];
    assume wf(Heap, Mask);
    assume (Heap[Heap[current#88, Message.sender2], Future.q] == null) || (dtype(Heap[Heap[current#88, Message.sender2], Future.q]) == FutureChannel#t);
    assume predicateK > 0;
    Mask[Heap[current#88, Message.sender2], Future.q] := Mask[Heap[current#88, Message.sender2], Future.q][perm$R := Mask[Heap[current#88, Message.sender2], Future.q][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[Heap[current#88, Message.sender2], Future.q]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume !(Heap[Heap[current#88, Message.sender2], Future.q] == null);
    assume Heap[Heap[current#88, Message.sender2], Future.q] != null;
    Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid] := inhaleHeap#_1520[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1520[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid] := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.valid]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume Heap[Heap[current#88, Message.sender2], Future.q] != null;
    Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState] := inhaleHeap#_1520[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState];
    assume wf(Heap, Mask);
    assume inhaleHeap#_1520[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState] == Heap;
    assume Fractions(100) > 0;
    Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume Heap[current#88, Message.vr1] == #Message.factorial(Heap, Mask, current#88, 0);
    assume Heap[current#88, Message.receiver2] != null;
    Heap[Heap[current#88, Message.receiver2], FactorialCont.v] := inhaleHeap#_1520[Heap[current#88, Message.receiver2], FactorialCont.v];
    assume wf(Heap, Mask);
    assume true;
    assume predicateK > 0;
    Mask[Heap[current#88, Message.receiver2], FactorialCont.v] := Mask[Heap[current#88, Message.receiver2], FactorialCont.v][perm$R := Mask[Heap[current#88, Message.receiver2], FactorialCont.v][perm$R] + predicateK];
    assume IsGoodMask(Mask);
    assume IsGoodState(inhaleHeap#_1520[Heap[current#88, Message.receiver2], FactorialCont.v]);
    assume wf(Heap, Mask);
    assume wf(inhaleHeap#_1520, Mask);
    assume !(Heap[current#88, Message.receiver2] == null);
    assume Heap[Heap[current#88, Message.receiver2], FactorialCont.v] == 1;
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    // end inhale
    // if
    assert {:msg "  852.7: Receiver might be null."} true ==> (this != null);
    assert {:msg "  852.7: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
    if (Heap[this, FactorialCont.cust] == null) {
      // local var m
      // assigment to m
      // new
      havoc nw#_1521;
      assume (nw#_1521 != null) && (dtype(nw#_1521) == Message#t);
      assume (forall<T#_21> f: Field (T#_21) :: (Mask[nw#_1521, f][perm$R] == 0) && (Mask[nw#_1521, f][perm$N] == 0));
      assume Heap[nw#_1521, mu] == $LockBottom;
      assume Heap[nw#_1521, held] <= 0;
      assume Heap[nw#_1521, rdheld] == false;
      Mask[nw#_1521, Message.type] := Mask[nw#_1521, Message.type][perm$R := Mask[nw#_1521, Message.type][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.sender1] := Mask[nw#_1521, Message.sender1][perm$R := Mask[nw#_1521, Message.sender1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.sender3] := Mask[nw#_1521, Message.sender3][perm$R := Mask[nw#_1521, Message.sender3][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.sender2] := Mask[nw#_1521, Message.sender2][perm$R := Mask[nw#_1521, Message.sender2][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.sender4] := Mask[nw#_1521, Message.sender4][perm$R := Mask[nw#_1521, Message.sender4][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.receiver1] := Mask[nw#_1521, Message.receiver1][perm$R := Mask[nw#_1521, Message.receiver1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.receiver2] := Mask[nw#_1521, Message.receiver2][perm$R := Mask[nw#_1521, Message.receiver2][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.receiver3] := Mask[nw#_1521, Message.receiver3][perm$R := Mask[nw#_1521, Message.receiver3][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.receiver4] := Mask[nw#_1521, Message.receiver4][perm$R := Mask[nw#_1521, Message.receiver4][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.v1] := Mask[nw#_1521, Message.v1][perm$R := Mask[nw#_1521, Message.v1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.vo1] := Mask[nw#_1521, Message.vo1][perm$R := Mask[nw#_1521, Message.vo1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.cust1] := Mask[nw#_1521, Message.cust1][perm$R := Mask[nw#_1521, Message.cust1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.vr1] := Mask[nw#_1521, Message.vr1][perm$R := Mask[nw#_1521, Message.vr1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.old1] := Mask[nw#_1521, Message.old1][perm$R := Mask[nw#_1521, Message.old1][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.vr2] := Mask[nw#_1521, Message.vr2][perm$R := Mask[nw#_1521, Message.vr2][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.old2] := Mask[nw#_1521, Message.old2][perm$R := Mask[nw#_1521, Message.old2][perm$R] + Fractions(100)];
      Mask[nw#_1521, Message.vr3] := Mask[nw#_1521, Message.vr3][perm$R := Mask[nw#_1521, Message.vr3][perm$R] + Fractions(100)];
      Mask[nw#_1521, mu] := Mask[nw#_1521, mu][perm$R := Mask[nw#_1521, mu][perm$R] + Fractions(100)];
      m#90 := nw#_1521;
      // update field sender4
      assert {:msg "  855.5: Location might not be writable"} CanWrite(Mask, m#90, Message.sender4);
      Heap[m#90, Message.sender4] := this;
      assume wf(Heap, Mask);
      assume (0 < methodCallK#_1525) && ((1000 * methodCallK#_1525) < Fractions(1)) && ((1000 * methodCallK#_1525) < methodK#_1489);
      // call setFinalResult
      callHeap#_1522 := Heap;
      callMask#_1523 := Mask;
      callCredits#_1524 := Credits;
      assert {:msg "  857.5: The target of the method call might be null."} m#90 != null;
      assert {:msg "  857.27: Receiver might be null."} true ==> (current#88 != null);
      assert {:msg "  857.27: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.vr1);
      assert {:msg "  857.39: Receiver might be null."} true ==> (this != null);
      assert {:msg "  857.39: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
      assert {:msg "  857.42: Receiver might be null."} true ==> (current#88 != null);
      assert {:msg "  857.42: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender2);
      this#163 := m#90;
      vr#164 := Heap[current#88, Message.vr1] * Heap[this, FactorialCont.v];
      receiver#165 := Heap[current#88, Message.sender2];
      // begin exhale (precondition)
      exhaleMask#_1526 := Mask;
      if (!(Heap[this#163, Message.sender4] == null)) {
        assert {:msg "  857.5: The precondition at 709.11 might not hold. The expression at 710.45 might not evaluate to true."} !(Heap[Heap[this#163, Message.sender4], FactorialCont.q] == null);
      } else {
      }
      assert {:msg "  857.5: The precondition at 709.11 might not hold. The permission at 709.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  857.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.11 for Message.type."} (Fractions(100) <= exhaleMask#_1526[this#163, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1526[this#163, Message.type][perm$R]) ==> (0 <= exhaleMask#_1526[this#163, Message.type][perm$N]));
      exhaleMask#_1526[this#163, Message.type] := exhaleMask#_1526[this#163, Message.type][perm$R := exhaleMask#_1526[this#163, Message.type][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1526);
      assert {:msg "  857.5: The precondition at 709.11 might not hold. The permission at 709.24 might not be positive."} Fractions(100) > 0;
      assert {:msg "  857.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.24 for Message.sender4."} (Fractions(100) <= exhaleMask#_1526[this#163, Message.sender4][perm$R]) && ((Fractions(100) == exhaleMask#_1526[this#163, Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1526[this#163, Message.sender4][perm$N]));
      exhaleMask#_1526[this#163, Message.sender4] := exhaleMask#_1526[this#163, Message.sender4][perm$R := exhaleMask#_1526[this#163, Message.sender4][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1526);
      assert {:msg "  857.5: The precondition at 709.11 might not hold. The permission at 709.40 might not be positive."} Fractions(100) > 0;
      assert {:msg "  857.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.40 for Message.receiver4."} (Fractions(100) <= exhaleMask#_1526[this#163, Message.receiver4][perm$R]) && ((Fractions(100) == exhaleMask#_1526[this#163, Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1526[this#163, Message.receiver4][perm$N]));
      exhaleMask#_1526[this#163, Message.receiver4] := exhaleMask#_1526[this#163, Message.receiver4][perm$R := exhaleMask#_1526[this#163, Message.receiver4][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1526);
      assert {:msg "  857.5: The precondition at 709.11 might not hold. The permission at 709.58 might not be positive."} Fractions(100) > 0;
      assert {:msg "  857.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.58 for Message.vr3."} (Fractions(100) <= exhaleMask#_1526[this#163, Message.vr3][perm$R]) && ((Fractions(100) == exhaleMask#_1526[this#163, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1526[this#163, Message.vr3][perm$N]));
      exhaleMask#_1526[this#163, Message.vr3] := exhaleMask#_1526[this#163, Message.vr3][perm$R := exhaleMask#_1526[this#163, Message.vr3][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1526);
      if (!(Heap[this#163, Message.sender4] == null)) {
        assert {:msg "  857.5: The precondition at 709.11 might not hold. The permission at 710.23 might not be positive."} monitorK > 0;
        assert {:msg "  857.5: The precondition at 709.11 might not hold. Insufficient fraction at 710.23 for FactorialCont.q."} (monitorK <= exhaleMask#_1526[Heap[this#163, Message.sender4], FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1526[Heap[this#163, Message.sender4], FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1526[Heap[this#163, Message.sender4], FactorialCont.q][perm$N]));
        exhaleMask#_1526[Heap[this#163, Message.sender4], FactorialCont.q] := exhaleMask#_1526[Heap[this#163, Message.sender4], FactorialCont.q][perm$R := exhaleMask#_1526[Heap[this#163, Message.sender4], FactorialCont.q][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1526);
      } else {
      }
      Mask := exhaleMask#_1526;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_1534;
      assume IsGoodInhaleState(inhaleHeap#_1534, Heap, Mask);
      assume this#163 != null;
      Heap[this#163, Message.invFinalResult] := inhaleHeap#_1534[this#163, Message.invFinalResult];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1534[this#163, Message.invFinalResult] == Heap;
      assume Fractions(100) > 0;
      Mask[this#163, Message.invFinalResult] := Mask[this#163, Message.invFinalResult][perm$R := Mask[this#163, Message.invFinalResult][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1534[this#163, Message.invFinalResult]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1534, Mask);
      assume this#163 != null;
      Heap[this#163, Message.type] := inhaleHeap#_1534[this#163, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[this#163, Message.type] := Mask[this#163, Message.type][perm$R := Mask[this#163, Message.type][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1534[this#163, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1534, Mask);
      assume this#163 != null;
      Heap[this#163, Message.type] := inhaleHeap#_1534[this#163, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[this#163, Message.type] := Mask[this#163, Message.type][perm$R := Mask[this#163, Message.type][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1534[this#163, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1534, Mask);
      assume Heap[this#163, Message.type] == 4;
      assume this#163 != null;
      Heap[this#163, Message.vr3] := inhaleHeap#_1534[this#163, Message.vr3];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[this#163, Message.vr3] := Mask[this#163, Message.vr3][perm$R := Mask[this#163, Message.vr3][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1534[this#163, Message.vr3]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1534, Mask);
      assume Heap[this#163, Message.vr3] == vr#164;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // unfold
      assume (0 < unfoldK#_1535) && (unfoldK#_1535 < Fractions(1)) && ((1000 * unfoldK#_1535) < methodK#_1489);
      assert {:msg "  858.5: The target of the fold statement might be null."} m#90 != null;
      // begin exhale (unfold)
      exhaleMask#_1536 := Mask;
      assert {:msg "  858.5: unfold might fail because the predicate Message.invFinalResult does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
      assert {:msg "  858.5: unfold might fail because the predicate Message.invFinalResult does not hold. Insufficient fraction at <undefined position> for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1536[m#90, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1536[m#90, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1536[m#90, Message.invFinalResult][perm$N]));
      exhaleMask#_1536[m#90, Message.invFinalResult] := exhaleMask#_1536[m#90, Message.invFinalResult][perm$R := exhaleMask#_1536[m#90, Message.invFinalResult][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1536);
      Mask := exhaleMask#_1536;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (unfold)
      inhaleHeap#_1538 := Heap[m#90, Message.invFinalResult];
      assume IsGoodInhaleState(inhaleHeap#_1538, Heap, Mask);
      assume m#90 != null;
      Heap[m#90, Message.sender4] := inhaleHeap#_1538[m#90, Message.sender4];
      assume wf(Heap, Mask);
      assume (Heap[m#90, Message.sender4] == null) || (dtype(Heap[m#90, Message.sender4]) == FactorialCont#t);
      assume predicateK > 0;
      Mask[m#90, Message.sender4] := Mask[m#90, Message.sender4][perm$R := Mask[m#90, Message.sender4][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1538[m#90, Message.sender4]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1538, Mask);
      assume m#90 != null;
      Heap[m#90, Message.receiver4] := inhaleHeap#_1538[m#90, Message.receiver4];
      assume wf(Heap, Mask);
      assume (Heap[m#90, Message.receiver4] == null) || (dtype(Heap[m#90, Message.receiver4]) == Future#t);
      assume predicateK > 0;
      Mask[m#90, Message.receiver4] := Mask[m#90, Message.receiver4][perm$R := Mask[m#90, Message.receiver4][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1538[m#90, Message.receiver4]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1538, Mask);
      assume m#90 != null;
      Heap[m#90, Message.vr3] := inhaleHeap#_1538[m#90, Message.vr3];
      assume wf(Heap, Mask);
      assume true;
      assume predicateK > 0;
      Mask[m#90, Message.vr3] := Mask[m#90, Message.vr3][perm$R := Mask[m#90, Message.vr3][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1538[m#90, Message.vr3]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1538, Mask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // assert
      Heap#_1542 := Heap;
      Mask#_1543 := Mask;
      Credits#_1544 := Credits;
      // begin exhale (assert)
      exhaleMask#_1545 := Mask#_1543;
      assert {:msg "  860.12: Receiver might be null."} true ==> (m#90 != null);
      assert {:msg "  860.12: Location might not be readable."} true ==> CanRead(Mask#_1543, m#90, Message.vr3);
      assert {:msg "  860.31: Receiver might be null."} true ==> (this != null);
      assert {:msg "  860.31: Location might not be readable."} true ==> CanRead(Mask#_1543, this, FactorialCont.vo);
      assert {:msg "  860.19: Receiver might be null."} true ==> (m#90 != null);
      // check precondition of call
      assume (0 < funcappK#_1552) && ((1000 * funcappK#_1552) < Fractions(1));
      assume true;
      Heap#_1549 := Heap#_1542;
      Mask#_1550 := Mask#_1543;
      Credits#_1551 := Credits#_1544;
      // begin exhale (function call)
      exhaleMask#_1553 := Mask#_1550;
      assert {:msg "  860.19: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1549[this, FactorialCont.vo] >= 0;
      Mask#_1550 := exhaleMask#_1553;
      assume wf(Heap#_1549, Mask#_1550);
      // end exhale
      assert {:msg "  860.5: Assertion might not hold. The expression at 860.12 might not evaluate to true."} Heap#_1542[m#90, Message.vr3] == #Message.factorial(Heap#_1542, Mask#_1543, m#90, Heap#_1542[this, FactorialCont.vo]);
      Mask#_1543 := exhaleMask#_1545;
      assume wf(Heap#_1542, Mask#_1543);
      // end exhale
      // fold
      assume (0 < foldK#_1554) && ((1000 * foldK#_1554) < Fractions(1)) && ((1000 * foldK#_1554) < methodK#_1489);
      assert {:msg "  861.5: The target of the fold statement might be null."} m#90 != null;
      // begin exhale (fold)
      exhaleMask#_1555 := Mask;
      assert {:msg "  861.5: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.3 might not be positive."} predicateK > 0;
      assert {:msg "  861.5: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.3 for Message.sender4."} (predicateK <= exhaleMask#_1555[m#90, Message.sender4][perm$R]) && ((predicateK == exhaleMask#_1555[m#90, Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1555[m#90, Message.sender4][perm$N]));
      exhaleMask#_1555[m#90, Message.sender4] := exhaleMask#_1555[m#90, Message.sender4][perm$R := exhaleMask#_1555[m#90, Message.sender4][perm$R] - predicateK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1555);
      assert {:msg "  861.5: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.18 might not be positive."} predicateK > 0;
      assert {:msg "  861.5: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.18 for Message.receiver4."} (predicateK <= exhaleMask#_1555[m#90, Message.receiver4][perm$R]) && ((predicateK == exhaleMask#_1555[m#90, Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1555[m#90, Message.receiver4][perm$N]));
      exhaleMask#_1555[m#90, Message.receiver4] := exhaleMask#_1555[m#90, Message.receiver4][perm$R := exhaleMask#_1555[m#90, Message.receiver4][perm$R] - predicateK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1555);
      assert {:msg "  861.5: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.35 might not be positive."} predicateK > 0;
      assert {:msg "  861.5: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.35 for Message.vr3."} (predicateK <= exhaleMask#_1555[m#90, Message.vr3][perm$R]) && ((predicateK == exhaleMask#_1555[m#90, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1555[m#90, Message.vr3][perm$N]));
      exhaleMask#_1555[m#90, Message.vr3] := exhaleMask#_1555[m#90, Message.vr3][perm$R := exhaleMask#_1555[m#90, Message.vr3][perm$R] - predicateK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1555);
      Mask := exhaleMask#_1555;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (fold)
      havoc inhaleHeap#_1559;
      assume IsGoodInhaleState(inhaleHeap#_1559, Heap, Mask);
      assume m#90 != null;
      Heap[m#90, Message.invFinalResult] := inhaleHeap#_1559[m#90, Message.invFinalResult];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1559[m#90, Message.invFinalResult] == Heap;
      assume Fractions(100) > 0;
      Mask[m#90, Message.invFinalResult] := Mask[m#90, Message.invFinalResult][perm$R := Mask[m#90, Message.invFinalResult][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1559[m#90, Message.invFinalResult]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1559, Mask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      Heap[m#90, Message.invFinalResult] := Heap;
      assume wf(Heap, Mask);
      // unfold
      assume (0 < unfoldK#_1560) && (unfoldK#_1560 < Fractions(1)) && ((1000 * unfoldK#_1560) < methodK#_1489);
      assert {:msg "  862.12: Receiver might be null."} true ==> (current#88 != null);
      assert {:msg "  862.12: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender2);
      assert {:msg "  862.12: Receiver might be null."} true ==> (Heap[current#88, Message.sender2] != null);
      assert {:msg "  862.12: Location might not be readable."} true ==> CanRead(Mask, Heap[current#88, Message.sender2], Future.q);
      assert {:msg "  862.5: The target of the fold statement might be null."} Heap[Heap[current#88, Message.sender2], Future.q] != null;
      // begin exhale (unfold)
      exhaleMask#_1561 := Mask;
      assert {:msg "  862.5: unfold might fail because the predicate FutureChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
      assert {:msg "  862.5: unfold might fail because the predicate FutureChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1561[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1561[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1561[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$N]));
      exhaleMask#_1561[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState] := exhaleMask#_1561[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1561[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1561);
      Mask := exhaleMask#_1561;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (unfold)
      inhaleHeap#_1563 := Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState];
      assume IsGoodInhaleState(inhaleHeap#_1563, Heap, Mask);
      assume Heap[Heap[current#88, Message.sender2], Future.q] != null;
      Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] := inhaleHeap#_1563[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp];
      assume wf(Heap, Mask);
      assume (Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] == null) || (dtype(Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp]) == FutureChannelExpEP#t);
      assume monitorK > 0;
      Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp][perm$R := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1563[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1563, Mask);
      assume Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] != null;
      Heap[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state] := inhaleHeap#_1563[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state] := Mask[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state][perm$R := Mask[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1563[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1563, Mask);
      assume Heap[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state] == 0;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      assume (0 < methodCallK#_1567) && ((1000 * methodCallK#_1567) < Fractions(1)) && ((1000 * methodCallK#_1567) < methodK#_1489);
      // call sendFinalResult
      callHeap#_1564 := Heap;
      callMask#_1565 := Mask;
      callCredits#_1566 := Credits;
      assert {:msg "  863.10: Receiver might be null."} true ==> (current#88 != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender2);
      assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[current#88, Message.sender2] != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[current#88, Message.sender2], Future.q);
      assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[current#88, Message.sender2], Future.q] != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp);
      assert {:msg "  863.5: The target of the method call might be null."} Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] != null;
      this#166 := Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp];
      m#167 := m#90;
      // begin exhale (precondition)
      exhaleMask#_1568 := Mask;
      assert {:msg "  863.5: The precondition at 400.11 might not hold. The expression at 400.63 might not evaluate to true."} Heap[m#167, Message.type] == 4;
      assert {:msg "  863.5: The precondition at 402.11 might not hold. The expression at 402.11 might not evaluate to true."} Heap[this#166, FutureChannelExpEP.state] == 0;
      assert {:msg "  863.5: The precondition at 400.11 might not hold. The permission at 400.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  863.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.11 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1568[this#166, FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1568[this#166, FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1568[this#166, FutureChannelExpEP.state][perm$N]));
      exhaleMask#_1568[this#166, FutureChannelExpEP.state] := exhaleMask#_1568[this#166, FutureChannelExpEP.state][perm$R := exhaleMask#_1568[this#166, FutureChannelExpEP.state][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1568);
      assert {:msg "  863.5: The precondition at 400.11 might not hold. The permission at 400.25 might not be positive."} monitorK > 0;
      assert {:msg "  863.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.25 for Message.type."} (monitorK <= exhaleMask#_1568[m#167, Message.type][perm$R]) && ((monitorK == exhaleMask#_1568[m#167, Message.type][perm$R]) ==> (0 <= exhaleMask#_1568[m#167, Message.type][perm$N]));
      exhaleMask#_1568[m#167, Message.type] := exhaleMask#_1568[m#167, Message.type][perm$R := exhaleMask#_1568[m#167, Message.type][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1568);
      assert {:msg "  863.5: The precondition at 400.11 might not hold. The permission at 400.44 might not be positive."} monitorK > 0;
      assert {:msg "  863.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.44 for Message.type."} (monitorK <= exhaleMask#_1568[m#167, Message.type][perm$R]) && ((monitorK == exhaleMask#_1568[m#167, Message.type][perm$R]) ==> (0 <= exhaleMask#_1568[m#167, Message.type][perm$N]));
      exhaleMask#_1568[m#167, Message.type] := exhaleMask#_1568[m#167, Message.type][perm$R := exhaleMask#_1568[m#167, Message.type][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1568);
      assert {:msg "  863.5: The precondition at 400.11 might not hold. The permission at 400.76 might not be positive."} Fractions(100) > 0;
      assert {:msg "  863.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.76 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1568[m#167, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1568[m#167, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1568[m#167, Message.invFinalResult][perm$N]));
      exhaleMask#_1568[m#167, Message.invFinalResult] := exhaleMask#_1568[m#167, Message.invFinalResult][perm$R := exhaleMask#_1568[m#167, Message.invFinalResult][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1568);
      assert {:msg "  863.5: The precondition at 401.11 might not hold. The permission at 401.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  863.5: The precondition at 401.11 might not hold. Insufficient fraction at 401.11 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1568[this#166, FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1568[this#166, FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1568[this#166, FutureChannelExpEP.valid][perm$N]));
      exhaleMask#_1568[this#166, FutureChannelExpEP.valid] := exhaleMask#_1568[this#166, FutureChannelExpEP.valid][perm$R := exhaleMask#_1568[this#166, FutureChannelExpEP.valid][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1568);
      Mask := exhaleMask#_1568;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_1576;
      assume IsGoodInhaleState(inhaleHeap#_1576, Heap, Mask);
      assume this#166 != null;
      Heap[this#166, FutureChannelExpEP.state] := inhaleHeap#_1576[this#166, FutureChannelExpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[this#166, FutureChannelExpEP.state] := Mask[this#166, FutureChannelExpEP.state][perm$R := Mask[this#166, FutureChannelExpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1576[this#166, FutureChannelExpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1576, Mask);
      assume this#166 != null;
      Heap[this#166, FutureChannelExpEP.valid] := inhaleHeap#_1576[this#166, FutureChannelExpEP.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1576[this#166, FutureChannelExpEP.valid] == Heap;
      assume Fractions(100) > 0;
      Mask[this#166, FutureChannelExpEP.valid] := Mask[this#166, FutureChannelExpEP.valid][perm$R := Mask[this#166, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1576[this#166, FutureChannelExpEP.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1576, Mask);
      if (callHeap#_1564[this#166, FutureChannelExpEP.state] == 0) {
        assume Heap[this#166, FutureChannelExpEP.state] == 1;
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
    } else {
      // local var m
      // assigment to m
      // new
      havoc nw#_1577;
      assume (nw#_1577 != null) && (dtype(nw#_1577) == Message#t);
      assume (forall<T#_22> f: Field (T#_22) :: (Mask[nw#_1577, f][perm$R] == 0) && (Mask[nw#_1577, f][perm$N] == 0));
      assume Heap[nw#_1577, mu] == $LockBottom;
      assume Heap[nw#_1577, held] <= 0;
      assume Heap[nw#_1577, rdheld] == false;
      Mask[nw#_1577, Message.type] := Mask[nw#_1577, Message.type][perm$R := Mask[nw#_1577, Message.type][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.sender1] := Mask[nw#_1577, Message.sender1][perm$R := Mask[nw#_1577, Message.sender1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.sender3] := Mask[nw#_1577, Message.sender3][perm$R := Mask[nw#_1577, Message.sender3][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.sender2] := Mask[nw#_1577, Message.sender2][perm$R := Mask[nw#_1577, Message.sender2][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.sender4] := Mask[nw#_1577, Message.sender4][perm$R := Mask[nw#_1577, Message.sender4][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.receiver1] := Mask[nw#_1577, Message.receiver1][perm$R := Mask[nw#_1577, Message.receiver1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.receiver2] := Mask[nw#_1577, Message.receiver2][perm$R := Mask[nw#_1577, Message.receiver2][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.receiver3] := Mask[nw#_1577, Message.receiver3][perm$R := Mask[nw#_1577, Message.receiver3][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.receiver4] := Mask[nw#_1577, Message.receiver4][perm$R := Mask[nw#_1577, Message.receiver4][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.v1] := Mask[nw#_1577, Message.v1][perm$R := Mask[nw#_1577, Message.v1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.vo1] := Mask[nw#_1577, Message.vo1][perm$R := Mask[nw#_1577, Message.vo1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.cust1] := Mask[nw#_1577, Message.cust1][perm$R := Mask[nw#_1577, Message.cust1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.vr1] := Mask[nw#_1577, Message.vr1][perm$R := Mask[nw#_1577, Message.vr1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.old1] := Mask[nw#_1577, Message.old1][perm$R := Mask[nw#_1577, Message.old1][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.vr2] := Mask[nw#_1577, Message.vr2][perm$R := Mask[nw#_1577, Message.vr2][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.old2] := Mask[nw#_1577, Message.old2][perm$R := Mask[nw#_1577, Message.old2][perm$R] + Fractions(100)];
      Mask[nw#_1577, Message.vr3] := Mask[nw#_1577, Message.vr3][perm$R := Mask[nw#_1577, Message.vr3][perm$R] + Fractions(100)];
      Mask[nw#_1577, mu] := Mask[nw#_1577, mu][perm$R := Mask[nw#_1577, mu][perm$R] + Fractions(100)];
      m#92 := nw#_1577;
      // update field sender3
      assert {:msg "  869.5: Location might not be writable"} CanWrite(Mask, m#92, Message.sender3);
      assert {:msg "  869.16: Receiver might be null."} true ==> (current#88 != null);
      assert {:msg "  869.16: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender2);
      Heap[m#92, Message.sender3] := Heap[current#88, Message.sender2];
      assume wf(Heap, Mask);
      // assert
      Heap#_1581 := Heap;
      Mask#_1582 := Mask;
      Credits#_1583 := Credits;
      // begin exhale (assert)
      exhaleMask#_1584 := Mask#_1582;
      assert {:msg "  870.5: Assertion might not hold. The target of the acc predicate at 870.12 might be null."} this != null;
      assert {:msg "  870.5: Assertion might not hold. The permission at 870.12 might not be positive."} methodK#_1489 > 0;
      assert {:msg "  870.5: Assertion might not hold. Insufficient fraction at 870.12 for FactorialCont.v."} (methodK#_1489 <= exhaleMask#_1584[this, FactorialCont.v][perm$R]) && ((methodK#_1489 == exhaleMask#_1584[this, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1584[this, FactorialCont.v][perm$N]));
      exhaleMask#_1584[this, FactorialCont.v] := exhaleMask#_1584[this, FactorialCont.v][perm$R := exhaleMask#_1584[this, FactorialCont.v][perm$R] - methodK#_1489];
      assume IsGoodMask(Mask#_1582);
      assume wf(Heap#_1581, Mask#_1582);
      assume wf(Heap#_1581, exhaleMask#_1584);
      Mask#_1582 := exhaleMask#_1584;
      assume wf(Heap#_1581, Mask#_1582);
      // end exhale
      // assert
      Heap#_1589 := Heap;
      Mask#_1590 := Mask;
      Credits#_1591 := Credits;
      // begin exhale (assert)
      exhaleMask#_1592 := Mask#_1590;
      assert {:msg "  871.5: Assertion might not hold. The target of the acc predicate at 871.12 might be null."} this != null;
      assert {:msg "  871.5: Assertion might not hold. The permission at 871.12 might not be positive."} monitorK > 0;
      assert {:msg "  871.5: Assertion might not hold. Insufficient fraction at 871.12 for FactorialCont.v."} (monitorK <= exhaleMask#_1592[this, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1592[this, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1592[this, FactorialCont.v][perm$N]));
      exhaleMask#_1592[this, FactorialCont.v] := exhaleMask#_1592[this, FactorialCont.v][perm$R := exhaleMask#_1592[this, FactorialCont.v][perm$R] - monitorK];
      assume IsGoodMask(Mask#_1590);
      assume wf(Heap#_1589, Mask#_1590);
      assume wf(Heap#_1589, exhaleMask#_1592);
      Mask#_1590 := exhaleMask#_1592;
      assume wf(Heap#_1589, Mask#_1590);
      // end exhale
      assume (0 < methodCallK#_1597) && ((1000 * methodCallK#_1597) < Fractions(1)) && ((1000 * methodCallK#_1597) < methodK#_1489);
      // call setResult2
      callHeap#_1594 := Heap;
      callMask#_1595 := Mask;
      callCredits#_1596 := Credits;
      assert {:msg "  872.5: The target of the method call might be null."} m#92 != null;
      assert {:msg "  872.23: Receiver might be null."} true ==> (current#88 != null);
      assert {:msg "  872.23: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.vr1);
      assert {:msg "  872.35: Receiver might be null."} true ==> (this != null);
      assert {:msg "  872.35: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
      assert {:msg "  872.44: Receiver might be null."} true ==> (this != null);
      assert {:msg "  872.44: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
      this#168 := m#92;
      v#169 := Heap[current#88, Message.vr1] * Heap[this, FactorialCont.v];
      oldv#170 := this;
      receiver#171 := Heap[this, FactorialCont.cust];
      // begin exhale (precondition)
      exhaleMask#_1598 := Mask;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 694.28 might not evaluate to true."} !(oldv#170 == null);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 694.42 might not be positive."} methodCallK#_1597 > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.42 for FactorialCont.v."} exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R] > 0;
      assume methodCallK#_1597 < exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R];
      exhaleMask#_1598[oldv#170, FactorialCont.v] := exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R := exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R] - methodCallK#_1597];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 694.56 might not be positive."} methodCallK#_1597 > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.56 for FactorialCont.cust."} exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R] > 0;
      assume methodCallK#_1597 < exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R];
      exhaleMask#_1598[oldv#170, FactorialCont.cust] := exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R := exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R] - methodCallK#_1597];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 695.3 might not be positive."} methodCallK#_1597 > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 695.3 for FactorialCont.vo."} exhaleMask#_1598[Heap[oldv#170, FactorialCont.cust], FactorialCont.vo][perm$R] > 0;
      assume methodCallK#_1597 < exhaleMask#_1598[Heap[oldv#170, FactorialCont.cust], FactorialCont.vo][perm$R];
      exhaleMask#_1598[Heap[oldv#170, FactorialCont.cust], FactorialCont.vo] := exhaleMask#_1598[Heap[oldv#170, FactorialCont.cust], FactorialCont.vo][perm$R := exhaleMask#_1598[Heap[oldv#170, FactorialCont.cust], FactorialCont.vo][perm$R] - methodCallK#_1597];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 695.23 might not be positive."} methodCallK#_1597 > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 695.23 for FactorialCont.vo."} exhaleMask#_1598[receiver#171, FactorialCont.vo][perm$R] > 0;
      assume methodCallK#_1597 < exhaleMask#_1598[receiver#171, FactorialCont.vo][perm$R];
      exhaleMask#_1598[receiver#171, FactorialCont.vo] := exhaleMask#_1598[receiver#171, FactorialCont.vo][perm$R := exhaleMask#_1598[receiver#171, FactorialCont.vo][perm$R] - methodCallK#_1597];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 696.4 might not evaluate to true."} !(Heap[this#168, Message.sender3] == null);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 696.43 might not evaluate to true."} !(Heap[Heap[this#168, Message.sender3], Future.q] == null);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 698.25 might not evaluate to true."} Heap[oldv#170, FactorialCont.v] >= 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 698.38 might not evaluate to true."} Heap[oldv#170, FactorialCont.vo] >= 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 698.52 might not evaluate to true."} v#169 == #Message.factorial(Heap, Mask, this#168, Heap[oldv#170, FactorialCont.v]);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The expression at 698.76 might not evaluate to true."} Heap[oldv#170, FactorialCont.cust] == receiver#171;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 693.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 693.11 for Message.type."} (Fractions(100) <= exhaleMask#_1598[this#168, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1598[this#168, Message.type][perm$R]) ==> (0 <= exhaleMask#_1598[this#168, Message.type][perm$N]));
      exhaleMask#_1598[this#168, Message.type] := exhaleMask#_1598[this#168, Message.type][perm$R := exhaleMask#_1598[this#168, Message.type][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 693.25 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 693.25 for Message.sender3."} (Fractions(100) <= exhaleMask#_1598[this#168, Message.sender3][perm$R]) && ((Fractions(100) == exhaleMask#_1598[this#168, Message.sender3][perm$R]) ==> (0 <= exhaleMask#_1598[this#168, Message.sender3][perm$N]));
      exhaleMask#_1598[this#168, Message.sender3] := exhaleMask#_1598[this#168, Message.sender3][perm$R := exhaleMask#_1598[this#168, Message.sender3][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 693.41 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 693.41 for Message.receiver3."} (Fractions(100) <= exhaleMask#_1598[this#168, Message.receiver3][perm$R]) && ((Fractions(100) == exhaleMask#_1598[this#168, Message.receiver3][perm$R]) ==> (0 <= exhaleMask#_1598[this#168, Message.receiver3][perm$N]));
      exhaleMask#_1598[this#168, Message.receiver3] := exhaleMask#_1598[this#168, Message.receiver3][perm$R := exhaleMask#_1598[this#168, Message.receiver3][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 694.3 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.3 for Message.vr2."} (Fractions(100) <= exhaleMask#_1598[this#168, Message.vr2][perm$R]) && ((Fractions(100) == exhaleMask#_1598[this#168, Message.vr2][perm$R]) ==> (0 <= exhaleMask#_1598[this#168, Message.vr2][perm$N]));
      exhaleMask#_1598[this#168, Message.vr2] := exhaleMask#_1598[this#168, Message.vr2][perm$R := exhaleMask#_1598[this#168, Message.vr2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 694.15 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.15 for Message.old2."} (Fractions(100) <= exhaleMask#_1598[this#168, Message.old2][perm$R]) && ((Fractions(100) == exhaleMask#_1598[this#168, Message.old2][perm$R]) ==> (0 <= exhaleMask#_1598[this#168, Message.old2][perm$N]));
      exhaleMask#_1598[this#168, Message.old2] := exhaleMask#_1598[this#168, Message.old2][perm$R := exhaleMask#_1598[this#168, Message.old2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 696.21 might not be positive."} monitorK > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 696.21 for Future.q."} (monitorK <= exhaleMask#_1598[Heap[this#168, Message.sender3], Future.q][perm$R]) && ((monitorK == exhaleMask#_1598[Heap[this#168, Message.sender3], Future.q][perm$R]) ==> (0 <= exhaleMask#_1598[Heap[this#168, Message.sender3], Future.q][perm$N]));
      exhaleMask#_1598[Heap[this#168, Message.sender3], Future.q] := exhaleMask#_1598[Heap[this#168, Message.sender3], Future.q][perm$R := exhaleMask#_1598[Heap[this#168, Message.sender3], Future.q][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 696.62 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 696.62 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.valid][perm$N]));
      exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.valid] := exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 696.82 might not be positive."} Fractions(100) > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 696.82 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.initExpState][perm$N]));
      exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.initExpState] := exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1598[Heap[Heap[this#168, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 697.3 might not be positive."} monitorK > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 697.3 for FactorialCont.v."} (monitorK <= exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1598[oldv#170, FactorialCont.v][perm$N]));
      exhaleMask#_1598[oldv#170, FactorialCont.v] := exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R := exhaleMask#_1598[oldv#170, FactorialCont.v][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 697.23 might not be positive."} monitorK > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 697.23 for FactorialCont.vo."} (monitorK <= exhaleMask#_1598[oldv#170, FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1598[oldv#170, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1598[oldv#170, FactorialCont.vo][perm$N]));
      exhaleMask#_1598[oldv#170, FactorialCont.vo] := exhaleMask#_1598[oldv#170, FactorialCont.vo][perm$R := exhaleMask#_1598[oldv#170, FactorialCont.vo][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      assert {:msg "  872.5: The precondition at 693.11 might not hold. The permission at 698.3 might not be positive."} monitorK > 0;
      assert {:msg "  872.5: The precondition at 693.11 might not hold. Insufficient fraction at 698.3 for FactorialCont.cust."} (monitorK <= exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R]) && ((monitorK == exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$N]));
      exhaleMask#_1598[oldv#170, FactorialCont.cust] := exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R := exhaleMask#_1598[oldv#170, FactorialCont.cust][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1598);
      Mask := exhaleMask#_1598;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_1616;
      assume IsGoodInhaleState(inhaleHeap#_1616, Heap, Mask);
      assume this#168 != null;
      Heap[this#168, Message.invResult2] := inhaleHeap#_1616[this#168, Message.invResult2];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1616[this#168, Message.invResult2] == Heap;
      assume Fractions(100) > 0;
      Mask[this#168, Message.invResult2] := Mask[this#168, Message.invResult2][perm$R := Mask[this#168, Message.invResult2][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1616[this#168, Message.invResult2]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1616, Mask);
      assume this#168 != null;
      Heap[this#168, Message.type] := inhaleHeap#_1616[this#168, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[this#168, Message.type] := Mask[this#168, Message.type][perm$R := Mask[this#168, Message.type][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1616[this#168, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1616, Mask);
      assume this#168 != null;
      Heap[this#168, Message.type] := inhaleHeap#_1616[this#168, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[this#168, Message.type] := Mask[this#168, Message.type][perm$R := Mask[this#168, Message.type][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1616[this#168, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1616, Mask);
      assume Heap[this#168, Message.type] == 3;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // unfold
      assume (0 < unfoldK#_1617) && (unfoldK#_1617 < Fractions(1)) && ((1000 * unfoldK#_1617) < methodK#_1489);
      assert {:msg "  873.12: Receiver might be null."} true ==> (this != null);
      assert {:msg "  873.12: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
      assert {:msg "  873.12: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
      assert {:msg "  873.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
      assert {:msg "  873.5: The target of the fold statement might be null."} Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
      // begin exhale (unfold)
      exhaleMask#_1618 := Mask;
      assert {:msg "  873.5: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
      assert {:msg "  873.5: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1618[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1618[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1618[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
      exhaleMask#_1618[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1618[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1618[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1618);
      Mask := exhaleMask#_1618;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (unfold)
      inhaleHeap#_1620 := Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState];
      assume IsGoodInhaleState(inhaleHeap#_1620, Heap, Mask);
      assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
      Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1620[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp];
      assume wf(Heap, Mask);
      assume (Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
      assume monitorK > 0;
      Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1620[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1620, Mask);
      assume Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] != null;
      Heap[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] := inhaleHeap#_1620[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] := Mask[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R := Mask[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1620[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1620, Mask);
      assume Heap[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] == 0;
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      assume (0 < methodCallK#_1624) && ((1000 * methodCallK#_1624) < Fractions(1)) && ((1000 * methodCallK#_1624) < methodK#_1489);
      // call sendResult2
      callHeap#_1621 := Heap;
      callMask#_1622 := Mask;
      callCredits#_1623 := Credits;
      assert {:msg "  874.10: Receiver might be null."} true ==> (this != null);
      assert {:msg "  874.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
      assert {:msg "  874.10: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
      assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp);
      assert {:msg "  874.5: The target of the method call might be null."} Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] != null;
      this#172 := Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp];
      m#173 := m#92;
      // begin exhale (precondition)
      exhaleMask#_1625 := Mask;
      assert {:msg "  874.5: The precondition at 214.11 might not hold. The expression at 214.63 might not evaluate to true."} Heap[m#173, Message.type] == 3;
      assert {:msg "  874.5: The precondition at 216.11 might not hold. The expression at 216.11 might not evaluate to true."} Heap[this#172, FactorialContChannelExpEP.state] == 0;
      assert {:msg "  874.5: The precondition at 214.11 might not hold. The permission at 214.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  874.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.11 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1625[this#172, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1625[this#172, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1625[this#172, FactorialContChannelExpEP.state][perm$N]));
      exhaleMask#_1625[this#172, FactorialContChannelExpEP.state] := exhaleMask#_1625[this#172, FactorialContChannelExpEP.state][perm$R := exhaleMask#_1625[this#172, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1625);
      assert {:msg "  874.5: The precondition at 214.11 might not hold. The permission at 214.25 might not be positive."} monitorK > 0;
      assert {:msg "  874.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.25 for Message.type."} (monitorK <= exhaleMask#_1625[m#173, Message.type][perm$R]) && ((monitorK == exhaleMask#_1625[m#173, Message.type][perm$R]) ==> (0 <= exhaleMask#_1625[m#173, Message.type][perm$N]));
      exhaleMask#_1625[m#173, Message.type] := exhaleMask#_1625[m#173, Message.type][perm$R := exhaleMask#_1625[m#173, Message.type][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1625);
      assert {:msg "  874.5: The precondition at 214.11 might not hold. The permission at 214.44 might not be positive."} monitorK > 0;
      assert {:msg "  874.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.44 for Message.type."} (monitorK <= exhaleMask#_1625[m#173, Message.type][perm$R]) && ((monitorK == exhaleMask#_1625[m#173, Message.type][perm$R]) ==> (0 <= exhaleMask#_1625[m#173, Message.type][perm$N]));
      exhaleMask#_1625[m#173, Message.type] := exhaleMask#_1625[m#173, Message.type][perm$R := exhaleMask#_1625[m#173, Message.type][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1625);
      assert {:msg "  874.5: The precondition at 214.11 might not hold. The permission at 214.76 might not be positive."} Fractions(100) > 0;
      assert {:msg "  874.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.76 for Message.invResult2."} (Fractions(100) <= exhaleMask#_1625[m#173, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_1625[m#173, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_1625[m#173, Message.invResult2][perm$N]));
      exhaleMask#_1625[m#173, Message.invResult2] := exhaleMask#_1625[m#173, Message.invResult2][perm$R := exhaleMask#_1625[m#173, Message.invResult2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1625);
      assert {:msg "  874.5: The precondition at 215.12 might not hold. The permission at 215.12 might not be positive."} Fractions(100) > 0;
      assert {:msg "  874.5: The precondition at 215.12 might not hold. Insufficient fraction at 215.12 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1625[this#172, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1625[this#172, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1625[this#172, FactorialContChannelExpEP.valid][perm$N]));
      exhaleMask#_1625[this#172, FactorialContChannelExpEP.valid] := exhaleMask#_1625[this#172, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_1625[this#172, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1625);
      Mask := exhaleMask#_1625;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (postcondition)
      havoc inhaleHeap#_1633;
      assume IsGoodInhaleState(inhaleHeap#_1633, Heap, Mask);
      assume this#172 != null;
      Heap[this#172, FactorialContChannelExpEP.state] := inhaleHeap#_1633[this#172, FactorialContChannelExpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[this#172, FactorialContChannelExpEP.state] := Mask[this#172, FactorialContChannelExpEP.state][perm$R := Mask[this#172, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1633[this#172, FactorialContChannelExpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1633, Mask);
      assume this#172 != null;
      Heap[this#172, FactorialContChannelExpEP.valid] := inhaleHeap#_1633[this#172, FactorialContChannelExpEP.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1633[this#172, FactorialContChannelExpEP.valid] == Heap;
      assume Fractions(100) > 0;
      Mask[this#172, FactorialContChannelExpEP.valid] := Mask[this#172, FactorialContChannelExpEP.valid][perm$R := Mask[this#172, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1633[this#172, FactorialContChannelExpEP.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1633, Mask);
      if (callHeap#_1621[this#172, FactorialContChannelExpEP.state] == 0) {
        assume Heap[this#172, FactorialContChannelExpEP.state] == 1;
      } else {
      }
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // local var r
      // assigment to r
      // new
      havoc nw#_1634;
      assume (nw#_1634 != null) && (dtype(nw#_1634) == Message#t);
      assume (forall<T#_23> f: Field (T#_23) :: (Mask[nw#_1634, f][perm$R] == 0) && (Mask[nw#_1634, f][perm$N] == 0));
      assume Heap[nw#_1634, mu] == $LockBottom;
      assume Heap[nw#_1634, held] <= 0;
      assume Heap[nw#_1634, rdheld] == false;
      Mask[nw#_1634, Message.type] := Mask[nw#_1634, Message.type][perm$R := Mask[nw#_1634, Message.type][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.sender1] := Mask[nw#_1634, Message.sender1][perm$R := Mask[nw#_1634, Message.sender1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.sender3] := Mask[nw#_1634, Message.sender3][perm$R := Mask[nw#_1634, Message.sender3][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.sender2] := Mask[nw#_1634, Message.sender2][perm$R := Mask[nw#_1634, Message.sender2][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.sender4] := Mask[nw#_1634, Message.sender4][perm$R := Mask[nw#_1634, Message.sender4][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.receiver1] := Mask[nw#_1634, Message.receiver1][perm$R := Mask[nw#_1634, Message.receiver1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.receiver2] := Mask[nw#_1634, Message.receiver2][perm$R := Mask[nw#_1634, Message.receiver2][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.receiver3] := Mask[nw#_1634, Message.receiver3][perm$R := Mask[nw#_1634, Message.receiver3][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.receiver4] := Mask[nw#_1634, Message.receiver4][perm$R := Mask[nw#_1634, Message.receiver4][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.v1] := Mask[nw#_1634, Message.v1][perm$R := Mask[nw#_1634, Message.v1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.vo1] := Mask[nw#_1634, Message.vo1][perm$R := Mask[nw#_1634, Message.vo1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.cust1] := Mask[nw#_1634, Message.cust1][perm$R := Mask[nw#_1634, Message.cust1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.vr1] := Mask[nw#_1634, Message.vr1][perm$R := Mask[nw#_1634, Message.vr1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.old1] := Mask[nw#_1634, Message.old1][perm$R := Mask[nw#_1634, Message.old1][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.vr2] := Mask[nw#_1634, Message.vr2][perm$R := Mask[nw#_1634, Message.vr2][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.old2] := Mask[nw#_1634, Message.old2][perm$R := Mask[nw#_1634, Message.old2][perm$R] + Fractions(100)];
      Mask[nw#_1634, Message.vr3] := Mask[nw#_1634, Message.vr3][perm$R := Mask[nw#_1634, Message.vr3][perm$R] + Fractions(100)];
      Mask[nw#_1634, mu] := Mask[nw#_1634, mu][perm$R := Mask[nw#_1634, mu][perm$R] + Fractions(100)];
      r#94 := nw#_1634;
      // update field type
      assert {:msg "  877.5: Location might not be writable"} CanWrite(Mask, r#94, Message.type);
      Heap[r#94, Message.type] := 4;
      assume wf(Heap, Mask);
      // assert
      Heap#_1638 := Heap;
      Mask#_1639 := Mask;
      Credits#_1640 := Credits;
      // begin exhale (assert)
      exhaleMask#_1641 := Mask#_1639;
      assert {:msg "  878.12: Receiver might be null."} true ==> (r#94 != null);
      assert {:msg "  878.12: Location might not be readable."} true ==> CanRead(Mask#_1639, r#94, Message.vr3);
      assert {:msg "  878.31: Receiver might be null."} true ==> (this != null);
      assert {:msg "  878.31: Location might not be readable."} true ==> CanRead(Mask#_1639, this, FactorialCont.cust);
      assert {:msg "  878.31: Receiver might be null."} true ==> (Heap#_1638[this, FactorialCont.cust] != null);
      assert {:msg "  878.31: Location might not be readable."} true ==> CanRead(Mask#_1639, Heap#_1638[this, FactorialCont.cust], FactorialCont.vo);
      assert {:msg "  878.19: Receiver might be null."} true ==> (m#92 != null);
      // check precondition of call
      assume (0 < funcappK#_1648) && ((1000 * funcappK#_1648) < Fractions(1));
      assume true;
      Heap#_1645 := Heap#_1638;
      Mask#_1646 := Mask#_1639;
      Credits#_1647 := Credits#_1640;
      // begin exhale (function call)
      exhaleMask#_1649 := Mask#_1646;
      assert {:msg "  878.19: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1645[Heap#_1645[this, FactorialCont.cust], FactorialCont.vo] >= 0;
      Mask#_1646 := exhaleMask#_1649;
      assume wf(Heap#_1645, Mask#_1646);
      // end exhale
      if (Heap#_1638[r#94, Message.vr3] == #Message.factorial(Heap#_1638, Mask#_1639, m#92, Heap#_1638[Heap#_1638[this, FactorialCont.cust], FactorialCont.vo])) {
        assert {:msg "  878.44: Receiver might be null."} true ==> (r#94 != null);
        assert {:msg "  878.44: Location might not be readable."} true ==> CanRead(Mask#_1639, r#94, Message.vr3);
        assert {:msg "  878.63: Receiver might be null."} true ==> (this != null);
        assert {:msg "  878.63: Location might not be readable."} true ==> CanRead(Mask#_1639, this, FactorialCont.vo);
        assert {:msg "  878.51: Receiver might be null."} true ==> (m#92 != null);
        // check precondition of call
        assume (0 < funcappK#_1656) && ((1000 * funcappK#_1656) < Fractions(1));
        assume true;
        Heap#_1653 := Heap#_1638;
        Mask#_1654 := Mask#_1639;
        Credits#_1655 := Credits#_1640;
        // begin exhale (function call)
        exhaleMask#_1657 := Mask#_1654;
        assert {:msg "  878.51: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1653[this, FactorialCont.vo] >= 0;
        Mask#_1654 := exhaleMask#_1657;
        assume wf(Heap#_1653, Mask#_1654);
        // end exhale
        assert {:msg "  878.5: Assertion might not hold. The expression at 878.44 might not evaluate to true."} Heap#_1638[r#94, Message.vr3] == #Message.factorial(Heap#_1638, Mask#_1639, m#92, Heap#_1638[this, FactorialCont.vo]);
      } else {
      }
      if (Heap#_1638[r#94, Message.vr3] == #Message.factorial(Heap#_1638, Mask#_1639, m#92, Heap#_1638[Heap#_1638[this, FactorialCont.cust], FactorialCont.vo])) {
      } else {
      }
      Mask#_1639 := exhaleMask#_1641;
      assume wf(Heap#_1638, Mask#_1639);
      // end exhale
    }
  } else {
    // if
    assert {:msg "  883.7: Receiver might be null."} true ==> (current#88 != null);
    assert {:msg "  883.7: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.type);
    if (Heap[current#88, Message.type] == 3) {
      assume (0 < methodCallK#_1661) && ((1000 * methodCallK#_1661) < Fractions(1)) && ((1000 * methodCallK#_1661) < methodK#_1489);
      // call receiveResult2
      callHeap#_1658 := Heap;
      callMask#_1659 := Mask;
      callCredits#_1660 := Credits;
      assert {:msg "  884.18: Receiver might be null."} true ==> (this != null);
      assert {:msg "  884.18: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
      assert {:msg "  884.18: Receiver might be null."} true ==> (Heap[this, FactorialCont.q] != null);
      assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.q], FactorialContChannel.imp);
      assert {:msg "  884.4: The target of the method call might be null."} Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp] != null;
      this#174 := Heap[Heap[this, FactorialCont.q], FactorialContChannel.imp];
      mi#175 := current#88;
      // begin exhale (precondition)
      exhaleMask#_1662 := Mask;
      assert {:msg "  884.4: The precondition at 306.11 might not hold. The expression at 306.25 might not evaluate to true."} !(mi#175 == null);
      assert {:msg "  884.4: The precondition at 306.11 might not hold. The expression at 306.57 might not evaluate to true."} Heap[mi#175, Message.type] == 3;
      assert {:msg "  884.4: The precondition at 307.11 might not hold. The expression at 307.11 might not evaluate to true."} Heap[this#174, FactorialContChannelImpEP.state] == 0;
      assert {:msg "  884.4: The precondition at 306.11 might not hold. The permission at 306.11 might not be positive."} Fractions(100) > 0;
      assert {:msg "  884.4: The precondition at 306.11 might not hold. Insufficient fraction at 306.11 for FactorialContChannelImpEP.state."} (Fractions(100) <= exhaleMask#_1662[this#174, FactorialContChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1662[this#174, FactorialContChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1662[this#174, FactorialContChannelImpEP.state][perm$N]));
      exhaleMask#_1662[this#174, FactorialContChannelImpEP.state] := exhaleMask#_1662[this#174, FactorialContChannelImpEP.state][perm$R := exhaleMask#_1662[this#174, FactorialContChannelImpEP.state][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1662);
      assert {:msg "  884.4: The precondition at 306.11 might not hold. The permission at 306.37 might not be positive."} monitorK > 0;
      assert {:msg "  884.4: The precondition at 306.11 might not hold. Insufficient fraction at 306.37 for Message.type."} (monitorK <= exhaleMask#_1662[mi#175, Message.type][perm$R]) && ((monitorK == exhaleMask#_1662[mi#175, Message.type][perm$R]) ==> (0 <= exhaleMask#_1662[mi#175, Message.type][perm$N]));
      exhaleMask#_1662[mi#175, Message.type] := exhaleMask#_1662[mi#175, Message.type][perm$R := exhaleMask#_1662[mi#175, Message.type][perm$R] - monitorK];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1662);
      assert {:msg "  884.4: The precondition at 306.11 might not hold. The permission at 306.71 might not be positive."} Fractions(100) > 0;
      assert {:msg "  884.4: The precondition at 306.11 might not hold. Insufficient fraction at 306.71 for Message.inv."} (Fractions(100) <= exhaleMask#_1662[mi#175, Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_1662[mi#175, Message.inv][perm$R]) ==> (0 <= exhaleMask#_1662[mi#175, Message.inv][perm$N]));
      exhaleMask#_1662[mi#175, Message.inv] := exhaleMask#_1662[mi#175, Message.inv][perm$R := exhaleMask#_1662[mi#175, Message.inv][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1662);
      Mask := exhaleMask#_1662;
      assume wf(Heap, Mask);
      // end exhale
      havoc mo#176;
      // inhale (postcondition)
      havoc inhaleHeap#_1668;
      assume IsGoodInhaleState(inhaleHeap#_1668, Heap, Mask);
      assume this#174 != null;
      Heap[this#174, FactorialContChannelImpEP.state] := inhaleHeap#_1668[this#174, FactorialContChannelImpEP.state];
      assume wf(Heap, Mask);
      assume true;
      assume Fractions(100) > 0;
      Mask[this#174, FactorialContChannelImpEP.state] := Mask[this#174, FactorialContChannelImpEP.state][perm$R := Mask[this#174, FactorialContChannelImpEP.state][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1668[this#174, FactorialContChannelImpEP.state]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1668, Mask);
      assume Heap[this#174, FactorialContChannelImpEP.state] == 1;
      assume mo#176 != null;
      Heap[mo#176, Message.type] := inhaleHeap#_1668[mo#176, Message.type];
      assume wf(Heap, Mask);
      assume true;
      assume monitorK > 0;
      Mask[mo#176, Message.type] := Mask[mo#176, Message.type][perm$R := Mask[mo#176, Message.type][perm$R] + monitorK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1668[mo#176, Message.type]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1668, Mask);
      assume mo#176 == mi#175;
      assume Heap[mo#176, Message.type] == 3;
      assume mo#176 != null;
      Heap[mo#176, Message.invResult2] := inhaleHeap#_1668[mo#176, Message.invResult2];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1668[mo#176, Message.invResult2] == Heap;
      assume Fractions(100) > 0;
      Mask[mo#176, Message.invResult2] := Mask[mo#176, Message.invResult2][perm$R := Mask[mo#176, Message.invResult2][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1668[mo#176, Message.invResult2]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1668, Mask);
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      current#88 := mo#176;
      // unfold
      assume (0 < unfoldK#_1669) && (unfoldK#_1669 < Fractions(1)) && ((1000 * unfoldK#_1669) < methodK#_1489);
      assert {:msg "  885.4: The target of the fold statement might be null."} current#88 != null;
      // begin exhale (unfold)
      exhaleMask#_1670 := Mask;
      assert {:msg "  885.4: unfold might fail because the predicate Message.invResult2 does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
      assert {:msg "  885.4: unfold might fail because the predicate Message.invResult2 does not hold. Insufficient fraction at <undefined position> for Message.invResult2."} (Fractions(100) <= exhaleMask#_1670[current#88, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_1670[current#88, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_1670[current#88, Message.invResult2][perm$N]));
      exhaleMask#_1670[current#88, Message.invResult2] := exhaleMask#_1670[current#88, Message.invResult2][perm$R := exhaleMask#_1670[current#88, Message.invResult2][perm$R] - Fractions(100)];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      assume wf(Heap, exhaleMask#_1670);
      Mask := exhaleMask#_1670;
      assume wf(Heap, Mask);
      // end exhale
      // inhale (unfold)
      inhaleHeap#_1672 := Heap[current#88, Message.invResult2];
      assume IsGoodInhaleState(inhaleHeap#_1672, Heap, Mask);
      assume current#88 != null;
      Heap[current#88, Message.sender3] := inhaleHeap#_1672[current#88, Message.sender3];
      assume wf(Heap, Mask);
      assume (Heap[current#88, Message.sender3] == null) || (dtype(Heap[current#88, Message.sender3]) == Future#t);
      assume predicateK > 0;
      Mask[current#88, Message.sender3] := Mask[current#88, Message.sender3][perm$R := Mask[current#88, Message.sender3][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[current#88, Message.sender3]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume current#88 != null;
      Heap[current#88, Message.receiver3] := inhaleHeap#_1672[current#88, Message.receiver3];
      assume wf(Heap, Mask);
      assume (Heap[current#88, Message.receiver3] == null) || (dtype(Heap[current#88, Message.receiver3]) == FactorialCont#t);
      assume predicateK > 0;
      Mask[current#88, Message.receiver3] := Mask[current#88, Message.receiver3][perm$R := Mask[current#88, Message.receiver3][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[current#88, Message.receiver3]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume current#88 != null;
      Heap[current#88, Message.vr2] := inhaleHeap#_1672[current#88, Message.vr2];
      assume wf(Heap, Mask);
      assume true;
      assume predicateK > 0;
      Mask[current#88, Message.vr2] := Mask[current#88, Message.vr2][perm$R := Mask[current#88, Message.vr2][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[current#88, Message.vr2]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume current#88 != null;
      Heap[current#88, Message.old2] := inhaleHeap#_1672[current#88, Message.old2];
      assume wf(Heap, Mask);
      assume (Heap[current#88, Message.old2] == null) || (dtype(Heap[current#88, Message.old2]) == FactorialCont#t);
      assume predicateK > 0;
      Mask[current#88, Message.old2] := Mask[current#88, Message.old2][perm$R := Mask[current#88, Message.old2][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[current#88, Message.old2]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume !(Heap[current#88, Message.sender3] == null);
      assume Heap[current#88, Message.sender3] != null;
      Heap[Heap[current#88, Message.sender3], Future.q] := inhaleHeap#_1672[Heap[current#88, Message.sender3], Future.q];
      assume wf(Heap, Mask);
      assume (Heap[Heap[current#88, Message.sender3], Future.q] == null) || (dtype(Heap[Heap[current#88, Message.sender3], Future.q]) == FutureChannel#t);
      assume predicateK > 0;
      Mask[Heap[current#88, Message.sender3], Future.q] := Mask[Heap[current#88, Message.sender3], Future.q][perm$R := Mask[Heap[current#88, Message.sender3], Future.q][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[Heap[current#88, Message.sender3], Future.q]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume !(Heap[Heap[current#88, Message.sender3], Future.q] == null);
      assume Heap[Heap[current#88, Message.sender3], Future.q] != null;
      Heap[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid] := inhaleHeap#_1672[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1672[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid] == Heap;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid] := Mask[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid][perm$R := Mask[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.valid]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume Heap[Heap[current#88, Message.sender3], Future.q] != null;
      Heap[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState] := inhaleHeap#_1672[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState];
      assume wf(Heap, Mask);
      assume inhaleHeap#_1672[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState] == Heap;
      assume Fractions(100) > 0;
      Mask[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState] := Mask[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.initExpState]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume Heap[current#88, Message.old2] != null;
      Heap[Heap[current#88, Message.old2], FactorialCont.v] := inhaleHeap#_1672[Heap[current#88, Message.old2], FactorialCont.v];
      assume wf(Heap, Mask);
      assume true;
      assume predicateK > 0;
      Mask[Heap[current#88, Message.old2], FactorialCont.v] := Mask[Heap[current#88, Message.old2], FactorialCont.v][perm$R := Mask[Heap[current#88, Message.old2], FactorialCont.v][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[Heap[current#88, Message.old2], FactorialCont.v]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume Heap[current#88, Message.old2] != null;
      Heap[Heap[current#88, Message.old2], FactorialCont.vo] := inhaleHeap#_1672[Heap[current#88, Message.old2], FactorialCont.vo];
      assume wf(Heap, Mask);
      assume true;
      assume predicateK > 0;
      Mask[Heap[current#88, Message.old2], FactorialCont.vo] := Mask[Heap[current#88, Message.old2], FactorialCont.vo][perm$R := Mask[Heap[current#88, Message.old2], FactorialCont.vo][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[Heap[current#88, Message.old2], FactorialCont.vo]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume Heap[current#88, Message.old2] != null;
      Heap[Heap[current#88, Message.old2], FactorialCont.cust] := inhaleHeap#_1672[Heap[current#88, Message.old2], FactorialCont.cust];
      assume wf(Heap, Mask);
      assume (Heap[Heap[current#88, Message.old2], FactorialCont.cust] == null) || (dtype(Heap[Heap[current#88, Message.old2], FactorialCont.cust]) == FactorialCont#t);
      assume predicateK > 0;
      Mask[Heap[current#88, Message.old2], FactorialCont.cust] := Mask[Heap[current#88, Message.old2], FactorialCont.cust][perm$R := Mask[Heap[current#88, Message.old2], FactorialCont.cust][perm$R] + predicateK];
      assume IsGoodMask(Mask);
      assume IsGoodState(inhaleHeap#_1672[Heap[current#88, Message.old2], FactorialCont.cust]);
      assume wf(Heap, Mask);
      assume wf(inhaleHeap#_1672, Mask);
      assume Heap[Heap[current#88, Message.old2], FactorialCont.v] >= 0;
      assume Heap[Heap[current#88, Message.old2], FactorialCont.vo] >= 0;
      assume Heap[current#88, Message.vr2] == #Message.factorial(Heap, Mask, current#88, Heap[Heap[current#88, Message.old2], FactorialCont.v]);
      assume Heap[Heap[current#88, Message.old2], FactorialCont.cust] == Heap[current#88, Message.receiver3];
      assume IsGoodMask(Mask);
      assume wf(Heap, Mask);
      // end inhale
      // local var m
      // assigment to m
      // new
      havoc nw#_1673;
      assume (nw#_1673 != null) && (dtype(nw#_1673) == Message#t);
      assume (forall<T#_24> f: Field (T#_24) :: (Mask[nw#_1673, f][perm$R] == 0) && (Mask[nw#_1673, f][perm$N] == 0));
      assume Heap[nw#_1673, mu] == $LockBottom;
      assume Heap[nw#_1673, held] <= 0;
      assume Heap[nw#_1673, rdheld] == false;
      Mask[nw#_1673, Message.type] := Mask[nw#_1673, Message.type][perm$R := Mask[nw#_1673, Message.type][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.sender1] := Mask[nw#_1673, Message.sender1][perm$R := Mask[nw#_1673, Message.sender1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.sender3] := Mask[nw#_1673, Message.sender3][perm$R := Mask[nw#_1673, Message.sender3][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.sender2] := Mask[nw#_1673, Message.sender2][perm$R := Mask[nw#_1673, Message.sender2][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.sender4] := Mask[nw#_1673, Message.sender4][perm$R := Mask[nw#_1673, Message.sender4][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.receiver1] := Mask[nw#_1673, Message.receiver1][perm$R := Mask[nw#_1673, Message.receiver1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.receiver2] := Mask[nw#_1673, Message.receiver2][perm$R := Mask[nw#_1673, Message.receiver2][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.receiver3] := Mask[nw#_1673, Message.receiver3][perm$R := Mask[nw#_1673, Message.receiver3][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.receiver4] := Mask[nw#_1673, Message.receiver4][perm$R := Mask[nw#_1673, Message.receiver4][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.v1] := Mask[nw#_1673, Message.v1][perm$R := Mask[nw#_1673, Message.v1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.vo1] := Mask[nw#_1673, Message.vo1][perm$R := Mask[nw#_1673, Message.vo1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.cust1] := Mask[nw#_1673, Message.cust1][perm$R := Mask[nw#_1673, Message.cust1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.vr1] := Mask[nw#_1673, Message.vr1][perm$R := Mask[nw#_1673, Message.vr1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.old1] := Mask[nw#_1673, Message.old1][perm$R := Mask[nw#_1673, Message.old1][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.vr2] := Mask[nw#_1673, Message.vr2][perm$R := Mask[nw#_1673, Message.vr2][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.old2] := Mask[nw#_1673, Message.old2][perm$R := Mask[nw#_1673, Message.old2][perm$R] + Fractions(100)];
      Mask[nw#_1673, Message.vr3] := Mask[nw#_1673, Message.vr3][perm$R := Mask[nw#_1673, Message.vr3][perm$R] + Fractions(100)];
      Mask[nw#_1673, mu] := Mask[nw#_1673, mu][perm$R := Mask[nw#_1673, mu][perm$R] + Fractions(100)];
      m#96 := nw#_1673;
      // if
      assert {:msg "  887.7: Receiver might be null."} true ==> (this != null);
      assert {:msg "  887.7: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
      if (Heap[this, FactorialCont.cust] == null) {
        // update field sender4
        assert {:msg "  889.5: Location might not be writable"} CanWrite(Mask, m#96, Message.sender4);
        Heap[m#96, Message.sender4] := this;
        assume wf(Heap, Mask);
        assume (0 < methodCallK#_1677) && ((1000 * methodCallK#_1677) < Fractions(1)) && ((1000 * methodCallK#_1677) < methodK#_1489);
        // call setFinalResult
        callHeap#_1674 := Heap;
        callMask#_1675 := Mask;
        callCredits#_1676 := Credits;
        assert {:msg "  891.5: The target of the method call might be null."} m#96 != null;
        assert {:msg "  891.27: Receiver might be null."} true ==> (current#88 != null);
        assert {:msg "  891.27: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.vr2);
        assert {:msg "  891.39: Receiver might be null."} true ==> (this != null);
        assert {:msg "  891.39: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
        assert {:msg "  891.42: Receiver might be null."} true ==> (current#88 != null);
        assert {:msg "  891.42: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender3);
        this#177 := m#96;
        vr#178 := Heap[current#88, Message.vr2] * Heap[this, FactorialCont.v];
        receiver#179 := Heap[current#88, Message.sender3];
        // begin exhale (precondition)
        exhaleMask#_1678 := Mask;
        if (!(Heap[this#177, Message.sender4] == null)) {
          assert {:msg "  891.5: The precondition at 709.11 might not hold. The expression at 710.45 might not evaluate to true."} !(Heap[Heap[this#177, Message.sender4], FactorialCont.q] == null);
        } else {
        }
        assert {:msg "  891.5: The precondition at 709.11 might not hold. The permission at 709.11 might not be positive."} Fractions(100) > 0;
        assert {:msg "  891.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.11 for Message.type."} (Fractions(100) <= exhaleMask#_1678[this#177, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1678[this#177, Message.type][perm$R]) ==> (0 <= exhaleMask#_1678[this#177, Message.type][perm$N]));
        exhaleMask#_1678[this#177, Message.type] := exhaleMask#_1678[this#177, Message.type][perm$R := exhaleMask#_1678[this#177, Message.type][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1678);
        assert {:msg "  891.5: The precondition at 709.11 might not hold. The permission at 709.24 might not be positive."} Fractions(100) > 0;
        assert {:msg "  891.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.24 for Message.sender4."} (Fractions(100) <= exhaleMask#_1678[this#177, Message.sender4][perm$R]) && ((Fractions(100) == exhaleMask#_1678[this#177, Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1678[this#177, Message.sender4][perm$N]));
        exhaleMask#_1678[this#177, Message.sender4] := exhaleMask#_1678[this#177, Message.sender4][perm$R := exhaleMask#_1678[this#177, Message.sender4][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1678);
        assert {:msg "  891.5: The precondition at 709.11 might not hold. The permission at 709.40 might not be positive."} Fractions(100) > 0;
        assert {:msg "  891.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.40 for Message.receiver4."} (Fractions(100) <= exhaleMask#_1678[this#177, Message.receiver4][perm$R]) && ((Fractions(100) == exhaleMask#_1678[this#177, Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1678[this#177, Message.receiver4][perm$N]));
        exhaleMask#_1678[this#177, Message.receiver4] := exhaleMask#_1678[this#177, Message.receiver4][perm$R := exhaleMask#_1678[this#177, Message.receiver4][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1678);
        assert {:msg "  891.5: The precondition at 709.11 might not hold. The permission at 709.58 might not be positive."} Fractions(100) > 0;
        assert {:msg "  891.5: The precondition at 709.11 might not hold. Insufficient fraction at 709.58 for Message.vr3."} (Fractions(100) <= exhaleMask#_1678[this#177, Message.vr3][perm$R]) && ((Fractions(100) == exhaleMask#_1678[this#177, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1678[this#177, Message.vr3][perm$N]));
        exhaleMask#_1678[this#177, Message.vr3] := exhaleMask#_1678[this#177, Message.vr3][perm$R := exhaleMask#_1678[this#177, Message.vr3][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1678);
        if (!(Heap[this#177, Message.sender4] == null)) {
          assert {:msg "  891.5: The precondition at 709.11 might not hold. The permission at 710.23 might not be positive."} monitorK > 0;
          assert {:msg "  891.5: The precondition at 709.11 might not hold. Insufficient fraction at 710.23 for FactorialCont.q."} (monitorK <= exhaleMask#_1678[Heap[this#177, Message.sender4], FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1678[Heap[this#177, Message.sender4], FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1678[Heap[this#177, Message.sender4], FactorialCont.q][perm$N]));
          exhaleMask#_1678[Heap[this#177, Message.sender4], FactorialCont.q] := exhaleMask#_1678[Heap[this#177, Message.sender4], FactorialCont.q][perm$R := exhaleMask#_1678[Heap[this#177, Message.sender4], FactorialCont.q][perm$R] - monitorK];
          assume IsGoodMask(Mask);
          assume wf(Heap, Mask);
          assume wf(Heap, exhaleMask#_1678);
        } else {
        }
        Mask := exhaleMask#_1678;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_1686;
        assume IsGoodInhaleState(inhaleHeap#_1686, Heap, Mask);
        assume this#177 != null;
        Heap[this#177, Message.invFinalResult] := inhaleHeap#_1686[this#177, Message.invFinalResult];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1686[this#177, Message.invFinalResult] == Heap;
        assume Fractions(100) > 0;
        Mask[this#177, Message.invFinalResult] := Mask[this#177, Message.invFinalResult][perm$R := Mask[this#177, Message.invFinalResult][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1686[this#177, Message.invFinalResult]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1686, Mask);
        assume this#177 != null;
        Heap[this#177, Message.type] := inhaleHeap#_1686[this#177, Message.type];
        assume wf(Heap, Mask);
        assume true;
        assume monitorK > 0;
        Mask[this#177, Message.type] := Mask[this#177, Message.type][perm$R := Mask[this#177, Message.type][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1686[this#177, Message.type]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1686, Mask);
        assume this#177 != null;
        Heap[this#177, Message.type] := inhaleHeap#_1686[this#177, Message.type];
        assume wf(Heap, Mask);
        assume true;
        assume monitorK > 0;
        Mask[this#177, Message.type] := Mask[this#177, Message.type][perm$R := Mask[this#177, Message.type][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1686[this#177, Message.type]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1686, Mask);
        assume Heap[this#177, Message.type] == 4;
        assume this#177 != null;
        Heap[this#177, Message.vr3] := inhaleHeap#_1686[this#177, Message.vr3];
        assume wf(Heap, Mask);
        assume true;
        assume monitorK > 0;
        Mask[this#177, Message.vr3] := Mask[this#177, Message.vr3][perm$R := Mask[this#177, Message.vr3][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1686[this#177, Message.vr3]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1686, Mask);
        assume Heap[this#177, Message.vr3] == vr#178;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        // unfold
        assume (0 < unfoldK#_1687) && (unfoldK#_1687 < Fractions(1)) && ((1000 * unfoldK#_1687) < methodK#_1489);
        assert {:msg "  892.5: The target of the fold statement might be null."} m#96 != null;
        // begin exhale (unfold)
        exhaleMask#_1688 := Mask;
        assert {:msg "  892.5: unfold might fail because the predicate Message.invFinalResult does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
        assert {:msg "  892.5: unfold might fail because the predicate Message.invFinalResult does not hold. Insufficient fraction at <undefined position> for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1688[m#96, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1688[m#96, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1688[m#96, Message.invFinalResult][perm$N]));
        exhaleMask#_1688[m#96, Message.invFinalResult] := exhaleMask#_1688[m#96, Message.invFinalResult][perm$R := exhaleMask#_1688[m#96, Message.invFinalResult][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1688);
        Mask := exhaleMask#_1688;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (unfold)
        inhaleHeap#_1690 := Heap[m#96, Message.invFinalResult];
        assume IsGoodInhaleState(inhaleHeap#_1690, Heap, Mask);
        assume m#96 != null;
        Heap[m#96, Message.sender4] := inhaleHeap#_1690[m#96, Message.sender4];
        assume wf(Heap, Mask);
        assume (Heap[m#96, Message.sender4] == null) || (dtype(Heap[m#96, Message.sender4]) == FactorialCont#t);
        assume predicateK > 0;
        Mask[m#96, Message.sender4] := Mask[m#96, Message.sender4][perm$R := Mask[m#96, Message.sender4][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1690[m#96, Message.sender4]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1690, Mask);
        assume m#96 != null;
        Heap[m#96, Message.receiver4] := inhaleHeap#_1690[m#96, Message.receiver4];
        assume wf(Heap, Mask);
        assume (Heap[m#96, Message.receiver4] == null) || (dtype(Heap[m#96, Message.receiver4]) == Future#t);
        assume predicateK > 0;
        Mask[m#96, Message.receiver4] := Mask[m#96, Message.receiver4][perm$R := Mask[m#96, Message.receiver4][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1690[m#96, Message.receiver4]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1690, Mask);
        assume m#96 != null;
        Heap[m#96, Message.vr3] := inhaleHeap#_1690[m#96, Message.vr3];
        assume wf(Heap, Mask);
        assume true;
        assume predicateK > 0;
        Mask[m#96, Message.vr3] := Mask[m#96, Message.vr3][perm$R := Mask[m#96, Message.vr3][perm$R] + predicateK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1690[m#96, Message.vr3]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1690, Mask);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        // assert
        Heap#_1694 := Heap;
        Mask#_1695 := Mask;
        Credits#_1696 := Credits;
        // begin exhale (assert)
        exhaleMask#_1697 := Mask#_1695;
        assert {:msg "  894.12: Receiver might be null."} true ==> (m#96 != null);
        assert {:msg "  894.12: Location might not be readable."} true ==> CanRead(Mask#_1695, m#96, Message.vr3);
        assert {:msg "  894.31: Receiver might be null."} true ==> (this != null);
        assert {:msg "  894.31: Location might not be readable."} true ==> CanRead(Mask#_1695, this, FactorialCont.vo);
        assert {:msg "  894.19: Receiver might be null."} true ==> (m#96 != null);
        // check precondition of call
        assume (0 < funcappK#_1704) && ((1000 * funcappK#_1704) < Fractions(1));
        assume true;
        Heap#_1701 := Heap#_1694;
        Mask#_1702 := Mask#_1695;
        Credits#_1703 := Credits#_1696;
        // begin exhale (function call)
        exhaleMask#_1705 := Mask#_1702;
        assert {:msg "  894.19: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1701[this, FactorialCont.vo] >= 0;
        Mask#_1702 := exhaleMask#_1705;
        assume wf(Heap#_1701, Mask#_1702);
        // end exhale
        assert {:msg "  894.5: Assertion might not hold. The expression at 894.12 might not evaluate to true."} Heap#_1694[m#96, Message.vr3] == #Message.factorial(Heap#_1694, Mask#_1695, m#96, Heap#_1694[this, FactorialCont.vo]);
        Mask#_1695 := exhaleMask#_1697;
        assume wf(Heap#_1694, Mask#_1695);
        // end exhale
        // fold
        assume (0 < foldK#_1706) && ((1000 * foldK#_1706) < Fractions(1)) && ((1000 * foldK#_1706) < methodK#_1489);
        assert {:msg "  895.5: The target of the fold statement might be null."} m#96 != null;
        // begin exhale (fold)
        exhaleMask#_1707 := Mask;
        assert {:msg "  895.5: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.3 might not be positive."} predicateK > 0;
        assert {:msg "  895.5: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.3 for Message.sender4."} (predicateK <= exhaleMask#_1707[m#96, Message.sender4][perm$R]) && ((predicateK == exhaleMask#_1707[m#96, Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1707[m#96, Message.sender4][perm$N]));
        exhaleMask#_1707[m#96, Message.sender4] := exhaleMask#_1707[m#96, Message.sender4][perm$R := exhaleMask#_1707[m#96, Message.sender4][perm$R] - predicateK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1707);
        assert {:msg "  895.5: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.18 might not be positive."} predicateK > 0;
        assert {:msg "  895.5: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.18 for Message.receiver4."} (predicateK <= exhaleMask#_1707[m#96, Message.receiver4][perm$R]) && ((predicateK == exhaleMask#_1707[m#96, Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1707[m#96, Message.receiver4][perm$N]));
        exhaleMask#_1707[m#96, Message.receiver4] := exhaleMask#_1707[m#96, Message.receiver4][perm$R := exhaleMask#_1707[m#96, Message.receiver4][perm$R] - predicateK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1707);
        assert {:msg "  895.5: Fold might fail because the definition of Message.invFinalResult does not hold. The permission at 645.35 might not be positive."} predicateK > 0;
        assert {:msg "  895.5: Fold might fail because the definition of Message.invFinalResult does not hold. Insufficient fraction at 645.35 for Message.vr3."} (predicateK <= exhaleMask#_1707[m#96, Message.vr3][perm$R]) && ((predicateK == exhaleMask#_1707[m#96, Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1707[m#96, Message.vr3][perm$N]));
        exhaleMask#_1707[m#96, Message.vr3] := exhaleMask#_1707[m#96, Message.vr3][perm$R := exhaleMask#_1707[m#96, Message.vr3][perm$R] - predicateK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1707);
        Mask := exhaleMask#_1707;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (fold)
        havoc inhaleHeap#_1711;
        assume IsGoodInhaleState(inhaleHeap#_1711, Heap, Mask);
        assume m#96 != null;
        Heap[m#96, Message.invFinalResult] := inhaleHeap#_1711[m#96, Message.invFinalResult];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1711[m#96, Message.invFinalResult] == Heap;
        assume Fractions(100) > 0;
        Mask[m#96, Message.invFinalResult] := Mask[m#96, Message.invFinalResult][perm$R := Mask[m#96, Message.invFinalResult][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1711[m#96, Message.invFinalResult]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1711, Mask);
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        Heap[m#96, Message.invFinalResult] := Heap;
        assume wf(Heap, Mask);
        // unfold
        assume (0 < unfoldK#_1712) && (unfoldK#_1712 < Fractions(1)) && ((1000 * unfoldK#_1712) < methodK#_1489);
        assert {:msg "  896.12: Receiver might be null."} true ==> (current#88 != null);
        assert {:msg "  896.12: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender2);
        assert {:msg "  896.12: Receiver might be null."} true ==> (Heap[current#88, Message.sender2] != null);
        assert {:msg "  896.12: Location might not be readable."} true ==> CanRead(Mask, Heap[current#88, Message.sender2], Future.q);
        assert {:msg "  896.5: The target of the fold statement might be null."} Heap[Heap[current#88, Message.sender2], Future.q] != null;
        // begin exhale (unfold)
        exhaleMask#_1713 := Mask;
        assert {:msg "  896.5: unfold might fail because the predicate FutureChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
        assert {:msg "  896.5: unfold might fail because the predicate FutureChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1713[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1713[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1713[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$N]));
        exhaleMask#_1713[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState] := exhaleMask#_1713[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1713[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1713);
        Mask := exhaleMask#_1713;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (unfold)
        inhaleHeap#_1715 := Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.initExpState];
        assume IsGoodInhaleState(inhaleHeap#_1715, Heap, Mask);
        assume Heap[Heap[current#88, Message.sender2], Future.q] != null;
        Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] := inhaleHeap#_1715[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp];
        assume wf(Heap, Mask);
        assume (Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] == null) || (dtype(Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp]) == FutureChannelExpEP#t);
        assume monitorK > 0;
        Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp][perm$R := Mask[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1715[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1715, Mask);
        assume Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp] != null;
        Heap[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state] := inhaleHeap#_1715[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state];
        assume wf(Heap, Mask);
        assume true;
        assume Fractions(100) > 0;
        Mask[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state] := Mask[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state][perm$R := Mask[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1715[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1715, Mask);
        assume Heap[Heap[Heap[Heap[current#88, Message.sender2], Future.q], FutureChannel.exp], FutureChannelExpEP.state] == 0;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        assume (0 < methodCallK#_1719) && ((1000 * methodCallK#_1719) < Fractions(1)) && ((1000 * methodCallK#_1719) < methodK#_1489);
        // call sendFinalResult
        callHeap#_1716 := Heap;
        callMask#_1717 := Mask;
        callCredits#_1718 := Credits;
        assert {:msg "  897.10: Receiver might be null."} true ==> (current#88 != null);
        assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender3);
        assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[current#88, Message.sender3] != null);
        assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[current#88, Message.sender3], Future.q);
        assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[current#88, Message.sender3], Future.q] != null);
        assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.exp);
        assert {:msg "  897.5: The target of the method call might be null."} Heap[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.exp] != null;
        this#180 := Heap[Heap[Heap[current#88, Message.sender3], Future.q], FutureChannel.exp];
        m#181 := m#96;
        // begin exhale (precondition)
        exhaleMask#_1720 := Mask;
        assert {:msg "  897.5: The precondition at 400.11 might not hold. The expression at 400.63 might not evaluate to true."} Heap[m#181, Message.type] == 4;
        assert {:msg "  897.5: The precondition at 402.11 might not hold. The expression at 402.11 might not evaluate to true."} Heap[this#180, FutureChannelExpEP.state] == 0;
        assert {:msg "  897.5: The precondition at 400.11 might not hold. The permission at 400.11 might not be positive."} Fractions(100) > 0;
        assert {:msg "  897.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.11 for FutureChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1720[this#180, FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1720[this#180, FutureChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1720[this#180, FutureChannelExpEP.state][perm$N]));
        exhaleMask#_1720[this#180, FutureChannelExpEP.state] := exhaleMask#_1720[this#180, FutureChannelExpEP.state][perm$R := exhaleMask#_1720[this#180, FutureChannelExpEP.state][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1720);
        assert {:msg "  897.5: The precondition at 400.11 might not hold. The permission at 400.25 might not be positive."} monitorK > 0;
        assert {:msg "  897.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.25 for Message.type."} (monitorK <= exhaleMask#_1720[m#181, Message.type][perm$R]) && ((monitorK == exhaleMask#_1720[m#181, Message.type][perm$R]) ==> (0 <= exhaleMask#_1720[m#181, Message.type][perm$N]));
        exhaleMask#_1720[m#181, Message.type] := exhaleMask#_1720[m#181, Message.type][perm$R := exhaleMask#_1720[m#181, Message.type][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1720);
        assert {:msg "  897.5: The precondition at 400.11 might not hold. The permission at 400.44 might not be positive."} monitorK > 0;
        assert {:msg "  897.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.44 for Message.type."} (monitorK <= exhaleMask#_1720[m#181, Message.type][perm$R]) && ((monitorK == exhaleMask#_1720[m#181, Message.type][perm$R]) ==> (0 <= exhaleMask#_1720[m#181, Message.type][perm$N]));
        exhaleMask#_1720[m#181, Message.type] := exhaleMask#_1720[m#181, Message.type][perm$R := exhaleMask#_1720[m#181, Message.type][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1720);
        assert {:msg "  897.5: The precondition at 400.11 might not hold. The permission at 400.76 might not be positive."} Fractions(100) > 0;
        assert {:msg "  897.5: The precondition at 400.11 might not hold. Insufficient fraction at 400.76 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1720[m#181, Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1720[m#181, Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1720[m#181, Message.invFinalResult][perm$N]));
        exhaleMask#_1720[m#181, Message.invFinalResult] := exhaleMask#_1720[m#181, Message.invFinalResult][perm$R := exhaleMask#_1720[m#181, Message.invFinalResult][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1720);
        assert {:msg "  897.5: The precondition at 401.11 might not hold. The permission at 401.11 might not be positive."} Fractions(100) > 0;
        assert {:msg "  897.5: The precondition at 401.11 might not hold. Insufficient fraction at 401.11 for FutureChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1720[this#180, FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1720[this#180, FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1720[this#180, FutureChannelExpEP.valid][perm$N]));
        exhaleMask#_1720[this#180, FutureChannelExpEP.valid] := exhaleMask#_1720[this#180, FutureChannelExpEP.valid][perm$R := exhaleMask#_1720[this#180, FutureChannelExpEP.valid][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1720);
        Mask := exhaleMask#_1720;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_1728;
        assume IsGoodInhaleState(inhaleHeap#_1728, Heap, Mask);
        assume this#180 != null;
        Heap[this#180, FutureChannelExpEP.state] := inhaleHeap#_1728[this#180, FutureChannelExpEP.state];
        assume wf(Heap, Mask);
        assume true;
        assume Fractions(100) > 0;
        Mask[this#180, FutureChannelExpEP.state] := Mask[this#180, FutureChannelExpEP.state][perm$R := Mask[this#180, FutureChannelExpEP.state][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1728[this#180, FutureChannelExpEP.state]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1728, Mask);
        assume this#180 != null;
        Heap[this#180, FutureChannelExpEP.valid] := inhaleHeap#_1728[this#180, FutureChannelExpEP.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1728[this#180, FutureChannelExpEP.valid] == Heap;
        assume Fractions(100) > 0;
        Mask[this#180, FutureChannelExpEP.valid] := Mask[this#180, FutureChannelExpEP.valid][perm$R := Mask[this#180, FutureChannelExpEP.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1728[this#180, FutureChannelExpEP.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1728, Mask);
        if (callHeap#_1716[this#180, FutureChannelExpEP.state] == 0) {
          assume Heap[this#180, FutureChannelExpEP.state] == 1;
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
      } else {
        // update field sender3
        assert {:msg "  902.5: Location might not be writable"} CanWrite(Mask, m#96, Message.sender3);
        assert {:msg "  902.16: Receiver might be null."} true ==> (current#88 != null);
        assert {:msg "  902.16: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.sender3);
        Heap[m#96, Message.sender3] := Heap[current#88, Message.sender3];
        assume wf(Heap, Mask);
        assume (0 < methodCallK#_1732) && ((1000 * methodCallK#_1732) < Fractions(1)) && ((1000 * methodCallK#_1732) < methodK#_1489);
        // call setResult2
        callHeap#_1729 := Heap;
        callMask#_1730 := Mask;
        callCredits#_1731 := Credits;
        assert {:msg "  905.5: The target of the method call might be null."} m#96 != null;
        assert {:msg "  905.23: Receiver might be null."} true ==> (current#88 != null);
        assert {:msg "  905.23: Location might not be readable."} true ==> CanRead(Mask, current#88, Message.vr2);
        assert {:msg "  905.35: Receiver might be null."} true ==> (this != null);
        assert {:msg "  905.35: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.v);
        assert {:msg "  905.43: Receiver might be null."} true ==> (this != null);
        assert {:msg "  905.43: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
        this#182 := m#96;
        v#183 := Heap[current#88, Message.vr2] * Heap[this, FactorialCont.v];
        oldv#184 := this;
        receiver#185 := Heap[this, FactorialCont.cust];
        // begin exhale (precondition)
        exhaleMask#_1733 := Mask;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 694.28 might not evaluate to true."} !(oldv#184 == null);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 694.42 might not be positive."} methodCallK#_1732 > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.42 for FactorialCont.v."} exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R] > 0;
        assume methodCallK#_1732 < exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R];
        exhaleMask#_1733[oldv#184, FactorialCont.v] := exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R := exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R] - methodCallK#_1732];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 694.56 might not be positive."} methodCallK#_1732 > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.56 for FactorialCont.cust."} exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R] > 0;
        assume methodCallK#_1732 < exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R];
        exhaleMask#_1733[oldv#184, FactorialCont.cust] := exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R := exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R] - methodCallK#_1732];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 695.3 might not be positive."} methodCallK#_1732 > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 695.3 for FactorialCont.vo."} exhaleMask#_1733[Heap[oldv#184, FactorialCont.cust], FactorialCont.vo][perm$R] > 0;
        assume methodCallK#_1732 < exhaleMask#_1733[Heap[oldv#184, FactorialCont.cust], FactorialCont.vo][perm$R];
        exhaleMask#_1733[Heap[oldv#184, FactorialCont.cust], FactorialCont.vo] := exhaleMask#_1733[Heap[oldv#184, FactorialCont.cust], FactorialCont.vo][perm$R := exhaleMask#_1733[Heap[oldv#184, FactorialCont.cust], FactorialCont.vo][perm$R] - methodCallK#_1732];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 695.23 might not be positive."} methodCallK#_1732 > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 695.23 for FactorialCont.vo."} exhaleMask#_1733[receiver#185, FactorialCont.vo][perm$R] > 0;
        assume methodCallK#_1732 < exhaleMask#_1733[receiver#185, FactorialCont.vo][perm$R];
        exhaleMask#_1733[receiver#185, FactorialCont.vo] := exhaleMask#_1733[receiver#185, FactorialCont.vo][perm$R := exhaleMask#_1733[receiver#185, FactorialCont.vo][perm$R] - methodCallK#_1732];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 696.4 might not evaluate to true."} !(Heap[this#182, Message.sender3] == null);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 696.43 might not evaluate to true."} !(Heap[Heap[this#182, Message.sender3], Future.q] == null);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 698.25 might not evaluate to true."} Heap[oldv#184, FactorialCont.v] >= 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 698.38 might not evaluate to true."} Heap[oldv#184, FactorialCont.vo] >= 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 698.52 might not evaluate to true."} v#183 == #Message.factorial(Heap, Mask, this#182, Heap[oldv#184, FactorialCont.v]);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The expression at 698.76 might not evaluate to true."} Heap[oldv#184, FactorialCont.cust] == receiver#185;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 693.11 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 693.11 for Message.type."} (Fractions(100) <= exhaleMask#_1733[this#182, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1733[this#182, Message.type][perm$R]) ==> (0 <= exhaleMask#_1733[this#182, Message.type][perm$N]));
        exhaleMask#_1733[this#182, Message.type] := exhaleMask#_1733[this#182, Message.type][perm$R := exhaleMask#_1733[this#182, Message.type][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 693.25 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 693.25 for Message.sender3."} (Fractions(100) <= exhaleMask#_1733[this#182, Message.sender3][perm$R]) && ((Fractions(100) == exhaleMask#_1733[this#182, Message.sender3][perm$R]) ==> (0 <= exhaleMask#_1733[this#182, Message.sender3][perm$N]));
        exhaleMask#_1733[this#182, Message.sender3] := exhaleMask#_1733[this#182, Message.sender3][perm$R := exhaleMask#_1733[this#182, Message.sender3][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 693.41 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 693.41 for Message.receiver3."} (Fractions(100) <= exhaleMask#_1733[this#182, Message.receiver3][perm$R]) && ((Fractions(100) == exhaleMask#_1733[this#182, Message.receiver3][perm$R]) ==> (0 <= exhaleMask#_1733[this#182, Message.receiver3][perm$N]));
        exhaleMask#_1733[this#182, Message.receiver3] := exhaleMask#_1733[this#182, Message.receiver3][perm$R := exhaleMask#_1733[this#182, Message.receiver3][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 694.3 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.3 for Message.vr2."} (Fractions(100) <= exhaleMask#_1733[this#182, Message.vr2][perm$R]) && ((Fractions(100) == exhaleMask#_1733[this#182, Message.vr2][perm$R]) ==> (0 <= exhaleMask#_1733[this#182, Message.vr2][perm$N]));
        exhaleMask#_1733[this#182, Message.vr2] := exhaleMask#_1733[this#182, Message.vr2][perm$R := exhaleMask#_1733[this#182, Message.vr2][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 694.15 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 694.15 for Message.old2."} (Fractions(100) <= exhaleMask#_1733[this#182, Message.old2][perm$R]) && ((Fractions(100) == exhaleMask#_1733[this#182, Message.old2][perm$R]) ==> (0 <= exhaleMask#_1733[this#182, Message.old2][perm$N]));
        exhaleMask#_1733[this#182, Message.old2] := exhaleMask#_1733[this#182, Message.old2][perm$R := exhaleMask#_1733[this#182, Message.old2][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 696.21 might not be positive."} monitorK > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 696.21 for Future.q."} (monitorK <= exhaleMask#_1733[Heap[this#182, Message.sender3], Future.q][perm$R]) && ((monitorK == exhaleMask#_1733[Heap[this#182, Message.sender3], Future.q][perm$R]) ==> (0 <= exhaleMask#_1733[Heap[this#182, Message.sender3], Future.q][perm$N]));
        exhaleMask#_1733[Heap[this#182, Message.sender3], Future.q] := exhaleMask#_1733[Heap[this#182, Message.sender3], Future.q][perm$R := exhaleMask#_1733[Heap[this#182, Message.sender3], Future.q][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 696.62 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 696.62 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.valid][perm$N]));
        exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.valid] := exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 696.82 might not be positive."} Fractions(100) > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 696.82 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.initExpState][perm$N]));
        exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.initExpState] := exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1733[Heap[Heap[this#182, Message.sender3], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 697.3 might not be positive."} monitorK > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 697.3 for FactorialCont.v."} (monitorK <= exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1733[oldv#184, FactorialCont.v][perm$N]));
        exhaleMask#_1733[oldv#184, FactorialCont.v] := exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R := exhaleMask#_1733[oldv#184, FactorialCont.v][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 697.23 might not be positive."} monitorK > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 697.23 for FactorialCont.vo."} (monitorK <= exhaleMask#_1733[oldv#184, FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1733[oldv#184, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1733[oldv#184, FactorialCont.vo][perm$N]));
        exhaleMask#_1733[oldv#184, FactorialCont.vo] := exhaleMask#_1733[oldv#184, FactorialCont.vo][perm$R := exhaleMask#_1733[oldv#184, FactorialCont.vo][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        assert {:msg "  905.5: The precondition at 693.11 might not hold. The permission at 698.3 might not be positive."} monitorK > 0;
        assert {:msg "  905.5: The precondition at 693.11 might not hold. Insufficient fraction at 698.3 for FactorialCont.cust."} (monitorK <= exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R]) && ((monitorK == exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$N]));
        exhaleMask#_1733[oldv#184, FactorialCont.cust] := exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R := exhaleMask#_1733[oldv#184, FactorialCont.cust][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1733);
        Mask := exhaleMask#_1733;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_1751;
        assume IsGoodInhaleState(inhaleHeap#_1751, Heap, Mask);
        assume this#182 != null;
        Heap[this#182, Message.invResult2] := inhaleHeap#_1751[this#182, Message.invResult2];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1751[this#182, Message.invResult2] == Heap;
        assume Fractions(100) > 0;
        Mask[this#182, Message.invResult2] := Mask[this#182, Message.invResult2][perm$R := Mask[this#182, Message.invResult2][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1751[this#182, Message.invResult2]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1751, Mask);
        assume this#182 != null;
        Heap[this#182, Message.type] := inhaleHeap#_1751[this#182, Message.type];
        assume wf(Heap, Mask);
        assume true;
        assume monitorK > 0;
        Mask[this#182, Message.type] := Mask[this#182, Message.type][perm$R := Mask[this#182, Message.type][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1751[this#182, Message.type]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1751, Mask);
        assume this#182 != null;
        Heap[this#182, Message.type] := inhaleHeap#_1751[this#182, Message.type];
        assume wf(Heap, Mask);
        assume true;
        assume monitorK > 0;
        Mask[this#182, Message.type] := Mask[this#182, Message.type][perm$R := Mask[this#182, Message.type][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1751[this#182, Message.type]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1751, Mask);
        assume Heap[this#182, Message.type] == 3;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        // unfold
        assume (0 < unfoldK#_1752) && (unfoldK#_1752 < Fractions(1)) && ((1000 * unfoldK#_1752) < methodK#_1489);
        assert {:msg "  906.12: Receiver might be null."} true ==> (this != null);
        assert {:msg "  906.12: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
        assert {:msg "  906.12: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
        assert {:msg "  906.12: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
        assert {:msg "  906.5: The target of the fold statement might be null."} Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
        // begin exhale (unfold)
        exhaleMask#_1753 := Mask;
        assert {:msg "  906.5: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
        assert {:msg "  906.5: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1753[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1753[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1753[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
        exhaleMask#_1753[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1753[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1753[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1753);
        Mask := exhaleMask#_1753;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (unfold)
        inhaleHeap#_1755 := Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.initExpState];
        assume IsGoodInhaleState(inhaleHeap#_1755, Heap, Mask);
        assume Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null;
        Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] := inhaleHeap#_1755[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp];
        assume wf(Heap, Mask);
        assume (Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] == null) || (dtype(Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
        assume monitorK > 0;
        Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp][perm$R := Mask[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp][perm$R] + monitorK];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1755[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1755, Mask);
        assume Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] != null;
        Heap[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] := inhaleHeap#_1755[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state];
        assume wf(Heap, Mask);
        assume true;
        assume Fractions(100) > 0;
        Mask[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] := Mask[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R := Mask[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1755[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1755, Mask);
        assume Heap[Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp], FactorialContChannelExpEP.state] == 0;
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        assume (0 < methodCallK#_1759) && ((1000 * methodCallK#_1759) < Fractions(1)) && ((1000 * methodCallK#_1759) < methodK#_1489);
        // call sendResult2
        callHeap#_1756 := Heap;
        callMask#_1757 := Mask;
        callCredits#_1758 := Credits;
        assert {:msg "  907.10: Receiver might be null."} true ==> (this != null);
        assert {:msg "  907.10: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.cust);
        assert {:msg "  907.10: Receiver might be null."} true ==> (Heap[this, FactorialCont.cust] != null);
        assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[this, FactorialCont.cust], FactorialCont.q);
        assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[Heap[this, FactorialCont.cust], FactorialCont.q] != null);
        assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp);
        assert {:msg "  907.5: The target of the method call might be null."} Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp] != null;
        this#186 := Heap[Heap[Heap[this, FactorialCont.cust], FactorialCont.q], FactorialContChannel.exp];
        m#187 := m#96;
        // begin exhale (precondition)
        exhaleMask#_1760 := Mask;
        assert {:msg "  907.5: The precondition at 214.11 might not hold. The expression at 214.63 might not evaluate to true."} Heap[m#187, Message.type] == 3;
        assert {:msg "  907.5: The precondition at 216.11 might not hold. The expression at 216.11 might not evaluate to true."} Heap[this#186, FactorialContChannelExpEP.state] == 0;
        assert {:msg "  907.5: The precondition at 214.11 might not hold. The permission at 214.11 might not be positive."} Fractions(100) > 0;
        assert {:msg "  907.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.11 for FactorialContChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1760[this#186, FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1760[this#186, FactorialContChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1760[this#186, FactorialContChannelExpEP.state][perm$N]));
        exhaleMask#_1760[this#186, FactorialContChannelExpEP.state] := exhaleMask#_1760[this#186, FactorialContChannelExpEP.state][perm$R := exhaleMask#_1760[this#186, FactorialContChannelExpEP.state][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1760);
        assert {:msg "  907.5: The precondition at 214.11 might not hold. The permission at 214.25 might not be positive."} monitorK > 0;
        assert {:msg "  907.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.25 for Message.type."} (monitorK <= exhaleMask#_1760[m#187, Message.type][perm$R]) && ((monitorK == exhaleMask#_1760[m#187, Message.type][perm$R]) ==> (0 <= exhaleMask#_1760[m#187, Message.type][perm$N]));
        exhaleMask#_1760[m#187, Message.type] := exhaleMask#_1760[m#187, Message.type][perm$R := exhaleMask#_1760[m#187, Message.type][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1760);
        assert {:msg "  907.5: The precondition at 214.11 might not hold. The permission at 214.44 might not be positive."} monitorK > 0;
        assert {:msg "  907.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.44 for Message.type."} (monitorK <= exhaleMask#_1760[m#187, Message.type][perm$R]) && ((monitorK == exhaleMask#_1760[m#187, Message.type][perm$R]) ==> (0 <= exhaleMask#_1760[m#187, Message.type][perm$N]));
        exhaleMask#_1760[m#187, Message.type] := exhaleMask#_1760[m#187, Message.type][perm$R := exhaleMask#_1760[m#187, Message.type][perm$R] - monitorK];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1760);
        assert {:msg "  907.5: The precondition at 214.11 might not hold. The permission at 214.76 might not be positive."} Fractions(100) > 0;
        assert {:msg "  907.5: The precondition at 214.11 might not hold. Insufficient fraction at 214.76 for Message.invResult2."} (Fractions(100) <= exhaleMask#_1760[m#187, Message.invResult2][perm$R]) && ((Fractions(100) == exhaleMask#_1760[m#187, Message.invResult2][perm$R]) ==> (0 <= exhaleMask#_1760[m#187, Message.invResult2][perm$N]));
        exhaleMask#_1760[m#187, Message.invResult2] := exhaleMask#_1760[m#187, Message.invResult2][perm$R := exhaleMask#_1760[m#187, Message.invResult2][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1760);
        assert {:msg "  907.5: The precondition at 215.12 might not hold. The permission at 215.12 might not be positive."} Fractions(100) > 0;
        assert {:msg "  907.5: The precondition at 215.12 might not hold. Insufficient fraction at 215.12 for FactorialContChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1760[this#186, FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1760[this#186, FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1760[this#186, FactorialContChannelExpEP.valid][perm$N]));
        exhaleMask#_1760[this#186, FactorialContChannelExpEP.valid] := exhaleMask#_1760[this#186, FactorialContChannelExpEP.valid][perm$R := exhaleMask#_1760[this#186, FactorialContChannelExpEP.valid][perm$R] - Fractions(100)];
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        assume wf(Heap, exhaleMask#_1760);
        Mask := exhaleMask#_1760;
        assume wf(Heap, Mask);
        // end exhale
        // inhale (postcondition)
        havoc inhaleHeap#_1768;
        assume IsGoodInhaleState(inhaleHeap#_1768, Heap, Mask);
        assume this#186 != null;
        Heap[this#186, FactorialContChannelExpEP.state] := inhaleHeap#_1768[this#186, FactorialContChannelExpEP.state];
        assume wf(Heap, Mask);
        assume true;
        assume Fractions(100) > 0;
        Mask[this#186, FactorialContChannelExpEP.state] := Mask[this#186, FactorialContChannelExpEP.state][perm$R := Mask[this#186, FactorialContChannelExpEP.state][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1768[this#186, FactorialContChannelExpEP.state]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1768, Mask);
        assume this#186 != null;
        Heap[this#186, FactorialContChannelExpEP.valid] := inhaleHeap#_1768[this#186, FactorialContChannelExpEP.valid];
        assume wf(Heap, Mask);
        assume inhaleHeap#_1768[this#186, FactorialContChannelExpEP.valid] == Heap;
        assume Fractions(100) > 0;
        Mask[this#186, FactorialContChannelExpEP.valid] := Mask[this#186, FactorialContChannelExpEP.valid][perm$R := Mask[this#186, FactorialContChannelExpEP.valid][perm$R] + Fractions(100)];
        assume IsGoodMask(Mask);
        assume IsGoodState(inhaleHeap#_1768[this#186, FactorialContChannelExpEP.valid]);
        assume wf(Heap, Mask);
        assume wf(inhaleHeap#_1768, Mask);
        if (callHeap#_1756[this#186, FactorialContChannelExpEP.state] == 0) {
          assume Heap[this#186, FactorialContChannelExpEP.state] == 1;
        } else {
        }
        assume IsGoodMask(Mask);
        assume wf(Heap, Mask);
        // end inhale
        // local var r
        // assigment to r
        // new
        havoc nw#_1769;
        assume (nw#_1769 != null) && (dtype(nw#_1769) == Message#t);
        assume (forall<T#_25> f: Field (T#_25) :: (Mask[nw#_1769, f][perm$R] == 0) && (Mask[nw#_1769, f][perm$N] == 0));
        assume Heap[nw#_1769, mu] == $LockBottom;
        assume Heap[nw#_1769, held] <= 0;
        assume Heap[nw#_1769, rdheld] == false;
        Mask[nw#_1769, Message.type] := Mask[nw#_1769, Message.type][perm$R := Mask[nw#_1769, Message.type][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.sender1] := Mask[nw#_1769, Message.sender1][perm$R := Mask[nw#_1769, Message.sender1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.sender3] := Mask[nw#_1769, Message.sender3][perm$R := Mask[nw#_1769, Message.sender3][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.sender2] := Mask[nw#_1769, Message.sender2][perm$R := Mask[nw#_1769, Message.sender2][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.sender4] := Mask[nw#_1769, Message.sender4][perm$R := Mask[nw#_1769, Message.sender4][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.receiver1] := Mask[nw#_1769, Message.receiver1][perm$R := Mask[nw#_1769, Message.receiver1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.receiver2] := Mask[nw#_1769, Message.receiver2][perm$R := Mask[nw#_1769, Message.receiver2][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.receiver3] := Mask[nw#_1769, Message.receiver3][perm$R := Mask[nw#_1769, Message.receiver3][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.receiver4] := Mask[nw#_1769, Message.receiver4][perm$R := Mask[nw#_1769, Message.receiver4][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.v1] := Mask[nw#_1769, Message.v1][perm$R := Mask[nw#_1769, Message.v1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.vo1] := Mask[nw#_1769, Message.vo1][perm$R := Mask[nw#_1769, Message.vo1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.cust1] := Mask[nw#_1769, Message.cust1][perm$R := Mask[nw#_1769, Message.cust1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.vr1] := Mask[nw#_1769, Message.vr1][perm$R := Mask[nw#_1769, Message.vr1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.old1] := Mask[nw#_1769, Message.old1][perm$R := Mask[nw#_1769, Message.old1][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.vr2] := Mask[nw#_1769, Message.vr2][perm$R := Mask[nw#_1769, Message.vr2][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.old2] := Mask[nw#_1769, Message.old2][perm$R := Mask[nw#_1769, Message.old2][perm$R] + Fractions(100)];
        Mask[nw#_1769, Message.vr3] := Mask[nw#_1769, Message.vr3][perm$R := Mask[nw#_1769, Message.vr3][perm$R] + Fractions(100)];
        Mask[nw#_1769, mu] := Mask[nw#_1769, mu][perm$R := Mask[nw#_1769, mu][perm$R] + Fractions(100)];
        r#98 := nw#_1769;
        // update field type
        assert {:msg "  910.5: Location might not be writable"} CanWrite(Mask, r#98, Message.type);
        Heap[r#98, Message.type] := 4;
        assume wf(Heap, Mask);
        // assert
        Heap#_1773 := Heap;
        Mask#_1774 := Mask;
        Credits#_1775 := Credits;
        // begin exhale (assert)
        exhaleMask#_1776 := Mask#_1774;
        assert {:msg "  911.12: Receiver might be null."} true ==> (r#98 != null);
        assert {:msg "  911.12: Location might not be readable."} true ==> CanRead(Mask#_1774, r#98, Message.vr3);
        assert {:msg "  911.31: Receiver might be null."} true ==> (this != null);
        assert {:msg "  911.31: Location might not be readable."} true ==> CanRead(Mask#_1774, this, FactorialCont.cust);
        assert {:msg "  911.31: Receiver might be null."} true ==> (Heap#_1773[this, FactorialCont.cust] != null);
        assert {:msg "  911.31: Location might not be readable."} true ==> CanRead(Mask#_1774, Heap#_1773[this, FactorialCont.cust], FactorialCont.vo);
        assert {:msg "  911.19: Receiver might be null."} true ==> (m#96 != null);
        // check precondition of call
        assume (0 < funcappK#_1783) && ((1000 * funcappK#_1783) < Fractions(1));
        assume true;
        Heap#_1780 := Heap#_1773;
        Mask#_1781 := Mask#_1774;
        Credits#_1782 := Credits#_1775;
        // begin exhale (function call)
        exhaleMask#_1784 := Mask#_1781;
        assert {:msg "  911.19: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1780[Heap#_1780[this, FactorialCont.cust], FactorialCont.vo] >= 0;
        Mask#_1781 := exhaleMask#_1784;
        assume wf(Heap#_1780, Mask#_1781);
        // end exhale
        if (Heap#_1773[r#98, Message.vr3] == #Message.factorial(Heap#_1773, Mask#_1774, m#96, Heap#_1773[Heap#_1773[this, FactorialCont.cust], FactorialCont.vo])) {
          assert {:msg "  911.45: Receiver might be null."} true ==> (r#98 != null);
          assert {:msg "  911.45: Location might not be readable."} true ==> CanRead(Mask#_1774, r#98, Message.vr3);
          assert {:msg "  911.64: Receiver might be null."} true ==> (this != null);
          assert {:msg "  911.64: Location might not be readable."} true ==> CanRead(Mask#_1774, this, FactorialCont.vo);
          assert {:msg "  911.52: Receiver might be null."} true ==> (m#96 != null);
          // check precondition of call
          assume (0 < funcappK#_1791) && ((1000 * funcappK#_1791) < Fractions(1));
          assume true;
          Heap#_1788 := Heap#_1773;
          Mask#_1789 := Mask#_1774;
          Credits#_1790 := Credits#_1775;
          // begin exhale (function call)
          exhaleMask#_1792 := Mask#_1789;
          assert {:msg "  911.52: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} Heap#_1788[this, FactorialCont.vo] >= 0;
          Mask#_1789 := exhaleMask#_1792;
          assume wf(Heap#_1788, Mask#_1789);
          // end exhale
          assert {:msg "  911.5: Assertion might not hold. The expression at 911.45 might not evaluate to true."} Heap#_1773[r#98, Message.vr3] == #Message.factorial(Heap#_1773, Mask#_1774, m#96, Heap#_1773[this, FactorialCont.vo]);
        } else {
        }
        if (Heap#_1773[r#98, Message.vr3] == #Message.factorial(Heap#_1773, Mask#_1774, m#96, Heap#_1773[Heap#_1773[this, FactorialCont.cust], FactorialCont.vo])) {
        } else {
        }
        Mask#_1774 := exhaleMask#_1776;
        assume wf(Heap#_1773, Mask#_1774);
        // end exhale
      }
    } else {
      // assume
      assume false;
    }
  }
  assert {:msg "  838.2: Method might lock/unlock more than allowed."} (forall lk#_1793: ref :: {Heap[lk#_1793, held]} {Heap[lk#_1793, rdheld]} (((0 < Heap[lk#_1793, held]) == (0 < old(Heap)[lk#_1793, held])) && (Heap[lk#_1793, rdheld] == old(Heap)[lk#_1793, rdheld])) || false);
  assert {:msg "  838.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
function #FactorialCont.getQ(heap: HeapType, mask: MaskType, this: ref) returns ($myresult: ref);
procedure FactorialCont.getQ$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var functionK#_1794: int;
  var inhaleHeap#_1795: HeapType;
  var result: ref;
  assume (0 < functionK#_1794) && ((1000 * functionK#_1794) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // inhale (precondition)
  havoc inhaleHeap#_1795;
  assume IsGoodInhaleState(inhaleHeap#_1795, Heap, Mask);
  assume this != null;
  Heap[this, FactorialCont.q] := inhaleHeap#_1795[this, FactorialCont.q];
  assume wf(Heap, Mask);
  assume (Heap[this, FactorialCont.q] == null) || (dtype(Heap[this, FactorialCont.q]) == FactorialContChannel#t);
  assume functionK#_1794 > 0;
  Mask[this, FactorialCont.q] := Mask[this, FactorialCont.q][perm$R := Mask[this, FactorialCont.q][perm$R] + functionK#_1794];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1795[this, FactorialCont.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1795, Mask);
  assert {:msg "  921.20: Receiver might be null."} true ==> (this != null);
  assert {:msg "  921.20: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume !(Heap[this, FactorialCont.q] == null);
  assert {:msg "  921.31: Receiver might be null."} true ==> (this != null);
  assert {:msg "  921.31: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assert {:msg "  921.31: Receiver might be null."} Heap[this, FactorialCont.q] != null;
  assert {:msg "  921.31: Receiver might be null."} true ==> (this != null);
  assert {:msg "  921.31: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  assume Heap[this, FactorialCont.q] != null;
  Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid] := inhaleHeap#_1795[Heap[this, FactorialCont.q], FactorialContChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1795[Heap[this, FactorialCont.q], FactorialContChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid] := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R := Mask[Heap[this, FactorialCont.q], FactorialContChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1795[Heap[this, FactorialCont.q], FactorialContChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1795, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  assume CurrentModule == module#default;
  assert {:msg "  923.3: Receiver might be null."} true ==> (this != null);
  assert {:msg "  923.3: Location might not be readable."} true ==> CanRead(Mask, this, FactorialCont.q);
  result := Heap[this, FactorialCont.q];
}
axiom (forall Heap: HeapType, Mask: MaskType, this: ref :: {#FactorialCont.getQ(Heap, Mask, this)} wf(Heap, Mask) && (CurrentModule == module#default) ==> (#FactorialCont.getQ(Heap, Mask, this) == Heap[this, FactorialCont.q]));
function ##FactorialCont.getQ(state: HeapType, this: ref) returns ($myresult: ref);
axiom (forall Heap: HeapType, Mask: MaskType, this: ref :: {#FactorialCont.getQ(Heap, Mask, this)} wf(Heap, Mask) && IsGoodState(combine(nostate, combine(Heap[this, FactorialCont.q], Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid]))) && CanAssumeFunctionDefs ==> (#FactorialCont.getQ(Heap, Mask, this) == ##FactorialCont.getQ(combine(nostate, combine(Heap[this, FactorialCont.q], Heap[Heap[this, FactorialCont.q], FactorialContChannel.valid])), this)));
procedure FactorialCont.main$checkDefinedness(this: ref where (this == null) || (dtype(this) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1796: int;
  assume (0 < methodK#_1796) && ((1000 * methodK#_1796) < Fractions(1));
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  assume CanAssumeFunctionDefs;
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  Mask := ZeroMask;
  Credits := ZeroCredits;
  havoc Heap;
}
procedure FactorialCont.main(this: ref where (this == null) || (dtype(this) == FactorialCont#t)) returns ()
  modifies Heap, Mask, Credits;
  requires this!=null;
  free requires wf(Heap, Mask);
{
  var methodK#_1796: int;
  var actor#100: ref where (actor#100 == null) || (dtype(actor#100) == FactorialActor#t);
  var nw#_1797: ref;
  var methodCallK#_1801: int;
  var this#188: ref where (this#188 == null) || (dtype(this#188) == FactorialActor#t);
  var callHeap#_1798: HeapType;
  var callMask#_1799: MaskType;
  var callCredits#_1800: CreditsType;
  var exhaleMask#_1802: MaskType;
  var isHeld#_1804: int;
  var isRdHeld#_1805: bool;
  var inhaleHeap#_1806: HeapType;
  var m#102: ref where (m#102 == null) || (dtype(m#102) == Message#t);
  var nw#_1807: ref;
  var f#104: ref where (f#104 == null) || (dtype(f#104) == Future#t);
  var nw#_1808: ref;
  var methodCallK#_1812: int;
  var this#189: ref where (this#189 == null) || (dtype(this#189) == Future#t);
  var callHeap#_1809: HeapType;
  var callMask#_1810: MaskType;
  var callCredits#_1811: CreditsType;
  var exhaleMask#_1813: MaskType;
  var isHeld#_1816: int;
  var isRdHeld#_1817: bool;
  var inhaleHeap#_1818: HeapType;
  var unfoldK#_1819: int;
  var exhaleMask#_1820: MaskType;
  var inhaleHeap#_1822: HeapType;
  var unfoldK#_1823: int;
  var exhaleMask#_1824: MaskType;
  var inhaleHeap#_1826: HeapType;
  var methodCallK#_1830: int;
  var this#190: ref where (this#190 == null) || (dtype(this#190) == Message#t);
  var v#191: int where true;
  var vo#192: int where true;
  var cust#193: ref where (cust#193 == null) || (dtype(cust#193) == FactorialCont#t);
  var receiver#194: ref where (receiver#194 == null) || (dtype(receiver#194) == FactorialActor#t);
  var callHeap#_1827: HeapType;
  var callMask#_1828: MaskType;
  var callCredits#_1829: CreditsType;
  var exhaleMask#_1831: MaskType;
  var isHeld#_1848: int;
  var isRdHeld#_1849: bool;
  var inhaleHeap#_1850: HeapType;
  var methodCallK#_1854: int;
  var this#195: ref where (this#195 == null) || (dtype(this#195) == FactorialActorChannelExpEP#t);
  var m#196: ref where (m#196 == null) || (dtype(m#196) == Message#t);
  var callHeap#_1851: HeapType;
  var callMask#_1852: MaskType;
  var callCredits#_1853: CreditsType;
  var exhaleMask#_1855: MaskType;
  var isHeld#_1861: int;
  var isRdHeld#_1862: bool;
  var inhaleHeap#_1863: HeapType;
  var foldK#_1864: int;
  var exhaleMask#_1865: MaskType;
  var inhaleHeap#_1868: HeapType;
  var asyncMethodCallK#_1875: int;
  var preCallHeap#_1871: HeapType;
  var preCallMask#_1872: MaskType;
  var preCallCredits#_1873: CreditsType;
  var argsSeq#_1874: ArgSeq;
  var this#197: ref where (this#197 == null) || (dtype(this#197) == FactorialActor#t);
  var exhaleMask#_1876: MaskType;
  var token#_1869: ref;
  var asyncstate#_1870: int;
  var res#106: ref where (res#106 == null) || (dtype(res#106) == Message#t);
  var methodCallK#_1886: int;
  var this#198: ref where (this#198 == null) || (dtype(this#198) == Future#t);
  var m#199: ref where (m#199 == null) || (dtype(m#199) == Message#t);
  var callHeap#_1883: HeapType;
  var callMask#_1884: MaskType;
  var callCredits#_1885: CreditsType;
  var exhaleMask#_1887: MaskType;
  var isHeld#_1898: int;
  var isRdHeld#_1899: bool;
  var inhaleHeap#_1900: HeapType;
  var Heap#_1904: HeapType;
  var Mask#_1905: MaskType;
  var Credits#_1906: CreditsType;
  var exhaleMask#_1907: MaskType;
  var funcappK#_1914: int;
  var Heap#_1911: HeapType;
  var Mask#_1912: MaskType;
  var Credits#_1913: CreditsType;
  var exhaleMask#_1915: MaskType;
  assume (0 < methodK#_1796) && ((1000 * methodK#_1796) < Fractions(1));
  assume CurrentModule == module#default;
  assume CanAssumeFunctionDefs;
  // define pre-initial state
  Mask := ZeroMask;
  Credits := ZeroCredits;
  // define initial state
  assume Heap == old(Heap);
  assume Mask == old(Mask);
  assume Credits == old(Credits);
  // local var actor
  // assigment to actor
  // new
  havoc nw#_1797;
  assume (nw#_1797 != null) && (dtype(nw#_1797) == FactorialActor#t);
  assume (forall<T#_26> f: Field (T#_26) :: (Mask[nw#_1797, f][perm$R] == 0) && (Mask[nw#_1797, f][perm$N] == 0));
  assume Heap[nw#_1797, mu] == $LockBottom;
  assume Heap[nw#_1797, held] <= 0;
  assume Heap[nw#_1797, rdheld] == false;
  Mask[nw#_1797, FactorialActor.q] := Mask[nw#_1797, FactorialActor.q][perm$R := Mask[nw#_1797, FactorialActor.q][perm$R] + Fractions(100)];
  Mask[nw#_1797, mu] := Mask[nw#_1797, mu][perm$R := Mask[nw#_1797, mu][perm$R] + Fractions(100)];
  actor#100 := nw#_1797;
  assume (0 < methodCallK#_1801) && ((1000 * methodCallK#_1801) < Fractions(1)) && ((1000 * methodCallK#_1801) < methodK#_1796);
  // call init
  callHeap#_1798 := Heap;
  callMask#_1799 := Mask;
  callCredits#_1800 := Credits;
  assert {:msg "  929.3: The target of the method call might be null."} actor#100 != null;
  this#188 := actor#100;
  // begin exhale (precondition)
  exhaleMask#_1802 := Mask;
  assert {:msg "  929.3: The precondition at 725.11 might not hold. The permission at 725.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  929.3: The precondition at 725.11 might not hold. Insufficient fraction at 725.11 for FactorialActor.q."} (Fractions(100) <= exhaleMask#_1802[this#188, FactorialActor.q][perm$R]) && ((Fractions(100) == exhaleMask#_1802[this#188, FactorialActor.q][perm$R]) ==> (0 <= exhaleMask#_1802[this#188, FactorialActor.q][perm$N]));
  exhaleMask#_1802[this#188, FactorialActor.q] := exhaleMask#_1802[this#188, FactorialActor.q][perm$R := exhaleMask#_1802[this#188, FactorialActor.q][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1802);
  Mask := exhaleMask#_1802;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1806;
  assume IsGoodInhaleState(inhaleHeap#_1806, Heap, Mask);
  assume this#188 != null;
  Heap[this#188, FactorialActor.q] := inhaleHeap#_1806[this#188, FactorialActor.q];
  assume wf(Heap, Mask);
  assume (Heap[this#188, FactorialActor.q] == null) || (dtype(Heap[this#188, FactorialActor.q]) == FactorialActorChannel#t);
  assume Fractions(50) > 0;
  Mask[this#188, FactorialActor.q] := Mask[this#188, FactorialActor.q][perm$R := Mask[this#188, FactorialActor.q][perm$R] + Fractions(50)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[this#188, FactorialActor.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume !(Heap[this#188, FactorialActor.q] == null);
  assume Heap[this#188, FactorialActor.q] != null;
  Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume Heap[this#188, FactorialActor.q] != null;
  Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid] := inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid] := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid][perm$R := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume Heap[this#188, FactorialActor.q] != null;
  Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState] := inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState] := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume Heap[this#188, FactorialActor.q] != null;
  Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState] := inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState] := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume Heap[this#188, FactorialActor.q] != null;
  Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume !(Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp] == null);
  assume Heap[this#188, FactorialActor.q] != null;
  Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := inhaleHeap#_1806[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null) || (dtype(Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := Mask[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := Mask[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume !(Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  assume Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := inhaleHeap#_1806[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null) || (dtype(Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]) == Channel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] := Mask[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R := Mask[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1806[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1806, Mask);
  assume !(Heap[Heap[Heap[this#188, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.expch] == null);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // local var m
  // assigment to m
  // new
  havoc nw#_1807;
  assume (nw#_1807 != null) && (dtype(nw#_1807) == Message#t);
  assume (forall<T#_27> f: Field (T#_27) :: (Mask[nw#_1807, f][perm$R] == 0) && (Mask[nw#_1807, f][perm$N] == 0));
  assume Heap[nw#_1807, mu] == $LockBottom;
  assume Heap[nw#_1807, held] <= 0;
  assume Heap[nw#_1807, rdheld] == false;
  Mask[nw#_1807, Message.type] := Mask[nw#_1807, Message.type][perm$R := Mask[nw#_1807, Message.type][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.sender1] := Mask[nw#_1807, Message.sender1][perm$R := Mask[nw#_1807, Message.sender1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.sender3] := Mask[nw#_1807, Message.sender3][perm$R := Mask[nw#_1807, Message.sender3][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.sender2] := Mask[nw#_1807, Message.sender2][perm$R := Mask[nw#_1807, Message.sender2][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.sender4] := Mask[nw#_1807, Message.sender4][perm$R := Mask[nw#_1807, Message.sender4][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.receiver1] := Mask[nw#_1807, Message.receiver1][perm$R := Mask[nw#_1807, Message.receiver1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.receiver2] := Mask[nw#_1807, Message.receiver2][perm$R := Mask[nw#_1807, Message.receiver2][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.receiver3] := Mask[nw#_1807, Message.receiver3][perm$R := Mask[nw#_1807, Message.receiver3][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.receiver4] := Mask[nw#_1807, Message.receiver4][perm$R := Mask[nw#_1807, Message.receiver4][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.v1] := Mask[nw#_1807, Message.v1][perm$R := Mask[nw#_1807, Message.v1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.vo1] := Mask[nw#_1807, Message.vo1][perm$R := Mask[nw#_1807, Message.vo1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.cust1] := Mask[nw#_1807, Message.cust1][perm$R := Mask[nw#_1807, Message.cust1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.vr1] := Mask[nw#_1807, Message.vr1][perm$R := Mask[nw#_1807, Message.vr1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.old1] := Mask[nw#_1807, Message.old1][perm$R := Mask[nw#_1807, Message.old1][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.vr2] := Mask[nw#_1807, Message.vr2][perm$R := Mask[nw#_1807, Message.vr2][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.old2] := Mask[nw#_1807, Message.old2][perm$R := Mask[nw#_1807, Message.old2][perm$R] + Fractions(100)];
  Mask[nw#_1807, Message.vr3] := Mask[nw#_1807, Message.vr3][perm$R := Mask[nw#_1807, Message.vr3][perm$R] + Fractions(100)];
  Mask[nw#_1807, mu] := Mask[nw#_1807, mu][perm$R := Mask[nw#_1807, mu][perm$R] + Fractions(100)];
  m#102 := nw#_1807;
  // local var f
  // assigment to f
  // new
  havoc nw#_1808;
  assume (nw#_1808 != null) && (dtype(nw#_1808) == Future#t);
  assume (forall<T#_28> f: Field (T#_28) :: (Mask[nw#_1808, f][perm$R] == 0) && (Mask[nw#_1808, f][perm$N] == 0));
  assume Heap[nw#_1808, mu] == $LockBottom;
  assume Heap[nw#_1808, held] <= 0;
  assume Heap[nw#_1808, rdheld] == false;
  Mask[nw#_1808, Future.sent] := Mask[nw#_1808, Future.sent][perm$R := Mask[nw#_1808, Future.sent][perm$R] + Fractions(100)];
  Mask[nw#_1808, Future.value] := Mask[nw#_1808, Future.value][perm$R := Mask[nw#_1808, Future.value][perm$R] + Fractions(100)];
  Mask[nw#_1808, Future.q] := Mask[nw#_1808, Future.q][perm$R := Mask[nw#_1808, Future.q][perm$R] + Fractions(100)];
  Mask[nw#_1808, mu] := Mask[nw#_1808, mu][perm$R := Mask[nw#_1808, mu][perm$R] + Fractions(100)];
  f#104 := nw#_1808;
  assume (0 < methodCallK#_1812) && ((1000 * methodCallK#_1812) < Fractions(1)) && ((1000 * methodCallK#_1812) < methodK#_1796);
  // call init
  callHeap#_1809 := Heap;
  callMask#_1810 := Mask;
  callCredits#_1811 := Credits;
  assert {:msg "  934.3: The target of the method call might be null."} f#104 != null;
  this#189 := f#104;
  // begin exhale (precondition)
  exhaleMask#_1813 := Mask;
  assert {:msg "  934.3: The precondition at 550.11 might not hold. The permission at 550.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  934.3: The precondition at 550.11 might not hold. Insufficient fraction at 550.11 for Future.q."} (Fractions(100) <= exhaleMask#_1813[this#189, Future.q][perm$R]) && ((Fractions(100) == exhaleMask#_1813[this#189, Future.q][perm$R]) ==> (0 <= exhaleMask#_1813[this#189, Future.q][perm$N]));
  exhaleMask#_1813[this#189, Future.q] := exhaleMask#_1813[this#189, Future.q][perm$R := exhaleMask#_1813[this#189, Future.q][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1813);
  assert {:msg "  934.3: The precondition at 550.11 might not hold. The permission at 550.21 might not be positive."} Fractions(100) > 0;
  assert {:msg "  934.3: The precondition at 550.11 might not hold. Insufficient fraction at 550.21 for Future.value."} (Fractions(100) <= exhaleMask#_1813[this#189, Future.value][perm$R]) && ((Fractions(100) == exhaleMask#_1813[this#189, Future.value][perm$R]) ==> (0 <= exhaleMask#_1813[this#189, Future.value][perm$N]));
  exhaleMask#_1813[this#189, Future.value] := exhaleMask#_1813[this#189, Future.value][perm$R := exhaleMask#_1813[this#189, Future.value][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1813);
  Mask := exhaleMask#_1813;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1818;
  assume IsGoodInhaleState(inhaleHeap#_1818, Heap, Mask);
  assume this#189 != null;
  Heap[this#189, Future.q] := inhaleHeap#_1818[this#189, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this#189, Future.q] == null) || (dtype(Heap[this#189, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this#189, Future.q] := Mask[this#189, Future.q][perm$R := Mask[this#189, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1818[this#189, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1818, Mask);
  assume this#189 != null;
  Heap[this#189, Future.value] := inhaleHeap#_1818[this#189, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this#189, Future.value] == null) || (dtype(Heap[this#189, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this#189, Future.value] := Mask[this#189, Future.value][perm$R := Mask[this#189, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1818[this#189, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1818, Mask);
  assume !(Heap[this#189, Future.q] == null);
  assume Heap[this#189, Future.q] != null;
  Heap[Heap[this#189, Future.q], FutureChannel.valid] := inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#189, Future.q], FutureChannel.valid] := Mask[Heap[this#189, Future.q], FutureChannel.valid][perm$R := Mask[Heap[this#189, Future.q], FutureChannel.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1818, Mask);
  assume Heap[this#189, Future.q] != null;
  Heap[Heap[this#189, Future.q], FutureChannel.initExpState] := inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#189, Future.q], FutureChannel.initExpState] := Mask[Heap[this#189, Future.q], FutureChannel.initExpState][perm$R := Mask[Heap[this#189, Future.q], FutureChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1818, Mask);
  assume Heap[this#189, Future.q] != null;
  Heap[Heap[this#189, Future.q], FutureChannel.initImpState] := inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.initImpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.initImpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#189, Future.q], FutureChannel.initImpState] := Mask[Heap[this#189, Future.q], FutureChannel.initImpState][perm$R := Mask[Heap[this#189, Future.q], FutureChannel.initImpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1818[Heap[this#189, Future.q], FutureChannel.initImpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1818, Mask);
  assume Heap[this#189, Future.value] == null;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1819) && (unfoldK#_1819 < Fractions(1)) && ((1000 * unfoldK#_1819) < methodK#_1796);
  assert {:msg "  935.10: Receiver might be null."} true ==> (actor#100 != null);
  assert {:msg "  935.10: Location might not be readable."} true ==> CanRead(Mask, actor#100, FactorialActor.q);
  assert {:msg "  935.3: The target of the fold statement might be null."} Heap[actor#100, FactorialActor.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1820 := Mask;
  assert {:msg "  935.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  935.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_1820[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1820[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1820[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid][perm$N]));
  exhaleMask#_1820[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid] := exhaleMask#_1820[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid][perm$R := exhaleMask#_1820[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1820);
  Mask := exhaleMask#_1820;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1822 := Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.valid];
  assume IsGoodInhaleState(inhaleHeap#_1822, Heap, Mask);
  assume Heap[actor#100, FactorialActor.q] != null;
  Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp] := inhaleHeap#_1822[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp] == null) || (dtype(Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
  assume monitorK > 0;
  Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp] := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp][perm$R := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1822[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1822, Mask);
  assume Heap[actor#100, FactorialActor.q] != null;
  Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1822[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1822[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1822, Mask);
  assume Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == null) || (dtype(Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1822, Mask);
  assume Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch];
  assume wf(Heap, Mask);
  assume (Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == null) || (dtype(Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
  assume monitorK > 0;
  Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1822, Mask);
  assume !(Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp] == null);
  assume !(Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] == null);
  assume Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp] != null;
  Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid] := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1822, Mask);
  assume Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid] := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1822[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1822, Mask);
  assume Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.ch] == Heap[actor#100, FactorialActor.q];
  assume Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.ch] == Heap[actor#100, FactorialActor.q];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // unfold
  assume (0 < unfoldK#_1823) && (unfoldK#_1823 < Fractions(1)) && ((1000 * unfoldK#_1823) < methodK#_1796);
  assert {:msg "  936.10: Receiver might be null."} true ==> (actor#100 != null);
  assert {:msg "  936.10: Location might not be readable."} true ==> CanRead(Mask, actor#100, FactorialActor.q);
  assert {:msg "  936.3: The target of the fold statement might be null."} Heap[actor#100, FactorialActor.q] != null;
  // begin exhale (unfold)
  exhaleMask#_1824 := Mask;
  assert {:msg "  936.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. The permission at <undefined position> might not be positive."} Fractions(100) > 0;
  assert {:msg "  936.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initExpState."} (Fractions(100) <= exhaleMask#_1824[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1824[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1824[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$N]));
  exhaleMask#_1824[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState] := exhaleMask#_1824[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := exhaleMask#_1824[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1824);
  Mask := exhaleMask#_1824;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (unfold)
  inhaleHeap#_1826 := Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState];
  assume IsGoodInhaleState(inhaleHeap#_1826, Heap, Mask);
  assume Heap[actor#100, FactorialActor.q] != null;
  Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] := inhaleHeap#_1826[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp];
  assume wf(Heap, Mask);
  assume (Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] == null) || (dtype(Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
  assume monitorK > 0;
  Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1826[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1826, Mask);
  assume Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] != null;
  Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := inhaleHeap#_1826[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := Mask[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1826[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1826, Mask);
  assume Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // update field sender1
  assert {:msg "  937.3: Location might not be writable"} CanWrite(Mask, m#102, Message.sender1);
  Heap[m#102, Message.sender1] := f#104;
  assume wf(Heap, Mask);
  // update field sent
  assert {:msg "  938.3: Location might not be writable"} CanWrite(Mask, f#104, Future.sent);
  Heap[f#104, Future.sent] := m#102;
  assume wf(Heap, Mask);
  assume (0 < methodCallK#_1830) && ((1000 * methodCallK#_1830) < Fractions(1)) && ((1000 * methodCallK#_1830) < methodK#_1796);
  // call setValue
  callHeap#_1827 := Heap;
  callMask#_1828 := Mask;
  callCredits#_1829 := Credits;
  assert {:msg "  939.3: The target of the method call might be null."} m#102 != null;
  this#190 := m#102;
  v#191 := 5;
  vo#192 := 5;
  cust#193 := null;
  receiver#194 := actor#100;
  // begin exhale (precondition)
  exhaleMask#_1831 := Mask;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 661.3 might not evaluate to true."} !(Heap[this#190, Message.sender1] == null);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 661.42 might not evaluate to true."} !(Heap[Heap[this#190, Message.sender1], Future.q] == null);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 662.48 might not evaluate to true."} v#191 >= 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 662.56 might not evaluate to true."} vo#192 >= 0;
  if (cust#193 == null) {
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 663.19 might not evaluate to true."} v#191 == vo#192;
  } else {
  }
  if (!(cust#193 == null)) {
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 664.23 might not evaluate to true."} !(Heap[cust#193, FactorialCont.q] == null);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 665.55 might not evaluate to true."} !(Heap[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] == null);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 666.23 might not evaluate to true."} v#191 == (Heap[cust#193, FactorialCont.v] - 1);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The expression at 666.38 might not evaluate to true."} vo#192 == Heap[cust#193, FactorialCont.vo];
  } else {
  }
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 659.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 659.11 for Message.type."} (Fractions(100) <= exhaleMask#_1831[this#190, Message.type][perm$R]) && ((Fractions(100) == exhaleMask#_1831[this#190, Message.type][perm$R]) ==> (0 <= exhaleMask#_1831[this#190, Message.type][perm$N]));
  exhaleMask#_1831[this#190, Message.type] := exhaleMask#_1831[this#190, Message.type][perm$R := exhaleMask#_1831[this#190, Message.type][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 659.24 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 659.24 for Message.sender1."} (Fractions(100) <= exhaleMask#_1831[this#190, Message.sender1][perm$R]) && ((Fractions(100) == exhaleMask#_1831[this#190, Message.sender1][perm$R]) ==> (0 <= exhaleMask#_1831[this#190, Message.sender1][perm$N]));
  exhaleMask#_1831[this#190, Message.sender1] := exhaleMask#_1831[this#190, Message.sender1][perm$R := exhaleMask#_1831[this#190, Message.sender1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 659.40 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 659.40 for Message.receiver1."} (Fractions(100) <= exhaleMask#_1831[this#190, Message.receiver1][perm$R]) && ((Fractions(100) == exhaleMask#_1831[this#190, Message.receiver1][perm$R]) ==> (0 <= exhaleMask#_1831[this#190, Message.receiver1][perm$N]));
  exhaleMask#_1831[this#190, Message.receiver1] := exhaleMask#_1831[this#190, Message.receiver1][perm$R := exhaleMask#_1831[this#190, Message.receiver1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 660.3 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 660.3 for Message.v1."} (Fractions(100) <= exhaleMask#_1831[this#190, Message.v1][perm$R]) && ((Fractions(100) == exhaleMask#_1831[this#190, Message.v1][perm$R]) ==> (0 <= exhaleMask#_1831[this#190, Message.v1][perm$N]));
  exhaleMask#_1831[this#190, Message.v1] := exhaleMask#_1831[this#190, Message.v1][perm$R := exhaleMask#_1831[this#190, Message.v1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 660.14 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 660.14 for Message.vo1."} (Fractions(100) <= exhaleMask#_1831[this#190, Message.vo1][perm$R]) && ((Fractions(100) == exhaleMask#_1831[this#190, Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1831[this#190, Message.vo1][perm$N]));
  exhaleMask#_1831[this#190, Message.vo1] := exhaleMask#_1831[this#190, Message.vo1][perm$R := exhaleMask#_1831[this#190, Message.vo1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 660.26 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 660.26 for Message.cust1."} (Fractions(100) <= exhaleMask#_1831[this#190, Message.cust1][perm$R]) && ((Fractions(100) == exhaleMask#_1831[this#190, Message.cust1][perm$R]) ==> (0 <= exhaleMask#_1831[this#190, Message.cust1][perm$N]));
  exhaleMask#_1831[this#190, Message.cust1] := exhaleMask#_1831[this#190, Message.cust1][perm$R := exhaleMask#_1831[this#190, Message.cust1][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 661.20 might not be positive."} monitorK > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 661.20 for Future.q."} (monitorK <= exhaleMask#_1831[Heap[this#190, Message.sender1], Future.q][perm$R]) && ((monitorK == exhaleMask#_1831[Heap[this#190, Message.sender1], Future.q][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[this#190, Message.sender1], Future.q][perm$N]));
  exhaleMask#_1831[Heap[this#190, Message.sender1], Future.q] := exhaleMask#_1831[Heap[this#190, Message.sender1], Future.q][perm$R := exhaleMask#_1831[Heap[this#190, Message.sender1], Future.q][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 662.3 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 662.3 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.valid][perm$N]));
  exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.valid] := exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.valid][perm$R := exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 662.22 might not be positive."} Fractions(100) > 0;
  assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 662.22 for FutureChannel.initExpState."} (Fractions(100) <= exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.initExpState][perm$N]));
  exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.initExpState] := exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.initExpState][perm$R := exhaleMask#_1831[Heap[Heap[this#190, Message.sender1], Future.q], FutureChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1831);
  if (cust#193 == null) {
  } else {
  }
  if (!(cust#193 == null)) {
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 664.4 might not be positive."} monitorK > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 664.4 for FactorialCont.q."} (monitorK <= exhaleMask#_1831[cust#193, FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1831[cust#193, FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1831[cust#193, FactorialCont.q][perm$N]));
    exhaleMask#_1831[cust#193, FactorialCont.q] := exhaleMask#_1831[cust#193, FactorialCont.q][perm$R := exhaleMask#_1831[cust#193, FactorialCont.q][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 664.39 might not be positive."} Fractions(100) > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 664.39 for FactorialContChannel.valid."} (Fractions(100) <= exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.valid][perm$N]));
    exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.valid] := exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.valid][perm$R := exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.valid][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 664.55 might not be positive."} Fractions(100) > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 664.55 for FactorialContChannel.initExpState."} (Fractions(100) <= exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.initExpState][perm$N]));
    exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.initExpState] := exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.initExpState][perm$R := exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.initExpState][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 665.3 might not be positive."} monitorK > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 665.3 for FactorialContChannel.imp."} (monitorK <= exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp][perm$N]));
    exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp] := exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp][perm$R := exhaleMask#_1831[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 665.26 might not be positive."} monitorK > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 665.26 for FactorialContChannelImpEP.impch."} (monitorK <= exhaleMask#_1831[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1831[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1831[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$N]));
    exhaleMask#_1831[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch] := exhaleMask#_1831[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1831[Heap[Heap[cust#193, FactorialCont.q], FactorialContChannel.imp], FactorialContChannelImpEP.impch][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 665.81 might not be positive."} monitorK > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 665.81 for FactorialCont.v."} (monitorK <= exhaleMask#_1831[cust#193, FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1831[cust#193, FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1831[cust#193, FactorialCont.v][perm$N]));
    exhaleMask#_1831[cust#193, FactorialCont.v] := exhaleMask#_1831[cust#193, FactorialCont.v][perm$R := exhaleMask#_1831[cust#193, FactorialCont.v][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
    assert {:msg "  939.3: The precondition at 659.11 might not hold. The permission at 666.3 might not be positive."} monitorK > 0;
    assert {:msg "  939.3: The precondition at 659.11 might not hold. Insufficient fraction at 666.3 for FactorialCont.vo."} (monitorK <= exhaleMask#_1831[cust#193, FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1831[cust#193, FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1831[cust#193, FactorialCont.vo][perm$N]));
    exhaleMask#_1831[cust#193, FactorialCont.vo] := exhaleMask#_1831[cust#193, FactorialCont.vo][perm$R := exhaleMask#_1831[cust#193, FactorialCont.vo][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1831);
  } else {
  }
  Mask := exhaleMask#_1831;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1850;
  assume IsGoodInhaleState(inhaleHeap#_1850, Heap, Mask);
  assume this#190 != null;
  Heap[this#190, Message.invValue] := inhaleHeap#_1850[this#190, Message.invValue];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1850[this#190, Message.invValue] == Heap;
  assume Fractions(100) > 0;
  Mask[this#190, Message.invValue] := Mask[this#190, Message.invValue][perm$R := Mask[this#190, Message.invValue][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1850[this#190, Message.invValue]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1850, Mask);
  assume this#190 != null;
  Heap[this#190, Message.type] := inhaleHeap#_1850[this#190, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this#190, Message.type] := Mask[this#190, Message.type][perm$R := Mask[this#190, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1850[this#190, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1850, Mask);
  assume this#190 != null;
  Heap[this#190, Message.type] := inhaleHeap#_1850[this#190, Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this#190, Message.type] := Mask[this#190, Message.type][perm$R := Mask[this#190, Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1850[this#190, Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1850, Mask);
  assume Heap[this#190, Message.type] == 1;
  assume this#190 != null;
  Heap[this#190, Message.vo1] := inhaleHeap#_1850[this#190, Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[this#190, Message.vo1] := Mask[this#190, Message.vo1][perm$R := Mask[this#190, Message.vo1][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1850[this#190, Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1850, Mask);
  assume Heap[this#190, Message.vo1] >= 0;
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  assume (0 < methodCallK#_1854) && ((1000 * methodCallK#_1854) < Fractions(1)) && ((1000 * methodCallK#_1854) < methodK#_1796);
  // call sendValue
  callHeap#_1851 := Heap;
  callMask#_1852 := Mask;
  callCredits#_1853 := Credits;
  assert {:msg "  940.8: Receiver might be null."} true ==> (actor#100 != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, actor#100, FactorialActor.q);
  assert {:msg "  <undefined position>: Receiver might be null."} true ==> (Heap[actor#100, FactorialActor.q] != null);
  assert {:msg "  <undefined position>: Location might not be readable."} true ==> CanRead(Mask, Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp);
  assert {:msg "  940.3: The target of the method call might be null."} Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] != null;
  this#195 := Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp];
  m#196 := m#102;
  // begin exhale (precondition)
  exhaleMask#_1855 := Mask;
  assert {:msg "  940.3: The precondition at 34.11 might not hold. The expression at 34.63 might not evaluate to true."} Heap[m#196, Message.type] == 1;
  assert {:msg "  940.3: The precondition at 36.11 might not hold. The expression at 36.11 might not evaluate to true."} Heap[this#195, FactorialActorChannelExpEP.state] == 0;
  assert {:msg "  940.3: The precondition at 34.11 might not hold. The permission at 34.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  940.3: The precondition at 34.11 might not hold. Insufficient fraction at 34.11 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1855[this#195, FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1855[this#195, FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1855[this#195, FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_1855[this#195, FactorialActorChannelExpEP.state] := exhaleMask#_1855[this#195, FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1855[this#195, FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1855);
  assert {:msg "  940.3: The precondition at 34.11 might not hold. The permission at 34.25 might not be positive."} monitorK > 0;
  assert {:msg "  940.3: The precondition at 34.11 might not hold. Insufficient fraction at 34.25 for Message.type."} (monitorK <= exhaleMask#_1855[m#196, Message.type][perm$R]) && ((monitorK == exhaleMask#_1855[m#196, Message.type][perm$R]) ==> (0 <= exhaleMask#_1855[m#196, Message.type][perm$N]));
  exhaleMask#_1855[m#196, Message.type] := exhaleMask#_1855[m#196, Message.type][perm$R := exhaleMask#_1855[m#196, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1855);
  assert {:msg "  940.3: The precondition at 34.11 might not hold. The permission at 34.44 might not be positive."} monitorK > 0;
  assert {:msg "  940.3: The precondition at 34.11 might not hold. Insufficient fraction at 34.44 for Message.type."} (monitorK <= exhaleMask#_1855[m#196, Message.type][perm$R]) && ((monitorK == exhaleMask#_1855[m#196, Message.type][perm$R]) ==> (0 <= exhaleMask#_1855[m#196, Message.type][perm$N]));
  exhaleMask#_1855[m#196, Message.type] := exhaleMask#_1855[m#196, Message.type][perm$R := exhaleMask#_1855[m#196, Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1855);
  assert {:msg "  940.3: The precondition at 34.11 might not hold. The permission at 34.76 might not be positive."} Fractions(100) > 0;
  assert {:msg "  940.3: The precondition at 34.11 might not hold. Insufficient fraction at 34.76 for Message.invValue."} (Fractions(100) <= exhaleMask#_1855[m#196, Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_1855[m#196, Message.invValue][perm$R]) ==> (0 <= exhaleMask#_1855[m#196, Message.invValue][perm$N]));
  exhaleMask#_1855[m#196, Message.invValue] := exhaleMask#_1855[m#196, Message.invValue][perm$R := exhaleMask#_1855[m#196, Message.invValue][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1855);
  assert {:msg "  940.3: The precondition at 35.11 might not hold. The permission at 35.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  940.3: The precondition at 35.11 might not hold. Insufficient fraction at 35.11 for FactorialActorChannelExpEP.valid."} (Fractions(100) <= exhaleMask#_1855[this#195, FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1855[this#195, FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1855[this#195, FactorialActorChannelExpEP.valid][perm$N]));
  exhaleMask#_1855[this#195, FactorialActorChannelExpEP.valid] := exhaleMask#_1855[this#195, FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1855[this#195, FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1855);
  Mask := exhaleMask#_1855;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (postcondition)
  havoc inhaleHeap#_1863;
  assume IsGoodInhaleState(inhaleHeap#_1863, Heap, Mask);
  assume this#195 != null;
  Heap[this#195, FactorialActorChannelExpEP.state] := inhaleHeap#_1863[this#195, FactorialActorChannelExpEP.state];
  assume wf(Heap, Mask);
  assume true;
  assume Fractions(100) > 0;
  Mask[this#195, FactorialActorChannelExpEP.state] := Mask[this#195, FactorialActorChannelExpEP.state][perm$R := Mask[this#195, FactorialActorChannelExpEP.state][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1863[this#195, FactorialActorChannelExpEP.state]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1863, Mask);
  assume this#195 != null;
  Heap[this#195, FactorialActorChannelExpEP.valid] := inhaleHeap#_1863[this#195, FactorialActorChannelExpEP.valid];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1863[this#195, FactorialActorChannelExpEP.valid] == Heap;
  assume Fractions(100) > 0;
  Mask[this#195, FactorialActorChannelExpEP.valid] := Mask[this#195, FactorialActorChannelExpEP.valid][perm$R := Mask[this#195, FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1863[this#195, FactorialActorChannelExpEP.valid]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1863, Mask);
  if (callHeap#_1851[this#195, FactorialActorChannelExpEP.state] == 0) {
    assume Heap[this#195, FactorialActorChannelExpEP.state] == 0;
  } else {
  }
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  // fold
  assume (0 < foldK#_1864) && ((1000 * foldK#_1864) < Fractions(1)) && ((1000 * foldK#_1864) < methodK#_1796);
  assert {:msg "  941.8: Receiver might be null."} true ==> (actor#100 != null);
  assert {:msg "  941.8: Location might not be readable."} true ==> CanRead(Mask, actor#100, FactorialActor.q);
  assert {:msg "  941.3: The target of the fold statement might be null."} Heap[actor#100, FactorialActor.q] != null;
  // begin exhale (fold)
  exhaleMask#_1865 := Mask;
  assert {:msg "  941.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. The expression at 139.37 might not evaluate to true."} Heap[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] == 0;
  assert {:msg "  941.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. The permission at 139.3 might not be positive."} monitorK > 0;
  assert {:msg "  941.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. Insufficient fraction at 139.3 for FactorialActorChannel.exp."} (monitorK <= exhaleMask#_1865[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1865[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1865[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$N]));
  exhaleMask#_1865[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp] := exhaleMask#_1865[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R := exhaleMask#_1865[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1865);
  assert {:msg "  941.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. The permission at 139.19 might not be positive."} Fractions(100) > 0;
  assert {:msg "  941.3: Fold might fail because the definition of FactorialActorChannel.initExpState does not hold. Insufficient fraction at 139.19 for FactorialActorChannelExpEP.state."} (Fractions(100) <= exhaleMask#_1865[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1865[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1865[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$N]));
  exhaleMask#_1865[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state] := exhaleMask#_1865[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1865[Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.exp], FactorialActorChannelExpEP.state][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1865);
  Mask := exhaleMask#_1865;
  assume wf(Heap, Mask);
  // end exhale
  // inhale (fold)
  havoc inhaleHeap#_1868;
  assume IsGoodInhaleState(inhaleHeap#_1868, Heap, Mask);
  assume Heap[actor#100, FactorialActor.q] != null;
  Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState] := inhaleHeap#_1868[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1868[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState] := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := Mask[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1868[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1868, Mask);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  Heap[Heap[actor#100, FactorialActor.q], FactorialActorChannel.initExpState] := Heap;
  assume wf(Heap, Mask);
  assume (0 < asyncMethodCallK#_1875) && ((1000 * asyncMethodCallK#_1875) < Fractions(1)) && ((1000 * asyncMethodCallK#_1875) < methodK#_1796);
  // call act
  preCallHeap#_1871 := Heap;
  preCallMask#_1872 := Mask;
  preCallCredits#_1873 := Credits;
  assert {:msg "  944.3: The target of the method call might be null."} actor#100 != null;
  this#197 := actor#100;
  argsSeq#_1874[0] := this#197;
  // begin exhale (precondition)
  exhaleMask#_1876 := Mask;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The expression at 735.25 might not evaluate to true."} !(Heap[this#197, FactorialActor.q] == null);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The expression at 735.101 might not evaluate to true."} !(Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp] == null);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The expression at 735.140 might not evaluate to true."} !(Heap[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] == null);
  Credits[Heap[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch]] - 1;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The permission at 735.11 might not be positive."} monitorK > 0;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. Insufficient fraction at 735.11 for FactorialActor.q."} (monitorK <= exhaleMask#_1876[this#197, FactorialActor.q][perm$R]) && ((monitorK == exhaleMask#_1876[this#197, FactorialActor.q][perm$R]) ==> (0 <= exhaleMask#_1876[this#197, FactorialActor.q][perm$N]));
  exhaleMask#_1876[this#197, FactorialActor.q] := exhaleMask#_1876[this#197, FactorialActor.q][perm$R := exhaleMask#_1876[this#197, FactorialActor.q][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1876);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The permission at 735.36 might not be positive."} Fractions(100) > 0;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. Insufficient fraction at 735.36 for FactorialActorChannel.valid."} (Fractions(100) <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.valid][perm$N]));
  exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.valid] := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.valid][perm$R := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1876);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The permission at 735.47 might not be positive."} Fractions(100) > 0;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. Insufficient fraction at 735.47 for FactorialActorChannel.initImpState."} (Fractions(100) <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initImpState][perm$N]));
  exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initImpState] := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initImpState][perm$R := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initImpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1876);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The permission at 735.65 might not be positive."} Fractions(100) > 0;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. Insufficient fraction at 735.65 for FactorialActorChannel.initExpState."} (Fractions(100) <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initExpState][perm$N]));
  exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initExpState] := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initExpState][perm$R := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.initExpState][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1876);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The permission at 735.83 might not be positive."} monitorK > 0;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. Insufficient fraction at 735.83 for FactorialActorChannel.imp."} (monitorK <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp][perm$N]));
  exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp] := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp][perm$R := exhaleMask#_1876[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1876);
  assert {:msg "  944.3: The precondition at 735.11 might not hold. The permission at 735.116 might not be positive."} monitorK > 0;
  assert {:msg "  944.3: The precondition at 735.11 might not hold. Insufficient fraction at 735.116 for FactorialActorChannelImpEP.impch."} (monitorK <= exhaleMask#_1876[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1876[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1876[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$N]));
  exhaleMask#_1876[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch] := exhaleMask#_1876[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1876[Heap[Heap[this#197, FactorialActor.q], FactorialActorChannel.imp], FactorialActorChannelImpEP.impch][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1876);
  Mask := exhaleMask#_1876;
  assume wf(Heap, Mask);
  // end exhale
  havoc token#_1869;
  assume token#_1869 != null;
  assume Heap[token#_1869, joinable] == 0;
  assume Mask[token#_1869, joinable][perm$N] == 0;
  assume Mask[token#_1869, joinable][perm$R] == 0;
  Mask[token#_1869, joinable] := Mask[token#_1869, joinable][perm$R := Mask[token#_1869, joinable][perm$R] + Fractions(100)];
  havoc asyncstate#_1870;
  assume asyncstate#_1870 != 0;
  Heap[token#_1869, joinable] := asyncstate#_1870;
  Heap[token#_1869, forkK] := asyncMethodCallK#_1875;
  assume Call$Heap(asyncstate#_1870) == preCallHeap#_1871;
  assume Call$Mask(asyncstate#_1870) == preCallMask#_1872;
  assume Call$Credits(asyncstate#_1870) == preCallCredits#_1873;
  assume Call$Args(asyncstate#_1870) == argsSeq#_1874;
  assume wf(Heap, Mask);
  // local var res
  // assigment to res
  res#106 := null;
  assume (0 < methodCallK#_1886) && ((1000 * methodCallK#_1886) < Fractions(1)) && ((1000 * methodCallK#_1886) < methodK#_1796);
  // call get
  callHeap#_1883 := Heap;
  callMask#_1884 := Mask;
  callCredits#_1885 := Credits;
  assert {:msg "  947.3: The target of the method call might be null."} f#104 != null;
  this#198 := f#104;
  // begin exhale (precondition)
  exhaleMask#_1887 := Mask;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The expression at 563.65 might not evaluate to true."} Heap[Heap[this#198, Future.sent], Message.type] == 1;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The expression at 563.103 might not evaluate to true."} Heap[Heap[this#198, Future.sent], Message.vo1] >= 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The expression at 564.40 might not evaluate to true."} !(Heap[this#198, Future.q] == null);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The expression at 564.51 might not evaluate to true."} !(Heap[this#198, Future.sent] == null);
  if (!(Heap[this#198, Future.value] == null)) {
    assert {:msg "  947.3: The precondition at 565.12 might not hold. The expression at 566.4 might not evaluate to true."} Heap[Heap[this#198, Future.value], Message.type] == 4;
    assert {:msg "  947.3: The precondition at 565.12 might not hold. The expression at 566.68 might not evaluate to true."} Heap[Heap[this#198, Future.value], Message.vr3] == #Message.factorial(Heap, Mask, Heap[this#198, Future.sent], Heap[Heap[this#198, Future.sent], Message.vo1]);
  } else {
  }
  if (Heap[this#198, Future.value] == null) {
    Credits[Heap[Heap[Heap[this#198, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] := Credits[Heap[Heap[Heap[this#198, Future.q], FutureChannel.imp], FutureChannelImpEP.impch]] - 1;
    assert {:msg "  947.3: The precondition at 567.12 might not hold. The expression at 567.53 might not evaluate to true."} (forall o#_1888: ref :: (((0 < Heap[o#_1888, held]) || Heap[o#_1888, rdheld]) || (Credits[o#_1888] < 0)) ==> MuBelow(Heap[o#_1888, mu], Heap[Heap[Heap[Heap[this#198, Future.q], FutureChannel.imp], FutureChannelImpEP.impch], mu]));
  } else {
  }
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 563.11 might not be positive."} Fractions(100) > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 563.11 for Future.value."} (Fractions(100) <= exhaleMask#_1887[this#198, Future.value][perm$R]) && ((Fractions(100) == exhaleMask#_1887[this#198, Future.value][perm$R]) ==> (0 <= exhaleMask#_1887[this#198, Future.value][perm$N]));
  exhaleMask#_1887[this#198, Future.value] := exhaleMask#_1887[this#198, Future.value][perm$R := exhaleMask#_1887[this#198, Future.value][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 563.25 might not be positive."} monitorK > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 563.25 for Future.sent."} (monitorK <= exhaleMask#_1887[this#198, Future.sent][perm$R]) && ((monitorK == exhaleMask#_1887[this#198, Future.sent][perm$R]) ==> (0 <= exhaleMask#_1887[this#198, Future.sent][perm$N]));
  exhaleMask#_1887[this#198, Future.sent] := exhaleMask#_1887[this#198, Future.sent][perm$R := exhaleMask#_1887[this#198, Future.sent][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 563.42 might not be positive."} monitorK > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 563.42 for Message.type."} (monitorK <= exhaleMask#_1887[Heap[this#198, Future.sent], Message.type][perm$R]) && ((monitorK == exhaleMask#_1887[Heap[this#198, Future.sent], Message.type][perm$R]) ==> (0 <= exhaleMask#_1887[Heap[this#198, Future.sent], Message.type][perm$N]));
  exhaleMask#_1887[Heap[this#198, Future.sent], Message.type] := exhaleMask#_1887[Heap[this#198, Future.sent], Message.type][perm$R := exhaleMask#_1887[Heap[this#198, Future.sent], Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 563.81 might not be positive."} monitorK > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 563.81 for Message.vo1."} (monitorK <= exhaleMask#_1887[Heap[this#198, Future.sent], Message.vo1][perm$R]) && ((monitorK == exhaleMask#_1887[Heap[this#198, Future.sent], Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1887[Heap[this#198, Future.sent], Message.vo1][perm$N]));
  exhaleMask#_1887[Heap[this#198, Future.sent], Message.vo1] := exhaleMask#_1887[Heap[this#198, Future.sent], Message.vo1][perm$R := exhaleMask#_1887[Heap[this#198, Future.sent], Message.vo1][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 564.3 might not be positive."} monitorK > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 564.3 for Message.type."} (monitorK <= exhaleMask#_1887[Heap[this#198, Future.value], Message.type][perm$R]) && ((monitorK == exhaleMask#_1887[Heap[this#198, Future.value], Message.type][perm$R]) ==> (0 <= exhaleMask#_1887[Heap[this#198, Future.value], Message.type][perm$N]));
  exhaleMask#_1887[Heap[this#198, Future.value], Message.type] := exhaleMask#_1887[Heap[this#198, Future.value], Message.type][perm$R := exhaleMask#_1887[Heap[this#198, Future.value], Message.type][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 564.26 might not be positive."} monitorK > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 564.26 for Future.q."} (monitorK <= exhaleMask#_1887[this#198, Future.q][perm$R]) && ((monitorK == exhaleMask#_1887[this#198, Future.q][perm$R]) ==> (0 <= exhaleMask#_1887[this#198, Future.q][perm$N]));
  exhaleMask#_1887[this#198, Future.q] := exhaleMask#_1887[this#198, Future.q][perm$R := exhaleMask#_1887[this#198, Future.q][perm$R] - monitorK];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  assert {:msg "  947.3: The precondition at 563.11 might not hold. The permission at 564.66 might not be positive."} Fractions(100) > 0;
  assert {:msg "  947.3: The precondition at 563.11 might not hold. Insufficient fraction at 564.66 for FutureChannel.valid."} (Fractions(100) <= exhaleMask#_1887[Heap[this#198, Future.q], FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1887[Heap[this#198, Future.q], FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1887[Heap[this#198, Future.q], FutureChannel.valid][perm$N]));
  exhaleMask#_1887[Heap[this#198, Future.q], FutureChannel.valid] := exhaleMask#_1887[Heap[this#198, Future.q], FutureChannel.valid][perm$R := exhaleMask#_1887[Heap[this#198, Future.q], FutureChannel.valid][perm$R] - Fractions(100)];
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  assume wf(Heap, exhaleMask#_1887);
  if (!(Heap[this#198, Future.value] == null)) {
    assert {:msg "  947.3: The precondition at 565.12 might not hold. The permission at 566.21 might not be positive."} Fractions(100) > 0;
    assert {:msg "  947.3: The precondition at 565.12 might not hold. Insufficient fraction at 566.21 for Message.invFinalResult."} (Fractions(100) <= exhaleMask#_1887[Heap[this#198, Future.value], Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1887[Heap[this#198, Future.value], Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1887[Heap[this#198, Future.value], Message.invFinalResult][perm$N]));
    exhaleMask#_1887[Heap[this#198, Future.value], Message.invFinalResult] := exhaleMask#_1887[Heap[this#198, Future.value], Message.invFinalResult][perm$R := exhaleMask#_1887[Heap[this#198, Future.value], Message.invFinalResult][perm$R] - Fractions(100)];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1887);
    assert {:msg "  947.3: The precondition at 565.12 might not hold. The permission at 566.46 might not be positive."} monitorK > 0;
    assert {:msg "  947.3: The precondition at 565.12 might not hold. Insufficient fraction at 566.46 for Message.vr3."} (monitorK <= exhaleMask#_1887[Heap[this#198, Future.value], Message.vr3][perm$R]) && ((monitorK == exhaleMask#_1887[Heap[this#198, Future.value], Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1887[Heap[this#198, Future.value], Message.vr3][perm$N]));
    exhaleMask#_1887[Heap[this#198, Future.value], Message.vr3] := exhaleMask#_1887[Heap[this#198, Future.value], Message.vr3][perm$R := exhaleMask#_1887[Heap[this#198, Future.value], Message.vr3][perm$R] - monitorK];
    assume IsGoodMask(Mask);
    assume wf(Heap, Mask);
    assume wf(Heap, exhaleMask#_1887);
  } else {
  }
  if (Heap[this#198, Future.value] == null) {
  } else {
  }
  Mask := exhaleMask#_1887;
  assume wf(Heap, Mask);
  // end exhale
  havoc m#199;
  // inhale (postcondition)
  havoc inhaleHeap#_1900;
  assume IsGoodInhaleState(inhaleHeap#_1900, Heap, Mask);
  assume this#198 != null;
  Heap[this#198, Future.value] := inhaleHeap#_1900[this#198, Future.value];
  assume wf(Heap, Mask);
  assume (Heap[this#198, Future.value] == null) || (dtype(Heap[this#198, Future.value]) == Message#t);
  assume Fractions(100) > 0;
  Mask[this#198, Future.value] := Mask[this#198, Future.value][perm$R := Mask[this#198, Future.value][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[this#198, Future.value]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume this#198 != null;
  Heap[this#198, Future.sent] := inhaleHeap#_1900[this#198, Future.sent];
  assume wf(Heap, Mask);
  assume (Heap[this#198, Future.sent] == null) || (dtype(Heap[this#198, Future.sent]) == Message#t);
  assume monitorK > 0;
  Mask[this#198, Future.sent] := Mask[this#198, Future.sent][perm$R := Mask[this#198, Future.sent][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[this#198, Future.sent]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume Heap[this#198, Future.sent] != null;
  Heap[Heap[this#198, Future.sent], Message.type] := inhaleHeap#_1900[Heap[this#198, Future.sent], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this#198, Future.sent], Message.type] := Mask[Heap[this#198, Future.sent], Message.type][perm$R := Mask[Heap[this#198, Future.sent], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[Heap[this#198, Future.sent], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume Heap[Heap[this#198, Future.sent], Message.type] == 1;
  assume Heap[this#198, Future.sent] != null;
  Heap[Heap[this#198, Future.sent], Message.vo1] := inhaleHeap#_1900[Heap[this#198, Future.sent], Message.vo1];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this#198, Future.sent], Message.vo1] := Mask[Heap[this#198, Future.sent], Message.vo1][perm$R := Mask[Heap[this#198, Future.sent], Message.vo1][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[Heap[this#198, Future.sent], Message.vo1]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume Heap[Heap[this#198, Future.sent], Message.vo1] >= 0;
  assume Heap[this#198, Future.value] != null;
  Heap[Heap[this#198, Future.value], Message.vr3] := inhaleHeap#_1900[Heap[this#198, Future.value], Message.vr3];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this#198, Future.value], Message.vr3] := Mask[Heap[this#198, Future.value], Message.vr3][perm$R := Mask[Heap[this#198, Future.value], Message.vr3][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[Heap[this#198, Future.value], Message.vr3]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume Heap[this#198, Future.value] != null;
  Heap[Heap[this#198, Future.value], Message.type] := inhaleHeap#_1900[Heap[this#198, Future.value], Message.type];
  assume wf(Heap, Mask);
  assume true;
  assume monitorK > 0;
  Mask[Heap[this#198, Future.value], Message.type] := Mask[Heap[this#198, Future.value], Message.type][perm$R := Mask[Heap[this#198, Future.value], Message.type][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[Heap[this#198, Future.value], Message.type]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume this#198 != null;
  Heap[this#198, Future.q] := inhaleHeap#_1900[this#198, Future.q];
  assume wf(Heap, Mask);
  assume (Heap[this#198, Future.q] == null) || (dtype(Heap[this#198, Future.q]) == FutureChannel#t);
  assume monitorK > 0;
  Mask[this#198, Future.q] := Mask[this#198, Future.q][perm$R := Mask[this#198, Future.q][perm$R] + monitorK];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[this#198, Future.q]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume !(Heap[this#198, Future.value] == null);
  assume m#199 == Heap[this#198, Future.value];
  assume Heap[Heap[this#198, Future.value], Message.type] == 4;
  assume Heap[this#198, Future.value] != null;
  Heap[Heap[this#198, Future.value], Message.invFinalResult] := inhaleHeap#_1900[Heap[this#198, Future.value], Message.invFinalResult];
  assume wf(Heap, Mask);
  assume inhaleHeap#_1900[Heap[this#198, Future.value], Message.invFinalResult] == Heap;
  assume Fractions(100) > 0;
  Mask[Heap[this#198, Future.value], Message.invFinalResult] := Mask[Heap[this#198, Future.value], Message.invFinalResult][perm$R := Mask[Heap[this#198, Future.value], Message.invFinalResult][perm$R] + Fractions(100)];
  assume IsGoodMask(Mask);
  assume IsGoodState(inhaleHeap#_1900[Heap[this#198, Future.value], Message.invFinalResult]);
  assume wf(Heap, Mask);
  assume wf(inhaleHeap#_1900, Mask);
  assume Heap[Heap[this#198, Future.value], Message.vr3] == #Message.factorial(Heap, Mask, Heap[this#198, Future.sent], Heap[Heap[this#198, Future.sent], Message.vo1]);
  assume IsGoodMask(Mask);
  assume wf(Heap, Mask);
  // end inhale
  res#106 := m#199;
  // assert
  Heap#_1904 := Heap;
  Mask#_1905 := Mask;
  Credits#_1906 := Credits;
  // begin exhale (assert)
  exhaleMask#_1907 := Mask#_1905;
  assert {:msg "  949.10: Receiver might be null."} true ==> (res#106 != null);
  assert {:msg "  949.10: Location might not be readable."} true ==> CanRead(Mask#_1905, res#106, Message.vr3);
  assert {:msg "  949.19: Receiver might be null."} true ==> (m#102 != null);
  // check precondition of call
  assume (0 < funcappK#_1914) && ((1000 * funcappK#_1914) < Fractions(1));
  assume true;
  Heap#_1911 := Heap#_1904;
  Mask#_1912 := Mask#_1905;
  Credits#_1913 := Credits#_1906;
  // begin exhale (function call)
  exhaleMask#_1915 := Mask#_1912;
  assert {:msg "  949.19: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true."} 5 >= 0;
  Mask#_1912 := exhaleMask#_1915;
  assume wf(Heap#_1911, Mask#_1912);
  // end exhale
  assert {:msg "  949.3: Assertion might not hold. The expression at 949.10 might not evaluate to true."} Heap#_1904[res#106, Message.vr3] == #Message.factorial(Heap#_1904, Mask#_1905, m#102, 5);
  Mask#_1905 := exhaleMask#_1907;
  assume wf(Heap#_1904, Mask#_1905);
  // end exhale
  assert {:msg "  926.2: Method might lock/unlock more than allowed."} (forall lk#_1916: ref :: {Heap[lk#_1916, held]} {Heap[lk#_1916, rdheld]} (((0 < Heap[lk#_1916, held]) == (0 < old(Heap)[lk#_1916, held])) && (Heap[lk#_1916, rdheld] == old(Heap)[lk#_1916, rdheld])) || false);
  assert {:msg "  926.2: Method body is not allowed to leave any debt."} (forall ch: ref :: (ch == null) || (0 <= Credits[ch]));
}
