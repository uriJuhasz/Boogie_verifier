type Integer = int;
type Boolean = bool;
type HeapType = <a>[ref,Field (a)]a;
type MaskType = <a>[ref,Field (a)][PermissionComponent]int;
type CreditsType = [ref]int;
type ArgSeq = <T>[int]T;
type string = int;
type Field m0;
type ref;
type PermissionComponent;
type ModuleName;
type TypeName;
type Mu;
const null : ref;
const unique perm$R : PermissionComponent;
const unique perm$N : PermissionComponent;
const Permission$denominator : int;
const Permission$FullFraction : int;
const Permission$Zero : [PermissionComponent]int;
const Permission$Full : [PermissionComponent]int;
const ZeroMask : MaskType;
const unique joinable : Field (int);
const unique token#t : TypeName;
const unique forkK : Field (int);
const channelK : int;
const monitorK : int;
const predicateK : int;
const nostate : HeapType;
const CurrentModule : ModuleName;
const CanAssumeFunctionDefs : bool;
const unique mu : Field (Mu);
const $LockBottom : Mu;
const unique held : Field (int);
const unique rdheld : Field (bool);
const ZeroCredits : CreditsType;
const unique Channel#t : TypeName;
const unique module#default : ModuleName;
const unique Queue#t : TypeName;
const unique FactorialActorChannelExpEP#t : TypeName;
const unique FactorialActorChannelExpEP.state : Field (int);
const unique FactorialActorChannelExpEP.ch : Field (ref);
const unique FactorialActorChannelExpEP.expch : Field (ref);
const unique FactorialActorChannelExpEP.valid : Field (HeapType);
const unique FactorialActorChannelImpEP#t : TypeName;
const unique FactorialActorChannelImpEP.state : Field (int);
const unique FactorialActorChannelImpEP.ch : Field (ref);
const unique FactorialActorChannelImpEP.impch : Field (ref);
const unique FactorialActorChannelImpEP.valid : Field (HeapType);
const unique FactorialActorChannel#t : TypeName;
const unique FactorialActorChannel.imp : Field (ref);
const unique FactorialActorChannel.exp : Field (ref);
const unique FactorialActorChannel.valid : Field (HeapType);
const unique FactorialActorChannel.initImpState : Field (HeapType);
const unique FactorialActorChannel.initExpState : Field (HeapType);
const unique FactorialContChannelExpEP#t : TypeName;
const unique FactorialContChannelExpEP.state : Field (int);
const unique FactorialContChannelExpEP.ch : Field (ref);
const unique FactorialContChannelExpEP.expch : Field (ref);
const unique FactorialContChannelExpEP.valid : Field (HeapType);
const unique FactorialContChannelImpEP#t : TypeName;
const unique FactorialContChannelImpEP.state : Field (int);
const unique FactorialContChannelImpEP.ch : Field (ref);
const unique FactorialContChannelImpEP.impch : Field (ref);
const unique FactorialContChannelImpEP.valid : Field (HeapType);
const unique FactorialContChannel#t : TypeName;
const unique FactorialContChannel.imp : Field (ref);
const unique FactorialContChannel.exp : Field (ref);
const unique FactorialContChannel.valid : Field (HeapType);
const unique FactorialContChannel.initImpState : Field (HeapType);
const unique FactorialContChannel.initExpState : Field (HeapType);
const unique FutureChannelExpEP#t : TypeName;
const unique FutureChannelExpEP.state : Field (int);
const unique FutureChannelExpEP.ch : Field (ref);
const unique FutureChannelExpEP.expch : Field (ref);
const unique FutureChannelExpEP.valid : Field (HeapType);
const unique FutureChannelImpEP#t : TypeName;
const unique FutureChannelImpEP.state : Field (int);
const unique FutureChannelImpEP.ch : Field (ref);
const unique FutureChannelImpEP.impch : Field (ref);
const unique FutureChannelImpEP.valid : Field (HeapType);
const unique FutureChannel#t : TypeName;
const unique FutureChannel.imp : Field (ref);
const unique FutureChannel.exp : Field (ref);
const unique FutureChannel.valid : Field (HeapType);
const unique FutureChannel.initImpState : Field (HeapType);
const unique FutureChannel.initExpState : Field (HeapType);
const unique Future#t : TypeName;
const unique Future.sent : Field (ref);
const unique Future.value : Field (ref);
const unique Future.q : Field (ref);
const unique Message#t : TypeName;
const unique Message.type : Field (int);
const unique Message.sender1 : Field (ref);
const unique Message.sender3 : Field (ref);
const unique Message.sender2 : Field (ref);
const unique Message.sender4 : Field (ref);
const unique Message.receiver1 : Field (ref);
const unique Message.receiver2 : Field (ref);
const unique Message.receiver3 : Field (ref);
const unique Message.receiver4 : Field (ref);
const unique Message.v1 : Field (int);
const unique Message.vo1 : Field (int);
const unique Message.cust1 : Field (ref);
const unique Message.vr1 : Field (int);
const unique Message.old1 : Field (ref);
const unique Message.vr2 : Field (int);
const unique Message.old2 : Field (ref);
const unique Message.vr3 : Field (int);
const unique Message.invValue : Field (HeapType);
const unique Message.invResult1 : Field (HeapType);
const unique Message.invResult2 : Field (HeapType);
const unique Message.invFinalResult : Field (HeapType);
const unique Message.inv : Field (HeapType);
const unique FactorialActor#t : TypeName;
const unique FactorialActor.q : Field (ref);
const unique FactorialCont#t : TypeName;
const unique FactorialCont.q : Field (ref);
const unique FactorialCont.v : Field (int);
const unique FactorialCont.vo : Field (int);
const unique FactorialCont.cust : Field (ref);
const $old_Heap : HeapType;
const $old_Mask : MaskType;
const $old_Credits : CreditsType;
function Fractions(int) : int;
function IsGoodState <T> (T) : bool;
function combine <T,U> (T,U) : T;
function dtype(ref) : TypeName;
function MuBelow(Mu,Mu) : bool;
function Acquire$Heap(int) : HeapType;
function Acquire$Mask(int) : MaskType;
function Acquire$Credits(int) : CreditsType;
function LastSeen$Heap(Mu,int) : HeapType;
function LastSeen$Mask(Mu,int) : MaskType;
function LastSeen$Credits(Mu,int) : CreditsType;
function wf(HeapType,MaskType) : bool;
function IsGoodInhaleState(HeapType,HeapType,MaskType) : bool;
function {:expand  false} CanRead <T> (MaskType,ref,Field (T)) : bool;
function {:expand  false} CanWrite <T> (MaskType,ref,Field (T)) : bool;
function {:expand  true} IsGoodMask(MaskType) : bool;
function DecPerm <T> (MaskType,ref,Field (T),int) : MaskType;
function DecEpsilons <T> (MaskType,ref,Field (T),int) : MaskType;
function IncPerm <T> (MaskType,ref,Field (T),int) : MaskType;
function IncEpsilons <T> (MaskType,ref,Field (T),int) : MaskType;
function Havocing <T,U> (HeapType,ref,Field (T),U) : HeapType;
function Call$Heap(int) : HeapType;
function Call$Mask(int) : MaskType;
function Call$Credits(int) : CreditsType;
function Call$Args(int) : ArgSeq;
function EmptyMask(MaskType) : bool;
function EmptyCredits(CreditsType) : bool;
function NonPredicateField <T> (Field (T)) : bool;
function PredicateField <T> (Field (T)) : bool;
function submask(MaskType,MaskType) : bool;
function ite <T> (bool,T,T) : T;
function #Future.getQ(HeapType,MaskType,ref) : ref;
function ##Future.getQ(HeapType,ref) : ref;
function #Message.factorial(HeapType,MaskType,ref,int) : int;
function #Message.factorial#limited(HeapType,MaskType,ref,int) : int;
function ##Message.factorial(HeapType,ref,int) : int;
function #FactorialActor.getQ(HeapType,MaskType,ref) : ref;
function ##FactorialActor.getQ(HeapType,ref) : ref;
function #FactorialCont.getQ(HeapType,MaskType,ref) : ref;
function ##FactorialCont.getQ(HeapType,ref) : ref;
var Heap : HeapType;
var Mask : MaskType;
var Credits : CreditsType;
var current#67 : ref;
var this#127 : ref;
var msg#128 : ref;
var this#129 : ref;
var mi#130 : ref;
var mo#131 : ref;
var m#69 : ref;
var this#132 : ref;
var receiver#134 : ref;
var this#135 : ref;
var m#136 : ref;
var m#71 : ref;
var this#137 : ref;
var oldv#139 : ref;
var receiver#140 : ref;
var this#141 : ref;
var m#142 : ref;
var r#73 : ref;
var cont#75 : ref;
var this#143 : ref;
var custp#146 : ref;
var this#147 : ref;
var m#77 : ref;
var this#148 : ref;
var cust#151 : ref;
var receiver#152 : ref;
var this#153 : ref;
var m#154 : ref;
var r#79 : ref;
var methodK#_1151 : int;
var inhaleHeap#_1153_$_0 : HeapType;
var Heap_$_0 : HeapType;
var Mask_$_0 : MaskType;
var Heap_$_1 : HeapType;
var Mask_$_1 : MaskType;
var Heap_$_2 : HeapType;
var Mask_$_2 : MaskType;
var Heap_$_3 : HeapType;
var Mask_$_3 : MaskType;
var Heap_$_4 : HeapType;
var Mask_$_4 : MaskType;
var Heap_$_5 : HeapType;
var Mask_$_5 : MaskType;
var Credits_$_0 : CreditsType;
var unfoldK#_1154 : int;
var exhaleMask#_1155_$_0 : MaskType;
var inhaleHeap#_1157_$_0 : HeapType;
var Heap_$_6 : HeapType;
var Mask_$_6 : MaskType;
var Heap_$_7 : HeapType;
var Mask_$_7 : MaskType;
var Heap_$_8 : HeapType;
var Mask_$_8 : MaskType;
var Heap_$_9 : HeapType;
var Mask_$_9 : MaskType;
var Heap_$_10 : HeapType;
var Mask_$_10 : MaskType;
var Heap_$_11 : HeapType;
var Mask_$_11 : MaskType;
var unfoldK#_1158 : int;
var exhaleMask#_1159_$_0 : MaskType;
var inhaleHeap#_1161_$_0 : HeapType;
var Heap_$_12 : HeapType;
var Mask_$_12 : MaskType;
var Heap_$_13 : HeapType;
var Mask_$_13 : MaskType;
var Heap_$_14 : HeapType;
var Mask_$_14 : MaskType;
var Heap_$_15 : HeapType;
var Mask_$_15 : MaskType;
var Heap_$_16 : HeapType;
var Mask_$_16 : MaskType;
var Heap_$_17 : HeapType;
var Mask_$_17 : MaskType;
var Heap_$_18 : HeapType;
var Mask_$_18 : MaskType;
var Heap_$_19 : HeapType;
var Mask_$_19 : MaskType;
var unfoldK#_1162 : int;
var exhaleMask#_1163_$_0 : MaskType;
var inhaleHeap#_1165_$_0 : HeapType;
var Heap_$_20 : HeapType;
var Mask_$_20 : MaskType;
var Heap_$_21 : HeapType;
var Mask_$_21 : MaskType;
var unfoldK#_1166 : int;
var exhaleMask#_1167_$_0 : MaskType;
var inhaleHeap#_1169_$_0 : HeapType;
var Heap_$_22 : HeapType;
var Mask_$_22 : MaskType;
var Heap_$_23 : HeapType;
var Mask_$_23 : MaskType;
var whileK#_1176 : int;
var Credits_$_1 : CreditsType;
var exhaleMask#_1177_$_0 : MaskType;
var exhaleMask#_1177_$_1 : MaskType;
var exhaleMask#_1177_$_2 : MaskType;
var exhaleMask#_1177_$_3 : MaskType;
var exhaleMask#_1177_$_4 : MaskType;
var exhaleMask#_1177_$_5 : MaskType;
var exhaleMask#_1177_$_6 : MaskType;
var exhaleMask#_1177_$_7 : MaskType;
var exhaleMask#_1177_$_8 : MaskType;
var inhaleHeap#_1434_$_0 : HeapType;
var Heap_$_46 : HeapType;
var Mask_$_44 : MaskType;
var Heap_$_47 : HeapType;
var Mask_$_45 : MaskType;
var Heap_$_48 : HeapType;
var Mask_$_46 : MaskType;
var Heap_$_49 : HeapType;
var Mask_$_47 : MaskType;
var Heap_$_50 : HeapType;
var Mask_$_48 : MaskType;
var Heap_$_51 : HeapType;
var Mask_$_49 : MaskType;
var Heap_$_52 : HeapType;
var Mask_$_50 : MaskType;
var Heap_$_53 : HeapType;
var Mask_$_51 : MaskType;
var Heap_$_54 : HeapType;
var Mask_$_52 : MaskType;
var Credits_$_5 : CreditsType;
var inhaleHeap#_1189_$_0 : HeapType;
var Heap_$_34 : HeapType;
var Heap_$_35 : HeapType;
var Mask_$_33 : MaskType;
var Heap_$_36 : HeapType;
var Mask_$_34 : MaskType;
var Heap_$_37 : HeapType;
var Mask_$_35 : MaskType;
var Heap_$_38 : HeapType;
var Mask_$_36 : MaskType;
var Heap_$_39 : HeapType;
var Mask_$_37 : MaskType;
var Heap_$_40 : HeapType;
var Mask_$_38 : MaskType;
var Heap_$_41 : HeapType;
var Mask_$_39 : MaskType;
var Heap_$_42 : HeapType;
var Mask_$_40 : MaskType;
var Heap_$_43 : HeapType;
var Mask_$_41 : MaskType;
var Credits_$_3 : CreditsType;
var this#127_$_0 : ref;
var msg#128_$_0 : ref;
var inhaleHeap#_1192_$_0 : HeapType;
var Heap_$_44 : HeapType;
var Mask_$_42 : MaskType;
var Heap_$_45 : HeapType;
var Mask_$_43 : MaskType;
var Credits_$_4 : CreditsType;
var Mask_$_221 : MaskType;
var Credits_$_7 : CreditsType;
var Heap_$_134 : HeapType;
var Credits_$_8 : CreditsType;
var exhaleMask#_1420_$_0 : MaskType;
var exhaleMask#_1420_$_1 : MaskType;
var exhaleMask#_1420_$_2 : MaskType;
var exhaleMask#_1420_$_3 : MaskType;
var exhaleMask#_1420_$_4 : MaskType;
var exhaleMask#_1420_$_5 : MaskType;
var exhaleMask#_1420_$_6 : MaskType;
var exhaleMask#_1420_$_7 : MaskType;
var exhaleMask#_1420_$_8 : MaskType;
var methodCallK#_1196 : int;
var this#129_$_0 : ref;
var exhaleMask#_1197_$_0 : MaskType;
var exhaleMask#_1197_$_1 : MaskType;
var exhaleMask#_1197_$_2 : MaskType;
var mo#131_$_0 : ref;
var inhaleHeap#_1203_$_0 : HeapType;
var Heap_$_55 : HeapType;
var Mask_$_53 : MaskType;
var Heap_$_56 : HeapType;
var Mask_$_54 : MaskType;
var Heap_$_57 : HeapType;
var Mask_$_55 : MaskType;
var unfoldK#_1204 : int;
var exhaleMask#_1205_$_0 : MaskType;
var inhaleHeap#_1207_$_0 : HeapType;
var Heap_$_58 : HeapType;
var Mask_$_56 : MaskType;
var Heap_$_59 : HeapType;
var Mask_$_57 : MaskType;
var Heap_$_60 : HeapType;
var Mask_$_58 : MaskType;
var Heap_$_61 : HeapType;
var Mask_$_59 : MaskType;
var Heap_$_62 : HeapType;
var Mask_$_60 : MaskType;
var Heap_$_63 : HeapType;
var Mask_$_61 : MaskType;
var Heap_$_64 : HeapType;
var Mask_$_62 : MaskType;
var Heap_$_65 : HeapType;
var Mask_$_63 : MaskType;
var Mask_$_71 : MaskType;
var Heap_$_73 : HeapType;
var nw#_1321_$_0 : ref;
var Mask_$_72 : MaskType;
var Mask_$_73 : MaskType;
var Mask_$_74 : MaskType;
var Mask_$_75 : MaskType;
var Mask_$_76 : MaskType;
var methodCallK#_1325 : int;
var vp#144_$_0 : int;
var vop#145_$_0 : int;
var custp#146_$_0 : ref;
var exhaleMask#_1326_$_0 : MaskType;
var exhaleMask#_1326_$_1 : MaskType;
var exhaleMask#_1326_$_2 : MaskType;
var exhaleMask#_1326_$_3 : MaskType;
var exhaleMask#_1326_$_8 : MaskType;
var inhaleHeap#_1337_$_0 : HeapType;
var Heap_$_74 : HeapType;
var Mask_$_77 : MaskType;
var Heap_$_75 : HeapType;
var Mask_$_78 : MaskType;
var Heap_$_76 : HeapType;
var Mask_$_79 : MaskType;
var Heap_$_77 : HeapType;
var Mask_$_80 : MaskType;
var Heap_$_78 : HeapType;
var Mask_$_81 : MaskType;
var Heap_$_79 : HeapType;
var Mask_$_82 : MaskType;
var Heap_$_80 : HeapType;
var Mask_$_83 : MaskType;
var Heap_$_81 : HeapType;
var Mask_$_84 : MaskType;
var Heap_$_82 : HeapType;
var Mask_$_85 : MaskType;
var Heap_$_83 : HeapType;
var Mask_$_86 : MaskType;
var Heap_$_84 : HeapType;
var Mask_$_87 : MaskType;
var Heap_$_85 : HeapType;
var Mask_$_88 : MaskType;
var Heap_$_86 : HeapType;
var Mask_$_89 : MaskType;
var Heap_$_87 : HeapType;
var Mask_$_90 : MaskType;
var Heap_$_92 : HeapType;
var Mask_$_95 : MaskType;
var asyncMethodCallK#_1344 : int;
var argsSeq#_1343_$_0 : ArgSeq;
var argsSeq#_1343 : ArgSeq;
var Credits_$_6 : CreditsType;
var exhaleMask#_1345_$_0 : MaskType;
var exhaleMask#_1345_$_1 : MaskType;
var exhaleMask#_1345_$_2 : MaskType;
var exhaleMask#_1345_$_3 : MaskType;
var exhaleMask#_1345_$_4 : MaskType;
var exhaleMask#_1345_$_5 : MaskType;
var exhaleMask#_1345_$_6 : MaskType;
var exhaleMask#_1345_$_7 : MaskType;
var exhaleMask#_1345_$_12 : MaskType;
var token#_1338_$_0 : ref;
var Mask_$_96 : MaskType;
var asyncstate#_1339_$_0 : int;
var Heap_$_93 : HeapType;
var Heap_$_94 : HeapType;
var nw#_1358_$_0 : ref;
var Mask_$_97 : MaskType;
var Mask_$_98 : MaskType;
var Mask_$_99 : MaskType;
var Mask_$_100 : MaskType;
var Mask_$_101 : MaskType;
var Mask_$_102 : MaskType;
var Mask_$_103 : MaskType;
var Mask_$_104 : MaskType;
var Mask_$_105 : MaskType;
var Mask_$_106 : MaskType;
var Mask_$_107 : MaskType;
var Mask_$_108 : MaskType;
var Mask_$_109 : MaskType;
var Mask_$_110 : MaskType;
var Mask_$_111 : MaskType;
var Mask_$_112 : MaskType;
var Mask_$_113 : MaskType;
var Mask_$_114 : MaskType;
var Heap_$_95 : HeapType;
var methodCallK#_1362 : int;
var v#149_$_0 : int;
var vo#150_$_0 : int;
var exhaleMask#_1363_$_0 : MaskType;
var exhaleMask#_1363_$_1 : MaskType;
var exhaleMask#_1363_$_2 : MaskType;
var exhaleMask#_1363_$_3 : MaskType;
var exhaleMask#_1363_$_4 : MaskType;
var exhaleMask#_1363_$_5 : MaskType;
var exhaleMask#_1363_$_6 : MaskType;
var exhaleMask#_1363_$_7 : MaskType;
var exhaleMask#_1363_$_8 : MaskType;
var exhaleMask#_1363_$_16 : MaskType;
var inhaleHeap#_1382_$_0 : HeapType;
var Heap_$_96 : HeapType;
var Mask_$_115 : MaskType;
var Heap_$_97 : HeapType;
var Mask_$_116 : MaskType;
var Heap_$_98 : HeapType;
var Mask_$_117 : MaskType;
var Heap_$_99 : HeapType;
var Mask_$_118 : MaskType;
var methodCallK#_1386 : int;
var this#153_$_0 : ref;
var exhaleMask#_1387_$_0 : MaskType;
var exhaleMask#_1387_$_1 : MaskType;
var exhaleMask#_1387_$_2 : MaskType;
var exhaleMask#_1387_$_3 : MaskType;
var exhaleMask#_1387_$_4 : MaskType;
var inhaleHeap#_1395_$_0 : HeapType;
var Heap_$_100 : HeapType;
var Mask_$_119 : MaskType;
var Heap_$_101 : HeapType;
var Mask_$_120 : MaskType;
var nw#_1396_$_0 : ref;
var Mask_$_121 : MaskType;
var Mask_$_122 : MaskType;
var Mask_$_123 : MaskType;
var Mask_$_124 : MaskType;
var Mask_$_125 : MaskType;
var Mask_$_126 : MaskType;
var Mask_$_127 : MaskType;
var Mask_$_128 : MaskType;
var Mask_$_129 : MaskType;
var Mask_$_130 : MaskType;
var Mask_$_131 : MaskType;
var Mask_$_132 : MaskType;
var Mask_$_133 : MaskType;
var Mask_$_134 : MaskType;
var Mask_$_135 : MaskType;
var Mask_$_136 : MaskType;
var Mask_$_137 : MaskType;
var Mask_$_138 : MaskType;
var Heap_$_102 : HeapType;
var funcappK#_1410 : int;
var funcappK#_1418 : int;
var exhaleMask#_1363_$_9 : MaskType;
var exhaleMask#_1363_$_10 : MaskType;
var exhaleMask#_1363_$_11 : MaskType;
var exhaleMask#_1363_$_12 : MaskType;
var exhaleMask#_1363_$_13 : MaskType;
var exhaleMask#_1363_$_14 : MaskType;
var exhaleMask#_1363_$_15 : MaskType;
var exhaleMask#_1345_$_8 : MaskType;
var exhaleMask#_1345_$_9 : MaskType;
var exhaleMask#_1345_$_10 : MaskType;
var exhaleMask#_1345_$_11 : MaskType;
var Heap_$_88 : HeapType;
var Mask_$_91 : MaskType;
var Heap_$_89 : HeapType;
var Mask_$_92 : MaskType;
var Heap_$_90 : HeapType;
var Mask_$_93 : MaskType;
var Heap_$_91 : HeapType;
var Mask_$_94 : MaskType;
var exhaleMask#_1326_$_4 : MaskType;
var exhaleMask#_1326_$_5 : MaskType;
var exhaleMask#_1326_$_6 : MaskType;
var exhaleMask#_1326_$_7 : MaskType;
var nw#_1258_$_0 : ref;
var Mask_$_157 : MaskType;
var Mask_$_158 : MaskType;
var Mask_$_159 : MaskType;
var Mask_$_160 : MaskType;
var Mask_$_161 : MaskType;
var Mask_$_162 : MaskType;
var Mask_$_163 : MaskType;
var Mask_$_164 : MaskType;
var Mask_$_165 : MaskType;
var Mask_$_166 : MaskType;
var Mask_$_167 : MaskType;
var Mask_$_168 : MaskType;
var Mask_$_169 : MaskType;
var Mask_$_170 : MaskType;
var Mask_$_171 : MaskType;
var Mask_$_172 : MaskType;
var Mask_$_173 : MaskType;
var Mask_$_174 : MaskType;
var Heap_$_104 : HeapType;
var methodCallK#_1262 : int;
var receiver#140_$_0 : ref;
var exhaleMask#_1263_$_0 : MaskType;
var exhaleMask#_1263_$_1 : MaskType;
var exhaleMask#_1263_$_2 : MaskType;
var exhaleMask#_1263_$_3 : MaskType;
var exhaleMask#_1263_$_4 : MaskType;
var exhaleMask#_1263_$_5 : MaskType;
var exhaleMask#_1263_$_6 : MaskType;
var exhaleMask#_1263_$_7 : MaskType;
var exhaleMask#_1263_$_8 : MaskType;
var inhaleHeap#_1275_$_0 : HeapType;
var Heap_$_105 : HeapType;
var Mask_$_175 : MaskType;
var Heap_$_106 : HeapType;
var Mask_$_176 : MaskType;
var Heap_$_107 : HeapType;
var Mask_$_177 : MaskType;
var Heap_$_108 : HeapType;
var Mask_$_178 : MaskType;
var unfoldK#_1276 : int;
var exhaleMask#_1277_$_0 : MaskType;
var inhaleHeap#_1279_$_0 : HeapType;
var Heap_$_109 : HeapType;
var Mask_$_179 : MaskType;
var Heap_$_110 : HeapType;
var Mask_$_180 : MaskType;
var Heap_$_111 : HeapType;
var Mask_$_181 : MaskType;
var Heap_$_112 : HeapType;
var Mask_$_182 : MaskType;
var Heap_$_113 : HeapType;
var Mask_$_183 : MaskType;
var Heap_$_114 : HeapType;
var Mask_$_184 : MaskType;
var unfoldK#_1280 : int;
var exhaleMask#_1281_$_0 : MaskType;
var inhaleHeap#_1283_$_0 : HeapType;
var Heap_$_115 : HeapType;
var Mask_$_185 : MaskType;
var Heap_$_116 : HeapType;
var Mask_$_186 : MaskType;
var methodCallK#_1287 : int;
var this#141_$_0 : ref;
var exhaleMask#_1288_$_0 : MaskType;
var exhaleMask#_1288_$_1 : MaskType;
var exhaleMask#_1288_$_2 : MaskType;
var exhaleMask#_1288_$_3 : MaskType;
var exhaleMask#_1288_$_4 : MaskType;
var inhaleHeap#_1296_$_0 : HeapType;
var Heap_$_117 : HeapType;
var Mask_$_187 : MaskType;
var Heap_$_118 : HeapType;
var Mask_$_188 : MaskType;
var nw#_1297_$_0 : ref;
var Mask_$_189 : MaskType;
var Mask_$_190 : MaskType;
var Mask_$_191 : MaskType;
var Mask_$_192 : MaskType;
var Mask_$_193 : MaskType;
var Mask_$_194 : MaskType;
var Mask_$_195 : MaskType;
var Mask_$_196 : MaskType;
var Mask_$_197 : MaskType;
var Mask_$_198 : MaskType;
var Mask_$_199 : MaskType;
var Mask_$_200 : MaskType;
var Mask_$_201 : MaskType;
var Mask_$_202 : MaskType;
var Mask_$_203 : MaskType;
var Mask_$_204 : MaskType;
var Mask_$_205 : MaskType;
var Mask_$_206 : MaskType;
var Heap_$_119 : HeapType;
var funcappK#_1311 : int;
var funcappK#_1319 : int;
var nw#_1208_$_0 : ref;
var Mask_$_139 : MaskType;
var Mask_$_140 : MaskType;
var Mask_$_141 : MaskType;
var Mask_$_142 : MaskType;
var Mask_$_143 : MaskType;
var Mask_$_144 : MaskType;
var Mask_$_145 : MaskType;
var Mask_$_146 : MaskType;
var Mask_$_147 : MaskType;
var Mask_$_148 : MaskType;
var Mask_$_149 : MaskType;
var Mask_$_150 : MaskType;
var Mask_$_151 : MaskType;
var Mask_$_152 : MaskType;
var Mask_$_153 : MaskType;
var Mask_$_154 : MaskType;
var Mask_$_155 : MaskType;
var Mask_$_156 : MaskType;
var Heap_$_103 : HeapType;
var methodCallK#_1212 : int;
var receiver#134_$_0 : ref;
var exhaleMask#_1213_$_0 : MaskType;
var exhaleMask#_1213_$_1 : MaskType;
var exhaleMask#_1213_$_2 : MaskType;
var exhaleMask#_1213_$_3 : MaskType;
var exhaleMask#_1213_$_5 : MaskType;
var inhaleHeap#_1221_$_0 : HeapType;
var Heap_$_120 : HeapType;
var Mask_$_207 : MaskType;
var Heap_$_121 : HeapType;
var Mask_$_208 : MaskType;
var Heap_$_122 : HeapType;
var Mask_$_209 : MaskType;
var Heap_$_123 : HeapType;
var Mask_$_210 : MaskType;
var funcappK#_1235 : int;
var unfoldK#_1237 : int;
var exhaleMask#_1238_$_0 : MaskType;
var inhaleHeap#_1240_$_0 : HeapType;
var Heap_$_124 : HeapType;
var Mask_$_211 : MaskType;
var Heap_$_125 : HeapType;
var Mask_$_212 : MaskType;
var Heap_$_126 : HeapType;
var Mask_$_213 : MaskType;
var Heap_$_127 : HeapType;
var Mask_$_214 : MaskType;
var Heap_$_128 : HeapType;
var Mask_$_215 : MaskType;
var Heap_$_129 : HeapType;
var Mask_$_216 : MaskType;
var unfoldK#_1241 : int;
var exhaleMask#_1242_$_0 : MaskType;
var inhaleHeap#_1244_$_0 : HeapType;
var Heap_$_130 : HeapType;
var Mask_$_217 : MaskType;
var Heap_$_131 : HeapType;
var Mask_$_218 : MaskType;
var methodCallK#_1248 : int;
var this#135_$_0 : ref;
var exhaleMask#_1249_$_0 : MaskType;
var exhaleMask#_1249_$_1 : MaskType;
var exhaleMask#_1249_$_2 : MaskType;
var exhaleMask#_1249_$_3 : MaskType;
var exhaleMask#_1249_$_4 : MaskType;
var inhaleHeap#_1257_$_0 : HeapType;
var Heap_$_132 : HeapType;
var Mask_$_219 : MaskType;
var Heap_$_133 : HeapType;
var Mask_$_220 : MaskType;
var exhaleMask#_1213_$_4 : MaskType;
var Heap_$_66 : HeapType;
var Mask_$_64 : MaskType;
var Heap_$_67 : HeapType;
var Mask_$_65 : MaskType;
var Heap_$_68 : HeapType;
var Mask_$_66 : MaskType;
var Heap_$_69 : HeapType;
var Mask_$_67 : MaskType;
var Heap_$_70 : HeapType;
var Mask_$_68 : MaskType;
var Heap_$_71 : HeapType;
var Mask_$_69 : MaskType;
var Heap_$_72 : HeapType;
var Mask_$_70 : MaskType;
var inhaleHeap#_1188_$_0 : HeapType;
var Heap_$_24 : HeapType;
var Heap_$_25 : HeapType;
var Mask_$_24 : MaskType;
var Heap_$_26 : HeapType;
var Mask_$_25 : MaskType;
var Heap_$_27 : HeapType;
var Mask_$_26 : MaskType;
var Heap_$_28 : HeapType;
var Mask_$_27 : MaskType;
var Heap_$_29 : HeapType;
var Mask_$_28 : MaskType;
var Heap_$_30 : HeapType;
var Mask_$_29 : MaskType;
var Heap_$_31 : HeapType;
var Mask_$_30 : MaskType;
var Heap_$_32 : HeapType;
var Mask_$_31 : MaskType;
var Heap_$_33 : HeapType;
var Mask_$_32 : MaskType;
var Credits_$_2 : CreditsType;
var inhaleHeap#_1153 : HeapType;
var exhaleMask#_1155 : MaskType;
var inhaleHeap#_1157 : HeapType;
var exhaleMask#_1159 : MaskType;
var inhaleHeap#_1161 : HeapType;
var exhaleMask#_1163 : MaskType;
var inhaleHeap#_1165 : HeapType;
var exhaleMask#_1167 : MaskType;
var inhaleHeap#_1169 : HeapType;
var whileHeap#_1170 : HeapType;
var whileMask#_1171 : MaskType;
var whileCredits#_1172 : CreditsType;
var exhaleMask#_1177 : MaskType;
var inhaleHeap#_1188 : HeapType;
var inhaleHeap#_1189 : HeapType;
var iterStartHeap#_1173 : HeapType;
var iterStartMask#_1174 : MaskType;
var iterStartCredits#_1175 : CreditsType;
var inhaleHeap#_1192 : HeapType;
var callHeap#_1193 : HeapType;
var callMask#_1194 : MaskType;
var callCredits#_1195 : CreditsType;
var exhaleMask#_1197 : MaskType;
var inhaleHeap#_1203 : HeapType;
var exhaleMask#_1205 : MaskType;
var inhaleHeap#_1207 : HeapType;
var nw#_1208 : ref;
var vr#133 : int;
var callHeap#_1209 : HeapType;
var callMask#_1210 : MaskType;
var callCredits#_1211 : CreditsType;
var exhaleMask#_1213 : MaskType;
var inhaleHeap#_1221 : HeapType;
var Heap#_1225 : HeapType;
var Mask#_1226 : MaskType;
var Credits#_1227 : CreditsType;
var exhaleMask#_1228 : MaskType;
var Heap#_1232 : HeapType;
var Mask#_1233 : MaskType;
var Credits#_1234 : CreditsType;
var exhaleMask#_1236 : MaskType;
var exhaleMask#_1238 : MaskType;
var inhaleHeap#_1240 : HeapType;
var exhaleMask#_1242 : MaskType;
var inhaleHeap#_1244 : HeapType;
var callHeap#_1245 : HeapType;
var callMask#_1246 : MaskType;
var callCredits#_1247 : CreditsType;
var exhaleMask#_1249 : MaskType;
var inhaleHeap#_1257 : HeapType;
var nw#_1258 : ref;
var v#138 : int;
var callHeap#_1259 : HeapType;
var callMask#_1260 : MaskType;
var callCredits#_1261 : CreditsType;
var exhaleMask#_1263 : MaskType;
var inhaleHeap#_1275 : HeapType;
var exhaleMask#_1277 : MaskType;
var inhaleHeap#_1279 : HeapType;
var exhaleMask#_1281 : MaskType;
var inhaleHeap#_1283 : HeapType;
var callHeap#_1284 : HeapType;
var callMask#_1285 : MaskType;
var callCredits#_1286 : CreditsType;
var exhaleMask#_1288 : MaskType;
var inhaleHeap#_1296 : HeapType;
var nw#_1297 : ref;
var Heap#_1301 : HeapType;
var Mask#_1302 : MaskType;
var Credits#_1303 : CreditsType;
var exhaleMask#_1304 : MaskType;
var Heap#_1308 : HeapType;
var Mask#_1309 : MaskType;
var Credits#_1310 : CreditsType;
var exhaleMask#_1312 : MaskType;
var Heap#_1316 : HeapType;
var Mask#_1317 : MaskType;
var Credits#_1318 : CreditsType;
var exhaleMask#_1320 : MaskType;
var nw#_1321 : ref;
var vp#144 : int;
var vop#145 : int;
var callHeap#_1322 : HeapType;
var callMask#_1323 : MaskType;
var callCredits#_1324 : CreditsType;
var exhaleMask#_1326 : MaskType;
var inhaleHeap#_1337 : HeapType;
var preCallHeap#_1340 : HeapType;
var preCallMask#_1341 : MaskType;
var preCallCredits#_1342 : CreditsType;
var exhaleMask#_1345 : MaskType;
var token#_1338 : ref;
var asyncstate#_1339 : int;
var nw#_1358 : ref;
var v#149 : int;
var vo#150 : int;
var callHeap#_1359 : HeapType;
var callMask#_1360 : MaskType;
var callCredits#_1361 : CreditsType;
var exhaleMask#_1363 : MaskType;
var inhaleHeap#_1382 : HeapType;
var callHeap#_1383 : HeapType;
var callMask#_1384 : MaskType;
var callCredits#_1385 : CreditsType;
var exhaleMask#_1387 : MaskType;
var inhaleHeap#_1395 : HeapType;
var nw#_1396 : ref;
var Heap#_1400 : HeapType;
var Mask#_1401 : MaskType;
var Credits#_1402 : CreditsType;
var exhaleMask#_1403 : MaskType;
var Heap#_1407 : HeapType;
var Mask#_1408 : MaskType;
var Credits#_1409 : CreditsType;
var exhaleMask#_1411 : MaskType;
var Heap#_1415 : HeapType;
var Mask#_1416 : MaskType;
var Credits#_1417 : CreditsType;
var exhaleMask#_1419 : MaskType;
var exhaleMask#_1420 : MaskType;
var inhaleHeap#_1434 : HeapType;
procedure FactorialActor.act (this : ref)
{
	var methodK#_1151 : int;
	var inhaleHeap#_1153 : HeapType;
	var unfoldK#_1154 : int;
	var exhaleMask#_1155 : MaskType;
	var inhaleHeap#_1157 : HeapType;
	var unfoldK#_1158 : int;
	var exhaleMask#_1159 : MaskType;
	var inhaleHeap#_1161 : HeapType;
	var unfoldK#_1162 : int;
	var exhaleMask#_1163 : MaskType;
	var inhaleHeap#_1165 : HeapType;
	var unfoldK#_1166 : int;
	var exhaleMask#_1167 : MaskType;
	var inhaleHeap#_1169 : HeapType;
	var whileK#_1176 : int;
	var whileHeap#_1170 : HeapType;
	var whileMask#_1171 : MaskType;
	var whileCredits#_1172 : CreditsType;
	var exhaleMask#_1177 : MaskType;
	var inhaleHeap#_1188 : HeapType;
	var inhaleHeap#_1189 : HeapType;
	var iterStartHeap#_1173 : HeapType;
	var iterStartMask#_1174 : MaskType;
	var iterStartCredits#_1175 : CreditsType;
	var current#67 : ref;
	var this#127 : ref;
	var msg#128 : ref;
	var inhaleHeap#_1192 : HeapType;
	var methodCallK#_1196 : int;
	var this#129 : ref;
	var mi#130 : ref;
	var mo#131 : ref;
	var callHeap#_1193 : HeapType;
	var callMask#_1194 : MaskType;
	var callCredits#_1195 : CreditsType;
	var exhaleMask#_1197 : MaskType;
	var inhaleHeap#_1203 : HeapType;
	var unfoldK#_1204 : int;
	var exhaleMask#_1205 : MaskType;
	var inhaleHeap#_1207 : HeapType;
	var m#69 : ref;
	var nw#_1208 : ref;
	var methodCallK#_1212 : int;
	var this#132 : ref;
	var vr#133 : int;
	var receiver#134 : ref;
	var callHeap#_1209 : HeapType;
	var callMask#_1210 : MaskType;
	var callCredits#_1211 : CreditsType;
	var exhaleMask#_1213 : MaskType;
	var inhaleHeap#_1221 : HeapType;
	var Heap#_1225 : HeapType;
	var Mask#_1226 : MaskType;
	var Credits#_1227 : CreditsType;
	var exhaleMask#_1228 : MaskType;
	var funcappK#_1235 : int;
	var Heap#_1232 : HeapType;
	var Mask#_1233 : MaskType;
	var Credits#_1234 : CreditsType;
	var exhaleMask#_1236 : MaskType;
	var unfoldK#_1237 : int;
	var exhaleMask#_1238 : MaskType;
	var inhaleHeap#_1240 : HeapType;
	var unfoldK#_1241 : int;
	var exhaleMask#_1242 : MaskType;
	var inhaleHeap#_1244 : HeapType;
	var methodCallK#_1248 : int;
	var this#135 : ref;
	var m#136 : ref;
	var callHeap#_1245 : HeapType;
	var callMask#_1246 : MaskType;
	var callCredits#_1247 : CreditsType;
	var exhaleMask#_1249 : MaskType;
	var inhaleHeap#_1257 : HeapType;
	var m#71 : ref;
	var nw#_1258 : ref;
	var methodCallK#_1262 : int;
	var this#137 : ref;
	var v#138 : int;
	var oldv#139 : ref;
	var receiver#140 : ref;
	var callHeap#_1259 : HeapType;
	var callMask#_1260 : MaskType;
	var callCredits#_1261 : CreditsType;
	var exhaleMask#_1263 : MaskType;
	var inhaleHeap#_1275 : HeapType;
	var unfoldK#_1276 : int;
	var exhaleMask#_1277 : MaskType;
	var inhaleHeap#_1279 : HeapType;
	var unfoldK#_1280 : int;
	var exhaleMask#_1281 : MaskType;
	var inhaleHeap#_1283 : HeapType;
	var methodCallK#_1287 : int;
	var this#141 : ref;
	var m#142 : ref;
	var callHeap#_1284 : HeapType;
	var callMask#_1285 : MaskType;
	var callCredits#_1286 : CreditsType;
	var exhaleMask#_1288 : MaskType;
	var inhaleHeap#_1296 : HeapType;
	var r#73 : ref;
	var nw#_1297 : ref;
	var Heap#_1301 : HeapType;
	var Mask#_1302 : MaskType;
	var Credits#_1303 : CreditsType;
	var exhaleMask#_1304 : MaskType;
	var funcappK#_1311 : int;
	var Heap#_1308 : HeapType;
	var Mask#_1309 : MaskType;
	var Credits#_1310 : CreditsType;
	var exhaleMask#_1312 : MaskType;
	var funcappK#_1319 : int;
	var Heap#_1316 : HeapType;
	var Mask#_1317 : MaskType;
	var Credits#_1318 : CreditsType;
	var exhaleMask#_1320 : MaskType;
	var cont#75 : ref;
	var nw#_1321 : ref;
	var methodCallK#_1325 : int;
	var this#143 : ref;
	var vp#144 : int;
	var vop#145 : int;
	var custp#146 : ref;
	var callHeap#_1322 : HeapType;
	var callMask#_1323 : MaskType;
	var callCredits#_1324 : CreditsType;
	var exhaleMask#_1326 : MaskType;
	var inhaleHeap#_1337 : HeapType;
	var asyncMethodCallK#_1344 : int;
	var preCallHeap#_1340 : HeapType;
	var preCallMask#_1341 : MaskType;
	var preCallCredits#_1342 : CreditsType;
	var argsSeq#_1343 : ArgSeq;
	var this#147 : ref;
	var exhaleMask#_1345 : MaskType;
	var token#_1338 : ref;
	var asyncstate#_1339 : int;
	var m#77 : ref;
	var nw#_1358 : ref;
	var methodCallK#_1362 : int;
	var this#148 : ref;
	var v#149 : int;
	var vo#150 : int;
	var cust#151 : ref;
	var receiver#152 : ref;
	var callHeap#_1359 : HeapType;
	var callMask#_1360 : MaskType;
	var callCredits#_1361 : CreditsType;
	var exhaleMask#_1363 : MaskType;
	var inhaleHeap#_1382 : HeapType;
	var methodCallK#_1386 : int;
	var this#153 : ref;
	var m#154 : ref;
	var callHeap#_1383 : HeapType;
	var callMask#_1384 : MaskType;
	var callCredits#_1385 : CreditsType;
	var exhaleMask#_1387 : MaskType;
	var inhaleHeap#_1395 : HeapType;
	var r#79 : ref;
	var nw#_1396 : ref;
	var Heap#_1400 : HeapType;
	var Mask#_1401 : MaskType;
	var Credits#_1402 : CreditsType;
	var exhaleMask#_1403 : MaskType;
	var funcappK#_1410 : int;
	var Heap#_1407 : HeapType;
	var Mask#_1408 : MaskType;
	var Credits#_1409 : CreditsType;
	var exhaleMask#_1411 : MaskType;
	var funcappK#_1418 : int;
	var Heap#_1415 : HeapType;
	var Mask#_1416 : MaskType;
	var Credits#_1417 : CreditsType;
	var exhaleMask#_1419 : MaskType;
	var exhaleMask#_1420 : MaskType;
	var inhaleHeap#_1434 : HeapType;
	var inhaleHeap#_1153_$_0 : HeapType;
	var Heap_$_0 : HeapType;
	var Mask_$_0 : MaskType;
	var Heap_$_1 : HeapType;
	var Mask_$_1 : MaskType;
	var Heap_$_2 : HeapType;
	var Mask_$_2 : MaskType;
	var Heap_$_3 : HeapType;
	var Mask_$_3 : MaskType;
	var Heap_$_4 : HeapType;
	var Mask_$_4 : MaskType;
	var Heap_$_5 : HeapType;
	var Mask_$_5 : MaskType;
	var Credits_$_0 : CreditsType;
	var exhaleMask#_1155_$_0 : MaskType;
	var inhaleHeap#_1157_$_0 : HeapType;
	var Heap_$_6 : HeapType;
	var Mask_$_6 : MaskType;
	var Heap_$_7 : HeapType;
	var Mask_$_7 : MaskType;
	var Heap_$_8 : HeapType;
	var Mask_$_8 : MaskType;
	var Heap_$_9 : HeapType;
	var Mask_$_9 : MaskType;
	var Heap_$_10 : HeapType;
	var Mask_$_10 : MaskType;
	var Heap_$_11 : HeapType;
	var Mask_$_11 : MaskType;
	var exhaleMask#_1159_$_0 : MaskType;
	var inhaleHeap#_1161_$_0 : HeapType;
	var Heap_$_12 : HeapType;
	var Mask_$_12 : MaskType;
	var Heap_$_13 : HeapType;
	var Mask_$_13 : MaskType;
	var Heap_$_14 : HeapType;
	var Mask_$_14 : MaskType;
	var Heap_$_15 : HeapType;
	var Mask_$_15 : MaskType;
	var Heap_$_16 : HeapType;
	var Mask_$_16 : MaskType;
	var Heap_$_17 : HeapType;
	var Mask_$_17 : MaskType;
	var Heap_$_18 : HeapType;
	var Mask_$_18 : MaskType;
	var Heap_$_19 : HeapType;
	var Mask_$_19 : MaskType;
	var exhaleMask#_1163_$_0 : MaskType;
	var inhaleHeap#_1165_$_0 : HeapType;
	var Heap_$_20 : HeapType;
	var Mask_$_20 : MaskType;
	var Heap_$_21 : HeapType;
	var Mask_$_21 : MaskType;
	var exhaleMask#_1167_$_0 : MaskType;
	var inhaleHeap#_1169_$_0 : HeapType;
	var Heap_$_22 : HeapType;
	var Mask_$_22 : MaskType;
	var Heap_$_23 : HeapType;
	var Mask_$_23 : MaskType;
	var Credits_$_1 : CreditsType;
	var exhaleMask#_1177_$_0 : MaskType;
	var exhaleMask#_1177_$_1 : MaskType;
	var exhaleMask#_1177_$_2 : MaskType;
	var exhaleMask#_1177_$_3 : MaskType;
	var exhaleMask#_1177_$_4 : MaskType;
	var exhaleMask#_1177_$_5 : MaskType;
	var exhaleMask#_1177_$_6 : MaskType;
	var exhaleMask#_1177_$_7 : MaskType;
	var exhaleMask#_1177_$_8 : MaskType;
	var Heap_$_24 : HeapType;
	var inhaleHeap#_1188_$_0 : HeapType;
	var Heap_$_25 : HeapType;
	var Mask_$_24 : MaskType;
	var Heap_$_26 : HeapType;
	var Mask_$_25 : MaskType;
	var Heap_$_27 : HeapType;
	var Mask_$_26 : MaskType;
	var Heap_$_28 : HeapType;
	var Mask_$_27 : MaskType;
	var Heap_$_29 : HeapType;
	var Mask_$_28 : MaskType;
	var Heap_$_30 : HeapType;
	var Mask_$_29 : MaskType;
	var Heap_$_31 : HeapType;
	var Mask_$_30 : MaskType;
	var Heap_$_32 : HeapType;
	var Mask_$_31 : MaskType;
	var Heap_$_33 : HeapType;
	var Mask_$_32 : MaskType;
	var Credits_$_2 : CreditsType;
	var Heap_$_34 : HeapType;
	var inhaleHeap#_1189_$_0 : HeapType;
	var Heap_$_35 : HeapType;
	var Mask_$_33 : MaskType;
	var Heap_$_36 : HeapType;
	var Mask_$_34 : MaskType;
	var Heap_$_37 : HeapType;
	var Mask_$_35 : MaskType;
	var Heap_$_38 : HeapType;
	var Mask_$_36 : MaskType;
	var Heap_$_39 : HeapType;
	var Mask_$_37 : MaskType;
	var Heap_$_40 : HeapType;
	var Mask_$_38 : MaskType;
	var Heap_$_41 : HeapType;
	var Mask_$_39 : MaskType;
	var Heap_$_42 : HeapType;
	var Mask_$_40 : MaskType;
	var Heap_$_43 : HeapType;
	var Mask_$_41 : MaskType;
	var Credits_$_3 : CreditsType;
	var this#127_$_0 : ref;
	var msg#128_$_0 : ref;
	var inhaleHeap#_1192_$_0 : HeapType;
	var Heap_$_44 : HeapType;
	var Mask_$_42 : MaskType;
	var Heap_$_45 : HeapType;
	var Mask_$_43 : MaskType;
	var Credits_$_4 : CreditsType;
	var inhaleHeap#_1434_$_0 : HeapType;
	var Heap_$_46 : HeapType;
	var Mask_$_44 : MaskType;
	var Heap_$_47 : HeapType;
	var Mask_$_45 : MaskType;
	var Heap_$_48 : HeapType;
	var Mask_$_46 : MaskType;
	var Heap_$_49 : HeapType;
	var Mask_$_47 : MaskType;
	var Heap_$_50 : HeapType;
	var Mask_$_48 : MaskType;
	var Heap_$_51 : HeapType;
	var Mask_$_49 : MaskType;
	var Heap_$_52 : HeapType;
	var Mask_$_50 : MaskType;
	var Heap_$_53 : HeapType;
	var Mask_$_51 : MaskType;
	var Heap_$_54 : HeapType;
	var Mask_$_52 : MaskType;
	var Credits_$_5 : CreditsType;
	var this#129_$_0 : ref;
	var exhaleMask#_1197_$_0 : MaskType;
	var exhaleMask#_1197_$_1 : MaskType;
	var exhaleMask#_1197_$_2 : MaskType;
	var mo#131_$_0 : ref;
	var inhaleHeap#_1203_$_0 : HeapType;
	var Heap_$_55 : HeapType;
	var Mask_$_53 : MaskType;
	var Heap_$_56 : HeapType;
	var Mask_$_54 : MaskType;
	var Heap_$_57 : HeapType;
	var Mask_$_55 : MaskType;
	var exhaleMask#_1205_$_0 : MaskType;
	var inhaleHeap#_1207_$_0 : HeapType;
	var Heap_$_58 : HeapType;
	var Mask_$_56 : MaskType;
	var Heap_$_59 : HeapType;
	var Mask_$_57 : MaskType;
	var Heap_$_60 : HeapType;
	var Mask_$_58 : MaskType;
	var Heap_$_61 : HeapType;
	var Mask_$_59 : MaskType;
	var Heap_$_62 : HeapType;
	var Mask_$_60 : MaskType;
	var Heap_$_63 : HeapType;
	var Mask_$_61 : MaskType;
	var Heap_$_64 : HeapType;
	var Mask_$_62 : MaskType;
	var Heap_$_65 : HeapType;
	var Mask_$_63 : MaskType;
	var Heap_$_66 : HeapType;
	var Mask_$_64 : MaskType;
	var Heap_$_67 : HeapType;
	var Mask_$_65 : MaskType;
	var Heap_$_68 : HeapType;
	var Mask_$_66 : MaskType;
	var Heap_$_69 : HeapType;
	var Mask_$_67 : MaskType;
	var Heap_$_70 : HeapType;
	var Mask_$_68 : MaskType;
	var Heap_$_71 : HeapType;
	var Mask_$_69 : MaskType;
	var Heap_$_72 : HeapType;
	var Mask_$_70 : MaskType;
	var Mask_$_71 : MaskType;
	var Heap_$_73 : HeapType;
	var nw#_1321_$_0 : ref;
	var Mask_$_72 : MaskType;
	var Mask_$_73 : MaskType;
	var Mask_$_74 : MaskType;
	var Mask_$_75 : MaskType;
	var Mask_$_76 : MaskType;
	var vp#144_$_0 : int;
	var vop#145_$_0 : int;
	var custp#146_$_0 : ref;
	var exhaleMask#_1326_$_0 : MaskType;
	var exhaleMask#_1326_$_1 : MaskType;
	var exhaleMask#_1326_$_2 : MaskType;
	var exhaleMask#_1326_$_3 : MaskType;
	var exhaleMask#_1326_$_4 : MaskType;
	var exhaleMask#_1326_$_5 : MaskType;
	var exhaleMask#_1326_$_6 : MaskType;
	var exhaleMask#_1326_$_7 : MaskType;
	var exhaleMask#_1326_$_8 : MaskType;
	var inhaleHeap#_1337_$_0 : HeapType;
	var Heap_$_74 : HeapType;
	var Mask_$_77 : MaskType;
	var Heap_$_75 : HeapType;
	var Mask_$_78 : MaskType;
	var Heap_$_76 : HeapType;
	var Mask_$_79 : MaskType;
	var Heap_$_77 : HeapType;
	var Mask_$_80 : MaskType;
	var Heap_$_78 : HeapType;
	var Mask_$_81 : MaskType;
	var Heap_$_79 : HeapType;
	var Mask_$_82 : MaskType;
	var Heap_$_80 : HeapType;
	var Mask_$_83 : MaskType;
	var Heap_$_81 : HeapType;
	var Mask_$_84 : MaskType;
	var Heap_$_82 : HeapType;
	var Mask_$_85 : MaskType;
	var Heap_$_83 : HeapType;
	var Mask_$_86 : MaskType;
	var Heap_$_84 : HeapType;
	var Mask_$_87 : MaskType;
	var Heap_$_85 : HeapType;
	var Mask_$_88 : MaskType;
	var Heap_$_86 : HeapType;
	var Mask_$_89 : MaskType;
	var Heap_$_87 : HeapType;
	var Mask_$_90 : MaskType;
	var Heap_$_88 : HeapType;
	var Mask_$_91 : MaskType;
	var Heap_$_89 : HeapType;
	var Mask_$_92 : MaskType;
	var Heap_$_90 : HeapType;
	var Mask_$_93 : MaskType;
	var Heap_$_91 : HeapType;
	var Mask_$_94 : MaskType;
	var Heap_$_92 : HeapType;
	var Mask_$_95 : MaskType;
	var argsSeq#_1343_$_0 : ArgSeq;
	var Credits_$_6 : CreditsType;
	var exhaleMask#_1345_$_0 : MaskType;
	var exhaleMask#_1345_$_1 : MaskType;
	var exhaleMask#_1345_$_2 : MaskType;
	var exhaleMask#_1345_$_3 : MaskType;
	var exhaleMask#_1345_$_4 : MaskType;
	var exhaleMask#_1345_$_5 : MaskType;
	var exhaleMask#_1345_$_6 : MaskType;
	var exhaleMask#_1345_$_7 : MaskType;
	var exhaleMask#_1345_$_8 : MaskType;
	var exhaleMask#_1345_$_9 : MaskType;
	var exhaleMask#_1345_$_10 : MaskType;
	var exhaleMask#_1345_$_11 : MaskType;
	var exhaleMask#_1345_$_12 : MaskType;
	var token#_1338_$_0 : ref;
	var Mask_$_96 : MaskType;
	var asyncstate#_1339_$_0 : int;
	var Heap_$_93 : HeapType;
	var Heap_$_94 : HeapType;
	var nw#_1358_$_0 : ref;
	var Mask_$_97 : MaskType;
	var Mask_$_98 : MaskType;
	var Mask_$_99 : MaskType;
	var Mask_$_100 : MaskType;
	var Mask_$_101 : MaskType;
	var Mask_$_102 : MaskType;
	var Mask_$_103 : MaskType;
	var Mask_$_104 : MaskType;
	var Mask_$_105 : MaskType;
	var Mask_$_106 : MaskType;
	var Mask_$_107 : MaskType;
	var Mask_$_108 : MaskType;
	var Mask_$_109 : MaskType;
	var Mask_$_110 : MaskType;
	var Mask_$_111 : MaskType;
	var Mask_$_112 : MaskType;
	var Mask_$_113 : MaskType;
	var Mask_$_114 : MaskType;
	var Heap_$_95 : HeapType;
	var v#149_$_0 : int;
	var vo#150_$_0 : int;
	var exhaleMask#_1363_$_0 : MaskType;
	var exhaleMask#_1363_$_1 : MaskType;
	var exhaleMask#_1363_$_2 : MaskType;
	var exhaleMask#_1363_$_3 : MaskType;
	var exhaleMask#_1363_$_4 : MaskType;
	var exhaleMask#_1363_$_5 : MaskType;
	var exhaleMask#_1363_$_6 : MaskType;
	var exhaleMask#_1363_$_7 : MaskType;
	var exhaleMask#_1363_$_8 : MaskType;
	var exhaleMask#_1363_$_9 : MaskType;
	var exhaleMask#_1363_$_10 : MaskType;
	var exhaleMask#_1363_$_11 : MaskType;
	var exhaleMask#_1363_$_12 : MaskType;
	var exhaleMask#_1363_$_13 : MaskType;
	var exhaleMask#_1363_$_14 : MaskType;
	var exhaleMask#_1363_$_15 : MaskType;
	var exhaleMask#_1363_$_16 : MaskType;
	var inhaleHeap#_1382_$_0 : HeapType;
	var Heap_$_96 : HeapType;
	var Mask_$_115 : MaskType;
	var Heap_$_97 : HeapType;
	var Mask_$_116 : MaskType;
	var Heap_$_98 : HeapType;
	var Mask_$_117 : MaskType;
	var Heap_$_99 : HeapType;
	var Mask_$_118 : MaskType;
	var this#153_$_0 : ref;
	var exhaleMask#_1387_$_0 : MaskType;
	var exhaleMask#_1387_$_1 : MaskType;
	var exhaleMask#_1387_$_2 : MaskType;
	var exhaleMask#_1387_$_3 : MaskType;
	var exhaleMask#_1387_$_4 : MaskType;
	var inhaleHeap#_1395_$_0 : HeapType;
	var Heap_$_100 : HeapType;
	var Mask_$_119 : MaskType;
	var Heap_$_101 : HeapType;
	var Mask_$_120 : MaskType;
	var nw#_1396_$_0 : ref;
	var Mask_$_121 : MaskType;
	var Mask_$_122 : MaskType;
	var Mask_$_123 : MaskType;
	var Mask_$_124 : MaskType;
	var Mask_$_125 : MaskType;
	var Mask_$_126 : MaskType;
	var Mask_$_127 : MaskType;
	var Mask_$_128 : MaskType;
	var Mask_$_129 : MaskType;
	var Mask_$_130 : MaskType;
	var Mask_$_131 : MaskType;
	var Mask_$_132 : MaskType;
	var Mask_$_133 : MaskType;
	var Mask_$_134 : MaskType;
	var Mask_$_135 : MaskType;
	var Mask_$_136 : MaskType;
	var Mask_$_137 : MaskType;
	var Mask_$_138 : MaskType;
	var Heap_$_102 : HeapType;
	var nw#_1208_$_0 : ref;
	var Mask_$_139 : MaskType;
	var Mask_$_140 : MaskType;
	var Mask_$_141 : MaskType;
	var Mask_$_142 : MaskType;
	var Mask_$_143 : MaskType;
	var Mask_$_144 : MaskType;
	var Mask_$_145 : MaskType;
	var Mask_$_146 : MaskType;
	var Mask_$_147 : MaskType;
	var Mask_$_148 : MaskType;
	var Mask_$_149 : MaskType;
	var Mask_$_150 : MaskType;
	var Mask_$_151 : MaskType;
	var Mask_$_152 : MaskType;
	var Mask_$_153 : MaskType;
	var Mask_$_154 : MaskType;
	var Mask_$_155 : MaskType;
	var Mask_$_156 : MaskType;
	var Heap_$_103 : HeapType;
	var receiver#134_$_0 : ref;
	var nw#_1258_$_0 : ref;
	var Mask_$_157 : MaskType;
	var Mask_$_158 : MaskType;
	var Mask_$_159 : MaskType;
	var Mask_$_160 : MaskType;
	var Mask_$_161 : MaskType;
	var Mask_$_162 : MaskType;
	var Mask_$_163 : MaskType;
	var Mask_$_164 : MaskType;
	var Mask_$_165 : MaskType;
	var Mask_$_166 : MaskType;
	var Mask_$_167 : MaskType;
	var Mask_$_168 : MaskType;
	var Mask_$_169 : MaskType;
	var Mask_$_170 : MaskType;
	var Mask_$_171 : MaskType;
	var Mask_$_172 : MaskType;
	var Mask_$_173 : MaskType;
	var Mask_$_174 : MaskType;
	var Heap_$_104 : HeapType;
	var receiver#140_$_0 : ref;
	var exhaleMask#_1263_$_0 : MaskType;
	var exhaleMask#_1263_$_1 : MaskType;
	var exhaleMask#_1263_$_2 : MaskType;
	var exhaleMask#_1263_$_3 : MaskType;
	var exhaleMask#_1263_$_4 : MaskType;
	var exhaleMask#_1263_$_5 : MaskType;
	var exhaleMask#_1263_$_6 : MaskType;
	var exhaleMask#_1263_$_7 : MaskType;
	var exhaleMask#_1263_$_8 : MaskType;
	var inhaleHeap#_1275_$_0 : HeapType;
	var Heap_$_105 : HeapType;
	var Mask_$_175 : MaskType;
	var Heap_$_106 : HeapType;
	var Mask_$_176 : MaskType;
	var Heap_$_107 : HeapType;
	var Mask_$_177 : MaskType;
	var Heap_$_108 : HeapType;
	var Mask_$_178 : MaskType;
	var exhaleMask#_1277_$_0 : MaskType;
	var inhaleHeap#_1279_$_0 : HeapType;
	var Heap_$_109 : HeapType;
	var Mask_$_179 : MaskType;
	var Heap_$_110 : HeapType;
	var Mask_$_180 : MaskType;
	var Heap_$_111 : HeapType;
	var Mask_$_181 : MaskType;
	var Heap_$_112 : HeapType;
	var Mask_$_182 : MaskType;
	var Heap_$_113 : HeapType;
	var Mask_$_183 : MaskType;
	var Heap_$_114 : HeapType;
	var Mask_$_184 : MaskType;
	var exhaleMask#_1281_$_0 : MaskType;
	var inhaleHeap#_1283_$_0 : HeapType;
	var Heap_$_115 : HeapType;
	var Mask_$_185 : MaskType;
	var Heap_$_116 : HeapType;
	var Mask_$_186 : MaskType;
	var this#141_$_0 : ref;
	var exhaleMask#_1288_$_0 : MaskType;
	var exhaleMask#_1288_$_1 : MaskType;
	var exhaleMask#_1288_$_2 : MaskType;
	var exhaleMask#_1288_$_3 : MaskType;
	var exhaleMask#_1288_$_4 : MaskType;
	var inhaleHeap#_1296_$_0 : HeapType;
	var Heap_$_117 : HeapType;
	var Mask_$_187 : MaskType;
	var Heap_$_118 : HeapType;
	var Mask_$_188 : MaskType;
	var nw#_1297_$_0 : ref;
	var Mask_$_189 : MaskType;
	var Mask_$_190 : MaskType;
	var Mask_$_191 : MaskType;
	var Mask_$_192 : MaskType;
	var Mask_$_193 : MaskType;
	var Mask_$_194 : MaskType;
	var Mask_$_195 : MaskType;
	var Mask_$_196 : MaskType;
	var Mask_$_197 : MaskType;
	var Mask_$_198 : MaskType;
	var Mask_$_199 : MaskType;
	var Mask_$_200 : MaskType;
	var Mask_$_201 : MaskType;
	var Mask_$_202 : MaskType;
	var Mask_$_203 : MaskType;
	var Mask_$_204 : MaskType;
	var Mask_$_205 : MaskType;
	var Mask_$_206 : MaskType;
	var Heap_$_119 : HeapType;
	var exhaleMask#_1213_$_0 : MaskType;
	var exhaleMask#_1213_$_1 : MaskType;
	var exhaleMask#_1213_$_2 : MaskType;
	var exhaleMask#_1213_$_3 : MaskType;
	var exhaleMask#_1213_$_4 : MaskType;
	var exhaleMask#_1213_$_5 : MaskType;
	var inhaleHeap#_1221_$_0 : HeapType;
	var Heap_$_120 : HeapType;
	var Mask_$_207 : MaskType;
	var Heap_$_121 : HeapType;
	var Mask_$_208 : MaskType;
	var Heap_$_122 : HeapType;
	var Mask_$_209 : MaskType;
	var Heap_$_123 : HeapType;
	var Mask_$_210 : MaskType;
	var exhaleMask#_1238_$_0 : MaskType;
	var inhaleHeap#_1240_$_0 : HeapType;
	var Heap_$_124 : HeapType;
	var Mask_$_211 : MaskType;
	var Heap_$_125 : HeapType;
	var Mask_$_212 : MaskType;
	var Heap_$_126 : HeapType;
	var Mask_$_213 : MaskType;
	var Heap_$_127 : HeapType;
	var Mask_$_214 : MaskType;
	var Heap_$_128 : HeapType;
	var Mask_$_215 : MaskType;
	var Heap_$_129 : HeapType;
	var Mask_$_216 : MaskType;
	var exhaleMask#_1242_$_0 : MaskType;
	var inhaleHeap#_1244_$_0 : HeapType;
	var Heap_$_130 : HeapType;
	var Mask_$_217 : MaskType;
	var Heap_$_131 : HeapType;
	var Mask_$_218 : MaskType;
	var this#135_$_0 : ref;
	var exhaleMask#_1249_$_0 : MaskType;
	var exhaleMask#_1249_$_1 : MaskType;
	var exhaleMask#_1249_$_2 : MaskType;
	var exhaleMask#_1249_$_3 : MaskType;
	var exhaleMask#_1249_$_4 : MaskType;
	var inhaleHeap#_1257_$_0 : HeapType;
	var Heap_$_132 : HeapType;
	var Mask_$_219 : MaskType;
	var Heap_$_133 : HeapType;
	var Mask_$_220 : MaskType;
	var Mask_$_221 : MaskType;
	var Credits_$_7 : CreditsType;
	var Heap_$_134 : HeapType;
	var Credits_$_8 : CreditsType;
	var exhaleMask#_1420_$_0 : MaskType;
	var exhaleMask#_1420_$_1 : MaskType;
	var exhaleMask#_1420_$_2 : MaskType;
	var exhaleMask#_1420_$_3 : MaskType;
	var exhaleMask#_1420_$_4 : MaskType;
	var exhaleMask#_1420_$_5 : MaskType;
	var exhaleMask#_1420_$_6 : MaskType;
	var exhaleMask#_1420_$_7 : MaskType;
	var exhaleMask#_1420_$_8 : MaskType;
	var $_$_condition : bool;
	var $_$_condition_$0 : bool;
	var $_$_condition_$1 : bool;
	var $_$_condition_$2 : bool;
	var $_$_condition_$3 : bool;
	var $_$_condition_$4 : bool;
	var $_$_condition_$5 : bool;
	var $_$_condition_$6 : bool;
	var $_$_condition_$7 : bool;
	var $_$_condition_$8 : bool;
	var $_$_condition_$9 : bool;
	var $_$_condition_$10 : bool;
	var $_$_condition_$11 : bool;
	var $_$_condition_$12 : bool;
	var $_$_condition_$13 : bool;
	var $_$_condition_$14 : bool;
	var $_$_condition_$15 : bool;
	var $_$_condition_$16 : bool;
	var $_$_condition_$17 : bool;
	var $_$_condition_$18 : bool;
	var $_$_condition_$19 : bool;
	var $_$_condition_$20 : bool;
	var $_$_condition_$21 : bool;
	var $_$_condition_$22 : bool;
	var $_$_condition_$23 : bool;
	var $_$_condition_$24 : bool;
	var $_$_condition_$25 : bool;
	var $_$_condition_$26 : bool;
	var $_$_condition_$27 : bool;
	var $_$_condition_$28 : bool;
$start:
	assume Permission$denominator > 0;
	assume (Permission$Zero[perm$R] == 0) && (Permission$Zero[perm$N] == 0);
	assume (Permission$Full[perm$R] == Permission$FullFraction) && (Permission$Full[perm$N] == 0);
	assume (forall<T> o : ref, f : Field (T) , pc : PermissionComponent :: ( ZeroMask[o,f][pc] == 0 ));
	assume IsGoodMask(ZeroMask);
	assume NonPredicateField(joinable);
	assume NonPredicateField(forkK);
	assume (forall  n : Integer :: {Fractions(n)} ( Fractions(n) == (n * Permission$denominator) ));
	assume (forall  x : Integer, y : Integer :: ( ((0 <= x) && (x <= y)) ==> (Fractions(x) <= Fractions(y)) ));
	assume Permission$FullFraction == Fractions(100);
	assume (0 < channelK) && ((1000 * channelK) < Fractions(1));
	assume (0 < monitorK) && ((1000 * monitorK) < Fractions(1));
	assume (0 < predicateK) && ((1000 * predicateK) < Fractions(1));
	assume (predicateK == channelK) && (channelK == monitorK);
	assume (forall<T,U> a : T, b : U :: {IsGoodState(combine(a,b))} ( IsGoodState(combine(a,b)) <==> (IsGoodState(a) && IsGoodState(b)) ));
	assume IsGoodState(nostate);
	assume NonPredicateField(mu);
	assume (forall  m : Mu, n_$0 : Mu :: {MuBelow(m,n_$0),MuBelow(n_$0,m)} ( !(MuBelow(m,n_$0) && MuBelow(n_$0,m)) ));
	assume (forall  m_$0 : Mu, n_$1 : Mu, o_$0 : Mu :: {MuBelow(m_$0,n_$1),MuBelow(n_$1,o_$0)} ( (MuBelow(m_$0,n_$1) && MuBelow(n_$1,o_$0)) ==> MuBelow(m_$0,o_$0) ));
	assume (forall  m_$1 : Mu, n_$2 : Mu :: ( MuBelow(m_$1,n_$2) ==> (!(n_$2 == $LockBottom)) ));
	assume NonPredicateField(held);
	assume NonPredicateField(rdheld);
	assume (forall  ih : HeapType, h : HeapType, m_$2 : MaskType :: {IsGoodInhaleState(ih,h,m_$2)} ( IsGoodInhaleState(ih,h,m_$2) <==> ((((((forall<T> o_$1 : ref, f_$0 : Field (T)  :: {ih[o_$1,f_$0]} ( CanRead(m_$2,o_$1,f_$0) ==> (ih[o_$1,f_$0] == h[o_$1,f_$0]) ))) && ((forall  o_$2 : ref :: {ih[o_$2,held]} ( (0 < ih[o_$2,held]) <==> (0 < h[o_$2,held]) )))) && ((forall  o_$3 : ref :: {ih[o_$3,rdheld]} ( ih[o_$3,rdheld] <==> h[o_$3,rdheld] )))) && ((forall  o_$4 : ref :: {h[o_$4,held]} ( (0 < h[o_$4,held]) ==> (ih[o_$4,mu] == h[o_$4,mu]) )))) && ((forall  o_$5 : ref :: {h[o_$5,rdheld]} ( h[o_$5,rdheld] ==> (ih[o_$5,mu] == h[o_$5,mu]) )))) ));
	assume (forall<T> m_$3 : MaskType, obj : ref, f_$1 : Field (T)  :: {CanRead(m_$3,obj,f_$1)} {:expand  false}( CanRead(m_$3,obj,f_$1) <==> ((0 < m_$3[obj,f_$1][perm$R]) || (0 < m_$3[obj,f_$1][perm$N])) ));
	assume (forall<T> m_$4 : MaskType, obj_$0 : ref, f_$2 : Field (T)  :: {CanWrite(m_$4,obj_$0,f_$2)} {:expand  false}( CanWrite(m_$4,obj_$0,f_$2) <==> ((m_$4[obj_$0,f_$2][perm$R] == Permission$FullFraction) && (m_$4[obj_$0,f_$2][perm$N] == 0)) ));
	assume (forall  m_$5 : MaskType :: {IsGoodMask(m_$5)} {:expand  true}( IsGoodMask(m_$5) <==> ((forall<T> o_$6 : ref, f_$3 : Field (T)  :: ( ((0 <= m_$5[o_$6,f_$3][perm$R]) && (NonPredicateField(f_$3) ==> ((m_$5[o_$6,f_$3][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6,f_$3][perm$N]) ==> (m_$5[o_$6,f_$3][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6,f_$3][perm$N] < 0) ==> (0 < m_$5[o_$6,f_$3][perm$R])) ))) ));
	assume (forall  h_$0 : HeapType, m_$6 : MaskType, o_$7 : ref, q : ref :: {wf(h_$0,m_$6),h_$0[o_$7,mu],h_$0[q,mu]} ( (((wf(h_$0,m_$6) && (!(o_$7 == q))) && ((0 < h_$0[o_$7,held]) || h_$0[o_$7,rdheld])) && ((0 < h_$0[q,held]) || h_$0[q,rdheld])) ==> (!(h_$0[o_$7,mu] == h_$0[q,mu])) ));
	assume (forall<T,U> m_$7 : MaskType, o_$8 : ref, f_$4 : Field (T) , howMuch : Integer, q_$0 : ref, g : Field (U)  :: {DecPerm(m_$7,o_$8,f_$4,howMuch)[q_$0,g][perm$R]} ( DecPerm(m_$7,o_$8,f_$4,howMuch)[q_$0,g][perm$R] == ite((o_$8 == q_$0) && (f_$4 == g),m_$7[q_$0,g][perm$R] - howMuch,m_$7[q_$0,g][perm$R]) ));
	assume (forall<T,U> m_$8 : MaskType, o_$9 : ref, f_$5 : Field (T) , howMuch_$0 : Integer, q_$1 : ref, g_$0 : Field (U)  :: {DecPerm(m_$8,o_$9,f_$5,howMuch_$0)[q_$1,g_$0][perm$N]} ( DecEpsilons(m_$8,o_$9,f_$5,howMuch_$0)[q_$1,g_$0][perm$N] == ite((o_$9 == q_$1) && (f_$5 == g_$0),m_$8[q_$1,g_$0][perm$N] - howMuch_$0,m_$8[q_$1,g_$0][perm$N]) ));
	assume (forall<T,U> m_$9 : MaskType, o_$10 : ref, f_$6 : Field (T) , howMuch_$1 : Integer, q_$2 : ref, g_$1 : Field (U)  :: {IncPerm(m_$9,o_$10,f_$6,howMuch_$1)[q_$2,g_$1][perm$R]} ( IncPerm(m_$9,o_$10,f_$6,howMuch_$1)[q_$2,g_$1][perm$R] == ite((o_$10 == q_$2) && (f_$6 == g_$1),m_$9[q_$2,g_$1][perm$R] + howMuch_$1,m_$9[q_$2,g_$1][perm$R]) ));
	assume (forall<T,U> m_$10 : MaskType, o_$11 : ref, f_$7 : Field (T) , howMuch_$2 : Integer, q_$3 : ref, g_$2 : Field (U)  :: {IncPerm(m_$10,o_$11,f_$7,howMuch_$2)[q_$3,g_$2][perm$N]} ( IncEpsilons(m_$10,o_$11,f_$7,howMuch_$2)[q_$3,g_$2][perm$N] == ite((o_$11 == q_$3) && (f_$7 == g_$2),m_$10[q_$3,g_$2][perm$N] + howMuch_$2,m_$10[q_$3,g_$2][perm$N]) ));
	assume (forall<T,U> h_$1 : HeapType, o_$12 : ref, f_$8 : Field (T) , newValue : U, q_$4 : ref, g_$3 : Field (U)  :: {Havocing(h_$1,o_$12,f_$8,newValue)[q_$4,g_$3]} ( Havocing(h_$1,o_$12,f_$8,newValue)[q_$4,g_$3] == ite((o_$12 == q_$4) && (f_$8 == g_$3),newValue,h_$1[q_$4,g_$3]) ));
	assume (forall  m_$11 : MaskType :: {EmptyMask(m_$11)} ( EmptyMask(m_$11) <==> ((forall<T> o_$13 : ref, f_$9 : Field (T)  :: ( NonPredicateField(f_$9) ==> ((m_$11[o_$13,f_$9][perm$R] <= 0) && (m_$11[o_$13,f_$9][perm$N] <= 0)) ))) ));
	assume (forall  o_$14 : ref :: ( ZeroCredits[o_$14] == 0 ));
	assume (forall  c : CreditsType :: {EmptyCredits(c)} ( EmptyCredits(c) <==> ((forall  o_$15 : ref :: ( (!(o_$15 == null)) ==> (c[o_$15] == 0) ))) ));
	assume (forall<T> f_$10 : Field (T)  :: ( NonPredicateField(f_$10) ==> (!PredicateField(f_$10)) ));
	assume (forall<T> f_$11 : Field (T)  :: ( PredicateField(f_$11) ==> (!NonPredicateField(f_$11)) ));
	assume (forall  m1 : MaskType, m2 : MaskType :: {submask(m1,m2)} ( submask(m1,m2) <==> ((forall<T> o_$16 : ref, f_$12 : Field (T)  :: ( (m1[o_$16,f_$12][perm$R] < m2[o_$16,f_$12][perm$R]) || ((m1[o_$16,f_$12][perm$R] == m2[o_$16,f_$12][perm$R]) && (m1[o_$16,f_$12][perm$N] <= m2[o_$16,f_$12][perm$N])) ))) ));
	assume (forall<T> con : Boolean, a_$0 : T, b_$0 : T :: {ite(con,a_$0,b_$0)} ( con ==> (ite(con,a_$0,b_$0) == a_$0) ));
	assume (forall<T> con_$0 : Boolean, a_$1 : T, b_$1 : T :: {ite(con_$0,a_$1,b_$1)} ( (!con_$0) ==> (ite(con_$0,a_$1,b_$1) == b_$1) ));
	assume NonPredicateField(FactorialActorChannelExpEP.state);
	assume NonPredicateField(FactorialActorChannelExpEP.ch);
	assume NonPredicateField(FactorialActorChannelExpEP.expch);
	assume PredicateField(FactorialActorChannelExpEP.valid);
	assume NonPredicateField(FactorialActorChannelImpEP.state);
	assume NonPredicateField(FactorialActorChannelImpEP.ch);
	assume NonPredicateField(FactorialActorChannelImpEP.impch);
	assume PredicateField(FactorialActorChannelImpEP.valid);
	assume NonPredicateField(FactorialActorChannel.imp);
	assume NonPredicateField(FactorialActorChannel.exp);
	assume PredicateField(FactorialActorChannel.valid);
	assume PredicateField(FactorialActorChannel.initImpState);
	assume PredicateField(FactorialActorChannel.initExpState);
	assume NonPredicateField(FactorialContChannelExpEP.state);
	assume NonPredicateField(FactorialContChannelExpEP.ch);
	assume NonPredicateField(FactorialContChannelExpEP.expch);
	assume PredicateField(FactorialContChannelExpEP.valid);
	assume NonPredicateField(FactorialContChannelImpEP.state);
	assume NonPredicateField(FactorialContChannelImpEP.ch);
	assume NonPredicateField(FactorialContChannelImpEP.impch);
	assume PredicateField(FactorialContChannelImpEP.valid);
	assume NonPredicateField(FactorialContChannel.imp);
	assume NonPredicateField(FactorialContChannel.exp);
	assume PredicateField(FactorialContChannel.valid);
	assume PredicateField(FactorialContChannel.initImpState);
	assume PredicateField(FactorialContChannel.initExpState);
	assume NonPredicateField(FutureChannelExpEP.state);
	assume NonPredicateField(FutureChannelExpEP.ch);
	assume NonPredicateField(FutureChannelExpEP.expch);
	assume PredicateField(FutureChannelExpEP.valid);
	assume NonPredicateField(FutureChannelImpEP.state);
	assume NonPredicateField(FutureChannelImpEP.ch);
	assume NonPredicateField(FutureChannelImpEP.impch);
	assume PredicateField(FutureChannelImpEP.valid);
	assume NonPredicateField(FutureChannel.imp);
	assume NonPredicateField(FutureChannel.exp);
	assume PredicateField(FutureChannel.valid);
	assume PredicateField(FutureChannel.initImpState);
	assume PredicateField(FutureChannel.initExpState);
	assume NonPredicateField(Future.sent);
	assume NonPredicateField(Future.value);
	assume NonPredicateField(Future.q);
	assume (forall  Heap_$0 : HeapType, Mask_$0 : MaskType, this_$0 : ref :: {#Future.getQ(Heap_$0,Mask_$0,this_$0)} ( (wf(Heap_$0,Mask_$0) && (CurrentModule == module#default)) ==> (#Future.getQ(Heap_$0,Mask_$0,this_$0) == Heap_$0[this_$0,Future.q]) ));
	assume (forall  Heap_$1 : HeapType, Mask_$1 : MaskType, this_$1 : ref :: {#Future.getQ(Heap_$1,Mask_$1,this_$1)} ( ((wf(Heap_$1,Mask_$1) && IsGoodState(combine(nostate,combine(Heap_$1[this_$1,Future.q],Heap_$1[Heap_$1[this_$1,Future.q],FutureChannel.valid])))) && CanAssumeFunctionDefs) ==> (#Future.getQ(Heap_$1,Mask_$1,this_$1) == ##Future.getQ(combine(nostate,combine(Heap_$1[this_$1,Future.q],Heap_$1[Heap_$1[this_$1,Future.q],FutureChannel.valid])),this_$1)) ));
	assume NonPredicateField(Message.type);
	assume NonPredicateField(Message.sender1);
	assume NonPredicateField(Message.sender3);
	assume NonPredicateField(Message.sender2);
	assume NonPredicateField(Message.sender4);
	assume NonPredicateField(Message.receiver1);
	assume NonPredicateField(Message.receiver2);
	assume NonPredicateField(Message.receiver3);
	assume NonPredicateField(Message.receiver4);
	assume NonPredicateField(Message.v1);
	assume NonPredicateField(Message.vo1);
	assume NonPredicateField(Message.cust1);
	assume NonPredicateField(Message.vr1);
	assume NonPredicateField(Message.old1);
	assume NonPredicateField(Message.vr2);
	assume NonPredicateField(Message.old2);
	assume NonPredicateField(Message.vr3);
	assume (forall  Heap_$2 : HeapType, Mask_$2 : MaskType, this_$2 : ref, v#49 : Integer :: {#Message.factorial(Heap_$2,Mask_$2,this_$2,v#49)} ( (wf(Heap_$2,Mask_$2) && (CurrentModule == module#default)) ==> (#Message.factorial(Heap_$2,Mask_$2,this_$2,v#49) == ite(v#49 == 0,1,v#49 * #Message.factorial(Heap_$2,Mask_$2,this_$2,v#49 - 1))) ));
	assume (forall  Heap_$3 : HeapType, Mask_$3 : MaskType, this_$3 : ref, v#49_$0 : Integer :: {#Message.factorial(Heap_$3,Mask_$3,this_$3,v#49_$0)} ( #Message.factorial(Heap_$3,Mask_$3,this_$3,v#49_$0) == #Message.factorial#limited(Heap_$3,Mask_$3,this_$3,v#49_$0) ));
	assume (forall  Heap_$4 : HeapType, Mask_$4 : MaskType, this_$4 : ref, v#49_$1 : Integer :: {#Message.factorial#limited(Heap_$4,Mask_$4,this_$4,v#49_$1)} ( ((wf(Heap_$4,Mask_$4) && IsGoodState(combine(nostate,nostate))) && CanAssumeFunctionDefs) ==> (#Message.factorial#limited(Heap_$4,Mask_$4,this_$4,v#49_$1) == ##Message.factorial(combine(nostate,nostate),this_$4,v#49_$1)) ));
	assume (forall  Heap_$5 : HeapType, Mask_$5 : MaskType, this_$5 : ref, v#49_$2 : Integer :: {#Message.factorial(Heap_$5,Mask_$5,this_$5,v#49_$2)} ( (wf(Heap_$5,Mask_$5) && CanAssumeFunctionDefs) ==> ((v#49_$2 == 0) ==> (#Message.factorial(Heap_$5,Mask_$5,this_$5,v#49_$2) == 1)) ));
	assume (forall  Heap_$6 : HeapType, Mask_$6 : MaskType, this_$6 : ref, v#49_$3 : Integer :: {#Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3)} ( (wf(Heap_$6,Mask_$6) && CanAssumeFunctionDefs) ==> ((v#49_$3 > 0) ==> (#Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3) == (v#49_$3 * #Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3 - 1)))) ));
	assume PredicateField(Message.invValue);
	assume PredicateField(Message.invResult1);
	assume PredicateField(Message.invResult2);
	assume PredicateField(Message.invFinalResult);
	assume PredicateField(Message.inv);
	assume NonPredicateField(FactorialActor.q);
	assume (forall  Heap_$7 : HeapType, Mask_$7 : MaskType, this_$7 : ref :: {#FactorialActor.getQ(Heap_$7,Mask_$7,this_$7)} ( (wf(Heap_$7,Mask_$7) && (CurrentModule == module#default)) ==> (#FactorialActor.getQ(Heap_$7,Mask_$7,this_$7) == Heap_$7[this_$7,FactorialActor.q]) ));
	assume (forall  Heap_$8 : HeapType, Mask_$8 : MaskType, this_$8 : ref :: {#FactorialActor.getQ(Heap_$8,Mask_$8,this_$8)} ( ((wf(Heap_$8,Mask_$8) && IsGoodState(combine(nostate,combine(Heap_$8[this_$8,FactorialActor.q],Heap_$8[Heap_$8[this_$8,FactorialActor.q],FactorialActorChannel.valid])))) && CanAssumeFunctionDefs) ==> (#FactorialActor.getQ(Heap_$8,Mask_$8,this_$8) == ##FactorialActor.getQ(combine(nostate,combine(Heap_$8[this_$8,FactorialActor.q],Heap_$8[Heap_$8[this_$8,FactorialActor.q],FactorialActorChannel.valid])),this_$8)) ));
	assume NonPredicateField(FactorialCont.q);
	assume NonPredicateField(FactorialCont.v);
	assume NonPredicateField(FactorialCont.vo);
	assume NonPredicateField(FactorialCont.cust);
	assume (forall  Heap_$9 : HeapType, Mask_$9 : MaskType, this_$9 : ref :: {#FactorialCont.getQ(Heap_$9,Mask_$9,this_$9)} ( (wf(Heap_$9,Mask_$9) && (CurrentModule == module#default)) ==> (#FactorialCont.getQ(Heap_$9,Mask_$9,this_$9) == Heap_$9[this_$9,FactorialCont.q]) ));
	assume (forall  Heap_$10 : HeapType, Mask_$10 : MaskType, this_$10 : ref :: {#FactorialCont.getQ(Heap_$10,Mask_$10,this_$10)} ( ((wf(Heap_$10,Mask_$10) && IsGoodState(combine(nostate,combine(Heap_$10[this_$10,FactorialCont.q],Heap_$10[Heap_$10[this_$10,FactorialCont.q],FactorialContChannel.valid])))) && CanAssumeFunctionDefs) ==> (#FactorialCont.getQ(Heap_$10,Mask_$10,this_$10) == ##FactorialCont.getQ(combine(nostate,combine(Heap_$10[this_$10,FactorialCont.q],Heap_$10[Heap_$10[this_$10,FactorialCont.q],FactorialContChannel.valid])),this_$10)) ));
	goto PreconditionGeneratedEntry;
$exit:
	assume false;
PreconditionGeneratedEntry:
	assume IsGoodMask(Mask);
	assume (this == null) || (dtype(this) == FactorialActor#t);
	assume (current#67 == null) || (dtype(current#67) == Message#t);
	assume (this#127 == null) || (dtype(this#127) == Channel#t);
	assume (msg#128 == null) || (dtype(msg#128) == Message#t);
	assume (this#129 == null) || (dtype(this#129) == FactorialActorChannelImpEP#t);
	assume (mi#130 == null) || (dtype(mi#130) == Message#t);
	assume (mo#131 == null) || (dtype(mo#131) == Message#t);
	assume (m#69 == null) || (dtype(m#69) == Message#t);
	assume (this#132 == null) || (dtype(this#132) == Message#t);
	assume true;
	assume (receiver#134 == null) || (dtype(receiver#134) == Future#t);
	assume (this#135 == null) || (dtype(this#135) == FutureChannelExpEP#t);
	assume (m#136 == null) || (dtype(m#136) == Message#t);
	assume (m#71 == null) || (dtype(m#71) == Message#t);
	assume (this#137 == null) || (dtype(this#137) == Message#t);
	assume true;
	assume (oldv#139 == null) || (dtype(oldv#139) == FactorialActor#t);
	assume (receiver#140 == null) || (dtype(receiver#140) == FactorialCont#t);
	assume (this#141 == null) || (dtype(this#141) == FactorialContChannelExpEP#t);
	assume (m#142 == null) || (dtype(m#142) == Message#t);
	assume (r#73 == null) || (dtype(r#73) == Message#t);
	assume (cont#75 == null) || (dtype(cont#75) == FactorialCont#t);
	assume (this#143 == null) || (dtype(this#143) == FactorialCont#t);
	assume true;
	assume true;
	assume (custp#146 == null) || (dtype(custp#146) == FactorialCont#t);
	assume (this#147 == null) || (dtype(this#147) == FactorialCont#t);
	assume (m#77 == null) || (dtype(m#77) == Message#t);
	assume (this#148 == null) || (dtype(this#148) == Message#t);
	assume true;
	assume true;
	assume (cust#151 == null) || (dtype(cust#151) == FactorialCont#t);
	assume (receiver#152 == null) || (dtype(receiver#152) == FactorialActor#t);
	assume (this#153 == null) || (dtype(this#153) == FactorialActorChannelExpEP#t);
	assume (m#154 == null) || (dtype(m#154) == Message#t);
	assume (r#79 == null) || (dtype(r#79) == Message#t);
	assume !(this == null);
	assume wf(Heap,Mask);
	goto anon0;
anon0:
	assume (0 < methodK#_1151) && ((1000 * methodK#_1151) < Fractions(1));
	assume CurrentModule == module#default;
	assume CanAssumeFunctionDefs;
	assume IsGoodInhaleState(inhaleHeap#_1153_$_0,Heap,ZeroMask);
	assume !(this == null);
	assume Heap_$_0 == Heap[this,FactorialActor.q := inhaleHeap#_1153_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_0,ZeroMask);
	assume (Heap_$_0[this,FactorialActor.q] == null) || (dtype(Heap_$_0[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_0 == ZeroMask[this,FactorialActor.q := ZeroMask[this,FactorialActor.q][perm$R := ZeroMask[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_0);
	assume IsGoodState(inhaleHeap#_1153_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_0,Mask_$_0);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_0);
	assume !(Heap_$_0[this,FactorialActor.q] == null);
	assume !(Heap_$_0[this,FactorialActor.q] == null);
	assume Heap_$_1 == Heap_$_0[Heap_$_0[this,FactorialActor.q],FactorialActorChannel.valid := inhaleHeap#_1153_$_0[Heap_$_0[this,FactorialActor.q],FactorialActorChannel.valid]];
	assume wf(Heap_$_1,Mask_$_0);
	assume inhaleHeap#_1153_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid] == Heap_$_1;
	assume Fractions(100) > 0;
	assume Mask_$_1 == Mask_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid := Mask_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid][perm$R := Mask_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_1);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.valid]);
	assume wf(Heap_$_1,Mask_$_1);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_1);
	assume !(Heap_$_1[this,FactorialActor.q] == null);
	assume Heap_$_2 == Heap_$_1[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.initImpState := inhaleHeap#_1153_$_0[Heap_$_1[this,FactorialActor.q],FactorialActorChannel.initImpState]];
	assume wf(Heap_$_2,Mask_$_1);
	assume inhaleHeap#_1153_$_0[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState] == Heap_$_2;
	assume Fractions(100) > 0;
	assume Mask_$_2 == Mask_$_1[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState := Mask_$_1[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R := Mask_$_1[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_2);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initImpState]);
	assume wf(Heap_$_2,Mask_$_2);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_2);
	assume !(Heap_$_2[this,FactorialActor.q] == null);
	assume Heap_$_3 == Heap_$_2[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initExpState := inhaleHeap#_1153_$_0[Heap_$_2[this,FactorialActor.q],FactorialActorChannel.initExpState]];
	assume wf(Heap_$_3,Mask_$_2);
	assume inhaleHeap#_1153_$_0[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState] == Heap_$_3;
	assume Fractions(100) > 0;
	assume Mask_$_3 == Mask_$_2[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState := Mask_$_2[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R := Mask_$_2[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_3);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.initExpState]);
	assume wf(Heap_$_3,Mask_$_3);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_3);
	assume !(Heap_$_3[this,FactorialActor.q] == null);
	assume Heap_$_4 == Heap_$_3[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1153_$_0[Heap_$_3[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_4,Mask_$_3);
	assume (Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_4 == Mask_$_3[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_3[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_3[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_4);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_4,Mask_$_4);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_4);
	assume !(Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_5 == Heap_$_4[Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1153_$_0[Heap_$_4[Heap_$_4[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_5,Mask_$_4);
	assume (Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_5 == Mask_$_4[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_4[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_4[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_5);
	assume IsGoodState(inhaleHeap#_1153_$_0[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_5,Mask_$_5);
	assume wf(inhaleHeap#_1153_$_0,Mask_$_5);
	assume !(Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Credits_$_0 == ZeroCredits[Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := ZeroCredits[Heap_$_5[Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_5);
	assume wf(Heap_$_5,Mask_$_5);
	assume Heap_$_5 == Heap;
	assume Mask_$_5 == Mask;
	assume Credits_$_0 == Credits;
	assume ((0 < unfoldK#_1154) && (unfoldK#_1154 < Fractions(1))) && ((1000 * unfoldK#_1154) < methodK#_1151);
	assert { :msg "  738.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  738.10: Location might not be readable." } true ==> CanRead(Mask_$_5,this,FactorialActor.q);
	assert { :msg "  738.3: The target of the fold statement might be null." } !(Heap_$_5[this,FactorialActor.q] == null);
	assert { :msg "  738.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  738.3: unfold might fail because the predicate FactorialActorChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.valid." } (Fractions(100) <= Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R]) && ((Fractions(100) == Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R]) ==> (0 <= Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$N]));
	assume exhaleMask#_1155_$_0 == Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid := Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R := Mask_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_5);
	assume wf(Heap_$_5,Mask_$_5);
	assume wf(Heap_$_5,exhaleMask#_1155_$_0);
	assume wf(Heap_$_5,exhaleMask#_1155_$_0);
	assume inhaleHeap#_1157_$_0 == Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.valid];
	assume IsGoodInhaleState(inhaleHeap#_1157_$_0,Heap_$_5,exhaleMask#_1155_$_0);
	assume !(Heap_$_5[this,FactorialActor.q] == null);
	assume Heap_$_6 == Heap_$_5[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1157_$_0[Heap_$_5[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_6,exhaleMask#_1155_$_0);
	assume (Heap_$_6[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_6[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_6 == exhaleMask#_1155_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1155_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1155_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_6);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_6,Mask_$_6);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_6);
	assume !(Heap_$_6[this,FactorialActor.q] == null);
	assume Heap_$_7 == Heap_$_6[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1157_$_0[Heap_$_6[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_7,Mask_$_6);
	assume (Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_7 == Mask_$_6[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_6[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_6[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_7);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_7,Mask_$_7);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_7);
	assume !(Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_8 == Heap_$_7[Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1157_$_0[Heap_$_7[Heap_$_7[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_8,Mask_$_7);
	assume (Heap_$_8[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_8[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_8 == Mask_$_7[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_7[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_7[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_8);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_8,Mask_$_8);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_8);
	assume !(Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_9 == Heap_$_8[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch := inhaleHeap#_1157_$_0[Heap_$_8[Heap_$_8[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch]];
	assume wf(Heap_$_9,Mask_$_8);
	assume (Heap_$_9[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch] == null) || (dtype(Heap_$_9[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_9 == Mask_$_8[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch := Mask_$_8[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch][perm$R := Mask_$_8[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_9);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch]);
	assume wf(Heap_$_9,Mask_$_9);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_9);
	assume !(Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume !(Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_10 == Heap_$_9[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid := inhaleHeap#_1157_$_0[Heap_$_9[Heap_$_9[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid]];
	assume wf(Heap_$_10,Mask_$_9);
	assume inhaleHeap#_1157_$_0[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid] == Heap_$_10;
	assume Fractions(100) > 0;
	assume Mask_$_10 == Mask_$_9[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid := Mask_$_9[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R := Mask_$_9[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_10);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid]);
	assume wf(Heap_$_10,Mask_$_10);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_10);
	assume !(Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_11 == Heap_$_10[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1157_$_0[Heap_$_10[Heap_$_10[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_11,Mask_$_10);
	assume inhaleHeap#_1157_$_0[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_11;
	assume Fractions(100) > 0;
	assume Mask_$_11 == Mask_$_10[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_10[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_10[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_11);
	assume IsGoodState(inhaleHeap#_1157_$_0[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_11,Mask_$_11);
	assume wf(inhaleHeap#_1157_$_0,Mask_$_11);
	assume Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == Heap_$_11[this,FactorialActor.q];
	assume Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.ch] == Heap_$_11[this,FactorialActor.q];
	assume IsGoodMask(Mask_$_11);
	assume wf(Heap_$_11,Mask_$_11);
	assume ((0 < unfoldK#_1158) && (unfoldK#_1158 < Fractions(1))) && ((1000 * unfoldK#_1158) < methodK#_1151);
	assert { :msg "  739.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  739.10: Location might not be readable." } true ==> CanRead(Mask_$_11,this,FactorialActor.q);
	assert { :msg "  739.10: Receiver might be null." } true ==> (!(Heap_$_11[this,FactorialActor.q] == null));
	assert { :msg "  739.10: Location might not be readable." } true ==> CanRead(Mask_$_11,Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  739.3: The target of the fold statement might be null." } !(Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  739.3: unfold might fail because the predicate FactorialActorChannelImpEP.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  739.3: unfold might fail because the predicate FactorialActorChannelImpEP.valid does not hold. Insufficient fraction at <undefined position> for FactorialActorChannelImpEP.valid." } (Fractions(100) <= Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R]) && ((Fractions(100) == Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R]) ==> (0 <= Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$N]));
	assume exhaleMask#_1159_$_0 == Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid := Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R := Mask_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_11);
	assume wf(Heap_$_11,Mask_$_11);
	assume wf(Heap_$_11,exhaleMask#_1159_$_0);
	assume wf(Heap_$_11,exhaleMask#_1159_$_0);
	assume inhaleHeap#_1161_$_0 == Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.valid];
	assume IsGoodInhaleState(inhaleHeap#_1161_$_0,Heap_$_11,exhaleMask#_1159_$_0);
	assume !(Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_12 == Heap_$_11[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1161_$_0[Heap_$_11[Heap_$_11[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_12,exhaleMask#_1159_$_0);
	assume (Heap_$_12[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_12[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_12 == exhaleMask#_1159_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := exhaleMask#_1159_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1159_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_12);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_12,Mask_$_12);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_12);
	assume !(Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_13 == Heap_$_12[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1161_$_0[Heap_$_12[Heap_$_12[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_13,Mask_$_12);
	assume (Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_13 == Mask_$_12[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_12[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_12[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_13);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_13,Mask_$_13);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_13);
	assume !(Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null);
	assume !(Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null);
	assume Heap_$_14 == Heap_$_13[Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp := inhaleHeap#_1161_$_0[Heap_$_13[Heap_$_13[Heap_$_13[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp]];
	assume wf(Heap_$_14,Mask_$_13);
	assume (Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp] == null) || (dtype(Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_14 == Mask_$_13[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp := Mask_$_13[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp][perm$R := Mask_$_13[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_14);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp]);
	assume wf(Heap_$_14,Mask_$_14);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_14);
	assume !(Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp] == null);
	assume !(Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null);
	assume Heap_$_15 == Heap_$_14[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp := inhaleHeap#_1161_$_0[Heap_$_14[Heap_$_14[Heap_$_14[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp]];
	assume wf(Heap_$_15,Mask_$_14);
	assume (Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp] == null) || (dtype(Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_15 == Mask_$_14[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp := Mask_$_14[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp][perm$R := Mask_$_14[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_15);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp]);
	assume wf(Heap_$_15,Mask_$_15);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_15);
	assume !(Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp] == null);
	assume !(Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp] == null);
	assume Heap_$_16 == Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1161_$_0[Heap_$_15[Heap_$_15[Heap_$_15[Heap_$_15[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_16,Mask_$_15);
	assume (Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_16 == Mask_$_15[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_15[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_15[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_16);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_16,Mask_$_16);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_16);
	assume !(Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume !(Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp] == null);
	assume Heap_$_17 == Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch := inhaleHeap#_1161_$_0[Heap_$_16[Heap_$_16[Heap_$_16[Heap_$_16[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch]];
	assume wf(Heap_$_17,Mask_$_16);
	assume (Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch] == null) || (dtype(Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_17 == Mask_$_16[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch := Mask_$_16[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch][perm$R := Mask_$_16[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_17);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch]);
	assume wf(Heap_$_17,Mask_$_17);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_17);
	assume !(Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch] == null);
	assume !(Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_18 == Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1161_$_0[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[Heap_$_17[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_18,Mask_$_17);
	assume true;
	assume monitorK > 0;
	assume Mask_$_18 == Mask_$_17[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_17[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_17[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_18);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_18,Mask_$_18);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_18);
	assume !(Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch] == null);
	assume Heap_$_19 == Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu := inhaleHeap#_1161_$_0[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[Heap_$_18[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu]];
	assume wf(Heap_$_19,Mask_$_18);
	assume true;
	assume monitorK > 0;
	assume Mask_$_19 == Mask_$_18[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu := Mask_$_18[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu][perm$R := Mask_$_18[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_19);
	assume IsGoodState(inhaleHeap#_1161_$_0[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch],FactorialActorChannel.exp],FactorialActorChannelExpEP.expch],mu]);
	assume wf(Heap_$_19,Mask_$_19);
	assume wf(inhaleHeap#_1161_$_0,Mask_$_19);
	assume IsGoodMask(Mask_$_19);
	assume wf(Heap_$_19,Mask_$_19);
	assume ((0 < unfoldK#_1162) && (unfoldK#_1162 < Fractions(1))) && ((1000 * unfoldK#_1162) < methodK#_1151);
	assert { :msg "  740.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  740.10: Location might not be readable." } true ==> CanRead(Mask_$_19,this,FactorialActor.q);
	assert { :msg "  740.3: The target of the fold statement might be null." } !(Heap_$_19[this,FactorialActor.q] == null);
	assert { :msg "  740.3: unfold might fail because the predicate FactorialActorChannel.initImpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  740.3: unfold might fail because the predicate FactorialActorChannel.initImpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initImpState." } (Fractions(100) <= Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R]) && ((Fractions(100) == Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R]) ==> (0 <= Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$N]));
	assume exhaleMask#_1163_$_0 == Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState := Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R := Mask_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_19);
	assume wf(Heap_$_19,Mask_$_19);
	assume wf(Heap_$_19,exhaleMask#_1163_$_0);
	assume wf(Heap_$_19,exhaleMask#_1163_$_0);
	assume inhaleHeap#_1165_$_0 == Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.initImpState];
	assume IsGoodInhaleState(inhaleHeap#_1165_$_0,Heap_$_19,exhaleMask#_1163_$_0);
	assume !(Heap_$_19[this,FactorialActor.q] == null);
	assume Heap_$_20 == Heap_$_19[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1165_$_0[Heap_$_19[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_20,exhaleMask#_1163_$_0);
	assume (Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_20 == exhaleMask#_1163_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1163_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1163_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_20);
	assume IsGoodState(inhaleHeap#_1165_$_0[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_20,Mask_$_20);
	assume wf(inhaleHeap#_1165_$_0,Mask_$_20);
	assume !(Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_21 == Heap_$_20[Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1165_$_0[Heap_$_20[Heap_$_20[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_21,Mask_$_20);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_21 == Mask_$_20[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_20[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_20[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_21);
	assume IsGoodState(inhaleHeap#_1165_$_0[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_21,Mask_$_21);
	assume wf(inhaleHeap#_1165_$_0,Mask_$_21);
	assume Heap_$_21[Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume IsGoodMask(Mask_$_21);
	assume wf(Heap_$_21,Mask_$_21);
	assume ((0 < unfoldK#_1166) && (unfoldK#_1166 < Fractions(1))) && ((1000 * unfoldK#_1166) < methodK#_1151);
	assert { :msg "  741.10: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  741.10: Location might not be readable." } true ==> CanRead(Mask_$_21,this,FactorialActor.q);
	assert { :msg "  741.3: The target of the fold statement might be null." } !(Heap_$_21[this,FactorialActor.q] == null);
	assert { :msg "  741.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  741.3: unfold might fail because the predicate FactorialActorChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialActorChannel.initExpState." } (Fractions(100) <= Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R]) && ((Fractions(100) == Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R]) ==> (0 <= Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$N]));
	assume exhaleMask#_1167_$_0 == Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState := Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R := Mask_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_21);
	assume wf(Heap_$_21,Mask_$_21);
	assume wf(Heap_$_21,exhaleMask#_1167_$_0);
	assume wf(Heap_$_21,exhaleMask#_1167_$_0);
	assume inhaleHeap#_1169_$_0 == Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.initExpState];
	assume IsGoodInhaleState(inhaleHeap#_1169_$_0,Heap_$_21,exhaleMask#_1167_$_0);
	assume !(Heap_$_21[this,FactorialActor.q] == null);
	assume Heap_$_22 == Heap_$_21[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1169_$_0[Heap_$_21[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_22,exhaleMask#_1167_$_0);
	assume (Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_22 == exhaleMask#_1167_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp := exhaleMask#_1167_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := exhaleMask#_1167_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_22);
	assume IsGoodState(inhaleHeap#_1169_$_0[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_22,Mask_$_22);
	assume wf(inhaleHeap#_1169_$_0,Mask_$_22);
	assume !(Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_23 == Heap_$_22[Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1169_$_0[Heap_$_22[Heap_$_22[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_23,Mask_$_22);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_23 == Mask_$_22[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_22[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_22[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume IsGoodState(inhaleHeap#_1169_$_0[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(inhaleHeap#_1169_$_0,Mask_$_23);
	assume Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume ((0 < whileK#_1176) && ((1000 * whileK#_1176) < Fractions(1))) && ((1000 * whileK#_1176) < methodK#_1151);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The expression at 743.27 might not evaluate to true." } !(Heap_$_23[this,FactorialActor.q] == null);
	assert { :msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.13 might not evaluate to true." } Heap_$_23[this,FactorialActor.q] == Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assert { :msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.28 might not evaluate to true." } !(Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  744.13: The loop invariant might not hold on entry to the loop. The expression at 744.43 might not evaluate to true." } !(Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. The expression at 745.31 might not evaluate to true." } !(Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  746.13: The loop invariant might not hold on entry to the loop. The expression at 746.33 might not evaluate to true." } Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  747.13: The loop invariant might not hold on entry to the loop. The expression at 747.33 might not evaluate to true." } Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_1 == Credits_$_0[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_0[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] - 1];
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.13 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.13 for FactorialActor.q." } (monitorK <= Mask_$_23[this,FactorialActor.q][perm$R]) && ((monitorK == Mask_$_23[this,FactorialActor.q][perm$R]) ==> (0 <= Mask_$_23[this,FactorialActor.q][perm$N]));
	assume exhaleMask#_1177_$_0 == Mask_$_23[this,FactorialActor.q := Mask_$_23[this,FactorialActor.q][perm$R := Mask_$_23[this,FactorialActor.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_0);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.38 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.38 for FactorialActorChannel.imp." } (monitorK <= exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$N]));
	assume exhaleMask#_1177_$_1 == exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1177_$_0[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_1);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.56 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.56 for FactorialActorChannelImpEP.impch." } (monitorK <= exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1177_$_2 == exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1177_$_1[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_2);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.80 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.80 for mu." } (monitorK <= exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) && ((monitorK == exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) ==> (0 <= exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$N]));
	assume exhaleMask#_1177_$_3 == exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := exhaleMask#_1177_$_2[Heap_$_23[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_3);
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. The permission at 743.107 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 743.107 for FactorialActorChannelImpEP.ch." } (monitorK <= exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$N]));
	assume exhaleMask#_1177_$_4 == exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1177_$_3[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_4);
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. The permission at 745.13 might not be positive." } monitorK > 0;
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 745.13 for FactorialActorChannel.exp." } (monitorK <= exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$N]));
	assume exhaleMask#_1177_$_5 == exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp := exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := exhaleMask#_1177_$_4[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_5);
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. The permission at 745.46 might not be positive." } Fractions(100) > 0;
	assert { :msg "  745.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 745.46 for FactorialActorChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1177_$_6 == exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1177_$_5[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_6);
	assert { :msg "  746.13: The loop invariant might not hold on entry to the loop. The permission at 746.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  746.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 746.13 for FactorialActorChannelExpEP.state." } (Fractions(100) <= exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$N]));
	assume exhaleMask#_1177_$_7 == exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1177_$_6[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_7);
	assert { :msg "  747.13: The loop invariant might not hold on entry to the loop. The permission at 747.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  747.13: The loop invariant might not hold on entry to the loop. Insufficient fraction at 747.13 for FactorialActorChannelImpEP.state." } (Fractions(100) <= exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$N]));
	assume exhaleMask#_1177_$_8 == exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1177_$_7[Heap_$_23[Heap_$_23[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_23);
	assume wf(Heap_$_23,Mask_$_23);
	assume wf(Heap_$_23,exhaleMask#_1177_$_8);
	assume wf(Heap_$_23,exhaleMask#_1177_$_8);
	assert { :msg "  742.3: Loop invariant must consume all debt on entry to the loop." } (forall  ch : ref :: ( (ch == null) || (0 <= Credits_$_1[ch]) ));
	assert { :msg "  742.3: Method execution before loop might lock/unlock more than allowed by lockchange clause of loop." } (forall  lk#_1187 : ref :: {Heap_$_23[lk#_1187,held]} {Heap_$_23[lk#_1187,rdheld]} ( (((0 < Heap_$_23[lk#_1187,held]) <==> (0 < Heap[lk#_1187,held])) && (Heap_$_23[lk#_1187,rdheld] <==> Heap[lk#_1187,rdheld])) || false ));
	if ($_$_condition) { goto $cascade_0_$1_$0; } else { goto anon73_Then; }
$cascade_0_$1_$0:
	if ($_$_condition_$0) { goto anon74_Then; } else { goto anon74_Else; }
anon73_Then:
	assume IsGoodInhaleState(inhaleHeap#_1188_$_0,Heap_$_24,ZeroMask);
	assume !(this == null);
	assume Heap_$_25 == Heap_$_24[this,FactorialActor.q := inhaleHeap#_1188_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_25,ZeroMask);
	assume (Heap_$_25[this,FactorialActor.q] == null) || (dtype(Heap_$_25[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_24 == ZeroMask[this,FactorialActor.q := ZeroMask[this,FactorialActor.q][perm$R := ZeroMask[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_24);
	assume IsGoodState(inhaleHeap#_1188_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_25,Mask_$_24);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_24);
	assert { :msg "  743.27: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.27: Location might not be readable." } true ==> CanRead(Mask_$_24,this,FactorialActor.q);
	assume !(Heap_$_25[this,FactorialActor.q] == null);
	assert { :msg "  743.41: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.41: Location might not be readable." } true ==> CanRead(Mask_$_24,this,FactorialActor.q);
	assume !(Heap_$_25[this,FactorialActor.q] == null);
	assume Heap_$_26 == Heap_$_25[Heap_$_25[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1188_$_0[Heap_$_25[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_26,Mask_$_24);
	assume (Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_25 == Mask_$_24[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_24[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_24[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_25);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_26,Mask_$_25);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_25);
	assert { :msg "  743.59: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.59: Location might not be readable." } true ==> CanRead(Mask_$_25,this,FactorialActor.q);
	assert { :msg "  743.59: Receiver might be null." } true ==> (!(Heap_$_26[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_25,Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_27 == Heap_$_26[Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1188_$_0[Heap_$_26[Heap_$_26[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_27,Mask_$_25);
	assume (Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_26 == Mask_$_25[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_25[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_25[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_26);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_27,Mask_$_26);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_26);
	assert { :msg "  743.83: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.83: Location might not be readable." } true ==> CanRead(Mask_$_26,this,FactorialActor.q);
	assert { :msg "  743.83: Receiver might be null." } true ==> (!(Heap_$_27[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_26,Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_26,Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assume !(Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_28 == Heap_$_27[Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1188_$_0[Heap_$_27[Heap_$_27[Heap_$_27[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_28,Mask_$_26);
	assume true;
	assume monitorK > 0;
	assume Mask_$_27 == Mask_$_26[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_26[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_26[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_27);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_28,Mask_$_27);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_27);
	assert { :msg "  743.110: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  743.110: Location might not be readable." } true ==> CanRead(Mask_$_27,this,FactorialActor.q);
	assert { :msg "  743.110: Receiver might be null." } true ==> (!(Heap_$_28[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_27,Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_29 == Heap_$_28[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1188_$_0[Heap_$_28[Heap_$_28[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_29,Mask_$_27);
	assume (Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_28 == Mask_$_27[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_27[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_27[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_28);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_29,Mask_$_28);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_28);
	assert { :msg "  744.13: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.13: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.16: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.16: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.16: Receiver might be null." } true ==> (!(Heap_$_29[this,FactorialActor.q] == null));
	assert { :msg "  744.16: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  744.16: Receiver might be null." } true ==> (!(Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  744.16: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch);
	assume Heap_$_29[this,FactorialActor.q] == Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assert { :msg "  744.28: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.28: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.28: Receiver might be null." } true ==> (!(Heap_$_29[this,FactorialActor.q] == null));
	assert { :msg "  744.28: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  744.43: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  744.43: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assert { :msg "  744.43: Receiver might be null." } true ==> (!(Heap_$_29[this,FactorialActor.q] == null));
	assert { :msg "  744.43: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  744.43: Receiver might be null." } true ==> (!(Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  744.43: Location might not be readable." } true ==> CanRead(Mask_$_28,Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assume !(Heap_$_29[Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  745.16: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.16: Location might not be readable." } true ==> CanRead(Mask_$_28,this,FactorialActor.q);
	assume !(Heap_$_29[this,FactorialActor.q] == null);
	assume Heap_$_30 == Heap_$_29[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1188_$_0[Heap_$_29[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_30,Mask_$_28);
	assume (Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_29 == Mask_$_28[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_28[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_28[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_29);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_30,Mask_$_29);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_29);
	assert { :msg "  745.31: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.31: Location might not be readable." } true ==> CanRead(Mask_$_29,this,FactorialActor.q);
	assert { :msg "  745.31: Receiver might be null." } true ==> (!(Heap_$_30[this,FactorialActor.q] == null));
	assert { :msg "  745.31: Location might not be readable." } true ==> CanRead(Mask_$_29,Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp);
	assume !(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,this,FactorialActor.q);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(Heap_$_30[this,FactorialActor.q] == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp);
	assert { :msg "  745.46: Receiver might be null." } !(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,this,FactorialActor.q);
	assert { :msg "  745.46: Receiver might be null." } true ==> (!(Heap_$_30[this,FactorialActor.q] == null));
	assert { :msg "  745.46: Location might not be readable." } true ==> CanRead(Mask_$_29,Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp);
	assume !(Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_31 == Heap_$_30[Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1188_$_0[Heap_$_30[Heap_$_30[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_31,Mask_$_29);
	assume inhaleHeap#_1188_$_0[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_31;
	assume Fractions(100) > 0;
	assume Mask_$_30 == Mask_$_29[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_29[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_29[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_30);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_31,Mask_$_30);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_30);
	assert { :msg "  746.17: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  746.17: Location might not be readable." } true ==> CanRead(Mask_$_30,this,FactorialActor.q);
	assert { :msg "  746.17: Receiver might be null." } true ==> (!(Heap_$_31[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_30,Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp);
	assume !(Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_32 == Heap_$_31[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1188_$_0[Heap_$_31[Heap_$_31[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_32,Mask_$_30);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_31 == Mask_$_30[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_30[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_30[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_31);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_32,Mask_$_31);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_31);
	assert { :msg "  746.33: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  746.33: Location might not be readable." } true ==> CanRead(Mask_$_31,this,FactorialActor.q);
	assert { :msg "  746.33: Receiver might be null." } true ==> (!(Heap_$_32[this,FactorialActor.q] == null));
	assert { :msg "  746.33: Location might not be readable." } true ==> CanRead(Mask_$_31,Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp);
	assert { :msg "  746.33: Receiver might be null." } true ==> (!(Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp] == null));
	assert { :msg "  746.33: Location might not be readable." } true ==> CanRead(Mask_$_31,Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state);
	assume Heap_$_32[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  747.17: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  747.17: Location might not be readable." } true ==> CanRead(Mask_$_31,this,FactorialActor.q);
	assert { :msg "  747.17: Receiver might be null." } true ==> (!(Heap_$_32[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_31,Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp);
	assume !(Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_33 == Heap_$_32[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1188_$_0[Heap_$_32[Heap_$_32[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_33,Mask_$_31);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_32 == Mask_$_31[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_31[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_31[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_32);
	assume IsGoodState(inhaleHeap#_1188_$_0[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_33,Mask_$_32);
	assume wf(inhaleHeap#_1188_$_0,Mask_$_32);
	assert { :msg "  747.33: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  747.33: Location might not be readable." } true ==> CanRead(Mask_$_32,this,FactorialActor.q);
	assert { :msg "  747.33: Receiver might be null." } true ==> (!(Heap_$_33[this,FactorialActor.q] == null));
	assert { :msg "  747.33: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  747.33: Receiver might be null." } true ==> (!(Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  747.33: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state);
	assume Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assert { :msg "  748.20: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  748.20: Location might not be readable." } true ==> CanRead(Mask_$_32,this,FactorialActor.q);
	assert { :msg "  748.20: Receiver might be null." } true ==> (!(Heap_$_33[this,FactorialActor.q] == null));
	assert { :msg "  748.20: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  748.20: Receiver might be null." } true ==> (!(Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  748.20: Location might not be readable." } true ==> CanRead(Mask_$_32,Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assert { :msg "  748.20: The target of the credit predicate might be null." } !(Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Credits_$_2 == ZeroCredits[Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := ZeroCredits[Heap_$_33[Heap_$_33[Heap_$_33[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_32);
	assume wf(Heap_$_33,Mask_$_32);
	assume false;
	goto $exit;
anon74_Then:
	assume IsGoodInhaleState(inhaleHeap#_1189_$_0,Heap_$_34,ZeroMask);
	assume !(this == null);
	assume Heap_$_35 == Heap_$_34[this,FactorialActor.q := inhaleHeap#_1189_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_35,ZeroMask);
	assume (Heap_$_35[this,FactorialActor.q] == null) || (dtype(Heap_$_35[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_33 == ZeroMask[this,FactorialActor.q := ZeroMask[this,FactorialActor.q][perm$R := ZeroMask[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_33);
	assume IsGoodState(inhaleHeap#_1189_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_35,Mask_$_33);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_33);
	assume !(Heap_$_35[this,FactorialActor.q] == null);
	assume !(Heap_$_35[this,FactorialActor.q] == null);
	assume Heap_$_36 == Heap_$_35[Heap_$_35[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1189_$_0[Heap_$_35[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_36,Mask_$_33);
	assume (Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_34 == Mask_$_33[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_33[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_33[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_34);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_36,Mask_$_34);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_34);
	assume !(Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_37 == Heap_$_36[Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1189_$_0[Heap_$_36[Heap_$_36[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_37,Mask_$_34);
	assume (Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_35 == Mask_$_34[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_34[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_34[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_35);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_37,Mask_$_35);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_35);
	assume !(Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_38 == Heap_$_37[Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1189_$_0[Heap_$_37[Heap_$_37[Heap_$_37[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_38,Mask_$_35);
	assume true;
	assume monitorK > 0;
	assume Mask_$_36 == Mask_$_35[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_35[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_35[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_36);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_38,Mask_$_36);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_36);
	assume !(Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_39 == Heap_$_38[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1189_$_0[Heap_$_38[Heap_$_38[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_39,Mask_$_36);
	assume (Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_37 == Mask_$_36[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_36[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_36[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_37);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_39,Mask_$_37);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_37);
	assume Heap_$_39[this,FactorialActor.q] == Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assume !(Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_39[Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume !(Heap_$_39[this,FactorialActor.q] == null);
	assume Heap_$_40 == Heap_$_39[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1189_$_0[Heap_$_39[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_40,Mask_$_37);
	assume (Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_38 == Mask_$_37[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_37[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_37[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_38);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_40,Mask_$_38);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_38);
	assume !(Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume !(Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_41 == Heap_$_40[Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1189_$_0[Heap_$_40[Heap_$_40[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_41,Mask_$_38);
	assume inhaleHeap#_1189_$_0[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_41;
	assume Fractions(100) > 0;
	assume Mask_$_39 == Mask_$_38[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_38[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_38[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_39);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_41,Mask_$_39);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_39);
	assume !(Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_42 == Heap_$_41[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1189_$_0[Heap_$_41[Heap_$_41[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_42,Mask_$_39);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_40 == Mask_$_39[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_39[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_39[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_40);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_42,Mask_$_40);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_40);
	assume Heap_$_42[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assume !(Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_43 == Heap_$_42[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1189_$_0[Heap_$_42[Heap_$_42[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_43,Mask_$_40);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_41 == Mask_$_40[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_40[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_40[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_41);
	assume IsGoodState(inhaleHeap#_1189_$_0[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_43,Mask_$_41);
	assume wf(inhaleHeap#_1189_$_0,Mask_$_41);
	assume Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_3 == ZeroCredits[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := ZeroCredits[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_41);
	assume wf(Heap_$_43,Mask_$_41);
	assume (forall  lk#_1190 : ref :: {Heap_$_43[lk#_1190,held]} {Heap_$_43[lk#_1190,rdheld]} ( (((0 < Heap_$_43[lk#_1190,held]) <==> (0 < Heap[lk#_1190,held])) && (Heap_$_43[lk#_1190,rdheld] <==> Heap[lk#_1190,rdheld])) || false ));
	assume true;
	assert { :msg "  751.21: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  751.21: Location might not be readable." } true ==> CanRead(Mask_$_41,this,FactorialActor.q);
	assert { :msg "  751.21: Receiver might be null." } true ==> (!(Heap_$_43[this,FactorialActor.q] == null));
	assert { :msg "  751.21: Location might not be readable." } true ==> CanRead(Mask_$_41,Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  751.21: Receiver might be null." } true ==> (!(Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp] == null));
	assert { :msg "  751.21: Location might not be readable." } true ==> CanRead(Mask_$_41,Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch);
	assert { :msg "  751.21: The channel might be null." } !(Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  751.4: receive operation requires a credit" } 0 < Credits_$_3[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assert { :msg "  751.4: The mu field of the channel in the receive statement might not be readable." } CanRead(Mask_$_41,Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu);
	assert { :msg "  751.4: The channel must lie above waitlevel in the wait order" } (forall  o#_1191 : ref :: ( (((0 < Heap_$_43[o#_1191,held]) || Heap_$_43[o#_1191,rdheld]) || (Credits_$_3[o#_1191] < 0)) ==> MuBelow(Heap_$_43[o#_1191,mu],Heap_$_43[Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]) ));
	assume this#127_$_0 == Heap_$_43[Heap_$_43[Heap_$_43[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch];
	assume (msg#128_$_0 == null) || (dtype(msg#128_$_0) == Message#t);
	assume IsGoodInhaleState(inhaleHeap#_1192_$_0,Heap_$_43,Mask_$_41);
	assume !(msg#128_$_0 == null);
	assume !(msg#128_$_0 == null);
	assume Heap_$_44 == Heap_$_43[msg#128_$_0,Message.type := inhaleHeap#_1192_$_0[msg#128_$_0,Message.type]];
	assume wf(Heap_$_44,Mask_$_41);
	assume true;
	assume channelK > 0;
	assume Mask_$_42 == Mask_$_41[msg#128_$_0,Message.type := Mask_$_41[msg#128_$_0,Message.type][perm$R := Mask_$_41[msg#128_$_0,Message.type][perm$R] + channelK]];
	assume IsGoodMask(Mask_$_42);
	assume IsGoodState(inhaleHeap#_1192_$_0[msg#128_$_0,Message.type]);
	assume wf(Heap_$_44,Mask_$_42);
	assume wf(inhaleHeap#_1192_$_0,Mask_$_42);
	assume !(msg#128_$_0 == null);
	assume Heap_$_45 == Heap_$_44[msg#128_$_0,Message.inv := inhaleHeap#_1192_$_0[msg#128_$_0,Message.inv]];
	assume wf(Heap_$_45,Mask_$_42);
	assume inhaleHeap#_1192_$_0[msg#128_$_0,Message.inv] == Heap_$_45;
	assume Fractions(100) > 0;
	assume Mask_$_43 == Mask_$_42[msg#128_$_0,Message.inv := Mask_$_42[msg#128_$_0,Message.inv][perm$R := Mask_$_42[msg#128_$_0,Message.inv][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_43);
	assume IsGoodState(inhaleHeap#_1192_$_0[msg#128_$_0,Message.inv]);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(inhaleHeap#_1192_$_0,Mask_$_43);
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume Credits_$_4 == Credits_$_3[Heap_$_45[Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_3[Heap_$_45[Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] - 1];
	assert { :msg "  752.7: Receiver might be null." } true ==> (!(msg#128_$_0 == null));
	assert { :msg "  752.7: Location might not be readable." } true ==> CanRead(Mask_$_43,msg#128_$_0,Message.type);
	if ($_$_condition_$1) { goto anon75_Then; } else { goto anon75_Else; }
anon74_Else:
	assume (forall  lk#_1433 : ref :: {Heap_$_23[lk#_1433,held]} {Heap_$_23[lk#_1433,rdheld]} ( (((0 < Heap_$_23[lk#_1433,held]) <==> (0 < Heap[lk#_1433,held])) && (Heap_$_23[lk#_1433,rdheld] <==> Heap[lk#_1433,rdheld])) || false ));
	assume IsGoodInhaleState(inhaleHeap#_1434_$_0,Heap_$_23,exhaleMask#_1177_$_8);
	assume !(this == null);
	assume Heap_$_46 == Heap_$_23[this,FactorialActor.q := inhaleHeap#_1434_$_0[this,FactorialActor.q]];
	assume wf(Heap_$_46,exhaleMask#_1177_$_8);
	assume (Heap_$_46[this,FactorialActor.q] == null) || (dtype(Heap_$_46[this,FactorialActor.q]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_44 == exhaleMask#_1177_$_8[this,FactorialActor.q := exhaleMask#_1177_$_8[this,FactorialActor.q][perm$R := exhaleMask#_1177_$_8[this,FactorialActor.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_44);
	assume IsGoodState(inhaleHeap#_1434_$_0[this,FactorialActor.q]);
	assume wf(Heap_$_46,Mask_$_44);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_44);
	assume !(Heap_$_46[this,FactorialActor.q] == null);
	assume !(Heap_$_46[this,FactorialActor.q] == null);
	assume Heap_$_47 == Heap_$_46[Heap_$_46[this,FactorialActor.q],FactorialActorChannel.imp := inhaleHeap#_1434_$_0[Heap_$_46[this,FactorialActor.q],FactorialActorChannel.imp]];
	assume wf(Heap_$_47,Mask_$_44);
	assume (Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp] == null) || (dtype(Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp]) == FactorialActorChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_45 == Mask_$_44[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp := Mask_$_44[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := Mask_$_44[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_45);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp]);
	assume wf(Heap_$_47,Mask_$_45);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_45);
	assume !(Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_48 == Heap_$_47[Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := inhaleHeap#_1434_$_0[Heap_$_47[Heap_$_47[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]];
	assume wf(Heap_$_48,Mask_$_45);
	assume (Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null) || (dtype(Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_46 == Mask_$_45[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := Mask_$_45[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := Mask_$_45[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_46);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]);
	assume wf(Heap_$_48,Mask_$_46);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_46);
	assume !(Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume Heap_$_49 == Heap_$_48[Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := inhaleHeap#_1434_$_0[Heap_$_48[Heap_$_48[Heap_$_48[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]];
	assume wf(Heap_$_49,Mask_$_46);
	assume true;
	assume monitorK > 0;
	assume Mask_$_47 == Mask_$_46[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := Mask_$_46[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := Mask_$_46[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_47);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu]);
	assume wf(Heap_$_49,Mask_$_47);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_47);
	assume !(Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_50 == Heap_$_49[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := inhaleHeap#_1434_$_0[Heap_$_49[Heap_$_49[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]];
	assume wf(Heap_$_50,Mask_$_47);
	assume (Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch] == null) || (dtype(Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]) == FactorialActorChannel#t);
	assume monitorK > 0;
	assume Mask_$_48 == Mask_$_47[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := Mask_$_47[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := Mask_$_47[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_48);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch]);
	assume wf(Heap_$_50,Mask_$_48);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_48);
	assume Heap_$_50[this,FactorialActor.q] == Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assume !(Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume !(Heap_$_50[Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assume !(Heap_$_50[this,FactorialActor.q] == null);
	assume Heap_$_51 == Heap_$_50[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.exp := inhaleHeap#_1434_$_0[Heap_$_50[this,FactorialActor.q],FactorialActorChannel.exp]];
	assume wf(Heap_$_51,Mask_$_48);
	assume (Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp] == null) || (dtype(Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp]) == FactorialActorChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_49 == Mask_$_48[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp := Mask_$_48[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := Mask_$_48[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_49);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp]);
	assume wf(Heap_$_51,Mask_$_49);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_49);
	assume !(Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume !(Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_52 == Heap_$_51[Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := inhaleHeap#_1434_$_0[Heap_$_51[Heap_$_51[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_52,Mask_$_49);
	assume inhaleHeap#_1434_$_0[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid] == Heap_$_52;
	assume Fractions(100) > 0;
	assume Mask_$_50 == Mask_$_49[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := Mask_$_49[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := Mask_$_49[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_50);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_52,Mask_$_50);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_50);
	assume !(Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume Heap_$_53 == Heap_$_52[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := inhaleHeap#_1434_$_0[Heap_$_52[Heap_$_52[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_53,Mask_$_50);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_51 == Mask_$_50[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := Mask_$_50[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := Mask_$_50[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_51);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_53,Mask_$_51);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_51);
	assume Heap_$_53[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assume !(Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume Heap_$_54 == Heap_$_53[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := inhaleHeap#_1434_$_0[Heap_$_53[Heap_$_53[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_54,Mask_$_51);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_52 == Mask_$_51[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := Mask_$_51[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := Mask_$_51[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_52);
	assume IsGoodState(inhaleHeap#_1434_$_0[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_54,Mask_$_52);
	assume wf(inhaleHeap#_1434_$_0,Mask_$_52);
	assume Heap_$_54[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_5 == Credits_$_1[Heap_$_54[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_1[Heap_$_54[Heap_$_54[Heap_$_54[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] + 1];
	assume IsGoodMask(Mask_$_52);
	assume wf(Heap_$_54,Mask_$_52);
	assume !true;
	assert { :msg "  734.2: Method might lock/unlock more than allowed." } (forall  lk#_1435 : ref :: {Heap_$_54[lk#_1435,held]} {Heap_$_54[lk#_1435,rdheld]} ( (((0 < Heap_$_54[lk#_1435,held]) <==> (0 < Heap[lk#_1435,held])) && (Heap_$_54[lk#_1435,rdheld] <==> Heap[lk#_1435,rdheld])) || false ));
	assert { :msg "  734.2: Method body is not allowed to leave any debt." } (forall  ch_$0 : ref :: ( (ch_$0 == null) || (0 <= Credits_$_5[ch_$0]) ));
	goto $exit;
anon75_Then:
	assume Heap_$_45[msg#128_$_0,Message.type] == 1;
	assume ((0 < methodCallK#_1196) && ((1000 * methodCallK#_1196) < Fractions(1))) && ((1000 * methodCallK#_1196) < whileK#_1176);
	assert { :msg "  753.19: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  753.19: Location might not be readable." } true ==> CanRead(Mask_$_43,this,FactorialActor.q);
	assert { :msg "  753.19: Receiver might be null." } true ==> (!(Heap_$_45[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_43,Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp);
	assert { :msg "  753.5: The target of the method call might be null." } !(Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assume this#129_$_0 == Heap_$_45[Heap_$_45[this,FactorialActor.q],FactorialActorChannel.imp];
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The expression at 95.25 might not evaluate to true." } !(msg#128_$_0 == null);
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The expression at 95.57 might not evaluate to true." } Heap_$_45[msg#128_$_0,Message.type] == 1;
	assert { :msg "  753.5: The precondition at 96.11 might not hold. The expression at 96.11 might not evaluate to true." } Heap_$_45[this#129_$_0,FactorialActorChannelImpEP.state] == 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.11 for FactorialActorChannelImpEP.state." } (Fractions(100) <= Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$N]));
	assume exhaleMask#_1197_$_0 == Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state := Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R := Mask_$_43[this#129_$_0,FactorialActorChannelImpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(Heap_$_45,exhaleMask#_1197_$_0);
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.37 might not be positive." } monitorK > 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.37 for Message.type." } (monitorK <= exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$N]));
	assume exhaleMask#_1197_$_1 == exhaleMask#_1197_$_0[msg#128_$_0,Message.type := exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R := exhaleMask#_1197_$_0[msg#128_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(Heap_$_45,exhaleMask#_1197_$_1);
	assert { :msg "  753.5: The precondition at 95.11 might not hold. The permission at 95.71 might not be positive." } Fractions(100) > 0;
	assert { :msg "  753.5: The precondition at 95.11 might not hold. Insufficient fraction at 95.71 for Message.inv." } (Fractions(100) <= exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R]) && ((Fractions(100) == exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R]) ==> (0 <= exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$N]));
	assume exhaleMask#_1197_$_2 == exhaleMask#_1197_$_1[msg#128_$_0,Message.inv := exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R := exhaleMask#_1197_$_1[msg#128_$_0,Message.inv][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_43);
	assume wf(Heap_$_45,Mask_$_43);
	assume wf(Heap_$_45,exhaleMask#_1197_$_2);
	assume wf(Heap_$_45,exhaleMask#_1197_$_2);
	assume (mo#131_$_0 == null) || (dtype(mo#131_$_0) == Message#t);
	assume IsGoodInhaleState(inhaleHeap#_1203_$_0,Heap_$_45,exhaleMask#_1197_$_2);
	assume !(this#129_$_0 == null);
	assume Heap_$_55 == Heap_$_45[this#129_$_0,FactorialActorChannelImpEP.state := inhaleHeap#_1203_$_0[this#129_$_0,FactorialActorChannelImpEP.state]];
	assume wf(Heap_$_55,exhaleMask#_1197_$_2);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_53 == exhaleMask#_1197_$_2[this#129_$_0,FactorialActorChannelImpEP.state := exhaleMask#_1197_$_2[this#129_$_0,FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1197_$_2[this#129_$_0,FactorialActorChannelImpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_53);
	assume IsGoodState(inhaleHeap#_1203_$_0[this#129_$_0,FactorialActorChannelImpEP.state]);
	assume wf(Heap_$_55,Mask_$_53);
	assume wf(inhaleHeap#_1203_$_0,Mask_$_53);
	assume Heap_$_55[this#129_$_0,FactorialActorChannelImpEP.state] == 0;
	assume !(mo#131_$_0 == null);
	assume Heap_$_56 == Heap_$_55[mo#131_$_0,Message.type := inhaleHeap#_1203_$_0[mo#131_$_0,Message.type]];
	assume wf(Heap_$_56,Mask_$_53);
	assume true;
	assume monitorK > 0;
	assume Mask_$_54 == Mask_$_53[mo#131_$_0,Message.type := Mask_$_53[mo#131_$_0,Message.type][perm$R := Mask_$_53[mo#131_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_54);
	assume IsGoodState(inhaleHeap#_1203_$_0[mo#131_$_0,Message.type]);
	assume wf(Heap_$_56,Mask_$_54);
	assume wf(inhaleHeap#_1203_$_0,Mask_$_54);
	assume Heap_$_56[mo#131_$_0,Message.type] == 1;
	assume msg#128_$_0 == mo#131_$_0;
	assume !(mo#131_$_0 == null);
	assume Heap_$_57 == Heap_$_56[mo#131_$_0,Message.invValue := inhaleHeap#_1203_$_0[mo#131_$_0,Message.invValue]];
	assume wf(Heap_$_57,Mask_$_54);
	assume inhaleHeap#_1203_$_0[mo#131_$_0,Message.invValue] == Heap_$_57;
	assume Fractions(100) > 0;
	assume Mask_$_55 == Mask_$_54[mo#131_$_0,Message.invValue := Mask_$_54[mo#131_$_0,Message.invValue][perm$R := Mask_$_54[mo#131_$_0,Message.invValue][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_55);
	assume IsGoodState(inhaleHeap#_1203_$_0[mo#131_$_0,Message.invValue]);
	assume wf(Heap_$_57,Mask_$_55);
	assume wf(inhaleHeap#_1203_$_0,Mask_$_55);
	assume IsGoodMask(Mask_$_55);
	assume wf(Heap_$_57,Mask_$_55);
	assume ((0 < unfoldK#_1204) && (unfoldK#_1204 < Fractions(1))) && ((1000 * unfoldK#_1204) < whileK#_1176);
	assert { :msg "  754.5: The target of the fold statement might be null." } !(mo#131_$_0 == null);
	assert { :msg "  754.5: unfold might fail because the predicate Message.invValue does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  754.5: unfold might fail because the predicate Message.invValue does not hold. Insufficient fraction at <undefined position> for Message.invValue." } (Fractions(100) <= Mask_$_55[mo#131_$_0,Message.invValue][perm$R]) && ((Fractions(100) == Mask_$_55[mo#131_$_0,Message.invValue][perm$R]) ==> (0 <= Mask_$_55[mo#131_$_0,Message.invValue][perm$N]));
	assume exhaleMask#_1205_$_0 == Mask_$_55[mo#131_$_0,Message.invValue := Mask_$_55[mo#131_$_0,Message.invValue][perm$R := Mask_$_55[mo#131_$_0,Message.invValue][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_55);
	assume wf(Heap_$_57,Mask_$_55);
	assume wf(Heap_$_57,exhaleMask#_1205_$_0);
	assume wf(Heap_$_57,exhaleMask#_1205_$_0);
	assume inhaleHeap#_1207_$_0 == Heap_$_57[mo#131_$_0,Message.invValue];
	assume IsGoodInhaleState(inhaleHeap#_1207_$_0,Heap_$_57,exhaleMask#_1205_$_0);
	assume !(mo#131_$_0 == null);
	assume Heap_$_58 == Heap_$_57[mo#131_$_0,Message.sender1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.sender1]];
	assume wf(Heap_$_58,exhaleMask#_1205_$_0);
	assume (Heap_$_58[mo#131_$_0,Message.sender1] == null) || (dtype(Heap_$_58[mo#131_$_0,Message.sender1]) == Future#t);
	assume predicateK > 0;
	assume Mask_$_56 == exhaleMask#_1205_$_0[mo#131_$_0,Message.sender1 := exhaleMask#_1205_$_0[mo#131_$_0,Message.sender1][perm$R := exhaleMask#_1205_$_0[mo#131_$_0,Message.sender1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_56);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.sender1]);
	assume wf(Heap_$_58,Mask_$_56);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_56);
	assume !(mo#131_$_0 == null);
	assume Heap_$_59 == Heap_$_58[mo#131_$_0,Message.receiver1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.receiver1]];
	assume wf(Heap_$_59,Mask_$_56);
	assume (Heap_$_59[mo#131_$_0,Message.receiver1] == null) || (dtype(Heap_$_59[mo#131_$_0,Message.receiver1]) == FactorialActor#t);
	assume predicateK > 0;
	assume Mask_$_57 == Mask_$_56[mo#131_$_0,Message.receiver1 := Mask_$_56[mo#131_$_0,Message.receiver1][perm$R := Mask_$_56[mo#131_$_0,Message.receiver1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_57);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.receiver1]);
	assume wf(Heap_$_59,Mask_$_57);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_57);
	assume !(mo#131_$_0 == null);
	assume Heap_$_60 == Heap_$_59[mo#131_$_0,Message.cust1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.cust1]];
	assume wf(Heap_$_60,Mask_$_57);
	assume (Heap_$_60[mo#131_$_0,Message.cust1] == null) || (dtype(Heap_$_60[mo#131_$_0,Message.cust1]) == FactorialCont#t);
	assume predicateK > 0;
	assume Mask_$_58 == Mask_$_57[mo#131_$_0,Message.cust1 := Mask_$_57[mo#131_$_0,Message.cust1][perm$R := Mask_$_57[mo#131_$_0,Message.cust1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_58);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.cust1]);
	assume wf(Heap_$_60,Mask_$_58);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_58);
	assume !(mo#131_$_0 == null);
	assume Heap_$_61 == Heap_$_60[mo#131_$_0,Message.v1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.v1]];
	assume wf(Heap_$_61,Mask_$_58);
	assume true;
	assume predicateK > 0;
	assume Mask_$_59 == Mask_$_58[mo#131_$_0,Message.v1 := Mask_$_58[mo#131_$_0,Message.v1][perm$R := Mask_$_58[mo#131_$_0,Message.v1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_59);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.v1]);
	assume wf(Heap_$_61,Mask_$_59);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_59);
	assume !(mo#131_$_0 == null);
	assume Heap_$_62 == Heap_$_61[mo#131_$_0,Message.vo1 := inhaleHeap#_1207_$_0[mo#131_$_0,Message.vo1]];
	assume wf(Heap_$_62,Mask_$_59);
	assume true;
	assume predicateK > 0;
	assume Mask_$_60 == Mask_$_59[mo#131_$_0,Message.vo1 := Mask_$_59[mo#131_$_0,Message.vo1][perm$R := Mask_$_59[mo#131_$_0,Message.vo1][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_60);
	assume IsGoodState(inhaleHeap#_1207_$_0[mo#131_$_0,Message.vo1]);
	assume wf(Heap_$_62,Mask_$_60);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_60);
	assume !(Heap_$_62[mo#131_$_0,Message.sender1] == null);
	assume !(Heap_$_62[mo#131_$_0,Message.sender1] == null);
	assume Heap_$_63 == Heap_$_62[Heap_$_62[mo#131_$_0,Message.sender1],Future.q := inhaleHeap#_1207_$_0[Heap_$_62[mo#131_$_0,Message.sender1],Future.q]];
	assume wf(Heap_$_63,Mask_$_60);
	assume (Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q] == null) || (dtype(Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q]) == FutureChannel#t);
	assume predicateK > 0;
	assume Mask_$_61 == Mask_$_60[Heap_$_63[mo#131_$_0,Message.sender1],Future.q := Mask_$_60[Heap_$_63[mo#131_$_0,Message.sender1],Future.q][perm$R := Mask_$_60[Heap_$_63[mo#131_$_0,Message.sender1],Future.q][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_61);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_63[mo#131_$_0,Message.sender1],Future.q]);
	assume wf(Heap_$_63,Mask_$_61);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_61);
	assume !(Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q] == null);
	assume !(Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_64 == Heap_$_63[Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid := inhaleHeap#_1207_$_0[Heap_$_63[Heap_$_63[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid]];
	assume wf(Heap_$_64,Mask_$_61);
	assume inhaleHeap#_1207_$_0[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid] == Heap_$_64;
	assume Fractions(100) > 0;
	assume Mask_$_62 == Mask_$_61[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid := Mask_$_61[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R := Mask_$_61[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_62);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid]);
	assume wf(Heap_$_64,Mask_$_62);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_62);
	assume !(Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_65 == Heap_$_64[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState := inhaleHeap#_1207_$_0[Heap_$_64[Heap_$_64[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState]];
	assume wf(Heap_$_65,Mask_$_62);
	assume inhaleHeap#_1207_$_0[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState] == Heap_$_65;
	assume Fractions(100) > 0;
	assume Mask_$_63 == Mask_$_62[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState := Mask_$_62[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R := Mask_$_62[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_63);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_65[Heap_$_65[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState]);
	assume wf(Heap_$_65,Mask_$_63);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_63);
	assume Heap_$_65[mo#131_$_0,Message.v1] >= 0;
	assume Heap_$_65[mo#131_$_0,Message.vo1] >= 0;
	if ($_$_condition_$2) { goto anon76_Then; } else { goto anon76_Else; }
anon75_Else:
	assume !(Heap_$_45[msg#128_$_0,Message.type] == 1);
	assume Mask_$_221 == Mask_$_43;
	assume Credits_$_7 == Credits_$_4;
	assume Heap_$_134 == Heap_$_45;
	goto anon70;
anon76_Then:
	assume Heap_$_65[mo#131_$_0,Message.cust1] == null;
	assume Heap_$_65[mo#131_$_0,Message.v1] == Heap_$_65[mo#131_$_0,Message.vo1];
	if ($_$_condition_$3) { goto anon77_Then; } else { goto anon77_Else; }
anon76_Else:
	assume !(Heap_$_65[mo#131_$_0,Message.cust1] == null);
	if ($_$_condition_$4) { goto anon77_Then; } else { goto anon77_Else; }
anon70:
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The expression at 743.27 might not evaluate to true." } !(Heap_$_134[this,FactorialActor.q] == null);
	assert { :msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.13 might not evaluate to true." } Heap_$_134[this,FactorialActor.q] == Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch];
	assert { :msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.28 might not evaluate to true." } !(Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp] == null);
	assert { :msg "  744.13: The loop invariant at 744.13 might not be preserved by the loop. The expression at 744.43 might not evaluate to true." } !(Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] == null);
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The expression at 745.31 might not evaluate to true." } !(Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assert { :msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. The expression at 746.33 might not evaluate to true." } Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. The expression at 747.33 might not evaluate to true." } Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state] == 0;
	assume Credits_$_8 == Credits_$_7[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch] := Credits_$_7[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch]] - 1];
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.13 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.13 for FactorialActor.q." } (monitorK <= Mask_$_221[this,FactorialActor.q][perm$R]) && ((monitorK == Mask_$_221[this,FactorialActor.q][perm$R]) ==> (0 <= Mask_$_221[this,FactorialActor.q][perm$N]));
	assume exhaleMask#_1420_$_0 == Mask_$_221[this,FactorialActor.q := Mask_$_221[this,FactorialActor.q][perm$R := Mask_$_221[this,FactorialActor.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_0);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.38 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.38 for FactorialActorChannel.imp." } (monitorK <= exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$N]));
	assume exhaleMask#_1420_$_1 == exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp := exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R := exhaleMask#_1420_$_0[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_1);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.56 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.56 for FactorialActorChannelImpEP.impch." } (monitorK <= exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1420_$_2 == exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch := exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R := exhaleMask#_1420_$_1[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_2);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.80 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.80 for mu." } (monitorK <= exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) && ((monitorK == exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R]) ==> (0 <= exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$N]));
	assume exhaleMask#_1420_$_3 == exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu := exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R := exhaleMask#_1420_$_2[Heap_$_134[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.impch],mu][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_3);
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. The permission at 743.107 might not be positive." } monitorK > 0;
	assert { :msg "  743.13: The loop invariant at 743.13 might not be preserved by the loop. Insufficient fraction at 743.107 for FactorialActorChannelImpEP.ch." } (monitorK <= exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) && ((monitorK == exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R]) ==> (0 <= exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$N]));
	assume exhaleMask#_1420_$_4 == exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch := exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R := exhaleMask#_1420_$_3[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.ch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_4);
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The permission at 745.13 might not be positive." } monitorK > 0;
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. Insufficient fraction at 745.13 for FactorialActorChannel.exp." } (monitorK <= exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) && ((monitorK == exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R]) ==> (0 <= exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$N]));
	assume exhaleMask#_1420_$_5 == exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp := exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R := exhaleMask#_1420_$_4[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_5);
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. The permission at 745.46 might not be positive." } Fractions(100) > 0;
	assert { :msg "  745.13: The loop invariant at 745.13 might not be preserved by the loop. Insufficient fraction at 745.46 for FactorialActorChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1420_$_6 == exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid := exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1420_$_5[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_6);
	assert { :msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. The permission at 746.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  746.13: The loop invariant at 746.13 might not be preserved by the loop. Insufficient fraction at 746.13 for FactorialActorChannelExpEP.state." } (Fractions(100) <= exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$N]));
	assume exhaleMask#_1420_$_7 == exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state := exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1420_$_6[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.exp],FactorialActorChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_7);
	assert { :msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. The permission at 747.13 might not be positive." } Fractions(100) > 0;
	assert { :msg "  747.13: The loop invariant at 747.13 might not be preserved by the loop. Insufficient fraction at 747.13 for FactorialActorChannelImpEP.state." } (Fractions(100) <= exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) && ((Fractions(100) == exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R]) ==> (0 <= exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$N]));
	assume exhaleMask#_1420_$_8 == exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state := exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R := exhaleMask#_1420_$_7[Heap_$_134[Heap_$_134[this,FactorialActor.q],FactorialActorChannel.imp],FactorialActorChannelImpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_221);
	assume wf(Heap_$_134,Mask_$_221);
	assume wf(Heap_$_134,exhaleMask#_1420_$_8);
	assume wf(Heap_$_134,exhaleMask#_1420_$_8);
	assert { :msg "  742.3: The loop might lock/unlock more than the lockchange clause allows." } (forall  lk#_1430 : ref :: {Heap_$_134[lk#_1430,held]} {Heap_$_134[lk#_1430,rdheld]} ( (((0 < Heap_$_134[lk#_1430,held]) <==> (0 < Heap[lk#_1430,held])) && (Heap_$_134[lk#_1430,rdheld] <==> Heap[lk#_1430,rdheld])) || false ));
	assert { :msg "  742.3: Loop body is not allowed to leave any debt." } (forall  ch_$1 : ref :: ( (ch_$1 == null) || (0 <= Credits_$_8[ch_$1]) ));
	assume false;
	goto $exit;
anon77_Then:
	assume !(Heap_$_65[mo#131_$_0,Message.cust1] == null);
	assume !(Heap_$_65[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_66 == Heap_$_65[Heap_$_65[mo#131_$_0,Message.cust1],FactorialCont.q := inhaleHeap#_1207_$_0[Heap_$_65[mo#131_$_0,Message.cust1],FactorialCont.q]];
	assume wf(Heap_$_66,Mask_$_63);
	assume (Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q] == null) || (dtype(Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q]) == FactorialContChannel#t);
	assume predicateK > 0;
	assume Mask_$_64 == Mask_$_63[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q := Mask_$_63[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q][perm$R := Mask_$_63[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_64);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q]);
	assume wf(Heap_$_66,Mask_$_64);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_64);
	assume !(Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume !(Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_67 == Heap_$_66[Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1207_$_0[Heap_$_66[Heap_$_66[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_67,Mask_$_64);
	assume inhaleHeap#_1207_$_0[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid] == Heap_$_67;
	assume Fractions(100) > 0;
	assume Mask_$_65 == Mask_$_64[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid := Mask_$_64[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_64[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_65);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_67,Mask_$_65);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_65);
	assume !(Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_68 == Heap_$_67[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState := inhaleHeap#_1207_$_0[Heap_$_67[Heap_$_67[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState]];
	assume wf(Heap_$_68,Mask_$_65);
	assume inhaleHeap#_1207_$_0[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState] == Heap_$_68;
	assume Fractions(100) > 0;
	assume Mask_$_66 == Mask_$_65[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState := Mask_$_65[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_65[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_66);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState]);
	assume wf(Heap_$_68,Mask_$_66);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_66);
	assume !(Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_69 == Heap_$_68[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1207_$_0[Heap_$_68[Heap_$_68[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_69,Mask_$_66);
	assume (Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume predicateK > 0;
	assume Mask_$_67 == Mask_$_66[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := Mask_$_66[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R := Mask_$_66[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_67);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_69,Mask_$_67);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_67);
	assume !(Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_70 == Heap_$_69[Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := inhaleHeap#_1207_$_0[Heap_$_69[Heap_$_69[Heap_$_69[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]];
	assume wf(Heap_$_70,Mask_$_67);
	assume (Heap_$_70[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null) || (dtype(Heap_$_70[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]) == Channel#t);
	assume predicateK > 0;
	assume Mask_$_68 == Mask_$_67[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := Mask_$_67[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := Mask_$_67[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_68);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]);
	assume wf(Heap_$_70,Mask_$_68);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_68);
	assume !(Heap_$_70[Heap_$_70[Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assume !(Heap_$_70[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_71 == Heap_$_70[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.v := inhaleHeap#_1207_$_0[Heap_$_70[mo#131_$_0,Message.cust1],FactorialCont.v]];
	assume wf(Heap_$_71,Mask_$_68);
	assume true;
	assume predicateK > 0;
	assume Mask_$_69 == Mask_$_68[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v := Mask_$_68[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v][perm$R := Mask_$_68[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_69);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.v]);
	assume wf(Heap_$_71,Mask_$_69);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_69);
	assume !(Heap_$_71[mo#131_$_0,Message.cust1] == null);
	assume Heap_$_72 == Heap_$_71[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.vo := inhaleHeap#_1207_$_0[Heap_$_71[mo#131_$_0,Message.cust1],FactorialCont.vo]];
	assume wf(Heap_$_72,Mask_$_69);
	assume true;
	assume predicateK > 0;
	assume Mask_$_70 == Mask_$_69[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo := Mask_$_69[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo][perm$R := Mask_$_69[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo][perm$R] + predicateK]];
	assume IsGoodMask(Mask_$_70);
	assume IsGoodState(inhaleHeap#_1207_$_0[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo]);
	assume wf(Heap_$_72,Mask_$_70);
	assume wf(inhaleHeap#_1207_$_0,Mask_$_70);
	assume Heap_$_72[mo#131_$_0,Message.v1] == (Heap_$_72[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.v] - 1);
	assume Heap_$_72[mo#131_$_0,Message.vo1] == Heap_$_72[Heap_$_72[mo#131_$_0,Message.cust1],FactorialCont.vo];
	assume Mask_$_71 == Mask_$_70;
	assume Heap_$_73 == Heap_$_72;
	goto anon10;
anon77_Else:
	assume Heap_$_65[mo#131_$_0,Message.cust1] == null;
	assume Mask_$_71 == Mask_$_63;
	assume Heap_$_73 == Heap_$_65;
	goto anon10;
anon10:
	assume IsGoodMask(Mask_$_71);
	assume wf(Heap_$_73,Mask_$_71);
	assert { :msg "  755.8: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  755.8: Location might not be readable." } true ==> CanRead(Mask_$_71,mo#131_$_0,Message.v1);
	if ($_$_condition_$5) { goto anon78_Then; } else { goto anon78_Else; }
anon78_Then:
	assume Heap_$_73[mo#131_$_0,Message.v1] == 0;
	assert { :msg "  756.10: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  756.10: Location might not be readable." } true ==> CanRead(Mask_$_71,mo#131_$_0,Message.cust1);
	if ($_$_condition_$6) { goto anon79_Then; } else { goto anon79_Else; }
anon78_Else:
	assume !(Heap_$_73[mo#131_$_0,Message.v1] == 0);
	assume (!(nw#_1321_$_0 == null)) && (dtype(nw#_1321_$_0) == FactorialCont#t);
	assume (forall<T#_15> f_$13 : Field (T#_15)  :: ( (Mask_$_71[nw#_1321_$_0,f_$13][perm$R] == 0) && (Mask_$_71[nw#_1321_$_0,f_$13][perm$N] == 0) ));
	assume Heap_$_73[nw#_1321_$_0,mu] == $LockBottom;
	assume Heap_$_73[nw#_1321_$_0,held] <= 0;
	assume Heap_$_73[nw#_1321_$_0,rdheld] <==> false;
	assume Mask_$_72 == Mask_$_71[nw#_1321_$_0,FactorialCont.q := Mask_$_71[nw#_1321_$_0,FactorialCont.q][perm$R := Mask_$_71[nw#_1321_$_0,FactorialCont.q][perm$R] + Fractions(100)]];
	assume Mask_$_73 == Mask_$_72[nw#_1321_$_0,FactorialCont.v := Mask_$_72[nw#_1321_$_0,FactorialCont.v][perm$R := Mask_$_72[nw#_1321_$_0,FactorialCont.v][perm$R] + Fractions(100)]];
	assume Mask_$_74 == Mask_$_73[nw#_1321_$_0,FactorialCont.vo := Mask_$_73[nw#_1321_$_0,FactorialCont.vo][perm$R := Mask_$_73[nw#_1321_$_0,FactorialCont.vo][perm$R] + Fractions(100)]];
	assume Mask_$_75 == Mask_$_74[nw#_1321_$_0,FactorialCont.cust := Mask_$_74[nw#_1321_$_0,FactorialCont.cust][perm$R := Mask_$_74[nw#_1321_$_0,FactorialCont.cust][perm$R] + Fractions(100)]];
	assume Mask_$_76 == Mask_$_75[nw#_1321_$_0,mu := Mask_$_75[nw#_1321_$_0,mu][perm$R := Mask_$_75[nw#_1321_$_0,mu][perm$R] + Fractions(100)]];
	assume ((0 < methodCallK#_1325) && ((1000 * methodCallK#_1325) < Fractions(1))) && ((1000 * methodCallK#_1325) < whileK#_1176);
	assert { :msg "  784.6: The target of the method call might be null." } !(nw#_1321_$_0 == null);
	assert { :msg "  784.21: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  784.21: Location might not be readable." } true ==> CanRead(Mask_$_76,mo#131_$_0,Message.v1);
	assert { :msg "  784.32: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  784.32: Location might not be readable." } true ==> CanRead(Mask_$_76,mo#131_$_0,Message.vo1);
	assert { :msg "  784.44: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  784.44: Location might not be readable." } true ==> CanRead(Mask_$_76,mo#131_$_0,Message.cust1);
	assume vp#144_$_0 == Heap_$_73[mo#131_$_0,Message.v1];
	assume vop#145_$_0 == Heap_$_73[mo#131_$_0,Message.vo1];
	assume custp#146_$_0 == Heap_$_73[mo#131_$_0,Message.cust1];
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 822.54 might not evaluate to true." } vp#144_$_0 >= 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 822.64 might not evaluate to true." } vop#145_$_0 >= 0;
	if ($_$_condition_$7) { goto anon86_Then; } else { goto anon86_Else; }
anon79_Then:
	assume Heap_$_73[mo#131_$_0,Message.cust1] == null;
	assume (!(nw#_1208_$_0 == null)) && (dtype(nw#_1208_$_0) == Message#t);
	assume (forall<T#_12> f_$14 : Field (T#_12)  :: ( (Mask_$_71[nw#_1208_$_0,f_$14][perm$R] == 0) && (Mask_$_71[nw#_1208_$_0,f_$14][perm$N] == 0) ));
	assume Heap_$_73[nw#_1208_$_0,mu] == $LockBottom;
	assume Heap_$_73[nw#_1208_$_0,held] <= 0;
	assume Heap_$_73[nw#_1208_$_0,rdheld] <==> false;
	assume Mask_$_139 == Mask_$_71[nw#_1208_$_0,Message.type := Mask_$_71[nw#_1208_$_0,Message.type][perm$R := Mask_$_71[nw#_1208_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_140 == Mask_$_139[nw#_1208_$_0,Message.sender1 := Mask_$_139[nw#_1208_$_0,Message.sender1][perm$R := Mask_$_139[nw#_1208_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_141 == Mask_$_140[nw#_1208_$_0,Message.sender3 := Mask_$_140[nw#_1208_$_0,Message.sender3][perm$R := Mask_$_140[nw#_1208_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_142 == Mask_$_141[nw#_1208_$_0,Message.sender2 := Mask_$_141[nw#_1208_$_0,Message.sender2][perm$R := Mask_$_141[nw#_1208_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_143 == Mask_$_142[nw#_1208_$_0,Message.sender4 := Mask_$_142[nw#_1208_$_0,Message.sender4][perm$R := Mask_$_142[nw#_1208_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_144 == Mask_$_143[nw#_1208_$_0,Message.receiver1 := Mask_$_143[nw#_1208_$_0,Message.receiver1][perm$R := Mask_$_143[nw#_1208_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_145 == Mask_$_144[nw#_1208_$_0,Message.receiver2 := Mask_$_144[nw#_1208_$_0,Message.receiver2][perm$R := Mask_$_144[nw#_1208_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_146 == Mask_$_145[nw#_1208_$_0,Message.receiver3 := Mask_$_145[nw#_1208_$_0,Message.receiver3][perm$R := Mask_$_145[nw#_1208_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_147 == Mask_$_146[nw#_1208_$_0,Message.receiver4 := Mask_$_146[nw#_1208_$_0,Message.receiver4][perm$R := Mask_$_146[nw#_1208_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_148 == Mask_$_147[nw#_1208_$_0,Message.v1 := Mask_$_147[nw#_1208_$_0,Message.v1][perm$R := Mask_$_147[nw#_1208_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_149 == Mask_$_148[nw#_1208_$_0,Message.vo1 := Mask_$_148[nw#_1208_$_0,Message.vo1][perm$R := Mask_$_148[nw#_1208_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_150 == Mask_$_149[nw#_1208_$_0,Message.cust1 := Mask_$_149[nw#_1208_$_0,Message.cust1][perm$R := Mask_$_149[nw#_1208_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_151 == Mask_$_150[nw#_1208_$_0,Message.vr1 := Mask_$_150[nw#_1208_$_0,Message.vr1][perm$R := Mask_$_150[nw#_1208_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_152 == Mask_$_151[nw#_1208_$_0,Message.old1 := Mask_$_151[nw#_1208_$_0,Message.old1][perm$R := Mask_$_151[nw#_1208_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_153 == Mask_$_152[nw#_1208_$_0,Message.vr2 := Mask_$_152[nw#_1208_$_0,Message.vr2][perm$R := Mask_$_152[nw#_1208_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_154 == Mask_$_153[nw#_1208_$_0,Message.old2 := Mask_$_153[nw#_1208_$_0,Message.old2][perm$R := Mask_$_153[nw#_1208_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_155 == Mask_$_154[nw#_1208_$_0,Message.vr3 := Mask_$_154[nw#_1208_$_0,Message.vr3][perm$R := Mask_$_154[nw#_1208_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_156 == Mask_$_155[nw#_1208_$_0,mu := Mask_$_155[nw#_1208_$_0,mu][perm$R := Mask_$_155[nw#_1208_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  759.7: Location might not be writable" } CanWrite(Mask_$_156,nw#_1208_$_0,Message.sender4);
	assume Heap_$_103 == Heap_$_73[nw#_1208_$_0,Message.sender4 := null];
	assume wf(Heap_$_103,Mask_$_156);
	assume ((0 < methodCallK#_1212) && ((1000 * methodCallK#_1212) < Fractions(1))) && ((1000 * methodCallK#_1212) < whileK#_1176);
	assert { :msg "  760.7: The target of the method call might be null." } !(nw#_1208_$_0 == null);
	assert { :msg "  760.31: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  760.31: Location might not be readable." } true ==> CanRead(Mask_$_156,mo#131_$_0,Message.sender1);
	assume receiver#134_$_0 == Heap_$_103[mo#131_$_0,Message.sender1];
	if ($_$_condition_$8) { goto anon80_Then; } else { goto anon80_Else; }
anon79_Else:
	assume !(Heap_$_73[mo#131_$_0,Message.cust1] == null);
	assume (!(nw#_1258_$_0 == null)) && (dtype(nw#_1258_$_0) == Message#t);
	assume (forall<T#_13> f_$15 : Field (T#_13)  :: ( (Mask_$_71[nw#_1258_$_0,f_$15][perm$R] == 0) && (Mask_$_71[nw#_1258_$_0,f_$15][perm$N] == 0) ));
	assume Heap_$_73[nw#_1258_$_0,mu] == $LockBottom;
	assume Heap_$_73[nw#_1258_$_0,held] <= 0;
	assume Heap_$_73[nw#_1258_$_0,rdheld] <==> false;
	assume Mask_$_157 == Mask_$_71[nw#_1258_$_0,Message.type := Mask_$_71[nw#_1258_$_0,Message.type][perm$R := Mask_$_71[nw#_1258_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_158 == Mask_$_157[nw#_1258_$_0,Message.sender1 := Mask_$_157[nw#_1258_$_0,Message.sender1][perm$R := Mask_$_157[nw#_1258_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_159 == Mask_$_158[nw#_1258_$_0,Message.sender3 := Mask_$_158[nw#_1258_$_0,Message.sender3][perm$R := Mask_$_158[nw#_1258_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_160 == Mask_$_159[nw#_1258_$_0,Message.sender2 := Mask_$_159[nw#_1258_$_0,Message.sender2][perm$R := Mask_$_159[nw#_1258_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_161 == Mask_$_160[nw#_1258_$_0,Message.sender4 := Mask_$_160[nw#_1258_$_0,Message.sender4][perm$R := Mask_$_160[nw#_1258_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_162 == Mask_$_161[nw#_1258_$_0,Message.receiver1 := Mask_$_161[nw#_1258_$_0,Message.receiver1][perm$R := Mask_$_161[nw#_1258_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_163 == Mask_$_162[nw#_1258_$_0,Message.receiver2 := Mask_$_162[nw#_1258_$_0,Message.receiver2][perm$R := Mask_$_162[nw#_1258_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_164 == Mask_$_163[nw#_1258_$_0,Message.receiver3 := Mask_$_163[nw#_1258_$_0,Message.receiver3][perm$R := Mask_$_163[nw#_1258_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_165 == Mask_$_164[nw#_1258_$_0,Message.receiver4 := Mask_$_164[nw#_1258_$_0,Message.receiver4][perm$R := Mask_$_164[nw#_1258_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_166 == Mask_$_165[nw#_1258_$_0,Message.v1 := Mask_$_165[nw#_1258_$_0,Message.v1][perm$R := Mask_$_165[nw#_1258_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_167 == Mask_$_166[nw#_1258_$_0,Message.vo1 := Mask_$_166[nw#_1258_$_0,Message.vo1][perm$R := Mask_$_166[nw#_1258_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_168 == Mask_$_167[nw#_1258_$_0,Message.cust1 := Mask_$_167[nw#_1258_$_0,Message.cust1][perm$R := Mask_$_167[nw#_1258_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_169 == Mask_$_168[nw#_1258_$_0,Message.vr1 := Mask_$_168[nw#_1258_$_0,Message.vr1][perm$R := Mask_$_168[nw#_1258_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_170 == Mask_$_169[nw#_1258_$_0,Message.old1 := Mask_$_169[nw#_1258_$_0,Message.old1][perm$R := Mask_$_169[nw#_1258_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_171 == Mask_$_170[nw#_1258_$_0,Message.vr2 := Mask_$_170[nw#_1258_$_0,Message.vr2][perm$R := Mask_$_170[nw#_1258_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_172 == Mask_$_171[nw#_1258_$_0,Message.old2 := Mask_$_171[nw#_1258_$_0,Message.old2][perm$R := Mask_$_171[nw#_1258_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_173 == Mask_$_172[nw#_1258_$_0,Message.vr3 := Mask_$_172[nw#_1258_$_0,Message.vr3][perm$R := Mask_$_172[nw#_1258_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_174 == Mask_$_173[nw#_1258_$_0,mu := Mask_$_173[nw#_1258_$_0,mu][perm$R := Mask_$_173[nw#_1258_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  771.7: Location might not be writable" } CanWrite(Mask_$_174,nw#_1258_$_0,Message.sender2);
	assert { :msg "  771.18: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  771.18: Location might not be readable." } true ==> CanRead(Mask_$_174,mo#131_$_0,Message.sender1);
	assume Heap_$_104 == Heap_$_73[nw#_1258_$_0,Message.sender2 := Heap_$_73[mo#131_$_0,Message.sender1]];
	assume wf(Heap_$_104,Mask_$_174);
	assume ((0 < methodCallK#_1262) && ((1000 * methodCallK#_1262) < Fractions(1))) && ((1000 * methodCallK#_1262) < whileK#_1176);
	assert { :msg "  772.7: The target of the method call might be null." } !(nw#_1258_$_0 == null);
	assert { :msg "  772.32: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  772.32: Location might not be readable." } true ==> CanRead(Mask_$_174,mo#131_$_0,Message.cust1);
	assume receiver#140_$_0 == Heap_$_104[mo#131_$_0,Message.cust1];
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 681.4 might not evaluate to true." } !(Heap_$_104[nw#_1258_$_0,Message.sender2] == null);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 681.44 might not evaluate to true." } !(Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q] == null);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.3 might not evaluate to true." } 1 == #Message.factorial(Heap_$_104,Mask_$_174,nw#_1258_$_0,0);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.45 might not evaluate to true." } !(receiver#140_$_0 == null);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The expression at 682.64 might not evaluate to true." } Heap_$_104[receiver#140_$_0,FactorialCont.v] == 1;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.11 for Message.type." } (Fractions(100) <= Mask_$_174[nw#_1258_$_0,Message.type][perm$R]) && ((Fractions(100) == Mask_$_174[nw#_1258_$_0,Message.type][perm$R]) ==> (0 <= Mask_$_174[nw#_1258_$_0,Message.type][perm$N]));
	assume exhaleMask#_1263_$_0 == Mask_$_174[nw#_1258_$_0,Message.type := Mask_$_174[nw#_1258_$_0,Message.type][perm$R := Mask_$_174[nw#_1258_$_0,Message.type][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_0);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.25 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.25 for Message.sender2." } (Fractions(100) <= exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R]) ==> (0 <= exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$N]));
	assume exhaleMask#_1263_$_1 == exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2 := exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R := exhaleMask#_1263_$_0[nw#_1258_$_0,Message.sender2][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_1);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 679.41 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 679.41 for Message.receiver2." } (Fractions(100) <= exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R]) ==> (0 <= exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$N]));
	assume exhaleMask#_1263_$_2 == exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2 := exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R := exhaleMask#_1263_$_1[nw#_1258_$_0,Message.receiver2][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_2);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 680.3 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 680.3 for Message.vr1." } (Fractions(100) <= exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R]) ==> (0 <= exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$N]));
	assume exhaleMask#_1263_$_3 == exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1 := exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R := exhaleMask#_1263_$_2[nw#_1258_$_0,Message.vr1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_3);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 680.15 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 680.15 for Message.old1." } (Fractions(100) <= exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R]) ==> (0 <= exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$N]));
	assume exhaleMask#_1263_$_4 == exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1 := exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R := exhaleMask#_1263_$_3[nw#_1258_$_0,Message.old1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_4);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.22 might not be positive." } monitorK > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.22 for Future.q." } (monitorK <= exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R]) && ((monitorK == exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R]) ==> (0 <= exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$N]));
	assume exhaleMask#_1263_$_5 == exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q := exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R := exhaleMask#_1263_$_4[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_5);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.63 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.63 for FutureChannel.valid." } (Fractions(100) <= exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$N]));
	assume exhaleMask#_1263_$_6 == exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid := exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R := exhaleMask#_1263_$_5[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_6);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 681.82 might not be positive." } Fractions(100) > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 681.82 for FutureChannel.initExpState." } (Fractions(100) <= exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$N]));
	assume exhaleMask#_1263_$_7 == exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState := exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R := exhaleMask#_1263_$_6[Heap_$_104[Heap_$_104[nw#_1258_$_0,Message.sender2],Future.q],FutureChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_7);
	assert { :msg "  772.7: The precondition at 679.11 might not hold. The permission at 682.22 might not be positive." } monitorK > 0;
	assert { :msg "  772.7: The precondition at 679.11 might not hold. Insufficient fraction at 682.22 for FactorialCont.v." } (monitorK <= exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1263_$_8 == exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v := exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R := exhaleMask#_1263_$_7[receiver#140_$_0,FactorialCont.v][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_174);
	assume wf(Heap_$_104,Mask_$_174);
	assume wf(Heap_$_104,exhaleMask#_1263_$_8);
	assume wf(Heap_$_104,exhaleMask#_1263_$_8);
	assume IsGoodInhaleState(inhaleHeap#_1275_$_0,Heap_$_104,exhaleMask#_1263_$_8);
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_105 == Heap_$_104[nw#_1258_$_0,Message.invResult1 := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.invResult1]];
	assume wf(Heap_$_105,exhaleMask#_1263_$_8);
	assume inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.invResult1] == Heap_$_105;
	assume Fractions(100) > 0;
	assume Mask_$_175 == exhaleMask#_1263_$_8[nw#_1258_$_0,Message.invResult1 := exhaleMask#_1263_$_8[nw#_1258_$_0,Message.invResult1][perm$R := exhaleMask#_1263_$_8[nw#_1258_$_0,Message.invResult1][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_175);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.invResult1]);
	assume wf(Heap_$_105,Mask_$_175);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_175);
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_106 == Heap_$_105[nw#_1258_$_0,Message.type := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]];
	assume wf(Heap_$_106,Mask_$_175);
	assume true;
	assume monitorK > 0;
	assume Mask_$_176 == Mask_$_175[nw#_1258_$_0,Message.type := Mask_$_175[nw#_1258_$_0,Message.type][perm$R := Mask_$_175[nw#_1258_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_176);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]);
	assume wf(Heap_$_106,Mask_$_176);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_176);
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_107 == Heap_$_106[nw#_1258_$_0,Message.type := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]];
	assume wf(Heap_$_107,Mask_$_176);
	assume true;
	assume monitorK > 0;
	assume Mask_$_177 == Mask_$_176[nw#_1258_$_0,Message.type := Mask_$_176[nw#_1258_$_0,Message.type][perm$R := Mask_$_176[nw#_1258_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_177);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.type]);
	assume wf(Heap_$_107,Mask_$_177);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_177);
	assume Heap_$_107[nw#_1258_$_0,Message.type] == 2;
	assume !(nw#_1258_$_0 == null);
	assume Heap_$_108 == Heap_$_107[nw#_1258_$_0,Message.receiver2 := inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.receiver2]];
	assume wf(Heap_$_108,Mask_$_177);
	assume (Heap_$_108[nw#_1258_$_0,Message.receiver2] == null) || (dtype(Heap_$_108[nw#_1258_$_0,Message.receiver2]) == FactorialCont#t);
	assume monitorK > 0;
	assume Mask_$_178 == Mask_$_177[nw#_1258_$_0,Message.receiver2 := Mask_$_177[nw#_1258_$_0,Message.receiver2][perm$R := Mask_$_177[nw#_1258_$_0,Message.receiver2][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_178);
	assume IsGoodState(inhaleHeap#_1275_$_0[nw#_1258_$_0,Message.receiver2]);
	assume wf(Heap_$_108,Mask_$_178);
	assume wf(inhaleHeap#_1275_$_0,Mask_$_178);
	assume Heap_$_108[nw#_1258_$_0,Message.receiver2] == receiver#140_$_0;
	assume IsGoodMask(Mask_$_178);
	assume wf(Heap_$_108,Mask_$_178);
	assume ((0 < unfoldK#_1276) && (unfoldK#_1276 < Fractions(1))) && ((1000 * unfoldK#_1276) < whileK#_1176);
	assert { :msg "  773.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  773.14: Location might not be readable." } true ==> CanRead(Mask_$_178,mo#131_$_0,Message.cust1);
	assert { :msg "  773.14: Receiver might be null." } true ==> (!(Heap_$_108[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  773.14: Location might not be readable." } true ==> CanRead(Mask_$_178,Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q);
	assert { :msg "  773.7: The target of the fold statement might be null." } !(Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assert { :msg "  773.7: unfold might fail because the predicate FactorialContChannel.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  773.7: unfold might fail because the predicate FactorialContChannel.valid does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.valid." } (Fractions(100) <= Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1277_$_0 == Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid := Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_178[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_178);
	assume wf(Heap_$_108,Mask_$_178);
	assume wf(Heap_$_108,exhaleMask#_1277_$_0);
	assume wf(Heap_$_108,exhaleMask#_1277_$_0);
	assume inhaleHeap#_1279_$_0 == Heap_$_108[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.valid];
	assume IsGoodInhaleState(inhaleHeap#_1279_$_0,Heap_$_108,exhaleMask#_1277_$_0);
	assume !(Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_109 == Heap_$_108[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1279_$_0[Heap_$_108[Heap_$_108[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_109,exhaleMask#_1277_$_0);
	assume (Heap_$_109[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_109[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_179 == exhaleMask#_1277_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp := exhaleMask#_1277_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R := exhaleMask#_1277_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_179);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_109,Mask_$_179);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_179);
	assume !(Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_110 == Heap_$_109[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := inhaleHeap#_1279_$_0[Heap_$_109[Heap_$_109[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]];
	assume wf(Heap_$_110,Mask_$_179);
	assume (Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null) || (dtype(Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_180 == Mask_$_179[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := Mask_$_179[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R := Mask_$_179[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_180);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]);
	assume wf(Heap_$_110,Mask_$_180);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_180);
	assume !(Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_111 == Heap_$_110[Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch := inhaleHeap#_1279_$_0[Heap_$_110[Heap_$_110[Heap_$_110[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch]];
	assume wf(Heap_$_111,Mask_$_180);
	assume (Heap_$_111[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch] == null) || (dtype(Heap_$_111[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch]) == FactorialContChannel#t);
	assume monitorK > 0;
	assume Mask_$_181 == Mask_$_180[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch := Mask_$_180[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch][perm$R := Mask_$_180[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_181);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch]);
	assume wf(Heap_$_111,Mask_$_181);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_181);
	assume !(Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_112 == Heap_$_111[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch := inhaleHeap#_1279_$_0[Heap_$_111[Heap_$_111[Heap_$_111[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch]];
	assume wf(Heap_$_112,Mask_$_181);
	assume (Heap_$_112[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch] == null) || (dtype(Heap_$_112[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch]) == FactorialContChannel#t);
	assume monitorK > 0;
	assume Mask_$_182 == Mask_$_181[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch := Mask_$_181[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch][perm$R := Mask_$_181[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_182);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch]);
	assume wf(Heap_$_112,Mask_$_182);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_182);
	assume !(Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume !(Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume !(Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_113 == Heap_$_112[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid := inhaleHeap#_1279_$_0[Heap_$_112[Heap_$_112[Heap_$_112[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid]];
	assume wf(Heap_$_113,Mask_$_182);
	assume inhaleHeap#_1279_$_0[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid] == Heap_$_113;
	assume Fractions(100) > 0;
	assume Mask_$_183 == Mask_$_182[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid := Mask_$_182[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid][perm$R := Mask_$_182[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_183);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.valid]);
	assume wf(Heap_$_113,Mask_$_183);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_183);
	assume !(Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_114 == Heap_$_113[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid := inhaleHeap#_1279_$_0[Heap_$_113[Heap_$_113[Heap_$_113[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid]];
	assume wf(Heap_$_114,Mask_$_183);
	assume inhaleHeap#_1279_$_0[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid] == Heap_$_114;
	assume Fractions(100) > 0;
	assume Mask_$_184 == Mask_$_183[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid := Mask_$_183[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid][perm$R := Mask_$_183[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_184);
	assume IsGoodState(inhaleHeap#_1279_$_0[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.valid]);
	assume wf(Heap_$_114,Mask_$_184);
	assume wf(inhaleHeap#_1279_$_0,Mask_$_184);
	assume Heap_$_114[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.ch] == Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q];
	assume Heap_$_114[Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.ch] == Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q];
	assume IsGoodMask(Mask_$_184);
	assume wf(Heap_$_114,Mask_$_184);
	assume ((0 < unfoldK#_1280) && (unfoldK#_1280 < Fractions(1))) && ((1000 * unfoldK#_1280) < whileK#_1176);
	assert { :msg "  774.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  774.14: Location might not be readable." } true ==> CanRead(Mask_$_184,mo#131_$_0,Message.cust1);
	assert { :msg "  774.14: Receiver might be null." } true ==> (!(Heap_$_114[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  774.14: Location might not be readable." } true ==> CanRead(Mask_$_184,Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q);
	assert { :msg "  774.7: The target of the fold statement might be null." } !(Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assert { :msg "  774.7: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  774.7: unfold might fail because the predicate FactorialContChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FactorialContChannel.initExpState." } (Fractions(100) <= Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1281_$_0 == Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState := Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_184[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_184);
	assume wf(Heap_$_114,Mask_$_184);
	assume wf(Heap_$_114,exhaleMask#_1281_$_0);
	assume wf(Heap_$_114,exhaleMask#_1281_$_0);
	assume inhaleHeap#_1283_$_0 == Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.initExpState];
	assume IsGoodInhaleState(inhaleHeap#_1283_$_0,Heap_$_114,exhaleMask#_1281_$_0);
	assume !(Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q] == null);
	assume Heap_$_115 == Heap_$_114[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := inhaleHeap#_1283_$_0[Heap_$_114[Heap_$_114[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]];
	assume wf(Heap_$_115,exhaleMask#_1281_$_0);
	assume (Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null) || (dtype(Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_185 == exhaleMask#_1281_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp := exhaleMask#_1281_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R := exhaleMask#_1281_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_185);
	assume IsGoodState(inhaleHeap#_1283_$_0[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp]);
	assume wf(Heap_$_115,Mask_$_185);
	assume wf(inhaleHeap#_1283_$_0,Mask_$_185);
	assume !(Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_116 == Heap_$_115[Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state := inhaleHeap#_1283_$_0[Heap_$_115[Heap_$_115[Heap_$_115[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state]];
	assume wf(Heap_$_116,Mask_$_185);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_186 == Mask_$_185[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state := Mask_$_185[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state][perm$R := Mask_$_185[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume IsGoodState(inhaleHeap#_1283_$_0[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state]);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(inhaleHeap#_1283_$_0,Mask_$_186);
	assume Heap_$_116[Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.state] == 0;
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume ((0 < methodCallK#_1287) && ((1000 * methodCallK#_1287) < Fractions(1))) && ((1000 * methodCallK#_1287) < whileK#_1176);
	assert { :msg "  775.12: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_186,mo#131_$_0,Message.cust1);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_116[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_186,Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_186,Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp);
	assert { :msg "  775.7: The target of the method call might be null." } !(Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp] == null);
	assume this#141_$_0 == Heap_$_116[Heap_$_116[Heap_$_116[mo#131_$_0,Message.cust1],FactorialCont.q],FactorialContChannel.exp];
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The expression at 195.63 might not evaluate to true." } Heap_$_116[nw#_1258_$_0,Message.type] == 2;
	assert { :msg "  775.7: The precondition at 197.11 might not hold. The expression at 197.11 might not evaluate to true." } Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.11 for FactorialContChannelExpEP.state." } (Fractions(100) <= Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R]) && ((Fractions(100) == Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R]) ==> (0 <= Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$N]));
	assume exhaleMask#_1288_$_0 == Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state := Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R := Mask_$_186[this#141_$_0,FactorialContChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_0);
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.25 might not be positive." } monitorK > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.25 for Message.type." } (monitorK <= exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$N]));
	assume exhaleMask#_1288_$_1 == exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type := exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R := exhaleMask#_1288_$_0[nw#_1258_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_1);
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.44 might not be positive." } monitorK > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.44 for Message.type." } (monitorK <= exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$N]));
	assume exhaleMask#_1288_$_2 == exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type := exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R := exhaleMask#_1288_$_1[nw#_1258_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_2);
	assert { :msg "  775.7: The precondition at 195.11 might not hold. The permission at 195.76 might not be positive." } Fractions(100) > 0;
	assert { :msg "  775.7: The precondition at 195.11 might not hold. Insufficient fraction at 195.76 for Message.invResult1." } (Fractions(100) <= exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R]) && ((Fractions(100) == exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R]) ==> (0 <= exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$N]));
	assume exhaleMask#_1288_$_3 == exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1 := exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R := exhaleMask#_1288_$_2[nw#_1258_$_0,Message.invResult1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_3);
	assert { :msg "  775.7: The precondition at 196.11 might not hold. The permission at 196.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  775.7: The precondition at 196.11 might not hold. Insufficient fraction at 196.11 for FactorialContChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1288_$_4 == exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid := exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R := exhaleMask#_1288_$_3[this#141_$_0,FactorialContChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_186);
	assume wf(Heap_$_116,Mask_$_186);
	assume wf(Heap_$_116,exhaleMask#_1288_$_4);
	assume wf(Heap_$_116,exhaleMask#_1288_$_4);
	assume IsGoodInhaleState(inhaleHeap#_1296_$_0,Heap_$_116,exhaleMask#_1288_$_4);
	assume !(this#141_$_0 == null);
	assume Heap_$_117 == Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state := inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.state]];
	assume wf(Heap_$_117,exhaleMask#_1288_$_4);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_187 == exhaleMask#_1288_$_4[this#141_$_0,FactorialContChannelExpEP.state := exhaleMask#_1288_$_4[this#141_$_0,FactorialContChannelExpEP.state][perm$R := exhaleMask#_1288_$_4[this#141_$_0,FactorialContChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_187);
	assume IsGoodState(inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.state]);
	assume wf(Heap_$_117,Mask_$_187);
	assume wf(inhaleHeap#_1296_$_0,Mask_$_187);
	assume !(this#141_$_0 == null);
	assume Heap_$_118 == Heap_$_117[this#141_$_0,FactorialContChannelExpEP.valid := inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.valid]];
	assume wf(Heap_$_118,Mask_$_187);
	assume inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.valid] == Heap_$_118;
	assume Fractions(100) > 0;
	assume Mask_$_188 == Mask_$_187[this#141_$_0,FactorialContChannelExpEP.valid := Mask_$_187[this#141_$_0,FactorialContChannelExpEP.valid][perm$R := Mask_$_187[this#141_$_0,FactorialContChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_188);
	assume IsGoodState(inhaleHeap#_1296_$_0[this#141_$_0,FactorialContChannelExpEP.valid]);
	assume wf(Heap_$_118,Mask_$_188);
	assume wf(inhaleHeap#_1296_$_0,Mask_$_188);
	if ($_$_condition_$9) { goto anon83_Then; } else { goto anon83_Else; }
anon86_Then:
	assume !(custp#146_$_0 == null);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 823.41 might not evaluate to true." } !(Heap_$_73[custp#146_$_0,FactorialCont.q] == null);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The expression at 823.120 might not evaluate to true." } vop#145_$_0 == Heap_$_73[custp#146_$_0,FactorialCont.vo];
	goto anon35;
anon86_Else:
	assume custp#146_$_0 == null;
	goto anon35;
anon80_Then:
	assume !(Heap_$_103[nw#_1208_$_0,Message.sender4] == null);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The expression at 710.45 might not evaluate to true." } !(Heap_$_103[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q] == null);
	goto anon15;
anon80_Else:
	assume Heap_$_103[nw#_1208_$_0,Message.sender4] == null;
	goto anon15;
anon83_Then:
	assume Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0;
	assume Heap_$_118[this#141_$_0,FactorialContChannelExpEP.state] == 1;
	goto anon25;
anon83_Else:
	assume !(Heap_$_116[this#141_$_0,FactorialContChannelExpEP.state] == 0);
	goto anon25;
anon35:
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.11 for FactorialCont.v." } (Fractions(100) <= Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R]) && ((Fractions(100) == Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R]) ==> (0 <= Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1326_$_0 == Mask_$_76[nw#_1321_$_0,FactorialCont.v := Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R := Mask_$_76[nw#_1321_$_0,FactorialCont.v][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_0);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.20 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.20 for FactorialCont.vo." } (Fractions(100) <= exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1326_$_1 == exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo := exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R := exhaleMask#_1326_$_0[nw#_1321_$_0,FactorialCont.vo][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_1);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.31 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.31 for FactorialCont.cust." } (Fractions(100) <= exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$N]));
	assume exhaleMask#_1326_$_2 == exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust := exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R := exhaleMask#_1326_$_1[nw#_1321_$_0,FactorialCont.cust][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_2);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 822.44 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 822.44 for FactorialCont.q." } (Fractions(100) <= exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1326_$_3 == exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q := exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R := exhaleMask#_1326_$_2[nw#_1321_$_0,FactorialCont.q][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_3);
	if ($_$_condition_$10) { goto anon87_Then; } else { goto anon87_Else; }
anon15:
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.11 for Message.type." } (Fractions(100) <= Mask_$_156[nw#_1208_$_0,Message.type][perm$R]) && ((Fractions(100) == Mask_$_156[nw#_1208_$_0,Message.type][perm$R]) ==> (0 <= Mask_$_156[nw#_1208_$_0,Message.type][perm$N]));
	assume exhaleMask#_1213_$_0 == Mask_$_156[nw#_1208_$_0,Message.type := Mask_$_156[nw#_1208_$_0,Message.type][perm$R := Mask_$_156[nw#_1208_$_0,Message.type][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_0);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.24 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.24 for Message.sender4." } (Fractions(100) <= exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R]) && ((Fractions(100) == exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R]) ==> (0 <= exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$N]));
	assume exhaleMask#_1213_$_1 == exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4 := exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R := exhaleMask#_1213_$_0[nw#_1208_$_0,Message.sender4][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_1);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.40 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.40 for Message.receiver4." } (Fractions(100) <= exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R]) && ((Fractions(100) == exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R]) ==> (0 <= exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$N]));
	assume exhaleMask#_1213_$_2 == exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4 := exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R := exhaleMask#_1213_$_1[nw#_1208_$_0,Message.receiver4][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_2);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 709.58 might not be positive." } Fractions(100) > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 709.58 for Message.vr3." } (Fractions(100) <= exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R]) && ((Fractions(100) == exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R]) ==> (0 <= exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$N]));
	assume exhaleMask#_1213_$_3 == exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3 := exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R := exhaleMask#_1213_$_2[nw#_1208_$_0,Message.vr3][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_3);
	if ($_$_condition_$11) { goto anon81_Then; } else { goto anon81_Else; }
anon25:
	assume IsGoodMask(Mask_$_188);
	assume wf(Heap_$_118,Mask_$_188);
	assume (!(nw#_1297_$_0 == null)) && (dtype(nw#_1297_$_0) == Message#t);
	assume (forall<T#_14> f_$16 : Field (T#_14)  :: ( (Mask_$_188[nw#_1297_$_0,f_$16][perm$R] == 0) && (Mask_$_188[nw#_1297_$_0,f_$16][perm$N] == 0) ));
	assume Heap_$_118[nw#_1297_$_0,mu] == $LockBottom;
	assume Heap_$_118[nw#_1297_$_0,held] <= 0;
	assume Heap_$_118[nw#_1297_$_0,rdheld] <==> false;
	assume Mask_$_189 == Mask_$_188[nw#_1297_$_0,Message.type := Mask_$_188[nw#_1297_$_0,Message.type][perm$R := Mask_$_188[nw#_1297_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_190 == Mask_$_189[nw#_1297_$_0,Message.sender1 := Mask_$_189[nw#_1297_$_0,Message.sender1][perm$R := Mask_$_189[nw#_1297_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_191 == Mask_$_190[nw#_1297_$_0,Message.sender3 := Mask_$_190[nw#_1297_$_0,Message.sender3][perm$R := Mask_$_190[nw#_1297_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_192 == Mask_$_191[nw#_1297_$_0,Message.sender2 := Mask_$_191[nw#_1297_$_0,Message.sender2][perm$R := Mask_$_191[nw#_1297_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_193 == Mask_$_192[nw#_1297_$_0,Message.sender4 := Mask_$_192[nw#_1297_$_0,Message.sender4][perm$R := Mask_$_192[nw#_1297_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_194 == Mask_$_193[nw#_1297_$_0,Message.receiver1 := Mask_$_193[nw#_1297_$_0,Message.receiver1][perm$R := Mask_$_193[nw#_1297_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_195 == Mask_$_194[nw#_1297_$_0,Message.receiver2 := Mask_$_194[nw#_1297_$_0,Message.receiver2][perm$R := Mask_$_194[nw#_1297_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_196 == Mask_$_195[nw#_1297_$_0,Message.receiver3 := Mask_$_195[nw#_1297_$_0,Message.receiver3][perm$R := Mask_$_195[nw#_1297_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_197 == Mask_$_196[nw#_1297_$_0,Message.receiver4 := Mask_$_196[nw#_1297_$_0,Message.receiver4][perm$R := Mask_$_196[nw#_1297_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_198 == Mask_$_197[nw#_1297_$_0,Message.v1 := Mask_$_197[nw#_1297_$_0,Message.v1][perm$R := Mask_$_197[nw#_1297_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_199 == Mask_$_198[nw#_1297_$_0,Message.vo1 := Mask_$_198[nw#_1297_$_0,Message.vo1][perm$R := Mask_$_198[nw#_1297_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_200 == Mask_$_199[nw#_1297_$_0,Message.cust1 := Mask_$_199[nw#_1297_$_0,Message.cust1][perm$R := Mask_$_199[nw#_1297_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_201 == Mask_$_200[nw#_1297_$_0,Message.vr1 := Mask_$_200[nw#_1297_$_0,Message.vr1][perm$R := Mask_$_200[nw#_1297_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_202 == Mask_$_201[nw#_1297_$_0,Message.old1 := Mask_$_201[nw#_1297_$_0,Message.old1][perm$R := Mask_$_201[nw#_1297_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_203 == Mask_$_202[nw#_1297_$_0,Message.vr2 := Mask_$_202[nw#_1297_$_0,Message.vr2][perm$R := Mask_$_202[nw#_1297_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_204 == Mask_$_203[nw#_1297_$_0,Message.old2 := Mask_$_203[nw#_1297_$_0,Message.old2][perm$R := Mask_$_203[nw#_1297_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_205 == Mask_$_204[nw#_1297_$_0,Message.vr3 := Mask_$_204[nw#_1297_$_0,Message.vr3][perm$R := Mask_$_204[nw#_1297_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_206 == Mask_$_205[nw#_1297_$_0,mu := Mask_$_205[nw#_1297_$_0,mu][perm$R := Mask_$_205[nw#_1297_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  778.7: Location might not be writable" } CanWrite(Mask_$_206,nw#_1297_$_0,Message.type);
	assume Heap_$_119 == Heap_$_118[nw#_1297_$_0,Message.type := 4];
	assume wf(Heap_$_119,Mask_$_206);
	assert { :msg "  779.14: Receiver might be null." } true ==> (!(nw#_1297_$_0 == null));
	assert { :msg "  779.14: Location might not be readable." } true ==> CanRead(Mask_$_206,nw#_1297_$_0,Message.vr3);
	assert { :msg "  779.33: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  779.33: Location might not be readable." } true ==> CanRead(Mask_$_206,mo#131_$_0,Message.cust1);
	assert { :msg "  779.33: Receiver might be null." } true ==> (!(Heap_$_119[mo#131_$_0,Message.cust1] == null));
	assert { :msg "  779.33: Location might not be readable." } true ==> CanRead(Mask_$_206,Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo);
	assert { :msg "  779.21: Receiver might be null." } true ==> (!(nw#_1297_$_0 == null));
	assume (0 < funcappK#_1311) && ((1000 * funcappK#_1311) < Fractions(1));
	assume true;
	assert { :msg "  779.21: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo] >= 0;
	assume wf(Heap_$_119,Mask_$_206);
	if ($_$_condition_$12) { goto anon84_Then; } else { goto anon84_Else; }
anon87_Then:
	assume !(custp#146_$_0 == null);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.21 might not be positive." } monitorK > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.21 for FactorialCont.q." } (monitorK <= exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1326_$_4 == exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q := exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R := exhaleMask#_1326_$_3[custp#146_$_0,FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_4);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.58 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.58 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1326_$_5 == exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1326_$_4[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_5);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.75 might not be positive." } Fractions(100) > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.75 for FactorialContChannel.initExpState." } (Fractions(100) <= exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1326_$_6 == exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState := exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R := exhaleMask#_1326_$_5[Heap_$_73[custp#146_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_6);
	assert { :msg "  784.6: The precondition at 822.11 might not hold. The permission at 823.99 might not be positive." } monitorK > 0;
	assert { :msg "  784.6: The precondition at 822.11 might not hold. Insufficient fraction at 823.99 for FactorialCont.vo." } (monitorK <= exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1326_$_7 == exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo := exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R := exhaleMask#_1326_$_6[custp#146_$_0,FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_76);
	assume wf(Heap_$_73,Mask_$_76);
	assume wf(Heap_$_73,exhaleMask#_1326_$_7);
	assume exhaleMask#_1326_$_8 == exhaleMask#_1326_$_7;
	goto anon38;
anon87_Else:
	assume custp#146_$_0 == null;
	assume exhaleMask#_1326_$_8 == exhaleMask#_1326_$_3;
	goto anon38;
anon81_Then:
	assume !(Heap_$_103[nw#_1208_$_0,Message.sender4] == null);
	assert { :msg "  760.7: The precondition at 709.11 might not hold. The permission at 710.23 might not be positive." } monitorK > 0;
	assert { :msg "  760.7: The precondition at 709.11 might not hold. Insufficient fraction at 710.23 for FactorialCont.q." } (monitorK <= exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$N]));
	assume exhaleMask#_1213_$_4 == exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q := exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R := exhaleMask#_1213_$_3[Heap_$_103[nw#_1208_$_0,Message.sender4],FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_156);
	assume wf(Heap_$_103,Mask_$_156);
	assume wf(Heap_$_103,exhaleMask#_1213_$_4);
	assume exhaleMask#_1213_$_5 == exhaleMask#_1213_$_4;
	goto anon18;
anon81_Else:
	assume Heap_$_103[nw#_1208_$_0,Message.sender4] == null;
	assume exhaleMask#_1213_$_5 == exhaleMask#_1213_$_3;
	goto anon18;
anon84_Then:
	assume Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]);
	assert { :msg "  779.54: Receiver might be null." } true ==> (!(nw#_1297_$_0 == null));
	assert { :msg "  779.54: Location might not be readable." } true ==> CanRead(Mask_$_206,nw#_1297_$_0,Message.vr3);
	assert { :msg "  779.73: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  779.73: Location might not be readable." } true ==> CanRead(Mask_$_206,mo#131_$_0,Message.vo1);
	assert { :msg "  779.61: Receiver might be null." } true ==> (!(nw#_1258_$_0 == null));
	assume (0 < funcappK#_1319) && ((1000 * funcappK#_1319) < Fractions(1));
	assume true;
	assert { :msg "  779.61: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_119[mo#131_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_119,Mask_$_206);
	assert { :msg "  779.7: Assertion might not hold. The expression at 779.54 might not evaluate to true." } Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1258_$_0,Heap_$_119[mo#131_$_0,Message.vo1]);
	if ($_$_condition_$13) { goto anon85_Then; } else { goto anon85_Else; }
anon84_Else:
	assume !(Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	if ($_$_condition_$14) { goto anon85_Then; } else { goto anon85_Else; }
anon38:
	assume wf(Heap_$_73,exhaleMask#_1326_$_8);
	assume IsGoodInhaleState(inhaleHeap#_1337_$_0,Heap_$_73,exhaleMask#_1326_$_8);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_74 == Heap_$_73[nw#_1321_$_0,FactorialCont.v := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.v]];
	assume wf(Heap_$_74,exhaleMask#_1326_$_8);
	assume true;
	assume Fractions(50) > 0;
	assume Mask_$_77 == exhaleMask#_1326_$_8[nw#_1321_$_0,FactorialCont.v := exhaleMask#_1326_$_8[nw#_1321_$_0,FactorialCont.v][perm$R := exhaleMask#_1326_$_8[nw#_1321_$_0,FactorialCont.v][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_77);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.v]);
	assume wf(Heap_$_74,Mask_$_77);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_77);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_75 == Heap_$_74[nw#_1321_$_0,FactorialCont.vo := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.vo]];
	assume wf(Heap_$_75,Mask_$_77);
	assume true;
	assume Fractions(50) > 0;
	assume Mask_$_78 == Mask_$_77[nw#_1321_$_0,FactorialCont.vo := Mask_$_77[nw#_1321_$_0,FactorialCont.vo][perm$R := Mask_$_77[nw#_1321_$_0,FactorialCont.vo][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_78);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.vo]);
	assume wf(Heap_$_75,Mask_$_78);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_78);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_76 == Heap_$_75[nw#_1321_$_0,FactorialCont.cust := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.cust]];
	assume wf(Heap_$_76,Mask_$_78);
	assume (Heap_$_76[nw#_1321_$_0,FactorialCont.cust] == null) || (dtype(Heap_$_76[nw#_1321_$_0,FactorialCont.cust]) == FactorialCont#t);
	assume Fractions(50) > 0;
	assume Mask_$_79 == Mask_$_78[nw#_1321_$_0,FactorialCont.cust := Mask_$_78[nw#_1321_$_0,FactorialCont.cust][perm$R := Mask_$_78[nw#_1321_$_0,FactorialCont.cust][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_79);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.cust]);
	assume wf(Heap_$_76,Mask_$_79);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_79);
	assume !(nw#_1321_$_0 == null);
	assume Heap_$_77 == Heap_$_76[nw#_1321_$_0,FactorialCont.q := inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.q]];
	assume wf(Heap_$_77,Mask_$_79);
	assume (Heap_$_77[nw#_1321_$_0,FactorialCont.q] == null) || (dtype(Heap_$_77[nw#_1321_$_0,FactorialCont.q]) == FactorialContChannel#t);
	assume Fractions(50) > 0;
	assume Mask_$_80 == Mask_$_79[nw#_1321_$_0,FactorialCont.q := Mask_$_79[nw#_1321_$_0,FactorialCont.q][perm$R := Mask_$_79[nw#_1321_$_0,FactorialCont.q][perm$R] + Fractions(50)]];
	assume IsGoodMask(Mask_$_80);
	assume IsGoodState(inhaleHeap#_1337_$_0[nw#_1321_$_0,FactorialCont.q]);
	assume wf(Heap_$_77,Mask_$_80);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_80);
	assume !(Heap_$_77[nw#_1321_$_0,FactorialCont.q] == null);
	assume !(Heap_$_77[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_78 == Heap_$_77[Heap_$_77[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1337_$_0[Heap_$_77[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_78,Mask_$_80);
	assume inhaleHeap#_1337_$_0[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid] == Heap_$_78;
	assume Fractions(100) > 0;
	assume Mask_$_81 == Mask_$_80[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := Mask_$_80[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_80[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_81);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_78,Mask_$_81);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_81);
	assume !(Heap_$_78[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_79 == Heap_$_78[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1337_$_0[Heap_$_78[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_79,Mask_$_81);
	assume inhaleHeap#_1337_$_0[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid] == Heap_$_79;
	assume Fractions(100) > 0;
	assume Mask_$_82 == Mask_$_81[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := Mask_$_81[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_81[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_82);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_79,Mask_$_82);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_82);
	assume !(Heap_$_79[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_80 == Heap_$_79[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState := inhaleHeap#_1337_$_0[Heap_$_79[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState]];
	assume wf(Heap_$_80,Mask_$_82);
	assume inhaleHeap#_1337_$_0[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState] == Heap_$_80;
	assume Fractions(100) > 0;
	assume Mask_$_83 == Mask_$_82[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState := Mask_$_82[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R := Mask_$_82[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_83);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState]);
	assume wf(Heap_$_80,Mask_$_83);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_83);
	assume !(Heap_$_80[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_81 == Heap_$_80[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState := inhaleHeap#_1337_$_0[Heap_$_80[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState]];
	assume wf(Heap_$_81,Mask_$_83);
	assume inhaleHeap#_1337_$_0[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState] == Heap_$_81;
	assume Fractions(100) > 0;
	assume Mask_$_84 == Mask_$_83[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState := Mask_$_83[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_83[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_84);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState]);
	assume wf(Heap_$_81,Mask_$_84);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_84);
	assume !(Heap_$_81[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_82 == Heap_$_81[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1337_$_0[Heap_$_81[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_82,Mask_$_84);
	assume (Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_85 == Mask_$_84[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := Mask_$_84[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := Mask_$_84[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_85);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_82,Mask_$_85);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_85);
	assume !(Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_83 == Heap_$_82[Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := inhaleHeap#_1337_$_0[Heap_$_82[Heap_$_82[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]];
	assume wf(Heap_$_83,Mask_$_85);
	assume (Heap_$_83[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null) || (dtype(Heap_$_83[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_86 == Mask_$_85[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := Mask_$_85[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := Mask_$_85[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_86);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]);
	assume wf(Heap_$_83,Mask_$_86);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_86);
	assume !(Heap_$_83[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_84 == Heap_$_83[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := inhaleHeap#_1337_$_0[Heap_$_83[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]];
	assume wf(Heap_$_84,Mask_$_86);
	assume (Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null) || (dtype(Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]) == FactorialContChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_87 == Mask_$_86[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := Mask_$_86[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := Mask_$_86[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_87);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp]);
	assume wf(Heap_$_84,Mask_$_87);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_87);
	assume !(Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp] == null);
	assume Heap_$_85 == Heap_$_84[Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := inhaleHeap#_1337_$_0[Heap_$_84[Heap_$_84[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]];
	assume wf(Heap_$_85,Mask_$_87);
	assume (Heap_$_85[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null) || (dtype(Heap_$_85[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_88 == Mask_$_87[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := Mask_$_87[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := Mask_$_87[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_88);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]);
	assume wf(Heap_$_85,Mask_$_88);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_88);
	assume !(Heap_$_85[Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assume !(Heap_$_85[nw#_1321_$_0,FactorialCont.q] == null);
	assume Heap_$_86 == Heap_$_85[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp := inhaleHeap#_1337_$_0[Heap_$_85[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp]];
	assume wf(Heap_$_86,Mask_$_88);
	assume (Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp] == null) || (dtype(Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp]) == FactorialContChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_89 == Mask_$_88[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp := Mask_$_88[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp][perm$R := Mask_$_88[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_89);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp]);
	assume wf(Heap_$_86,Mask_$_89);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_89);
	assume !(Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp] == null);
	assume Heap_$_87 == Heap_$_86[Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch := inhaleHeap#_1337_$_0[Heap_$_86[Heap_$_86[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch]];
	assume wf(Heap_$_87,Mask_$_89);
	assume (Heap_$_87[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch] == null) || (dtype(Heap_$_87[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch]) == Channel#t);
	assume monitorK > 0;
	assume Mask_$_90 == Mask_$_89[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch := Mask_$_89[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch][perm$R := Mask_$_89[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_90);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.exp],FactorialContChannelExpEP.expch]);
	assume wf(Heap_$_87,Mask_$_90);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_90);
	assume Heap_$_87[nw#_1321_$_0,FactorialCont.v] >= 0;
	assume Heap_$_87[nw#_1321_$_0,FactorialCont.vo] >= 0;
	assume vp#144_$_0 == Heap_$_87[nw#_1321_$_0,FactorialCont.v];
	assume vop#145_$_0 == Heap_$_87[nw#_1321_$_0,FactorialCont.vo];
	if ($_$_condition_$15) { goto anon88_Then; } else { goto anon88_Else; }
anon18:
	assume wf(Heap_$_103,exhaleMask#_1213_$_5);
	assume IsGoodInhaleState(inhaleHeap#_1221_$_0,Heap_$_103,exhaleMask#_1213_$_5);
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_120 == Heap_$_103[nw#_1208_$_0,Message.invFinalResult := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.invFinalResult]];
	assume wf(Heap_$_120,exhaleMask#_1213_$_5);
	assume inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.invFinalResult] == Heap_$_120;
	assume Fractions(100) > 0;
	assume Mask_$_207 == exhaleMask#_1213_$_5[nw#_1208_$_0,Message.invFinalResult := exhaleMask#_1213_$_5[nw#_1208_$_0,Message.invFinalResult][perm$R := exhaleMask#_1213_$_5[nw#_1208_$_0,Message.invFinalResult][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_207);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.invFinalResult]);
	assume wf(Heap_$_120,Mask_$_207);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_207);
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_121 == Heap_$_120[nw#_1208_$_0,Message.type := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]];
	assume wf(Heap_$_121,Mask_$_207);
	assume true;
	assume monitorK > 0;
	assume Mask_$_208 == Mask_$_207[nw#_1208_$_0,Message.type := Mask_$_207[nw#_1208_$_0,Message.type][perm$R := Mask_$_207[nw#_1208_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_208);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]);
	assume wf(Heap_$_121,Mask_$_208);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_208);
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_122 == Heap_$_121[nw#_1208_$_0,Message.type := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]];
	assume wf(Heap_$_122,Mask_$_208);
	assume true;
	assume monitorK > 0;
	assume Mask_$_209 == Mask_$_208[nw#_1208_$_0,Message.type := Mask_$_208[nw#_1208_$_0,Message.type][perm$R := Mask_$_208[nw#_1208_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_209);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.type]);
	assume wf(Heap_$_122,Mask_$_209);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_209);
	assume Heap_$_122[nw#_1208_$_0,Message.type] == 4;
	assume !(nw#_1208_$_0 == null);
	assume Heap_$_123 == Heap_$_122[nw#_1208_$_0,Message.vr3 := inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.vr3]];
	assume wf(Heap_$_123,Mask_$_209);
	assume true;
	assume monitorK > 0;
	assume Mask_$_210 == Mask_$_209[nw#_1208_$_0,Message.vr3 := Mask_$_209[nw#_1208_$_0,Message.vr3][perm$R := Mask_$_209[nw#_1208_$_0,Message.vr3][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_210);
	assume IsGoodState(inhaleHeap#_1221_$_0[nw#_1208_$_0,Message.vr3]);
	assume wf(Heap_$_123,Mask_$_210);
	assume wf(inhaleHeap#_1221_$_0,Mask_$_210);
	assume Heap_$_123[nw#_1208_$_0,Message.vr3] == 1;
	assume IsGoodMask(Mask_$_210);
	assume wf(Heap_$_123,Mask_$_210);
	assert { :msg "  762.14: Receiver might be null." } true ==> (!(nw#_1208_$_0 == null));
	assert { :msg "  762.14: Location might not be readable." } true ==> CanRead(Mask_$_210,nw#_1208_$_0,Message.vr3);
	assert { :msg "  762.33: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  762.33: Location might not be readable." } true ==> CanRead(Mask_$_210,mo#131_$_0,Message.vo1);
	assert { :msg "  762.21: Receiver might be null." } true ==> (!(nw#_1208_$_0 == null));
	assume (0 < funcappK#_1235) && ((1000 * funcappK#_1235) < Fractions(1));
	assume true;
	assert { :msg "  762.21: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_123[mo#131_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_123,Mask_$_210);
	assert { :msg "  762.7: Assertion might not hold. The expression at 762.14 might not evaluate to true." } Heap_$_123[nw#_1208_$_0,Message.vr3] == #Message.factorial(Heap_$_123,Mask_$_210,nw#_1208_$_0,Heap_$_123[mo#131_$_0,Message.vo1]);
	assume wf(Heap_$_123,Mask_$_210);
	assume ((0 < unfoldK#_1237) && (unfoldK#_1237 < Fractions(1))) && ((1000 * unfoldK#_1237) < whileK#_1176);
	assert { :msg "  763.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  763.14: Location might not be readable." } true ==> CanRead(Mask_$_210,mo#131_$_0,Message.sender1);
	assert { :msg "  763.14: Receiver might be null." } true ==> (!(Heap_$_123[mo#131_$_0,Message.sender1] == null));
	assert { :msg "  763.14: Location might not be readable." } true ==> CanRead(Mask_$_210,Heap_$_123[mo#131_$_0,Message.sender1],Future.q);
	assert { :msg "  763.7: The target of the fold statement might be null." } !(Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q] == null);
	assert { :msg "  763.7: unfold might fail because the predicate FutureChannel.valid does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  763.7: unfold might fail because the predicate FutureChannel.valid does not hold. Insufficient fraction at <undefined position> for FutureChannel.valid." } (Fractions(100) <= Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) && ((Fractions(100) == Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) ==> (0 <= Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$N]));
	assume exhaleMask#_1238_$_0 == Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid := Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R := Mask_$_210[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_210);
	assume wf(Heap_$_123,Mask_$_210);
	assume wf(Heap_$_123,exhaleMask#_1238_$_0);
	assume wf(Heap_$_123,exhaleMask#_1238_$_0);
	assume inhaleHeap#_1240_$_0 == Heap_$_123[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.valid];
	assume IsGoodInhaleState(inhaleHeap#_1240_$_0,Heap_$_123,exhaleMask#_1238_$_0);
	assume !(Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_124 == Heap_$_123[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp := inhaleHeap#_1240_$_0[Heap_$_123[Heap_$_123[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp]];
	assume wf(Heap_$_124,exhaleMask#_1238_$_0);
	assume (Heap_$_124[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null) || (dtype(Heap_$_124[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp]) == FutureChannelImpEP#t);
	assume monitorK > 0;
	assume Mask_$_211 == exhaleMask#_1238_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp := exhaleMask#_1238_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp][perm$R := exhaleMask#_1238_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_211);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp]);
	assume wf(Heap_$_124,Mask_$_211);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_211);
	assume !(Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_125 == Heap_$_124[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := inhaleHeap#_1240_$_0[Heap_$_124[Heap_$_124[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]];
	assume wf(Heap_$_125,Mask_$_211);
	assume (Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null) || (dtype(Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]) == FutureChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_212 == Mask_$_211[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := Mask_$_211[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R := Mask_$_211[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_212);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]);
	assume wf(Heap_$_125,Mask_$_212);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_212);
	assume !(Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null);
	assume Heap_$_126 == Heap_$_125[Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch := inhaleHeap#_1240_$_0[Heap_$_125[Heap_$_125[Heap_$_125[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch]];
	assume wf(Heap_$_126,Mask_$_212);
	assume (Heap_$_126[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch] == null) || (dtype(Heap_$_126[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch]) == FutureChannel#t);
	assume monitorK > 0;
	assume Mask_$_213 == Mask_$_212[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch := Mask_$_212[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch][perm$R := Mask_$_212[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_213);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch]);
	assume wf(Heap_$_126,Mask_$_213);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_213);
	assume !(Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume Heap_$_127 == Heap_$_126[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch := inhaleHeap#_1240_$_0[Heap_$_126[Heap_$_126[Heap_$_126[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch]];
	assume wf(Heap_$_127,Mask_$_213);
	assume (Heap_$_127[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch] == null) || (dtype(Heap_$_127[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch]) == FutureChannel#t);
	assume monitorK > 0;
	assume Mask_$_214 == Mask_$_213[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch := Mask_$_213[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch][perm$R := Mask_$_213[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_214);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch]);
	assume wf(Heap_$_127,Mask_$_214);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_214);
	assume !(Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null);
	assume !(Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume !(Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp] == null);
	assume Heap_$_128 == Heap_$_127[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid := inhaleHeap#_1240_$_0[Heap_$_127[Heap_$_127[Heap_$_127[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid]];
	assume wf(Heap_$_128,Mask_$_214);
	assume inhaleHeap#_1240_$_0[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid] == Heap_$_128;
	assume Fractions(100) > 0;
	assume Mask_$_215 == Mask_$_214[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid := Mask_$_214[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid][perm$R := Mask_$_214[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_215);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.valid]);
	assume wf(Heap_$_128,Mask_$_215);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_215);
	assume !(Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume Heap_$_129 == Heap_$_128[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid := inhaleHeap#_1240_$_0[Heap_$_128[Heap_$_128[Heap_$_128[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid]];
	assume wf(Heap_$_129,Mask_$_215);
	assume inhaleHeap#_1240_$_0[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid] == Heap_$_129;
	assume Fractions(100) > 0;
	assume Mask_$_216 == Mask_$_215[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid := Mask_$_215[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid][perm$R := Mask_$_215[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_216);
	assume IsGoodState(inhaleHeap#_1240_$_0[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.valid]);
	assume wf(Heap_$_129,Mask_$_216);
	assume wf(inhaleHeap#_1240_$_0,Mask_$_216);
	assume Heap_$_129[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.imp],FutureChannelImpEP.ch] == Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q];
	assume Heap_$_129[Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.ch] == Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q];
	assume IsGoodMask(Mask_$_216);
	assume wf(Heap_$_129,Mask_$_216);
	assume ((0 < unfoldK#_1241) && (unfoldK#_1241 < Fractions(1))) && ((1000 * unfoldK#_1241) < whileK#_1176);
	assert { :msg "  764.14: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  764.14: Location might not be readable." } true ==> CanRead(Mask_$_216,mo#131_$_0,Message.sender1);
	assert { :msg "  764.14: Receiver might be null." } true ==> (!(Heap_$_129[mo#131_$_0,Message.sender1] == null));
	assert { :msg "  764.14: Location might not be readable." } true ==> CanRead(Mask_$_216,Heap_$_129[mo#131_$_0,Message.sender1],Future.q);
	assert { :msg "  764.7: The target of the fold statement might be null." } !(Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q] == null);
	assert { :msg "  764.7: unfold might fail because the predicate FutureChannel.initExpState does not hold. The permission at <undefined position> might not be positive." } Fractions(100) > 0;
	assert { :msg "  764.7: unfold might fail because the predicate FutureChannel.initExpState does not hold. Insufficient fraction at <undefined position> for FutureChannel.initExpState." } (Fractions(100) <= Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) && ((Fractions(100) == Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) ==> (0 <= Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$N]));
	assume exhaleMask#_1242_$_0 == Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState := Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R := Mask_$_216[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_216);
	assume wf(Heap_$_129,Mask_$_216);
	assume wf(Heap_$_129,exhaleMask#_1242_$_0);
	assume wf(Heap_$_129,exhaleMask#_1242_$_0);
	assume inhaleHeap#_1244_$_0 == Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.initExpState];
	assume IsGoodInhaleState(inhaleHeap#_1244_$_0,Heap_$_129,exhaleMask#_1242_$_0);
	assume !(Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q] == null);
	assume Heap_$_130 == Heap_$_129[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := inhaleHeap#_1244_$_0[Heap_$_129[Heap_$_129[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]];
	assume wf(Heap_$_130,exhaleMask#_1242_$_0);
	assume (Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null) || (dtype(Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]) == FutureChannelExpEP#t);
	assume monitorK > 0;
	assume Mask_$_217 == exhaleMask#_1242_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp := exhaleMask#_1242_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R := exhaleMask#_1242_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_217);
	assume IsGoodState(inhaleHeap#_1244_$_0[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp]);
	assume wf(Heap_$_130,Mask_$_217);
	assume wf(inhaleHeap#_1244_$_0,Mask_$_217);
	assume !(Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume Heap_$_131 == Heap_$_130[Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state := inhaleHeap#_1244_$_0[Heap_$_130[Heap_$_130[Heap_$_130[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state]];
	assume wf(Heap_$_131,Mask_$_217);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_218 == Mask_$_217[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state := Mask_$_217[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state][perm$R := Mask_$_217[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume IsGoodState(inhaleHeap#_1244_$_0[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state]);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(inhaleHeap#_1244_$_0,Mask_$_218);
	assume Heap_$_131[Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp],FutureChannelExpEP.state] == 0;
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume ((0 < methodCallK#_1248) && ((1000 * methodCallK#_1248) < Fractions(1))) && ((1000 * methodCallK#_1248) < whileK#_1176);
	assert { :msg "  765.12: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_218,mo#131_$_0,Message.sender1);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_131[mo#131_$_0,Message.sender1] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_218,Heap_$_131[mo#131_$_0,Message.sender1],Future.q);
	assert { :msg "  <undefined position>: Receiver might be null." } true ==> (!(Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_218,Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp);
	assert { :msg "  765.7: The target of the method call might be null." } !(Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp] == null);
	assume this#135_$_0 == Heap_$_131[Heap_$_131[Heap_$_131[mo#131_$_0,Message.sender1],Future.q],FutureChannel.exp];
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The expression at 400.63 might not evaluate to true." } Heap_$_131[nw#_1208_$_0,Message.type] == 4;
	assert { :msg "  765.7: The precondition at 402.11 might not hold. The expression at 402.11 might not evaluate to true." } Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.11 for FutureChannelExpEP.state." } (Fractions(100) <= Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R]) && ((Fractions(100) == Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R]) ==> (0 <= Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$N]));
	assume exhaleMask#_1249_$_0 == Mask_$_218[this#135_$_0,FutureChannelExpEP.state := Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R := Mask_$_218[this#135_$_0,FutureChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_0);
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.25 might not be positive." } monitorK > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.25 for Message.type." } (monitorK <= exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$N]));
	assume exhaleMask#_1249_$_1 == exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type := exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R := exhaleMask#_1249_$_0[nw#_1208_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_1);
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.44 might not be positive." } monitorK > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.44 for Message.type." } (monitorK <= exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$N]));
	assume exhaleMask#_1249_$_2 == exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type := exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R := exhaleMask#_1249_$_1[nw#_1208_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_2);
	assert { :msg "  765.7: The precondition at 400.11 might not hold. The permission at 400.76 might not be positive." } Fractions(100) > 0;
	assert { :msg "  765.7: The precondition at 400.11 might not hold. Insufficient fraction at 400.76 for Message.invFinalResult." } (Fractions(100) <= exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R]) && ((Fractions(100) == exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R]) ==> (0 <= exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$N]));
	assume exhaleMask#_1249_$_3 == exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult := exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R := exhaleMask#_1249_$_2[nw#_1208_$_0,Message.invFinalResult][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_3);
	assert { :msg "  765.7: The precondition at 401.11 might not hold. The permission at 401.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  765.7: The precondition at 401.11 might not hold. Insufficient fraction at 401.11 for FutureChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1249_$_4 == exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid := exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R := exhaleMask#_1249_$_3[this#135_$_0,FutureChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_218);
	assume wf(Heap_$_131,Mask_$_218);
	assume wf(Heap_$_131,exhaleMask#_1249_$_4);
	assume wf(Heap_$_131,exhaleMask#_1249_$_4);
	assume IsGoodInhaleState(inhaleHeap#_1257_$_0,Heap_$_131,exhaleMask#_1249_$_4);
	assume !(this#135_$_0 == null);
	assume Heap_$_132 == Heap_$_131[this#135_$_0,FutureChannelExpEP.state := inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.state]];
	assume wf(Heap_$_132,exhaleMask#_1249_$_4);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_219 == exhaleMask#_1249_$_4[this#135_$_0,FutureChannelExpEP.state := exhaleMask#_1249_$_4[this#135_$_0,FutureChannelExpEP.state][perm$R := exhaleMask#_1249_$_4[this#135_$_0,FutureChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_219);
	assume IsGoodState(inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.state]);
	assume wf(Heap_$_132,Mask_$_219);
	assume wf(inhaleHeap#_1257_$_0,Mask_$_219);
	assume !(this#135_$_0 == null);
	assume Heap_$_133 == Heap_$_132[this#135_$_0,FutureChannelExpEP.valid := inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.valid]];
	assume wf(Heap_$_133,Mask_$_219);
	assume inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.valid] == Heap_$_133;
	assume Fractions(100) > 0;
	assume Mask_$_220 == Mask_$_219[this#135_$_0,FutureChannelExpEP.valid := Mask_$_219[this#135_$_0,FutureChannelExpEP.valid][perm$R := Mask_$_219[this#135_$_0,FutureChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_220);
	assume IsGoodState(inhaleHeap#_1257_$_0[this#135_$_0,FutureChannelExpEP.valid]);
	assume wf(Heap_$_133,Mask_$_220);
	assume wf(inhaleHeap#_1257_$_0,Mask_$_220);
	if ($_$_condition_$16) { goto anon82_Then; } else { goto anon82_Else; }
anon85_Then:
	assume Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]);
	goto anon31;
anon85_Else:
	assume !(Heap_$_119[nw#_1297_$_0,Message.vr3] == #Message.factorial(Heap_$_119,Mask_$_206,nw#_1297_$_0,Heap_$_119[Heap_$_119[mo#131_$_0,Message.cust1],FactorialCont.vo]));
	goto anon31;
anon88_Then:
	assume !(Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null);
	assume !(Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null);
	assume Heap_$_88 == Heap_$_87[Heap_$_87[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q := inhaleHeap#_1337_$_0[Heap_$_87[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q]];
	assume wf(Heap_$_88,Mask_$_90);
	assume (Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null) || (dtype(Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q]) == FactorialContChannel#t);
	assume monitorK > 0;
	assume Mask_$_91 == Mask_$_90[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q := Mask_$_90[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R := Mask_$_90[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_91);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q]);
	assume wf(Heap_$_88,Mask_$_91);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_91);
	assume !(Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assume !(Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assume Heap_$_89 == Heap_$_88[Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid := inhaleHeap#_1337_$_0[Heap_$_88[Heap_$_88[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid]];
	assume wf(Heap_$_89,Mask_$_91);
	assume inhaleHeap#_1337_$_0[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid] == Heap_$_89;
	assume Fractions(100) > 0;
	assume Mask_$_92 == Mask_$_91[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid := Mask_$_91[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R := Mask_$_91[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_92);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid]);
	assume wf(Heap_$_89,Mask_$_92);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_92);
	assume !(Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assume Heap_$_90 == Heap_$_89[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState := inhaleHeap#_1337_$_0[Heap_$_89[Heap_$_89[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState]];
	assume wf(Heap_$_90,Mask_$_92);
	assume inhaleHeap#_1337_$_0[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState] == Heap_$_90;
	assume Fractions(100) > 0;
	assume Mask_$_93 == Mask_$_92[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState := Mask_$_92[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R := Mask_$_92[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_93);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState]);
	assume wf(Heap_$_90,Mask_$_93);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_93);
	assume !(Heap_$_90[nw#_1321_$_0,FactorialCont.cust] == null);
	assume Heap_$_91 == Heap_$_90[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo := inhaleHeap#_1337_$_0[Heap_$_90[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo]];
	assume wf(Heap_$_91,Mask_$_93);
	assume true;
	assume monitorK > 0;
	assume Mask_$_94 == Mask_$_93[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo := Mask_$_93[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R := Mask_$_93[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_94);
	assume IsGoodState(inhaleHeap#_1337_$_0[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo]);
	assume wf(Heap_$_91,Mask_$_94);
	assume wf(inhaleHeap#_1337_$_0,Mask_$_94);
	assume Heap_$_91[Heap_$_91[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo] == Heap_$_91[nw#_1321_$_0,FactorialCont.vo];
	assume Heap_$_92 == Heap_$_91;
	assume Mask_$_95 == Mask_$_94;
	goto anon41;
anon88_Else:
	assume Heap_$_87[nw#_1321_$_0,FactorialCont.cust] == null;
	assume Heap_$_92 == Heap_$_87;
	assume Mask_$_95 == Mask_$_90;
	goto anon41;
anon82_Then:
	assume Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0;
	assume Heap_$_133[this#135_$_0,FutureChannelExpEP.state] == 1;
	goto anon21;
anon82_Else:
	assume !(Heap_$_131[this#135_$_0,FutureChannelExpEP.state] == 0);
	goto anon21;
anon31:
	assume wf(Heap_$_119,Mask_$_206);
	assume Mask_$_221 == Mask_$_206;
	assume Credits_$_7 == Credits_$_4;
	assume Heap_$_134 == Heap_$_119;
	goto anon70;
anon41:
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume ((0 < asyncMethodCallK#_1344) && ((1000 * asyncMethodCallK#_1344) < Fractions(1))) && ((1000 * asyncMethodCallK#_1344) < whileK#_1176);
	assert { :msg "  785.6: The target of the method call might be null." } !(nw#_1321_$_0 == null);
	assume argsSeq#_1343_$_0 == argsSeq#_1343[0 := nw#_1321_$_0];
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.54 might not evaluate to true." } !(Heap_$_92[nw#_1321_$_0,FactorialCont.q] == null);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.137 might not evaluate to true." } !(Heap_$_92[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.158 might not evaluate to true." } Heap_$_92[nw#_1321_$_0,FactorialCont.v] >= 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The expression at 839.166 might not evaluate to true." } Heap_$_92[nw#_1321_$_0,FactorialCont.vo] >= 0;
	if ($_$_condition_$17) { goto anon89_Then; } else { goto anon89_Else; }
anon21:
	assume IsGoodMask(Mask_$_220);
	assume wf(Heap_$_133,Mask_$_220);
	assume Mask_$_221 == Mask_$_220;
	assume Credits_$_7 == Credits_$_4;
	assume Heap_$_134 == Heap_$_133;
	goto anon70;
anon89_Then:
	assume !(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The expression at 840.65 might not evaluate to true." } !(Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q] == null);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The expression at 840.140 might not evaluate to true." } Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo] == Heap_$_92[nw#_1321_$_0,FactorialCont.vo];
	goto anon44;
anon89_Else:
	assume Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null;
	goto anon44;
anon44:
	assume Credits_$_6 == Credits_$_4[Heap_$_92[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] := Credits_$_4[Heap_$_92[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch]] - 1];
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.11 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.11 for FactorialCont.q." } (monitorK <= Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R]) && ((monitorK == Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R]) ==> (0 <= Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1345_$_0 == Mask_$_95[nw#_1321_$_0,FactorialCont.q := Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R := Mask_$_95[nw#_1321_$_0,FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_0);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.25 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.25 for FactorialCont.v." } (monitorK <= exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1345_$_1 == exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v := exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R := exhaleMask#_1345_$_0[nw#_1321_$_0,FactorialCont.v][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_1);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.39 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.39 for FactorialCont.vo." } (monitorK <= exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1345_$_2 == exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo := exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R := exhaleMask#_1345_$_1[nw#_1321_$_0,FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_2);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.66 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.66 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1345_$_3 == exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1345_$_2[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_3);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.77 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.77 for FactorialContChannel.initImpState." } (Fractions(100) <= exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R]) ==> (0 <= exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$N]));
	assume exhaleMask#_1345_$_4 == exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState := exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R := exhaleMask#_1345_$_3[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initImpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_4);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.95 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.95 for FactorialContChannel.imp." } (monitorK <= exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$N]));
	assume exhaleMask#_1345_$_5 == exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := exhaleMask#_1345_$_4[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_5);
	assert { :msg "  785.6: The precondition at 839.11 might not hold. The permission at 839.113 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 839.11 might not hold. Insufficient fraction at 839.113 for FactorialContChannelImpEP.impch." } (monitorK <= exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1345_$_6 == exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1345_$_5[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_6);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.11 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.11 for FactorialCont.cust." } (monitorK <= exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R]) && ((monitorK == exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R]) ==> (0 <= exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$N]));
	assume exhaleMask#_1345_$_7 == exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust := exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R := exhaleMask#_1345_$_6[nw#_1321_$_0,FactorialCont.cust][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_7);
	if ($_$_condition_$18) { goto anon90_Then; } else { goto anon90_Else; }
anon90_Then:
	assume !(Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.46 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.46 for FactorialCont.q." } (monitorK <= exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$N]));
	assume exhaleMask#_1345_$_8 == exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q := exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R := exhaleMask#_1345_$_7[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_8);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.81 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.81 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1345_$_9 == exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1345_$_8[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_9);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.97 might not be positive." } Fractions(100) > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.97 for FactorialContChannel.initExpState." } (Fractions(100) <= exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1345_$_10 == exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState := exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R := exhaleMask#_1345_$_9[Heap_$_92[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_10);
	assert { :msg "  785.6: The precondition at 840.11 might not hold. The permission at 840.120 might not be positive." } monitorK > 0;
	assert { :msg "  785.6: The precondition at 840.11 might not hold. Insufficient fraction at 840.120 for FactorialCont.vo." } (monitorK <= exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$N]));
	assume exhaleMask#_1345_$_11 == exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo := exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R := exhaleMask#_1345_$_10[Heap_$_92[nw#_1321_$_0,FactorialCont.cust],FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_95);
	assume wf(Heap_$_92,Mask_$_95);
	assume wf(Heap_$_92,exhaleMask#_1345_$_11);
	assume exhaleMask#_1345_$_12 == exhaleMask#_1345_$_11;
	goto anon47;
anon90_Else:
	assume Heap_$_92[nw#_1321_$_0,FactorialCont.cust] == null;
	assume exhaleMask#_1345_$_12 == exhaleMask#_1345_$_7;
	goto anon47;
anon47:
	assume wf(Heap_$_92,exhaleMask#_1345_$_12);
	assume !(token#_1338_$_0 == null);
	assume Heap_$_92[token#_1338_$_0,joinable] == 0;
	assume exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$N] == 0;
	assume exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$R] == 0;
	assume Mask_$_96 == exhaleMask#_1345_$_12[token#_1338_$_0,joinable := exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$R := exhaleMask#_1345_$_12[token#_1338_$_0,joinable][perm$R] + Fractions(100)]];
	assume !(asyncstate#_1339_$_0 == 0);
	assume Heap_$_93 == Heap_$_92[token#_1338_$_0,joinable := asyncstate#_1339_$_0];
	assume Heap_$_94 == Heap_$_93[token#_1338_$_0,forkK := asyncMethodCallK#_1344];
	assume Call$Heap(asyncstate#_1339_$_0) == Heap_$_92;
	assume Call$Mask(asyncstate#_1339_$_0) == Mask_$_95;
	assume Call$Credits(asyncstate#_1339_$_0) == Credits_$_4;
	assume Call$Args(asyncstate#_1339_$_0) == argsSeq#_1343_$_0;
	assume wf(Heap_$_94,Mask_$_96);
	assume (!(nw#_1358_$_0 == null)) && (dtype(nw#_1358_$_0) == Message#t);
	assume (forall<T#_16> f_$17 : Field (T#_16)  :: ( (Mask_$_96[nw#_1358_$_0,f_$17][perm$R] == 0) && (Mask_$_96[nw#_1358_$_0,f_$17][perm$N] == 0) ));
	assume Heap_$_94[nw#_1358_$_0,mu] == $LockBottom;
	assume Heap_$_94[nw#_1358_$_0,held] <= 0;
	assume Heap_$_94[nw#_1358_$_0,rdheld] <==> false;
	assume Mask_$_97 == Mask_$_96[nw#_1358_$_0,Message.type := Mask_$_96[nw#_1358_$_0,Message.type][perm$R := Mask_$_96[nw#_1358_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_98 == Mask_$_97[nw#_1358_$_0,Message.sender1 := Mask_$_97[nw#_1358_$_0,Message.sender1][perm$R := Mask_$_97[nw#_1358_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_99 == Mask_$_98[nw#_1358_$_0,Message.sender3 := Mask_$_98[nw#_1358_$_0,Message.sender3][perm$R := Mask_$_98[nw#_1358_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_100 == Mask_$_99[nw#_1358_$_0,Message.sender2 := Mask_$_99[nw#_1358_$_0,Message.sender2][perm$R := Mask_$_99[nw#_1358_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_101 == Mask_$_100[nw#_1358_$_0,Message.sender4 := Mask_$_100[nw#_1358_$_0,Message.sender4][perm$R := Mask_$_100[nw#_1358_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_102 == Mask_$_101[nw#_1358_$_0,Message.receiver1 := Mask_$_101[nw#_1358_$_0,Message.receiver1][perm$R := Mask_$_101[nw#_1358_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_103 == Mask_$_102[nw#_1358_$_0,Message.receiver2 := Mask_$_102[nw#_1358_$_0,Message.receiver2][perm$R := Mask_$_102[nw#_1358_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_104 == Mask_$_103[nw#_1358_$_0,Message.receiver3 := Mask_$_103[nw#_1358_$_0,Message.receiver3][perm$R := Mask_$_103[nw#_1358_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_105 == Mask_$_104[nw#_1358_$_0,Message.receiver4 := Mask_$_104[nw#_1358_$_0,Message.receiver4][perm$R := Mask_$_104[nw#_1358_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_106 == Mask_$_105[nw#_1358_$_0,Message.v1 := Mask_$_105[nw#_1358_$_0,Message.v1][perm$R := Mask_$_105[nw#_1358_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_107 == Mask_$_106[nw#_1358_$_0,Message.vo1 := Mask_$_106[nw#_1358_$_0,Message.vo1][perm$R := Mask_$_106[nw#_1358_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_108 == Mask_$_107[nw#_1358_$_0,Message.cust1 := Mask_$_107[nw#_1358_$_0,Message.cust1][perm$R := Mask_$_107[nw#_1358_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_109 == Mask_$_108[nw#_1358_$_0,Message.vr1 := Mask_$_108[nw#_1358_$_0,Message.vr1][perm$R := Mask_$_108[nw#_1358_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_110 == Mask_$_109[nw#_1358_$_0,Message.old1 := Mask_$_109[nw#_1358_$_0,Message.old1][perm$R := Mask_$_109[nw#_1358_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_111 == Mask_$_110[nw#_1358_$_0,Message.vr2 := Mask_$_110[nw#_1358_$_0,Message.vr2][perm$R := Mask_$_110[nw#_1358_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_112 == Mask_$_111[nw#_1358_$_0,Message.old2 := Mask_$_111[nw#_1358_$_0,Message.old2][perm$R := Mask_$_111[nw#_1358_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_113 == Mask_$_112[nw#_1358_$_0,Message.vr3 := Mask_$_112[nw#_1358_$_0,Message.vr3][perm$R := Mask_$_112[nw#_1358_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_114 == Mask_$_113[nw#_1358_$_0,mu := Mask_$_113[nw#_1358_$_0,mu][perm$R := Mask_$_113[nw#_1358_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  788.6: Location might not be writable" } CanWrite(Mask_$_114,nw#_1358_$_0,Message.sender1);
	assert { :msg "  788.17: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  788.17: Location might not be readable." } true ==> CanRead(Mask_$_114,mo#131_$_0,Message.sender1);
	assume Heap_$_95 == Heap_$_94[nw#_1358_$_0,Message.sender1 := Heap_$_94[mo#131_$_0,Message.sender1]];
	assume wf(Heap_$_95,Mask_$_114);
	assume ((0 < methodCallK#_1362) && ((1000 * methodCallK#_1362) < Fractions(1))) && ((1000 * methodCallK#_1362) < whileK#_1176);
	assert { :msg "  789.6: The target of the method call might be null." } !(nw#_1358_$_0 == null);
	assert { :msg "  789.22: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  789.22: Location might not be readable." } true ==> CanRead(Mask_$_114,mo#131_$_0,Message.v1);
	assert { :msg "  789.35: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  789.35: Location might not be readable." } true ==> CanRead(Mask_$_114,mo#131_$_0,Message.vo1);
	assume v#149_$_0 == (Heap_$_95[mo#131_$_0,Message.v1] - 1);
	assume vo#150_$_0 == Heap_$_95[mo#131_$_0,Message.vo1];
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 661.3 might not evaluate to true." } !(Heap_$_95[nw#_1358_$_0,Message.sender1] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 661.42 might not evaluate to true." } !(Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 662.48 might not evaluate to true." } v#149_$_0 >= 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 662.56 might not evaluate to true." } vo#150_$_0 >= 0;
	if ($_$_condition_$19) { goto anon91_Then; } else { goto anon91_Else; }
anon91_Then:
	assume nw#_1321_$_0 == null;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 663.19 might not evaluate to true." } v#149_$_0 == vo#150_$_0;
	if ($_$_condition_$20) { goto anon92_Then; } else { goto anon92_Else; }
anon91_Else:
	assume !(nw#_1321_$_0 == null);
	if ($_$_condition_$21) { goto anon92_Then; } else { goto anon92_Else; }
anon92_Then:
	assume !(nw#_1321_$_0 == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 664.23 might not evaluate to true." } !(Heap_$_95[nw#_1321_$_0,FactorialCont.q] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 665.55 might not evaluate to true." } !(Heap_$_95[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch] == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 666.23 might not evaluate to true." } v#149_$_0 == (Heap_$_95[nw#_1321_$_0,FactorialCont.v] - 1);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The expression at 666.38 might not evaluate to true." } vo#150_$_0 == Heap_$_95[nw#_1321_$_0,FactorialCont.vo];
	goto anon53;
anon92_Else:
	assume nw#_1321_$_0 == null;
	goto anon53;
anon53:
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.11 for Message.type." } (Fractions(100) <= Mask_$_114[nw#_1358_$_0,Message.type][perm$R]) && ((Fractions(100) == Mask_$_114[nw#_1358_$_0,Message.type][perm$R]) ==> (0 <= Mask_$_114[nw#_1358_$_0,Message.type][perm$N]));
	assume exhaleMask#_1363_$_0 == Mask_$_114[nw#_1358_$_0,Message.type := Mask_$_114[nw#_1358_$_0,Message.type][perm$R := Mask_$_114[nw#_1358_$_0,Message.type][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_0);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.24 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.24 for Message.sender1." } (Fractions(100) <= exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R]) ==> (0 <= exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$N]));
	assume exhaleMask#_1363_$_1 == exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1 := exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R := exhaleMask#_1363_$_0[nw#_1358_$_0,Message.sender1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_1);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 659.40 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 659.40 for Message.receiver1." } (Fractions(100) <= exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R]) ==> (0 <= exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$N]));
	assume exhaleMask#_1363_$_2 == exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1 := exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R := exhaleMask#_1363_$_1[nw#_1358_$_0,Message.receiver1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_2);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.3 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.3 for Message.v1." } (Fractions(100) <= exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R]) ==> (0 <= exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$N]));
	assume exhaleMask#_1363_$_3 == exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1 := exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R := exhaleMask#_1363_$_2[nw#_1358_$_0,Message.v1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_3);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.14 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.14 for Message.vo1." } (Fractions(100) <= exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R]) ==> (0 <= exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$N]));
	assume exhaleMask#_1363_$_4 == exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1 := exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R := exhaleMask#_1363_$_3[nw#_1358_$_0,Message.vo1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_4);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 660.26 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 660.26 for Message.cust1." } (Fractions(100) <= exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R]) ==> (0 <= exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$N]));
	assume exhaleMask#_1363_$_5 == exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1 := exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R := exhaleMask#_1363_$_4[nw#_1358_$_0,Message.cust1][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_5);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 661.20 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 661.20 for Future.q." } (monitorK <= exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R]) && ((monitorK == exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R]) ==> (0 <= exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$N]));
	assume exhaleMask#_1363_$_6 == exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q := exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R := exhaleMask#_1363_$_5[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_6);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 662.3 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 662.3 for FutureChannel.valid." } (Fractions(100) <= exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$N]));
	assume exhaleMask#_1363_$_7 == exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid := exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R := exhaleMask#_1363_$_6[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_7);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 662.22 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 662.22 for FutureChannel.initExpState." } (Fractions(100) <= exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$N]));
	assume exhaleMask#_1363_$_8 == exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState := exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R := exhaleMask#_1363_$_7[Heap_$_95[Heap_$_95[nw#_1358_$_0,Message.sender1],Future.q],FutureChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_8);
	if ($_$_condition_$22) { goto anon93_Then; } else { goto anon93_Else; }
anon93_Then:
	assume nw#_1321_$_0 == null;
	if ($_$_condition_$23) { goto anon94_Then; } else { goto anon94_Else; }
anon93_Else:
	assume !(nw#_1321_$_0 == null);
	if ($_$_condition_$24) { goto anon94_Then; } else { goto anon94_Else; }
anon94_Then:
	assume !(nw#_1321_$_0 == null);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.4 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.4 for FactorialCont.q." } (monitorK <= exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R]) && ((monitorK == exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R]) ==> (0 <= exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$N]));
	assume exhaleMask#_1363_$_9 == exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q := exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R := exhaleMask#_1363_$_8[nw#_1321_$_0,FactorialCont.q][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_9);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.39 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.39 for FactorialContChannel.valid." } (Fractions(100) <= exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R]) ==> (0 <= exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$N]));
	assume exhaleMask#_1363_$_10 == exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid := exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R := exhaleMask#_1363_$_9[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_10);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 664.55 might not be positive." } Fractions(100) > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 664.55 for FactorialContChannel.initExpState." } (Fractions(100) <= exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) && ((Fractions(100) == exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R]) ==> (0 <= exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$N]));
	assume exhaleMask#_1363_$_11 == exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState := exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R := exhaleMask#_1363_$_10[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.initExpState][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_11);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.3 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.3 for FactorialContChannel.imp." } (monitorK <= exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) && ((monitorK == exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R]) ==> (0 <= exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$N]));
	assume exhaleMask#_1363_$_12 == exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp := exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R := exhaleMask#_1363_$_11[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_12);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.26 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.26 for FactorialContChannelImpEP.impch." } (monitorK <= exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) && ((monitorK == exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R]) ==> (0 <= exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$N]));
	assume exhaleMask#_1363_$_13 == exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch := exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R := exhaleMask#_1363_$_12[Heap_$_95[Heap_$_95[nw#_1321_$_0,FactorialCont.q],FactorialContChannel.imp],FactorialContChannelImpEP.impch][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_13);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 665.81 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 665.81 for FactorialCont.v." } (monitorK <= exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R]) && ((monitorK == exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R]) ==> (0 <= exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$N]));
	assume exhaleMask#_1363_$_14 == exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v := exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R := exhaleMask#_1363_$_13[nw#_1321_$_0,FactorialCont.v][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_14);
	assert { :msg "  789.6: The precondition at 659.11 might not hold. The permission at 666.3 might not be positive." } monitorK > 0;
	assert { :msg "  789.6: The precondition at 659.11 might not hold. Insufficient fraction at 666.3 for FactorialCont.vo." } (monitorK <= exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R]) && ((monitorK == exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R]) ==> (0 <= exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$N]));
	assume exhaleMask#_1363_$_15 == exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo := exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R := exhaleMask#_1363_$_14[nw#_1321_$_0,FactorialCont.vo][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_114);
	assume wf(Heap_$_95,Mask_$_114);
	assume wf(Heap_$_95,exhaleMask#_1363_$_15);
	assume exhaleMask#_1363_$_16 == exhaleMask#_1363_$_15;
	goto anon59;
anon94_Else:
	assume nw#_1321_$_0 == null;
	assume exhaleMask#_1363_$_16 == exhaleMask#_1363_$_8;
	goto anon59;
anon59:
	assume wf(Heap_$_95,exhaleMask#_1363_$_16);
	assume IsGoodInhaleState(inhaleHeap#_1382_$_0,Heap_$_95,exhaleMask#_1363_$_16);
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_96 == Heap_$_95[nw#_1358_$_0,Message.invValue := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.invValue]];
	assume wf(Heap_$_96,exhaleMask#_1363_$_16);
	assume inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.invValue] == Heap_$_96;
	assume Fractions(100) > 0;
	assume Mask_$_115 == exhaleMask#_1363_$_16[nw#_1358_$_0,Message.invValue := exhaleMask#_1363_$_16[nw#_1358_$_0,Message.invValue][perm$R := exhaleMask#_1363_$_16[nw#_1358_$_0,Message.invValue][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_115);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.invValue]);
	assume wf(Heap_$_96,Mask_$_115);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_115);
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_97 == Heap_$_96[nw#_1358_$_0,Message.type := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]];
	assume wf(Heap_$_97,Mask_$_115);
	assume true;
	assume monitorK > 0;
	assume Mask_$_116 == Mask_$_115[nw#_1358_$_0,Message.type := Mask_$_115[nw#_1358_$_0,Message.type][perm$R := Mask_$_115[nw#_1358_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_116);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]);
	assume wf(Heap_$_97,Mask_$_116);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_116);
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_98 == Heap_$_97[nw#_1358_$_0,Message.type := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]];
	assume wf(Heap_$_98,Mask_$_116);
	assume true;
	assume monitorK > 0;
	assume Mask_$_117 == Mask_$_116[nw#_1358_$_0,Message.type := Mask_$_116[nw#_1358_$_0,Message.type][perm$R := Mask_$_116[nw#_1358_$_0,Message.type][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_117);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.type]);
	assume wf(Heap_$_98,Mask_$_117);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_117);
	assume Heap_$_98[nw#_1358_$_0,Message.type] == 1;
	assume !(nw#_1358_$_0 == null);
	assume Heap_$_99 == Heap_$_98[nw#_1358_$_0,Message.vo1 := inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.vo1]];
	assume wf(Heap_$_99,Mask_$_117);
	assume true;
	assume monitorK > 0;
	assume Mask_$_118 == Mask_$_117[nw#_1358_$_0,Message.vo1 := Mask_$_117[nw#_1358_$_0,Message.vo1][perm$R := Mask_$_117[nw#_1358_$_0,Message.vo1][perm$R] + monitorK]];
	assume IsGoodMask(Mask_$_118);
	assume IsGoodState(inhaleHeap#_1382_$_0[nw#_1358_$_0,Message.vo1]);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(inhaleHeap#_1382_$_0,Mask_$_118);
	assume Heap_$_99[nw#_1358_$_0,Message.vo1] >= 0;
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume ((0 < methodCallK#_1386) && ((1000 * methodCallK#_1386) < Fractions(1))) && ((1000 * methodCallK#_1386) < whileK#_1176);
	assert { :msg "  790.11: Receiver might be null." } true ==> (!(this == null));
	assert { :msg "  790.11: Location might not be readable." } true ==> CanRead(Mask_$_118,this,FactorialActor.q);
	assert { :msg "  790.11: Receiver might be null." } true ==> (!(Heap_$_99[this,FactorialActor.q] == null));
	assert { :msg "  <undefined position>: Location might not be readable." } true ==> CanRead(Mask_$_118,Heap_$_99[this,FactorialActor.q],FactorialActorChannel.exp);
	assert { :msg "  790.6: The target of the method call might be null." } !(Heap_$_99[Heap_$_99[this,FactorialActor.q],FactorialActorChannel.exp] == null);
	assume this#153_$_0 == Heap_$_99[Heap_$_99[this,FactorialActor.q],FactorialActorChannel.exp];
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The expression at 34.63 might not evaluate to true." } Heap_$_99[nw#_1358_$_0,Message.type] == 1;
	assert { :msg "  790.6: The precondition at 36.11 might not hold. The expression at 36.11 might not evaluate to true." } Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.11 for FactorialActorChannelExpEP.state." } (Fractions(100) <= Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R]) && ((Fractions(100) == Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R]) ==> (0 <= Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$N]));
	assume exhaleMask#_1387_$_0 == Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state := Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R := Mask_$_118[this#153_$_0,FactorialActorChannelExpEP.state][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_0);
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.25 might not be positive." } monitorK > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.25 for Message.type." } (monitorK <= exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$N]));
	assume exhaleMask#_1387_$_1 == exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type := exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R := exhaleMask#_1387_$_0[nw#_1358_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_1);
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.44 might not be positive." } monitorK > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.44 for Message.type." } (monitorK <= exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R]) && ((monitorK == exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R]) ==> (0 <= exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$N]));
	assume exhaleMask#_1387_$_2 == exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type := exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R := exhaleMask#_1387_$_1[nw#_1358_$_0,Message.type][perm$R] - monitorK]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_2);
	assert { :msg "  790.6: The precondition at 34.11 might not hold. The permission at 34.76 might not be positive." } Fractions(100) > 0;
	assert { :msg "  790.6: The precondition at 34.11 might not hold. Insufficient fraction at 34.76 for Message.invValue." } (Fractions(100) <= exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R]) && ((Fractions(100) == exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R]) ==> (0 <= exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$N]));
	assume exhaleMask#_1387_$_3 == exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue := exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R := exhaleMask#_1387_$_2[nw#_1358_$_0,Message.invValue][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_3);
	assert { :msg "  790.6: The precondition at 35.11 might not hold. The permission at 35.11 might not be positive." } Fractions(100) > 0;
	assert { :msg "  790.6: The precondition at 35.11 might not hold. Insufficient fraction at 35.11 for FactorialActorChannelExpEP.valid." } (Fractions(100) <= exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R]) && ((Fractions(100) == exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R]) ==> (0 <= exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$N]));
	assume exhaleMask#_1387_$_4 == exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid := exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R := exhaleMask#_1387_$_3[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R] - Fractions(100)]];
	assume IsGoodMask(Mask_$_118);
	assume wf(Heap_$_99,Mask_$_118);
	assume wf(Heap_$_99,exhaleMask#_1387_$_4);
	assume wf(Heap_$_99,exhaleMask#_1387_$_4);
	assume IsGoodInhaleState(inhaleHeap#_1395_$_0,Heap_$_99,exhaleMask#_1387_$_4);
	assume !(this#153_$_0 == null);
	assume Heap_$_100 == Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state := inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.state]];
	assume wf(Heap_$_100,exhaleMask#_1387_$_4);
	assume true;
	assume Fractions(100) > 0;
	assume Mask_$_119 == exhaleMask#_1387_$_4[this#153_$_0,FactorialActorChannelExpEP.state := exhaleMask#_1387_$_4[this#153_$_0,FactorialActorChannelExpEP.state][perm$R := exhaleMask#_1387_$_4[this#153_$_0,FactorialActorChannelExpEP.state][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_119);
	assume IsGoodState(inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.state]);
	assume wf(Heap_$_100,Mask_$_119);
	assume wf(inhaleHeap#_1395_$_0,Mask_$_119);
	assume !(this#153_$_0 == null);
	assume Heap_$_101 == Heap_$_100[this#153_$_0,FactorialActorChannelExpEP.valid := inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.valid]];
	assume wf(Heap_$_101,Mask_$_119);
	assume inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.valid] == Heap_$_101;
	assume Fractions(100) > 0;
	assume Mask_$_120 == Mask_$_119[this#153_$_0,FactorialActorChannelExpEP.valid := Mask_$_119[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R := Mask_$_119[this#153_$_0,FactorialActorChannelExpEP.valid][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_120);
	assume IsGoodState(inhaleHeap#_1395_$_0[this#153_$_0,FactorialActorChannelExpEP.valid]);
	assume wf(Heap_$_101,Mask_$_120);
	assume wf(inhaleHeap#_1395_$_0,Mask_$_120);
	if ($_$_condition_$25) { goto anon95_Then; } else { goto anon95_Else; }
anon95_Then:
	assume Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0;
	assume Heap_$_101[this#153_$_0,FactorialActorChannelExpEP.state] == 0;
	goto anon62;
anon95_Else:
	assume !(Heap_$_99[this#153_$_0,FactorialActorChannelExpEP.state] == 0);
	goto anon62;
anon62:
	assume IsGoodMask(Mask_$_120);
	assume wf(Heap_$_101,Mask_$_120);
	assume (!(nw#_1396_$_0 == null)) && (dtype(nw#_1396_$_0) == Message#t);
	assume (forall<T#_17> f_$18 : Field (T#_17)  :: ( (Mask_$_120[nw#_1396_$_0,f_$18][perm$R] == 0) && (Mask_$_120[nw#_1396_$_0,f_$18][perm$N] == 0) ));
	assume Heap_$_101[nw#_1396_$_0,mu] == $LockBottom;
	assume Heap_$_101[nw#_1396_$_0,held] <= 0;
	assume Heap_$_101[nw#_1396_$_0,rdheld] <==> false;
	assume Mask_$_121 == Mask_$_120[nw#_1396_$_0,Message.type := Mask_$_120[nw#_1396_$_0,Message.type][perm$R := Mask_$_120[nw#_1396_$_0,Message.type][perm$R] + Fractions(100)]];
	assume Mask_$_122 == Mask_$_121[nw#_1396_$_0,Message.sender1 := Mask_$_121[nw#_1396_$_0,Message.sender1][perm$R := Mask_$_121[nw#_1396_$_0,Message.sender1][perm$R] + Fractions(100)]];
	assume Mask_$_123 == Mask_$_122[nw#_1396_$_0,Message.sender3 := Mask_$_122[nw#_1396_$_0,Message.sender3][perm$R := Mask_$_122[nw#_1396_$_0,Message.sender3][perm$R] + Fractions(100)]];
	assume Mask_$_124 == Mask_$_123[nw#_1396_$_0,Message.sender2 := Mask_$_123[nw#_1396_$_0,Message.sender2][perm$R := Mask_$_123[nw#_1396_$_0,Message.sender2][perm$R] + Fractions(100)]];
	assume Mask_$_125 == Mask_$_124[nw#_1396_$_0,Message.sender4 := Mask_$_124[nw#_1396_$_0,Message.sender4][perm$R := Mask_$_124[nw#_1396_$_0,Message.sender4][perm$R] + Fractions(100)]];
	assume Mask_$_126 == Mask_$_125[nw#_1396_$_0,Message.receiver1 := Mask_$_125[nw#_1396_$_0,Message.receiver1][perm$R := Mask_$_125[nw#_1396_$_0,Message.receiver1][perm$R] + Fractions(100)]];
	assume Mask_$_127 == Mask_$_126[nw#_1396_$_0,Message.receiver2 := Mask_$_126[nw#_1396_$_0,Message.receiver2][perm$R := Mask_$_126[nw#_1396_$_0,Message.receiver2][perm$R] + Fractions(100)]];
	assume Mask_$_128 == Mask_$_127[nw#_1396_$_0,Message.receiver3 := Mask_$_127[nw#_1396_$_0,Message.receiver3][perm$R := Mask_$_127[nw#_1396_$_0,Message.receiver3][perm$R] + Fractions(100)]];
	assume Mask_$_129 == Mask_$_128[nw#_1396_$_0,Message.receiver4 := Mask_$_128[nw#_1396_$_0,Message.receiver4][perm$R := Mask_$_128[nw#_1396_$_0,Message.receiver4][perm$R] + Fractions(100)]];
	assume Mask_$_130 == Mask_$_129[nw#_1396_$_0,Message.v1 := Mask_$_129[nw#_1396_$_0,Message.v1][perm$R := Mask_$_129[nw#_1396_$_0,Message.v1][perm$R] + Fractions(100)]];
	assume Mask_$_131 == Mask_$_130[nw#_1396_$_0,Message.vo1 := Mask_$_130[nw#_1396_$_0,Message.vo1][perm$R := Mask_$_130[nw#_1396_$_0,Message.vo1][perm$R] + Fractions(100)]];
	assume Mask_$_132 == Mask_$_131[nw#_1396_$_0,Message.cust1 := Mask_$_131[nw#_1396_$_0,Message.cust1][perm$R := Mask_$_131[nw#_1396_$_0,Message.cust1][perm$R] + Fractions(100)]];
	assume Mask_$_133 == Mask_$_132[nw#_1396_$_0,Message.vr1 := Mask_$_132[nw#_1396_$_0,Message.vr1][perm$R := Mask_$_132[nw#_1396_$_0,Message.vr1][perm$R] + Fractions(100)]];
	assume Mask_$_134 == Mask_$_133[nw#_1396_$_0,Message.old1 := Mask_$_133[nw#_1396_$_0,Message.old1][perm$R := Mask_$_133[nw#_1396_$_0,Message.old1][perm$R] + Fractions(100)]];
	assume Mask_$_135 == Mask_$_134[nw#_1396_$_0,Message.vr2 := Mask_$_134[nw#_1396_$_0,Message.vr2][perm$R := Mask_$_134[nw#_1396_$_0,Message.vr2][perm$R] + Fractions(100)]];
	assume Mask_$_136 == Mask_$_135[nw#_1396_$_0,Message.old2 := Mask_$_135[nw#_1396_$_0,Message.old2][perm$R := Mask_$_135[nw#_1396_$_0,Message.old2][perm$R] + Fractions(100)]];
	assume Mask_$_137 == Mask_$_136[nw#_1396_$_0,Message.vr3 := Mask_$_136[nw#_1396_$_0,Message.vr3][perm$R := Mask_$_136[nw#_1396_$_0,Message.vr3][perm$R] + Fractions(100)]];
	assume Mask_$_138 == Mask_$_137[nw#_1396_$_0,mu := Mask_$_137[nw#_1396_$_0,mu][perm$R := Mask_$_137[nw#_1396_$_0,mu][perm$R] + Fractions(100)]];
	assert { :msg "  793.6: Location might not be writable" } CanWrite(Mask_$_138,nw#_1396_$_0,Message.type);
	assume Heap_$_102 == Heap_$_101[nw#_1396_$_0,Message.type := 4];
	assume wf(Heap_$_102,Mask_$_138);
	assert { :msg "  794.13: Receiver might be null." } true ==> (!(nw#_1396_$_0 == null));
	assert { :msg "  794.13: Location might not be readable." } true ==> CanRead(Mask_$_138,nw#_1396_$_0,Message.vr3);
	assert { :msg "  794.32: Receiver might be null." } true ==> (!(nw#_1358_$_0 == null));
	assert { :msg "  794.32: Location might not be readable." } true ==> CanRead(Mask_$_138,nw#_1358_$_0,Message.vo1);
	assert { :msg "  794.20: Receiver might be null." } true ==> (!(nw#_1358_$_0 == null));
	assume (0 < funcappK#_1410) && ((1000 * funcappK#_1410) < Fractions(1));
	assume true;
	assert { :msg "  794.20: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_102[nw#_1358_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_102,Mask_$_138);
	if ($_$_condition_$26) { goto anon96_Then; } else { goto anon96_Else; }
anon96_Then:
	assume Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]);
	assert { :msg "  794.43: Receiver might be null." } true ==> (!(nw#_1396_$_0 == null));
	assert { :msg "  794.43: Location might not be readable." } true ==> CanRead(Mask_$_138,nw#_1396_$_0,Message.vr3);
	assert { :msg "  794.62: Receiver might be null." } true ==> (!(mo#131_$_0 == null));
	assert { :msg "  794.62: Location might not be readable." } true ==> CanRead(Mask_$_138,mo#131_$_0,Message.vo1);
	assert { :msg "  794.50: Receiver might be null." } true ==> (!(nw#_1358_$_0 == null));
	assume (0 < funcappK#_1418) && ((1000 * funcappK#_1418) < Fractions(1));
	assume true;
	assert { :msg "  794.50: Precondition at 617.11 might not hold. The expression at 617.11 might not evaluate to true." } Heap_$_102[mo#131_$_0,Message.vo1] >= 0;
	assume wf(Heap_$_102,Mask_$_138);
	assert { :msg "  794.6: Assertion might not hold. The expression at 794.43 might not evaluate to true." } Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[mo#131_$_0,Message.vo1]);
	if ($_$_condition_$27) { goto anon97_Then; } else { goto anon97_Else; }
anon96_Else:
	assume !(Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	if ($_$_condition_$28) { goto anon97_Then; } else { goto anon97_Else; }
anon97_Then:
	assume Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]);
	goto anon68;
anon97_Else:
	assume !(Heap_$_102[nw#_1396_$_0,Message.vr3] == #Message.factorial(Heap_$_102,Mask_$_138,nw#_1358_$_0,Heap_$_102[nw#_1358_$_0,Message.vo1]));
	goto anon68;
anon68:
	assume wf(Heap_$_102,Mask_$_138);
	assume Mask_$_221 == Mask_$_138;
	assume Credits_$_7 == Credits_$_6;
	assume Heap_$_134 == Heap_$_102;
	goto anon70;
}
