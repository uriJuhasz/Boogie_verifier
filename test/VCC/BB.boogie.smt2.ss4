(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@$kind 0)
(declare-fun $kind_composite () T@$kind)
(declare-fun $kind_primitive () T@$kind)
(declare-fun $kind_array () T@$kind)
(declare-fun $kind_thread () T@$kind)
(declare-sort T@$ctype 0)
(declare-fun ^^i1 () T@$ctype)
(declare-fun ^^i2 () T@$ctype)
(declare-fun ^^i4 () T@$ctype)
(declare-fun ^^i8 () T@$ctype)
(declare-fun ^^u1 () T@$ctype)
(declare-fun ^^u2 () T@$ctype)
(declare-fun ^^u4 () T@$ctype)
(declare-fun ^^u8 () T@$ctype)
(declare-fun ^^void () T@$ctype)
(declare-fun ^^bool () T@$ctype)
(declare-fun ^^f4 () T@$ctype)
(declare-fun ^^f8 () T@$ctype)
(declare-fun ^^claim () T@$ctype)
(declare-fun ^^root_emb () T@$ctype)
(declare-fun ^^mathint () T@$ctype)
(declare-fun |^$#thread_id_t| () T@$ctype)
(declare-fun |^$#ptrset| () T@$ctype)
(declare-fun |^$#state_t| () T@$ctype)
(declare-fun |^$#struct| () T@$ctype)
(declare-fun $memory_allocator_type () T@$ctype)
(declare-sort T@$ptr 0)
(declare-fun $no_claim () T@$ptr)
(declare-sort T@$pure_function 0)
(declare-fun |cf#classifier#default| () T@$pure_function)
(declare-sort T@cf_event 0)
(declare-fun conditional_moment () T@cf_event)
(declare-fun took_then_branch () T@cf_event)
(declare-fun took_else_branch () T@cf_event)
(declare-fun loop_register () T@cf_event)
(declare-fun loop_entered () T@cf_event)
(declare-fun loop_exited () T@cf_event)
(declare-sort T@var_locglob 0)
(declare-fun cev_local () T@var_locglob)
(declare-fun cev_global () T@var_locglob)
(declare-fun cev_parameter () T@var_locglob)
(declare-fun cev_implicit () T@var_locglob)
(declare-fun |^$#thread_id| () T@$ctype)
(declare-fun ^A () T@$ctype)
(declare-sort T@$field 0)
(declare-fun A.$owns () T@$field)
(declare-fun A.x () T@$field)
(declare-sort T@$label 0)
(declare-fun |l#public| () T@$label)
(declare-sort T@$token 0)
(declare-fun |#tok$1^49.25| () T@$token)
(declare-fun |#tok$1^48.25| () T@$token)
(declare-fun |#tok$1^42.19| () T@$token)
(declare-fun |#tok$1^43.5| () T@$token)
(declare-fun |#tok$1^37.19| () T@$token)
(declare-fun |#tok$1^39.33| () T@$token)
(declare-fun |#tok$1^38.5| () T@$token)
(declare-fun |#tok$1^9.5| () T@$token)
(declare-fun |#tok$1^7.5| () T@$token)
(declare-fun |#loc.res#3| () T@$token)
(declare-fun |#tok$1^38.9| () T@$token)
(declare-fun |#loc.Exchange#2| () T@$token)
(declare-fun |#tok$1^38.43| () T@$token)
(declare-fun |#distTp3| () T@$ctype)
(declare-fun |#loc.Destination#1| () T@$token)
(declare-fun |#tok$1^38.36| () T@$token)
(declare-fun |#tok$1^33.27| () T@$token)
(declare-fun |#tok$1^27.19| () T@$token)
(declare-fun |#tok$1^29.33| () T@$token)
(declare-fun |#tok$1^28.5| () T@$token)
(declare-fun |#loc.y| () T@$token)
(declare-fun |#tok$1^23.3| () T@$token)
(declare-fun |#loc.z| () T@$token)
(declare-fun |#tok$1^24.3| () T@$token)
(declare-fun |#loc.c1| () T@$token)
(declare-fun |#loc.c2| () T@$token)
(declare-fun |#tok$1^25.26| () T@$token)
(declare-fun |#distTp2| () T@$ctype)
(declare-fun |#loc.c| () T@$token)
(declare-fun |#loc.a| () T@$token)
(declare-fun |#tok$1^18.1| () T@$token)
(declare-fun |#distTp1| () T@$ctype)
(declare-fun |#loc._this_| () T@$token)
(declare-fun |#tok$1^13.1| () T@$token)
(declare-fun |#file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c| () T@$token)
(declare-fun $is_primitive (T@$ctype) Bool)
(declare-fun $kind_of (T@$ctype) T@$kind)
(declare-fun $is_arraytype (T@$ctype) Bool)
(declare-fun $is_threadtype (T@$ctype) Bool)
(declare-fun $is_nested_range (T@$ctype T@$ctype Int Int) Bool)
(declare-fun $is_nested (T@$ctype T@$ctype) Bool)
(declare-fun $nesting_min (T@$ctype T@$ctype) Int)
(declare-fun $nesting_max (T@$ctype T@$ctype) Int)
(declare-fun $typ (T@$ptr) T@$ctype)
(declare-fun $ptr (T@$ctype Int) T@$ptr)
(declare-fun $ref (T@$ptr) Int)
(declare-fun $null () T@$ptr)
(declare-fun $has_volatile_owns_set (T@$ctype) Bool)
(declare-fun $position_marker () Bool)
(declare-sort T@$state 0)
(declare-fun $mutable (T@$state T@$ptr) Bool)
(declare-fun $typed (T@$state T@$ptr) Bool)
(declare-fun $owner (T@$state T@$ptr) T@$ptr)
(declare-fun $me () T@$ptr)
(declare-fun $closed (T@$state T@$ptr) Bool)
(declare-fun $in_range_phys_ptr (Int) Bool)
(declare-fun $arch_spec_ptr_start () Int)
(declare-fun $in_range_spec_ptr (Int) Bool)
(declare-fun $is_domain_root (T@$state T@$ptr) Bool)
(declare-fun $thread_local (T@$state T@$ptr) Bool)
(declare-sort T@$type_state 0)
(declare-fun $ts_is_volatile (T@$type_state) Bool)
(declare-sort T@$typemap_t 0)
(declare-fun $select.tm (T@$typemap_t T@$ptr) T@$type_state)
(declare-fun $typemap (T@$state) T@$typemap_t)
(declare-fun $ts_emb (T@$type_state) T@$ptr)
(declare-fun $in_wrapped_domain (T@$state T@$ptr) Bool)
(declare-fun $sequential (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $spans_the_same (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $depends (T@$state T@$state T@$ptr T@$ptr) Bool)
(declare-fun $inv2 (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $nonvolatile_spans_the_same (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-sort T@$version 0)
(declare-fun $read_version (T@$state T@$ptr) T@$version)
(declare-sort T@$ptrset 0)
(declare-fun $owns (T@$state T@$ptr) T@$ptrset)
(declare-fun $state_spans_the_same (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $state_nonvolatile_spans_the_same (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $domain (T@$state T@$ptr) T@$ptrset)
(declare-fun $ver_domain (T@$version) T@$ptrset)
(declare-fun $by_claim (T@$state T@$ptr T@$ptr T@$ptr) T@$ptr)
(declare-sort T@$vol_version 0)
(declare-fun $read_vol_version (T@$state T@$ptr) T@$vol_version)
(declare-fun $int_to_vol_version (Int) T@$vol_version)
(declare-sort T@$memory_t 0)
(declare-fun $select.mem (T@$memory_t T@$ptr) Int)
(declare-fun $memory (T@$state) T@$memory_t)
(declare-fun $get_memory_allocator () T@$ptr)
(declare-fun $memory_allocator_ref () Int)
(declare-fun $ptr_level (T@$ctype) Int)
(declare-fun $left_split (T@$ptr Int) T@$ptr)
(declare-fun $array (T@$ctype Int) T@$ctype)
(declare-fun $element_type (T@$ctype) T@$ctype)
(declare-fun $right_split (T@$ptr Int) T@$ptr)
(declare-fun $array_length (T@$ctype) Int)
(declare-fun $idx (T@$ptr Int T@$ctype) T@$ptr)
(declare-fun $joined_array (T@$ptr T@$ptr) T@$ptr)
(declare-fun $inlined_array (T@$ptr T@$ctype) T@$ptr)
(declare-fun $array_range (T@$state T@$ptr T@$ctype Int) T@$ptrset)
(declare-fun $array_range_no_state (T@$ptr T@$ctype Int) T@$ptrset)
(declare-fun $get_fnptr (Int T@$ctype) T@$ptr)
(declare-fun $get_fnptr_ref (Int) Int)
(declare-fun $not_shared (T@$state T@$ptr) Bool)
(declare-fun $is (T@$ptr T@$ctype) Bool)
(declare-fun $is_non_primitive (T@$ctype) Bool)
(declare-fun $is_claimable (T@$ctype) Bool)
(declare-fun $ref_cnt (T@$state T@$ptr) Int)
(declare-fun $claimed_closed (T@$state T@$ptr) Bool)
(declare-sort T@$status 0)
(declare-fun $st_ref_cnt (T@$status) Int)
(declare-sort T@$statusmap_t 0)
(declare-fun $select.sm (T@$statusmap_t T@$ptr) T@$status)
(declare-fun $statusmap (T@$state) T@$statusmap_t)
(declare-fun $account_claim (T@$state T@$ptr T@$ptr) Bool)
(declare-fun $good_state (T@$state) Bool)
(declare-fun $claims_obj (T@$ptr T@$ptr) Bool)
(declare-fun $seclbl.top () Bool)
(declare-fun $seclbl.bot () Bool)
(declare-fun $arch_ptr_size () Int)
(declare-fun $is_math_type (T@$ctype) Bool)
(declare-fun $is_composite (T@$ctype) Bool)
(declare-fun $sizeof (T@$ctype) Int)
(declare-fun $set_eq (T@$ptrset T@$ptrset) Bool)
(declare-fun $set_empty () T@$ptrset)
(declare-fun $dot (T@$ptr T@$field) T@$ptr)
(declare-fun $is_base_field (T@$field) Bool)
(declare-fun $field_parent_type (T@$field) T@$ctype)
(declare-fun $is_primitive_non_volatile_field (T@$field) Bool)
(declare-fun $owns_set_field (T@$ctype) T@$field)
(declare-fun $is_primitive_volatile_field (T@$field) Bool)
(declare-fun $field_offset (T@$field) Int)
(declare-fun $ptr_to (T@$ctype) T@$ctype)
(declare-fun $spec_ptr_to (T@$ctype) T@$ctype)
(declare-fun $file_name_is (Int T@$token) Bool)
(declare-fun %lbl%+7264 () Bool)
(declare-fun $function_entry (T@$state) Bool)
(declare-fun $s () T@$state)
(declare-fun $good_state_ext (T@$token T@$state) Bool)
(declare-fun $full_stop (T@$state) Bool)
(declare-fun $can_use_all_frame_axioms (T@$state) Bool)
(declare-fun $local_value_is (T@$state T@$token T@$token Int T@$ctype) Bool)
(declare-fun $ptr_to_int (T@$ptr) Int)
(declare-fun |P#_this_| () Int)
(declare-fun $local_value_is_ptr (T@$state T@$token T@$token T@$ptr T@$ctype) Bool)
(declare-fun |#wrTime$1^13.1| () Int)
(declare-fun $current_timestamp (T@$state) Int)
(declare-fun $is_unwrap_check () Bool)
(declare-fun $is_stuttering_check () Bool)
(declare-fun $good_for_pre_can_unwrap (T@$state) Bool)
(declare-fun |call0formal@#l@0| () T@$ptr)
(declare-fun $s@0 () T@$state)
(declare-fun %lbl%@8407 () Bool)
(declare-fun %lbl%+8264 () Bool)
(assert (and (distinct $kind_composite $kind_primitive $kind_array $kind_thread)(distinct ^^i1 ^^i2 ^^i4 ^^i8 ^^u1 ^^u2 ^^u4 ^^u8 ^^void ^^bool ^^f4 ^^f8 ^^claim ^^root_emb ^^mathint |^$#thread_id_t| |^$#ptrset| |^$#state_t| |^$#struct| $memory_allocator_type |^$#thread_id| ^A |#distTp3| |#distTp2| |#distTp1|)(distinct conditional_moment took_then_branch took_else_branch loop_register loop_entered loop_exited)(distinct cev_local cev_global cev_parameter cev_implicit)(distinct A.$owns A.x)(distinct |#tok$1^49.25| |#tok$1^48.25| |#tok$1^42.19| |#tok$1^43.5| |#tok$1^37.19| |#tok$1^39.33| |#tok$1^38.5| |#tok$1^9.5| |#tok$1^7.5| |#loc.res#3| |#tok$1^38.9| |#loc.Exchange#2| |#tok$1^38.43| |#loc.Destination#1| |#tok$1^38.36| |#tok$1^33.27| |#tok$1^27.19| |#tok$1^29.33| |#tok$1^28.5| |#loc.y| |#tok$1^23.3| |#loc.z| |#tok$1^24.3| |#loc.c1| |#loc.c2| |#tok$1^25.26| |#loc.c| |#loc.a| |#tok$1^18.1| |#loc._this_| |#tok$1^13.1| |#file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c|))
)
(assert (forall ((t T@$ctype) ) (!  (and (=> ($is_primitive t) (= ($kind_of t) $kind_primitive)) (=> (= ($kind_of t) $kind_primitive) ($is_primitive t)))
 :qid |BBbpl.127:36|
 :weight 0
 :skolemid |0|
 :pattern ( ($is_primitive t))
)))
(assert (forall ((t@@0 T@$ctype) ) (!  (and (=> ($is_arraytype t@@0) (= ($kind_of t@@0) $kind_array)) (=> (= ($kind_of t@@0) $kind_array) ($is_arraytype t@@0)))
 :qid |BBbpl.139:36|
 :weight 0
 :skolemid |1|
 :pattern ( ($is_arraytype t@@0))
)))
(assert (forall ((t@@1 T@$ctype) ) (!  (and (=> ($is_threadtype t@@1) (= ($kind_of t@@1) $kind_thread)) (=> (= ($kind_of t@@1) $kind_thread) ($is_threadtype t@@1)))
 :qid |BBbpl.145:37|
 :weight 0
 :skolemid |2|
 :pattern ( ($is_threadtype t@@1))
)))
(assert (forall ((t@@2 T@$ctype) (s T@$ctype) (q@min Int) (q@max Int) ) (!  (and (=> ($is_nested_range t@@2 s q@min q@max) (and (and ($is_nested t@@2 s) (= ($nesting_min t@@2 s) q@min)) (= ($nesting_max t@@2 s) q@max))) (=> (and (and ($is_nested t@@2 s) (= ($nesting_min t@@2 s) q@min)) (= ($nesting_max t@@2 s) q@max)) ($is_nested_range t@@2 s q@min q@max)))
 :qid |BBbpl.208:27|
 :skolemid |3|
 :pattern ( ($is_nested_range t@@2 s q@min q@max))
)))
(assert (forall ((|#t| T@$ctype) (|#b| Int) ) (! (= ($typ ($ptr |#t| |#b|)) |#t|)
 :qid |BBbpl.219:15|
 :weight 0
 :skolemid |4|
)))
(assert (forall ((|#t@@0| T@$ctype) (|#b@@0| Int) ) (! (= ($ref ($ptr |#t@@0| |#b@@0|)) |#b@@0|)
 :qid |BBbpl.220:15|
 :weight 0
 :skolemid |5|
)))
(assert (= $null ($ptr ^^void 0)))
(assert ($has_volatile_owns_set ^^claim))
(assert $position_marker)
(assert (forall ((S T@$state) (p T@$ptr) ) (!  (and (=> ($mutable S p) (and (and ($typed S p) (= ($owner S p) $me)) (not ($closed S p)))) (=> (and (and ($typed S p) (= ($owner S p) $me)) (not ($closed S p))) ($mutable S p)))
 :qid |BBbpl.366:31|
 :weight 0
 :skolemid |6|
 :pattern ( ($mutable S p))
)))
(assert (forall ((|#r| Int) ) (!  (and (=> ($in_range_phys_ptr |#r|) (and (<= 0 |#r|) (<= |#r| $arch_spec_ptr_start))) (=> (and (<= 0 |#r|) (<= |#r| $arch_spec_ptr_start)) ($in_range_phys_ptr |#r|)))
 :qid |BBbpl.380:29|
 :skolemid |7|
 :pattern ( ($in_range_phys_ptr |#r|))
)))
(assert (forall ((|#r@@0| Int) ) (!  (and (=> ($in_range_spec_ptr |#r@@0|) (or (= 0 |#r@@0|) (> |#r@@0| $arch_spec_ptr_start))) (=> (or (= 0 |#r@@0|) (> |#r@@0| $arch_spec_ptr_start)) ($in_range_spec_ptr |#r@@0|)))
 :qid |BBbpl.382:29|
 :skolemid |8|
 :pattern ( ($in_range_spec_ptr |#r@@0|))
)))
(assert (forall ((S@@0 T@$state) (p@@0 T@$ptr) ) (!  (and (=> ($is_domain_root S@@0 p@@0) true) (=> true ($is_domain_root S@@0 p@@0)))
 :qid |BBbpl.409:26|
 :skolemid |9|
 :pattern ( ($is_domain_root S@@0 p@@0))
)))
(assert (forall ((S@@1 T@$state) (p@@1 T@$ptr) ) (!  (and (=> ($thread_local S@@1 p@@1) (and ($typed S@@1 p@@1) (or (and (and (= ($kind_of ($typ p@@1)) $kind_primitive) (or (not ($ts_is_volatile ($select.tm ($typemap S@@1) p@@1))) (not ($closed S@@1 ($ts_emb ($select.tm ($typemap S@@1) p@@1)))))) (and (not (= ($kind_of ($typ ($ts_emb ($select.tm ($typemap S@@1) p@@1)))) $kind_primitive)) (or (= ($owner S@@1 ($ts_emb ($select.tm ($typemap S@@1) p@@1))) $me) ($in_wrapped_domain S@@1 ($ts_emb ($select.tm ($typemap S@@1) p@@1)))))) (and (not (= ($kind_of ($typ p@@1)) $kind_primitive)) (or (= ($owner S@@1 p@@1) $me) ($in_wrapped_domain S@@1 p@@1)))))) (=> (and ($typed S@@1 p@@1) (or (and (and (= ($kind_of ($typ p@@1)) $kind_primitive) (or (not ($ts_is_volatile ($select.tm ($typemap S@@1) p@@1))) (not ($closed S@@1 ($ts_emb ($select.tm ($typemap S@@1) p@@1)))))) (and (not (= ($kind_of ($typ ($ts_emb ($select.tm ($typemap S@@1) p@@1)))) $kind_primitive)) (or (= ($owner S@@1 ($ts_emb ($select.tm ($typemap S@@1) p@@1))) $me) ($in_wrapped_domain S@@1 ($ts_emb ($select.tm ($typemap S@@1) p@@1)))))) (and (not (= ($kind_of ($typ p@@1)) $kind_primitive)) (or (= ($owner S@@1 p@@1) $me) ($in_wrapped_domain S@@1 p@@1))))) ($thread_local S@@1 p@@1)))
 :qid |BBbpl.421:24|
 :skolemid |10|
 :pattern ( ($thread_local S@@1 p@@1))
)))
(assert (forall ((|#s1| T@$state) (|#s2| T@$state) (|#p| T@$ptr) (|#t@@1| T@$ctype) ) (!  (and (=> ($sequential |#s1| |#s2| |#p| |#t@@1|) (=> (and ($closed |#s1| |#p|) ($closed |#s2| |#p|)) ($spans_the_same |#s1| |#s2| |#p| |#t@@1|))) (=> (=> (and ($closed |#s1| |#p|) ($closed |#s2| |#p|)) ($spans_the_same |#s1| |#s2| |#p| |#t@@1|)) ($sequential |#s1| |#s2| |#p| |#t@@1|)))
 :qid |BBbpl.469:34|
 :weight 0
 :skolemid |11|
 :pattern ( ($sequential |#s1| |#s2| |#p| |#t@@1|))
)))
(assert (forall ((|#s1@@0| T@$state) (|#s2@@0| T@$state) (|#dependant| T@$ptr) (|#this| T@$ptr) ) (!  (and (=> ($depends |#s1@@0| |#s2@@0| |#dependant| |#this|) (or (or ($spans_the_same |#s1@@0| |#s2@@0| |#this| ($typ |#this|)) (or (and (not ($closed |#s1@@0| |#dependant|)) (not ($closed |#s2@@0| |#dependant|))) (and ($inv2 |#s1@@0| |#s2@@0| |#dependant| ($typ |#dependant|)) ($nonvolatile_spans_the_same |#s1@@0| |#s2@@0| |#dependant| ($typ |#dependant|))))) ($is_threadtype ($typ |#dependant|)))) (=> (or (or ($spans_the_same |#s1@@0| |#s2@@0| |#this| ($typ |#this|)) (or (and (not ($closed |#s1@@0| |#dependant|)) (not ($closed |#s2@@0| |#dependant|))) (and ($inv2 |#s1@@0| |#s2@@0| |#dependant| ($typ |#dependant|)) ($nonvolatile_spans_the_same |#s1@@0| |#s2@@0| |#dependant| ($typ |#dependant|))))) ($is_threadtype ($typ |#dependant|))) ($depends |#s1@@0| |#s2@@0| |#dependant| |#this|)))
 :qid |BBbpl.472:31|
 :weight 0
 :skolemid |12|
 :pattern ( ($depends |#s1@@0| |#s2@@0| |#dependant| |#this|))
)))
(assert (forall ((|#s1@@1| T@$state) (|#s2@@1| T@$state) (|#p@@0| T@$ptr) (|#t@@2| T@$ctype) ) (!  (and (=> ($spans_the_same |#s1@@1| |#s2@@1| |#p@@0| |#t@@2|) (and (and (and (= ($read_version |#s1@@1| |#p@@0|) ($read_version |#s2@@1| |#p@@0|)) (= ($owns |#s1@@1| |#p@@0|) ($owns |#s2@@1| |#p@@0|))) (= ($select.tm ($typemap |#s1@@1|) |#p@@0|) ($select.tm ($typemap |#s2@@1|) |#p@@0|))) ($state_spans_the_same |#s1@@1| |#s2@@1| |#p@@0| |#t@@2|))) (=> (and (and (and (= ($read_version |#s1@@1| |#p@@0|) ($read_version |#s2@@1| |#p@@0|)) (= ($owns |#s1@@1| |#p@@0|) ($owns |#s2@@1| |#p@@0|))) (= ($select.tm ($typemap |#s1@@1|) |#p@@0|) ($select.tm ($typemap |#s2@@1|) |#p@@0|))) ($state_spans_the_same |#s1@@1| |#s2@@1| |#p@@0| |#t@@2|)) ($spans_the_same |#s1@@1| |#s2@@1| |#p@@0| |#t@@2|)))
 :qid |BBbpl.477:38|
 :weight 0
 :skolemid |13|
 :pattern ( ($spans_the_same |#s1@@1| |#s2@@1| |#p@@0| |#t@@2|))
)))
(assert (forall ((|#s1@@2| T@$state) (|#s2@@2| T@$state) (|#p@@1| T@$ptr) (|#t@@3| T@$ctype) ) (!  (and (=> ($nonvolatile_spans_the_same |#s1@@2| |#s2@@2| |#p@@1| |#t@@3|) (and (and (= ($read_version |#s1@@2| |#p@@1|) ($read_version |#s2@@2| |#p@@1|)) (= ($select.tm ($typemap |#s1@@2|) |#p@@1|) ($select.tm ($typemap |#s2@@2|) |#p@@1|))) ($state_nonvolatile_spans_the_same |#s1@@2| |#s2@@2| |#p@@1| |#t@@3|))) (=> (and (and (= ($read_version |#s1@@2| |#p@@1|) ($read_version |#s2@@2| |#p@@1|)) (= ($select.tm ($typemap |#s1@@2|) |#p@@1|) ($select.tm ($typemap |#s2@@2|) |#p@@1|))) ($state_nonvolatile_spans_the_same |#s1@@2| |#s2@@2| |#p@@1| |#t@@3|)) ($nonvolatile_spans_the_same |#s1@@2| |#s2@@2| |#p@@1| |#t@@3|)))
 :qid |BBbpl.486:50|
 :weight 0
 :skolemid |14|
 :pattern ( ($nonvolatile_spans_the_same |#s1@@2| |#s2@@2| |#p@@1| |#t@@3|))
)))
(assert (forall ((S@@2 T@$state) (p@@2 T@$ptr) ) (! (= ($domain S@@2 p@@2) ($ver_domain ($read_version S@@2 p@@2)))
 :qid |BBbpl.558:30|
 :weight 0
 :skolemid |16|
 :pattern ( ($domain S@@2 p@@2))
)))
(assert (forall ((S@@3 T@$state) (c T@$ptr) (obj T@$ptr) (ptr T@$ptr) ) (! (= ($by_claim S@@3 c obj ptr) ptr)
 :qid |BBbpl.576:32|
 :weight 0
 :skolemid |17|
 :pattern ( ($by_claim S@@3 c obj ptr))
)))
(assert (forall ((S@@4 T@$state) (p@@3 T@$ptr) ) (! (= ($read_vol_version S@@4 p@@3) ($int_to_vol_version ($select.mem ($memory S@@4) p@@3)))
 :qid |BBbpl.587:40|
 :weight 0
 :skolemid |18|
 :pattern ( ($read_vol_version S@@4 p@@3))
)))
(assert (= $get_memory_allocator ($ptr $memory_allocator_type $memory_allocator_ref)))
(assert (= ($ptr_level $memory_allocator_type) 0))
(assert (forall ((a T@$ptr) (i Int) ) (! (= ($left_split a i) ($ptr ($array ($element_type ($typ a)) i) ($ref a)))
 :qid |BBbpl.771:22|
 :skolemid |20|
 :pattern ( ($left_split a i))
)))
(assert (forall ((a@@0 T@$ptr) (i@@0 Int) ) (! (= ($right_split a@@0 i@@0) ($ptr ($array ($element_type ($typ a@@0)) (- ($array_length ($typ a@@0)) i@@0)) ($ref ($idx ($ptr ($element_type ($typ a@@0)) ($ref a@@0)) i@@0 ($element_type ($typ a@@0))))))
 :qid |BBbpl.773:23|
 :skolemid |21|
 :pattern ( ($right_split a@@0 i@@0))
)))
(assert (forall ((a1 T@$ptr) (a2 T@$ptr) ) (! (= ($joined_array a1 a2) ($ptr ($array ($element_type ($typ a1)) (+ ($array_length ($typ a1)) ($array_length ($typ a2)))) ($ref a1)))
 :qid |BBbpl.776:24|
 :skolemid |22|
 :pattern ( ($joined_array a1 a2))
)))
(assert (forall ((p@@4 T@$ptr) (T T@$ctype) ) (! (= ($inlined_array p@@4 T) p@@4)
 :qid |BBbpl.842:37|
 :weight 0
 :skolemid |23|
 :pattern ( ($inlined_array p@@4 T))
)))
(assert (forall ((S@@5 T@$state) (p@@5 T@$ptr) (T@@0 T@$ctype) (sz Int) ) (! (= ($array_range S@@5 p@@5 T@@0 sz) ($array_range_no_state p@@5 T@@0 sz))
 :qid |BBbpl.878:23|
 :skolemid |24|
 :pattern ( ($array_range S@@5 p@@5 T@@0 sz))
)))
(assert (forall ((no Int) (t@@3 T@$ctype) ) (! (= ($get_fnptr no t@@3) ($ptr t@@3 ($get_fnptr_ref no)))
 :qid |BBbpl.928:21|
 :skolemid |25|
 :pattern ( ($get_fnptr no t@@3))
)))
(assert (forall ((S@@6 T@$state) (p@@6 T@$ptr) ) (!  (and (=> ($not_shared S@@6 p@@6) (and (and (and (and (and ($closed S@@6 p@@6) (= ($owner S@@6 p@@6) $me)) (and ($is p@@6 ($typ p@@6)) ($typed S@@6 p@@6))) (not (= ($kind_of ($typ p@@6)) $kind_primitive))) ($is_non_primitive ($typ p@@6))) (or (not ($is_claimable ($typ p@@6))) (= ($ref_cnt S@@6 p@@6) 0)))) (=> (and (and (and (and (and ($closed S@@6 p@@6) (= ($owner S@@6 p@@6) $me)) (and ($is p@@6 ($typ p@@6)) ($typed S@@6 p@@6))) (not (= ($kind_of ($typ p@@6)) $kind_primitive))) ($is_non_primitive ($typ p@@6))) (or (not ($is_claimable ($typ p@@6))) (= ($ref_cnt S@@6 p@@6) 0))) ($not_shared S@@6 p@@6)))
 :qid |BBbpl.969:34|
 :weight 0
 :skolemid |26|
 :pattern ( ($not_shared S@@6 p@@6))
)))
(assert (forall ((s@@0 T@$state) (p@@7 T@$ptr) ) (!  (and (=> ($claimed_closed s@@0 p@@7) ($closed s@@0 p@@7)) (=> ($closed s@@0 p@@7) ($claimed_closed s@@0 p@@7)))
 :qid |BBbpl.972:38|
 :weight 0
 :skolemid |27|
 :pattern ( ($claimed_closed s@@0 p@@7))
)))
(assert (= $no_claim ($ptr ^^claim 0)))
(assert (forall ((S@@7 T@$state) (p@@8 T@$ptr) ) (! (= ($ref_cnt S@@7 p@@8) ($st_ref_cnt ($select.sm ($statusmap S@@7) p@@8)))
 :qid |BBbpl.984:31|
 :weight 0
 :skolemid |28|
 :pattern ( ($ref_cnt S@@7 p@@8))
)))
(assert (forall ((S@@8 T@$state) (c@@0 T@$ptr) (o T@$ptr) ) (!  (and (=> ($account_claim S@@8 c@@0 o) (and (and ($good_state S@@8) ($closed S@@8 c@@0)) ($claims_obj c@@0 o))) (=> (and (and ($good_state S@@8) ($closed S@@8 c@@0)) ($claims_obj c@@0 o)) ($account_claim S@@8 c@@0 o)))
 :qid |BBbpl.989:25|
 :skolemid |29|
 :pattern ( ($account_claim S@@8 c@@0 o))
)))
(assert  (=> $seclbl.top true))
(assert  (=> true $seclbl.top))
(assert  (=> $seclbl.bot false))
(assert  (=> false $seclbl.bot))
(assert (= $arch_ptr_size 8))
(assert ($is_math_type |^$#thread_id|))
(assert ($is_composite ^A))
(assert (= ($ptr_level ^A) 0))
(assert (= ($sizeof ^A) 4))
(assert (forall ((|#s1@@3| T@$state) (|#s2@@3| T@$state) (|#p@@2| T@$ptr) ) (!  (and (=> ($inv2 |#s1@@3| |#s2@@3| |#p@@2| ^A) (and (and ($typed |#s2@@3| |#p@@2|) ($set_eq ($owns |#s2@@3| |#p@@2|) $set_empty)) (or (= ($select.mem ($memory |#s1@@3|) ($dot |#p@@2| A.x)) ($select.mem ($memory |#s2@@3|) ($dot |#p@@2| A.x))) (= (+ ($select.mem ($memory |#s1@@3|) ($dot |#p@@2| A.x)) 1) ($select.mem ($memory |#s2@@3|) ($dot |#p@@2| A.x)))))) (=> (and (and ($typed |#s2@@3| |#p@@2|) ($set_eq ($owns |#s2@@3| |#p@@2|) $set_empty)) (or (= ($select.mem ($memory |#s1@@3|) ($dot |#p@@2| A.x)) ($select.mem ($memory |#s2@@3|) ($dot |#p@@2| A.x))) (= (+ ($select.mem ($memory |#s1@@3|) ($dot |#p@@2| A.x)) 1) ($select.mem ($memory |#s2@@3|) ($dot |#p@@2| A.x))))) ($inv2 |#s1@@3| |#s2@@3| |#p@@2| ^A)))
 :qid |BBbpl.1247:15|
 :skolemid |30|
 :pattern ( ($inv2 |#s1@@3| |#s2@@3| |#p@@2| ^A))
)))
(assert  (=> ($is_claimable ^A) false))
(assert  (=> false ($is_claimable ^A)))
(assert  (=> ($has_volatile_owns_set ^A) false))
(assert  (=> false ($has_volatile_owns_set ^A)))
(assert ($is_base_field A.$owns))
(assert (= ($field_parent_type A.$owns) ^A))
(assert ($is_primitive_non_volatile_field A.$owns))
(assert (= ($owns_set_field ^A) A.$owns))
(assert ($is_base_field A.x))
(assert (= ($field_parent_type A.x) ^A))
(assert ($is_primitive_volatile_field A.x))
(assert (= ($field_offset A.x) 0))
(assert (= |#distTp3| ($ptr_to ^^i4)))
(assert (= |#distTp2| ($spec_ptr_to ^^claim)))
(assert (= |#distTp1| ($ptr_to ^A)))
(assert ($file_name_is 1 |#file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c|))
(push 1)
(set-info :boogie-vc-id f)
(assert (not
(let ((anon6_correct  (=> 
	(! (and %lbl%+7264 true) :lblpos +7264) 
	(=> 
		($function_entry $s) 
			(=> 
				(and (and ($good_state_ext |#tok$1^13.1| $s) ($full_stop $s)) ($can_use_all_frame_axioms $s))
					(=> 
						(and (and (and ($local_value_is $s |#tok$1^13.1| |#loc._this_| ($ptr_to_int ($ptr ^A |P#_this_|)) ($ptr_to ^A)) ($local_value_is_ptr $s |#tok$1^13.1| |#loc._this_| ($ptr ^A |P#_this_|) ($ptr_to ^A))) (= |#wrTime$1^13.1| ($current_timestamp $s))) (and $is_unwrap_check (not $is_stuttering_check)))
						(=> 
							(and (and (and (and (and (and (and (and (and (and 
								($closed $s ($ptr ^A |P#_this_|)) 
								(= ($owner $s ($ptr ^A |P#_this_|)) $me)) (and 
								($is ($ptr ^A |P#_this_|) ($typ ($ptr ^A |P#_this_|))) 
								($typed $s ($ptr ^A |P#_this_|)))) 
								(not (= ($kind_of ($typ ($ptr ^A |P#_this_|))) $kind_primitive)))
								($is_non_primitive ($typ ($ptr ^A |P#_this_|))))
								(or (not ($is_claimable ($typ ($ptr ^A |P#_this_|)))) (= ($ref_cnt $s ($ptr ^A |P#_this_|)) 0)))
								($inv2 $s $s ($ptr ^A |P#_this_|) ($typ ($ptr ^A |P#_this_|))))
								(forall ((|#q| T@$ptr) ) (!  (=> ($closed $s |#q|) ($inv2 $s $s |#q| ($typ |#q|)))
 :qid |BBbpl.651:13|
 :skolemid |19|
 :pattern ( ($select.sm ($statusmap $s) |#q|))
))) 
								($good_for_pre_can_unwrap $s))
								(= |call0formal@#l@0| ($ptr ^A |P#_this_|)))
								(and ($spans_the_same $s $s@0 |call0formal@#l@0| ($typ |call0formal@#l@0|)) 
								($good_state_ext |#tok$1^13.1| $s@0)))
 (! (or %lbl%@8407  (=> $is_unwrap_check ($set_eq ($owns $s@0 ($ptr ^A |P#_this_|)) $set_empty))) :lblneg @8407))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+8264 true) :lblpos +8264) anon6_correct)))
PreconditionGeneratedEntry_correct))
))
(check-sat)
(pop 1)
; Valid
