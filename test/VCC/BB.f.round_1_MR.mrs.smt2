;Analysis time until now:     2s
(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-logic  UFNIA)
;(set-option :produce-unsat-cores true)
; done setting options
;Sorts
(declare-sort $@Map@@$ptr@To@Bool@@ 0)
(declare-sort $ctype 0)
(declare-sort $field 0)
(declare-sort $kind 0)
(declare-sort $memory_t 0)
(declare-sort $ptr 0)
(declare-sort $ptrclub 0)
(declare-sort $ptrset 0)
(declare-sort $pure_function 0)
(declare-sort $state 0)
(declare-sort $status 0)
(declare-sort $statusmap_t 0)
(declare-sort $token 0)
(declare-sort $type_state 0)
(declare-sort $typemap_t 0)
(declare-sort $version 0)
(declare-sort $vol_version 0)

;Functions
(declare-fun $@bf_44 ( $token $state ) Bool)
(declare-fun $@bf_53 ( ) Bool)
(declare-fun $@bf_67 ( $token $state ) Bool)
(declare-fun $@bf_71 ( ) Bool)
(declare-fun $@bf_72 ( ) Bool)
(declare-fun $@bf_73 ( ) Bool)
(declare-fun $@bf_74 ( ) Bool)
(declare-fun $@bf_75 ( ) Bool)
(declare-fun $@bf_76 ( ) Bool)
(declare-fun $@bf_77 ( ) Bool)
(declare-fun $@bf_78 ( ) Bool)
(declare-fun $@bf_79 ( ) Bool)
(declare-fun $@bf_80 ( ) Bool)
(declare-fun $@bf_81 ( ) Bool)
(declare-fun $@bf_82 ( ) Bool)
(declare-fun $@distTp1 ( ) $ctype)
(declare-fun $@distTp2 ( ) $ctype)
(declare-fun $@distTp3 ( ) $ctype)
(declare-fun $@file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c ( ) $token)
(declare-fun $@loc._this_ ( ) $token)
(declare-fun $@sk_6 ( $state ) $ptr)
(declare-fun $@sk_7 ( $state ) $ptr)
(declare-fun $@sk_8 ( $state ) $ptr)
(declare-fun $@sk_9 ( $state ) $ptr)
(declare-fun $@tok$1^13.1 ( ) $token)
(declare-fun $arch_spec_ptr_start ( ) Int)
(declare-fun $array ( $ctype Int ) $ctype)
(declare-fun $current_frame_level ( ) Int)
(declare-fun $current_pure_post_level ( ) Int)
(declare-fun $current_timestamp ( $state ) Int)
(declare-fun $dot ( $ptr $field ) $ptr)
(declare-fun $extent ( $state $ptr ) $ptrset)
(declare-fun $fetch_from_vv ( $vol_version $ptr ) Int)
(declare-fun $field_parent_type ( $field ) $ctype)
(declare-fun $frame_level ( $pure_function ) Int)
(declare-fun $full_extent ( $ptr ) $ptrset)
(declare-fun $idx ( $ptr Int $ctype ) $ptr)
(declare-fun $index_within ( $ptr $ptr ) Int)
(declare-fun $int_to_ptr ( Int ) $ptr)
(declare-fun $kind_array ( ) $kind)
(declare-fun $kind_composite ( ) $kind)
(declare-fun $kind_of ( $ctype ) $kind)
(declare-fun $kind_primitive ( ) $kind)
(declare-fun $kind_thread ( ) $kind)
(declare-fun $me ( ) $ptr)
(declare-fun $memory ( $state ) $memory_t)
(declare-fun $memory_allocator_type ( ) $ctype)
(declare-fun $owner ( $state $ptr ) $ptr)
(declare-fun $owns ( $state $ptr ) $ptrset)
(declare-fun $ptr ( $ctype Int ) $ptr)
(declare-fun $ptr_level ( $ctype ) Int)
(declare-fun $ptr_to ( $ctype ) $ctype)
(declare-fun $ptr_to_int ( $ptr ) Int)
(declare-fun $ptrclub.members ( $ptrclub ) $@Map@@$ptr@To@Bool@@)
(declare-fun $pure_post_level ( $pure_function ) Int)
(declare-fun $read_version ( $state $ptr ) $version)
(declare-fun $read_vol_version ( $state $ptr ) $vol_version)
(declare-fun $ref ( $ptr ) Int)
(declare-fun $ref_cnt ( $state $ptr ) Int)
(declare-fun $s ( ) $state)
(declare-fun $s@0 ( ) $state)
(declare-fun $select.mem ( $memory_t $ptr ) Int)
(declare-fun $select.sm ( $statusmap_t $ptr ) $status)
(declare-fun $select.tm ( $typemap_t $ptr ) $type_state)
(declare-fun $select_range.mem ( $memory_t $ptr Int ) Int)
(declare-fun $set_difference ( $ptrset $ptrset ) $ptrset)
(declare-fun $set_empty ( ) $ptrset)
(declare-fun $set_singleton ( $ptr ) $ptrset)
(declare-fun $set_union ( $ptrset $ptrset ) $ptrset)
(declare-fun $span ( $ptr ) $ptrset)
(declare-fun $statusmap ( $state ) $statusmap_t)
(declare-fun $timestamp ( $state $ptr ) Int)
(declare-fun $ts_active_option ( $type_state ) $field)
(declare-fun $ts_emb ( $type_state ) $ptr)
(declare-fun $ts_path ( $type_state ) $field)
(declare-fun $typ ( $ptr ) $ctype)
(declare-fun $typemap ( $state ) $typemap_t)
(declare-fun ^$@thread_id ( ) $ctype)
(declare-fun ^^claim ( ) $ctype)
(declare-fun ^^i4 ( ) $ctype)
(declare-fun ^^root_emb ( ) $ctype)
(declare-fun ^^void ( ) $ctype)
(declare-fun ^A ( ) $ctype)
(declare-fun A.$owns ( ) $field)
(declare-fun A.x ( ) $field)
(declare-fun call0formal@@l@0 ( ) $ptr)
(declare-fun P@_this_ ( ) Int)

;Predicates
(declare-fun $can_use_all_frame_axioms ( $state ) Bool)
(declare-fun $closed ( $state $ptr ) Bool)
(declare-fun $extent_mutable ( $state $ptr ) Bool)
(declare-fun $forall_inv2_when_closed ( $state $state ) Bool)
(declare-fun $full_stop ( $state ) Bool)
(declare-fun $function_entry ( $state ) Bool)
(declare-fun $good_for_pre_can_unwrap ( $state ) Bool)
(declare-fun $good_state ( $state ) Bool)
(declare-fun $good_state_ext ( $token $state ) Bool)
(declare-fun $in_range_phys_ptr ( Int ) Bool)
(declare-fun $in_range_spec_ptr ( Int ) Bool)
(declare-fun $in_wrapped_domain ( $state $ptr ) Bool)
(declare-fun $in_writes_at ( Int $ptr ) Bool)
(declare-fun $inv2 ( $state $state $ptr $ctype ) Bool)
(declare-fun $is ( $ptr $ctype ) Bool)
(declare-fun $is_base_field ( $field ) Bool)
(declare-fun $is_claimable ( $ctype ) Bool)
(declare-fun $is_non_primitive ( $ctype ) Bool)
(declare-fun $is_stuttering_check ( ) Bool)
(declare-fun $is_threadtype ( $ctype ) Bool)
(declare-fun $is_unwrap_check ( ) Bool)
(declare-fun $local_value_is ( $state $token $token Int $ctype ) Bool)
(declare-fun $local_value_is_ptr ( $state $token $token $ptr $ctype ) Bool)
(declare-fun $mutable ( $state $ptr ) Bool)
(declare-fun $nonvolatile_spans_the_same ( $state $state $ptr $ctype ) Bool)
(declare-fun $set_eq ( $ptrset $ptrset ) Bool)
(declare-fun $set_in ( $ptr $ptrset ) Bool)
(declare-fun $spans_the_same ( $state $state $ptr $ctype ) Bool)
(declare-fun $state_nonvolatile_spans_the_same ( $state $state $ptr $ctype ) Bool)
(declare-fun $state_spans_the_same ( $state $state $ptr $ctype ) Bool)
(declare-fun $stuttering_pre ( $state $ptr ) Bool)
(declare-fun $thread_local ( $state $ptr ) Bool)
(declare-fun $ts_is_volatile ( $type_state ) Bool)
(declare-fun $typed ( $state $ptr ) Bool)
(declare-fun $valid_claim ( $state $ptr ) Bool)
(declare-fun anon6_assertion ( ) Bool)
(declare-fun MapRead$$@Map@@$ptr@To@Bool@@$ ( $@Map@@$ptr@To@Bool@@ $ptr ) Bool)

;Axioms
   (assert (! $is_unwrap_check :named ax_0))
   (assert (! ($can_use_all_frame_axioms $s) :named ax_1))
   (assert (! ($closed $s call0formal@@l@0) :named ax_2))
   (assert (! ($full_stop $s) :named ax_3))
   (assert (! ($function_entry $s) :named ax_4))
   (assert (! ($good_for_pre_can_unwrap $s) :named ax_5))
   (assert (! ($good_state_ext $@tok$1^13.1 $s) :named ax_6))
   (assert (! ($good_state_ext $@tok$1^13.1 $s@0) :named ax_7))
   (assert (! ($in_range_spec_ptr 0) :named ax_8))
   (assert (! ($inv2 $s $s call0formal@@l@0 ($typ call0formal@@l@0)) :named ax_9))
   (assert (! ($is call0formal@@l@0 ($typ call0formal@@l@0)) :named ax_10))
   (assert (! ($is_base_field A.$owns) :named ax_11))
   (assert (! ($is_base_field A.x) :named ax_12))
   (assert (! ($is_non_primitive ($typ call0formal@@l@0)) :named ax_13))
   (assert (! ($local_value_is $s $@tok$1^13.1 $@loc._this_ ($ptr_to_int call0formal@@l@0) $@distTp1) :named ax_14))
   (assert (! ($local_value_is_ptr $s $@tok$1^13.1 $@loc._this_ call0formal@@l@0 $@distTp1) :named ax_15))
   (assert (! ($spans_the_same $s $s@0 call0formal@@l@0 ($typ call0formal@@l@0)) :named ax_16))
   (assert (! ($typed $s call0formal@@l@0) :named ax_17))
   (assert (! (= $@distTp1 ($ptr_to ^A)) :named ax_18))
   (assert (! (= $@distTp3 ($ptr_to ^^i4)) :named ax_19))
   (assert (! (= $me ($owner $s call0formal@@l@0)) :named ax_20))
   (assert (! (= (- 1) (* (- 1) 1)) :named ax_21))
   (assert (! (= (= true $@bf_53) (and (not $is_unwrap_check) (not $is_stuttering_check))) :named ax_22))
   (assert (! (= ^A ($field_parent_type A.$owns)) :named ax_23))
   (assert (! (= ^A ($field_parent_type A.x)) :named ax_24))
   (assert (! (= 0 ($ptr_level $memory_allocator_type)) :named ax_25))
   (assert (! (= 0 ($ptr_level ^A)) :named ax_26))
   (assert (! (= call0formal@@l@0 ($ptr ^A P@_this_)) :named ax_27))
   (assert (! (= true $@bf_71) :named ax_28))
   (assert (! (= true $@bf_72) :named ax_29))
   (assert (! (= true $@bf_74) :named ax_30))
   (assert (! (= true $@bf_75) :named ax_31))
   (assert (! (= true $@bf_79) :named ax_32))
   (assert (! (= true $@bf_80) :named ax_33))
   (assert (! (= true $@bf_81) :named ax_34))
   (assert (! (forall( (|#l_$2| $ptr) (|#p_$14| $ptr))(= ($set_in |#p_$14| ($span |#l_$2|)) ($set_in |#p_$14| ($span |#l_$2|)))) :named ax_35))
   (assert (! (forall( (|#l_$3| $ptr) (|#p_$16| $ptr))(= ($set_in |#p_$16| ($full_extent |#l_$3|)) ($set_in |#p_$16| ($full_extent |#l_$3|)))) :named ax_36))
   (assert (! (forall( (|#o| $ptr) (|#f| $ptr) (|S_$19| $state))(= (and (= ($ts_emb ($select.tm ($typemap |S_$19|) |#f|)) |#o|) (= $kind_primitive ($kind_of ($typ |#f|)))) (and (= ($ts_emb ($select.tm ($typemap |S_$19|) |#f|)) |#o|) (= $kind_primitive ($kind_of ($typ |#f|)))))) :named ax_37))
   (assert (! (forall( (|#p_$0| $ptr) (|S_$0| $state))(= ($ts_emb ($select.tm ($typemap |S_$0|) |#p_$0|)) ($ts_emb ($select.tm ($typemap |S_$0|) |#p_$0|)))) :named ax_38))
   (assert (! (forall( (|#p_$1| $ptr) (|S_$1| $state))(= ($ts_path ($select.tm ($typemap |S_$1|) |#p_$1|)) ($ts_path ($select.tm ($typemap |S_$1|) |#p_$1|)))) :named ax_39))
   (assert (! (forall( (|#p_$10| $ptr) (|S_$25| $state))(= (and ($typed |S_$25| |#p_$10|) (not ($ts_is_volatile ($select.tm ($typemap |S_$25|) |#p_$10|)))) (and ($typed |S_$25| |#p_$10|) (not ($ts_is_volatile ($select.tm ($typemap |S_$25|) |#p_$10|)))))) :named ax_40))
   (assert (! (forall( (|#p_$11| $ptr) (|#l| $ptr) (|S_$31| $state) (|S0| $state))(= (and (and (and (and (and (and (and (and (and (= ($owner |S_$31| |#p_$11|) $me) ($closed |S_$31| |#p_$11|)) (and ($typed |S_$31| |#p_$11|) ($is |#p_$11| ($typ |#p_$11|)))) (not (= $kind_primitive ($kind_of ($typ |#p_$11|))))) ($is_non_primitive ($typ |#p_$11|))) ($typed |S0| |#p_$11|)) (= ($timestamp |S_$31| |#p_$11|) ($current_timestamp |S_$31|))) ($is_non_primitive ($typ |#p_$11|))) ($set_in |#p_$11| ($owns |S0| |#l|))) (and (= ($owner |S0| |#p_$11|) |#l|) ($closed |S0| |#p_$11|))) (and (and (and (and (and (and (and (and (and (= ($owner |S_$31| |#p_$11|) $me) ($closed |S_$31| |#p_$11|)) (and ($typed |S_$31| |#p_$11|) ($is |#p_$11| ($typ |#p_$11|)))) (not (= $kind_primitive ($kind_of ($typ |#p_$11|))))) ($is_non_primitive ($typ |#p_$11|))) ($typed |S0| |#p_$11|)) (= ($timestamp |S_$31| |#p_$11|) ($current_timestamp |S_$31|))) ($is_non_primitive ($typ |#p_$11|))) ($set_in |#p_$11| ($owns |S0| |#l|))) (and (= ($owner |S0| |#p_$11|) |#l|) ($closed |S0| |#p_$11|))))) :named ax_41))
   (assert (! (forall( (|#p_$12| $ptr) (|#l_$0| $ptr) (|S_$32| $state) (|S0_$0| $state))(= (and (and (and (and (and (and (and (and (and (and (= ($owner |S_$32| |#p_$12|) $me) ($closed |S_$32| |#p_$12|)) (and ($typed |S_$32| |#p_$12|) ($is |#p_$12| ($typ |#p_$12|)))) (not (= $kind_primitive ($kind_of ($typ |#p_$12|))))) ($is_non_primitive ($typ |#p_$12|))) ($typed |S0_$0| |#p_$12|)) (= ($timestamp |S_$32| |#p_$12|) ($current_timestamp |S_$32|))) ($is_non_primitive ($typ |#p_$12|))) ($set_in |#p_$12| ($owns |S0_$0| |#l_$0|))) (and (= ($owner |S0_$0| |#p_$12|) |#l_$0|) ($closed |S0_$0| |#p_$12|))) (=> ($is_claimable ($typ |#p_$12|)) (= ($ref_cnt |S0_$0| |#p_$12|) ($ref_cnt |S_$32| |#p_$12|)))) (and (and (and (and (and (and (and (and (and (and (= ($owner |S_$32| |#p_$12|) $me) ($closed |S_$32| |#p_$12|)) (and ($typed |S_$32| |#p_$12|) ($is |#p_$12| ($typ |#p_$12|)))) (not (= $kind_primitive ($kind_of ($typ |#p_$12|))))) ($is_non_primitive ($typ |#p_$12|))) ($typed |S0_$0| |#p_$12|)) (= ($timestamp |S_$32| |#p_$12|) ($current_timestamp |S_$32|))) ($is_non_primitive ($typ |#p_$12|))) ($set_in |#p_$12| ($owns |S0_$0| |#l_$0|))) (and (= ($owner |S0_$0| |#p_$12|) |#l_$0|) ($closed |S0_$0| |#p_$12|))) (=> ($is_claimable ($typ |#p_$12|)) (= ($ref_cnt |S0_$0| |#p_$12|) ($ref_cnt |S_$32| |#p_$12|)))))) :named ax_42))
   (assert (! (forall( (|#p_$13| $ptr) (|#l_$1| $ptr) (|S_$33| $state))(= ($set_in |#p_$13| ($owns |S_$33| |#l_$1|)) ($set_in |#p_$13| ($owns |S_$33| |#l_$1|)))) :named ax_43))
   (assert (! (forall( (|#p_$15| $ptr))(= ($full_extent |#p_$15|) ($full_extent |#p_$15|))) :named ax_44))
   (assert (! (forall( (|#p2_$0| $ptr) (|#p1_$0| $ptr))(= ($set_in |#p1_$0| ($full_extent |#p2_$0|)) ($set_in |#p1_$0| ($full_extent |#p2_$0|)))) :named ax_45))
   (assert (! (forall( (|#p2| $ptr) (|#p1| $ptr) (|S_$22| $state))(= ($set_in |#p1| ($extent |S_$22| |#p2|)) ($set_in |#p1| ($extent |S_$22| |#p2|)))) :named ax_46))
   (assert (! (forall( (|#q_$0_$3| $ptr))(!(=> ($closed $s |#q_$0_$3|) ($inv2 $s $s |#q_$0_$3| ($typ |#q_$0_$3|)))  :pattern ( ($select.sm ($statusmap $s) |#q_$0_$3|)))) :named ax_47))
   (assert (! (forall( (|#r_$0| Int))(!(= (or (= 0 |#r_$0|) (> |#r_$0| $arch_spec_ptr_start)) ($in_range_spec_ptr |#r_$0|))  :pattern ( ($in_range_spec_ptr |#r_$0|)))) :named ax_48))
   (assert (! (forall( (|#r| Int))(!(= (and (<= 0 |#r|) (<= |#r| $arch_spec_ptr_start)) ($in_range_phys_ptr |#r|))  :pattern ( ($in_range_phys_ptr |#r|)))) :named ax_49))
   (assert (! (forall( (|#s1_$5| $state) (|#s2_$3| $state) (|#p_$18| $ptr) (|#t_$8| $ctype))(!(= (and (and (and (= ($read_version |#s2_$3| |#p_$18|) ($read_version |#s1_$5| |#p_$18|)) (= ($owns |#s2_$3| |#p_$18|) ($owns |#s1_$5| |#p_$18|))) (= ($select.tm ($typemap |#s2_$3|) |#p_$18|) ($select.tm ($typemap |#s1_$5|) |#p_$18|))) ($state_spans_the_same |#s1_$5| |#s2_$3| |#p_$18| |#t_$8|)) ($spans_the_same |#s1_$5| |#s2_$3| |#p_$18| |#t_$8|))  :weight  0 :pattern ( ($spans_the_same |#s1_$5| |#s2_$3| |#p_$18| |#t_$8|)))) :named ax_50))
   (assert (! (forall( (|#s1_$6| $state) (|#s2_$4| $state) (|#p_$19| $ptr) (|#t_$9| $ctype))(!(= (and (and (= ($select.tm ($typemap |#s2_$4|) |#p_$19|) ($select.tm ($typemap |#s1_$6|) |#p_$19|)) (= ($read_version |#s2_$4| |#p_$19|) ($read_version |#s1_$6| |#p_$19|))) ($state_nonvolatile_spans_the_same |#s1_$6| |#s2_$4| |#p_$19| |#t_$9|)) ($nonvolatile_spans_the_same |#s1_$6| |#s2_$4| |#p_$19| |#t_$9|))  :weight  0 :pattern ( ($nonvolatile_spans_the_same |#s1_$6| |#s2_$4| |#p_$19| |#t_$9|)))) :named ax_51))
   (assert (! (forall( (|#s1_$7| $state) (|#s2_$5| $state) (|#p_$20| $ptr))(!(= (and (or (= ($select.mem ($memory |#s2_$5|) ($dot |#p_$20| A.x)) (+ ($select.mem ($memory |#s1_$7|) ($dot |#p_$20| A.x)) 1)) (= ($select.mem ($memory |#s2_$5|) ($dot |#p_$20| A.x)) ($select.mem ($memory |#s1_$7|) ($dot |#p_$20| A.x)))) (and ($typed |#s2_$5| |#p_$20|) ($set_eq ($owns |#s2_$5| |#p_$20|) $set_empty))) ($inv2 |#s1_$7| |#s2_$5| |#p_$20| ^A))  :pattern ( ($inv2 |#s1_$7| |#s2_$5| |#p_$20| ^A)))) :named ax_52))
   (assert (! (forall( (|#t_$0| $ctype) (|#p_$2| $ptr) (|S_$12| $state))(= (and (and (and (and (= ($owner |S_$12| |#p_$2|) $me) ($closed |S_$12| |#p_$2|)) (and ($typed |S_$12| |#p_$2|) ($is |#p_$2| |#t_$0|))) (not (= $kind_primitive ($kind_of |#t_$0|)))) ($is_non_primitive |#t_$0|)) (and (and (and (and (= ($owner |S_$12| |#p_$2|) $me) ($closed |S_$12| |#p_$2|)) (and ($typed |S_$12| |#p_$2|) ($is |#p_$2| |#t_$0|))) (not (= $kind_primitive ($kind_of |#t_$0|)))) ($is_non_primitive |#t_$0|)))) :named ax_53))
   (assert (! (forall( (|#t_$1| $ctype) (|#p_$3| $ptr) (|S_$16| $state))(= (and ($typed |S_$16| |#p_$3|) ($is |#p_$3| |#t_$1|)) (and ($typed |S_$16| |#p_$3|) ($is |#p_$3| |#t_$1|)))) :named ax_54))
   (assert (! (forall( (|#t_$2| $ctype) (|#p_$4| $ptr) (|S_$17| $state))(= (and (=> (and ($typed |S_$17| |#p_$4|) ($is |#p_$4| |#t_$2|)) ($in_range_phys_ptr ($ref |#p_$4|))) (and ($typed |S_$17| |#p_$4|) ($is |#p_$4| |#t_$2|))) (and (=> (and ($typed |S_$17| |#p_$4|) ($is |#p_$4| |#t_$2|)) ($in_range_phys_ptr ($ref |#p_$4|))) (and ($typed |S_$17| |#p_$4|) ($is |#p_$4| |#t_$2|))))) :named ax_55))
   (assert (! (forall( (|#t_$3| $ctype) (|#p_$5| $ptr) (|S_$18| $state))(= (and (=> (and ($typed |S_$18| |#p_$5|) ($is |#p_$5| |#t_$3|)) ($in_range_spec_ptr ($ref |#p_$5|))) (and ($typed |S_$18| |#p_$5|) ($is |#p_$5| |#t_$3|))) (and (=> (and ($typed |S_$18| |#p_$5|) ($is |#p_$5| |#t_$3|)) ($in_range_spec_ptr ($ref |#p_$5|))) (and ($typed |S_$18| |#p_$5|) ($is |#p_$5| |#t_$3|))))) :named ax_56))
   (assert (! (forall( (|#t_$4| $ctype) (|#p_$6| $ptr) (|S_$21| $state))(= (and ($thread_local |S_$21| |#p_$6|) ($is |#p_$6| |#t_$4|)) (and ($thread_local |S_$21| |#p_$6|) ($is |#p_$6| |#t_$4|)))) :named ax_57))
   (assert (! (forall( (|#t_$5| $ctype) (|#b| Int))(!(= ($typ ($ptr |#t_$5| |#b|)) |#t_$5|)  :weight  0)) :named ax_58))
   (assert (! (forall( (|#t_$6| $ctype) (|#b_$0| Int))(!(= ($ref ($ptr |#t_$6| |#b_$0|)) |#b_$0|)  :weight  0)) :named ax_59))
   (assert (! (forall( (|#t| $ctype) (|#p| $ptr))(= ($ptr |#t| ($ref |#p|)) ($ptr |#t| ($ref |#p|)))) :named ax_60))
   (assert (! (forall( (|c_$1| $ptrclub) (|p_$33| $ptr))(= (MapRead$$@Map@@$ptr@To@Bool@@$ ($ptrclub.members |c_$1|) |p_$33|) (MapRead$$@Map@@$ptr@To@Bool@@$ ($ptrclub.members |c_$1|) |p_$33|))) :named ax_61))
   (assert (! (forall( (|e_$0| $ptr) (|S_$39| $ptrset))(= ($set_difference |S_$39| ($set_singleton |e_$0|)) ($set_difference |S_$39| ($set_singleton |e_$0|)))) :named ax_62))
   (assert (! (forall( (|e| $ptr) (|S_$38| $ptrset))(= ($set_union |S_$38| ($set_singleton |e|)) ($set_union |S_$38| ($set_singleton |e|)))) :named ax_63))
   (assert (! (forall( (|emb| $ptr) (|p_$31| $ptr) (|S_$40| $state))(= (and (and (= |emb| ($ts_emb ($select.tm ($typemap |S_$40|) |p_$31|))) (not ($ts_is_volatile ($select.tm ($typemap |S_$40|) |p_$31|)))) ($typed |S_$40| |p_$31|)) (and (and (= |emb| ($ts_emb ($select.tm ($typemap |S_$40|) |p_$31|))) (not ($ts_is_volatile ($select.tm ($typemap |S_$40|) |p_$31|)))) ($typed |S_$40| |p_$31|)))) :named ax_64))
   (assert (! (forall( (|f_$1| $field) (|p_$25| $ptr) (|S_$26| $state))(= ($fetch_from_vv ($read_vol_version |S_$26| |p_$25|) ($dot |p_$25| |f_$1|)) ($fetch_from_vv ($read_vol_version |S_$26| |p_$25|) ($dot |p_$25| |f_$1|)))) :named ax_65))
   (assert (! (forall( (|f_$2| $field) (|u_$0| $ptr) (|S_$36| $state))(= (= |f_$2| ($ts_active_option ($select.tm ($typemap |S_$36|) |u_$0|))) (= |f_$2| ($ts_active_option ($select.tm ($typemap |S_$36|) |u_$0|))))) :named ax_66))
   (assert (! (forall( (|f_$3| $pure_function))(= (< ($frame_level |f_$3|) $current_frame_level) (< ($frame_level |f_$3|) $current_frame_level))) :named ax_67))
   (assert (! (forall( (|f_$4| $pure_function))(= (< ($pure_post_level |f_$4|) $current_pure_post_level) (< ($pure_post_level |f_$4|) $current_pure_post_level))) :named ax_68))
   (assert (! (forall( (|isvolatile| Bool) (|tp| $ctype) (|f_$0| $field) (|p_$8| $ptr) (|S_$2| $state))(= (and (= |isvolatile| ($ts_is_volatile ($select.tm ($typemap |S_$2|) ($dot |p_$8| |f_$0|)))) (and (= |f_$0| ($ts_path ($select.tm ($typemap |S_$2|) ($dot |p_$8| |f_$0|)))) (and (= |p_$8| ($ts_emb ($select.tm ($typemap |S_$2|) ($dot |p_$8| |f_$0|)))) (and ($typed |S_$2| ($dot |p_$8| |f_$0|)) ($is ($dot |p_$8| |f_$0|) |tp|))))) (and (= |isvolatile| ($ts_is_volatile ($select.tm ($typemap |S_$2|) ($dot |p_$8| |f_$0|)))) (and (= |f_$0| ($ts_path ($select.tm ($typemap |S_$2|) ($dot |p_$8| |f_$0|)))) (and (= |p_$8| ($ts_emb ($select.tm ($typemap |S_$2|) ($dot |p_$8| |f_$0|)))) (and ($typed |S_$2| ($dot |p_$8| |f_$0|)) ($is ($dot |p_$8| |f_$0|) |tp|))))))) :named ax_69))
   (assert (! (forall( (|l2_$0| Bool) (|l1_$0| Bool))(= (and |l2_$0| |l1_$0|) (and |l2_$0| |l1_$0|))) :named ax_70))
   (assert (! (forall( (|l2_$1| Bool) (|l1_$1| Bool))(= (or |l2_$1| |l1_$1|) (or |l2_$1| |l1_$1|))) :named ax_71))
   (assert (! (forall( (|l2| Bool) (|l1| Bool))(= (=> |l1| |l2|) (=> |l1| |l2|))) :named ax_72))
   (assert (! (forall( (|max| Int) (|val| Int) (|min| Int))(= (and (<= |val| |max|) (<= |min| |val|)) (and (<= |val| |max|) (<= |min| |val|)))) :named ax_73))
   (assert (! (forall( (|owner| $ptr) (|p_$18| $ptr) (|S_$11| $state))(= (and (= |owner| ($owner |S_$11| |p_$18|)) ($closed |S_$11| |p_$18|)) (and (= |owner| ($owner |S_$11| |p_$18|)) ($closed |S_$11| |p_$18|)))) :named ax_74))
   (assert (! (forall( (|owns| $ptrset) (|o| $ptr) (|S_$34| $state))(= ($set_difference |owns| ($owns |S_$34| |o|)) ($set_difference |owns| ($owns |S_$34| |o|)))) :named ax_75))
   (assert (! (forall( (|p_$0| $ptr))(= (= ($kind_of ($typ |p_$0|)) $kind_composite) (= ($kind_of ($typ |p_$0|)) $kind_composite))) :named ax_76))
   (assert (! (forall( (|p_$1| $ptr))(= ($is_non_primitive ($typ |p_$1|)) ($is_non_primitive ($typ |p_$1|)))) :named ax_77))
   (assert (! (forall( (|p_$10| $ptr) (|S_$4| $state))(= ($ts_is_volatile ($select.tm ($typemap |S_$4|) |p_$10|)) ($ts_is_volatile ($select.tm ($typemap |S_$4|) |p_$10|)))) :named ax_78))
   (assert (! (forall( (|p_$11| $ptr) (|S_$5| $state))(= (= ($ts_emb ($select.tm ($typemap |S_$5|) |p_$11|)) ($ptr ^^root_emb ($ref |p_$11|))) (= ($ts_emb ($select.tm ($typemap |S_$5|) |p_$11|)) ($ptr ^^root_emb ($ref |p_$11|))))) :named ax_79))
   (assert (! (forall( (|p_$12| $ptr) (|M2| $state) (|M1| $state))(= (and (<= ($timestamp |M2| |p_$12|) ($current_timestamp |M2|)) (< ($current_timestamp |M1|) ($timestamp |M2| |p_$12|))) (and (<= ($timestamp |M2| |p_$12|) ($current_timestamp |M2|)) (< ($current_timestamp |M1|) ($timestamp |M2| |p_$12|))))) :named ax_80))
   (assert (! (forall( (|p_$13| $ptr) (|begin_time| Int) (|S_$6| $state))(= (and (or (>= ($timestamp |S_$6| |p_$13|) |begin_time|) ($in_writes_at |begin_time| |p_$13|)) ($mutable |S_$6| |p_$13|)) (and (or (>= ($timestamp |S_$6| |p_$13|) |begin_time|) ($in_writes_at |begin_time| |p_$13|)) ($mutable |S_$6| |p_$13|)))) :named ax_81))
   (assert (! (forall( (|p_$14| $ptr) (|begin_time_$0| Int) (|S_$7| $state))(= (and (and (=> (= $kind_primitive ($kind_of ($typ |p_$14|))) (not ($closed |S_$7| |p_$14|))) (and ($typed |S_$7| |p_$14|) (= ($owner |S_$7| |p_$14|) $me))) (or (>= ($timestamp |S_$7| |p_$14|) |begin_time_$0|) ($in_writes_at |begin_time_$0| |p_$14|))) (and (and (=> (= $kind_primitive ($kind_of ($typ |p_$14|))) (not ($closed |S_$7| |p_$14|))) (and ($typed |S_$7| |p_$14|) (= ($owner |S_$7| |p_$14|) $me))) (or (>= ($timestamp |S_$7| |p_$14|) |begin_time_$0|) ($in_writes_at |begin_time_$0| |p_$14|))))) :named ax_82))
   (assert (! (forall( (|p_$15| $ptr) (|S_$8| $state))(= ($select.sm ($statusmap |S_$8|) |p_$15|) ($select.sm ($statusmap |S_$8|) |p_$15|))) :named ax_83))
   (assert (! (forall( (|p_$16| $ptr) (|S_$9| $state))(= ($select.tm ($typemap |S_$9|) |p_$16|) ($select.tm ($typemap |S_$9|) |p_$16|))) :named ax_84))
   (assert (! (forall( (|p_$17| $ptr) (|S_$10| $state))(= (not (= $kind_thread ($kind_of ($typ ($owner |S_$10| |p_$17|))))) (not (= $kind_thread ($kind_of ($typ ($owner |S_$10| |p_$17|))))))) :named ax_85))
   (assert (! (forall( (|p_$19| $ptr) (|S_$13| $state))(= (or (and (= $kind_primitive ($kind_of ($typ |p_$19|))) ($closed |S_$13| |p_$19|)) (not (= ($owner |S_$13| |p_$19|) $me))) (or (and (= $kind_primitive ($kind_of ($typ |p_$19|))) ($closed |S_$13| |p_$19|)) (not (= ($owner |S_$13| |p_$19|) $me))))) :named ax_86))
   (assert (! (forall( (|p_$2| $ptr) (|s_$0| $state))(= ($select.mem ($memory |s_$0|) |p_$2|) ($select.mem ($memory |s_$0|) |p_$2|))) :named ax_87))
   (assert (! (forall( (|p_$20| $ptr) (|S_$14| $state))(= (and ($typed |S_$14| |p_$20|) (= ($owner |S_$14| |p_$20|) $me)) (and ($typed |S_$14| |p_$20|) (= ($owner |S_$14| |p_$20|) $me)))) :named ax_88))
   (assert (! (forall( (|p_$21| $ptr) (|S_$15| $state))(= (and (=> (= $kind_primitive ($kind_of ($typ |p_$21|))) (not ($closed |S_$15| |p_$21|))) (and ($typed |S_$15| |p_$21|) (= ($owner |S_$15| |p_$21|) $me))) (and (=> (= $kind_primitive ($kind_of ($typ |p_$21|))) (not ($closed |S_$15| |p_$21|))) (and ($typed |S_$15| |p_$21|) (= ($owner |S_$15| |p_$21|) $me))))) :named ax_89))
   (assert (! (forall( (|p_$23| $ptr) (|S_$20| $state))(= (and (or (= ($owner |S_$20| |p_$23|) $me) ($in_wrapped_domain |S_$20| |p_$23|)) (not (= $kind_primitive ($kind_of ($typ |p_$23|))))) (and (or (= ($owner |S_$20| |p_$23|) $me) ($in_wrapped_domain |S_$20| |p_$23|)) (not (= $kind_primitive ($kind_of ($typ |p_$23|))))))) :named ax_90))
   (assert (! (forall( (|p_$24| $ptr) (|S2| $state) (|S1| $state))(= ($inv2 |S1| |S2| |p_$24| ($typ |p_$24|)) ($inv2 |S1| |S2| |p_$24| ($typ |p_$24|)))) :named ax_91))
   (assert (! (forall( (|p_$26| $ptr) (|S_$27| $state))(= (and ($stuttering_pre |S_$27| |p_$26|) (and ($inv2 |S_$27| |S_$27| |p_$26| ($typ |p_$26|)) ($closed |S_$27| |p_$26|))) (and ($stuttering_pre |S_$27| |p_$26|) (and ($inv2 |S_$27| |S_$27| |p_$26| ($typ |p_$26|)) ($closed |S_$27| |p_$26|))))) :named ax_92))
   (assert (! (forall( (|p_$27| $ptr) (|S_$28| $state))(= (and (and (forall( (|#q_$0_$1| $ptr))(!(=> ($closed |S_$28| |#q_$0_$1|) ($inv2 |S_$28| |S_$28| |#q_$0_$1| ($typ |#q_$0_$1|)))  :pattern ( ($select.sm ($statusmap |S_$28|) |#q_$0_$1|)))) (and (and (or (= 0 ($ref_cnt |S_$28| |p_$27|)) (not ($is_claimable ($typ |p_$27|)))) (and (and (and (and (= ($owner |S_$28| |p_$27|) $me) ($closed |S_$28| |p_$27|)) (and ($typed |S_$28| |p_$27|) ($is |p_$27| ($typ |p_$27|)))) (not (= $kind_primitive ($kind_of ($typ |p_$27|))))) ($is_non_primitive ($typ |p_$27|)))) ($inv2 |S_$28| |S_$28| |p_$27| ($typ |p_$27|)))) ($good_for_pre_can_unwrap |S_$28|)) (and (and (forall( (|#q_$0| $ptr))(!(=> ($closed |S_$28| |#q_$0|) ($inv2 |S_$28| |S_$28| |#q_$0| ($typ |#q_$0|)))  :pattern ( ($select.sm ($statusmap |S_$28|) |#q_$0|)))) (and (and (or (= 0 ($ref_cnt |S_$28| |p_$27|)) (not ($is_claimable ($typ |p_$27|)))) (and (and (and (and (= ($owner |S_$28| |p_$27|) $me) ($closed |S_$28| |p_$27|)) (and ($typed |S_$28| |p_$27|) ($is |p_$27| ($typ |p_$27|)))) (not (= $kind_primitive ($kind_of ($typ |p_$27|))))) ($is_non_primitive ($typ |p_$27|)))) ($inv2 |S_$28| |S_$28| |p_$27| ($typ |p_$27|)))) ($good_for_pre_can_unwrap |S_$28|)))) :named ax_93))
   (assert (! (forall( (|p_$28| $ptr) (|S_$29| $state))(= (= ($timestamp |S_$29| |p_$28|) ($current_timestamp |S_$29|)) (= ($timestamp |S_$29| |p_$28|) ($current_timestamp |S_$29|)))) :named ax_94))
   (assert (! (forall( (|p_$29| $ptr) (|S_$30| $state))(= (and (= ($timestamp |S_$30| |p_$29|) ($current_timestamp |S_$30|)) ($mutable |S_$30| |p_$29|)) (and (= ($timestamp |S_$30| |p_$29|) ($current_timestamp |S_$30|)) ($mutable |S_$30| |p_$29|)))) :named ax_95))
   (assert (! (forall( (|p_$30| $ptr) (|S_$37| $state))(= (and (and (= ($ts_emb ($select.tm ($typemap |S_$37|) |p_$30|)) ($ptr ^^root_emb ($ref |p_$30|))) ($extent_mutable |S_$37| |p_$30|)) (= ($timestamp |S_$37| |p_$30|) ($current_timestamp |S_$37|))) (and (and (= ($ts_emb ($select.tm ($typemap |S_$37|) |p_$30|)) ($ptr ^^root_emb ($ref |p_$30|))) ($extent_mutable |S_$37| |p_$30|)) (= ($timestamp |S_$37| |p_$30|) ($current_timestamp |S_$37|))))) :named ax_96))
   (assert (! (forall( (|p_$4| $ptr) (|s2| $state) (|s1| $state))(= (= ($select.mem ($memory |s2|) |p_$4|) ($select.mem ($memory |s1|) |p_$4|)) (= ($select.mem ($memory |s2|) |p_$4|) ($select.mem ($memory |s1|) |p_$4|)))) :named ax_97))
   (assert (! (forall( (|p_$5| $ptr) (|s2_$0| $state) (|s1_$0| $state))(= (= ($select.sm ($statusmap |s2_$0|) |p_$5|) ($select.sm ($statusmap |s1_$0|) |p_$5|)) (= ($select.sm ($statusmap |s2_$0|) |p_$5|) ($select.sm ($statusmap |s1_$0|) |p_$5|)))) :named ax_98))
   (assert (! (forall( (|p_$6| $ptr) (|s2_$1| $state) (|s1_$1| $state))(= (= ($select.tm ($typemap |s2_$1|) |p_$6|) ($select.tm ($typemap |s1_$1|) |p_$6|)) (= ($select.tm ($typemap |s2_$1|) |p_$6|) ($select.tm ($typemap |s1_$1|) |p_$6|)))) :named ax_99))
   (assert (! (forall( (|p_$9| $ptr) (|S_$3| $state))(= (= ($ts_emb ($select.tm ($typemap |S_$3|) |p_$9|)) ($ptr ^^root_emb ($ref |p_$9|))) (= ($ts_emb ($select.tm ($typemap |S_$3|) |p_$9|)) ($ptr ^^root_emb ($ref |p_$9|))))) :named ax_100))
   (assert (! (forall( (|p| $ptr))(= ($is_threadtype ($typ |p|)) ($is_threadtype ($typ |p|)))) :named ax_101))
   (assert (! (forall( (|p2_$0| $ptr) (|p1_$0| $ptr))(= (not (= ($ref |p2_$0|) ($ref |p1_$0|))) (not (= ($ref |p2_$0|) ($ref |p1_$0|))))) :named ax_102))
   (assert (! (forall( (|p2| $ptr) (|p1| $ptr))(= (= ($ref |p2|) ($ref |p1|)) (= ($ref |p2|) ($ref |p1|)))) :named ax_103))
   (assert (! (forall( (|S_$23| $state) (|t_$5| $token))(= (and ($good_state_ext |t_$5| |S_$23|) ($full_stop |S_$23|)) (and ($good_state_ext |t_$5| |S_$23|) ($full_stop |S_$23|)))) :named ax_104))
   (assert (! (forall( (|S_$24| $state))(= (forall( (|#p_$9_$0| $ptr) (|#q_$1| $ptr))(!(=> (and (and ($set_in |#p_$9_$0| ($owns |S_$24| |#q_$1|)) ($good_state |S_$24|)) ($closed |S_$24| |#q_$1|)) (and ($closed |S_$24| |#p_$9_$0|) (not (= 0 ($ref |#p_$9_$0|)))))  :pattern ( ($set_in |#p_$9_$0| ($owns |S_$24| |#q_$1|))))) (forall( (|#p_$9| $ptr) (|#q| $ptr))(!(=> (and (and ($set_in |#p_$9| ($owns |S_$24| |#q|)) ($good_state |S_$24|)) ($closed |S_$24| |#q|)) (and ($closed |S_$24| |#p_$9|) (not (= 0 ($ref |#p_$9|)))))  :pattern ( ($set_in |#p_$9| ($owns |S_$24| |#q|))))))) :named ax_105))
   (assert (! (forall( (|S_$42| $state) (|p_$34| $ptr))(!(= (and (and ($typed |S_$42| |p_$34|) (= ($owner |S_$42| |p_$34|) $me)) (not ($closed |S_$42| |p_$34|))) ($mutable |S_$42| |p_$34|))  :weight  0 :pattern ( ($mutable |S_$42| |p_$34|)))) :named ax_106))
   (assert (! (forall( (|S_$44| $state) (|p_$36| $ptr))(!(= (and (or (and (and (or (= ($owner |S_$44| ($ts_emb ($select.tm ($typemap |S_$44|) |p_$36|))) $me) ($in_wrapped_domain |S_$44| ($ts_emb ($select.tm ($typemap |S_$44|) |p_$36|)))) (not (= $kind_primitive ($kind_of ($typ ($ts_emb ($select.tm ($typemap |S_$44|) |p_$36|))))))) (and (or (not ($ts_is_volatile ($select.tm ($typemap |S_$44|) |p_$36|))) (not ($closed |S_$44| ($ts_emb ($select.tm ($typemap |S_$44|) |p_$36|))))) (= $kind_primitive ($kind_of ($typ |p_$36|))))) (and (or (= ($owner |S_$44| |p_$36|) $me) ($in_wrapped_domain |S_$44| |p_$36|)) (not (= $kind_primitive ($kind_of ($typ |p_$36|)))))) ($typed |S_$44| |p_$36|)) ($thread_local |S_$44| |p_$36|))  :pattern ( ($thread_local |S_$44| |p_$36|)))) :named ax_107))
   (assert (! (forall( (|s| $state))(= |s| |s|)) :named ax_108))
   (assert (! (forall( (|s2_$2| $state) (|s1_$2| $state))(= (and (= ($typemap |s2_$2|) ($typemap |s1_$2|)) (= ($statusmap |s2_$2|) ($statusmap |s1_$2|))) (and (= ($typemap |s2_$2|) ($typemap |s1_$2|)) (= ($statusmap |s2_$2|) ($statusmap |s1_$2|))))) :named ax_109))
   (assert (! (forall( (|subject_$0| $field) (|approver_$0| $field) (|this_$0| $ptr) (|S2_$1| $state) (|S1_$1| $state))(= (or (or (or (= 0 ($ref ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))))) (= ($select.mem ($memory |S2_$1|) ($dot |this_$0| |subject_$0|)) ($select.mem ($memory |S1_$1|) ($dot |this_$0| |subject_$0|)))) (and ($inv2 |S1_$1| |S2_$1| ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))) ($typ ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))))) (not ($is_threadtype ($typ ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|)))))))) (and ($is_threadtype ($typ ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))))) (not (= ($read_vol_version |S2_$1| |this_$0|) ($read_vol_version |S1_$1| |this_$0|))))) (or (or (or (= 0 ($ref ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))))) (= ($select.mem ($memory |S2_$1|) ($dot |this_$0| |subject_$0|)) ($select.mem ($memory |S1_$1|) ($dot |this_$0| |subject_$0|)))) (and ($inv2 |S1_$1| |S2_$1| ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))) ($typ ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))))) (not ($is_threadtype ($typ ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|)))))))) (and ($is_threadtype ($typ ($int_to_ptr ($select.mem ($memory |S1_$1|) ($dot |this_$0| |approver_$0|))))) (not (= ($read_vol_version |S2_$1| |this_$0|) ($read_vol_version |S1_$1| |this_$0|))))))) :named ax_110))
   (assert (! (forall( (|subject_$1| $field) (|this_$1| $ptr) (|S2_$2| $state) (|S1_$2| $state))(= (or (or (or (= 0 ($ref ($owner |S1_$2| |this_$1|))) (= ($select.mem ($memory |S2_$2|) ($dot |this_$1| |subject_$1|)) ($select.mem ($memory |S1_$2|) ($dot |this_$1| |subject_$1|)))) (and ($inv2 |S1_$2| |S2_$2| ($owner |S1_$2| |this_$1|) ($typ ($owner |S1_$2| |this_$1|))) (not ($is_threadtype ($typ ($owner |S1_$2| |this_$1|)))))) (and ($is_threadtype ($typ ($owner |S1_$2| |this_$1|))) (not (= ($read_vol_version |S2_$2| |this_$1|) ($read_vol_version |S1_$2| |this_$1|))))) (or (or (or (= 0 ($ref ($owner |S1_$2| |this_$1|))) (= ($select.mem ($memory |S2_$2|) ($dot |this_$1| |subject_$1|)) ($select.mem ($memory |S1_$2|) ($dot |this_$1| |subject_$1|)))) (and ($inv2 |S1_$2| |S2_$2| ($owner |S1_$2| |this_$1|) ($typ ($owner |S1_$2| |this_$1|))) (not ($is_threadtype ($typ ($owner |S1_$2| |this_$1|)))))) (and ($is_threadtype ($typ ($owner |S1_$2| |this_$1|))) (not (= ($read_vol_version |S2_$2| |this_$1|) ($read_vol_version |S1_$2| |this_$1|))))))) :named ax_111))
   (assert (! (forall( (|subject| $field) (|approver| $ptr) (|this| $ptr) (|S2_$0| $state) (|S1_$0| $state))(= (or (or (or (= 0 ($ref |approver|)) (= ($select.mem ($memory |S2_$0|) ($dot |this| |subject|)) ($select.mem ($memory |S1_$0|) ($dot |this| |subject|)))) (and ($inv2 |S1_$0| |S2_$0| |approver| ($typ |approver|)) (not ($is_threadtype ($typ |approver|))))) (and ($is_threadtype ($typ |approver|)) (not (= ($read_vol_version |S2_$0| |this|) ($read_vol_version |S1_$0| |this|))))) (or (or (or (= 0 ($ref |approver|)) (= ($select.mem ($memory |S2_$0|) ($dot |this| |subject|)) ($select.mem ($memory |S1_$0|) ($dot |this| |subject|)))) (and ($inv2 |S1_$0| |S2_$0| |approver| ($typ |approver|)) (not ($is_threadtype ($typ |approver|))))) (and ($is_threadtype ($typ |approver|)) (not (= ($read_vol_version |S2_$0| |this|) ($read_vol_version |S1_$0| |this|))))))) :named ax_112))
   (assert (! (forall( (|sz_$0| Int) (|T| $ctype) (|p_$32| $ptr))(= ($ptr ($array |T| |sz_$0|) ($ref |p_$32|)) ($ptr ($array |T| |sz_$0|) ($ref |p_$32|)))) :named ax_113))
   (assert (! (forall( (|sz_$1| Int) (|T_$0| $ctype) (|arr| $ptr) (|q| $ptr))(= (and (= |q| ($idx |arr| ($index_within |q| |arr|) |T_$0|)) (and (<= 0 ($index_within |q| |arr|)) (<= ($index_within |q| |arr|) (- |sz_$1| 1)))) (and (= |q| ($idx |arr| ($index_within |q| |arr|) |T_$0|)) (and (<= 0 ($index_within |q| |arr|)) (<= ($index_within |q| |arr|) (- |sz_$1| 1)))))) :named ax_114))
   (assert (! (forall( (|sz_$2| Int) (|T_$1| $ctype) (|arr_$0| $ptr) (|q_$0| $ptr))(= (and (and (<= 0 ($index_within |q_$0| |arr_$0|)) (<= ($index_within |q_$0| |arr_$0|) (- |sz_$2| 1))) ($set_in |q_$0| ($full_extent ($idx |arr_$0| ($index_within |q_$0| |arr_$0|) |T_$1|)))) (and (and (<= 0 ($index_within |q_$0| |arr_$0|)) (<= ($index_within |q_$0| |arr_$0|) (- |sz_$2| 1))) ($set_in |q_$0| ($full_extent ($idx |arr_$0| ($index_within |q_$0| |arr_$0|) |T_$1|)))))) :named ax_115))
   (assert (! (forall( (|sz_$3| Int) (|T_$2| $ctype) (|arr_$1| $ptr) (|q_$1| $ptr) (|S_$41| $state))(= (and (and (<= 0 ($index_within |q_$1| |arr_$1|)) (<= ($index_within |q_$1| |arr_$1|) (- |sz_$3| 1))) ($set_in |q_$1| ($extent |S_$41| ($idx |arr_$1| ($index_within |q_$1| |arr_$1|) |T_$2|)))) (and (and (<= 0 ($index_within |q_$1| |arr_$1|)) (<= ($index_within |q_$1| |arr_$1|) (- |sz_$3| 1))) ($set_in |q_$1| ($extent |S_$41| ($idx |arr_$1| ($index_within |q_$1| |arr_$1|) |T_$2|)))))) :named ax_116))
   (assert (! (forall( (|sz| Int) (|p_$3| $ptr) (|s_$1| $state))(= ($select_range.mem ($memory |s_$1|) |p_$3| |sz|) ($select_range.mem ($memory |s_$1|) |p_$3| |sz|))) :named ax_117))
   (assert (! (forall( (|t_$0| $ctype))(= (= ($kind_of |t_$0|) $kind_composite) (= ($kind_of |t_$0|) $kind_composite))) :named ax_118))
   (assert (! (forall( (|t_$1| $ctype))(= (= ($kind_of |t_$1|) $kind_array) (= ($kind_of |t_$1|) $kind_array))) :named ax_119))
   (assert (! (forall( (|t_$2| $ctype))(= (not (= $kind_primitive ($kind_of |t_$2|))) (not (= $kind_primitive ($kind_of |t_$2|))))) :named ax_120))
   (assert (! (forall( (|t_$3| $ctype) (|p_$7| $ptr) (|S| $state))(= ($ptr |t_$3| ($select.mem ($memory |S|) |p_$7|)) ($ptr |t_$3| ($select.mem ($memory |S|) |p_$7|)))) :named ax_121))
   (assert (! (forall( (|t_$4| $ctype) (|f| $field))(= (and (= |t_$4| ($field_parent_type |f|)) ($is_base_field |f|)) (and (= |t_$4| ($field_parent_type |f|)) ($is_base_field |f|)))) :named ax_122))
   (assert (! (forall( (|t_$8| $ctype))(!(= (= $kind_thread ($kind_of |t_$8|)) ($is_threadtype |t_$8|))  :weight  0 :pattern ( ($is_threadtype |t_$8|)))) :named ax_123))
   (assert (! (forall( (|t| $ctype))(= (= $kind_primitive ($kind_of |t|)) (= $kind_primitive ($kind_of |t|)))) :named ax_124))
   (assert (! (forall( (|tok_$0| $token) (|c_$0| $ptr) (|#s2_$0| $state) (|#s1_$2| $state))(= (and (and (and (and (forall( (|#p_$9_$6| $ptr) (|#q_$7| $ptr))(!(=> (and (and ($set_in |#p_$9_$6| ($owns |#s2_$0| |#q_$7|)) ($good_state |#s2_$0|)) ($closed |#s2_$0| |#q_$7|)) (and ($closed |#s2_$0| |#p_$9_$6|) (not (= 0 ($ref |#p_$9_$6|)))))  :pattern ( ($set_in |#p_$9_$6| ($owns |#s2_$0| |#q_$7|))))) (and (forall( (|#p_$9_$5| $ptr) (|#q_$6| $ptr))(!(=> (and (and ($set_in |#p_$9_$5| ($owns |#s1_$2| |#q_$6|)) ($good_state |#s1_$2|)) ($closed |#s1_$2| |#q_$6|)) (and ($closed |#s1_$2| |#p_$9_$5|) (not (= 0 ($ref |#p_$9_$5|)))))  :pattern ( ($set_in |#p_$9_$5| ($owns |#s1_$2| |#q_$6|))))) (and ($good_state_ext |tok_$0| |#s2_$0|) (and ($good_state_ext |tok_$0| |#s1_$2|) ($full_stop |#s1_$2|))))) ($forall_inv2_when_closed |#s1_$2| |#s2_$0|)) ($valid_claim |#s1_$2| |c_$0|)) ($closed |#s2_$0| |c_$0|)) (and (and (and (and (forall( (|#p_$9_$4| $ptr) (|#q_$5| $ptr))(!(=> (and (and ($set_in |#p_$9_$4| ($owns |#s2_$0| |#q_$5|)) ($good_state |#s2_$0|)) ($closed |#s2_$0| |#q_$5|)) (and ($closed |#s2_$0| |#p_$9_$4|) (not (= 0 ($ref |#p_$9_$4|)))))  :pattern ( ($set_in |#p_$9_$4| ($owns |#s2_$0| |#q_$5|))))) (and (forall( (|#p_$9_$3| $ptr) (|#q_$4| $ptr))(!(=> (and (and ($set_in |#p_$9_$3| ($owns |#s1_$2| |#q_$4|)) ($good_state |#s1_$2|)) ($closed |#s1_$2| |#q_$4|)) (and ($closed |#s1_$2| |#p_$9_$3|) (not (= 0 ($ref |#p_$9_$3|)))))  :pattern ( ($set_in |#p_$9_$3| ($owns |#s1_$2| |#q_$4|))))) (and ($good_state_ext |tok_$0| |#s2_$0|) (and ($good_state_ext |tok_$0| |#s1_$2|) ($full_stop |#s1_$2|))))) ($forall_inv2_when_closed |#s1_$2| |#s2_$0|)) ($valid_claim |#s1_$2| |c_$0|)) ($closed |#s2_$0| |c_$0|)))) :named ax_125))
   (assert (! (forall( (|tok| $token) (|c| $ptr) (|#s1_$1| $state))(= (and (forall( (|#p_$9_$2| $ptr) (|#q_$3| $ptr))(!(=> (and (and ($set_in |#p_$9_$2| ($owns |#s1_$1| |#q_$3|)) ($good_state |#s1_$1|)) ($closed |#s1_$1| |#q_$3|)) (and ($closed |#s1_$1| |#p_$9_$2|) (not (= 0 ($ref |#p_$9_$2|)))))  :pattern ( ($set_in |#p_$9_$2| ($owns |#s1_$1| |#q_$3|))))) ($good_state_ext |tok| |#s1_$1|)) (and (forall( (|#p_$9_$1| $ptr) (|#q_$2| $ptr))(!(=> (and (and ($set_in |#p_$9_$1| ($owns |#s1_$1| |#q_$2|)) ($good_state |#s1_$1|)) ($closed |#s1_$1| |#q_$2|)) (and ($closed |#s1_$1| |#p_$9_$1|) (not (= 0 ($ref |#p_$9_$1|)))))  :pattern ( ($set_in |#p_$9_$1| ($owns |#s1_$1| |#q_$2|))))) ($good_state_ext |tok| |#s1_$1|)))) :named ax_126))
   (assert (! (forall( (|typ_$0| $ctype) (|#p_$8| $ptr) (|#s2| $state) (|#s1_$0| $state))(= (or (and (not ($closed |#s2| |#p_$8|)) (not ($closed |#s1_$0| |#p_$8|))) (and ($nonvolatile_spans_the_same |#s1_$0| |#s2| |#p_$8| |typ_$0|) ($inv2 |#s1_$0| |#s2| |#p_$8| |typ_$0|))) (or (and (not ($closed |#s2| |#p_$8|)) (not ($closed |#s1_$0| |#p_$8|))) (and ($nonvolatile_spans_the_same |#s1_$0| |#s2| |#p_$8| |typ_$0|) ($inv2 |#s1_$0| |#s2| |#p_$8| |typ_$0|))))) :named ax_127))
   (assert (! (forall( (|typ| $ctype) (|#p_$7| $ptr) (|#s1| $state))(= ($inv2 |#s1| |#s1| |#p_$7| |typ|) ($inv2 |#s1| |#s1| |#p_$7| |typ|))) :named ax_128))
   (assert (! (forall( (|u| $ptr) (|S_$35| $state))(= ($ts_active_option ($select.tm ($typemap |S_$35|) |u|)) ($ts_active_option ($select.tm ($typemap |S_$35|) |u|)))) :named ax_129))
   (assert (! (forall( (|y_$0| Int) (|x_$0| Int))(= (+ |x_$0| |y_$0|) (+ |x_$0| |y_$0|))) :named ax_130))
   (assert (! (forall( (|z| Int) (|y| Int) (|x| Int))(= (+ |x| (* |y| |z|)) (+ |x| (* |y| |z|)))) :named ax_131))
   (assert (! (not $is_stuttering_check) :named ax_132))
   (assert (! (not ($is_claimable ^A)) :named ax_133))
   (assert (! (not (= $@bf_53 true)) :named ax_134))
   (assert (! (not (= $@bf_73 true)) :named ax_135))
   (assert (! (not (= $@bf_76 true)) :named ax_136))
   (assert (! (not (= $@bf_77 true)) :named ax_137))
   (assert (! (not (= $@bf_78 true)) :named ax_138))
   (assert (! (not (= $@bf_82 true)) :named ax_139))
   (assert (! (not (= $@distTp1 $@distTp3)) :named ax_140))
   (assert (! (not (= $@distTp1 $memory_allocator_type)) :named ax_141))
   (assert (! (not (= $@distTp2 $@distTp1)) :named ax_142))
   (assert (! (not (= $@distTp2 $@distTp3)) :named ax_143))
   (assert (! (not (= $@distTp2 $memory_allocator_type)) :named ax_144))
   (assert (! (not (= $@distTp2 ^$@thread_id)) :named ax_145))
   (assert (! (not (= $@distTp2 ^^claim)) :named ax_146))
   (assert (! (not (= $@distTp2 ^^i4)) :named ax_147))
   (assert (! (not (= $@distTp2 ^^root_emb)) :named ax_148))
   (assert (! (not (= $@distTp2 ^^void)) :named ax_149))
   (assert (! (not (= $@distTp2 ^A)) :named ax_150))
   (assert (! (not (= $@distTp3 $@distTp1)) :named ax_151))
   (assert (! (not (= $@distTp3 $@distTp2)) :named ax_152))
   (assert (! (not (= $@distTp3 $memory_allocator_type)) :named ax_153))
   (assert (! (not (= $@file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c $@tok$1^13.1)) :named ax_154))
   (assert (! (not (= $@loc._this_ $@file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c)) :named ax_155))
   (assert (! (not (= $@loc._this_ $@tok$1^13.1)) :named ax_156))
   (assert (! (not (= $@tok$1^13.1 $@file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c)) :named ax_157))
   (assert (! (not (= $@tok$1^13.1 $@loc._this_)) :named ax_158))
   (assert (! (not (= $kind_array $kind_primitive)) :named ax_159))
   (assert (! (not (= $kind_array $kind_thread)) :named ax_160))
   (assert (! (not (= $kind_composite $kind_array)) :named ax_161))
   (assert (! (not (= $kind_composite $kind_primitive)) :named ax_162))
   (assert (! (not (= $kind_composite $kind_thread)) :named ax_163))
   (assert (! (not (= $kind_primitive $kind_array)) :named ax_164))
   (assert (! (not (= $kind_primitive $kind_composite)) :named ax_165))
   (assert (! (not (= $kind_primitive $kind_thread)) :named ax_166))
   (assert (! (not (= $kind_primitive ($kind_of ($typ call0formal@@l@0)))) :named ax_167))
   (assert (! (not (= $kind_thread $kind_array)) :named ax_168))
   (assert (! (not (= $kind_thread $kind_composite)) :named ax_169))
   (assert (! (not (= $kind_thread $kind_primitive)) :named ax_170))
   (assert (! (not (= $memory_allocator_type $@distTp1)) :named ax_171))
   (assert (! (not (= $memory_allocator_type $@distTp2)) :named ax_172))
   (assert (! (not (= $memory_allocator_type $@distTp3)) :named ax_173))
   (assert (! (not (= $memory_allocator_type ^$@thread_id)) :named ax_174))
   (assert (! (not (= $memory_allocator_type ^^claim)) :named ax_175))
   (assert (! (not (= $memory_allocator_type ^^i4)) :named ax_176))
   (assert (! (not (= $memory_allocator_type ^^root_emb)) :named ax_177))
   (assert (! (not (= $memory_allocator_type ^^void)) :named ax_178))
   (assert (! (not (= $memory_allocator_type ^A)) :named ax_179))
   (assert (! (not (= ^$@thread_id $@distTp1)) :named ax_180))
   (assert (! (not (= ^$@thread_id $@distTp2)) :named ax_181))
   (assert (! (not (= ^$@thread_id $@distTp3)) :named ax_182))
   (assert (! (not (= ^$@thread_id $memory_allocator_type)) :named ax_183))
   (assert (! (not (= ^$@thread_id ^^claim)) :named ax_184))
   (assert (! (not (= ^$@thread_id ^^i4)) :named ax_185))
   (assert (! (not (= ^$@thread_id ^^root_emb)) :named ax_186))
   (assert (! (not (= ^$@thread_id ^^void)) :named ax_187))
   (assert (! (not (= ^$@thread_id ^A)) :named ax_188))
   (assert (! (not (= ^^claim $@distTp1)) :named ax_189))
   (assert (! (not (= ^^claim $@distTp2)) :named ax_190))
   (assert (! (not (= ^^claim $@distTp3)) :named ax_191))
   (assert (! (not (= ^^claim $memory_allocator_type)) :named ax_192))
   (assert (! (not (= ^^claim ^$@thread_id)) :named ax_193))
   (assert (! (not (= ^^claim ^^i4)) :named ax_194))
   (assert (! (not (= ^^claim ^^root_emb)) :named ax_195))
   (assert (! (not (= ^^claim ^^void)) :named ax_196))
   (assert (! (not (= ^^claim ^A)) :named ax_197))
   (assert (! (not (= ^^i4 $@distTp1)) :named ax_198))
   (assert (! (not (= ^^i4 $@distTp2)) :named ax_199))
   (assert (! (not (= ^^i4 $@distTp3)) :named ax_200))
   (assert (! (not (= ^^i4 $memory_allocator_type)) :named ax_201))
   (assert (! (not (= ^^i4 ^$@thread_id)) :named ax_202))
   (assert (! (not (= ^^i4 ^^claim)) :named ax_203))
   (assert (! (not (= ^^i4 ^^root_emb)) :named ax_204))
   (assert (! (not (= ^^i4 ^^void)) :named ax_205))
   (assert (! (not (= ^^i4 ^A)) :named ax_206))
   (assert (! (not (= ^^root_emb $@distTp1)) :named ax_207))
   (assert (! (not (= ^^root_emb $@distTp2)) :named ax_208))
   (assert (! (not (= ^^root_emb $@distTp3)) :named ax_209))
   (assert (! (not (= ^^root_emb $memory_allocator_type)) :named ax_210))
   (assert (! (not (= ^^root_emb ^$@thread_id)) :named ax_211))
   (assert (! (not (= ^^root_emb ^^claim)) :named ax_212))
   (assert (! (not (= ^^root_emb ^^i4)) :named ax_213))
   (assert (! (not (= ^^root_emb ^^void)) :named ax_214))
   (assert (! (not (= ^^root_emb ^A)) :named ax_215))
   (assert (! (not (= ^^void $@distTp1)) :named ax_216))
   (assert (! (not (= ^^void $@distTp2)) :named ax_217))
   (assert (! (not (= ^^void $@distTp3)) :named ax_218))
   (assert (! (not (= ^^void $memory_allocator_type)) :named ax_219))
   (assert (! (not (= ^^void ^$@thread_id)) :named ax_220))
   (assert (! (not (= ^^void ^^claim)) :named ax_221))
   (assert (! (not (= ^^void ^^i4)) :named ax_222))
   (assert (! (not (= ^^void ^^root_emb)) :named ax_223))
   (assert (! (not (= ^^void ^A)) :named ax_224))
   (assert (! (not (= ^A $@distTp1)) :named ax_225))
   (assert (! (not (= ^A $@distTp2)) :named ax_226))
   (assert (! (not (= ^A $@distTp3)) :named ax_227))
   (assert (! (not (= ^A $memory_allocator_type)) :named ax_228))
   (assert (! (not (= ^A ^$@thread_id)) :named ax_229))
   (assert (! (not (= ^A ^^claim)) :named ax_230))
   (assert (! (not (= ^A ^^i4)) :named ax_231))
   (assert (! (not (= ^A ^^root_emb)) :named ax_232))
   (assert (! (not (= ^A ^^void)) :named ax_233))
   (assert (! (not (= A.x A.$owns)) :named ax_234))
   (assert (! (not (= true $@bf_73)) :named ax_235))
   (assert (! (not (= true $@bf_76)) :named ax_236))
   (assert (! (not (= true $@bf_77)) :named ax_237))
   (assert (! (not (= true $@bf_78)) :named ax_238))
   (assert (! (not (= true $@bf_82)) :named ax_239))
   (assert (! (or (not ($is_claimable ($typ call0formal@@l@0))) (= 0 ($ref_cnt $s call0formal@@l@0))) :named ax_240))
   (assert (! true :named ax_241))

;Program
(assert (! (and true
anon6_assertion
) :named ax_true))
(assert (! (=> anon6_assertion (not (and true
   (and true
      (=> $is_unwrap_check ($set_eq ($owns $s@0 ($ptr ^A P@_this_)) $set_empty))
   )
))) :named ax_anon6_assertion))
(assert (=> false (not (and
   anon6_assertion
))))

;Commands
   (check-sat)
   ;(get-unsat-core)
