(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-option :smt.qi.profile true)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@$kind 0)
(declare-fun $kind_composite () T@$kind)
(declare-fun $kind_primitive () T@$kind)
(declare-fun $kind_array () T@$kind)
(declare-fun $kind_thread () T@$kind)
(declare-sort T@$ctype 0)
(declare-fun ^^i1 () T@$ctype)
(declare-fun ^^i2 () T@$ctype)
(declare-fun ^^i4 () T@$ctype)
(declare-fun ^^i8 () T@$ctype)
(declare-fun ^^u1 () T@$ctype)
(declare-fun ^^u2 () T@$ctype)
(declare-fun ^^u4 () T@$ctype)
(declare-fun ^^u8 () T@$ctype)
(declare-fun ^^void () T@$ctype)
(declare-fun ^^bool () T@$ctype)
(declare-fun ^^f4 () T@$ctype)
(declare-fun ^^f8 () T@$ctype)
(declare-fun ^^claim () T@$ctype)
(declare-fun ^^root_emb () T@$ctype)
(declare-fun ^^mathint () T@$ctype)
(declare-fun |^$#thread_id_t| () T@$ctype)
(declare-fun |^$#ptrset| () T@$ctype)
(declare-fun |^$#state_t| () T@$ctype)
(declare-fun |^$#struct| () T@$ctype)
(declare-fun $memory_allocator_type () T@$ctype)
(declare-sort T@$ptr 0)
(declare-fun $no_claim () T@$ptr)
(declare-sort T@$pure_function 0)
(declare-fun |cf#classifier#default| () T@$pure_function)
(declare-fun |^$#thread_id| () T@$ctype)
(declare-fun ^A () T@$ctype)
(declare-sort T@$field 0)
(declare-fun A.$owns () T@$field)
(declare-fun A.x () T@$field)
(declare-sort T@$label 0)
(declare-fun |l#public| () T@$label)
(declare-fun |#distTp3| () T@$ctype)
(declare-fun |#distTp2| () T@$ctype)
(declare-fun |#distTp1| () T@$ctype)
(declare-sort T@$token 0)
(declare-fun |#loc._this_| () T@$token)
(declare-fun |#tok$1^13.1| () T@$token)
(declare-fun |#file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c| () T@$token)
(declare-fun %lbl%+3849 () Bool)
(declare-fun $is_unwrap_check () Bool)
(declare-fun $is_stuttering_check () Bool)
(declare-sort T@$state 0)
(declare-fun $closed (T@$state T@$ptr) Bool)
(declare-fun $s () T@$state)
(declare-fun $ptr (T@$ctype Int) T@$ptr)
(declare-fun |P#_this_| () Int)
(declare-fun $owner (T@$state T@$ptr) T@$ptr)
(declare-fun $me () T@$ptr)
(declare-fun $is (T@$ptr T@$ctype) Bool)
(declare-fun $typ (T@$ptr) T@$ctype)
(declare-fun $typed (T@$state T@$ptr) Bool)
(declare-fun $kind_of (T@$ctype) T@$kind)
(declare-fun $is_non_primitive (T@$ctype) Bool)
(declare-fun $is_claimable (T@$ctype) Bool)
(declare-fun $ref_cnt (T@$state T@$ptr) Int)
(declare-fun $inv2 (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $good_for_pre_can_unwrap (T@$state) Bool)
(declare-fun |call0formal_$_#l_$_0| () T@$ptr)
(declare-fun $spans_the_same (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-fun $s_$_0 () T@$state)
(declare-fun $s_$_2 () T@$state)
(declare-fun %lbl%@5046 () Bool)
(declare-sort T@$ptrset 0)
(declare-fun $set_eq (T@$ptrset T@$ptrset) Bool)
(declare-fun $owns (T@$state T@$ptr) T@$ptrset)
(declare-fun $set_empty () T@$ptrset)
(declare-fun %lbl%+3845 () Bool)
(declare-sort T@$memory_t 0)
(declare-fun $select.mem (T@$memory_t T@$ptr) Int)
(declare-fun $memory (T@$state) T@$memory_t)
(declare-fun $dot (T@$ptr T@$field) T@$ptr)
(declare-fun $state_spans_the_same (T@$state T@$state T@$ptr T@$ctype) Bool)
(declare-sort T@$version 0)
(declare-fun $read_version (T@$state T@$ptr) T@$version)
(declare-sort T@$typemap_t 0)
(declare-sort T@$type_state 0)
(declare-fun $select.tm (T@$typemap_t T@$ptr) T@$type_state)
(declare-fun $typemap (T@$state) T@$typemap_t)
(declare-fun $null () T@$ptr)
(declare-fun $good_state (T@$state) Bool)
(declare-sort T@$struct 0)
(declare-fun $vs_state (T@$struct) T@$state)
(declare-fun $struct_zero () T@$struct)
(declare-fun $has_volatile_owns_set (T@$ctype) Bool)
(declare-fun $position_marker () Bool)
(declare-fun $ptr_level (T@$ctype) Int)
(declare-fun $set_cardinality (T@$ptrset) Int)
(declare-fun $seclbl.top () Bool)
(declare-fun $seclbl.bot () Bool)
(declare-sort T@$map_t..$ptr_to..^^void.^^bool 0)
(declare-fun $int_to_map_t..ptr_to..^^void.^^bool (Int) T@$map_t..$ptr_to..^^void.^^bool)
(declare-fun $zero.$map_t..$ptr_to..^^void.^^bool () T@$map_t..$ptr_to..^^void.^^bool)
(declare-fun $function_arg_type (T@$pure_function Int T@$ctype) Bool)
(declare-fun $map_t (T@$ctype T@$ctype) T@$ctype)
(declare-fun $ptr_to (T@$ctype) T@$ctype)
(declare-fun $arch_ptr_size () Int)
(declare-fun $arch_spec_ptr_start () Int)
(declare-fun $max.u8 () Int)
(declare-fun $is_math_type (T@$ctype) Bool)
(declare-fun $is_composite (T@$ctype) Bool)
(declare-fun $sizeof (T@$ctype) Int)
(declare-fun $is_base_field (T@$field) Bool)
(declare-fun $field_parent_type (T@$field) T@$ctype)
(declare-fun $is_primitive_non_volatile_field (T@$field) Bool)
(declare-fun $owns_set_field (T@$ctype) T@$field)
(declare-fun $is_primitive_volatile_field (T@$field) Bool)
(declare-fun $spec_ptr_to (T@$ctype) T@$ctype)
(declare-fun $file_name_is (Int T@$token) Bool)
(declare-fun %lbl%+4443 () Bool)
(assert (and (distinct $kind_composite $kind_primitive $kind_array $kind_thread)(distinct ^^i1 ^^i2 ^^i4 ^^i8 ^^u1 ^^u2 ^^u4 ^^u8 ^^void ^^bool ^^f4 ^^f8 ^^claim ^^root_emb ^^mathint |^$#thread_id_t| |^$#ptrset| |^$#state_t| |^$#struct| $memory_allocator_type |^$#thread_id| ^A |#distTp3| |#distTp2| |#distTp1|)(distinct A.$owns A.x)(distinct |#loc._this_| |#tok$1^13.1| |#file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c|))
)
(push 1)
(assert (forall ((|#s1_$11| T@$state) (|#s2_$8| T@$state) (|#p_$33| T@$ptr) ) (!  (and (=> ($inv2 |#s1_$11| |#s2_$8| |#p_$33| ^A) (and (and ($typed |#s2_$8| |#p_$33|) ($set_eq ($owns |#s2_$8| |#p_$33|) $set_empty)) (or (= ($select.mem ($memory |#s1_$11|) ($dot |#p_$33| A.x)) ($select.mem ($memory |#s2_$8|) ($dot |#p_$33| A.x))) (= (+ ($select.mem ($memory |#s1_$11|) ($dot |#p_$33| A.x)) 1) ($select.mem ($memory |#s2_$8|) ($dot |#p_$33| A.x)))))) (=> (and (and ($typed |#s2_$8| |#p_$33|) ($set_eq ($owns |#s2_$8| |#p_$33|) $set_empty)) (or (= ($select.mem ($memory |#s1_$11|) ($dot |#p_$33| A.x)) ($select.mem ($memory |#s2_$8|) ($dot |#p_$33| A.x))) (= (+ ($select.mem ($memory |#s1_$11|) ($dot |#p_$33| A.x)) 1) ($select.mem ($memory |#s2_$8|) ($dot |#p_$33| A.x))))) ($inv2 |#s1_$11| |#s2_$8| |#p_$33| ^A)))
 :qid |LockFree.368:18|
 :skolemid |1|
 :pattern ( ($inv2 |#s1_$11| |#s2_$8| |#p_$33| ^A))
)))

(set-info :boogie-vc-id |A#adm|)
(assert (not
(let ((L3_correct  (=> (! (and %lbl%+3849 true) :lblpos +3849) (=> (and $is_unwrap_check (not $is_stuttering_check)) (=> (and (and (and (and (and (and ($closed $s ($ptr ^A |P#_this_|)) (= ($owner $s ($ptr ^A |P#_this_|)) $me)) (and ($is ($ptr ^A |P#_this_|) ($typ ($ptr ^A |P#_this_|))) ($typed $s ($ptr ^A |P#_this_|)))) (not (= ($kind_of ($typ ($ptr ^A |P#_this_|))) $kind_primitive))) ($is_non_primitive ($typ ($ptr ^A |P#_this_|)))) (and (or (not ($is_claimable ($typ ($ptr ^A |P#_this_|)))) (= ($ref_cnt $s ($ptr ^A |P#_this_|)) 0)) 
($inv2 $s $s ($ptr ^A |P#_this_|) ($typ ($ptr ^A |P#_this_|)))
)) (and (and ($good_for_pre_can_unwrap $s) (= |call0formal_$_#l_$_0| ($ptr ^A |P#_this_|))) (and ($spans_the_same $s $s_$_0 |call0formal_$_#l_$_0| ($typ |call0formal_$_#l_$_0|)) (= $s_$_2 $s_$_0)))) (! (or %lbl%@5046  (=> $is_unwrap_check ($set_eq ($owns $s_$_2 ($ptr ^A |P#_this_|)) $set_empty))) :lblneg @5046))))))
(let ((anon0_correct  (=> (! (and %lbl%+3845 true) :lblpos +3845) (=> (and (and (and (forall ((|#t_$5| T@$ctype) (|#b| Int) ) (! (= ($typ ($ptr |#t_$5| |#b|)) |#t_$5|)
 :qid |LockFree.367:18|
 :weight 0
 :skolemid |0|
)) true) (and (forall ((|#p_$34| T@$ptr) (|#s1_$12| T@$state) (|#s2_$10| T@$state) ) (!  (and (=> ($state_spans_the_same |#s1_$12| |#s2_$10| |#p_$34| ^A) (and (= ($select.mem ($memory |#s1_$12|) ($dot |#p_$34| A.$owns)) ($select.mem ($memory |#s2_$10|) ($dot |#p_$34| A.$owns))) (= ($select.mem ($memory |#s1_$12|) ($dot |#p_$34| A.x)) ($select.mem ($memory |#s2_$10|) ($dot |#p_$34| A.x))))) (=> (and (= ($select.mem ($memory |#s1_$12|) ($dot |#p_$34| A.$owns)) ($select.mem ($memory |#s2_$10|) ($dot |#p_$34| A.$owns))) (= ($select.mem ($memory |#s1_$12|) ($dot |#p_$34| A.x)) ($select.mem ($memory |#s2_$10|) ($dot |#p_$34| A.x)))) ($state_spans_the_same |#s1_$12| |#s2_$10| |#p_$34| ^A)))
 :qid |LockFree.369:18|
 :skolemid |2|
 :pattern ( ($state_spans_the_same |#s1_$12| |#s2_$10| |#p_$34| ^A))
)) (forall ((|#s1_$8| T@$state) (|#s2_$5| T@$state) (|#p_$27| T@$ptr) (|#t_$11| T@$ctype) ) (!  (and (=> ($spans_the_same |#s1_$8| |#s2_$5| |#p_$27| |#t_$11|) (and (and (and (= ($read_version |#s1_$8| |#p_$27|) ($read_version |#s2_$5| |#p_$27|)) (= ($owns |#s1_$8| |#p_$27|) ($owns |#s2_$5| |#p_$27|))) (= ($select.tm ($typemap |#s1_$8|) |#p_$27|) ($select.tm ($typemap |#s2_$5|) |#p_$27|))) ($state_spans_the_same |#s1_$8| |#s2_$5| |#p_$27| |#t_$11|))) (=> (and (and (and (= ($read_version |#s1_$8| |#p_$27|) ($read_version |#s2_$5| |#p_$27|)) (= ($owns |#s1_$8| |#p_$27|) ($owns |#s2_$5| |#p_$27|))) (= ($select.tm ($typemap |#s1_$8|) |#p_$27|) ($select.tm ($typemap |#s2_$5|) |#p_$27|))) ($state_spans_the_same |#s1_$8| |#s2_$5| |#p_$27| |#t_$11|)) ($spans_the_same |#s1_$8| |#s2_$5| |#p_$27| |#t_$11|)))
 :qid |LockFree.370:18|
 :weight 0
 :skolemid |3|
 :pattern ( ($spans_the_same |#s1_$8| |#s2_$5| |#p_$27| |#t_$11|))
)))) (and (and (= $null ($ptr ^^void 0)) ($good_state ($vs_state $struct_zero))) (and ($has_volatile_owns_set ^^claim) $position_marker))) (=> (and (and (and (and (and (= ($ptr_level $memory_allocator_type) 0) (= ($set_cardinality $set_empty) 0)) (and (= $no_claim ($ptr ^^claim 0)) ($is_claimable ^^claim))) (and (and (=> $seclbl.top true) (=> true $seclbl.top)) (and (=> $seclbl.bot false) (=> false $seclbl.bot)))) (and (and (and (= ($int_to_map_t..ptr_to..^^void.^^bool 0) $zero.$map_t..$ptr_to..^^void.^^bool) ($function_arg_type |cf#classifier#default| 0 ($map_t ($ptr_to ^^void) ^^bool))) (and (= $arch_ptr_size 8) (= $arch_spec_ptr_start $max.u8))) (and (and ($is_math_type |^$#thread_id|) ($is_composite ^A)) (and (= ($ptr_level ^A) 0) (= ($sizeof ^A) 4))))) (and (and (and (and (=> ($is_claimable ^A) false) (=> false ($is_claimable ^A))) (and (=> ($has_volatile_owns_set ^A) false) (=> false ($has_volatile_owns_set ^A)))) (and (and ($is_base_field A.$owns) (= ($field_parent_type A.$owns) ^A)) (and ($is_primitive_non_volatile_field A.$owns) (= ($owns_set_field ^A) A.$owns)))) (and (and (and ($is_base_field A.x) (= ($field_parent_type A.x) ^A)) ($is_primitive_volatile_field A.x)) (and (and (= |#distTp3| ($ptr_to ^^i4)) (= |#distTp2| ($spec_ptr_to ^^claim))) (and (= |#distTp1| ($ptr_to ^A)) ($file_name_is 1 |#file^C?3A?5Cdev?5Cfelt?5Cvcc?5CTest?5Ctestsuite?5Cexamples?5CLockFreeIncr.c|)))))) L3_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+4443 true) :lblpos +4443) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
